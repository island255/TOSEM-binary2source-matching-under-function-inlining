{
  "sharutils/sharutils-4.15.2/intl/bindtextdom.c": {
    "set_binding_values": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "static void\nset_binding_values (const char *domainname,\n\t\t    const char **dirnamep, const char **codesetp)\n{\n  struct binding *binding;\n  int modified;\n\n  /* Some sanity checks.  */\n  if (domainname == NULL || domainname[0] == '\\0')\n    {\n      if (dirnamep)\n\t*dirnamep = NULL;\n      if (codesetp)\n\t*codesetp = NULL;\n      return;\n    }\n\n  gl_rwlock_wrlock (_nl_state_lock);\n\n  modified = 0;\n\n  for (binding = _nl_domain_bindings; binding != NULL; binding = binding->next)\n    {\n      int compare = strcmp (domainname, binding->domainname);\n      if (compare == 0)\n\t/* We found it!  */\n\tbreak;\n      if (compare < 0)\n\t{\n\t  /* It is not in the list.  */\n\t  binding = NULL;\n\t  break;\n\t}\n    }\n\n  if (binding != NULL)\n    {\n      if (dirnamep)\n\t{\n\t  const char *dirname = *dirnamep;\n\n\t  if (dirname == NULL)\n\t    /* The current binding has be to returned.  */\n\t    *dirnamep = binding->dirname;\n\t  else\n\t    {\n\t      /* The domain is already bound.  If the new value and the old\n\t\t one are equal we simply do nothing.  Otherwise replace the\n\t\t old binding.  */\n\t      char *result = binding->dirname;\n\t      if (strcmp (dirname, result) != 0)\n\t\t{\n\t\t  if (strcmp (dirname, _nl_default_dirname) == 0)\n\t\t    result = (char *) _nl_default_dirname;\n\t\t  else\n\t\t    {\n#if defined _LIBC || defined HAVE_STRDUP\n\t\t      result = strdup (dirname);\n#else\n\t\t      size_t len = strlen (dirname) + 1;\n\t\t      result = (char *) malloc (len);\n\t\t      if (__builtin_expect (result != NULL, 1))\n\t\t\tmemcpy (result, dirname, len);\n#endif\n\t\t    }\n\n\t\t  if (__builtin_expect (result != NULL, 1))\n\t\t    {\n\t\t      if (binding->dirname != _nl_default_dirname)\n\t\t\tfree (binding->dirname);\n\n\t\t      binding->dirname = result;\n\t\t      modified = 1;\n\t\t    }\n\t\t}\n\t      *dirnamep = result;\n\t    }\n\t}\n\n      if (codesetp)\n\t{\n\t  const char *codeset = *codesetp;\n\n\t  if (codeset == NULL)\n\t    /* The current binding has be to returned.  */\n\t    *codesetp = binding->codeset;\n\t  else\n\t    {\n\t      /* The domain is already bound.  If the new value and the old\n\t\t one are equal we simply do nothing.  Otherwise replace the\n\t\t old binding.  */\n\t      char *result = binding->codeset;\n\t      if (result == NULL || strcmp (codeset, result) != 0)\n\t\t{\n#if defined _LIBC || defined HAVE_STRDUP\n\t\t  result = strdup (codeset);\n#else\n\t\t  size_t len = strlen (codeset) + 1;\n\t\t  result = (char *) malloc (len);\n\t\t  if (__builtin_expect (result != NULL, 1))\n\t\t    memcpy (result, codeset, len);\n#endif\n\n\t\t  if (__builtin_expect (result != NULL, 1))\n\t\t    {\n\t\t      free (binding->codeset);\n\n\t\t      binding->codeset = result;\n\t\t      modified = 1;\n\t\t    }\n\t\t}\n\t      *codesetp = result;\n\t    }\n\t}\n    }\n  else if ((dirnamep == NULL || *dirnamep == NULL)\n\t   && (codesetp == NULL || *codesetp == NULL))\n    {\n      /* Simply return the default values.  */\n      if (dirnamep)\n\t*dirnamep = _nl_default_dirname;\n      if (codesetp)\n\t*codesetp = NULL;\n    }\n  else\n    {\n      /* We have to create a new binding.  */\n      size_t len = strlen (domainname) + 1;\n      struct binding *new_binding =\n\t(struct binding *) malloc (offsetof (struct binding, domainname) + len);\n\n      if (__builtin_expect (new_binding == NULL, 0))\n\tgoto failed;\n\n      memcpy (new_binding->domainname, domainname, len);\n\n      if (dirnamep)\n\t{\n\t  const char *dirname = *dirnamep;\n\n\t  if (dirname == NULL)\n\t    /* The default value.  */\n\t    dirname = _nl_default_dirname;\n\t  else\n\t    {\n\t      if (strcmp (dirname, _nl_default_dirname) == 0)\n\t\tdirname = _nl_default_dirname;\n\t      else\n\t\t{\n\t\t  char *result;\n#if defined _LIBC || defined HAVE_STRDUP\n\t\t  result = strdup (dirname);\n\t\t  if (__builtin_expect (result == NULL, 0))\n\t\t    goto failed_dirname;\n#else\n\t\t  size_t len = strlen (dirname) + 1;\n\t\t  result = (char *) malloc (len);\n\t\t  if (__builtin_expect (result == NULL, 0))\n\t\t    goto failed_dirname;\n\t\t  memcpy (result, dirname, len);\n#endif\n\t\t  dirname = result;\n\t\t}\n\t    }\n\t  *dirnamep = dirname;\n\t  new_binding->dirname = (char *) dirname;\n\t}\n      else\n\t/* The default value.  */\n\tnew_binding->dirname = (char *) _nl_default_dirname;\n\n      if (codesetp)\n\t{\n\t  const char *codeset = *codesetp;\n\n\t  if (codeset != NULL)\n\t    {\n\t      char *result;\n\n#if defined _LIBC || defined HAVE_STRDUP\n\t      result = strdup (codeset);\n\t      if (__builtin_expect (result == NULL, 0))\n\t\tgoto failed_codeset;\n#else\n\t      size_t len = strlen (codeset) + 1;\n\t      result = (char *) malloc (len);\n\t      if (__builtin_expect (result == NULL, 0))\n\t\tgoto failed_codeset;\n\t      memcpy (result, codeset, len);\n#endif\n\t      codeset = result;\n\t    }\n\t  *codesetp = codeset;\n\t  new_binding->codeset = (char *) codeset;\n\t}\n      else\n\tnew_binding->codeset = NULL;\n\n      /* Now enqueue it.  */\n      if (_nl_domain_bindings == NULL\n\t  || strcmp (domainname, _nl_domain_bindings->domainname) < 0)\n\t{\n\t  new_binding->next = _nl_domain_bindings;\n\t  _nl_domain_bindings = new_binding;\n\t}\n      else\n\t{\n\t  binding = _nl_domain_bindings;\n\t  while (binding->next != NULL\n\t\t && strcmp (domainname, binding->next->domainname) > 0)\n\t    binding = binding->next;\n\n\t  new_binding->next = binding->next;\n\t  binding->next = new_binding;\n\t}\n\n      modified = 1;\n\n      /* Here we deal with memory allocation failures.  */\n      if (0)\n\t{\n\tfailed_codeset:\n\t  if (new_binding->dirname != _nl_default_dirname)\n\t    free (new_binding->dirname);\n\tfailed_dirname:\n\t  free (new_binding);\n\tfailed:\n\t  if (dirnamep)\n\t    *dirnamep = NULL;\n\t  if (codesetp)\n\t    *codesetp = NULL;\n\t}\n    }\n\n  /* If we modified any binding, we flush the caches.  */\n  if (modified)\n    ++_nl_msg_cat_cntr;\n\n  gl_rwlock_unlock (_nl_state_lock);\n}",
      "lines": 240,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "BINDTEXTDOMAIN": {
      "start_point": [
        317,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "char *\nBINDTEXTDOMAIN (const char *domainname, const char *dirname)\n{\n  set_binding_values (domainname, &dirname, NULL);\n  return (char *) dirname;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nBINDTEXTDOMAIN (const char *domainname, const char *dirname)",
        "*"
      ]
    },
    "BIND_TEXTDOMAIN_CODESET": {
      "start_point": [
        326,
        0
      ],
      "end_point": [
        331,
        1
      ],
      "content": "char *\nBIND_TEXTDOMAIN_CODESET (const char *domainname, const char *codeset)\n{\n  set_binding_values (domainname, NULL, &codeset);\n  return (char *) codeset;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nBIND_TEXTDOMAIN_CODESET (const char *domainname, const char *codeset)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/dcgettext.c": {
    "DCGETTEXT": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "char *\nDCGETTEXT (const char *domainname, const char *msgid, int category)\n{\n  return DCIGETTEXT (domainname, msgid, NULL, 0, 0, category);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nDCGETTEXT (const char *domainname, const char *msgid, int category)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/dcigettext.c": {
    "transcmp": {
      "start_point": [
        277,
        0
      ],
      "end_point": [
        312,
        1
      ],
      "content": "static int\ntranscmp (const void *p1, const void *p2)\n{\n  const struct known_translation_t *s1;\n  const struct known_translation_t *s2;\n  int result;\n\n  s1 = (const struct known_translation_t *) p1;\n  s2 = (const struct known_translation_t *) p2;\n\n  result = strcmp (s1->domain != NULL ? s1->msgid.appended : s1->msgid.ptr,\n\t\t   s2->domain != NULL ? s2->msgid.appended : s2->msgid.ptr);\n  if (result == 0)\n    {\n      result = strcmp (s1->domainname, s2->domainname);\n      if (result == 0)\n\t{\n#ifdef HAVE_PER_THREAD_LOCALE\n\t  result = strcmp (s1->localename, s2->localename);\n\t  if (result == 0)\n#endif\n\t    {\n#ifdef IN_LIBGLOCALE\n\t      result = strcmp (s1->encoding, s2->encoding);\n\t      if (result == 0)\n#endif\n\t\t/* We compare the category last (though this is the cheapest\n\t\t   operation) since it is hopefully always the same (namely\n\t\t   LC_MESSAGES).  */\n\t\tresult = s1->category - s2->category;\n\t    }\n\t}\n    }\n\n  return result;\n}",
      "lines": 36,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "plural_lookup": {
      "start_point": [
        1415,
        0
      ],
      "end_point": [
        1449,
        1
      ],
      "content": "static char *\ninternal_function\nplural_lookup (struct loaded_l10nfile *domain, unsigned long int n,\n\t       const char *translation, size_t translation_len)\n{\n  struct loaded_domain *domaindata = (struct loaded_domain *) domain->data;\n  unsigned long int index;\n  const char *p;\n\n  index = plural_eval (domaindata->plural, n);\n  if (index >= domaindata->nplurals)\n    /* This should never happen.  It means the plural expression and the\n       given maximum value do not match.  */\n    index = 0;\n\n  /* Skip INDEX strings at TRANSLATION.  */\n  p = translation;\n  while (index-- > 0)\n    {\n#ifdef _LIBC\n      p = __rawmemchr (p, '\\0');\n#else\n      p = strchr (p, '\\0');\n#endif\n      /* And skip over the NUL byte.  */\n      p++;\n\n      if (p >= translation + translation_len)\n\t/* This should never happen.  It means the plural expression\n\t   evaluated to a value larger than the number of variants\n\t   available for MSGID1.  */\n\treturn (char *) translation;\n    }\n  return (char *) p;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ninternal_function\nplural_lookup (struct loaded_l10nfile *domain, unsigned long int n,\n\t       const char *translation, size_t translation_len)",
        "*",
        "internal_function",
        "internal_function"
      ]
    },
    "category_to_name": {
      "start_point": [
        1453,
        0
      ],
      "end_point": [
        1509,
        1
      ],
      "content": "static const char *\ninternal_function\ncategory_to_name (int category)\n{\n  const char *retval;\n\n  switch (category)\n  {\n#ifdef LC_COLLATE\n  case LC_COLLATE:\n    retval = \"LC_COLLATE\";\n    break;\n#endif\n#ifdef LC_CTYPE\n  case LC_CTYPE:\n    retval = \"LC_CTYPE\";\n    break;\n#endif\n#ifdef LC_MONETARY\n  case LC_MONETARY:\n    retval = \"LC_MONETARY\";\n    break;\n#endif\n#ifdef LC_NUMERIC\n  case LC_NUMERIC:\n    retval = \"LC_NUMERIC\";\n    break;\n#endif\n#ifdef LC_TIME\n  case LC_TIME:\n    retval = \"LC_TIME\";\n    break;\n#endif\n#ifdef LC_MESSAGES\n  case LC_MESSAGES:\n    retval = \"LC_MESSAGES\";\n    break;\n#endif\n#ifdef LC_RESPONSE\n  case LC_RESPONSE:\n    retval = \"LC_RESPONSE\";\n    break;\n#endif\n#ifdef LC_ALL\n  case LC_ALL:\n    /* This might not make sense but is perhaps better than any other\n       value.  */\n    retval = \"LC_ALL\";\n    break;\n#endif\n  default:\n    /* If you have a better idea for a default value let me know.  */\n    retval = \"LC_XXX\";\n  }\n\n  return retval;\n}",
      "lines": 57,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ninternal_function\ncategory_to_name (int category)",
        "*",
        "internal_function",
        "internal_function"
      ]
    },
    "guess_category_value": {
      "start_point": [
        1518,
        14
      ],
      "end_point": [
        1601,
        1
      ],
      "content": "char *locale)\n\n#else\nguess_category_value (int category, const char *categoryname)\n#endif\n{\n  const char *language;\n#ifndef IN_LIBGLOCALE\n  const char *locale;\n# ifndef _LIBC\n  const char *language_default;\n  int locale_defaulted;\n# endif\n#endif\n\n  /* We use the settings in the following order:\n     1. The value of the environment variable 'LANGUAGE'.  This is a GNU\n        extension.  Its value can be a colon-separated list of locale names.\n     2. The value of the environment variable 'LC_ALL', 'LC_xxx', or 'LANG'.\n        More precisely, the first among these that is set to a non-empty value.\n        This is how POSIX specifies it.  The value is a single locale name.\n     3. A system-dependent preference list of languages.  Its value can be a\n        colon-separated list of locale names.\n     4. A system-dependent default locale name.\n     This way:\n       - System-dependent settings can be overridden by environment variables.\n       - If the system provides both a list of languages and a default locale,\n         the former is used.  */\n\n#ifndef IN_LIBGLOCALE\n  /* Fetch the locale name, through the POSIX method of looking to `LC_ALL',\n     `LC_xxx', and `LANG'.  On some systems this can be done by the\n     `setlocale' function itself.  */\n# ifdef _LIBC\n  locale = __current_locale_name (category);\n# else\n  locale_defaulted = 0;\n#  if HAVE_USELOCALE\n  locale = _nl_locale_name_thread_unsafe (category, categoryname);\n  if (locale == NULL)\n#  endif\n    {\n      locale = _nl_locale_name_posix (category, categoryname);\n      if (locale == NULL)\n\t{\n\t  locale = _nl_locale_name_default ();\n\t  locale_defaulted = 1;\n\t}\n    }\n# endif\n#endif\n\n  /* Ignore LANGUAGE and its system-dependent analogon if the locale is set\n     to \"C\" because\n     1. \"C\" locale usually uses the ASCII encoding, and most international\n\tmessages use non-ASCII characters. These characters get displayed\n\tas question marks (if using glibc's iconv()) or as invalid 8-bit\n\tcharacters (because other iconv()s refuse to convert most non-ASCII\n\tcharacters to ASCII). In any case, the output is ugly.\n     2. The precise output of some programs in the \"C\" locale is specified\n\tby POSIX and should not depend on environment variables like\n\t\"LANGUAGE\" or system-dependent information.  We allow such programs\n        to use gettext().  */\n  if (strcmp (locale, \"C\") == 0)\n    return locale;\n\n  /* The highest priority value is the value of the 'LANGUAGE' environment\n     variable.  */\n  language = getenv (\"LANGUAGE\");\n  if (language != NULL && language[0] != '\\0')\n    return language;\n#if !defined IN_LIBGLOCALE && !defined _LIBC\n  /* The next priority value is the locale name, if not defaulted.  */\n  if (locale_defaulted)\n    {\n      /* The next priority value is the default language preferences list. */\n      language_default = _nl_language_preferences_default ();\n      if (language_default != NULL)\n        return language_default;\n    }\n  /* The least priority value is the locale name, if defaulted.  */\n#endif\n  return locale;\n}",
      "lines": 84,
      "depth": 13,
      "decorators": [
        "char",
        "*locale)\n\n#else",
        "*locale",
        "*",
        "locale",
        ")",
        "#else"
      ]
    },
    "get_output_charset": {
      "start_point": [
        1605,
        0
      ],
      "end_point": [
        1653,
        1
      ],
      "content": "static const char *\ninternal_function\nget_output_charset (struct binding *domainbinding)\n{\n  /* The output charset should normally be determined by the locale.  But\n     sometimes the locale is not used or not correctly set up, so we provide\n     a possibility for the user to override this: the OUTPUT_CHARSET\n     environment variable.  Moreover, the value specified through\n     bind_textdomain_codeset overrides both.  */\n  if (domainbinding != NULL && domainbinding->codeset != NULL)\n    return domainbinding->codeset;\n  else\n    {\n      /* For speed reasons, we look at the value of OUTPUT_CHARSET only\n\t once.  This is a user variable that is not supposed to change\n\t during a program run.  */\n      static char *output_charset_cache;\n      static int output_charset_cached;\n\n      if (!output_charset_cached)\n\t{\n\t  const char *value = getenv (\"OUTPUT_CHARSET\");\n\n\t  if (value != NULL && value[0] != '\\0')\n\t    {\n\t      size_t len = strlen (value) + 1;\n\t      char *value_copy = (char *) malloc (len);\n\n\t      if (value_copy != NULL)\n\t\tmemcpy (value_copy, value, len);\n\t      output_charset_cache = value_copy;\n\t    }\n\t  output_charset_cached = 1;\n\t}\n\n      if (output_charset_cache != NULL)\n\treturn output_charset_cache;\n      else\n\t{\n# ifdef _LIBC\n\t  return _NL_CURRENT (LC_CTYPE, CODESET);\n# else\n#  if HAVE_ICONV\n\t  return locale_charset ();\n#  endif\n# endif\n\t}\n    }\n}",
      "lines": 49,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ninternal_function\nget_output_charset (struct binding *domainbinding)",
        "*",
        "internal_function",
        "internal_function"
      ]
    },
    "stpcpy": {
      "start_point": [
        1663,
        0
      ],
      "end_point": [
        1669,
        1
      ],
      "content": "static char *\nstpcpy (char *dest, const char *src)\n{\n  while ((*dest++ = *src++) != '\\0')\n    /* Do nothing. */ ;\n  return dest - 1;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nstpcpy (char *dest, const char *src)",
        "*"
      ]
    },
    "mempcpy": {
      "start_point": [
        1673,
        0
      ],
      "end_point": [
        1677,
        1
      ],
      "content": "static void *\nmempcpy (void *dest, const void *src, size_t n)\n{\n  return (void *) ((char *) memcpy (dest, src, n) + n);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nmempcpy (void *dest, const void *src, size_t n)",
        "*"
      ]
    },
    "free_mem": {
      "start_point": [
        1688,
        0
      ],
      "end_point": [
        1717,
        1
      ],
      "content": "libc_freeres_fn (free_mem)\n{\n  void *old;\n\n  while (_nl_domain_bindings != NULL)\n    {\n      struct binding *oldp = _nl_domain_bindings;\n      _nl_domain_bindings = _nl_domain_bindings->next;\n      if (oldp->dirname != _nl_default_dirname)\n\t/* Yes, this is a pointer comparison.  */\n\tfree (oldp->dirname);\n      free (oldp->codeset);\n      free (oldp);\n    }\n\n  if (_nl_current_default_domain != _nl_default_default_domain)\n    /* Yes, again a pointer comparison.  */\n    free ((char *) _nl_current_default_domain);\n\n  /* Remove the search tree with the known translations.  */\n  __tdestroy (root, free);\n  root = NULL;\n\n  while (transmem_list != NULL)\n    {\n      old = transmem_list;\n      transmem_list = transmem_list->next;\n      free (old);\n    }\n}",
      "lines": 30,
      "depth": 10,
      "decorators": null
    }
  },
  "sharutils/sharutils-4.15.2/intl/dcngettext.c": {
    "DCNGETTEXT": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "char *\nDCNGETTEXT (const char *domainname,\n\t    const char *msgid1, const char *msgid2, unsigned long int n,\n\t    int category)\n{\n  return DCIGETTEXT (domainname, msgid1, msgid2, 1, n, category);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nDCNGETTEXT (const char *domainname,\n\t    const char *msgid1, const char *msgid2, unsigned long int n,\n\t    int category)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/dgettext.c": {
    "DGETTEXT": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "char *\nDGETTEXT (const char *domainname, const char *msgid)\n{\n  return DCGETTEXT (domainname, msgid, LC_MESSAGES);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nDGETTEXT (const char *domainname, const char *msgid)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/dngettext.c": {
    "DNGETTEXT": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "char *\nDNGETTEXT (const char *domainname,\n\t   const char *msgid1, const char *msgid2, unsigned long int n)\n{\n  return DCNGETTEXT (domainname, msgid1, msgid2, n, LC_MESSAGES);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nDNGETTEXT (const char *domainname,\n\t   const char *msgid1, const char *msgid2, unsigned long int n)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/eval-plural.h": {
    "plural_eval": {
      "start_point": [
        22,
        9
      ],
      "end_point": [
        105,
        1
      ],
      "content": "long int\ninternal_function\nplural_eval (const struct expression *pexp, unsigned long int n)\n{\n  switch (pexp->nargs)\n    {\n    case 0:\n      switch (pexp->operation)\n\t{\n\tcase var:\n\t  return n;\n\tcase num:\n\t  return pexp->val.num;\n\tdefault:\n\t  break;\n\t}\n      /* NOTREACHED */\n      break;\n    case 1:\n      {\n\t/* pexp->operation must be lnot.  */\n\tunsigned long int arg = plural_eval (pexp->val.args[0], n);\n\treturn ! arg;\n      }\n    case 2:\n      {\n\tunsigned long int leftarg = plural_eval (pexp->val.args[0], n);\n\tif (pexp->operation == lor)\n\t  return leftarg || plural_eval (pexp->val.args[1], n);\n\telse if (pexp->operation == land)\n\t  return leftarg && plural_eval (pexp->val.args[1], n);\n\telse\n\t  {\n\t    unsigned long int rightarg = plural_eval (pexp->val.args[1], n);\n\n\t    switch (pexp->operation)\n\t      {\n\t      case mult:\n\t\treturn leftarg * rightarg;\n\t      case divide:\n#if !INTDIV0_RAISES_SIGFPE\n\t\tif (rightarg == 0)\n\t\t  raise (SIGFPE);\n#endif\n\t\treturn leftarg / rightarg;\n\t      case module:\n#if !INTDIV0_RAISES_SIGFPE\n\t\tif (rightarg == 0)\n\t\t  raise (SIGFPE);\n#endif\n\t\treturn leftarg % rightarg;\n\t      case plus:\n\t\treturn leftarg + rightarg;\n\t      case minus:\n\t\treturn leftarg - rightarg;\n\t      case less_than:\n\t\treturn leftarg < rightarg;\n\t      case greater_than:\n\t\treturn leftarg > rightarg;\n\t      case less_or_equal:\n\t\treturn leftarg <= rightarg;\n\t      case greater_or_equal:\n\t\treturn leftarg >= rightarg;\n\t      case equal:\n\t\treturn leftarg == rightarg;\n\t      case not_equal:\n\t\treturn leftarg != rightarg;\n\t      default:\n\t\tbreak;\n\t      }\n\t  }\n\t/* NOTREACHED */\n\tbreak;\n      }\n    case 3:\n      {\n\t/* pexp->operation must be qmop.  */\n\tunsigned long int boolarg = plural_eval (pexp->val.args[0], n);\n\treturn plural_eval (pexp->val.args[boolarg ? 1 : 2], n);\n      }\n    }\n  /* NOTREACHED */\n  return 0;\n}",
      "lines": 84,
      "depth": 17,
      "decorators": [
        "long int",
        "long",
        "int",
        "internal_function",
        "internal_function"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/explodename.c": {
    "_nl_find_language": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "static char *\n_nl_find_language (const char *name)\n{\n  while (name[0] != '\\0' && name[0] != '_' && name[0] != '@' && name[0] != '.')\n    ++name;\n\n  return (char *) name;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\n_nl_find_language (const char *name)",
        "*"
      ]
    },
    "_nl_explode_name": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "int\n_nl_explode_name (char *name,\n\t\t  const char **language, const char **modifier,\n\t\t  const char **territory, const char **codeset,\n\t\t  const char **normalized_codeset)\n{\n  char *cp;\n  int mask;\n\n  *modifier = NULL;\n  *territory = NULL;\n  *codeset = NULL;\n  *normalized_codeset = NULL;\n\n  /* Now we determine the single parts of the locale name.  First\n     look for the language.  Termination symbols are `_', '.', and `@'.  */\n  mask = 0;\n  *language = cp = name;\n  cp = _nl_find_language (*language);\n\n  if (*language == cp)\n    /* This does not make sense: language has to be specified.  Use\n       this entry as it is without exploding.  Perhaps it is an alias.  */\n    cp = strchr (*language, '\\0');\n  else\n    {\n      if (cp[0] == '_')\n\t{\n\t  /* Next is the territory.  */\n\t  cp[0] = '\\0';\n\t  *territory = ++cp;\n\n\t  while (cp[0] != '\\0' && cp[0] != '.' && cp[0] != '@')\n\t    ++cp;\n\n\t  mask |= XPG_TERRITORY;\n\t}\n\n      if (cp[0] == '.')\n\t{\n\t  /* Next is the codeset.  */\n\t  cp[0] = '\\0';\n\t  *codeset = ++cp;\n\n\t  while (cp[0] != '\\0' && cp[0] != '@')\n\t    ++cp;\n\n\t  mask |= XPG_CODESET;\n\n\t  if (*codeset != cp && (*codeset)[0] != '\\0')\n\t    {\n\t      *normalized_codeset = _nl_normalize_codeset (*codeset,\n\t\t\t\t\t\t\t   cp - *codeset);\n\t      if (*normalized_codeset == NULL)\n\t\treturn -1;\n\t      else if (strcmp (*codeset, *normalized_codeset) == 0)\n\t\tfree ((char *) *normalized_codeset);\n\t      else\n\t\tmask |= XPG_NORM_CODESET;\n\t    }\n\t}\n    }\n\n  if (cp[0] == '@')\n    {\n      /* Next is the modifier.  */\n      cp[0] = '\\0';\n      *modifier = ++cp;\n\n      if (cp[0] != '\\0')\n\tmask |= XPG_MODIFIER;\n    }\n\n  if (*territory != NULL && (*territory)[0] == '\\0')\n    mask &= ~XPG_TERRITORY;\n\n  if (*codeset != NULL && (*codeset)[0] == '\\0')\n    mask &= ~XPG_CODESET;\n\n  return mask;\n}",
      "lines": 81,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/export.h": {},
  "sharutils/sharutils-4.15.2/intl/finddomain.c": {
    "_nl_find_domain": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "struct loaded_l10nfile *\ninternal_function\n_nl_find_domain (const char *dirname, char *locale,\n\t\t const char *domainname, struct binding *domainbinding)\n{\n  struct loaded_l10nfile *retval;\n  const char *language;\n  const char *modifier;\n  const char *territory;\n  const char *codeset;\n  const char *normalized_codeset;\n  const char *alias_value;\n  int mask;\n\n  /* LOCALE can consist of up to four recognized parts for the XPG syntax:\n\n\t\tlanguage[_territory][.codeset][@modifier]\n\n     Beside the first part all of them are allowed to be missing.  If\n     the full specified locale is not found, the less specific one are\n     looked for.  The various parts will be stripped off according to\n     the following order:\n\t\t(1) codeset\n\t\t(2) normalized codeset\n\t\t(3) territory\n\t\t(4) modifier\n   */\n\n  /* We need to protect modifying the _NL_LOADED_DOMAINS data.  */\n  gl_rwlock_define_initialized (static, lock);\n  gl_rwlock_rdlock (lock);\n\n  /* If we have already tested for this locale entry there has to\n     be one data set in the list of loaded domains.  */\n  retval = _nl_make_l10nflist (&_nl_loaded_domains, dirname,\n\t\t\t       strlen (dirname) + 1, 0, locale, NULL, NULL,\n\t\t\t       NULL, NULL, domainname, 0);\n\n  gl_rwlock_unlock (lock);\n\n  if (retval != NULL)\n    {\n      /* We know something about this locale.  */\n      int cnt;\n\n      if (retval->decided <= 0)\n\t_nl_load_domain (retval, domainbinding);\n\n      if (retval->data != NULL)\n\treturn retval;\n\n      for (cnt = 0; retval->successor[cnt] != NULL; ++cnt)\n\t{\n\t  if (retval->successor[cnt]->decided <= 0)\n\t    _nl_load_domain (retval->successor[cnt], domainbinding);\n\n\t  if (retval->successor[cnt]->data != NULL)\n\t    break;\n\t}\n\n      return retval;\n      /* NOTREACHED */\n    }\n\n  /* See whether the locale value is an alias.  If yes its value\n     *overwrites* the alias name.  No test for the original value is\n     done.  */\n  alias_value = _nl_expand_alias (locale);\n  if (alias_value != NULL)\n    {\n#if defined _LIBC || defined HAVE_STRDUP\n      locale = strdup (alias_value);\n      if (locale == NULL)\n\treturn NULL;\n#else\n      size_t len = strlen (alias_value) + 1;\n      locale = (char *) malloc (len);\n      if (locale == NULL)\n\treturn NULL;\n\n      memcpy (locale, alias_value, len);\n#endif\n    }\n\n  /* Now we determine the single parts of the locale name.  First\n     look for the language.  Termination symbols are `_', '.', and `@'.  */\n  mask = _nl_explode_name (locale, &language, &modifier, &territory,\n\t\t\t   &codeset, &normalized_codeset);\n  if (mask == -1)\n    /* This means we are out of core.  */\n    return NULL;\n\n  /* We need to protect modifying the _NL_LOADED_DOMAINS data.  */\n  gl_rwlock_wrlock (lock);\n\n  /* Create all possible locale entries which might be interested in\n     generalization.  */\n  retval = _nl_make_l10nflist (&_nl_loaded_domains, dirname,\n\t\t\t       strlen (dirname) + 1, mask, language, territory,\n\t\t\t       codeset, normalized_codeset, modifier,\n\t\t\t       domainname, 1);\n\n  gl_rwlock_unlock (lock);\n\n  if (retval == NULL)\n    /* This means we are out of core.  */\n    goto out;\n\n  if (retval->decided <= 0)\n    _nl_load_domain (retval, domainbinding);\n  if (retval->data == NULL)\n    {\n      int cnt;\n      for (cnt = 0; retval->successor[cnt] != NULL; ++cnt)\n\t{\n\t  if (retval->successor[cnt]->decided <= 0)\n\t    _nl_load_domain (retval->successor[cnt], domainbinding);\n\t  if (retval->successor[cnt]->data != NULL)\n\t    break;\n\t}\n    }\n\n  /* The room for an alias was dynamically allocated.  Free it now.  */\n  if (alias_value != NULL)\n    free (locale);\n\nout:\n  /* The space for normalized_codeset is dynamically allocated.  Free it.  */\n  if (mask & XPG_NORM_CODESET)\n    free ((void *) normalized_codeset);\n\n  return retval;\n}",
      "lines": 133,
      "depth": 13,
      "decorators": [
        "struct loaded_l10nfile",
        "struct",
        "loaded_l10nfile",
        "*\ninternal_function\n_nl_find_domain (const char *dirname, char *locale,\n\t\t const char *domainname, struct binding *domainbinding)",
        "*",
        "internal_function",
        "internal_function"
      ]
    },
    "_nl_finddomain_subfreeres": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        208,
        1
      ],
      "content": "void __libc_freeres_fn_section\n_nl_finddomain_subfreeres ()\n{\n  struct loaded_l10nfile *runp = _nl_loaded_domains;\n\n  while (runp != NULL)\n    {\n      struct loaded_l10nfile *here = runp;\n      if (runp->data != NULL)\n\t_nl_unload_domain ((struct loaded_domain *) runp->data);\n      runp = runp->next;\n      free ((char *) here->filename);\n      free (here);\n    }\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "void",
        "__libc_freeres_fn_section",
        "__libc_freeres_fn_section"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/gettext.c": {
    "GETTEXT": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "char *\nGETTEXT (const char *msgid)\n{\n  return DCGETTEXT (NULL, msgid, LC_MESSAGES);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nGETTEXT (const char *msgid)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/gettextP.h": {},
  "sharutils/sharutils-4.15.2/intl/gmo.h": {},
  "sharutils/sharutils-4.15.2/intl/hash-string.c": {
    "__hash_string": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "unsigned long int\n__hash_string (const char *str_param)\n{\n  unsigned long int hval, g;\n  const char *str = str_param;\n\n  /* Compute the hash value for the given string.  */\n  hval = 0;\n  while (*str != '\\0')\n    {\n      hval <<= 4;\n      hval += (unsigned char) *str++;\n      g = hval & ((unsigned long int) 0xf << (HASHWORDBITS - 4));\n      if (g != 0)\n\t{\n\t  hval ^= g >> (HASHWORDBITS - 8);\n\t  hval ^= g;\n\t}\n    }\n  return hval;\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "unsigned long int",
        "unsigned",
        "long",
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/hash-string.h": {},
  "sharutils/sharutils-4.15.2/intl/intl-compat.c": {
    "gettext": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "DLL_EXPORTED\nchar *\ngettext (const char *msgid)\n{\n  return libintl_gettext (msgid);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "char",
        "char",
        "*\ngettext (const char *msgid)",
        "*"
      ]
    },
    "dgettext": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "DLL_EXPORTED\nchar *\ndgettext (const char *domainname, const char *msgid)\n{\n  return libintl_dgettext (domainname, msgid);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "char",
        "char",
        "*\ndgettext (const char *domainname, const char *msgid)",
        "*"
      ]
    },
    "dcgettext": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "DLL_EXPORTED\nchar *\ndcgettext (const char *domainname, const char *msgid, int category)\n{\n  return libintl_dcgettext (domainname, msgid, category);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "char",
        "char",
        "*\ndcgettext (const char *domainname, const char *msgid, int category)",
        "*"
      ]
    },
    "ngettext": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "DLL_EXPORTED\nchar *\nngettext (const char *msgid1, const char *msgid2, unsigned long int n)\n{\n  return libintl_ngettext (msgid1, msgid2, n);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "char",
        "char",
        "*\nngettext (const char *msgid1, const char *msgid2, unsigned long int n)",
        "*"
      ]
    },
    "dngettext": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "DLL_EXPORTED\nchar *\ndngettext (const char *domainname,\n           const char *msgid1, const char *msgid2, unsigned long int n)\n{\n  return libintl_dngettext (domainname, msgid1, msgid2, n);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "char",
        "char",
        "*\ndngettext (const char *domainname,\n           const char *msgid1, const char *msgid2, unsigned long int n)",
        "*"
      ]
    },
    "dcngettext": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "DLL_EXPORTED\nchar *\ndcngettext (const char *domainname,\n            const char *msgid1, const char *msgid2, unsigned long int n,\n            int category)\n{\n  return libintl_dcngettext (domainname, msgid1, msgid2, n, category);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "char",
        "char",
        "*\ndcngettext (const char *domainname,\n            const char *msgid1, const char *msgid2, unsigned long int n,\n            int category)",
        "*"
      ]
    },
    "textdomain": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "DLL_EXPORTED\nchar *\ntextdomain (const char *domainname)\n{\n  return libintl_textdomain (domainname);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "char",
        "char",
        "*\ntextdomain (const char *domainname)",
        "*"
      ]
    },
    "bindtextdomain": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "DLL_EXPORTED\nchar *\nbindtextdomain (const char *domainname, const char *dirname)\n{\n  return libintl_bindtextdomain (domainname, dirname);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "char",
        "char",
        "*\nbindtextdomain (const char *domainname, const char *dirname)",
        "*"
      ]
    },
    "bind_textdomain_codeset": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "DLL_EXPORTED\nchar *\nbind_textdomain_codeset (const char *domainname, const char *codeset)\n{\n  return libintl_bind_textdomain_codeset (domainname, codeset);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "char",
        "char",
        "*\nbind_textdomain_codeset (const char *domainname, const char *codeset)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/intl-exports.c": {},
  "sharutils/sharutils-4.15.2/intl/l10nflist.c": {
    "argz_count__": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "static size_t\nargz_count__ (const char *argz, size_t len)\n{\n  size_t count = 0;\n  while (len > 0)\n    {\n      size_t part_len = strlen (argz);\n      argz += part_len + 1;\n      len -= part_len + 1;\n      count++;\n    }\n  return count;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "argz_stringify__": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "static void\nargz_stringify__ (char *argz, size_t len, int sep)\n{\n  while (len > 0)\n    {\n      size_t part_len = strlen (argz);\n      argz += part_len;\n      len -= part_len + 1;\n      if (len > 0)\n\t*argz++ = sep;\n    }\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "argz_next__": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "static char *\nargz_next__ (char *argz, size_t argz_len, const char *entry)\n{\n  if (entry)\n    {\n      if (entry < argz + argz_len)\n        entry = strchr (entry, '\\0') + 1;\n\n      return entry >= argz + argz_len ? NULL : (char *) entry;\n    }\n  else\n    if (argz_len > 0)\n      return argz;\n    else\n      return 0;\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nargz_next__ (char *argz, size_t argz_len, const char *entry)",
        "*"
      ]
    },
    "pop": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "static inline int\npop (int x)\n{\n  /* We assume that no more than 16 bits are used.  */\n  x = ((x & ~0x5555) >> 1) + (x & 0x5555);\n  x = ((x & ~0x3333) >> 2) + (x & 0x3333);\n  x = ((x >> 4) + x) & 0x0f0f;\n  x = ((x >> 8) + x) & 0xff;\n\n  return x;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "_nl_make_l10nflist": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        337,
        1
      ],
      "content": "struct loaded_l10nfile *\n_nl_make_l10nflist (struct loaded_l10nfile **l10nfile_list,\n\t\t    const char *dirlist, size_t dirlist_len,\n\t\t    int mask, const char *language, const char *territory,\n\t\t    const char *codeset, const char *normalized_codeset,\n\t\t    const char *modifier,\n\t\t    const char *filename, int do_allocate)\n{\n  char *abs_filename;\n  struct loaded_l10nfile **lastp;\n  struct loaded_l10nfile *retval;\n  char *cp;\n  size_t dirlist_count;\n  size_t entries;\n  int cnt;\n\n  /* If LANGUAGE contains an absolute directory specification, we ignore\n     DIRLIST.  */\n  if (IS_ABSOLUTE_PATH (language))\n    dirlist_len = 0;\n\n  /* Allocate room for the full file name.  */\n  abs_filename = (char *) malloc (dirlist_len\n\t\t\t\t  + strlen (language)\n\t\t\t\t  + ((mask & XPG_TERRITORY) != 0\n\t\t\t\t     ? strlen (territory) + 1 : 0)\n\t\t\t\t  + ((mask & XPG_CODESET) != 0\n\t\t\t\t     ? strlen (codeset) + 1 : 0)\n\t\t\t\t  + ((mask & XPG_NORM_CODESET) != 0\n\t\t\t\t     ? strlen (normalized_codeset) + 1 : 0)\n\t\t\t\t  + ((mask & XPG_MODIFIER) != 0\n\t\t\t\t     ? strlen (modifier) + 1 : 0)\n\t\t\t\t  + 1 + strlen (filename) + 1);\n\n  if (abs_filename == NULL)\n    return NULL;\n\n  /* Construct file name.  */\n  cp = abs_filename;\n  if (dirlist_len > 0)\n    {\n      memcpy (cp, dirlist, dirlist_len);\n      __argz_stringify (cp, dirlist_len, PATH_SEPARATOR);\n      cp += dirlist_len;\n      cp[-1] = '/';\n    }\n\n  cp = stpcpy (cp, language);\n\n  if ((mask & XPG_TERRITORY) != 0)\n    {\n      *cp++ = '_';\n      cp = stpcpy (cp, territory);\n    }\n  if ((mask & XPG_CODESET) != 0)\n    {\n      *cp++ = '.';\n      cp = stpcpy (cp, codeset);\n    }\n  if ((mask & XPG_NORM_CODESET) != 0)\n    {\n      *cp++ = '.';\n      cp = stpcpy (cp, normalized_codeset);\n    }\n  if ((mask & XPG_MODIFIER) != 0)\n    {\n      *cp++ = '@';\n      cp = stpcpy (cp, modifier);\n    }\n\n  *cp++ = '/';\n  stpcpy (cp, filename);\n\n  /* Look in list of already loaded domains whether it is already\n     available.  */\n  lastp = l10nfile_list;\n  for (retval = *l10nfile_list; retval != NULL; retval = retval->next)\n    if (retval->filename != NULL)\n      {\n\tint compare = strcmp (retval->filename, abs_filename);\n\tif (compare == 0)\n\t  /* We found it!  */\n\t  break;\n\tif (compare < 0)\n\t  {\n\t    /* It's not in the list.  */\n\t    retval = NULL;\n\t    break;\n\t  }\n\n\tlastp = &retval->next;\n      }\n\n  if (retval != NULL || do_allocate == 0)\n    {\n      free (abs_filename);\n      return retval;\n    }\n\n  dirlist_count = (dirlist_len > 0 ? __argz_count (dirlist, dirlist_len) : 1);\n\n  /* Allocate a new loaded_l10nfile.  */\n  retval =\n    (struct loaded_l10nfile *)\n    malloc (sizeof (*retval)\n\t    + (((dirlist_count << pop (mask)) + (dirlist_count > 1 ? 1 : 0))\n\t       * sizeof (struct loaded_l10nfile *)));\n  if (retval == NULL)\n    {\n      free (abs_filename);\n      return NULL;\n    }\n\n  retval->filename = abs_filename;\n\n  /* We set retval->data to NULL here; it is filled in later.\n     Setting retval->decided to 1 here means that retval does not\n     correspond to a real file (dirlist_count > 1) or is not worth\n     looking up (if an unnormalized codeset was specified).  */\n  retval->decided = (dirlist_count > 1\n\t\t     || ((mask & XPG_CODESET) != 0\n\t\t\t && (mask & XPG_NORM_CODESET) != 0));\n  retval->data = NULL;\n\n  retval->next = *lastp;\n  *lastp = retval;\n\n  entries = 0;\n  /* Recurse to fill the inheritance list of RETVAL.\n     If the DIRLIST is a real list (i.e. DIRLIST_COUNT > 1), the RETVAL\n     entry does not correspond to a real file; retval->filename contains\n     colons.  In this case we loop across all elements of DIRLIST and\n     across all bit patterns dominated by MASK.\n     If the DIRLIST is a single directory or entirely redundant (i.e.\n     DIRLIST_COUNT == 1), we loop across all bit patterns dominated by\n     MASK, excluding MASK itself.\n     In either case, we loop down from MASK to 0.  This has the effect\n     that the extra bits in the locale name are dropped in this order:\n     first the modifier, then the territory, then the codeset, then the\n     normalized_codeset.  */\n  for (cnt = dirlist_count > 1 ? mask : mask - 1; cnt >= 0; --cnt)\n    if ((cnt & ~mask) == 0\n\t&& !((cnt & XPG_CODESET) != 0 && (cnt & XPG_NORM_CODESET) != 0))\n      {\n\tif (dirlist_count > 1)\n\t  {\n\t    /* Iterate over all elements of the DIRLIST.  */\n\t    char *dir = NULL;\n\n\t    while ((dir = __argz_next ((char *) dirlist, dirlist_len, dir))\n\t\t   != NULL)\n\t      retval->successor[entries++]\n\t\t= _nl_make_l10nflist (l10nfile_list, dir, strlen (dir) + 1,\n\t\t\t\t      cnt, language, territory, codeset,\n\t\t\t\t      normalized_codeset, modifier, filename,\n\t\t\t\t      1);\n\t  }\n\telse\n\t  retval->successor[entries++]\n\t    = _nl_make_l10nflist (l10nfile_list, dirlist, dirlist_len,\n\t\t\t\t  cnt, language, territory, codeset,\n\t\t\t\t  normalized_codeset, modifier, filename, 1);\n      }\n  retval->successor[entries] = NULL;\n\n  return retval;\n}",
      "lines": 167,
      "depth": 20,
      "decorators": [
        "struct loaded_l10nfile",
        "struct",
        "loaded_l10nfile",
        "*\n_nl_make_l10nflist (struct loaded_l10nfile **l10nfile_list,\n\t\t    const char *dirlist, size_t dirlist_len,\n\t\t    int mask, const char *language, const char *territory,\n\t\t    const char *codeset, const char *normalized_codeset,\n\t\t    const char *modifier,\n\t\t    const char *filename, int do_allocate)",
        "*"
      ]
    },
    "_nl_normalize_codeset": {
      "start_point": [
        343,
        0
      ],
      "end_point": [
        380,
        1
      ],
      "content": "const char *\n_nl_normalize_codeset (const char *codeset, size_t name_len)\n{\n  size_t len = 0;\n  int only_digit = 1;\n  char *retval;\n  char *wp;\n  size_t cnt;\n\n  for (cnt = 0; cnt < name_len; ++cnt)\n    if (isalnum ((unsigned char) codeset[cnt]))\n      {\n\t++len;\n\n\tif (isalpha ((unsigned char) codeset[cnt]))\n\t  only_digit = 0;\n      }\n\n  retval = (char *) malloc ((only_digit ? 3 : 0) + len + 1);\n\n  if (retval != NULL)\n    {\n      if (only_digit)\n\twp = stpcpy (retval, \"iso\");\n      else\n\twp = retval;\n\n      for (cnt = 0; cnt < name_len; ++cnt)\n\tif (isalpha ((unsigned char) codeset[cnt]))\n\t  *wp++ = tolower ((unsigned char) codeset[cnt]);\n\telse if (isdigit ((unsigned char) codeset[cnt]))\n\t  *wp++ = codeset[cnt];\n\n      *wp = '\\0';\n    }\n\n  return (const char *) retval;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "const",
        "const",
        "char",
        "*\n_nl_normalize_codeset (const char *codeset, size_t name_len)",
        "*"
      ]
    },
    "stpcpy": {
      "start_point": [
        390,
        0
      ],
      "end_point": [
        396,
        1
      ],
      "content": "static char *\nstpcpy (char *dest, const char *src)\n{\n  while ((*dest++ = *src++) != '\\0')\n    /* Do nothing. */ ;\n  return dest - 1;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nstpcpy (char *dest, const char *src)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/langprefs.c": {
    "_nl_language_preferences_win32_mui": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "static const char *\n_nl_language_preferences_win32_mui (HMODULE kernel32)\n{\n  /* DWORD GetUserPreferredUILanguages (ULONG dwFlags,\n                                        PULONG pulNumLanguages,\n                                        PWSTR pwszLanguagesBuffer,\n                                        PULONG pcchLanguagesBuffer);  */\n  typedef DWORD (WINAPI *GetUserPreferredUILanguages_func) (ULONG, PULONG, PWSTR, PULONG);\n  GetUserPreferredUILanguages_func p_GetUserPreferredUILanguages;\n\n  p_GetUserPreferredUILanguages =\n   (GetUserPreferredUILanguages_func)\n   GetProcAddress (kernel32, \"GetUserPreferredUILanguages\");\n  if (p_GetUserPreferredUILanguages != NULL)\n    {\n      ULONG num_languages;\n      ULONG bufsize;\n      DWORD ret;\n\n      bufsize = 0;\n      ret = p_GetUserPreferredUILanguages (MUI_LANGUAGE_NAME,\n                                           &num_languages,\n                                           NULL, &bufsize);\n      if (ret == 0\n          && GetLastError () == STATUS_BUFFER_OVERFLOW\n          && bufsize > 0)\n        {\n          WCHAR *buffer = (WCHAR *) malloc (bufsize * sizeof (WCHAR));\n          if (buffer != NULL)\n            {\n              ret = p_GetUserPreferredUILanguages (MUI_LANGUAGE_NAME,\n                                                   &num_languages,\n                                                   buffer, &bufsize);\n              if (ret)\n                {\n                  /* Convert the list from NUL-delimited WCHAR[] Win32 locale\n                     names to colon-delimited char[] Unix locale names.\n                     We assume that all these locale names are in ASCII,\n                     nonempty and contain no colons.  */\n                  char *languages =\n                    (char *) malloc (bufsize + num_languages * 10 + 1);\n                  if (languages != NULL)\n                    {\n                      const WCHAR *p = buffer;\n                      char *q = languages;\n                      ULONG i;\n                      for (i = 0; i < num_languages; i++)\n                        {\n                          char *q1;\n                          char *q2;\n\n                          q1 = q;\n                          if (i > 0)\n                            *q++ = ':';\n                          q2 = q;\n                          for (; *p != (WCHAR)'\\0'; p++)\n                            {\n                              if ((unsigned char) *p != *p || *p == ':')\n                                {\n                                  /* A non-ASCII character or a colon inside\n                                     the Win32 locale name! Punt.  */\n                                  q = q1;\n                                  break;\n                                }\n                              *q++ = (unsigned char) *p;\n                            }\n                          if (q == q1)\n                            /* An unexpected Win32 locale name occurred.  */\n                            break;\n                          *q = '\\0';\n                          _nl_locale_name_canonicalize (q2);\n                          q = q2 + strlen (q2);\n                          p++;\n                        }\n                      *q = '\\0';\n                      if (q > languages)\n                        {\n                          free (buffer);\n                          return languages;\n                        }\n                      free (languages);\n                    }\n                }\n              free (buffer);\n            }\n        }\n    }\n  return NULL;\n}",
      "lines": 89,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\n_nl_language_preferences_win32_mui (HMODULE kernel32)",
        "*"
      ]
    },
    "_nl_language_preferences_win32_ME": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "static const char *\n_nl_language_preferences_win32_ME (HMODULE kernel32)\n{\n  /* LANGID GetUserDefaultUILanguage (void);  */\n  typedef LANGID (WINAPI *GetUserDefaultUILanguage_func) (void);\n  GetUserDefaultUILanguage_func p_GetUserDefaultUILanguage;\n\n  p_GetUserDefaultUILanguage =\n   (GetUserDefaultUILanguage_func)\n   GetProcAddress (kernel32, \"GetUserDefaultUILanguage\");\n  if (p_GetUserDefaultUILanguage != NULL)\n    return _nl_locale_name_from_win32_LANGID (p_GetUserDefaultUILanguage ());\n  return NULL;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\n_nl_language_preferences_win32_ME (HMODULE kernel32)",
        "*"
      ]
    },
    "_nl_language_preferences_win32_95": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "static const char *\n_nl_language_preferences_win32_95 ()\n{\n  HKEY desktop_resource_locale_key;\n\n  if (RegOpenKeyExA (HKEY_CURRENT_USER,\n                     \"Control Panel\\\\Desktop\\\\ResourceLocale\",\n                     0, KEY_QUERY_VALUE, &desktop_resource_locale_key)\n      == NO_ERROR)\n    {\n      DWORD type;\n      char data[8 + 1];\n      DWORD data_size = sizeof (data);\n      DWORD ret;\n\n      ret = RegQueryValueExA (desktop_resource_locale_key, NULL, NULL,\n                              &type, data, &data_size);\n      RegCloseKey (desktop_resource_locale_key);\n\n      if (ret == NO_ERROR)\n        {\n          /* We expect a string, at most 8 bytes long, that parses as a\n             hexadecimal number.  */\n          if (type == REG_SZ\n              && data_size <= sizeof (data)\n              && (data_size < sizeof (data)\n                  || data[sizeof (data) - 1] == '\\0'))\n            {\n              LCID lcid;\n              char *endp;\n              /* Ensure it's NUL terminated.  */\n              if (data_size < sizeof (data))\n                data[data_size] = '\\0';\n              /* Parse it as a hexadecimal number.  */\n              lcid = strtoul (data, &endp, 16);\n              if (endp > data && *endp == '\\0')\n                return _nl_locale_name_from_win32_LCID (lcid);\n            }\n        }\n    }\n  return NULL;\n}",
      "lines": 42,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\n_nl_language_preferences_win32_95 ()",
        "*"
      ]
    },
    "ret_first_language": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "static BOOL CALLBACK\nret_first_language (HMODULE h, LPCSTR type, LPCSTR name, WORD lang, LONG_PTR param)\n{\n  *(const char **)param = _nl_locale_name_from_win32_LANGID (lang);\n  return FALSE;\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "BOOL",
        "CALLBACK",
        "CALLBACK"
      ]
    },
    "_nl_language_preferences_win32_system": {
      "start_point": [
        212,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "static const char *\n_nl_language_preferences_win32_system (HMODULE kernel32)\n{\n  const char *languages = NULL;\n  /* Ignore the warning on mingw here. mingw has a wrong definition of the last\n     parameter type of ENUMRESLANGPROC.  */\n  EnumResourceLanguages (kernel32, RT_VERSION, MAKEINTRESOURCE (1),\n                         ret_first_language, (LONG_PTR)&languages);\n  return languages;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\n_nl_language_preferences_win32_system (HMODULE kernel32)",
        "*"
      ]
    },
    "_nl_language_preferences_default": {
      "start_point": [
        232,
        0
      ],
      "end_point": [
        352,
        1
      ],
      "content": "const char *\n_nl_language_preferences_default (void)\n{\n#if HAVE_CFPREFERENCESCOPYAPPVALUE /* MacOS X 10.2 or newer */\n  {\n    /* Cache the preferences list, since CoreFoundation calls are expensive.  */\n    static const char *cached_languages;\n    static int cache_initialized;\n\n    if (!cache_initialized)\n      {\n        CFTypeRef preferences =\n          CFPreferencesCopyAppValue (CFSTR (\"AppleLanguages\"),\n                                     kCFPreferencesCurrentApplication);\n        if (preferences != NULL\n            && CFGetTypeID (preferences) == CFArrayGetTypeID ())\n          {\n            CFArrayRef prefArray = (CFArrayRef)preferences;\n            int n = CFArrayGetCount (prefArray);\n            char buf[256];\n            size_t size = 0;\n            int i;\n\n            for (i = 0; i < n; i++)\n              {\n                CFTypeRef element = CFArrayGetValueAtIndex (prefArray, i);\n                if (element != NULL\n                    && CFGetTypeID (element) == CFStringGetTypeID ()\n                    && CFStringGetCString ((CFStringRef)element,\n                                           buf, sizeof (buf),\n                                           kCFStringEncodingASCII))\n                  {\n                    _nl_locale_name_canonicalize (buf);\n                    size += strlen (buf) + 1;\n                    /* Most GNU programs use msgids in English and don't ship\n                       an en.mo message catalog.  Therefore when we see \"en\"\n                       in the preferences list, arrange for gettext() to\n                       return the msgid, and ignore all further elements of\n                       the preferences list.  */\n                    if (strcmp (buf, \"en\") == 0)\n                      break;\n                  }\n                else\n                  break;\n              }\n            if (size > 0)\n              {\n                char *languages = (char *) malloc (size);\n\n                if (languages != NULL)\n                  {\n                    char *p = languages;\n\n                    for (i = 0; i < n; i++)\n                      {\n                        CFTypeRef element =\n                          CFArrayGetValueAtIndex (prefArray, i);\n                        if (element != NULL\n                            && CFGetTypeID (element) == CFStringGetTypeID ()\n                            && CFStringGetCString ((CFStringRef)element,\n                                                   buf, sizeof (buf),\n                                                   kCFStringEncodingASCII))\n                          {\n                            _nl_locale_name_canonicalize (buf);\n                            strcpy (p, buf);\n                            p += strlen (buf);\n                            *p++ = ':';\n                            if (strcmp (buf, \"en\") == 0)\n                              break;\n                          }\n                        else\n                          break;\n                      }\n                    *--p = '\\0';\n\n                    cached_languages = languages;\n                  }\n              }\n          }\n        cache_initialized = 1;\n      }\n    if (cached_languages != NULL)\n      return cached_languages;\n  }\n#endif\n\n#ifdef WIN32_NATIVE\n  {\n    /* Cache the preferences list, since computing it is expensive.  */\n    static const char *cached_languages;\n    static int cache_initialized;\n\n    /* Activate the new code only when the GETTEXT_MUI environment variable is\n       set, for the time being, since the new code is not well tested.  */\n    if (!cache_initialized && getenv (\"GETTEXT_MUI\") != NULL)\n      {\n        const char *languages = NULL;\n        HMODULE kernel32 = GetModuleHandle (\"kernel32\");\n\n        if (kernel32 != NULL)\n          languages = _nl_language_preferences_win32_mui (kernel32);\n\n        if (languages == NULL && kernel32 != NULL)\n          languages = _nl_language_preferences_win32_ME (kernel32);\n\n        if (languages == NULL)\n          languages = _nl_language_preferences_win32_95 ();\n\n        if (languages == NULL && kernel32 != NULL)\n          languages = _nl_language_preferences_win32_system (kernel32);\n\n        cached_languages = languages;\n        cache_initialized = 1;\n      }\n    if (cached_languages != NULL)\n      return cached_languages;\n  }\n#endif\n\n  return NULL;\n}",
      "lines": 121,
      "depth": 23,
      "decorators": [
        "const",
        "const",
        "char",
        "*\n_nl_language_preferences_default (void)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/libgnuintl.in.h": {
    "gettext": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "static inline char *gettext (const char *__msgid)\n{\n  return libintl_gettext (__msgid);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "char",
        "*gettext (const char *__msgid)",
        "*"
      ]
    },
    "dgettext": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "static inline char *dgettext (const char *__domainname, const char *__msgid)\n{\n  return libintl_dgettext (__domainname, __msgid);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "char",
        "*dgettext (const char *__domainname, const char *__msgid)",
        "*"
      ]
    },
    "dcgettext": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "static inline char *dcgettext (const char *__domainname, const char *__msgid,\n                               int __category)\n{\n  return libintl_dcgettext (__domainname, __msgid, __category);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "char",
        "*dcgettext (const char *__domainname, const char *__msgid,\n                               int __category)",
        "*"
      ]
    },
    "ngettext": {
      "start_point": [
        184,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "static inline char *ngettext (const char *__msgid1, const char *__msgid2,\n                              unsigned long int __n)\n{\n  return libintl_ngettext (__msgid1, __msgid2, __n);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "char",
        "*ngettext (const char *__msgid1, const char *__msgid2,\n                              unsigned long int __n)",
        "*"
      ]
    },
    "dngettext": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "static inline char *dngettext (const char *__domainname, const char *__msgid1,\n                               const char *__msgid2, unsigned long int __n)\n{\n  return libintl_dngettext (__domainname, __msgid1, __msgid2, __n);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "char",
        "*dngettext (const char *__domainname, const char *__msgid1,\n                               const char *__msgid2, unsigned long int __n)",
        "*"
      ]
    },
    "dcngettext": {
      "start_point": [
        228,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "static inline char *dcngettext (const char *__domainname,\n                                const char *__msgid1, const char *__msgid2,\n                                unsigned long int __n, int __category)\n{\n  return libintl_dcngettext (__domainname, __msgid1, __msgid2, __n, __category);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "char",
        "*dcngettext (const char *__domainname,\n                                const char *__msgid1, const char *__msgid2,\n                                unsigned long int __n, int __category)",
        "*"
      ]
    },
    "textdomain": {
      "start_point": [
        253,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "static inline char *textdomain (const char *__domainname)\n{\n  return libintl_textdomain (__domainname);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "char",
        "*textdomain (const char *__domainname)",
        "*"
      ]
    },
    "bindtextdomain": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        274,
        1
      ],
      "content": "static inline char *bindtextdomain (const char *__domainname,\n                                    const char *__dirname)\n{\n  return libintl_bindtextdomain (__domainname, __dirname);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "char",
        "*bindtextdomain (const char *__domainname,\n                                    const char *__dirname)",
        "*"
      ]
    },
    "bind_textdomain_codeset": {
      "start_point": [
        288,
        0
      ],
      "end_point": [
        292,
        1
      ],
      "content": "static inline char *bind_textdomain_codeset (const char *__domainname,\n                                             const char *__codeset)\n{\n  return libintl_bind_textdomain_codeset (__domainname, __codeset);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "char",
        "*bind_textdomain_codeset (const char *__domainname,\n                                             const char *__codeset)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/loadinfo.h": {},
  "sharutils/sharutils-4.15.2/intl/loadmsgcat.c": {
    "get_sysdep_segment_value": {
      "start_point": [
        512,
        0
      ],
      "end_point": [
        778,
        1
      ],
      "content": "static const char *\nget_sysdep_segment_value (const char *name)\n{\n  /* Test for an ISO C 99 section 7.8.1 format string directive.\n     Syntax:\n     P R I { d | i | o | u | x | X }\n     { { | LEAST | FAST } { 8 | 16 | 32 | 64 } | MAX | PTR }  */\n  /* We don't use a table of 14 times 6 'const char *' strings here, because\n     data relocations cost startup time.  */\n  if (name[0] == 'P' && name[1] == 'R' && name[2] == 'I')\n    {\n      if (name[3] == 'd' || name[3] == 'i' || name[3] == 'o' || name[3] == 'u'\n\t  || name[3] == 'x' || name[3] == 'X')\n\t{\n\t  if (name[4] == '8' && name[5] == '\\0')\n\t    {\n\t      if (name[3] == 'd')\n\t\treturn PRId8;\n\t      if (name[3] == 'i')\n\t\treturn PRIi8;\n\t      if (name[3] == 'o')\n\t\treturn PRIo8;\n\t      if (name[3] == 'u')\n\t\treturn PRIu8;\n\t      if (name[3] == 'x')\n\t\treturn PRIx8;\n\t      if (name[3] == 'X')\n\t\treturn PRIX8;\n\t      abort ();\n\t    }\n\t  if (name[4] == '1' && name[5] == '6' && name[6] == '\\0')\n\t    {\n\t      if (name[3] == 'd')\n\t\treturn PRId16;\n\t      if (name[3] == 'i')\n\t\treturn PRIi16;\n\t      if (name[3] == 'o')\n\t\treturn PRIo16;\n\t      if (name[3] == 'u')\n\t\treturn PRIu16;\n\t      if (name[3] == 'x')\n\t\treturn PRIx16;\n\t      if (name[3] == 'X')\n\t\treturn PRIX16;\n\t      abort ();\n\t    }\n\t  if (name[4] == '3' && name[5] == '2' && name[6] == '\\0')\n\t    {\n\t      if (name[3] == 'd')\n\t\treturn PRId32;\n\t      if (name[3] == 'i')\n\t\treturn PRIi32;\n\t      if (name[3] == 'o')\n\t\treturn PRIo32;\n\t      if (name[3] == 'u')\n\t\treturn PRIu32;\n\t      if (name[3] == 'x')\n\t\treturn PRIx32;\n\t      if (name[3] == 'X')\n\t\treturn PRIX32;\n\t      abort ();\n\t    }\n\t  if (name[4] == '6' && name[5] == '4' && name[6] == '\\0')\n\t    {\n\t      if (name[3] == 'd')\n\t\treturn PRId64;\n\t      if (name[3] == 'i')\n\t\treturn PRIi64;\n\t      if (name[3] == 'o')\n\t\treturn PRIo64;\n\t      if (name[3] == 'u')\n\t\treturn PRIu64;\n\t      if (name[3] == 'x')\n\t\treturn PRIx64;\n\t      if (name[3] == 'X')\n\t\treturn PRIX64;\n\t      abort ();\n\t    }\n\t  if (name[4] == 'L' && name[5] == 'E' && name[6] == 'A'\n\t      && name[7] == 'S' && name[8] == 'T')\n\t    {\n\t      if (name[9] == '8' && name[10] == '\\0')\n\t\t{\n\t\t  if (name[3] == 'd')\n\t\t    return PRIdLEAST8;\n\t\t  if (name[3] == 'i')\n\t\t    return PRIiLEAST8;\n\t\t  if (name[3] == 'o')\n\t\t    return PRIoLEAST8;\n\t\t  if (name[3] == 'u')\n\t\t    return PRIuLEAST8;\n\t\t  if (name[3] == 'x')\n\t\t    return PRIxLEAST8;\n\t\t  if (name[3] == 'X')\n\t\t    return PRIXLEAST8;\n\t\t  abort ();\n\t\t}\n\t      if (name[9] == '1' && name[10] == '6' && name[11] == '\\0')\n\t\t{\n\t\t  if (name[3] == 'd')\n\t\t    return PRIdLEAST16;\n\t\t  if (name[3] == 'i')\n\t\t    return PRIiLEAST16;\n\t\t  if (name[3] == 'o')\n\t\t    return PRIoLEAST16;\n\t\t  if (name[3] == 'u')\n\t\t    return PRIuLEAST16;\n\t\t  if (name[3] == 'x')\n\t\t    return PRIxLEAST16;\n\t\t  if (name[3] == 'X')\n\t\t    return PRIXLEAST16;\n\t\t  abort ();\n\t\t}\n\t      if (name[9] == '3' && name[10] == '2' && name[11] == '\\0')\n\t\t{\n\t\t  if (name[3] == 'd')\n\t\t    return PRIdLEAST32;\n\t\t  if (name[3] == 'i')\n\t\t    return PRIiLEAST32;\n\t\t  if (name[3] == 'o')\n\t\t    return PRIoLEAST32;\n\t\t  if (name[3] == 'u')\n\t\t    return PRIuLEAST32;\n\t\t  if (name[3] == 'x')\n\t\t    return PRIxLEAST32;\n\t\t  if (name[3] == 'X')\n\t\t    return PRIXLEAST32;\n\t\t  abort ();\n\t\t}\n\t      if (name[9] == '6' && name[10] == '4' && name[11] == '\\0')\n\t\t{\n\t\t  if (name[3] == 'd')\n\t\t    return PRIdLEAST64;\n\t\t  if (name[3] == 'i')\n\t\t    return PRIiLEAST64;\n\t\t  if (name[3] == 'o')\n\t\t    return PRIoLEAST64;\n\t\t  if (name[3] == 'u')\n\t\t    return PRIuLEAST64;\n\t\t  if (name[3] == 'x')\n\t\t    return PRIxLEAST64;\n\t\t  if (name[3] == 'X')\n\t\t    return PRIXLEAST64;\n\t\t  abort ();\n\t\t}\n\t    }\n\t  if (name[4] == 'F' && name[5] == 'A' && name[6] == 'S'\n\t      && name[7] == 'T')\n\t    {\n\t      if (name[8] == '8' && name[9] == '\\0')\n\t\t{\n\t\t  if (name[3] == 'd')\n\t\t    return PRIdFAST8;\n\t\t  if (name[3] == 'i')\n\t\t    return PRIiFAST8;\n\t\t  if (name[3] == 'o')\n\t\t    return PRIoFAST8;\n\t\t  if (name[3] == 'u')\n\t\t    return PRIuFAST8;\n\t\t  if (name[3] == 'x')\n\t\t    return PRIxFAST8;\n\t\t  if (name[3] == 'X')\n\t\t    return PRIXFAST8;\n\t\t  abort ();\n\t\t}\n\t      if (name[8] == '1' && name[9] == '6' && name[10] == '\\0')\n\t\t{\n\t\t  if (name[3] == 'd')\n\t\t    return PRIdFAST16;\n\t\t  if (name[3] == 'i')\n\t\t    return PRIiFAST16;\n\t\t  if (name[3] == 'o')\n\t\t    return PRIoFAST16;\n\t\t  if (name[3] == 'u')\n\t\t    return PRIuFAST16;\n\t\t  if (name[3] == 'x')\n\t\t    return PRIxFAST16;\n\t\t  if (name[3] == 'X')\n\t\t    return PRIXFAST16;\n\t\t  abort ();\n\t\t}\n\t      if (name[8] == '3' && name[9] == '2' && name[10] == '\\0')\n\t\t{\n\t\t  if (name[3] == 'd')\n\t\t    return PRIdFAST32;\n\t\t  if (name[3] == 'i')\n\t\t    return PRIiFAST32;\n\t\t  if (name[3] == 'o')\n\t\t    return PRIoFAST32;\n\t\t  if (name[3] == 'u')\n\t\t    return PRIuFAST32;\n\t\t  if (name[3] == 'x')\n\t\t    return PRIxFAST32;\n\t\t  if (name[3] == 'X')\n\t\t    return PRIXFAST32;\n\t\t  abort ();\n\t\t}\n\t      if (name[8] == '6' && name[9] == '4' && name[10] == '\\0')\n\t\t{\n\t\t  if (name[3] == 'd')\n\t\t    return PRIdFAST64;\n\t\t  if (name[3] == 'i')\n\t\t    return PRIiFAST64;\n\t\t  if (name[3] == 'o')\n\t\t    return PRIoFAST64;\n\t\t  if (name[3] == 'u')\n\t\t    return PRIuFAST64;\n\t\t  if (name[3] == 'x')\n\t\t    return PRIxFAST64;\n\t\t  if (name[3] == 'X')\n\t\t    return PRIXFAST64;\n\t\t  abort ();\n\t\t}\n\t    }\n\t  if (name[4] == 'M' && name[5] == 'A' && name[6] == 'X'\n\t      && name[7] == '\\0')\n\t    {\n\t      if (name[3] == 'd')\n\t\treturn PRIdMAX;\n\t      if (name[3] == 'i')\n\t\treturn PRIiMAX;\n\t      if (name[3] == 'o')\n\t\treturn PRIoMAX;\n\t      if (name[3] == 'u')\n\t\treturn PRIuMAX;\n\t      if (name[3] == 'x')\n\t\treturn PRIxMAX;\n\t      if (name[3] == 'X')\n\t\treturn PRIXMAX;\n\t      abort ();\n\t    }\n\t  if (name[4] == 'P' && name[5] == 'T' && name[6] == 'R'\n\t      && name[7] == '\\0')\n\t    {\n\t      if (name[3] == 'd')\n\t\treturn PRIdPTR;\n\t      if (name[3] == 'i')\n\t\treturn PRIiPTR;\n\t      if (name[3] == 'o')\n\t\treturn PRIoPTR;\n\t      if (name[3] == 'u')\n\t\treturn PRIuPTR;\n\t      if (name[3] == 'x')\n\t\treturn PRIxPTR;\n\t      if (name[3] == 'X')\n\t\treturn PRIXPTR;\n\t      abort ();\n\t    }\n\t}\n    }\n  /* Test for a glibc specific printf() format directive flag.  */\n  if (name[0] == 'I' && name[1] == '\\0')\n    {\n#if defined _LIBC \\\n    || ((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 2)) \\\n        && !defined __UCLIBC__)\n      /* The 'I' flag, in numeric format directives, replaces ASCII digits\n\t with the 'outdigits' defined in the LC_CTYPE locale facet.  This is\n\t used for Farsi (Persian), some Indic languages, and maybe Arabic.  */\n      return \"I\";\n#else\n      return \"\";\n#endif\n    }\n  /* Other system dependent strings are not valid.  */\n  return NULL;\n}",
      "lines": 267,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nget_sysdep_segment_value (const char *name)",
        "*"
      ]
    },
    "_nl_unload_domain": {
      "start_point": [
        1318,
        18
      ],
      "end_point": [
        1349,
        1
      ],
      "content": "__libc_freeres_fn_section\n_nl_unload_domain (struct loaded_domain *domain)\n{\n  size_t i;\n\n  if (domain->plural != &__gettext_germanic_plural)\n    __gettext_free_exp ((struct expression *) domain->plural);\n\n  for (i = 0; i < domain->nconversions; i++)\n    {\n      struct converted_domain *convd = &domain->conversions[i];\n\n      free ((char *) convd->encoding);\n      if (convd->conv_tab != NULL && convd->conv_tab != (char **) -1)\n\tfree (convd->conv_tab);\n      if (convd->conv != (__gconv_t) -1)\n\t__gconv_close (convd->conv);\n    }\n  free (domain->conversions);\n  __libc_rwlock_fini (domain->conversions_lock);\n\n  free (domain->malloced);\n\n# ifdef _POSIX_MAPPED_FILES\n  if (domain->use_mmap)\n    munmap ((caddr_t) domain->data, domain->mmap_size);\n  else\n# endif\t/* _POSIX_MAPPED_FILES */\n    free ((void *) domain->data);\n\n  free (domain);\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "__libc_freeres_fn_section"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/localcharset.c": {
    "get_charset_aliases": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        350,
        1
      ],
      "content": "static const char *\nget_charset_aliases (void)\n{\n  const char *cp;\n\n  cp = charset_aliases;\n  if (cp == NULL)\n    {\n#if !(defined DARWIN7 || defined VMS || defined WINDOWS_NATIVE || defined __CYGWIN__)\n      const char *dir;\n      const char *base = \"charset.alias\";\n      char *file_name;\n\n      /* Make it possible to override the charset.alias location.  This is\n         necessary for running the testsuite before \"make install\".  */\n      dir = getenv (\"CHARSETALIASDIR\");\n      if (dir == NULL || dir[0] == '\\0')\n        dir = relocate (LIBDIR);\n\n      /* Concatenate dir and base into freshly allocated file_name.  */\n      {\n        size_t dir_len = strlen (dir);\n        size_t base_len = strlen (base);\n        int add_slash = (dir_len > 0 && !ISSLASH (dir[dir_len - 1]));\n        file_name = (char *) malloc (dir_len + add_slash + base_len + 1);\n        if (file_name != NULL)\n          {\n            memcpy (file_name, dir, dir_len);\n            if (add_slash)\n              file_name[dir_len] = DIRECTORY_SEPARATOR;\n            memcpy (file_name + dir_len + add_slash, base, base_len + 1);\n          }\n      }\n\n      if (file_name == NULL)\n        /* Out of memory.  Treat the file as empty.  */\n        cp = \"\";\n      else\n        {\n          int fd;\n\n          /* Open the file.  Reject symbolic links on platforms that support\n             O_NOFOLLOW.  This is a security feature.  Without it, an attacker\n             could retrieve parts of the contents (namely, the tail of the\n             first line that starts with \"* \") of an arbitrary file by placing\n             a symbolic link to that file under the name \"charset.alias\" in\n             some writable directory and defining the environment variable\n             CHARSETALIASDIR to point to that directory.  */\n          fd = open (file_name,\n                     O_RDONLY | (HAVE_WORKING_O_NOFOLLOW ? O_NOFOLLOW : 0));\n          if (fd < 0)\n            /* File not found.  Treat it as empty.  */\n            cp = \"\";\n          else\n            {\n              FILE *fp;\n\n              fp = fdopen (fd, \"r\");\n              if (fp == NULL)\n                {\n                  /* Out of memory.  Treat the file as empty.  */\n                  close (fd);\n                  cp = \"\";\n                }\n              else\n                {\n                  /* Parse the file's contents.  */\n                  char *res_ptr = NULL;\n                  size_t res_size = 0;\n\n                  for (;;)\n                    {\n                      int c;\n                      char buf1[50+1];\n                      char buf2[50+1];\n                      size_t l1, l2;\n                      char *old_res_ptr;\n\n                      c = getc (fp);\n                      if (c == EOF)\n                        break;\n                      if (c == '\\n' || c == ' ' || c == '\\t')\n                        continue;\n                      if (c == '#')\n                        {\n                          /* Skip comment, to end of line.  */\n                          do\n                            c = getc (fp);\n                          while (!(c == EOF || c == '\\n'));\n                          if (c == EOF)\n                            break;\n                          continue;\n                        }\n                      ungetc (c, fp);\n                      if (fscanf (fp, \"%50s %50s\", buf1, buf2) < 2)\n                        break;\n                      l1 = strlen (buf1);\n                      l2 = strlen (buf2);\n                      old_res_ptr = res_ptr;\n                      if (res_size == 0)\n                        {\n                          res_size = l1 + 1 + l2 + 1;\n                          res_ptr = (char *) malloc (res_size + 1);\n                        }\n                      else\n                        {\n                          res_size += l1 + 1 + l2 + 1;\n                          res_ptr = (char *) realloc (res_ptr, res_size + 1);\n                        }\n                      if (res_ptr == NULL)\n                        {\n                          /* Out of memory. */\n                          res_size = 0;\n                          free (old_res_ptr);\n                          break;\n                        }\n                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);\n                      strcpy (res_ptr + res_size - (l2 + 1), buf2);\n                    }\n                  fclose (fp);\n                  if (res_size == 0)\n                    cp = \"\";\n                  else\n                    {\n                      *(res_ptr + res_size) = '\\0';\n                      cp = res_ptr;\n                    }\n                }\n            }\n\n          free (file_name);\n        }\n\n#else\n\n# if defined DARWIN7\n      /* To avoid the trouble of installing a file that is shared by many\n         GNU packages -- many packaging systems have problems with this --,\n         simply inline the aliases here.  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-4\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"ISO8859-13\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"ISO8859-15\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"KOI8-R\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"KOI8-U\" \"\\0\" \"KOI8-U\" \"\\0\"\n           \"CP866\" \"\\0\" \"CP866\" \"\\0\"\n           \"CP949\" \"\\0\" \"CP949\" \"\\0\"\n           \"CP1131\" \"\\0\" \"CP1131\" \"\\0\"\n           \"CP1251\" \"\\0\" \"CP1251\" \"\\0\"\n           \"eucCN\" \"\\0\" \"GB2312\" \"\\0\"\n           \"GB2312\" \"\\0\" \"GB2312\" \"\\0\"\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"eucKR\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"Big5\" \"\\0\" \"BIG5\" \"\\0\"\n           \"Big5HKSCS\" \"\\0\" \"BIG5-HKSCS\" \"\\0\"\n           \"GBK\" \"\\0\" \"GBK\" \"\\0\"\n           \"GB18030\" \"\\0\" \"GB18030\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"ARMSCII-8\" \"\\0\" \"ARMSCII-8\" \"\\0\"\n           \"PT154\" \"\\0\" \"PT154\" \"\\0\"\n         /*\"ISCII-DEV\" \"\\0\" \"?\" \"\\0\"*/\n           \"*\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n\n# if defined VMS\n      /* To avoid the troubles of an extra file charset.alias_vms in the\n         sources of many GNU packages, simply inline the aliases here.  */\n      /* The list of encodings is taken from the OpenVMS 7.3-1 documentation\n         \"Compaq C Run-Time Library Reference Manual for OpenVMS systems\"\n         section 10.7 \"Handling Different Character Sets\".  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-8\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           /* Japanese */\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"DECKANJI\" \"\\0\" \"DEC-KANJI\" \"\\0\"\n           \"SDECKANJI\" \"\\0\" \"EUC-JP\" \"\\0\"\n           /* Chinese */\n           \"eucTW\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"DECHANYU\" \"\\0\" \"DEC-HANYU\" \"\\0\"\n           \"DECHANZI\" \"\\0\" \"GB2312\" \"\\0\"\n           /* Korean */\n           \"DECKOREAN\" \"\\0\" \"EUC-KR\" \"\\0\";\n# endif\n\n# if defined WINDOWS_NATIVE || defined __CYGWIN__\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      cp = \"CP936\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP1361\" \"\\0\" \"JOHAB\" \"\\0\"\n           \"CP20127\" \"\\0\" \"ASCII\" \"\\0\"\n           \"CP20866\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP20936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP21866\" \"\\0\" \"KOI8-RU\" \"\\0\"\n           \"CP28591\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP28592\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP28593\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP28594\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP28595\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP28596\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP28597\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP28598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP28599\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP28605\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP38598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP51932\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP51936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP51949\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP51950\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP54936\" \"\\0\" \"GB18030\" \"\\0\"\n           \"CP65001\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n#endif\n\n      charset_aliases = cp;\n    }\n\n  return cp;\n}",
      "lines": 229,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nget_charset_aliases (void)",
        "*"
      ]
    },
    "locale_charset": {
      "start_point": [
        361,
        0
      ],
      "end_point": [
        578,
        1
      ],
      "content": "const char *\nlocale_charset (void)\n{\n  const char *codeset;\n  const char *aliases;\n\n#if !(defined WINDOWS_NATIVE || defined OS2)\n\n# if HAVE_LANGINFO_CODESET\n\n  /* Most systems support nl_langinfo (CODESET) nowadays.  */\n  codeset = nl_langinfo (CODESET);\n\n#  ifdef __CYGWIN__\n  /* Cygwin < 1.7 does not have locales.  nl_langinfo (CODESET) always\n     returns \"US-ASCII\".  Return the suffix of the locale name from the\n     environment variables (if present) or the codepage as a number.  */\n  if (codeset != NULL && strcmp (codeset, \"US-ASCII\") == 0)\n    {\n      const char *locale;\n      static char buf[2 + 10 + 1];\n\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n      if (locale != NULL && locale[0] != '\\0')\n        {\n          /* If the locale name contains an encoding after the dot, return\n             it.  */\n          const char *dot = strchr (locale, '.');\n\n          if (dot != NULL)\n            {\n              const char *modifier;\n\n              dot++;\n              /* Look for the possible @... trailer and remove it, if any.  */\n              modifier = strchr (dot, '@');\n              if (modifier == NULL)\n                return dot;\n              if (modifier - dot < sizeof (buf))\n                {\n                  memcpy (buf, dot, modifier - dot);\n                  buf [modifier - dot] = '\\0';\n                  return buf;\n                }\n            }\n        }\n\n      /* The Windows API has a function returning the locale's codepage as a\n         number: GetACP().  This encoding is used by Cygwin, unless the user\n         has set the environment variable CYGWIN=codepage:oem (which very few\n         people do).\n         Output directed to console windows needs to be converted (to\n         GetOEMCP() if the console is using a raster font, or to\n         GetConsoleOutputCP() if it is using a TrueType font).  Cygwin does\n         this conversion transparently (see winsup/cygwin/fhandler_console.cc),\n         converting to GetConsoleOutputCP().  This leads to correct results,\n         except when SetConsoleOutputCP has been called and a raster font is\n         in use.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n      codeset = buf;\n    }\n#  endif\n\n# else\n\n  /* On old systems which lack it, use setlocale or getenv.  */\n  const char *locale = NULL;\n\n  /* But most old systems don't have a complete set of locales.  Some\n     (like SunOS 4 or DJGPP) have only the C locale.  Therefore we don't\n     use setlocale here; it would return \"C\" when it doesn't support the\n     locale name the user has set.  */\n#  if 0\n  locale = setlocale (LC_CTYPE, NULL);\n#  endif\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n    }\n\n  /* On some old systems, one used to set locale = \"iso8859_1\". On others,\n     you set it to \"language_COUNTRY.charset\". In any case, we resolve it\n     through the charset.alias file.  */\n  codeset = locale;\n\n# endif\n\n#elif defined WINDOWS_NATIVE\n\n  static char buf[2 + 10 + 1];\n\n  /* The Windows API has a function returning the locale's codepage as\n     a number, but the value doesn't change according to what the\n     'setlocale' call specified.  So we use it as a last resort, in\n     case the string returned by 'setlocale' doesn't specify the\n     codepage.  */\n  char *current_locale = setlocale (LC_ALL, NULL);\n  char *pdot;\n\n  /* If they set different locales for different categories,\n     'setlocale' will return a semi-colon separated list of locale\n     values.  To make sure we use the correct one, we choose LC_CTYPE.  */\n  if (strchr (current_locale, ';'))\n    current_locale = setlocale (LC_CTYPE, NULL);\n\n  pdot = strrchr (current_locale, '.');\n  if (pdot)\n    sprintf (buf, \"CP%s\", pdot + 1);\n  else\n    {\n      /* The Windows API has a function returning the locale's codepage as a\n        number: GetACP().\n        When the output goes to a console window, it needs to be provided in\n        GetOEMCP() encoding if the console is using a raster font, or in\n        GetConsoleOutputCP() encoding if it is using a TrueType font.\n        But in GUI programs and for output sent to files and pipes, GetACP()\n        encoding is the best bet.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n    }\n  codeset = buf;\n\n#elif defined OS2\n\n  const char *locale;\n  static char buf[2 + 10 + 1];\n  ULONG cp[3];\n  ULONG cplen;\n\n  /* Allow user to override the codeset, as set in the operating system,\n     with standard language environment variables.  */\n  locale = getenv (\"LC_ALL\");\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_CTYPE\");\n      if (locale == NULL || locale[0] == '\\0')\n        locale = getenv (\"LANG\");\n    }\n  if (locale != NULL && locale[0] != '\\0')\n    {\n      /* If the locale name contains an encoding after the dot, return it.  */\n      const char *dot = strchr (locale, '.');\n\n      if (dot != NULL)\n        {\n          const char *modifier;\n\n          dot++;\n          /* Look for the possible @... trailer and remove it, if any.  */\n          modifier = strchr (dot, '@');\n          if (modifier == NULL)\n            return dot;\n          if (modifier - dot < sizeof (buf))\n            {\n              memcpy (buf, dot, modifier - dot);\n              buf [modifier - dot] = '\\0';\n              return buf;\n            }\n        }\n\n      /* Resolve through the charset.alias file.  */\n      codeset = locale;\n    }\n  else\n    {\n      /* OS/2 has a function returning the locale's codepage as a number.  */\n      if (DosQueryCp (sizeof (cp), cp, &cplen))\n        codeset = \"\";\n      else\n        {\n          sprintf (buf, \"CP%u\", cp[0]);\n          codeset = buf;\n        }\n    }\n\n#endif\n\n  if (codeset == NULL)\n    /* The canonical name cannot be determined.  */\n    codeset = \"\";\n\n  /* Resolve alias. */\n  for (aliases = get_charset_aliases ();\n       *aliases != '\\0';\n       aliases += strlen (aliases) + 1, aliases += strlen (aliases) + 1)\n    if (strcmp (codeset, aliases) == 0\n        || (aliases[0] == '*' && aliases[1] == '\\0'))\n      {\n        codeset = aliases + strlen (aliases) + 1;\n        break;\n      }\n\n  /* Don't return an empty string.  GNU libc and GNU libiconv interpret\n     the empty string as denoting \"the locale's character encoding\",\n     thus GNU libiconv would call this function a second time.  */\n  if (codeset[0] == '\\0')\n    codeset = \"ASCII\";\n\n#ifdef DARWIN7\n  /* Mac OS X sets MB_CUR_MAX to 1 when LC_ALL=C, and \"UTF-8\"\n     (the default codeset) does not work when MB_CUR_MAX is 1.  */\n  if (strcmp (codeset, \"UTF-8\") == 0 && MB_CUR_MAX_L (uselocale (NULL)) <= 1)\n    codeset = \"ASCII\";\n#endif\n\n  return codeset;\n}",
      "lines": 218,
      "depth": 18,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nlocale_charset (void)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/localcharset.h": {},
  "sharutils/sharutils-4.15.2/intl/localealias.c": {
    "_nl_expand_alias": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "const char *\n_nl_expand_alias (const char *name)\n{\n  static const char *locale_alias_path;\n  struct alias_map *retval;\n  const char *result = NULL;\n  size_t added;\n\n  __libc_lock_lock (lock);\n\n  if (locale_alias_path == NULL)\n    locale_alias_path = LOCALE_ALIAS_PATH;\n\n  do\n    {\n      struct alias_map item;\n\n      item.alias = name;\n\n      if (nmap > 0)\n\tretval = (struct alias_map *) bsearch (&item, map, nmap,\n\t\t\t\t\t       sizeof (struct alias_map),\n\t\t\t\t\t       (int (*) (const void *,\n\t\t\t\t\t\t\t const void *)\n\t\t\t\t\t\t) alias_compare);\n      else\n\tretval = NULL;\n\n      /* We really found an alias.  Return the value.  */\n      if (retval != NULL)\n\t{\n\t  result = retval->value;\n\t  break;\n\t}\n\n      /* Perhaps we can find another alias file.  */\n      added = 0;\n      while (added == 0 && locale_alias_path[0] != '\\0')\n\t{\n\t  const char *start;\n\n\t  while (locale_alias_path[0] == PATH_SEPARATOR)\n\t    ++locale_alias_path;\n\t  start = locale_alias_path;\n\n\t  while (locale_alias_path[0] != '\\0'\n\t\t && locale_alias_path[0] != PATH_SEPARATOR)\n\t    ++locale_alias_path;\n\n\t  if (start < locale_alias_path)\n\t    added = read_alias_file (start, locale_alias_path - start);\n\t}\n    }\n  while (added != 0);\n\n  __libc_lock_unlock (lock);\n\n  return result;\n}",
      "lines": 59,
      "depth": 17,
      "decorators": [
        "const",
        "const",
        "char",
        "*\n_nl_expand_alias (const char *name)",
        "*"
      ]
    },
    "read_alias_file": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        386,
        1
      ],
      "content": "static size_t\ninternal_function\nread_alias_file (const char *fname, int fname_len)\n{\n  FILE *fp;\n  char *full_fname;\n  size_t added;\n  static const char aliasfile[] = \"/locale.alias\";\n\n  full_fname = (char *) alloca (fname_len + sizeof aliasfile);\n#ifdef HAVE_MEMPCPY\n  mempcpy (mempcpy (full_fname, fname, fname_len),\n\t   aliasfile, sizeof aliasfile);\n#else\n  memcpy (full_fname, fname, fname_len);\n  memcpy (&full_fname[fname_len], aliasfile, sizeof aliasfile);\n#endif\n\n#ifdef _LIBC\n  /* Note the file is opened with cancellation in the I/O functions\n     disabled.  */\n  fp = fopen (relocate (full_fname), \"rc\");\n#else\n  fp = fopen (relocate (full_fname), \"r\");\n#endif\n  freea (full_fname);\n  if (fp == NULL)\n    return 0;\n\n#ifdef HAVE___FSETLOCKING\n  /* No threads present.  */\n  __fsetlocking (fp, FSETLOCKING_BYCALLER);\n#endif\n\n  added = 0;\n  while (!FEOF (fp))\n    {\n      /* It is a reasonable approach to use a fix buffer here because\n\t a) we are only interested in the first two fields\n\t b) these fields must be usable as file names and so must not\n\t    be that long\n\t We avoid a multi-kilobyte buffer here since this would use up\n\t stack space which we might not have if the program ran out of\n\t memory.  */\n      char buf[400];\n      char *alias;\n      char *value;\n      char *cp;\n      int complete_line;\n\n      if (FGETS (buf, sizeof buf, fp) == NULL)\n\t/* EOF reached.  */\n\tbreak;\n\n      /* Determine whether the line is complete.  */\n      complete_line = strchr (buf, '\\n') != NULL;\n\n      cp = buf;\n      /* Ignore leading white space.  */\n      while (isspace ((unsigned char) cp[0]))\n\t++cp;\n\n      /* A leading '#' signals a comment line.  */\n      if (cp[0] != '\\0' && cp[0] != '#')\n\t{\n\t  alias = cp++;\n\t  while (cp[0] != '\\0' && !isspace ((unsigned char) cp[0]))\n\t    ++cp;\n\t  /* Terminate alias name.  */\n\t  if (cp[0] != '\\0')\n\t    *cp++ = '\\0';\n\n\t  /* Now look for the beginning of the value.  */\n\t  while (isspace ((unsigned char) cp[0]))\n\t    ++cp;\n\n\t  if (cp[0] != '\\0')\n\t    {\n\t      value = cp++;\n\t      while (cp[0] != '\\0' && !isspace ((unsigned char) cp[0]))\n\t\t++cp;\n\t      /* Terminate value.  */\n\t      if (cp[0] == '\\n')\n\t\t{\n\t\t  /* This has to be done to make the following test\n\t\t     for the end of line possible.  We are looking for\n\t\t     the terminating '\\n' which do not overwrite here.  */\n\t\t  *cp++ = '\\0';\n\t\t  *cp = '\\n';\n\t\t}\n\t      else if (cp[0] != '\\0')\n\t\t*cp++ = '\\0';\n\n#ifdef IN_LIBGLOCALE\n\t      /* glibc's locale.alias contains entries for ja_JP and ko_KR\n\t\t that make it impossible to use a Japanese or Korean UTF-8\n\t\t locale under the name \"ja_JP\" or \"ko_KR\".  Ignore these\n\t\t entries.  */\n\t      if (strchr (alias, '_') == NULL)\n#endif\n\t\t{\n\t\t  size_t alias_len;\n\t\t  size_t value_len;\n\n\t\t  if (nmap >= maxmap)\n\t\t    if (__builtin_expect (extend_alias_table (), 0))\n\t\t      goto out;\n\n\t\t  alias_len = strlen (alias) + 1;\n\t\t  value_len = strlen (value) + 1;\n\n\t\t  if (string_space_act + alias_len + value_len > string_space_max)\n\t\t    {\n\t\t      /* Increase size of memory pool.  */\n\t\t      size_t new_size = (string_space_max\n\t\t\t\t\t + (alias_len + value_len > 1024\n\t\t\t\t\t    ? alias_len + value_len : 1024));\n\t\t      char *new_pool = (char *) realloc (string_space, new_size);\n\t\t      if (new_pool == NULL)\n\t\t\tgoto out;\n\n\t\t      if (__builtin_expect (string_space != new_pool, 0))\n\t\t\t{\n\t\t\t  size_t i;\n\n\t\t\t  for (i = 0; i < nmap; i++)\n\t\t\t    {\n\t\t\t      map[i].alias += new_pool - string_space;\n\t\t\t      map[i].value += new_pool - string_space;\n\t\t\t    }\n\t\t\t}\n\n\t\t      string_space = new_pool;\n\t\t      string_space_max = new_size;\n\t\t    }\n\n\t\t  map[nmap].alias =\n\t\t    (const char *) memcpy (&string_space[string_space_act],\n\t\t\t\t\t   alias, alias_len);\n\t\t  string_space_act += alias_len;\n\n\t\t  map[nmap].value =\n\t\t    (const char *) memcpy (&string_space[string_space_act],\n\t\t\t\t\t   value, value_len);\n\t\t  string_space_act += value_len;\n\n\t\t  ++nmap;\n\t\t  ++added;\n\t\t}\n\t    }\n\t}\n\n      /* Possibly not the whole line fits into the buffer.  Ignore\n\t the rest of the line.  */\n      if (! complete_line)\n\tdo\n\t  if (FGETS (buf, sizeof buf, fp) == NULL)\n\t    /* Make sure the inner loop will be left.  The outer loop\n\t       will exit at the `feof' test.  */\n\t    break;\n\twhile (strchr (buf, '\\n') == NULL);\n    }\n\n out:\n  /* Should we test for ferror()?  I think we have to silently ignore\n     errors.  --drepper  */\n  fclose (fp);\n\n  if (added > 0)\n    qsort (map, nmap, sizeof (struct alias_map),\n\t   (int (*) (const void *, const void *)) alias_compare);\n\n  return added;\n}",
      "lines": 174,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "size_t",
        "internal_function",
        "internal_function"
      ]
    },
    "extend_alias_table": {
      "start_point": [
        389,
        0
      ],
      "end_point": [
        405,
        1
      ],
      "content": "static int\nextend_alias_table ()\n{\n  size_t new_size;\n  struct alias_map *new_map;\n\n  new_size = maxmap == 0 ? 100 : 2 * maxmap;\n  new_map = (struct alias_map *) realloc (map, (new_size\n\t\t\t\t\t\t* sizeof (struct alias_map)));\n  if (new_map == NULL)\n    /* Simply don't extend: we don't have any more core.  */\n    return -1;\n\n  map = new_map;\n  maxmap = new_size;\n  return 0;\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "alias_compare": {
      "start_point": [
        408,
        0
      ],
      "end_point": [
        436,
        1
      ],
      "content": "static int\nalias_compare (const struct alias_map *map1, const struct alias_map *map2)\n{\n#if defined _LIBC || defined HAVE_STRCASECMP\n  return strcasecmp (map1->alias, map2->alias);\n#else\n  const unsigned char *p1 = (const unsigned char *) map1->alias;\n  const unsigned char *p2 = (const unsigned char *) map2->alias;\n  unsigned char c1, c2;\n\n  if (p1 == p2)\n    return 0;\n\n  do\n    {\n      /* I know this seems to be odd but the tolower() function in\n\t some systems libc cannot handle nonalpha characters.  */\n      c1 = isupper (*p1) ? tolower (*p1) : *p1;\n      c2 = isupper (*p2) ? tolower (*p2) : *p2;\n      if (c1 == '\\0')\n\tbreak;\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  return c1 - c2;\n#endif\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/localename.c": {
    "gl_locale_name_canonicalize": [
      {
        "start_point": [
          1146,
          0
        ],
        "end_point": [
          1409,
          1
        ],
        "content": "void\ngl_locale_name_canonicalize (char *name)\n{\n  /* This conversion is based on a posting by\n     Deborah GoldSmith <goldsmit@apple.com> on 2005-03-08,\n     http://lists.apple.com/archives/carbon-dev/2005/Mar/msg00293.html */\n\n  /* Convert legacy (NeXTstep inherited) English names to Unix (ISO 639 and\n     ISO 3166) names.  Prior to Mac OS X 10.3, there is no API for doing this.\n     Therefore we do it ourselves, using a table based on the results of the\n     Mac OS X 10.3.8 function\n     CFLocaleCreateCanonicalLocaleIdentifierFromString().  */\n  typedef struct { const char legacy[21+1]; const char unixy[5+1]; }\n          legacy_entry;\n  static const legacy_entry legacy_table[] = {\n    { \"Afrikaans\",             \"af\" },\n    { \"Albanian\",              \"sq\" },\n    { \"Amharic\",               \"am\" },\n    { \"Arabic\",                \"ar\" },\n    { \"Armenian\",              \"hy\" },\n    { \"Assamese\",              \"as\" },\n    { \"Aymara\",                \"ay\" },\n    { \"Azerbaijani\",           \"az\" },\n    { \"Basque\",                \"eu\" },\n    { \"Belarusian\",            \"be\" },\n    { \"Belorussian\",           \"be\" },\n    { \"Bengali\",               \"bn\" },\n    { \"Brazilian Portugese\",   \"pt_BR\" },\n    { \"Brazilian Portuguese\",  \"pt_BR\" },\n    { \"Breton\",                \"br\" },\n    { \"Bulgarian\",             \"bg\" },\n    { \"Burmese\",               \"my\" },\n    { \"Byelorussian\",          \"be\" },\n    { \"Catalan\",               \"ca\" },\n    { \"Chewa\",                 \"ny\" },\n    { \"Chichewa\",              \"ny\" },\n    { \"Chinese\",               \"zh\" },\n    { \"Chinese, Simplified\",   \"zh_CN\" },\n    { \"Chinese, Traditional\",  \"zh_TW\" },\n    { \"Chinese, Tradtional\",   \"zh_TW\" },\n    { \"Croatian\",              \"hr\" },\n    { \"Czech\",                 \"cs\" },\n    { \"Danish\",                \"da\" },\n    { \"Dutch\",                 \"nl\" },\n    { \"Dzongkha\",              \"dz\" },\n    { \"English\",               \"en\" },\n    { \"Esperanto\",             \"eo\" },\n    { \"Estonian\",              \"et\" },\n    { \"Faroese\",               \"fo\" },\n    { \"Farsi\",                 \"fa\" },\n    { \"Finnish\",               \"fi\" },\n    { \"Flemish\",               \"nl_BE\" },\n    { \"French\",                \"fr\" },\n    { \"Galician\",              \"gl\" },\n    { \"Gallegan\",              \"gl\" },\n    { \"Georgian\",              \"ka\" },\n    { \"German\",                \"de\" },\n    { \"Greek\",                 \"el\" },\n    { \"Greenlandic\",           \"kl\" },\n    { \"Guarani\",               \"gn\" },\n    { \"Gujarati\",              \"gu\" },\n    { \"Hawaiian\",              \"haw\" }, /* Yes, \"haw\", not \"cpe\".  */\n    { \"Hebrew\",                \"he\" },\n    { \"Hindi\",                 \"hi\" },\n    { \"Hungarian\",             \"hu\" },\n    { \"Icelandic\",             \"is\" },\n    { \"Indonesian\",            \"id\" },\n    { \"Inuktitut\",             \"iu\" },\n    { \"Irish\",                 \"ga\" },\n    { \"Italian\",               \"it\" },\n    { \"Japanese\",              \"ja\" },\n    { \"Javanese\",              \"jv\" },\n    { \"Kalaallisut\",           \"kl\" },\n    { \"Kannada\",               \"kn\" },\n    { \"Kashmiri\",              \"ks\" },\n    { \"Kazakh\",                \"kk\" },\n    { \"Khmer\",                 \"km\" },\n    { \"Kinyarwanda\",           \"rw\" },\n    { \"Kirghiz\",               \"ky\" },\n    { \"Korean\",                \"ko\" },\n    { \"Kurdish\",               \"ku\" },\n    { \"Latin\",                 \"la\" },\n    { \"Latvian\",               \"lv\" },\n    { \"Lithuanian\",            \"lt\" },\n    { \"Macedonian\",            \"mk\" },\n    { \"Malagasy\",              \"mg\" },\n    { \"Malay\",                 \"ms\" },\n    { \"Malayalam\",             \"ml\" },\n    { \"Maltese\",               \"mt\" },\n    { \"Manx\",                  \"gv\" },\n    { \"Marathi\",               \"mr\" },\n    { \"Moldavian\",             \"mo\" },\n    { \"Mongolian\",             \"mn\" },\n    { \"Nepali\",                \"ne\" },\n    { \"Norwegian\",             \"nb\" }, /* Yes, \"nb\", not the obsolete \"no\".  */\n    { \"Nyanja\",                \"ny\" },\n    { \"Nynorsk\",               \"nn\" },\n    { \"Oriya\",                 \"or\" },\n    { \"Oromo\",                 \"om\" },\n    { \"Panjabi\",               \"pa\" },\n    { \"Pashto\",                \"ps\" },\n    { \"Persian\",               \"fa\" },\n    { \"Polish\",                \"pl\" },\n    { \"Portuguese\",            \"pt\" },\n    { \"Portuguese, Brazilian\", \"pt_BR\" },\n    { \"Punjabi\",               \"pa\" },\n    { \"Pushto\",                \"ps\" },\n    { \"Quechua\",               \"qu\" },\n    { \"Romanian\",              \"ro\" },\n    { \"Ruanda\",                \"rw\" },\n    { \"Rundi\",                 \"rn\" },\n    { \"Russian\",               \"ru\" },\n    { \"Sami\",                  \"se_NO\" }, /* Not just \"se\".  */\n    { \"Sanskrit\",              \"sa\" },\n    { \"Scottish\",              \"gd\" },\n    { \"Serbian\",               \"sr\" },\n    { \"Simplified Chinese\",    \"zh_CN\" },\n    { \"Sindhi\",                \"sd\" },\n    { \"Sinhalese\",             \"si\" },\n    { \"Slovak\",                \"sk\" },\n    { \"Slovenian\",             \"sl\" },\n    { \"Somali\",                \"so\" },\n    { \"Spanish\",               \"es\" },\n    { \"Sundanese\",             \"su\" },\n    { \"Swahili\",               \"sw\" },\n    { \"Swedish\",               \"sv\" },\n    { \"Tagalog\",               \"tl\" },\n    { \"Tajik\",                 \"tg\" },\n    { \"Tajiki\",                \"tg\" },\n    { \"Tamil\",                 \"ta\" },\n    { \"Tatar\",                 \"tt\" },\n    { \"Telugu\",                \"te\" },\n    { \"Thai\",                  \"th\" },\n    { \"Tibetan\",               \"bo\" },\n    { \"Tigrinya\",              \"ti\" },\n    { \"Tongan\",                \"to\" },\n    { \"Traditional Chinese\",   \"zh_TW\" },\n    { \"Turkish\",               \"tr\" },\n    { \"Turkmen\",               \"tk\" },\n    { \"Uighur\",                \"ug\" },\n    { \"Ukrainian\",             \"uk\" },\n    { \"Urdu\",                  \"ur\" },\n    { \"Uzbek\",                 \"uz\" },\n    { \"Vietnamese\",            \"vi\" },\n    { \"Welsh\",                 \"cy\" },\n    { \"Yiddish\",               \"yi\" }\n  };\n\n  /* Convert new-style locale names with language tags (ISO 639 and ISO 15924)\n     to Unix (ISO 639 and ISO 3166) names.  */\n  typedef struct { const char langtag[7+1]; const char unixy[12+1]; }\n          langtag_entry;\n  static const langtag_entry langtag_table[] = {\n    /* Mac OS X has \"az-Arab\", \"az-Cyrl\", \"az-Latn\".\n       The default script for az on Unix is Latin.  */\n    { \"az-Latn\", \"az\" },\n    /* Mac OS X has \"ga-dots\".  Does not yet exist on Unix.  */\n    { \"ga-dots\", \"ga\" },\n    /* Mac OS X has \"kk-Cyrl\".  Does not yet exist on Unix.  */\n    /* Mac OS X has \"mn-Cyrl\", \"mn-Mong\".\n       The default script for mn on Unix is Cyrillic.  */\n    { \"mn-Cyrl\", \"mn\" },\n    /* Mac OS X has \"ms-Arab\", \"ms-Latn\".\n       The default script for ms on Unix is Latin.  */\n    { \"ms-Latn\", \"ms\" },\n    /* Mac OS X has \"tg-Cyrl\".\n       The default script for tg on Unix is Cyrillic.  */\n    { \"tg-Cyrl\", \"tg\" },\n    /* Mac OS X has \"tk-Cyrl\".  Does not yet exist on Unix.  */\n    /* Mac OS X has \"tt-Cyrl\".\n       The default script for tt on Unix is Cyrillic.  */\n    { \"tt-Cyrl\", \"tt\" },\n    /* Mac OS X has \"zh-Hans\", \"zh-Hant\".\n       Country codes are used to distinguish these on Unix.  */\n    { \"zh-Hans\", \"zh_CN\" },\n    { \"zh-Hant\", \"zh_TW\" }\n  };\n\n  /* Convert script names (ISO 15924) to Unix conventions.\n     See http://www.unicode.org/iso15924/iso15924-codes.html  */\n  typedef struct { const char script[4+1]; const char unixy[9+1]; }\n          script_entry;\n  static const script_entry script_table[] = {\n    { \"Arab\", \"arabic\" },\n    { \"Cyrl\", \"cyrillic\" },\n    { \"Mong\", \"mongolian\" }\n  };\n\n  /* Step 1: Convert using legacy_table.  */\n  if (name[0] >= 'A' && name[0] <= 'Z')\n    {\n      unsigned int i1, i2;\n      i1 = 0;\n      i2 = sizeof (legacy_table) / sizeof (legacy_entry);\n      while (i2 - i1 > 1)\n        {\n          /* At this point we know that if name occurs in legacy_table,\n             its index must be >= i1 and < i2.  */\n          unsigned int i = (i1 + i2) >> 1;\n          const legacy_entry *p = &legacy_table[i];\n          if (strcmp (name, p->legacy) < 0)\n            i2 = i;\n          else\n            i1 = i;\n        }\n      if (strcmp (name, legacy_table[i1].legacy) == 0)\n        {\n          strcpy (name, legacy_table[i1].unixy);\n          return;\n        }\n    }\n\n  /* Step 2: Convert using langtag_table and script_table.  */\n  if (strlen (name) == 7 && name[2] == '-')\n    {\n      unsigned int i1, i2;\n      i1 = 0;\n      i2 = sizeof (langtag_table) / sizeof (langtag_entry);\n      while (i2 - i1 > 1)\n        {\n          /* At this point we know that if name occurs in langtag_table,\n             its index must be >= i1 and < i2.  */\n          unsigned int i = (i1 + i2) >> 1;\n          const langtag_entry *p = &langtag_table[i];\n          if (strcmp (name, p->langtag) < 0)\n            i2 = i;\n          else\n            i1 = i;\n        }\n      if (strcmp (name, langtag_table[i1].langtag) == 0)\n        {\n          strcpy (name, langtag_table[i1].unixy);\n          return;\n        }\n\n      i1 = 0;\n      i2 = sizeof (script_table) / sizeof (script_entry);\n      while (i2 - i1 > 1)\n        {\n          /* At this point we know that if (name + 3) occurs in script_table,\n             its index must be >= i1 and < i2.  */\n          unsigned int i = (i1 + i2) >> 1;\n          const script_entry *p = &script_table[i];\n          if (strcmp (name + 3, p->script) < 0)\n            i2 = i;\n          else\n            i1 = i;\n        }\n      if (strcmp (name + 3, script_table[i1].script) == 0)\n        {\n          name[2] = '@';\n          strcpy (name + 3, script_table[i1].unixy);\n          return;\n        }\n    }\n\n  /* Step 3: Convert new-style dash to Unix underscore. */\n  {\n    char *p;\n    for (p = name; *p != '\\0'; p++)\n      if (*p == '-')\n        *p = '_';\n  }\n}",
        "lines": 264,
        "depth": 13,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          1423,
          0
        ],
        "end_point": [
          1447,
          1
        ],
        "content": "void\ngl_locale_name_canonicalize (char *name)\n{\n  /* FIXME: This is probably incomplete: it does not handle \"zh-Hans\" and\n     \"zh-Hant\".  */\n  char *p;\n\n  for (p = name; *p != '\\0'; p++)\n    if (*p == '-')\n      {\n        *p = '_';\n        p++;\n        for (; *p != '\\0'; p++)\n          {\n            if (*p >= 'a' && *p <= 'z')\n              *p += 'A' - 'a';\n            if (*p == '-')\n              {\n                *p = '\\0';\n                return;\n              }\n          }\n        return;\n      }\n}",
        "lines": 25,
        "depth": 13,
        "decorators": [
          "void"
        ]
      }
    ],
    "gl_locale_name_from_win32_LANGID": {
      "start_point": [
        1452,
        0
      ],
      "end_point": [
        2495,
        1
      ],
      "content": "const char *\ngl_locale_name_from_win32_LANGID (LANGID langid)\n{\n  /* Activate the new code only when the GETTEXT_MUI environment variable is\n     set, for the time being, since the new code is not well tested.  */\n  if (getenv (\"GETTEXT_MUI\") != NULL)\n    {\n      static char namebuf[256];\n\n      /* Query the system's notion of locale name.\n         On Windows95/98/ME, GetLocaleInfoA returns some incorrect results.\n         But we don't need to support systems that are so old.  */\n      if (GetLocaleInfoA (MAKELCID (langid, SORT_DEFAULT), LOCALE_SNAME,\n                          namebuf, sizeof (namebuf) - 1))\n        {\n          /* Convert it to a Unix locale name.  */\n          gl_locale_name_canonicalize (namebuf);\n          return namebuf;\n        }\n    }\n  /* Internet Explorer has an LCID to RFC3066 name mapping stored in\n     HKEY_CLASSES_ROOT\\Mime\\Database\\Rfc1766.  But we better don't use that\n     since IE's i18n subsystem is known to be inconsistent with the native\n     Windows base (e.g. they have different character conversion facilities\n     that produce different results).  */\n  /* Use our own table.  */\n  {\n    int primary, sub;\n\n    /* Split into language and territory part.  */\n    primary = PRIMARYLANGID (langid);\n    sub = SUBLANGID (langid);\n\n    /* Dispatch on language.\n       See also http://www.unicode.org/unicode/onlinedat/languages.html .\n       For details about languages, see http://www.ethnologue.com/ .  */\n    switch (primary)\n      {\n      case LANG_AFRIKAANS:\n        switch (sub)\n          {\n          case SUBLANG_AFRIKAANS_SOUTH_AFRICA: return \"af_ZA\";\n          }\n        return \"af\";\n      case LANG_ALBANIAN:\n        switch (sub)\n          {\n          case SUBLANG_ALBANIAN_ALBANIA: return \"sq_AL\";\n          }\n        return \"sq\";\n      case LANG_ALSATIAN:\n        switch (sub)\n          {\n          case SUBLANG_ALSATIAN_FRANCE: return \"gsw_FR\";\n          }\n        return \"gsw\";\n      case LANG_AMHARIC:\n        switch (sub)\n          {\n          case SUBLANG_AMHARIC_ETHIOPIA: return \"am_ET\";\n          }\n        return \"am\";\n      case LANG_ARABIC:\n        switch (sub)\n          {\n          case SUBLANG_ARABIC_SAUDI_ARABIA: return \"ar_SA\";\n          case SUBLANG_ARABIC_IRAQ: return \"ar_IQ\";\n          case SUBLANG_ARABIC_EGYPT: return \"ar_EG\";\n          case SUBLANG_ARABIC_LIBYA: return \"ar_LY\";\n          case SUBLANG_ARABIC_ALGERIA: return \"ar_DZ\";\n          case SUBLANG_ARABIC_MOROCCO: return \"ar_MA\";\n          case SUBLANG_ARABIC_TUNISIA: return \"ar_TN\";\n          case SUBLANG_ARABIC_OMAN: return \"ar_OM\";\n          case SUBLANG_ARABIC_YEMEN: return \"ar_YE\";\n          case SUBLANG_ARABIC_SYRIA: return \"ar_SY\";\n          case SUBLANG_ARABIC_JORDAN: return \"ar_JO\";\n          case SUBLANG_ARABIC_LEBANON: return \"ar_LB\";\n          case SUBLANG_ARABIC_KUWAIT: return \"ar_KW\";\n          case SUBLANG_ARABIC_UAE: return \"ar_AE\";\n          case SUBLANG_ARABIC_BAHRAIN: return \"ar_BH\";\n          case SUBLANG_ARABIC_QATAR: return \"ar_QA\";\n          }\n        return \"ar\";\n      case LANG_ARMENIAN:\n        switch (sub)\n          {\n          case SUBLANG_ARMENIAN_ARMENIA: return \"hy_AM\";\n          }\n        return \"hy\";\n      case LANG_ASSAMESE:\n        switch (sub)\n          {\n          case SUBLANG_ASSAMESE_INDIA: return \"as_IN\";\n          }\n        return \"as\";\n      case LANG_AZERI:\n        switch (sub)\n          {\n          /* FIXME: Adjust this when Azerbaijani locales appear on Unix.  */\n          case 0x1e: return \"az@latin\";\n          case SUBLANG_AZERI_LATIN: return \"az_AZ@latin\";\n          case 0x1d: return \"az@cyrillic\";\n          case SUBLANG_AZERI_CYRILLIC: return \"az_AZ@cyrillic\";\n          }\n        return \"az\";\n      case LANG_BASHKIR:\n        switch (sub)\n          {\n          case SUBLANG_BASHKIR_RUSSIA: return \"ba_RU\";\n          }\n        return \"ba\";\n      case LANG_BASQUE:\n        switch (sub)\n          {\n          case SUBLANG_BASQUE_BASQUE: return \"eu_ES\";\n          }\n        return \"eu\"; /* Ambiguous: could be \"eu_ES\" or \"eu_FR\".  */\n      case LANG_BELARUSIAN:\n        switch (sub)\n          {\n          case SUBLANG_BELARUSIAN_BELARUS: return \"be_BY\";\n          }\n        return \"be\";\n      case LANG_BENGALI:\n        switch (sub)\n          {\n          case SUBLANG_BENGALI_INDIA: return \"bn_IN\";\n          case SUBLANG_BENGALI_BANGLADESH: return \"bn_BD\";\n          }\n        return \"bn\";\n      case LANG_BRETON:\n        switch (sub)\n          {\n          case SUBLANG_BRETON_FRANCE: return \"br_FR\";\n          }\n        return \"br\";\n      case LANG_BULGARIAN:\n        switch (sub)\n          {\n          case SUBLANG_BULGARIAN_BULGARIA: return \"bg_BG\";\n          }\n        return \"bg\";\n      case LANG_BURMESE:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"my_MM\";\n          }\n        return \"my\";\n      case LANG_CAMBODIAN:\n        switch (sub)\n          {\n          case SUBLANG_CAMBODIAN_CAMBODIA: return \"km_KH\";\n          }\n        return \"km\";\n      case LANG_CATALAN:\n        switch (sub)\n          {\n          case SUBLANG_CATALAN_SPAIN: return \"ca_ES\";\n          }\n        return \"ca\";\n      case LANG_CHEROKEE:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"chr_US\";\n          }\n        return \"chr\";\n      case LANG_CHINESE:\n        switch (sub)\n          {\n          case SUBLANG_CHINESE_TRADITIONAL: case 0x1f: return \"zh_TW\";\n          case SUBLANG_CHINESE_SIMPLIFIED: case 0x00: return \"zh_CN\";\n          case SUBLANG_CHINESE_HONGKONG: return \"zh_HK\"; /* traditional */\n          case SUBLANG_CHINESE_SINGAPORE: return \"zh_SG\"; /* simplified */\n          case SUBLANG_CHINESE_MACAU: return \"zh_MO\"; /* traditional */\n          }\n        return \"zh\";\n      case LANG_CORSICAN:\n        switch (sub)\n          {\n          case SUBLANG_CORSICAN_FRANCE: return \"co_FR\";\n          }\n        return \"co\";\n      case LANG_CROATIAN:      /* LANG_CROATIAN == LANG_SERBIAN == LANG_BOSNIAN\n                                * What used to be called Serbo-Croatian\n                                * should really now be two separate\n                                * languages because of political reasons.\n                                * (Says tml, who knows nothing about Serbian\n                                * or Croatian.)\n                                * (I can feel those flames coming already.)\n                                */\n        switch (sub)\n          {\n          /* Croatian */\n          case 0x00: return \"hr\";\n          case SUBLANG_CROATIAN_CROATIA: return \"hr_HR\";\n          case SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN: return \"hr_BA\";\n          /* Serbian */\n          case 0x1f: return \"sr\";\n          case 0x1c: return \"sr\"; /* latin */\n          case SUBLANG_SERBIAN_LATIN: return \"sr_CS\"; /* latin */\n          case 0x09: return \"sr_RS\"; /* latin */\n          case 0x0b: return \"sr_ME\"; /* latin */\n          case 0x06: return \"sr_BA\"; /* latin */\n          case 0x1b: return \"sr@cyrillic\";\n          case SUBLANG_SERBIAN_CYRILLIC: return \"sr_CS@cyrillic\";\n          case 0x0a: return \"sr_RS@cyrillic\";\n          case 0x0c: return \"sr_ME@cyrillic\";\n          case 0x07: return \"sr_BA@cyrillic\";\n          /* Bosnian */\n          case 0x1e: return \"bs\";\n          case 0x1a: return \"bs\"; /* latin */\n          case SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN: return \"bs_BA\"; /* latin */\n          case 0x19: return \"bs@cyrillic\";\n          case SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC: return \"bs_BA@cyrillic\";\n          }\n        return \"hr\";\n      case LANG_CZECH:\n        switch (sub)\n          {\n          case SUBLANG_CZECH_CZECH_REPUBLIC: return \"cs_CZ\";\n          }\n        return \"cs\";\n      case LANG_DANISH:\n        switch (sub)\n          {\n          case SUBLANG_DANISH_DENMARK: return \"da_DK\";\n          }\n        return \"da\";\n      case LANG_DARI:\n        /* FIXME: Adjust this when such locales appear on Unix.  */\n        switch (sub)\n          {\n          case SUBLANG_DARI_AFGHANISTAN: return \"prs_AF\";\n          }\n        return \"prs\";\n      case LANG_DIVEHI:\n        switch (sub)\n          {\n          case SUBLANG_DIVEHI_MALDIVES: return \"dv_MV\";\n          }\n        return \"dv\";\n      case LANG_DUTCH:\n        switch (sub)\n          {\n          case SUBLANG_DUTCH: return \"nl_NL\";\n          case SUBLANG_DUTCH_BELGIAN: /* FLEMISH, VLAAMS */ return \"nl_BE\";\n          case SUBLANG_DUTCH_SURINAM: return \"nl_SR\";\n          }\n        return \"nl\";\n      case LANG_EDO:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"bin_NG\";\n          }\n        return \"bin\";\n      case LANG_ENGLISH:\n        switch (sub)\n          {\n          /* SUBLANG_ENGLISH_US == SUBLANG_DEFAULT. Heh. I thought\n           * English was the language spoken in England.\n           * Oh well.\n           */\n          case SUBLANG_ENGLISH_US: return \"en_US\";\n          case SUBLANG_ENGLISH_UK: return \"en_GB\";\n          case SUBLANG_ENGLISH_AUS: return \"en_AU\";\n          case SUBLANG_ENGLISH_CAN: return \"en_CA\";\n          case SUBLANG_ENGLISH_NZ: return \"en_NZ\";\n          case SUBLANG_ENGLISH_EIRE: return \"en_IE\";\n          case SUBLANG_ENGLISH_SOUTH_AFRICA: return \"en_ZA\";\n          case SUBLANG_ENGLISH_JAMAICA: return \"en_JM\";\n          case SUBLANG_ENGLISH_CARIBBEAN: return \"en_GD\"; /* Grenada? */\n          case SUBLANG_ENGLISH_BELIZE: return \"en_BZ\";\n          case SUBLANG_ENGLISH_TRINIDAD: return \"en_TT\";\n          case SUBLANG_ENGLISH_ZIMBABWE: return \"en_ZW\";\n          case SUBLANG_ENGLISH_PHILIPPINES: return \"en_PH\";\n          case SUBLANG_ENGLISH_INDONESIA: return \"en_ID\";\n          case SUBLANG_ENGLISH_HONGKONG: return \"en_HK\";\n          case SUBLANG_ENGLISH_INDIA: return \"en_IN\";\n          case SUBLANG_ENGLISH_MALAYSIA: return \"en_MY\";\n          case SUBLANG_ENGLISH_SINGAPORE: return \"en_SG\";\n          }\n        return \"en\";\n      case LANG_ESTONIAN:\n        switch (sub)\n          {\n          case SUBLANG_ESTONIAN_ESTONIA: return \"et_EE\";\n          }\n        return \"et\";\n      case LANG_FAEROESE:\n        switch (sub)\n          {\n          case SUBLANG_FAEROESE_FAROE_ISLANDS: return \"fo_FO\";\n          }\n        return \"fo\";\n      case LANG_FARSI:\n        switch (sub)\n          {\n          case SUBLANG_FARSI_IRAN: return \"fa_IR\";\n          }\n        return \"fa\";\n      case LANG_FINNISH:\n        switch (sub)\n          {\n          case SUBLANG_FINNISH_FINLAND: return \"fi_FI\";\n          }\n        return \"fi\";\n      case LANG_FRENCH:\n        switch (sub)\n          {\n          case SUBLANG_FRENCH: return \"fr_FR\";\n          case SUBLANG_FRENCH_BELGIAN: /* WALLOON */ return \"fr_BE\";\n          case SUBLANG_FRENCH_CANADIAN: return \"fr_CA\";\n          case SUBLANG_FRENCH_SWISS: return \"fr_CH\";\n          case SUBLANG_FRENCH_LUXEMBOURG: return \"fr_LU\";\n          case SUBLANG_FRENCH_MONACO: return \"fr_MC\";\n          case SUBLANG_FRENCH_WESTINDIES: return \"fr\"; /* Caribbean? */\n          case SUBLANG_FRENCH_REUNION: return \"fr_RE\";\n          case SUBLANG_FRENCH_CONGO: return \"fr_CG\";\n          case SUBLANG_FRENCH_SENEGAL: return \"fr_SN\";\n          case SUBLANG_FRENCH_CAMEROON: return \"fr_CM\";\n          case SUBLANG_FRENCH_COTEDIVOIRE: return \"fr_CI\";\n          case SUBLANG_FRENCH_MALI: return \"fr_ML\";\n          case SUBLANG_FRENCH_MOROCCO: return \"fr_MA\";\n          case SUBLANG_FRENCH_HAITI: return \"fr_HT\";\n          }\n        return \"fr\";\n      case LANG_FRISIAN:\n        switch (sub)\n          {\n          case SUBLANG_FRISIAN_NETHERLANDS: return \"fy_NL\";\n          }\n        return \"fy\";\n      case LANG_FULFULDE:\n        /* Spoken in Nigeria, Guinea, Senegal, Mali, Niger, Cameroon, Benin.  */\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"ff_NG\";\n          }\n        return \"ff\";\n      case LANG_GAELIC:\n        switch (sub)\n          {\n          case 0x01: /* SCOTTISH */\n            /* old, superseded by LANG_SCOTTISH_GAELIC */\n            return \"gd_GB\";\n          case SUBLANG_IRISH_IRELAND: return \"ga_IE\";\n          }\n        return \"ga\";\n      case LANG_GALICIAN:\n        switch (sub)\n          {\n          case SUBLANG_GALICIAN_SPAIN: return \"gl_ES\";\n          }\n        return \"gl\";\n      case LANG_GEORGIAN:\n        switch (sub)\n          {\n          case SUBLANG_GEORGIAN_GEORGIA: return \"ka_GE\";\n          }\n        return \"ka\";\n      case LANG_GERMAN:\n        switch (sub)\n          {\n          case SUBLANG_GERMAN: return \"de_DE\";\n          case SUBLANG_GERMAN_SWISS: return \"de_CH\";\n          case SUBLANG_GERMAN_AUSTRIAN: return \"de_AT\";\n          case SUBLANG_GERMAN_LUXEMBOURG: return \"de_LU\";\n          case SUBLANG_GERMAN_LIECHTENSTEIN: return \"de_LI\";\n          }\n        return \"de\";\n      case LANG_GREEK:\n        switch (sub)\n          {\n          case SUBLANG_GREEK_GREECE: return \"el_GR\";\n          }\n        return \"el\";\n      case LANG_GREENLANDIC:\n        switch (sub)\n          {\n          case SUBLANG_GREENLANDIC_GREENLAND: return \"kl_GL\";\n          }\n        return \"kl\";\n      case LANG_GUARANI:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"gn_PY\";\n          }\n        return \"gn\";\n      case LANG_GUJARATI:\n        switch (sub)\n          {\n          case SUBLANG_GUJARATI_INDIA: return \"gu_IN\";\n          }\n        return \"gu\";\n      case LANG_HAUSA:\n        switch (sub)\n          {\n          case 0x1f: return \"ha\";\n          case SUBLANG_HAUSA_NIGERIA_LATIN: return \"ha_NG\";\n          }\n        return \"ha\";\n      case LANG_HAWAIIAN:\n        /* FIXME: Do they mean Hawaiian (\"haw_US\", 1000 speakers)\n           or Hawaii Creole English (\"cpe_US\", 600000 speakers)?  */\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"cpe_US\";\n          }\n        return \"cpe\";\n      case LANG_HEBREW:\n        switch (sub)\n          {\n          case SUBLANG_HEBREW_ISRAEL: return \"he_IL\";\n          }\n        return \"he\";\n      case LANG_HINDI:\n        switch (sub)\n          {\n          case SUBLANG_HINDI_INDIA: return \"hi_IN\";\n          }\n        return \"hi\";\n      case LANG_HUNGARIAN:\n        switch (sub)\n          {\n          case SUBLANG_HUNGARIAN_HUNGARY: return \"hu_HU\";\n          }\n        return \"hu\";\n      case LANG_IBIBIO:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"nic_NG\";\n          }\n        return \"nic\";\n      case LANG_ICELANDIC:\n        switch (sub)\n          {\n          case SUBLANG_ICELANDIC_ICELAND: return \"is_IS\";\n          }\n        return \"is\";\n      case LANG_IGBO:\n        switch (sub)\n          {\n          case SUBLANG_IGBO_NIGERIA: return \"ig_NG\";\n          }\n        return \"ig\";\n      case LANG_INDONESIAN:\n        switch (sub)\n          {\n          case SUBLANG_INDONESIAN_INDONESIA: return \"id_ID\";\n          }\n        return \"id\";\n      case LANG_INUKTITUT:\n        switch (sub)\n          {\n          case 0x1e: return \"iu\"; /* syllabic */\n          case SUBLANG_INUKTITUT_CANADA: return \"iu_CA\"; /* syllabic */\n          case 0x1f: return \"iu@latin\";\n          case SUBLANG_INUKTITUT_CANADA_LATIN: return \"iu_CA@latin\";\n          }\n        return \"iu\";\n      case LANG_ITALIAN:\n        switch (sub)\n          {\n          case SUBLANG_ITALIAN: return \"it_IT\";\n          case SUBLANG_ITALIAN_SWISS: return \"it_CH\";\n          }\n        return \"it\";\n      case LANG_JAPANESE:\n        switch (sub)\n          {\n          case SUBLANG_JAPANESE_JAPAN: return \"ja_JP\";\n          }\n        return \"ja\";\n      case LANG_KANNADA:\n        switch (sub)\n          {\n          case SUBLANG_KANNADA_INDIA: return \"kn_IN\";\n          }\n        return \"kn\";\n      case LANG_KANURI:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"kr_NG\";\n          }\n        return \"kr\";\n      case LANG_KASHMIRI:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"ks_PK\";\n          case SUBLANG_KASHMIRI_INDIA: return \"ks_IN\";\n          }\n        return \"ks\";\n      case LANG_KAZAK:\n        switch (sub)\n          {\n          case SUBLANG_KAZAK_KAZAKHSTAN: return \"kk_KZ\";\n          }\n        return \"kk\";\n      case LANG_KICHE:\n        /* FIXME: Adjust this when such locales appear on Unix.  */\n        switch (sub)\n          {\n          case SUBLANG_KICHE_GUATEMALA: return \"qut_GT\";\n          }\n        return \"qut\";\n      case LANG_KINYARWANDA:\n        switch (sub)\n          {\n          case SUBLANG_KINYARWANDA_RWANDA: return \"rw_RW\";\n          }\n        return \"rw\";\n      case LANG_KONKANI:\n        /* FIXME: Adjust this when such locales appear on Unix.  */\n        switch (sub)\n          {\n          case SUBLANG_KONKANI_INDIA: return \"kok_IN\";\n          }\n        return \"kok\";\n      case LANG_KOREAN:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"ko_KR\";\n          }\n        return \"ko\";\n      case LANG_KYRGYZ:\n        switch (sub)\n          {\n          case SUBLANG_KYRGYZ_KYRGYZSTAN: return \"ky_KG\";\n          }\n        return \"ky\";\n      case LANG_LAO:\n        switch (sub)\n          {\n          case SUBLANG_LAO_LAOS: return \"lo_LA\";\n          }\n        return \"lo\";\n      case LANG_LATIN:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"la_VA\";\n          }\n        return \"la\";\n      case LANG_LATVIAN:\n        switch (sub)\n          {\n          case SUBLANG_LATVIAN_LATVIA: return \"lv_LV\";\n          }\n        return \"lv\";\n      case LANG_LITHUANIAN:\n        switch (sub)\n          {\n          case SUBLANG_LITHUANIAN_LITHUANIA: return \"lt_LT\";\n          }\n        return \"lt\";\n      case LANG_LUXEMBOURGISH:\n        switch (sub)\n          {\n          case SUBLANG_LUXEMBOURGISH_LUXEMBOURG: return \"lb_LU\";\n          }\n        return \"lb\";\n      case LANG_MACEDONIAN:\n        switch (sub)\n          {\n          case SUBLANG_MACEDONIAN_MACEDONIA: return \"mk_MK\";\n          }\n        return \"mk\";\n      case LANG_MALAY:\n        switch (sub)\n          {\n          case SUBLANG_MALAY_MALAYSIA: return \"ms_MY\";\n          case SUBLANG_MALAY_BRUNEI_DARUSSALAM: return \"ms_BN\";\n          }\n        return \"ms\";\n      case LANG_MALAYALAM:\n        switch (sub)\n          {\n          case SUBLANG_MALAYALAM_INDIA: return \"ml_IN\";\n          }\n        return \"ml\";\n      case LANG_MALTESE:\n        switch (sub)\n          {\n          case SUBLANG_MALTESE_MALTA: return \"mt_MT\";\n          }\n        return \"mt\";\n      case LANG_MANIPURI:\n        /* FIXME: Adjust this when such locales appear on Unix.  */\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"mni_IN\";\n          }\n        return \"mni\";\n      case LANG_MAORI:\n        switch (sub)\n          {\n          case SUBLANG_MAORI_NEW_ZEALAND: return \"mi_NZ\";\n          }\n        return \"mi\";\n      case LANG_MAPUDUNGUN:\n        switch (sub)\n          {\n          case SUBLANG_MAPUDUNGUN_CHILE: return \"arn_CL\";\n          }\n        return \"arn\";\n      case LANG_MARATHI:\n        switch (sub)\n          {\n          case SUBLANG_MARATHI_INDIA: return \"mr_IN\";\n          }\n        return \"mr\";\n      case LANG_MOHAWK:\n        switch (sub)\n          {\n          case SUBLANG_MOHAWK_CANADA: return \"moh_CA\";\n          }\n        return \"moh\";\n      case LANG_MONGOLIAN:\n        switch (sub)\n          {\n          case SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA: case 0x1e: return \"mn_MN\";\n          case SUBLANG_MONGOLIAN_PRC: case 0x1f: return \"mn_CN\";\n          }\n        return \"mn\"; /* Ambiguous: could be \"mn_CN\" or \"mn_MN\".  */\n      case LANG_NEPALI:\n        switch (sub)\n          {\n          case SUBLANG_NEPALI_NEPAL: return \"ne_NP\";\n          case SUBLANG_NEPALI_INDIA: return \"ne_IN\";\n          }\n        return \"ne\";\n      case LANG_NORWEGIAN:\n        switch (sub)\n          {\n          case 0x1f: return \"nb\";\n          case SUBLANG_NORWEGIAN_BOKMAL: return \"nb_NO\";\n          case 0x1e: return \"nn\";\n          case SUBLANG_NORWEGIAN_NYNORSK: return \"nn_NO\";\n          }\n        return \"no\";\n      case LANG_OCCITAN:\n        switch (sub)\n          {\n          case SUBLANG_OCCITAN_FRANCE: return \"oc_FR\";\n          }\n        return \"oc\";\n      case LANG_ORIYA:\n        switch (sub)\n          {\n          case SUBLANG_ORIYA_INDIA: return \"or_IN\";\n          }\n        return \"or\";\n      case LANG_OROMO:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"om_ET\";\n          }\n        return \"om\";\n      case LANG_PAPIAMENTU:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"pap_AN\";\n          }\n        return \"pap\";\n      case LANG_PASHTO:\n        switch (sub)\n          {\n          case SUBLANG_PASHTO_AFGHANISTAN: return \"ps_AF\";\n          }\n        return \"ps\"; /* Ambiguous: could be \"ps_PK\" or \"ps_AF\".  */\n      case LANG_POLISH:\n        switch (sub)\n          {\n          case SUBLANG_POLISH_POLAND: return \"pl_PL\";\n          }\n        return \"pl\";\n      case LANG_PORTUGUESE:\n        switch (sub)\n          {\n          /* Hmm. SUBLANG_PORTUGUESE_BRAZILIAN == SUBLANG_DEFAULT.\n             Same phenomenon as SUBLANG_ENGLISH_US == SUBLANG_DEFAULT. */\n          case SUBLANG_PORTUGUESE_BRAZILIAN: return \"pt_BR\";\n          case SUBLANG_PORTUGUESE: return \"pt_PT\";\n          }\n        return \"pt\";\n      case LANG_PUNJABI:\n        switch (sub)\n          {\n          case SUBLANG_PUNJABI_INDIA: return \"pa_IN\"; /* Gurmukhi script */\n          case SUBLANG_PUNJABI_PAKISTAN: return \"pa_PK\"; /* Arabic script */\n          }\n        return \"pa\";\n      case LANG_QUECHUA:\n        /* Note: Microsoft uses the non-ISO language code \"quz\".  */\n        switch (sub)\n          {\n          case SUBLANG_QUECHUA_BOLIVIA: return \"qu_BO\";\n          case SUBLANG_QUECHUA_ECUADOR: return \"qu_EC\";\n          case SUBLANG_QUECHUA_PERU: return \"qu_PE\";\n          }\n        return \"qu\";\n      case LANG_ROMANIAN:\n        switch (sub)\n          {\n          case SUBLANG_ROMANIAN_ROMANIA: return \"ro_RO\";\n          case SUBLANG_ROMANIAN_MOLDOVA: return \"ro_MD\";\n          }\n        return \"ro\";\n      case LANG_ROMANSH:\n        switch (sub)\n          {\n          case SUBLANG_ROMANSH_SWITZERLAND: return \"rm_CH\";\n          }\n        return \"rm\";\n      case LANG_RUSSIAN:\n        switch (sub)\n          {\n          case SUBLANG_RUSSIAN_RUSSIA: return \"ru_RU\";\n          case SUBLANG_RUSSIAN_MOLDAVIA: return \"ru_MD\";\n          }\n        return \"ru\"; /* Ambiguous: could be \"ru_RU\" or \"ru_UA\" or \"ru_MD\".  */\n      case LANG_SAMI:\n        switch (sub)\n          {\n          /* Northern Sami */\n          case 0x00: return \"se\";\n          case SUBLANG_SAMI_NORTHERN_NORWAY: return \"se_NO\";\n          case SUBLANG_SAMI_NORTHERN_SWEDEN: return \"se_SE\";\n          case SUBLANG_SAMI_NORTHERN_FINLAND: return \"se_FI\";\n          /* Lule Sami */\n          case 0x1f: return \"smj\";\n          case SUBLANG_SAMI_LULE_NORWAY: return \"smj_NO\";\n          case SUBLANG_SAMI_LULE_SWEDEN: return \"smj_SE\";\n          /* Southern Sami */\n          case 0x1e: return \"sma\";\n          case SUBLANG_SAMI_SOUTHERN_NORWAY: return \"sma_NO\";\n          case SUBLANG_SAMI_SOUTHERN_SWEDEN: return \"sma_SE\";\n          /* Skolt Sami */\n          case 0x1d: return \"sms\";\n          case SUBLANG_SAMI_SKOLT_FINLAND: return \"sms_FI\";\n          /* Inari Sami */\n          case 0x1c: return \"smn\";\n          case SUBLANG_SAMI_INARI_FINLAND: return \"smn_FI\";\n          }\n        return \"se\"; /* or \"smi\"? */\n      case LANG_SANSKRIT:\n        switch (sub)\n          {\n          case SUBLANG_SANSKRIT_INDIA: return \"sa_IN\";\n          }\n        return \"sa\";\n      case LANG_SCOTTISH_GAELIC:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"gd_GB\";\n          }\n        return \"gd\";\n      case LANG_SINDHI:\n        switch (sub)\n          {\n          case SUBLANG_SINDHI_INDIA: return \"sd_IN\";\n          case SUBLANG_SINDHI_PAKISTAN: return \"sd_PK\";\n          /*case SUBLANG_SINDHI_AFGHANISTAN: return \"sd_AF\";*/\n          }\n        return \"sd\";\n      case LANG_SINHALESE:\n        switch (sub)\n          {\n          case SUBLANG_SINHALESE_SRI_LANKA: return \"si_LK\";\n          }\n        return \"si\";\n      case LANG_SLOVAK:\n        switch (sub)\n          {\n          case SUBLANG_SLOVAK_SLOVAKIA: return \"sk_SK\";\n          }\n        return \"sk\";\n      case LANG_SLOVENIAN:\n        switch (sub)\n          {\n          case SUBLANG_SLOVENIAN_SLOVENIA: return \"sl_SI\";\n          }\n        return \"sl\";\n      case LANG_SOMALI:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"so_SO\";\n          }\n        return \"so\";\n      case LANG_SORBIAN:\n        /* FIXME: Adjust this when such locales appear on Unix.  */\n        switch (sub)\n          {\n          /* Upper Sorbian */\n          case 0x00: return \"hsb\";\n          case SUBLANG_UPPER_SORBIAN_GERMANY: return \"hsb_DE\";\n          /* Lower Sorbian */\n          case 0x1f: return \"dsb\";\n          case SUBLANG_LOWER_SORBIAN_GERMANY: return \"dsb_DE\";\n          }\n        return \"wen\";\n      case LANG_SOTHO:\n        /* <http://www.microsoft.com/globaldev/reference/lcid-all.mspx> calls\n           it \"Sepedi\"; according to\n           <http://www.ethnologue.com/show_language.asp?code=nso>\n           <http://www.ethnologue.com/show_language.asp?code=sot>\n           it's the same as Northern Sotho.  */\n        switch (sub)\n          {\n          case SUBLANG_SOTHO_SOUTH_AFRICA: return \"nso_ZA\";\n          }\n        return \"nso\";\n      case LANG_SPANISH:\n        switch (sub)\n          {\n          case SUBLANG_SPANISH: return \"es_ES\";\n          case SUBLANG_SPANISH_MEXICAN: return \"es_MX\";\n          case SUBLANG_SPANISH_MODERN:\n            return \"es_ES@modern\";      /* not seen on Unix */\n          case SUBLANG_SPANISH_GUATEMALA: return \"es_GT\";\n          case SUBLANG_SPANISH_COSTA_RICA: return \"es_CR\";\n          case SUBLANG_SPANISH_PANAMA: return \"es_PA\";\n          case SUBLANG_SPANISH_DOMINICAN_REPUBLIC: return \"es_DO\";\n          case SUBLANG_SPANISH_VENEZUELA: return \"es_VE\";\n          case SUBLANG_SPANISH_COLOMBIA: return \"es_CO\";\n          case SUBLANG_SPANISH_PERU: return \"es_PE\";\n          case SUBLANG_SPANISH_ARGENTINA: return \"es_AR\";\n          case SUBLANG_SPANISH_ECUADOR: return \"es_EC\";\n          case SUBLANG_SPANISH_CHILE: return \"es_CL\";\n          case SUBLANG_SPANISH_URUGUAY: return \"es_UY\";\n          case SUBLANG_SPANISH_PARAGUAY: return \"es_PY\";\n          case SUBLANG_SPANISH_BOLIVIA: return \"es_BO\";\n          case SUBLANG_SPANISH_EL_SALVADOR: return \"es_SV\";\n          case SUBLANG_SPANISH_HONDURAS: return \"es_HN\";\n          case SUBLANG_SPANISH_NICARAGUA: return \"es_NI\";\n          case SUBLANG_SPANISH_PUERTO_RICO: return \"es_PR\";\n          case SUBLANG_SPANISH_US: return \"es_US\";\n          }\n        return \"es\";\n      case LANG_SUTU:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"bnt_TZ\"; /* or \"st_LS\" or \"nso_ZA\"? */\n          }\n        return \"bnt\";\n      case LANG_SWAHILI:\n        switch (sub)\n          {\n          case SUBLANG_SWAHILI_KENYA: return \"sw_KE\";\n          }\n        return \"sw\";\n      case LANG_SWEDISH:\n        switch (sub)\n          {\n          case SUBLANG_SWEDISH_SWEDEN: return \"sv_SE\";\n          case SUBLANG_SWEDISH_FINLAND: return \"sv_FI\";\n          }\n        return \"sv\";\n      case LANG_SYRIAC:\n        switch (sub)\n          {\n          case SUBLANG_SYRIAC_SYRIA: return \"syr_SY\"; /* An extinct language.  */\n          }\n        return \"syr\";\n      case LANG_TAGALOG:\n        switch (sub)\n          {\n          case SUBLANG_TAGALOG_PHILIPPINES: return \"tl_PH\"; /* or \"fil_PH\"? */\n          }\n        return \"tl\"; /* or \"fil\"? */\n      case LANG_TAJIK:\n        switch (sub)\n          {\n          case 0x1f: return \"tg\";\n          case SUBLANG_TAJIK_TAJIKISTAN: return \"tg_TJ\";\n          }\n        return \"tg\";\n      case LANG_TAMAZIGHT:\n        /* Note: Microsoft uses the non-ISO language code \"tmz\".  */\n        switch (sub)\n          {\n          /* FIXME: Adjust this when Tamazight locales appear on Unix.  */\n          case SUBLANG_TAMAZIGHT_ARABIC: return \"ber_MA@arabic\";\n          case 0x1f: return \"ber@latin\";\n          case SUBLANG_TAMAZIGHT_ALGERIA_LATIN: return \"ber_DZ@latin\";\n          }\n        return \"ber\";\n      case LANG_TAMIL:\n        switch (sub)\n          {\n          case SUBLANG_TAMIL_INDIA: return \"ta_IN\";\n          }\n        return \"ta\"; /* Ambiguous: could be \"ta_IN\" or \"ta_LK\" or \"ta_SG\".  */\n      case LANG_TATAR:\n        switch (sub)\n          {\n          case SUBLANG_TATAR_RUSSIA: return \"tt_RU\";\n          }\n        return \"tt\";\n      case LANG_TELUGU:\n        switch (sub)\n          {\n          case SUBLANG_TELUGU_INDIA: return \"te_IN\";\n          }\n        return \"te\";\n      case LANG_THAI:\n        switch (sub)\n          {\n          case SUBLANG_THAI_THAILAND: return \"th_TH\";\n          }\n        return \"th\";\n      case LANG_TIBETAN:\n        switch (sub)\n          {\n          case SUBLANG_TIBETAN_PRC:\n            /* Most Tibetans would not like \"bo_CN\".  But Tibet does not yet\n               have a country code of its own.  */\n            return \"bo\";\n          case SUBLANG_TIBETAN_BHUTAN: return \"bo_BT\";\n          }\n        return \"bo\";\n      case LANG_TIGRINYA:\n        switch (sub)\n          {\n          case SUBLANG_TIGRINYA_ETHIOPIA: return \"ti_ET\";\n          case SUBLANG_TIGRINYA_ERITREA: return \"ti_ER\";\n          }\n        return \"ti\";\n      case LANG_TSONGA:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"ts_ZA\";\n          }\n        return \"ts\";\n      case LANG_TSWANA:\n        /* Spoken in South Africa, Botswana.  */\n        switch (sub)\n          {\n          case SUBLANG_TSWANA_SOUTH_AFRICA: return \"tn_ZA\";\n          }\n        return \"tn\";\n      case LANG_TURKISH:\n        switch (sub)\n          {\n          case SUBLANG_TURKISH_TURKEY: return \"tr_TR\";\n          }\n        return \"tr\";\n      case LANG_TURKMEN:\n        switch (sub)\n          {\n          case SUBLANG_TURKMEN_TURKMENISTAN: return \"tk_TM\";\n          }\n        return \"tk\";\n      case LANG_UIGHUR:\n        switch (sub)\n          {\n          case SUBLANG_UIGHUR_PRC: return \"ug_CN\";\n          }\n        return \"ug\";\n      case LANG_UKRAINIAN:\n        switch (sub)\n          {\n          case SUBLANG_UKRAINIAN_UKRAINE: return \"uk_UA\";\n          }\n        return \"uk\";\n      case LANG_URDU:\n        switch (sub)\n          {\n          case SUBLANG_URDU_PAKISTAN: return \"ur_PK\";\n          case SUBLANG_URDU_INDIA: return \"ur_IN\";\n          }\n        return \"ur\";\n      case LANG_UZBEK:\n        switch (sub)\n          {\n          case 0x1f: return \"uz\";\n          case SUBLANG_UZBEK_LATIN: return \"uz_UZ\";\n          case 0x1e: return \"uz@cyrillic\";\n          case SUBLANG_UZBEK_CYRILLIC: return \"uz_UZ@cyrillic\";\n          }\n        return \"uz\";\n      case LANG_VENDA:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"ve_ZA\";\n          }\n        return \"ve\";\n      case LANG_VIETNAMESE:\n        switch (sub)\n          {\n          case SUBLANG_VIETNAMESE_VIETNAM: return \"vi_VN\";\n          }\n        return \"vi\";\n      case LANG_WELSH:\n        switch (sub)\n          {\n          case SUBLANG_WELSH_UNITED_KINGDOM: return \"cy_GB\";\n          }\n        return \"cy\";\n      case LANG_WOLOF:\n        switch (sub)\n          {\n          case SUBLANG_WOLOF_SENEGAL: return \"wo_SN\";\n          }\n        return \"wo\";\n      case LANG_XHOSA:\n        switch (sub)\n          {\n          case SUBLANG_XHOSA_SOUTH_AFRICA: return \"xh_ZA\";\n          }\n        return \"xh\";\n      case LANG_YAKUT:\n        switch (sub)\n          {\n          case SUBLANG_YAKUT_RUSSIA: return \"sah_RU\";\n          }\n        return \"sah\";\n      case LANG_YI:\n        switch (sub)\n          {\n          case SUBLANG_YI_PRC: return \"ii_CN\";\n          }\n        return \"ii\";\n      case LANG_YIDDISH:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"yi_IL\";\n          }\n        return \"yi\";\n      case LANG_YORUBA:\n        switch (sub)\n          {\n          case SUBLANG_YORUBA_NIGERIA: return \"yo_NG\";\n          }\n        return \"yo\";\n      case LANG_ZULU:\n        switch (sub)\n          {\n          case SUBLANG_ZULU_SOUTH_AFRICA: return \"zu_ZA\";\n          }\n        return \"zu\";\n      default: return \"C\";\n      }\n  }\n}",
      "lines": 1044,
      "depth": 12,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_from_win32_LANGID (LANGID langid)",
        "*"
      ]
    },
    "gl_locale_name_from_win32_LCID": {
      "start_point": [
        2500,
        0
      ],
      "end_point": [
        2509,
        1
      ],
      "content": "const char *\ngl_locale_name_from_win32_LCID (LCID lcid)\n{\n  LANGID langid;\n\n  /* Strip off the sorting rules, keep only the language part.  */\n  langid = LANGIDFROMLCID (lcid);\n\n  return gl_locale_name_from_win32_LANGID (langid);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_from_win32_LCID (LCID lcid)",
        "*"
      ]
    },
    "enum_locales_fn": {
      "start_point": [
        2519,
        0
      ],
      "end_point": [
        2545,
        1
      ],
      "content": "static BOOL CALLBACK\nenum_locales_fn (LPTSTR locale_num_str)\n{\n  char *endp;\n  char locval[2 * LOCALE_NAME_MAX_LENGTH + 1 + 1];\n  LCID try_lcid = strtoul (locale_num_str, &endp, 16);\n\n  if (GetLocaleInfo (try_lcid, LOCALE_SENGLANGUAGE,\n                    locval, LOCALE_NAME_MAX_LENGTH))\n    {\n      strcat (locval, \"_\");\n      if (GetLocaleInfo (try_lcid, LOCALE_SENGCOUNTRY,\n                        locval + strlen (locval), LOCALE_NAME_MAX_LENGTH))\n       {\n         size_t locval_len = strlen (locval);\n\n         if (strncmp (locval, lname, locval_len) == 0\n             && (lname[locval_len] == '.'\n                 || lname[locval_len] == '\\0'))\n           {\n             found_lcid = try_lcid;\n             return FALSE;\n           }\n       }\n    }\n  return TRUE;\n}",
      "lines": 27,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "BOOL",
        "CALLBACK",
        "CALLBACK"
      ]
    },
    "get_lcid": {
      "start_point": [
        2554,
        0
      ],
      "end_point": [
        2580,
        1
      ],
      "content": "static LCID\nget_lcid (const char *locale_name)\n{\n  /* A simple cache.  */\n  static LCID last_lcid;\n  static char last_locale[1000];\n\n  /* Lock while looking for an LCID, to protect access to static\n     variables: last_lcid, last_locale, found_lcid, and lname.  */\n  gl_lock_lock (get_lcid_lock);\n  if (last_lcid > 0 && strcmp (locale_name, last_locale) == 0)\n    {\n      gl_lock_unlock (get_lcid_lock);\n      return last_lcid;\n    }\n  strncpy (lname, locale_name, sizeof (lname) - 1);\n  lname[sizeof (lname) - 1] = '\\0';\n  found_lcid = 0;\n  EnumSystemLocales (enum_locales_fn, LCID_SUPPORTED);\n  if (found_lcid > 0)\n    {\n      last_lcid = found_lcid;\n      strcpy (last_locale, locale_name);\n    }\n  gl_lock_unlock (get_lcid_lock);\n  return found_lcid;\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "LCID"
      ]
    },
    "string_hash": {
      "start_point": [
        2596,
        0
      ],
      "end_point": [
        2606,
        1
      ],
      "content": "static size_t _GL_ATTRIBUTE_PURE\nstring_hash (const void *x)\n{\n  const char *s = (const char *) x;\n  size_t h = 0;\n\n  for (; *s; s++)\n    h = *s + ((h << 9) | (h >> (SIZE_BITS - 9)));\n\n  return h;\n}",
      "lines": 11,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "size_t",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "struniq": {
      "start_point": [
        2628,
        0
      ],
      "end_point": [
        2666,
        1
      ],
      "content": "static const char *\nstruniq (const char *string)\n{\n  size_t hashcode = string_hash (string);\n  size_t slot = hashcode % HASH_TABLE_SIZE;\n  size_t size;\n  struct hash_node *new_node;\n  struct hash_node *p;\n  for (p = struniq_hash_table[slot]; p != NULL; p = p->next)\n    if (strcmp (p->contents, string) == 0)\n      return p->contents;\n  size = strlen (string) + 1;\n  new_node =\n    (struct hash_node *)\n    malloc (offsetof (struct hash_node, contents[0]) + size);\n  if (new_node == NULL)\n    /* Out of memory.  Return a statically allocated string.  */\n    return \"C\";\n  memcpy (new_node->contents, string, size);\n  /* Lock while inserting new_node.  */\n  gl_lock_lock (struniq_lock);\n  /* Check whether another thread already added the string while we were\n     waiting on the lock.  */\n  for (p = struniq_hash_table[slot]; p != NULL; p = p->next)\n    if (strcmp (p->contents, string) == 0)\n      {\n        free (new_node);\n        new_node = p;\n        goto done;\n      }\n  /* Really insert new_node into the hash table.  Fill new_node entirely first,\n     because other threads may be iterating over the linked list.  */\n  new_node->next = struniq_hash_table[slot];\n  struniq_hash_table[slot] = new_node;\n done:\n  /* Unlock after new_node is inserted.  */\n  gl_lock_unlock (struniq_lock);\n  return new_node->contents;\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nstruniq (const char *string)",
        "*"
      ]
    },
    "gl_locale_name_thread_unsafe": {
      "start_point": [
        2678,
        0
      ],
      "end_point": [
        2730,
        1
      ],
      "content": "const char *\ngl_locale_name_thread_unsafe (int category, const char *categoryname)\n{\n# if HAVE_USELOCALE\n  {\n    locale_t thread_locale = uselocale (NULL);\n    if (thread_locale != LC_GLOBAL_LOCALE)\n      {\n#  if __GLIBC__ >= 2 && !defined __UCLIBC__\n        /* Work around an incorrect definition of the _NL_LOCALE_NAME macro in\n           glibc < 2.12.\n           See <http://sourceware.org/bugzilla/show_bug.cgi?id=10968>.  */\n        const char *name =\n          nl_langinfo (_NL_ITEM ((category), _NL_ITEM_INDEX (-1)));\n        if (name[0] == '\\0')\n          /* Fallback code for glibc < 2.4, which did not implement\n             nl_langinfo (_NL_LOCALE_NAME (category)).  */\n          name = thread_locale->__names[category];\n        return name;\n#  elif defined __FreeBSD__ || (defined __APPLE__ && defined __MACH__)\n        /* FreeBSD, Mac OS X */\n        int mask;\n\n        switch (category)\n          {\n          case LC_CTYPE:\n            mask = LC_CTYPE_MASK;\n            break;\n          case LC_NUMERIC:\n            mask = LC_NUMERIC_MASK;\n            break;\n          case LC_TIME:\n            mask = LC_TIME_MASK;\n            break;\n          case LC_COLLATE:\n            mask = LC_COLLATE_MASK;\n            break;\n          case LC_MONETARY:\n            mask = LC_MONETARY_MASK;\n            break;\n          case LC_MESSAGES:\n            mask = LC_MESSAGES_MASK;\n            break;\n          default: /* We shouldn't get here.  */\n            return \"\";\n          }\n        return querylocale (mask, thread_locale);\n#  endif\n      }\n  }\n# endif\n  return NULL;\n}",
      "lines": 53,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_thread_unsafe (int category, const char *categoryname)",
        "*"
      ]
    },
    "gl_locale_name_thread": {
      "start_point": [
        2734,
        0
      ],
      "end_point": [
        2764,
        1
      ],
      "content": "const char *\ngl_locale_name_thread (int category, const char *categoryname)\n{\n#if HAVE_USELOCALE\n  const char *name = gl_locale_name_thread_unsafe (category, categoryname);\n  if (name != NULL)\n    return struniq (name);\n#elif defined WINDOWS_NATIVE\n  if (LC_MIN <= category && category <= LC_MAX)\n    {\n      char *locname = setlocale (category, NULL);\n      LCID lcid = 0;\n\n      /* If CATEGORY is LC_ALL, the result might be a semi-colon\n        separated list of locales.  We need only one, so we take the\n        one corresponding to LC_CTYPE, as the most important for\n        character translations.  */\n      if (strchr (locname, ';'))\n       locname = setlocale (LC_CTYPE, NULL);\n\n      /* Convert locale name to LCID.  We don't want to use\n         LocaleNameToLCID because (a) it is only available since Vista,\n         and (b) it doesn't accept locale names returned by 'setlocale'.  */\n      lcid = get_lcid (locname);\n\n      if (lcid > 0)\n        return gl_locale_name_from_win32_LCID (lcid);\n    }\n#endif\n  return NULL;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_thread (int category, const char *categoryname)",
        "*"
      ]
    },
    "gl_locale_name_posix": {
      "start_point": [
        2776,
        0
      ],
      "end_point": [
        2803,
        1
      ],
      "content": "const char *\ngl_locale_name_posix (int category, const char *categoryname)\n{\n  /* Use the POSIX methods of looking to 'LC_ALL', 'LC_xxx', and 'LANG'.\n     On some systems this can be done by the 'setlocale' function itself.  */\n#if defined HAVE_SETLOCALE && defined HAVE_LC_MESSAGES && defined HAVE_LOCALE_NULL\n  return setlocale (category, NULL);\n#else\n  /* On other systems we ignore what setlocale reports and instead look at the\n     environment variables directly.  This is necessary\n       1. on systems which have a facility for customizing the default locale\n          (Mac OS X, native Windows, Cygwin) and where the system's setlocale()\n          function ignores this default locale (Mac OS X, Cygwin), in two cases:\n          a. when the user missed to use the setlocale() override from libintl\n             (for example by not including <libintl.h>),\n          b. when setlocale supports only the \"C\" locale, such as on Cygwin\n             1.5.x.  In this case even the override from libintl cannot help.\n       2. on all systems where setlocale supports only the \"C\" locale.  */\n  /* Strictly speaking, it is a POSIX violation to look at the environment\n     variables regardless whether setlocale has been called or not.  POSIX\n     says:\n         \"For C-language programs, the POSIX locale shall be the\n          default locale when the setlocale() function is not called.\"\n     But we assume that all programs that use internationalized APIs call\n     setlocale (LC_ALL, \"\").  */\n  return gl_locale_name_environ (category, categoryname);\n#endif\n}",
      "lines": 28,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_posix (int category, const char *categoryname)",
        "*"
      ]
    },
    "gl_locale_name_environ": {
      "start_point": [
        2805,
        0
      ],
      "end_point": [
        2836,
        1
      ],
      "content": "const char *\ngl_locale_name_environ (int category, const char *categoryname)\n{\n  const char *retval;\n\n  /* Setting of LC_ALL overrides all other.  */\n  retval = getenv (\"LC_ALL\");\n  if (retval != NULL && retval[0] != '\\0')\n    return retval;\n  /* Next comes the name of the desired category.  */\n  retval = getenv (categoryname);\n  if (retval != NULL && retval[0] != '\\0')\n    return retval;\n  /* Last possibility is the LANG environment variable.  */\n  retval = getenv (\"LANG\");\n  if (retval != NULL && retval[0] != '\\0')\n    {\n#if HAVE_CFLOCALECOPYCURRENT || HAVE_CFPREFERENCESCOPYAPPVALUE\n      /* Mac OS X 10.2 or newer.\n         Ignore invalid LANG value set by the Terminal application.  */\n      if (strcmp (retval, \"UTF-8\") != 0)\n#endif\n#if defined __CYGWIN__\n      /* Cygwin.\n         Ignore dummy LANG value set by ~/.profile.  */\n      if (strcmp (retval, \"C.UTF-8\") != 0)\n#endif\n        return retval;\n    }\n\n  return NULL;\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_environ (int category, const char *categoryname)",
        "*"
      ]
    },
    "gl_locale_name_default": {
      "start_point": [
        2838,
        0
      ],
      "end_point": [
        2935,
        1
      ],
      "content": "const char *\ngl_locale_name_default (void)\n{\n  /* POSIX:2001 says:\n     \"All implementations shall define a locale as the default locale, to be\n      invoked when no environment variables are set, or set to the empty\n      string.  This default locale can be the POSIX locale or any other\n      implementation-defined locale.  Some implementations may provide\n      facilities for local installation administrators to set the default\n      locale, customizing it for each location.  POSIX:2001 does not require\n      such a facility.\n\n     The systems with such a facility are Mac OS X and Windows: They provide a\n     GUI that allows the user to choose a locale.\n       - On Mac OS X, by default, none of LC_* or LANG are set.  Starting with\n         Mac OS X 10.4 or 10.5, LANG is set for processes launched by the\n         'Terminal' application (but sometimes to an incorrect value \"UTF-8\").\n         When no environment variable is set, setlocale (LC_ALL, \"\") uses the\n         \"C\" locale.\n       - On native Windows, by default, none of LC_* or LANG are set.\n         When no environment variable is set, setlocale (LC_ALL, \"\") uses the\n         locale chosen by the user.\n       - On Cygwin 1.5.x, by default, none of LC_* or LANG are set.\n         When no environment variable is set, setlocale (LC_ALL, \"\") uses the\n         \"C\" locale.\n       - On Cygwin 1.7, by default, LANG is set to \"C.UTF-8\" when the default\n         ~/.profile is executed.\n         When no environment variable is set, setlocale (LC_ALL, \"\") uses the\n         \"C.UTF-8\" locale, which operates in the same way as the \"C\" locale.\n  */\n\n#if !(HAVE_CFLOCALECOPYCURRENT || HAVE_CFPREFERENCESCOPYAPPVALUE || defined WINDOWS_NATIVE || defined __CYGWIN__)\n\n  /* The system does not have a way of setting the locale, other than the\n     POSIX specified environment variables.  We use C as default locale.  */\n  return \"C\";\n\n#else\n\n  /* Return an XPG style locale name language[_territory][@modifier].\n     Don't even bother determining the codeset; it's not useful in this\n     context, because message catalogs are not specific to a single\n     codeset.  */\n\n# if HAVE_CFLOCALECOPYCURRENT || HAVE_CFPREFERENCESCOPYAPPVALUE\n  /* Mac OS X 10.2 or newer */\n  {\n    /* Cache the locale name, since CoreFoundation calls are expensive.  */\n    static const char *cached_localename;\n\n    if (cached_localename == NULL)\n      {\n        char namebuf[256];\n#  if HAVE_CFLOCALECOPYCURRENT /* Mac OS X 10.3 or newer */\n        CFLocaleRef locale = CFLocaleCopyCurrent ();\n        CFStringRef name = CFLocaleGetIdentifier (locale);\n\n        if (CFStringGetCString (name, namebuf, sizeof (namebuf),\n                                kCFStringEncodingASCII))\n          {\n            gl_locale_name_canonicalize (namebuf);\n            cached_localename = strdup (namebuf);\n          }\n        CFRelease (locale);\n#  elif HAVE_CFPREFERENCESCOPYAPPVALUE /* Mac OS X 10.2 or newer */\n        CFTypeRef value =\n          CFPreferencesCopyAppValue (CFSTR (\"AppleLocale\"),\n                                     kCFPreferencesCurrentApplication);\n        if (value != NULL\n            && CFGetTypeID (value) == CFStringGetTypeID ()\n            && CFStringGetCString ((CFStringRef)value,\n                                   namebuf, sizeof (namebuf),\n                                   kCFStringEncodingASCII))\n          {\n            gl_locale_name_canonicalize (namebuf);\n            cached_localename = strdup (namebuf);\n          }\n#  endif\n        if (cached_localename == NULL)\n          cached_localename = \"C\";\n      }\n    return cached_localename;\n  }\n\n# endif\n\n# if defined WINDOWS_NATIVE || defined __CYGWIN__ /* Native Windows or Cygwin */\n  {\n    LCID lcid;\n\n    /* Use native Windows API locale ID.  */\n    lcid = GetThreadLocale ();\n\n    return gl_locale_name_from_win32_LCID (lcid);\n  }\n# endif\n#endif\n}",
      "lines": 98,
      "depth": 18,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_default (void)",
        "*"
      ]
    },
    "gl_locale_name": {
      "start_point": [
        2943,
        0
      ],
      "end_point": [
        2957,
        1
      ],
      "content": "const char *\ngl_locale_name (int category, const char *categoryname)\n{\n  const char *retval;\n\n  retval = gl_locale_name_thread (category, categoryname);\n  if (retval != NULL)\n    return retval;\n\n  retval = gl_locale_name_posix (category, categoryname);\n  if (retval != NULL)\n    return retval;\n\n  return gl_locale_name_default ();\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name (int category, const char *categoryname)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/lock.c": {
    "glthread_rwlock_init_multithreaded": [
      {
        "start_point": [
          36,
          0
        ],
        "end_point": [
          46,
          1
        ],
        "content": "int\nglthread_rwlock_init_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_rwlock_init (&lock->rwlock, NULL);\n  if (err != 0)\n    return err;\n  lock->initialized = 1;\n  return 0;\n}",
        "lines": 11,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          126,
          0
        ],
        "end_point": [
          143,
          1
        ],
        "content": "int\nglthread_rwlock_init_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_init (&lock->lock, NULL);\n  if (err != 0)\n    return err;\n  err = pthread_cond_init (&lock->waiting_readers, NULL);\n  if (err != 0)\n    return err;\n  err = pthread_cond_init (&lock->waiting_writers, NULL);\n  if (err != 0)\n    return err;\n  lock->waiting_writers_count = 0;\n  lock->runcount = 0;\n  return 0;\n}",
        "lines": 18,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_rdlock_multithreaded": [
      {
        "start_point": [
          48,
          0
        ],
        "end_point": [
          72,
          1
        ],
        "content": "int\nglthread_rwlock_rdlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_rwlock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_rwlock_rdlock (&lock->rwlock);\n}",
        "lines": 25,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          145,
          0
        ],
        "end_point": [
          172,
          1
        ],
        "content": "int\nglthread_rwlock_rdlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n  /* Test whether only readers are currently running, and whether the runcount\n     field will not overflow.  */\n  /* POSIX says: \"It is implementation-defined whether the calling thread\n     acquires the lock when a writer does not hold the lock and there are\n     writers blocked on the lock.\"  Let's say, no: give the writers a higher\n     priority.  */\n  while (!(lock->runcount + 1 > 0 && lock->waiting_writers_count == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_readers.  */\n      err = pthread_cond_wait (&lock->waiting_readers, &lock->lock);\n      if (err != 0)\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return err;\n        }\n    }\n  lock->runcount++;\n  return pthread_mutex_unlock (&lock->lock);\n}",
        "lines": 28,
        "depth": 12,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_wrlock_multithreaded": [
      {
        "start_point": [
          74,
          0
        ],
        "end_point": [
          98,
          1
        ],
        "content": "int\nglthread_rwlock_wrlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_rwlock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_rwlock_wrlock (&lock->rwlock);\n}",
        "lines": 25,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          174,
          0
        ],
        "end_point": [
          199,
          1
        ],
        "content": "int\nglthread_rwlock_wrlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n  /* Test whether no readers or writers are currently running.  */\n  while (!(lock->runcount == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_writers.  */\n      lock->waiting_writers_count++;\n      err = pthread_cond_wait (&lock->waiting_writers, &lock->lock);\n      if (err != 0)\n        {\n          lock->waiting_writers_count--;\n          pthread_mutex_unlock (&lock->lock);\n          return err;\n        }\n      lock->waiting_writers_count--;\n    }\n  lock->runcount--; /* runcount becomes -1 */\n  return pthread_mutex_unlock (&lock->lock);\n}",
        "lines": 26,
        "depth": 12,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_unlock_multithreaded": [
      {
        "start_point": [
          100,
          0
        ],
        "end_point": [
          106,
          1
        ],
        "content": "int\nglthread_rwlock_unlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    return EINVAL;\n  return pthread_rwlock_unlock (&lock->rwlock);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          201,
          0
        ],
        "end_point": [
          255,
          1
        ],
        "content": "int\nglthread_rwlock_unlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n  if (lock->runcount < 0)\n    {\n      /* Drop a writer lock.  */\n      if (!(lock->runcount == -1))\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount = 0;\n    }\n  else\n    {\n      /* Drop a reader lock.  */\n      if (!(lock->runcount > 0))\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount--;\n    }\n  if (lock->runcount == 0)\n    {\n      /* POSIX recommends that \"write locks shall take precedence over read\n         locks\", to avoid \"writer starvation\".  */\n      if (lock->waiting_writers_count > 0)\n        {\n          /* Wake up one of the waiting writers.  */\n          err = pthread_cond_signal (&lock->waiting_writers);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->lock);\n              return err;\n            }\n        }\n      else\n        {\n          /* Wake up all waiting readers.  */\n          err = pthread_cond_broadcast (&lock->waiting_readers);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->lock);\n              return err;\n            }\n        }\n    }\n  return pthread_mutex_unlock (&lock->lock);\n}",
        "lines": 55,
        "depth": 14,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_destroy_multithreaded": [
      {
        "start_point": [
          108,
          0
        ],
        "end_point": [
          120,
          1
        ],
        "content": "int\nglthread_rwlock_destroy_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  if (!lock->initialized)\n    return EINVAL;\n  err = pthread_rwlock_destroy (&lock->rwlock);\n  if (err != 0)\n    return err;\n  lock->initialized = 0;\n  return 0;\n}",
        "lines": 13,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          257,
          0
        ],
        "end_point": [
          272,
          1
        ],
        "content": "int\nglthread_rwlock_destroy_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_destroy (&lock->lock);\n  if (err != 0)\n    return err;\n  err = pthread_cond_destroy (&lock->waiting_readers);\n  if (err != 0)\n    return err;\n  err = pthread_cond_destroy (&lock->waiting_writers);\n  if (err != 0)\n    return err;\n  return 0;\n}",
        "lines": 16,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_init_multithreaded": [
      {
        "start_point": [
          282,
          0
        ],
        "end_point": [
          307,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_mutexattr_t attributes;\n  int err;\n\n  err = pthread_mutexattr_init (&attributes);\n  if (err != 0)\n    return err;\n  err = pthread_mutexattr_settype (&attributes, PTHREAD_MUTEX_RECURSIVE);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutex_init (lock, &attributes);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutexattr_destroy (&attributes);\n  if (err != 0)\n    return err;\n  return 0;\n}",
        "lines": 26,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          311,
          0
        ],
        "end_point": [
          337,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_mutexattr_t attributes;\n  int err;\n\n  err = pthread_mutexattr_init (&attributes);\n  if (err != 0)\n    return err;\n  err = pthread_mutexattr_settype (&attributes, PTHREAD_MUTEX_RECURSIVE);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutex_init (&lock->recmutex, &attributes);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutexattr_destroy (&attributes);\n  if (err != 0)\n    return err;\n  lock->initialized = 1;\n  return 0;\n}",
        "lines": 27,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          391,
          0
        ],
        "end_point": [
          402,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_init (&lock->mutex, NULL);\n  if (err != 0)\n    return err;\n  lock->owner = (pthread_t) 0;\n  lock->depth = 0;\n  return 0;\n}",
        "lines": 12,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          530,
          0
        ],
        "end_point": [
          541,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  int err;\n\n  err = mutex_init (&lock->mutex, USYNC_THREAD, NULL);\n  if (err != 0)\n    return err;\n  lock->owner = (thread_t) 0;\n  lock->depth = 0;\n  return 0;\n}",
        "lines": 12,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_lock_multithreaded": [
      {
        "start_point": [
          339,
          0
        ],
        "end_point": [
          363,
          1
        ],
        "content": "int\nglthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_recursive_lock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_mutex_lock (&lock->recmutex);\n}",
        "lines": 25,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          404,
          0
        ],
        "end_point": [
          423,
          1
        ],
        "content": "int\nglthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_t self = pthread_self ();\n  if (lock->owner != self)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->mutex);\n      if (err != 0)\n        return err;\n      lock->owner = self;\n    }\n  if (++(lock->depth) == 0) /* wraparound? */\n    {\n      lock->depth--;\n      return EAGAIN;\n    }\n  return 0;\n}",
        "lines": 20,
        "depth": 11,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          543,
          0
        ],
        "end_point": [
          562,
          1
        ],
        "content": "int\nglthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock)\n{\n  thread_t self = thr_self ();\n  if (lock->owner != self)\n    {\n      int err;\n\n      err = mutex_lock (&lock->mutex);\n      if (err != 0)\n        return err;\n      lock->owner = self;\n    }\n  if (++(lock->depth) == 0) /* wraparound? */\n    {\n      lock->depth--;\n      return EAGAIN;\n    }\n  return 0;\n}",
        "lines": 20,
        "depth": 11,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_unlock_multithreaded": [
      {
        "start_point": [
          365,
          0
        ],
        "end_point": [
          371,
          1
        ],
        "content": "int\nglthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (!lock->initialized)\n    return EINVAL;\n  return pthread_mutex_unlock (&lock->recmutex);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          425,
          0
        ],
        "end_point": [
          439,
          1
        ],
        "content": "int\nglthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != pthread_self ())\n    return EPERM;\n  if (lock->depth == 0)\n    return EINVAL;\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = (pthread_t) 0;\n      return pthread_mutex_unlock (&lock->mutex);\n    }\n  else\n    return 0;\n}",
        "lines": 15,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          564,
          0
        ],
        "end_point": [
          578,
          1
        ],
        "content": "int\nglthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != thr_self ())\n    return EPERM;\n  if (lock->depth == 0)\n    return EINVAL;\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = (thread_t) 0;\n      return mutex_unlock (&lock->mutex);\n    }\n  else\n    return 0;\n}",
        "lines": 15,
        "depth": 10,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_destroy_multithreaded": [
      {
        "start_point": [
          373,
          0
        ],
        "end_point": [
          385,
          1
        ],
        "content": "int\nglthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock)\n{\n  int err;\n\n  if (!lock->initialized)\n    return EINVAL;\n  err = pthread_mutex_destroy (&lock->recmutex);\n  if (err != 0)\n    return err;\n  lock->initialized = 0;\n  return 0;\n}",
        "lines": 13,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          441,
          0
        ],
        "end_point": [
          447,
          1
        ],
        "content": "int\nglthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != (pthread_t) 0)\n    return EBUSY;\n  return pthread_mutex_destroy (&lock->mutex);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          580,
          0
        ],
        "end_point": [
          586,
          1
        ],
        "content": "int\nglthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != (thread_t) 0)\n    return EBUSY;\n  return mutex_destroy (&lock->mutex);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_once_singlethreaded": [
      {
        "start_point": [
          455,
          0
        ],
        "end_point": [
          469,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (pthread_once_t *once_control)\n{\n  /* We don't know whether pthread_once_t is an integer type, a floating-point\n     type, a pointer type, or a structure type.  */\n  char *firstbyte = (char *)once_control;\n  if (*firstbyte == *(const char *)&fresh_once)\n    {\n      /* First time use of once_control.  Invert the first byte.  */\n      *firstbyte = ~ *(const char *)&fresh_once;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 15,
        "depth": 12,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          502,
          0
        ],
        "end_point": [
          514,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (pth_once_t *once_control)\n{\n  /* We know that pth_once_t is an integer type.  */\n  if (*once_control == PTH_ONCE_INIT)\n    {\n      /* First time use of once_control.  Invert the marker.  */\n      *once_control = ~ PTH_ONCE_INIT;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 13,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          613,
          0
        ],
        "end_point": [
          625,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (gl_once_t *once_control)\n{\n  /* We know that gl_once_t contains an integer type.  */\n  if (!once_control->inited)\n    {\n      /* First time use of once_control.  Invert the marker.  */\n      once_control->inited = ~ 0;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 13,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_once_call": {
      "start_point": [
        487,
        0
      ],
      "end_point": [
        493,
        1
      ],
      "content": "static void\nglthread_once_call (void *arg)\n{\n  void (**gl_once_temp_addr) (void) = (void (**) (void)) arg;\n  void (*initfunction) (void) = *gl_once_temp_addr;\n  initfunction ();\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glthread_once_multithreaded": [
      {
        "start_point": [
          495,
          0
        ],
        "end_point": [
          500,
          1
        ],
        "content": "int\nglthread_once_multithreaded (pth_once_t *once_control, void (*initfunction) (void))\n{\n  void (*temp) (void) = initfunction;\n  return (!pth_once (once_control, glthread_once_call, &temp) ? errno : 0);\n}",
        "lines": 6,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          590,
          0
        ],
        "end_point": [
          611,
          1
        ],
        "content": "int\nglthread_once_multithreaded (gl_once_t *once_control, void (*initfunction) (void))\n{\n  if (!once_control->inited)\n    {\n      int err;\n\n      /* Use the mutex to guarantee that if another thread is already calling\n         the initfunction, this thread waits until it's finished.  */\n      err = mutex_lock (&once_control->mutex);\n      if (err != 0)\n        return err;\n      if (!once_control->inited)\n        {\n          once_control->inited = 1;\n          initfunction ();\n        }\n      return mutex_unlock (&once_control->mutex);\n    }\n  else\n    return 0;\n}",
        "lines": 22,
        "depth": 11,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_lock_init_func": {
      "start_point": [
        635,
        0
      ],
      "end_point": [
        640,
        1
      ],
      "content": "void\nglthread_lock_init_func (gl_lock_t *lock)\n{\n  InitializeCriticalSection (&lock->lock);\n  lock->guard.done = 1;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glthread_lock_lock_func": {
      "start_point": [
        642,
        0
      ],
      "end_point": [
        658,
        1
      ],
      "content": "int\nglthread_lock_lock_func (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_lock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glthread_lock_unlock_func": {
      "start_point": [
        660,
        0
      ],
      "end_point": [
        667,
        1
      ],
      "content": "int\nglthread_lock_unlock_func (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "glthread_lock_destroy_func": {
      "start_point": [
        669,
        0
      ],
      "end_point": [
        677,
        1
      ],
      "content": "int\nglthread_lock_destroy_func (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  DeleteCriticalSection (&lock->lock);\n  lock->guard.done = 0;\n  return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "gl_waitqueue_init": {
      "start_point": [
        684,
        0
      ],
      "end_point": [
        691,
        1
      ],
      "content": "static void\ngl_waitqueue_init (gl_waitqueue_t *wq)\n{\n  wq->array = NULL;\n  wq->count = 0;\n  wq->alloc = 0;\n  wq->offset = 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gl_waitqueue_add": {
      "start_point": [
        695,
        0
      ],
      "end_point": [
        742,
        1
      ],
      "content": "static HANDLE\ngl_waitqueue_add (gl_waitqueue_t *wq)\n{\n  HANDLE event;\n  unsigned int index;\n\n  if (wq->count == wq->alloc)\n    {\n      unsigned int new_alloc = 2 * wq->alloc + 1;\n      HANDLE *new_array =\n        (HANDLE *) realloc (wq->array, new_alloc * sizeof (HANDLE));\n      if (new_array == NULL)\n        /* No more memory.  */\n        return INVALID_HANDLE_VALUE;\n      /* Now is a good opportunity to rotate the array so that its contents\n         starts at offset 0.  */\n      if (wq->offset > 0)\n        {\n          unsigned int old_count = wq->count;\n          unsigned int old_alloc = wq->alloc;\n          unsigned int old_offset = wq->offset;\n          unsigned int i;\n          if (old_offset + old_count > old_alloc)\n            {\n              unsigned int limit = old_offset + old_count - old_alloc;\n              for (i = 0; i < limit; i++)\n                new_array[old_alloc + i] = new_array[i];\n            }\n          for (i = 0; i < old_count; i++)\n            new_array[i] = new_array[old_offset + i];\n          wq->offset = 0;\n        }\n      wq->array = new_array;\n      wq->alloc = new_alloc;\n    }\n  /* Whether the created event is a manual-reset one or an auto-reset one,\n     does not matter, since we will wait on it only once.  */\n  event = CreateEvent (NULL, TRUE, FALSE, NULL);\n  if (event == INVALID_HANDLE_VALUE)\n    /* No way to allocate an event.  */\n    return INVALID_HANDLE_VALUE;\n  index = wq->offset + wq->count;\n  if (index >= wq->alloc)\n    index -= wq->alloc;\n  wq->array[index] = event;\n  wq->count++;\n  return event;\n}",
      "lines": 48,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "HANDLE"
      ]
    },
    "gl_waitqueue_notify_first": {
      "start_point": [
        745,
        0
      ],
      "end_point": [
        753,
        1
      ],
      "content": "static void\ngl_waitqueue_notify_first (gl_waitqueue_t *wq)\n{\n  SetEvent (wq->array[wq->offset + 0]);\n  wq->offset++;\n  wq->count--;\n  if (wq->count == 0 || wq->offset == wq->alloc)\n    wq->offset = 0;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gl_waitqueue_notify_all": {
      "start_point": [
        756,
        0
      ],
      "end_point": [
        770,
        1
      ],
      "content": "static void\ngl_waitqueue_notify_all (gl_waitqueue_t *wq)\n{\n  unsigned int i;\n\n  for (i = 0; i < wq->count; i++)\n    {\n      unsigned int index = wq->offset + i;\n      if (index >= wq->alloc)\n        index -= wq->alloc;\n      SetEvent (wq->array[index]);\n    }\n  wq->count = 0;\n  wq->offset = 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glthread_rwlock_init_func": {
      "start_point": [
        772,
        0
      ],
      "end_point": [
        780,
        1
      ],
      "content": "void\nglthread_rwlock_init_func (gl_rwlock_t *lock)\n{\n  InitializeCriticalSection (&lock->lock);\n  gl_waitqueue_init (&lock->waiting_readers);\n  gl_waitqueue_init (&lock->waiting_writers);\n  lock->runcount = 0;\n  lock->guard.done = 1;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glthread_rwlock_rdlock_func": {
      "start_point": [
        782,
        0
      ],
      "end_point": [
        834,
        1
      ],
      "content": "int\nglthread_rwlock_rdlock_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_rwlock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n  /* Test whether only readers are currently running, and whether the runcount\n     field will not overflow.  */\n  if (!(lock->runcount + 1 > 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_readers.  */\n      HANDLE event = gl_waitqueue_add (&lock->waiting_readers);\n      if (event != INVALID_HANDLE_VALUE)\n        {\n          DWORD result;\n          LeaveCriticalSection (&lock->lock);\n          /* Wait until another thread signals this event.  */\n          result = WaitForSingleObject (event, INFINITE);\n          if (result == WAIT_FAILED || result == WAIT_TIMEOUT)\n            abort ();\n          CloseHandle (event);\n          /* The thread which signalled the event already did the bookkeeping:\n             removed us from the waiting_readers, incremented lock->runcount.  */\n          if (!(lock->runcount > 0))\n            abort ();\n          return 0;\n        }\n      else\n        {\n          /* Allocation failure.  Weird.  */\n          do\n            {\n              LeaveCriticalSection (&lock->lock);\n              Sleep (1);\n              EnterCriticalSection (&lock->lock);\n            }\n          while (!(lock->runcount + 1 > 0));\n        }\n    }\n  lock->runcount++;\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 53,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_wrlock_func": {
      "start_point": [
        836,
        0
      ],
      "end_point": [
        887,
        1
      ],
      "content": "int\nglthread_rwlock_wrlock_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_rwlock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n  /* Test whether no readers or writers are currently running.  */\n  if (!(lock->runcount == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_writers.  */\n      HANDLE event = gl_waitqueue_add (&lock->waiting_writers);\n      if (event != INVALID_HANDLE_VALUE)\n        {\n          DWORD result;\n          LeaveCriticalSection (&lock->lock);\n          /* Wait until another thread signals this event.  */\n          result = WaitForSingleObject (event, INFINITE);\n          if (result == WAIT_FAILED || result == WAIT_TIMEOUT)\n            abort ();\n          CloseHandle (event);\n          /* The thread which signalled the event already did the bookkeeping:\n             removed us from the waiting_writers, set lock->runcount = -1.  */\n          if (!(lock->runcount == -1))\n            abort ();\n          return 0;\n        }\n      else\n        {\n          /* Allocation failure.  Weird.  */\n          do\n            {\n              LeaveCriticalSection (&lock->lock);\n              Sleep (1);\n              EnterCriticalSection (&lock->lock);\n            }\n          while (!(lock->runcount == 0));\n        }\n    }\n  lock->runcount--; /* runcount becomes -1 */\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 52,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_unlock_func": {
      "start_point": [
        889,
        0
      ],
      "end_point": [
        931,
        1
      ],
      "content": "int\nglthread_rwlock_unlock_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  EnterCriticalSection (&lock->lock);\n  if (lock->runcount < 0)\n    {\n      /* Drop a writer lock.  */\n      if (!(lock->runcount == -1))\n        abort ();\n      lock->runcount = 0;\n    }\n  else\n    {\n      /* Drop a reader lock.  */\n      if (!(lock->runcount > 0))\n        {\n          LeaveCriticalSection (&lock->lock);\n          return EPERM;\n        }\n      lock->runcount--;\n    }\n  if (lock->runcount == 0)\n    {\n      /* POSIX recommends that \"write locks shall take precedence over read\n         locks\", to avoid \"writer starvation\".  */\n      if (lock->waiting_writers.count > 0)\n        {\n          /* Wake up one of the waiting writers.  */\n          lock->runcount--;\n          gl_waitqueue_notify_first (&lock->waiting_writers);\n        }\n      else\n        {\n          /* Wake up all waiting readers.  */\n          lock->runcount += lock->waiting_readers.count;\n          gl_waitqueue_notify_all (&lock->waiting_readers);\n        }\n    }\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_destroy_func": {
      "start_point": [
        933,
        0
      ],
      "end_point": [
        947,
        1
      ],
      "content": "int\nglthread_rwlock_destroy_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  if (lock->runcount != 0)\n    return EBUSY;\n  DeleteCriticalSection (&lock->lock);\n  if (lock->waiting_readers.array != NULL)\n    free (lock->waiting_readers.array);\n  if (lock->waiting_writers.array != NULL)\n    free (lock->waiting_writers.array);\n  lock->guard.done = 0;\n  return 0;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "glthread_recursive_lock_init_func": {
      "start_point": [
        951,
        0
      ],
      "end_point": [
        958,
        1
      ],
      "content": "void\nglthread_recursive_lock_init_func (gl_recursive_lock_t *lock)\n{\n  lock->owner = 0;\n  lock->depth = 0;\n  InitializeCriticalSection (&lock->lock);\n  lock->guard.done = 1;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glthread_recursive_lock_lock_func": {
      "start_point": [
        960,
        0
      ],
      "end_point": [
        988,
        1
      ],
      "content": "int\nglthread_recursive_lock_lock_func (gl_recursive_lock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_recursive_lock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  {\n    DWORD self = GetCurrentThreadId ();\n    if (lock->owner != self)\n      {\n        EnterCriticalSection (&lock->lock);\n        lock->owner = self;\n      }\n    if (++(lock->depth) == 0) /* wraparound? */\n      {\n        lock->depth--;\n        return EAGAIN;\n      }\n  }\n  return 0;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glthread_recursive_lock_unlock_func": {
      "start_point": [
        990,
        0
      ],
      "end_point": [
        1003,
        1
      ],
      "content": "int\nglthread_recursive_lock_unlock_func (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != GetCurrentThreadId ())\n    return EPERM;\n  if (lock->depth == 0)\n    return EINVAL;\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = 0;\n      LeaveCriticalSection (&lock->lock);\n    }\n  return 0;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "glthread_recursive_lock_destroy_func": {
      "start_point": [
        1005,
        0
      ],
      "end_point": [
        1013,
        1
      ],
      "content": "int\nglthread_recursive_lock_destroy_func (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != 0)\n    return EBUSY;\n  DeleteCriticalSection (&lock->lock);\n  lock->guard.done = 0;\n  return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "glthread_once_func": {
      "start_point": [
        1017,
        0
      ],
      "end_point": [
        1052,
        1
      ],
      "content": "void\nglthread_once_func (gl_once_t *once_control, void (*initfunction) (void))\n{\n  if (once_control->inited <= 0)\n    {\n      if (InterlockedIncrement (&once_control->started) == 0)\n        {\n          /* This thread is the first one to come to this once_control.  */\n          InitializeCriticalSection (&once_control->lock);\n          EnterCriticalSection (&once_control->lock);\n          once_control->inited = 0;\n          initfunction ();\n          once_control->inited = 1;\n          LeaveCriticalSection (&once_control->lock);\n        }\n      else\n        {\n          /* Undo last operation.  */\n          InterlockedDecrement (&once_control->started);\n          /* Some other thread has already started the initialization.\n             Yield the CPU while waiting for the other thread to finish\n             initializing and taking the lock.  */\n          while (once_control->inited < 0)\n            Sleep (0);\n          if (once_control->inited <= 0)\n            {\n              /* Take the lock.  This blocks until the other thread has\n                 finished calling the initfunction.  */\n              EnterCriticalSection (&once_control->lock);\n              LeaveCriticalSection (&once_control->lock);\n              if (!(once_control->inited > 0))\n                abort ();\n            }\n        }\n    }\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/lock.h": {},
  "sharutils/sharutils-4.15.2/intl/log.c": {
    "print_escaped": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static void\nprint_escaped (FILE *stream, const char *str, const char *str_end)\n{\n  putc ('\"', stream);\n  for (; str != str_end; str++)\n    if (*str == '\\n')\n      {\n        fputs (\"\\\\n\\\"\", stream);\n        if (str + 1 == str_end)\n          return;\n        fputs (\"\\n\\\"\", stream);\n      }\n    else\n      {\n        if (*str == '\"' || *str == '\\\\')\n          putc ('\\\\', stream);\n        putc (*str, stream);\n      }\n  putc ('\"', stream);\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_nl_log_untranslated_locked": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "static inline void\n_nl_log_untranslated_locked (const char *logfilename, const char *domainname,\n                             const char *msgid1, const char *msgid2, int plural)\n{\n  FILE *logfile;\n  const char *separator;\n\n  /* Can we reuse the last opened logfile?  */\n  if (last_logfilename == NULL || strcmp (logfilename, last_logfilename) != 0)\n    {\n      /* Close the last used logfile.  */\n      if (last_logfilename != NULL)\n        {\n          if (last_logfile != NULL)\n            {\n              fclose (last_logfile);\n              last_logfile = NULL;\n            }\n          free (last_logfilename);\n          last_logfilename = NULL;\n        }\n      /* Open the logfile.  */\n      last_logfilename = (char *) malloc (strlen (logfilename) + 1);\n      if (last_logfilename == NULL)\n        return;\n      strcpy (last_logfilename, logfilename);\n      last_logfile = fopen (logfilename, \"a\");\n      if (last_logfile == NULL)\n        return;\n    }\n  logfile = last_logfile;\n\n  fprintf (logfile, \"domain \");\n  print_escaped (logfile, domainname, domainname + strlen (domainname));\n  separator = strchr (msgid1, MSGCTXT_SEPARATOR);\n  if (separator != NULL)\n    {\n      /* The part before the MSGCTXT_SEPARATOR is the msgctxt.  */\n      fprintf (logfile, \"\\nmsgctxt \");\n      print_escaped (logfile, msgid1, separator);\n      msgid1 = separator + 1;\n    }\n  fprintf (logfile, \"\\nmsgid \");\n  print_escaped (logfile, msgid1, msgid1 + strlen (msgid1));\n  if (plural)\n    {\n      fprintf (logfile, \"\\nmsgid_plural \");\n      print_escaped (logfile, msgid2, msgid2 + strlen (msgid2));\n      fprintf (logfile, \"\\nmsgstr[0] \\\"\\\"\\n\");\n    }\n  else\n    fprintf (logfile, \"\\nmsgstr \\\"\\\"\\n\");\n  putc ('\\n', logfile);\n}",
      "lines": 54,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "_nl_log_untranslated": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "void\n_nl_log_untranslated (const char *logfilename, const char *domainname,\n                      const char *msgid1, const char *msgid2, int plural)\n{\n  __libc_lock_lock (lock);\n  _nl_log_untranslated_locked (logfilename, domainname, msgid1, msgid2, plural);\n  __libc_lock_unlock (lock);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/ngettext.c": {
    "NGETTEXT": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "char *\nNGETTEXT (const char *msgid1, const char *msgid2, unsigned long int n)\n{\n  return DCNGETTEXT (NULL, msgid1, msgid2, n, LC_MESSAGES);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nNGETTEXT (const char *msgid1, const char *msgid2, unsigned long int n)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/os2compat.c": {
    "_nl_getenv": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "char *\n_nl_getenv (const char *name)\n{\n  unsigned char *value;\n  if (DosScanEnv (name, &value))\n    return NULL;\n  else\n    return value;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "char",
        "*\n_nl_getenv (const char *name)",
        "*"
      ]
    },
    "nlos2_initialize": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "static __attribute__((constructor)) void\nnlos2_initialize ()\n{\n  char *root = getenv (\"UNIXROOT\");\n  char *gnulocaledir = getenv (\"GNULOCALEDIR\");\n\n  _nlos2_libdir = gnulocaledir;\n  if (!_nlos2_libdir)\n    {\n      if (root)\n        {\n          size_t sl = strlen (root);\n          _nlos2_libdir = (char *) malloc (sl + strlen (LIBDIR) + 1);\n          memcpy (_nlos2_libdir, root, sl);\n          memcpy (_nlos2_libdir + sl, LIBDIR, strlen (LIBDIR) + 1);\n        }\n      else\n        _nlos2_libdir = LIBDIR;\n    }\n\n  _nlos2_localealiaspath = gnulocaledir;\n  if (!_nlos2_localealiaspath)\n    {\n      if (root)\n        {\n          size_t sl = strlen (root);\n          _nlos2_localealiaspath = (char *) malloc (sl + strlen (LOCALE_ALIAS_PATH) + 1);\n          memcpy (_nlos2_localealiaspath, root, sl);\n          memcpy (_nlos2_localealiaspath + sl, LOCALE_ALIAS_PATH, strlen (LOCALE_ALIAS_PATH) + 1);\n        }\n     else\n        _nlos2_localealiaspath = LOCALE_ALIAS_PATH;\n    }\n\n  _nlos2_localedir = gnulocaledir;\n  if (!_nlos2_localedir)\n    {\n      if (root)\n        {\n          size_t sl = strlen (root);\n          _nlos2_localedir = (char *) malloc (sl + strlen (LOCALEDIR) + 1);\n          memcpy (_nlos2_localedir, root, sl);\n          memcpy (_nlos2_localedir + sl, LOCALEDIR, strlen (LOCALEDIR) + 1);\n        }\n      else\n        _nlos2_localedir = LOCALEDIR;\n    }\n\n  if (strlen (_nlos2_localedir) <= MAXPATHLEN)\n    strcpy (libintl_nl_default_dirname, _nlos2_localedir);\n}",
      "lines": 51,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "__attribute__((constructor))",
        "__attribute__",
        "(",
        "(constructor)",
        "(",
        "constructor",
        ")",
        ")",
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/os2compat.h": {},
  "sharutils/sharutils-4.15.2/intl/osdep.c": {},
  "sharutils/sharutils-4.15.2/intl/plural-exp.c": {
    "init_germanic_plural": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "static void\ninit_germanic_plural ()\n{\n  if (plone.val.num == 0)\n    {\n      plvar.nargs = 0;\n      plvar.operation = var;\n\n      plone.nargs = 0;\n      plone.operation = num;\n      plone.val.num = 1;\n\n      GERMANIC_PLURAL.nargs = 2;\n      GERMANIC_PLURAL.operation = not_equal;\n      GERMANIC_PLURAL.val.args[0] = &plvar;\n      GERMANIC_PLURAL.val.args[1] = &plone;\n    }\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "EXTRACT_PLURAL_EXPRESSION": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "void\ninternal_function\nEXTRACT_PLURAL_EXPRESSION (const char *nullentry,\n\t\t\t   const struct expression **pluralp,\n\t\t\t   unsigned long int *npluralsp)\n{\n  if (nullentry != NULL)\n    {\n      const char *plural;\n      const char *nplurals;\n\n      plural = strstr (nullentry, \"plural=\");\n      nplurals = strstr (nullentry, \"nplurals=\");\n      if (plural == NULL || nplurals == NULL)\n\tgoto no_plural;\n      else\n\t{\n\t  char *endp;\n\t  unsigned long int n;\n\t  struct parse_args args;\n\n\t  /* First get the number.  */\n\t  nplurals += 9;\n\t  while (*nplurals != '\\0' && isspace ((unsigned char) *nplurals))\n\t    ++nplurals;\n\t  if (!(*nplurals >= '0' && *nplurals <= '9'))\n\t    goto no_plural;\n#if defined HAVE_STRTOUL || defined _LIBC\n\t  n = strtoul (nplurals, &endp, 10);\n#else\n\t  for (endp = nplurals, n = 0; *endp >= '0' && *endp <= '9'; endp++)\n\t    n = n * 10 + (*endp - '0');\n#endif\n\t  if (nplurals == endp)\n\t    goto no_plural;\n\t  *npluralsp = n;\n\n\t  /* Due to the restrictions bison imposes onto the interface of the\n\t     scanner function we have to put the input string and the result\n\t     passed up from the parser into the same structure which address\n\t     is passed down to the parser.  */\n\t  plural += 7;\n\t  args.cp = plural;\n\t  if (PLURAL_PARSE (&args) != 0)\n\t    goto no_plural;\n\t  *pluralp = args.res;\n\t}\n    }\n  else\n    {\n      /* By default we are using the Germanic form: singular form only\n         for `one', the plural form otherwise.  Yes, this is also what\n         English is using since English is a Germanic language.  */\n    no_plural:\n      INIT_GERMANIC_PLURAL ();\n      *pluralp = &GERMANIC_PLURAL;\n      *npluralsp = 2;\n    }\n}",
      "lines": 59,
      "depth": 16,
      "decorators": [
        "void",
        "internal_function",
        "internal_function"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/plural-exp.h": {},
  "sharutils/sharutils-4.15.2/intl/plural.c": {
    "new_exp": {
      "start_point": [
        215,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "static struct expression *\nnew_exp (int nargs, enum expression_operator op,\n\t struct expression * const *args)\n{\n  int i;\n  struct expression *newp;\n\n  /* If any of the argument could not be malloc'ed, just return NULL.  */\n  for (i = nargs - 1; i >= 0; i--)\n    if (args[i] == NULL)\n      goto fail;\n\n  /* Allocate a new expression.  */\n  newp = (struct expression *) malloc (sizeof (*newp));\n  if (newp != NULL)\n    {\n      newp->nargs = nargs;\n      newp->operation = op;\n      for (i = nargs - 1; i >= 0; i--)\n\tnewp->val.args[i] = args[i];\n      return newp;\n    }\n\n fail:\n  for (i = nargs - 1; i >= 0; i--)\n    FREE_EXPRESSION (args[i]);\n\n  return NULL;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "struct expression",
        "struct",
        "expression",
        "*\nnew_exp (int nargs, enum expression_operator op,\n\t struct expression * const *args)",
        "*"
      ]
    },
    "new_exp_0": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        249,
        1
      ],
      "content": "static inline struct expression *\nnew_exp_0 (enum expression_operator op)\n{\n  return new_exp (0, op, NULL);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct expression",
        "struct",
        "expression",
        "*\nnew_exp_0 (enum expression_operator op)",
        "*"
      ]
    },
    "new_exp_1": {
      "start_point": [
        251,
        0
      ],
      "end_point": [
        258,
        1
      ],
      "content": "static inline struct expression *\nnew_exp_1 (enum expression_operator op, struct expression *right)\n{\n  struct expression *args[1];\n\n  args[0] = right;\n  return new_exp (1, op, args);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct expression",
        "struct",
        "expression",
        "*\nnew_exp_1 (enum expression_operator op, struct expression *right)",
        "*"
      ]
    },
    "new_exp_2": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "static struct expression *\nnew_exp_2 (enum expression_operator op, struct expression *left,\n\t   struct expression *right)\n{\n  struct expression *args[2];\n\n  args[0] = left;\n  args[1] = right;\n  return new_exp (2, op, args);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct expression",
        "struct",
        "expression",
        "*\nnew_exp_2 (enum expression_operator op, struct expression *left,\n\t   struct expression *right)",
        "*"
      ]
    },
    "new_exp_3": {
      "start_point": [
        271,
        0
      ],
      "end_point": [
        281,
        1
      ],
      "content": "static inline struct expression *\nnew_exp_3 (enum expression_operator op, struct expression *bexp,\n\t   struct expression *tbranch, struct expression *fbranch)\n{\n  struct expression *args[3];\n\n  args[0] = bexp;\n  args[1] = tbranch;\n  args[2] = fbranch;\n  return new_exp (3, op, args);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct expression",
        "struct",
        "expression",
        "*\nnew_exp_3 (enum expression_operator op, struct expression *bexp,\n\t   struct expression *tbranch, struct expression *fbranch)",
        "*"
      ]
    },
    "yytnamerr": {
      "start_point": [
        998,
        0
      ],
      "end_point": [
        1035,
        1
      ],
      "content": "static YYSIZE_T\nyytnamerr (char *yyres, const char *yystr)\n{\n  if (*yystr == '\"')\n    {\n      YYSIZE_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n\tswitch (*++yyp)\n\t  {\n\t  case '\\'':\n\t  case ',':\n\t    goto do_not_strip_quotes;\n\n\t  case '\\\\':\n\t    if (*++yyp != '\\\\')\n\t      goto do_not_strip_quotes;\n\t    /* Fall through.  */\n\t  default:\n\t    if (yyres)\n\t      yyres[yyn] = *yyp;\n\t    yyn++;\n\t    break;\n\n\t  case '\"':\n\t    if (yyres)\n\t      yyres[yyn] = '\\0';\n\t    return yyn;\n\t  }\n    do_not_strip_quotes: ;\n    }\n\n  if (! yyres)\n    return yystrlen (yystr);\n\n  return yystpcpy (yyres, yystr) - yyres;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "yysyntax_error": {
      "start_point": [
        1046,
        0
      ],
      "end_point": [
        1175,
        1
      ],
      "content": "static int\nyysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,\n                yytype_int16 *yyssp, int yytoken)\n{\n  YYSIZE_T yysize0 = yytnamerr (YY_NULL, yytname[yytoken]);\n  YYSIZE_T yysize = yysize0;\n  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n  /* Internationalized format string. */\n  const char *yyformat = YY_NULL;\n  /* Arguments of yyformat. */\n  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n  /* Number of reported tokens (one for the \"unexpected\", one per\n     \"expected\"). */\n  int yycount = 0;\n\n  /* There are many possibilities here to consider:\n     - Assume YYFAIL is not used.  It's too flawed to consider.  See\n       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>\n       for details.  YYERROR is fine as it does not invoke this\n       function.\n     - If this state is a consistent state with a default action, then\n       the only way this function was invoked is if the default action\n       is an error action.  In that case, don't check for expected\n       tokens because there are none.\n     - The only way there can be no lookahead present (in yychar) is if\n       this state is a consistent state with a default action.  Thus,\n       detecting the absence of a lookahead is sufficient to determine\n       that there is no unexpected or expected token to report.  In that\n       case, just report a simple \"syntax error\".\n     - Don't assume there isn't a lookahead just because this state is a\n       consistent state with a default action.  There might have been a\n       previous inconsistent state, consistent state with a non-default\n       action, or user semantic action that manipulated yychar.\n     - Of course, the expected token list depends on states to have\n       correct lookahead information, and it depends on the parser not\n       to perform extra reductions after fetching a lookahead from the\n       scanner and before detecting a syntax error.  Thus, state merging\n       (from LALR or IELR) and default reductions corrupt the expected\n       token list.  However, the list is correct for canonical LR with\n       one exception: it will still contain any token that will not be\n       accepted due to an error action in a later state.\n  */\n  if (yytoken != YYEMPTY)\n    {\n      int yyn = yypact[*yyssp];\n      yyarg[yycount++] = yytname[yytoken];\n      if (!yypact_value_is_default (yyn))\n        {\n          /* Start YYX at -YYN if negative to avoid negative indexes in\n             YYCHECK.  In other words, skip the first -YYN actions for\n             this state because they are default actions.  */\n          int yyxbegin = yyn < 0 ? -yyn : 0;\n          /* Stay within bounds of both yycheck and yytname.  */\n          int yychecklim = YYLAST - yyn + 1;\n          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n          int yyx;\n\n          for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR\n                && !yytable_value_is_error (yytable[yyx + yyn]))\n              {\n                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n                  {\n                    yycount = 1;\n                    yysize = yysize0;\n                    break;\n                  }\n                yyarg[yycount++] = yytname[yyx];\n                {\n                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULL, yytname[yyx]);\n                  if (! (yysize <= yysize1\n                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n                    return 2;\n                  yysize = yysize1;\n                }\n              }\n        }\n    }\n\n  switch (yycount)\n    {\n# define YYCASE_(N, S)                      \\\n      case N:                               \\\n        yyformat = S;                       \\\n      break\n      YYCASE_(0, YY_(\"syntax error\"));\n      YYCASE_(1, YY_(\"syntax error, unexpected %s\"));\n      YYCASE_(2, YY_(\"syntax error, unexpected %s, expecting %s\"));\n      YYCASE_(3, YY_(\"syntax error, unexpected %s, expecting %s or %s\"));\n      YYCASE_(4, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\"));\n      YYCASE_(5, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\"));\n# undef YYCASE_\n    }\n\n  {\n    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);\n    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n      return 2;\n    yysize = yysize1;\n  }\n\n  if (*yymsg_alloc < yysize)\n    {\n      *yymsg_alloc = 2 * yysize;\n      if (! (yysize <= *yymsg_alloc\n             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))\n        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;\n      return 1;\n    }\n\n  /* Avoid sprintf, as that infringes on the user's name space.\n     Don't have undefined behavior even if the translation\n     produced a string with the wrong number of \"%s\"s.  */\n  {\n    char *yyp = *yymsg;\n    int yyi = 0;\n    while ((*yyp = *yyformat) != '\\0')\n      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)\n        {\n          yyp += yytnamerr (yyp, yyarg[yyi++]);\n          yyformat += 2;\n        }\n      else\n        {\n          yyp++;\n          yyformat++;\n        }\n  }\n  return 0;\n}",
      "lines": 130,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "FREE_EXPRESSION": {
      "start_point": [
        1840,
        0
      ],
      "end_point": [
        1864,
        1
      ],
      "content": "void\ninternal_function\nFREE_EXPRESSION (struct expression *exp)\n{\n  if (exp == NULL)\n    return;\n\n  /* Handle the recursive case.  */\n  switch (exp->nargs)\n    {\n    case 3:\n      FREE_EXPRESSION (exp->val.args[2]);\n      /* FALLTHROUGH */\n    case 2:\n      FREE_EXPRESSION (exp->val.args[1]);\n      /* FALLTHROUGH */\n    case 1:\n      FREE_EXPRESSION (exp->val.args[0]);\n      /* FALLTHROUGH */\n    default:\n      break;\n    }\n\n  free (exp);\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "yylex": {
      "start_point": [
        1867,
        0
      ],
      "end_point": [
        2007,
        1
      ],
      "content": "static int\nyylex (YYSTYPE *lval, struct parse_args *arg)\n{\n  const char *exp = arg->cp;\n  int result;\n\n  while (1)\n    {\n      if (exp[0] == '\\0')\n\t{\n\t  arg->cp = exp;\n\t  return YYEOF;\n\t}\n\n      if (exp[0] != ' ' && exp[0] != '\\t')\n\tbreak;\n\n      ++exp;\n    }\n\n  result = *exp++;\n  switch (result)\n    {\n    case '0': case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9':\n      {\n\tunsigned long int n = result - '0';\n\twhile (exp[0] >= '0' && exp[0] <= '9')\n\t  {\n\t    n *= 10;\n\t    n += exp[0] - '0';\n\t    ++exp;\n\t  }\n\tlval->num = n;\n\tresult = NUMBER;\n      }\n      break;\n\n    case '=':\n      if (exp[0] == '=')\n\t{\n\t  ++exp;\n\t  lval->op = equal;\n\t  result = EQUOP2;\n\t}\n      else\n\tresult = YYERRCODE;\n      break;\n\n    case '!':\n      if (exp[0] == '=')\n\t{\n\t  ++exp;\n\t  lval->op = not_equal;\n\t  result = EQUOP2;\n\t}\n      break;\n\n    case '&':\n    case '|':\n      if (exp[0] == result)\n\t++exp;\n      else\n\tresult = YYERRCODE;\n      break;\n\n    case '<':\n      if (exp[0] == '=')\n\t{\n\t  ++exp;\n\t  lval->op = less_or_equal;\n\t}\n      else\n\tlval->op = less_than;\n      result = CMPOP2;\n      break;\n\n    case '>':\n      if (exp[0] == '=')\n\t{\n\t  ++exp;\n\t  lval->op = greater_or_equal;\n\t}\n      else\n\tlval->op = greater_than;\n      result = CMPOP2;\n      break;\n\n    case '*':\n      lval->op = mult;\n      result = MULOP2;\n      break;\n\n    case '/':\n      lval->op = divide;\n      result = MULOP2;\n      break;\n\n    case '%':\n      lval->op = module;\n      result = MULOP2;\n      break;\n\n    case '+':\n      lval->op = plus;\n      result = ADDOP2;\n      break;\n\n    case '-':\n      lval->op = minus;\n      result = ADDOP2;\n      break;\n\n    case 'n':\n    case '?':\n    case ':':\n    case '(':\n    case ')':\n      /* Nothing, just return the character.  */\n      break;\n\n    case ';':\n    case '\\n':\n    case '\\0':\n      /* Be safe and let the user call this function again.  */\n      --exp;\n      result = YYEOF;\n      break;\n\n    default:\n      result = YYERRCODE;\n#if YYDEBUG != 0\n      --exp;\n#endif\n      break;\n    }\n\n  arg->cp = exp;\n\n  return result;\n}",
      "lines": 141,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yyerror": {
      "start_point": [
        2010,
        0
      ],
      "end_point": [
        2014,
        1
      ],
      "content": "static void\nyyerror (struct parse_args *arg, const char *str)\n{\n  /* Do nothing.  We don't print error messages here.  */\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/plural.y": {
    "yylex": [
      {
        "start_point": [
          43,
          14
        ],
        "end_point": [
          156,
          4
        ],
        "content": "struct parse_args *arg}\n%lex-param {struct parse_args *arg}\n%define api.pure full\n%expect 7\n\n%union {\n  unsigned long int num;\n  enum expression_operator op;\n  struct expression *exp;\n}\n\n%{\n/* Prototypes for local functions.  */\nstatic int yylex (YYSTYPE *lval, struct parse_args *arg);\nstatic void yyerror (struct parse_args *arg, const char *str);\n\n/* Allocation of expressions.  */\n\nstatic struct expression *\nnew_exp (int nargs, enum expression_operator op,\n\t struct expression * const *args)\n{\n  int i;\n  struct expression *newp;\n\n  /* If any of the argument could not be malloc'ed, just return NULL.  */\n  for (i = nargs - 1; i >= 0; i--)\n    if (args[i] == NULL)\n      goto fail;\n\n  /* Allocate a new expression.  */\n  newp = (struct expression *) malloc (sizeof (*newp));\n  if (newp != NULL)\n    {\n      newp->nargs = nargs;\n      newp->operation = op;\n      for (i = nargs - 1; i >= 0; i--)\n\tnewp->val.args[i] = args[i];\n      return newp;\n    }\n\n fail:\n  for (i = nargs - 1; i >= 0; i--)\n    FREE_EXPRESSION (args[i]);\n\n  return NULL;\n}\n\nstatic inline struct expression *\nnew_exp_0 (enum expression_operator op)\n{\n  return new_exp (0, op, NULL);\n}\n\nstatic inline struct expression *\nnew_exp_1 (enum expression_operator op, struct expression *right)\n{\n  struct expression *args[1];\n\n  args[0] = right;\n  return new_exp (1, op, args);\n}\n\nstatic struct expression *\nnew_exp_2 (enum expression_operator op, struct expression *left,\n\t   struct expression *right)\n{\n  struct expression *args[2];\n\n  args[0] = left;\n  args[1] = right;\n  return new_exp (2, op, args);\n}\n\nstatic inline struct expression *\nnew_exp_3 (enum expression_operator op, struct expression *bexp,\n\t   struct expression *tbranch, struct expression *fbranch)\n{\n  struct expression *args[3];\n\n  args[0] = bexp;\n  args[1] = tbranch;\n  args[2] = fbranch;\n  return new_exp (3, op, args);\n}\n\n%}\n\n/* This declares that all operators have the same associativity and the\n   precedence order as in C.  See [Harbison, Steele: C, A Reference Manual].\n   There is no unary minus and no bitwise operators.\n   Operators with the same syntactic behaviour have been merged into a single\n   token, to save space in the array generated by bison.  */\n%right '?'\t\t/*   ?\t\t*/\n%left '|'\t\t/*   ||\t\t*/\n%left '&'\t\t/*   &&\t\t*/\n%left EQUOP2\t\t/*   == !=\t*/\n%left CMPOP2\t\t/*   < > <= >=\t*/\n%left ADDOP2\t\t/*   + -\t*/\n%left MULOP2\t\t/*   * / %\t*/\n%right '!'\t\t/*   !\t\t*/\n\n%token <op> EQUOP2 CMPOP2 ADDOP2 MULOP2\n%token <num> NUMBER\n%type <exp> exp\n\n%%\n\nstart:\t  exp\n\t  {\n\t    if ($1 == NULL)\n\t      YYABORT;\n\t    arg->res = $1;\n\t  }",
        "lines": 114,
        "depth": 15,
        "decorators": [
          "struct parse_args",
          "struct",
          "parse_args",
          "*arg}\n%lex-param",
          "*",
          "arg}\n%lex-",
          "arg",
          "}",
          "%",
          "lex",
          "-",
          "param",
          "{struct parse_args *arg}\n%define api.pure full\n%expect 7\n\n%union {\n  unsigned long int num;\n  enum expression_operator op;\n  struct expression *exp;\n}\n\n%{\n/* Prototypes for local functions.  */\nstatic int yylex (YYSTYPE *lval, struct parse_args *arg);\nstatic void yyerror (struct parse_args *arg, const char *str);\n\n/* Allocation of expressions.  */\n\nstatic struct expression *\nnew_exp (int nargs, enum expression_operator op,\n\t struct expression * const *args)\n{\n  int i;\n  struct expression *newp;\n\n  /* If any of the argument could not be malloc'ed, just return NULL.  */\n  for (i = nargs - 1; i >= 0; i--)\n    if (args[i] == NULL)\n      goto fail;\n\n  /* Allocate a new expression.  */\n  newp = (struct expression *) malloc (sizeof (*newp));\n  if (newp != NULL)\n    {\n      newp->nargs = nargs;\n      newp->operation = op;\n      for (i = nargs - 1; i >= 0; i--)\n\tnewp->val.args[i] = args[i];\n      return newp;\n    }\n\n fail:\n  for (i = nargs - 1; i >= 0; i--)\n    FREE_EXPRESSION (args[i]);\n\n  return NULL;\n}\n\nstatic inline struct expression *\nnew_exp_0 (enum expression_operator op)\n{\n  return new_exp (0, op, NULL);\n}\n\nstatic inline struct expression *\nnew_exp_1 (enum expression_operator op, struct expression *right)\n{\n  struct expression *args[1];\n\n  args[0] = right;\n  return new_exp (1, op, args);\n}\n\nstatic struct expression *\nnew_exp_2 (enum expression_operator op, struct expression *left,\n\t   struct expression *right)\n{\n  struct expression *args[2];\n\n  args[0] = left;\n  args[1] = right;\n  return new_exp (2, op, args);\n}\n\nstatic inline struct expression *\nnew_exp_3 (enum expression_operator op, struct expression *bexp,\n\t   struct expression *tbranch, struct expression *fbranch)\n{\n  struct expression *args[3];\n\n  args[0] = bexp;\n  args[1] = tbranch;\n  args[2] = fbranch;\n  return new_exp (3, op, args);\n}\n\n%}\n\n/* This declares that all operators have the same associativity and the\n   precedence order as in C.  See [Harbison, Steele: C, A Reference Manual].\n   There is no unary minus and no bitwise operators.\n   Operators with the same syntactic behaviour have been merged into a single\n   token, to save space in the array generated by bison.  */\n%right '?'\t\t/*   ?\t\t*/\n%left '|'\t\t/*   ||\t\t*/\n%left '&'\t\t/*   &&\t\t*/\n%left EQUOP2\t\t/*   == !=\t*/\n%left CMPOP2\t\t/*   < > <= >=\t*/\n%left ADDOP2\t\t/*   + -\t*/\n%left MULOP2\t\t/*   * / %\t*/\n%right '!'\t\t/*   !\t\t*/\n\n%token <op> EQUOP2 CMPOP2 ADDOP2 MULOP2\n%token <num> NUMBER\n%type <exp> exp\n\n%%\n\nstart:\t  exp\n\t  {\n\t    if ($1 == NULL)\n\t      YYABORT;\n\t    arg->res = $1;\n\t  }",
          "{",
          "struct parse_args *arg}\n%define",
          "struct parse_args",
          "struct",
          "parse_args",
          "*arg}\n%define",
          "*",
          "arg}\n%",
          "arg",
          "}",
          "%",
          "define",
          "",
          "api.pure full\n%expect 7\n\n%union",
          "api.pure full\n%expect 7\n\n%union",
          "api.pure full\n%expect",
          "api.pure",
          "api",
          ".",
          "pure",
          "full",
          "full",
          "%",
          "expect",
          "7",
          "7",
          "%",
          "union",
          "",
          "{\n  unsigned long int num;\n  enum expression_operator op;\n  struct expression *exp;\n}",
          "{",
          "unsigned long int num;",
          "unsigned long int",
          "unsigned",
          "long",
          "int",
          "num",
          ";",
          "enum expression_operator op;",
          "enum expression_operator",
          "enum",
          "expression_operator",
          "op",
          ";",
          "struct expression *exp;",
          "struct expression",
          "struct",
          "expression",
          "*exp",
          "*",
          "exp",
          ";",
          "}",
          "%",
          "%",
          "{\n/* Prototypes for local functions.  */\nstatic int yylex (YYSTYPE *lval, struct parse_args *arg);\nstatic void yyerror (struct parse_args *arg, const char *str);\n\n/* Allocation of expressions.  */\n\nstatic struct expression *\nnew_exp (int nargs, enum expression_operator op,\n\t struct expression * const *args)\n{\n  int i;\n  struct expression *newp;\n\n  /* If any of the argument could not be malloc'ed, just return NULL.  */\n  for (i = nargs - 1; i >= 0; i--)\n    if (args[i] == NULL)\n      goto fail;\n\n  /* Allocate a new expression.  */\n  newp = (struct expression *) malloc (sizeof (*newp));\n  if (newp != NULL)\n    {\n      newp->nargs = nargs;\n      newp->operation = op;\n      for (i = nargs - 1; i >= 0; i--)\n\tnewp->val.args[i] = args[i];\n      return newp;\n    }\n\n fail:\n  for (i = nargs - 1; i >= 0; i--)\n    FREE_EXPRESSION (args[i]);\n\n  return NULL;\n}\n\nstatic inline struct expression *\nnew_exp_0 (enum expression_operator op)\n{\n  return new_exp (0, op, NULL);\n}\n\nstatic inline struct expression *\nnew_exp_1 (enum expression_operator op, struct expression *right)\n{\n  struct expression *args[1];\n\n  args[0] = right;\n  return new_exp (1, op, args);\n}\n\nstatic struct expression *\nnew_exp_2 (enum expression_operator op, struct expression *left,\n\t   struct expression *right)\n{\n  struct expression *args[2];\n\n  args[0] = left;\n  args[1] = right;\n  return new_exp (2, op, args);\n}\n\nstatic inline struct expression *\nnew_exp_3 (enum expression_operator op, struct expression *bexp,\n\t   struct expression *tbranch, struct expression *fbranch)\n{\n  struct expression *args[3];\n\n  args[0] = bexp;\n  args[1] = tbranch;\n  args[2] = fbranch;\n  return new_exp (3, op, args);\n}\n\n%}",
          "{",
          "/* Prototypes for local functions.  */",
          "static int yylex (YYSTYPE *lval, struct parse_args *arg);",
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          235,
          0
        ],
        "end_point": [
          375,
          1
        ],
        "content": "static int\nyylex (YYSTYPE *lval, struct parse_args *arg)\n{\n  const char *exp = arg->cp;\n  int result;\n\n  while (1)\n    {\n      if (exp[0] == '\\0')\n\t{\n\t  arg->cp = exp;\n\t  return YYEOF;\n\t}\n\n      if (exp[0] != ' ' && exp[0] != '\\t')\n\tbreak;\n\n      ++exp;\n    }\n\n  result = *exp++;\n  switch (result)\n    {\n    case '0': case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9':\n      {\n\tunsigned long int n = result - '0';\n\twhile (exp[0] >= '0' && exp[0] <= '9')\n\t  {\n\t    n *= 10;\n\t    n += exp[0] - '0';\n\t    ++exp;\n\t  }\n\tlval->num = n;\n\tresult = NUMBER;\n      }\n      break;\n\n    case '=':\n      if (exp[0] == '=')\n\t{\n\t  ++exp;\n\t  lval->op = equal;\n\t  result = EQUOP2;\n\t}\n      else\n\tresult = YYERRCODE;\n      break;\n\n    case '!':\n      if (exp[0] == '=')\n\t{\n\t  ++exp;\n\t  lval->op = not_equal;\n\t  result = EQUOP2;\n\t}\n      break;\n\n    case '&':\n    case '|':\n      if (exp[0] == result)\n\t++exp;\n      else\n\tresult = YYERRCODE;\n      break;\n\n    case '<':\n      if (exp[0] == '=')\n\t{\n\t  ++exp;\n\t  lval->op = less_or_equal;\n\t}\n      else\n\tlval->op = less_than;\n      result = CMPOP2;\n      break;\n\n    case '>':\n      if (exp[0] == '=')\n\t{\n\t  ++exp;\n\t  lval->op = greater_or_equal;\n\t}\n      else\n\tlval->op = greater_than;\n      result = CMPOP2;\n      break;\n\n    case '*':\n      lval->op = mult;\n      result = MULOP2;\n      break;\n\n    case '/':\n      lval->op = divide;\n      result = MULOP2;\n      break;\n\n    case '%':\n      lval->op = module;\n      result = MULOP2;\n      break;\n\n    case '+':\n      lval->op = plus;\n      result = ADDOP2;\n      break;\n\n    case '-':\n      lval->op = minus;\n      result = ADDOP2;\n      break;\n\n    case 'n':\n    case '?':\n    case ':':\n    case '(':\n    case ')':\n      /* Nothing, just return the character.  */\n      break;\n\n    case ';':\n    case '\\n':\n    case '\\0':\n      /* Be safe and let the user call this function again.  */\n      --exp;\n      result = YYEOF;\n      break;\n\n    default:\n      result = YYERRCODE;\n#if YYDEBUG != 0\n      --exp;\n#endif\n      break;\n    }\n\n  arg->cp = exp;\n\n  return result;\n}",
        "lines": 141,
        "depth": 13,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      }
    ],
    "new_exp": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static struct expression *\nnew_exp (int nargs, enum expression_operator op,\n\t struct expression * const *args)\n{\n  int i;\n  struct expression *newp;\n\n  /* If any of the argument could not be malloc'ed, just return NULL.  */\n  for (i = nargs - 1; i >= 0; i--)\n    if (args[i] == NULL)\n      goto fail;\n\n  /* Allocate a new expression.  */\n  newp = (struct expression *) malloc (sizeof (*newp));\n  if (newp != NULL)\n    {\n      newp->nargs = nargs;\n      newp->operation = op;\n      for (i = nargs - 1; i >= 0; i--)\n\tnewp->val.args[i] = args[i];\n      return newp;\n    }\n\n fail:\n  for (i = nargs - 1; i >= 0; i--)\n    FREE_EXPRESSION (args[i]);\n\n  return NULL;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "struct expression",
        "struct",
        "expression",
        "*\nnew_exp (int nargs, enum expression_operator op,\n\t struct expression * const *args)",
        "*"
      ]
    },
    "new_exp_0": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "static inline struct expression *\nnew_exp_0 (enum expression_operator op)\n{\n  return new_exp (0, op, NULL);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct expression",
        "struct",
        "expression",
        "*\nnew_exp_0 (enum expression_operator op)",
        "*"
      ]
    },
    "new_exp_1": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static inline struct expression *\nnew_exp_1 (enum expression_operator op, struct expression *right)\n{\n  struct expression *args[1];\n\n  args[0] = right;\n  return new_exp (1, op, args);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct expression",
        "struct",
        "expression",
        "*\nnew_exp_1 (enum expression_operator op, struct expression *right)",
        "*"
      ]
    },
    "new_exp_2": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "static struct expression *\nnew_exp_2 (enum expression_operator op, struct expression *left,\n\t   struct expression *right)\n{\n  struct expression *args[2];\n\n  args[0] = left;\n  args[1] = right;\n  return new_exp (2, op, args);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct expression",
        "struct",
        "expression",
        "*\nnew_exp_2 (enum expression_operator op, struct expression *left,\n\t   struct expression *right)",
        "*"
      ]
    },
    "new_exp_3": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "static inline struct expression *\nnew_exp_3 (enum expression_operator op, struct expression *bexp,\n\t   struct expression *tbranch, struct expression *fbranch)\n{\n  struct expression *args[3];\n\n  args[0] = bexp;\n  args[1] = tbranch;\n  args[2] = fbranch;\n  return new_exp (3, op, args);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct expression",
        "struct",
        "expression",
        "*\nnew_exp_3 (enum expression_operator op, struct expression *bexp,\n\t   struct expression *tbranch, struct expression *fbranch)",
        "*"
      ]
    },
    "FREE_EXPRESSION": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        232,
        1
      ],
      "content": "void\ninternal_function\nFREE_EXPRESSION (struct expression *exp)\n{\n  if (exp == NULL)\n    return;\n\n  /* Handle the recursive case.  */\n  switch (exp->nargs)\n    {\n    case 3:\n      FREE_EXPRESSION (exp->val.args[2]);\n      /* FALLTHROUGH */\n    case 2:\n      FREE_EXPRESSION (exp->val.args[1]);\n      /* FALLTHROUGH */\n    case 1:\n      FREE_EXPRESSION (exp->val.args[0]);\n      /* FALLTHROUGH */\n    default:\n      break;\n    }\n\n  free (exp);\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "yyerror": {
      "start_point": [
        378,
        0
      ],
      "end_point": [
        382,
        1
      ],
      "content": "static void\nyyerror (struct parse_args *arg, const char *str)\n{\n  /* Do nothing.  We don't print error messages here.  */\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/printf-args.c": {
    "PRINTF_FETCHARGS": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "int\nPRINTF_FETCHARGS (va_list args, arguments *a)\n{\n  size_t i;\n  argument *ap;\n\n  for (i = 0, ap = &a->arg[0]; i < a->count; i++, ap++)\n    switch (ap->type)\n      {\n      case TYPE_SCHAR:\n        ap->a.a_schar = va_arg (args, /*signed char*/ int);\n        break;\n      case TYPE_UCHAR:\n        ap->a.a_uchar = va_arg (args, /*unsigned char*/ int);\n        break;\n      case TYPE_SHORT:\n        ap->a.a_short = va_arg (args, /*short*/ int);\n        break;\n      case TYPE_USHORT:\n        ap->a.a_ushort = va_arg (args, /*unsigned short*/ int);\n        break;\n      case TYPE_INT:\n        ap->a.a_int = va_arg (args, int);\n        break;\n      case TYPE_UINT:\n        ap->a.a_uint = va_arg (args, unsigned int);\n        break;\n      case TYPE_LONGINT:\n        ap->a.a_longint = va_arg (args, long int);\n        break;\n      case TYPE_ULONGINT:\n        ap->a.a_ulongint = va_arg (args, unsigned long int);\n        break;\n#if HAVE_LONG_LONG_INT\n      case TYPE_LONGLONGINT:\n        ap->a.a_longlongint = va_arg (args, long long int);\n        break;\n      case TYPE_ULONGLONGINT:\n        ap->a.a_ulonglongint = va_arg (args, unsigned long long int);\n        break;\n#endif\n      case TYPE_DOUBLE:\n        ap->a.a_double = va_arg (args, double);\n        break;\n      case TYPE_LONGDOUBLE:\n        ap->a.a_longdouble = va_arg (args, long double);\n        break;\n      case TYPE_CHAR:\n        ap->a.a_char = va_arg (args, int);\n        break;\n#if HAVE_WINT_T\n      case TYPE_WIDE_CHAR:\n        /* Although ISO C 99 7.24.1.(2) says that wint_t is \"unchanged by\n           default argument promotions\", this is not the case in mingw32,\n           where wint_t is 'unsigned short'.  */\n        ap->a.a_wide_char =\n          (sizeof (wint_t) < sizeof (int)\n           ? va_arg (args, int)\n           : va_arg (args, wint_t));\n        break;\n#endif\n      case TYPE_STRING:\n        ap->a.a_string = va_arg (args, const char *);\n        /* A null pointer is an invalid argument for \"%s\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_string == NULL)\n          ap->a.a_string = \"(NULL)\";\n        break;\n#if HAVE_WCHAR_T\n      case TYPE_WIDE_STRING:\n        ap->a.a_wide_string = va_arg (args, const wchar_t *);\n        /* A null pointer is an invalid argument for \"%ls\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_wide_string == NULL)\n          {\n            static const wchar_t wide_null_string[] =\n              {\n                (wchar_t)'(',\n                (wchar_t)'N', (wchar_t)'U', (wchar_t)'L', (wchar_t)'L',\n                (wchar_t)')',\n                (wchar_t)0\n              };\n            ap->a.a_wide_string = wide_null_string;\n          }\n        break;\n#endif\n      case TYPE_POINTER:\n        ap->a.a_pointer = va_arg (args, void *);\n        break;\n      case TYPE_COUNT_SCHAR_POINTER:\n        ap->a.a_count_schar_pointer = va_arg (args, signed char *);\n        break;\n      case TYPE_COUNT_SHORT_POINTER:\n        ap->a.a_count_short_pointer = va_arg (args, short *);\n        break;\n      case TYPE_COUNT_INT_POINTER:\n        ap->a.a_count_int_pointer = va_arg (args, int *);\n        break;\n      case TYPE_COUNT_LONGINT_POINTER:\n        ap->a.a_count_longint_pointer = va_arg (args, long int *);\n        break;\n#if HAVE_LONG_LONG_INT\n      case TYPE_COUNT_LONGLONGINT_POINTER:\n        ap->a.a_count_longlongint_pointer = va_arg (args, long long int *);\n        break;\n#endif\n#if ENABLE_UNISTDIO\n      /* The unistdio extensions.  */\n      case TYPE_U8_STRING:\n        ap->a.a_u8_string = va_arg (args, const uint8_t *);\n        /* A null pointer is an invalid argument for \"%U\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u8_string == NULL)\n          {\n            static const uint8_t u8_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u8_string = u8_null_string;\n          }\n        break;\n      case TYPE_U16_STRING:\n        ap->a.a_u16_string = va_arg (args, const uint16_t *);\n        /* A null pointer is an invalid argument for \"%lU\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u16_string == NULL)\n          {\n            static const uint16_t u16_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u16_string = u16_null_string;\n          }\n        break;\n      case TYPE_U32_STRING:\n        ap->a.a_u32_string = va_arg (args, const uint32_t *);\n        /* A null pointer is an invalid argument for \"%llU\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u32_string == NULL)\n          {\n            static const uint32_t u32_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u32_string = u32_null_string;\n          }\n        break;\n#endif\n      default:\n        /* Unknown type.  */\n        return -1;\n      }\n  return 0;\n}",
      "lines": 153,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/printf-args.h": {},
  "sharutils/sharutils-4.15.2/intl/printf-parse.c": {
    "PRINTF_PARSE": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        631,
        1
      ],
      "content": "int\nPRINTF_PARSE (const CHAR_T *format, DIRECTIVES *d, arguments *a)\n{\n  const CHAR_T *cp = format;    /* pointer into format */\n  size_t arg_posn = 0;          /* number of regular arguments consumed */\n  size_t d_allocated;           /* allocated elements of d->dir */\n  size_t a_allocated;           /* allocated elements of a->arg */\n  size_t max_width_length = 0;\n  size_t max_precision_length = 0;\n\n  d->count = 0;\n  d_allocated = N_DIRECT_ALLOC_DIRECTIVES;\n  d->dir = d->direct_alloc_dir;\n\n  a->count = 0;\n  a_allocated = N_DIRECT_ALLOC_ARGUMENTS;\n  a->arg = a->direct_alloc_arg;\n\n#define REGISTER_ARG(_index_,_type_) \\\n  {                                                                     \\\n    size_t n = (_index_);                                               \\\n    if (n >= a_allocated)                                               \\\n      {                                                                 \\\n        size_t memory_size;                                             \\\n        argument *memory;                                               \\\n                                                                        \\\n        a_allocated = xtimes (a_allocated, 2);                          \\\n        if (a_allocated <= n)                                           \\\n          a_allocated = xsum (n, 1);                                    \\\n        memory_size = xtimes (a_allocated, sizeof (argument));          \\\n        if (size_overflow_p (memory_size))                              \\\n          /* Overflow, would lead to out of memory.  */                 \\\n          goto out_of_memory;                                           \\\n        memory = (argument *) (a->arg != a->direct_alloc_arg            \\\n                               ? realloc (a->arg, memory_size)          \\\n                               : malloc (memory_size));                 \\\n        if (memory == NULL)                                             \\\n          /* Out of memory.  */                                         \\\n          goto out_of_memory;                                           \\\n        if (a->arg == a->direct_alloc_arg)                              \\\n          memcpy (memory, a->arg, a->count * sizeof (argument));        \\\n        a->arg = memory;                                                \\\n      }                                                                 \\\n    while (a->count <= n)                                               \\\n      a->arg[a->count++].type = TYPE_NONE;                              \\\n    if (a->arg[n].type == TYPE_NONE)                                    \\\n      a->arg[n].type = (_type_);                                        \\\n    else if (a->arg[n].type != (_type_))                                \\\n      /* Ambiguous type for positional argument.  */                    \\\n      goto error;                                                       \\\n  }\n\n  while (*cp != '\\0')\n    {\n      CHAR_T c = *cp++;\n      if (c == '%')\n        {\n          size_t arg_index = ARG_NONE;\n          DIRECTIVE *dp = &d->dir[d->count]; /* pointer to next directive */\n\n          /* Initialize the next directive.  */\n          dp->dir_start = cp - 1;\n          dp->flags = 0;\n          dp->width_start = NULL;\n          dp->width_end = NULL;\n          dp->width_arg_index = ARG_NONE;\n          dp->precision_start = NULL;\n          dp->precision_end = NULL;\n          dp->precision_arg_index = ARG_NONE;\n          dp->arg_index = ARG_NONE;\n\n          /* Test for positional argument.  */\n          if (*cp >= '0' && *cp <= '9')\n            {\n              const CHAR_T *np;\n\n              for (np = cp; *np >= '0' && *np <= '9'; np++)\n                ;\n              if (*np == '$')\n                {\n                  size_t n = 0;\n\n                  for (np = cp; *np >= '0' && *np <= '9'; np++)\n                    n = xsum (xtimes (n, 10), *np - '0');\n                  if (n == 0)\n                    /* Positional argument 0.  */\n                    goto error;\n                  if (size_overflow_p (n))\n                    /* n too large, would lead to out of memory later.  */\n                    goto error;\n                  arg_index = n - 1;\n                  cp = np + 1;\n                }\n            }\n\n          /* Read the flags.  */\n          for (;;)\n            {\n              if (*cp == '\\'')\n                {\n                  dp->flags |= FLAG_GROUP;\n                  cp++;\n                }\n              else if (*cp == '-')\n                {\n                  dp->flags |= FLAG_LEFT;\n                  cp++;\n                }\n              else if (*cp == '+')\n                {\n                  dp->flags |= FLAG_SHOWSIGN;\n                  cp++;\n                }\n              else if (*cp == ' ')\n                {\n                  dp->flags |= FLAG_SPACE;\n                  cp++;\n                }\n              else if (*cp == '#')\n                {\n                  dp->flags |= FLAG_ALT;\n                  cp++;\n                }\n              else if (*cp == '0')\n                {\n                  dp->flags |= FLAG_ZERO;\n                  cp++;\n                }\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n              else if (*cp == 'I')\n                {\n                  dp->flags |= FLAG_LOCALIZED;\n                  cp++;\n                }\n#endif\n              else\n                break;\n            }\n\n          /* Parse the field width.  */\n          if (*cp == '*')\n            {\n              dp->width_start = cp;\n              cp++;\n              dp->width_end = cp;\n              if (max_width_length < 1)\n                max_width_length = 1;\n\n              /* Test for positional argument.  */\n              if (*cp >= '0' && *cp <= '9')\n                {\n                  const CHAR_T *np;\n\n                  for (np = cp; *np >= '0' && *np <= '9'; np++)\n                    ;\n                  if (*np == '$')\n                    {\n                      size_t n = 0;\n\n                      for (np = cp; *np >= '0' && *np <= '9'; np++)\n                        n = xsum (xtimes (n, 10), *np - '0');\n                      if (n == 0)\n                        /* Positional argument 0.  */\n                        goto error;\n                      if (size_overflow_p (n))\n                        /* n too large, would lead to out of memory later.  */\n                        goto error;\n                      dp->width_arg_index = n - 1;\n                      cp = np + 1;\n                    }\n                }\n              if (dp->width_arg_index == ARG_NONE)\n                {\n                  dp->width_arg_index = arg_posn++;\n                  if (dp->width_arg_index == ARG_NONE)\n                    /* arg_posn wrapped around.  */\n                    goto error;\n                }\n              REGISTER_ARG (dp->width_arg_index, TYPE_INT);\n            }\n          else if (*cp >= '0' && *cp <= '9')\n            {\n              size_t width_length;\n\n              dp->width_start = cp;\n              for (; *cp >= '0' && *cp <= '9'; cp++)\n                ;\n              dp->width_end = cp;\n              width_length = dp->width_end - dp->width_start;\n              if (max_width_length < width_length)\n                max_width_length = width_length;\n            }\n\n          /* Parse the precision.  */\n          if (*cp == '.')\n            {\n              cp++;\n              if (*cp == '*')\n                {\n                  dp->precision_start = cp - 1;\n                  cp++;\n                  dp->precision_end = cp;\n                  if (max_precision_length < 2)\n                    max_precision_length = 2;\n\n                  /* Test for positional argument.  */\n                  if (*cp >= '0' && *cp <= '9')\n                    {\n                      const CHAR_T *np;\n\n                      for (np = cp; *np >= '0' && *np <= '9'; np++)\n                        ;\n                      if (*np == '$')\n                        {\n                          size_t n = 0;\n\n                          for (np = cp; *np >= '0' && *np <= '9'; np++)\n                            n = xsum (xtimes (n, 10), *np - '0');\n                          if (n == 0)\n                            /* Positional argument 0.  */\n                            goto error;\n                          if (size_overflow_p (n))\n                            /* n too large, would lead to out of memory\n                               later.  */\n                            goto error;\n                          dp->precision_arg_index = n - 1;\n                          cp = np + 1;\n                        }\n                    }\n                  if (dp->precision_arg_index == ARG_NONE)\n                    {\n                      dp->precision_arg_index = arg_posn++;\n                      if (dp->precision_arg_index == ARG_NONE)\n                        /* arg_posn wrapped around.  */\n                        goto error;\n                    }\n                  REGISTER_ARG (dp->precision_arg_index, TYPE_INT);\n                }\n              else\n                {\n                  size_t precision_length;\n\n                  dp->precision_start = cp - 1;\n                  for (; *cp >= '0' && *cp <= '9'; cp++)\n                    ;\n                  dp->precision_end = cp;\n                  precision_length = dp->precision_end - dp->precision_start;\n                  if (max_precision_length < precision_length)\n                    max_precision_length = precision_length;\n                }\n            }\n\n          {\n            arg_type type;\n\n            /* Parse argument type/size specifiers.  */\n            {\n              int flags = 0;\n\n              for (;;)\n                {\n                  if (*cp == 'h')\n                    {\n                      flags |= (1 << (flags & 1));\n                      cp++;\n                    }\n                  else if (*cp == 'L')\n                    {\n                      flags |= 4;\n                      cp++;\n                    }\n                  else if (*cp == 'l')\n                    {\n                      flags += 8;\n                      cp++;\n                    }\n                  else if (*cp == 'j')\n                    {\n                      if (sizeof (intmax_t) > sizeof (long))\n                        {\n                          /* intmax_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (intmax_t) > sizeof (int))\n                        {\n                          /* intmax_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n                  else if (*cp == 'z' || *cp == 'Z')\n                    {\n                      /* 'z' is standardized in ISO C 99, but glibc uses 'Z'\n                         because the warning facility in gcc-2.95.2 understands\n                         only 'Z' (see gcc-2.95.2/gcc/c-common.c:1784).  */\n                      if (sizeof (size_t) > sizeof (long))\n                        {\n                          /* size_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (size_t) > sizeof (int))\n                        {\n                          /* size_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n                  else if (*cp == 't')\n                    {\n                      if (sizeof (ptrdiff_t) > sizeof (long))\n                        {\n                          /* ptrdiff_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (ptrdiff_t) > sizeof (int))\n                        {\n                          /* ptrdiff_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n#if defined __APPLE__ && defined __MACH__\n                  /* On MacOS X 10.3, PRIdMAX is defined as \"qd\".\n                     We cannot change it to \"lld\" because PRIdMAX must also\n                     be understood by the system's printf routines.  */\n                  else if (*cp == 'q')\n                    {\n                      if (64 / 8 > sizeof (long))\n                        {\n                          /* int64_t = long long */\n                          flags += 16;\n                        }\n                      else\n                        {\n                          /* int64_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n#endif\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                  /* On native Win32, PRIdMAX is defined as \"I64d\".\n                     We cannot change it to \"lld\" because PRIdMAX must also\n                     be understood by the system's printf routines.  */\n                  else if (*cp == 'I' && cp[1] == '6' && cp[2] == '4')\n                    {\n                      if (64 / 8 > sizeof (long))\n                        {\n                          /* __int64 = long long */\n                          flags += 16;\n                        }\n                      else\n                        {\n                          /* __int64 = long */\n                          flags += 8;\n                        }\n                      cp += 3;\n                    }\n#endif\n                  else\n                    break;\n                }\n\n              /* Read the conversion character.  */\n              c = *cp++;\n              switch (c)\n                {\n                case 'd': case 'i':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_LONGLONGINT;\n                  else\n#endif\n                  /* If 'long long' exists and is the same as 'long', we parse\n                     \"lld\" into TYPE_LONGINT.  */\n                  if (flags >= 8)\n                    type = TYPE_LONGINT;\n                  else if (flags & 2)\n                    type = TYPE_SCHAR;\n                  else if (flags & 1)\n                    type = TYPE_SHORT;\n                  else\n                    type = TYPE_INT;\n                  break;\n                case 'o': case 'u': case 'x': case 'X':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_ULONGLONGINT;\n                  else\n#endif\n                  /* If 'unsigned long long' exists and is the same as\n                     'unsigned long', we parse \"llu\" into TYPE_ULONGINT.  */\n                  if (flags >= 8)\n                    type = TYPE_ULONGINT;\n                  else if (flags & 2)\n                    type = TYPE_UCHAR;\n                  else if (flags & 1)\n                    type = TYPE_USHORT;\n                  else\n                    type = TYPE_UINT;\n                  break;\n                case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                case 'a': case 'A':\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_LONGDOUBLE;\n                  else\n                    type = TYPE_DOUBLE;\n                  break;\n                case 'c':\n                  if (flags >= 8)\n#if HAVE_WINT_T\n                    type = TYPE_WIDE_CHAR;\n#else\n                    goto error;\n#endif\n                  else\n                    type = TYPE_CHAR;\n                  break;\n#if HAVE_WINT_T\n                case 'C':\n                  type = TYPE_WIDE_CHAR;\n                  c = 'c';\n                  break;\n#endif\n                case 's':\n                  if (flags >= 8)\n#if HAVE_WCHAR_T\n                    type = TYPE_WIDE_STRING;\n#else\n                    goto error;\n#endif\n                  else\n                    type = TYPE_STRING;\n                  break;\n#if HAVE_WCHAR_T\n                case 'S':\n                  type = TYPE_WIDE_STRING;\n                  c = 's';\n                  break;\n#endif\n                case 'p':\n                  type = TYPE_POINTER;\n                  break;\n                case 'n':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_COUNT_LONGLONGINT_POINTER;\n                  else\n#endif\n                  /* If 'long long' exists and is the same as 'long', we parse\n                     \"lln\" into TYPE_COUNT_LONGINT_POINTER.  */\n                  if (flags >= 8)\n                    type = TYPE_COUNT_LONGINT_POINTER;\n                  else if (flags & 2)\n                    type = TYPE_COUNT_SCHAR_POINTER;\n                  else if (flags & 1)\n                    type = TYPE_COUNT_SHORT_POINTER;\n                  else\n                    type = TYPE_COUNT_INT_POINTER;\n                  break;\n#if ENABLE_UNISTDIO\n                /* The unistdio extensions.  */\n                case 'U':\n                  if (flags >= 16)\n                    type = TYPE_U32_STRING;\n                  else if (flags >= 8)\n                    type = TYPE_U16_STRING;\n                  else\n                    type = TYPE_U8_STRING;\n                  break;\n#endif\n                case '%':\n                  type = TYPE_NONE;\n                  break;\n                default:\n                  /* Unknown conversion character.  */\n                  goto error;\n                }\n            }\n\n            if (type != TYPE_NONE)\n              {\n                dp->arg_index = arg_index;\n                if (dp->arg_index == ARG_NONE)\n                  {\n                    dp->arg_index = arg_posn++;\n                    if (dp->arg_index == ARG_NONE)\n                      /* arg_posn wrapped around.  */\n                      goto error;\n                  }\n                REGISTER_ARG (dp->arg_index, type);\n              }\n            dp->conversion = c;\n            dp->dir_end = cp;\n          }\n\n          d->count++;\n          if (d->count >= d_allocated)\n            {\n              size_t memory_size;\n              DIRECTIVE *memory;\n\n              d_allocated = xtimes (d_allocated, 2);\n              memory_size = xtimes (d_allocated, sizeof (DIRECTIVE));\n              if (size_overflow_p (memory_size))\n                /* Overflow, would lead to out of memory.  */\n                goto out_of_memory;\n              memory = (DIRECTIVE *) (d->dir != d->direct_alloc_dir\n                                      ? realloc (d->dir, memory_size)\n                                      : malloc (memory_size));\n              if (memory == NULL)\n                /* Out of memory.  */\n                goto out_of_memory;\n              if (d->dir == d->direct_alloc_dir)\n                memcpy (memory, d->dir, d->count * sizeof (DIRECTIVE));\n              d->dir = memory;\n            }\n        }\n#if CHAR_T_ONLY_ASCII\n      else if (!c_isascii (c))\n        {\n          /* Non-ASCII character.  Not supported.  */\n          goto error;\n        }\n#endif\n    }\n  d->dir[d->count].dir_start = cp;\n\n  d->max_width_length = max_width_length;\n  d->max_precision_length = max_precision_length;\n  return 0;\n\nerror:\n  if (a->arg != a->direct_alloc_arg)\n    free (a->arg);\n  if (d->dir != d->direct_alloc_dir)\n    free (d->dir);\n  errno = EINVAL;\n  return -1;\n\nout_of_memory:\n  if (a->arg != a->direct_alloc_arg)\n    free (a->arg);\n  if (d->dir != d->direct_alloc_dir)\n    free (d->dir);\n  errno = ENOMEM;\n  return -1;\n}",
      "lines": 551,
      "depth": 24,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/printf-parse.h": {},
  "sharutils/sharutils-4.15.2/intl/printf.c": {
    "libintl_vfprintf": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_vfprintf (FILE *stream, const char *format, va_list args)\n{\n  if (strchr (format, '$') == NULL)\n    return vfprintf (stream, format, args);\n  else\n    {\n      size_t length;\n      char *result = libintl_vasnprintf (NULL, &length, format, args);\n      int retval = -1;\n      if (result != NULL)\n        {\n          size_t written = fwrite (result, 1, length, stream);\n          free (result);\n          if (written == length)\n            {\n              if (length > INT_MAX)\n                errno = EOVERFLOW;\n              else\n                retval = length;\n            }\n        }\n      return retval;\n    }\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_fprintf": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_fprintf (FILE *stream, const char *format, ...)\n{\n  va_list args;\n  int retval;\n\n  va_start (args, format);\n  retval = libintl_vfprintf (stream, format, args);\n  va_end (args);\n  return retval;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_vprintf": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_vprintf (const char *format, va_list args)\n{\n  return libintl_vfprintf (stdout, format, args);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_printf": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_printf (const char *format, ...)\n{\n  va_list args;\n  int retval;\n\n  va_start (args, format);\n  retval = libintl_vprintf (format, args);\n  va_end (args);\n  return retval;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_vsprintf": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_vsprintf (char *resultbuf, const char *format, va_list args)\n{\n  if (strchr (format, '$') == NULL)\n    return vsprintf (resultbuf, format, args);\n  else\n    {\n      size_t length = (size_t) ~0 / (4 * sizeof (char));\n      char *result = libintl_vasnprintf (resultbuf, &length, format, args);\n      if (result != resultbuf)\n        {\n          free (result);\n          return -1;\n        }\n      if (length > INT_MAX)\n        {\n          errno = EOVERFLOW;\n          return -1;\n        }\n      else\n        return length;\n    }\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_sprintf": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_sprintf (char *resultbuf, const char *format, ...)\n{\n  va_list args;\n  int retval;\n\n  va_start (args, format);\n  retval = libintl_vsprintf (resultbuf, format, args);\n  va_end (args);\n  return retval;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_vsnprintf": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        236,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_vsnprintf (char *resultbuf, size_t length, const char *format, va_list args)\n{\n  if (strchr (format, '$') == NULL)\n    return system_vsnprintf (resultbuf, length, format, args);\n  else\n    {\n      size_t maxlength = length;\n      char *result = libintl_vasnprintf (resultbuf, &length, format, args);\n      if (result == NULL)\n        return -1;\n      if (result != resultbuf)\n        {\n          if (maxlength > 0)\n            {\n              size_t pruned_length =\n                (length < maxlength ? length : maxlength - 1);\n              memcpy (resultbuf, result, pruned_length);\n              resultbuf[pruned_length] = '\\0';\n            }\n          free (result);\n        }\n      if (length > INT_MAX)\n        {\n          errno = EOVERFLOW;\n          return -1;\n        }\n      else\n        return length;\n    }\n}",
      "lines": 32,
      "depth": 14,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_snprintf": {
      "start_point": [
        238,
        0
      ],
      "end_point": [
        249,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_snprintf (char *resultbuf, size_t length, const char *format, ...)\n{\n  va_list args;\n  int retval;\n\n  va_start (args, format);\n  retval = libintl_vsnprintf (resultbuf, length, format, args);\n  va_end (args);\n  return retval;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_vasprintf": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_vasprintf (char **resultp, const char *format, va_list args)\n{\n  size_t length;\n  char *result = libintl_vasnprintf (NULL, &length, format, args);\n  if (result == NULL)\n    return -1;\n  if (length > INT_MAX)\n    {\n      free (result);\n      errno = EOVERFLOW;\n      return -1;\n    }\n  *resultp = result;\n  return length;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_asprintf": {
      "start_point": [
        273,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_asprintf (char **resultp, const char *format, ...)\n{\n  va_list args;\n  int retval;\n\n  va_start (args, format);\n  retval = libintl_vasprintf (resultp, format, args);\n  va_end (args);\n  return retval;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_vfwprintf": {
      "start_point": [
        319,
        0
      ],
      "end_point": [
        347,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_vfwprintf (FILE *stream, const wchar_t *format, va_list args)\n{\n  if (wcschr (format, '$') == NULL)\n    return vfwprintf (stream, format, args);\n  else\n    {\n      size_t length;\n      wchar_t *result = libintl_vasnwprintf (NULL, &length, format, args);\n      int retval = -1;\n      if (result != NULL)\n        {\n          size_t i;\n          for (i = 0; i < length; i++)\n            if (fputwc (result[i], stream) == WEOF)\n              break;\n          free (result);\n          if (i == length)\n            {\n              if (length > INT_MAX)\n                errno = EOVERFLOW;\n              else\n                retval = length;\n            }\n        }\n      return retval;\n    }\n}",
      "lines": 29,
      "depth": 14,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_fwprintf": {
      "start_point": [
        349,
        0
      ],
      "end_point": [
        360,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_fwprintf (FILE *stream, const wchar_t *format, ...)\n{\n  va_list args;\n  int retval;\n\n  va_start (args, format);\n  retval = libintl_vfwprintf (stream, format, args);\n  va_end (args);\n  return retval;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_vwprintf": {
      "start_point": [
        362,
        0
      ],
      "end_point": [
        367,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_vwprintf (const wchar_t *format, va_list args)\n{\n  return libintl_vfwprintf (stdout, format, args);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_wprintf": {
      "start_point": [
        369,
        0
      ],
      "end_point": [
        380,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_wprintf (const wchar_t *format, ...)\n{\n  va_list args;\n  int retval;\n\n  va_start (args, format);\n  retval = libintl_vwprintf (format, args);\n  va_end (args);\n  return retval;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_vswprintf": {
      "start_point": [
        382,
        0
      ],
      "end_point": [
        419,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_vswprintf (wchar_t *resultbuf, size_t length, const wchar_t *format, va_list args)\n{\n  if (wcschr (format, '$') == NULL)\n    return system_vswprintf (resultbuf, length, format, args);\n  else\n    {\n      size_t maxlength = length;\n      wchar_t *result = libintl_vasnwprintf (resultbuf, &length, format, args);\n      if (result == NULL)\n        return -1;\n      if (result != resultbuf)\n        {\n          if (maxlength > 0)\n            {\n              size_t pruned_length =\n                (length < maxlength ? length : maxlength - 1);\n              memcpy (resultbuf, result, pruned_length * sizeof (wchar_t));\n              resultbuf[pruned_length] = 0;\n            }\n          free (result);\n          /* Unlike vsnprintf, which has to return the number of character that\n             would have been produced if the resultbuf had been sufficiently\n             large, the vswprintf function has to return a negative value if\n             the resultbuf was not sufficiently large.  */\n          if (length >= maxlength)\n            return -1;\n        }\n      if (length > INT_MAX)\n        {\n          errno = EOVERFLOW;\n          return -1;\n        }\n      else\n        return length;\n    }\n}",
      "lines": 38,
      "depth": 15,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    },
    "libintl_swprintf": {
      "start_point": [
        421,
        0
      ],
      "end_point": [
        432,
        1
      ],
      "content": "DLL_EXPORTED\nint\nlibintl_swprintf (wchar_t *resultbuf, size_t length, const wchar_t *format, ...)\n{\n  va_list args;\n  int retval;\n\n  va_start (args, format);\n  retval = libintl_vswprintf (resultbuf, length, format, args);\n  va_end (args);\n  return retval;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "DLL_EXPORTED",
        "int",
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/relocatable.c": {
    "set_this_relocation_prefix": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "static void\nset_this_relocation_prefix (const char *orig_prefix_arg,\n                            const char *curr_prefix_arg)\n{\n  if (orig_prefix_arg != NULL && curr_prefix_arg != NULL\n      /* Optimization: if orig_prefix and curr_prefix are equal, the\n         relocation is a nop.  */\n      && strcmp (orig_prefix_arg, curr_prefix_arg) != 0)\n    {\n      /* Duplicate the argument strings.  */\n      char *memory;\n\n      orig_prefix_len = strlen (orig_prefix_arg);\n      curr_prefix_len = strlen (curr_prefix_arg);\n      memory = (char *) xmalloc (orig_prefix_len + 1 + curr_prefix_len + 1);\n#ifdef NO_XMALLOC\n      if (memory != NULL)\n#endif\n        {\n          memcpy (memory, orig_prefix_arg, orig_prefix_len + 1);\n          orig_prefix = memory;\n          memory += orig_prefix_len + 1;\n          memcpy (memory, curr_prefix_arg, curr_prefix_len + 1);\n          curr_prefix = memory;\n          return;\n        }\n    }\n  orig_prefix = NULL;\n  curr_prefix = NULL;\n  /* Don't worry about wasted memory here - this function is usually only\n     called once.  */\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_relocation_prefix": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "void\nset_relocation_prefix (const char *orig_prefix_arg, const char *curr_prefix_arg)\n{\n  set_this_relocation_prefix (orig_prefix_arg, curr_prefix_arg);\n\n  /* Now notify all dependent libraries.  */\n#if DEPENDS_ON_LIBCHARSET\n  libcharset_set_relocation_prefix (orig_prefix_arg, curr_prefix_arg);\n#endif\n#if DEPENDS_ON_LIBICONV && HAVE_ICONV && _LIBICONV_VERSION >= 0x0109\n  libiconv_set_relocation_prefix (orig_prefix_arg, curr_prefix_arg);\n#endif\n#if DEPENDS_ON_LIBINTL && ENABLE_NLS && defined libintl_set_relocation_prefix\n  libintl_set_relocation_prefix (orig_prefix_arg, curr_prefix_arg);\n#endif\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "compute_curr_prefix": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        295,
        1
      ],
      "content": "char *\ncompute_curr_prefix (const char *orig_installprefix,\n                     const char *orig_installdir,\n                     const char *curr_pathname)\n{\n  char *curr_installdir;\n  const char *rel_installdir;\n\n  if (curr_pathname == NULL)\n    return NULL;\n\n  /* Determine the relative installation directory, relative to the prefix.\n     This is simply the difference between orig_installprefix and\n     orig_installdir.  */\n  if (strncmp (orig_installprefix, orig_installdir, strlen (orig_installprefix))\n      != 0)\n    /* Shouldn't happen - nothing should be installed outside $(prefix).  */\n    return NULL;\n  rel_installdir = orig_installdir + strlen (orig_installprefix);\n\n  /* Determine the current installation directory.  */\n  {\n    const char *p_base = curr_pathname + FILE_SYSTEM_PREFIX_LEN (curr_pathname);\n    const char *p = curr_pathname + strlen (curr_pathname);\n    char *q;\n\n    while (p > p_base)\n      {\n        p--;\n        if (ISSLASH (*p))\n          break;\n      }\n\n    q = (char *) xmalloc (p - curr_pathname + 1);\n#ifdef NO_XMALLOC\n    if (q == NULL)\n      return NULL;\n#endif\n    memcpy (q, curr_pathname, p - curr_pathname);\n    q[p - curr_pathname] = '\\0';\n    curr_installdir = q;\n  }\n\n  /* Compute the current installation prefix by removing the trailing\n     rel_installdir from it.  */\n  {\n    const char *rp = rel_installdir + strlen (rel_installdir);\n    const char *cp = curr_installdir + strlen (curr_installdir);\n    const char *cp_base =\n      curr_installdir + FILE_SYSTEM_PREFIX_LEN (curr_installdir);\n\n    while (rp > rel_installdir && cp > cp_base)\n      {\n        bool same = false;\n        const char *rpi = rp;\n        const char *cpi = cp;\n\n        while (rpi > rel_installdir && cpi > cp_base)\n          {\n            rpi--;\n            cpi--;\n            if (ISSLASH (*rpi) || ISSLASH (*cpi))\n              {\n                if (ISSLASH (*rpi) && ISSLASH (*cpi))\n                  same = true;\n                break;\n              }\n            /* Do case-insensitive comparison if the file system is always or\n               often case-insensitive.  It's better to accept the comparison\n               if the difference is only in case, rather than to fail.  */\n#if defined _WIN32 || defined __WIN32__ || defined __CYGWIN__ || defined __EMX__ || defined __DJGPP__\n            /* Native Windows, Cygwin, OS/2, DOS - case insignificant file system */\n            if ((*rpi >= 'a' && *rpi <= 'z' ? *rpi - 'a' + 'A' : *rpi)\n                != (*cpi >= 'a' && *cpi <= 'z' ? *cpi - 'a' + 'A' : *cpi))\n              break;\n#else\n            if (*rpi != *cpi)\n              break;\n#endif\n          }\n        if (!same)\n          break;\n        /* The last pathname component was the same.  opi and cpi now point\n           to the slash before it.  */\n        rp = rpi;\n        cp = cpi;\n      }\n\n    if (rp > rel_installdir)\n      {\n        /* Unexpected: The curr_installdir does not end with rel_installdir.  */\n        free (curr_installdir);\n        return NULL;\n      }\n\n    {\n      size_t curr_prefix_len = cp - curr_installdir;\n      char *curr_prefix;\n\n      curr_prefix = (char *) xmalloc (curr_prefix_len + 1);\n#ifdef NO_XMALLOC\n      if (curr_prefix == NULL)\n        {\n          free (curr_installdir);\n          return NULL;\n        }\n#endif\n      memcpy (curr_prefix, curr_installdir, curr_prefix_len);\n      curr_prefix[curr_prefix_len] = '\\0';\n\n      free (curr_installdir);\n\n      return curr_prefix;\n    }\n  }\n}",
      "lines": 116,
      "depth": 17,
      "decorators": [
        "char",
        "*\ncompute_curr_prefix (const char *orig_installprefix,\n                     const char *orig_installdir,\n                     const char *curr_pathname)",
        "*"
      ]
    },
    "DllMain": {
      "start_point": [
        313,
        0
      ],
      "end_point": [
        335,
        1
      ],
      "content": "BOOL WINAPI\nDllMain (HINSTANCE module_handle, DWORD event, LPVOID reserved)\n{\n  (void) reserved;\n\n  if (event == DLL_PROCESS_ATTACH)\n    {\n      /* The DLL is being loaded into an application's address range.  */\n      static char location[MAX_PATH];\n\n      if (!GetModuleFileName (module_handle, location, sizeof (location)))\n        /* Shouldn't happen.  */\n        return FALSE;\n\n      if (!IS_PATH_WITH_DIR (location))\n        /* Shouldn't happen.  */\n        return FALSE;\n\n      shared_library_fullname = strdup (location);\n    }\n\n  return TRUE;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "BOOL",
        "WINAPI",
        "WINAPI"
      ]
    },
    "find_shared_library_fullname": {
      "start_point": [
        339,
        0
      ],
      "end_point": [
        390,
        1
      ],
      "content": "static void\nfind_shared_library_fullname ()\n{\n#if (defined __linux__ && (__GLIBC__ >= 2 || defined __UCLIBC__)) || defined __CYGWIN__\n  /* Linux has /proc/self/maps. glibc 2 and uClibc have the getline()\n     function.\n     Cygwin >= 1.5 has /proc/self/maps and the getline() function too.\n     But it is costly: ca. 0.3 ms on Linux, 3 ms on Cygwin 1.5, and 5 ms on\n     Cygwin 1.7.  */\n  FILE *fp;\n\n  /* Open the current process' maps file.  It describes one VMA per line.  */\n  fp = fopen (\"/proc/self/maps\", \"r\");\n  if (fp)\n    {\n      unsigned long address = (unsigned long) &find_shared_library_fullname;\n      for (;;)\n        {\n          unsigned long start, end;\n          int c;\n\n          if (fscanf (fp, \"%lx-%lx\", &start, &end) != 2)\n            break;\n          if (address >= start && address <= end - 1)\n            {\n              /* Found it.  Now see if this line contains a filename.  */\n              while (c = getc (fp), c != EOF && c != '\\n' && c != '/')\n                continue;\n              if (c == '/')\n                {\n                  size_t size;\n                  int len;\n\n                  ungetc (c, fp);\n                  shared_library_fullname = NULL; size = 0;\n                  len = getline (&shared_library_fullname, &size, fp);\n                  if (len >= 0)\n                    {\n                      /* Success: filled shared_library_fullname.  */\n                      if (len > 0 && shared_library_fullname[len - 1] == '\\n')\n                        shared_library_fullname[len - 1] = '\\0';\n                    }\n                }\n              break;\n            }\n          while (c = getc (fp), c != EOF && c != '\\n')\n            continue;\n        }\n      fclose (fp);\n    }\n#endif\n}",
      "lines": 52,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_shared_library_fullname": {
      "start_point": [
        397,
        0
      ],
      "end_point": [
        409,
        1
      ],
      "content": "static char *\nget_shared_library_fullname ()\n{\n#if !((defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__)\n  static bool tried_find_shared_library_fullname;\n  if (!tried_find_shared_library_fullname)\n    {\n      find_shared_library_fullname ();\n      tried_find_shared_library_fullname = true;\n    }\n#endif\n  return shared_library_fullname;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_shared_library_fullname ()",
        "*"
      ]
    },
    "relocate": {
      "start_point": [
        417,
        0
      ],
      "end_point": [
        493,
        1
      ],
      "content": "const char *\nrelocate (const char *pathname)\n{\n#if defined PIC && defined INSTALLDIR && ENABLE_COSTLY_RELOCATABLE\n  static int initialized;\n\n  /* Initialization code for a shared library.  */\n  if (!initialized)\n    {\n      /* At this point, orig_prefix and curr_prefix likely have already been\n         set through the main program's set_program_name_and_installdir\n         function.  This is sufficient in the case that the library has\n         initially been installed in the same orig_prefix.  But we can do\n         better, to also cover the cases that 1. it has been installed\n         in a different prefix before being moved to orig_prefix and (later)\n         to curr_prefix, 2. unlike the program, it has not moved away from\n         orig_prefix.  */\n      const char *orig_installprefix = INSTALLPREFIX;\n      const char *orig_installdir = INSTALLDIR;\n      char *curr_prefix_better;\n\n      curr_prefix_better =\n        compute_curr_prefix (orig_installprefix, orig_installdir,\n                             get_shared_library_fullname ());\n\n      set_relocation_prefix (orig_installprefix,\n                             curr_prefix_better != NULL\n                             ? curr_prefix_better\n                             : curr_prefix);\n\n      if (curr_prefix_better != NULL)\n        free (curr_prefix_better);\n\n      initialized = 1;\n    }\n#endif\n\n  /* Note: It is not necessary to perform case insensitive comparison here,\n     even for DOS-like file systems, because the pathname argument was\n     typically created from the same Makefile variable as orig_prefix came\n     from.  */\n  if (orig_prefix != NULL && curr_prefix != NULL\n      && strncmp (pathname, orig_prefix, orig_prefix_len) == 0)\n    {\n      if (pathname[orig_prefix_len] == '\\0')\n        {\n          /* pathname equals orig_prefix.  */\n          char *result = (char *) xmalloc (strlen (curr_prefix) + 1);\n\n#ifdef NO_XMALLOC\n          if (result != NULL)\n#endif\n            {\n              strcpy (result, curr_prefix);\n              return result;\n            }\n        }\n      else if (ISSLASH (pathname[orig_prefix_len]))\n        {\n          /* pathname starts with orig_prefix.  */\n          const char *pathname_tail = &pathname[orig_prefix_len];\n          char *result =\n            (char *) xmalloc (curr_prefix_len + strlen (pathname_tail) + 1);\n\n#ifdef NO_XMALLOC\n          if (result != NULL)\n#endif\n            {\n              memcpy (result, curr_prefix, curr_prefix_len);\n              strcpy (result + curr_prefix_len, pathname_tail);\n              return result;\n            }\n        }\n    }\n  /* Nothing to relocate.  */\n  return pathname;\n}",
      "lines": 77,
      "depth": 17,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nrelocate (const char *pathname)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/relocatable.h": {},
  "sharutils/sharutils-4.15.2/intl/setlocale.c": {
    "category_to_name": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static const char *\ncategory_to_name (int category)\n{\n  const char *retval;\n\n  switch (category)\n  {\n  case LC_COLLATE:\n    retval = \"LC_COLLATE\";\n    break;\n  case LC_CTYPE:\n    retval = \"LC_CTYPE\";\n    break;\n  case LC_MONETARY:\n    retval = \"LC_MONETARY\";\n    break;\n  case LC_NUMERIC:\n    retval = \"LC_NUMERIC\";\n    break;\n  case LC_TIME:\n    retval = \"LC_TIME\";\n    break;\n  case LC_MESSAGES:\n    retval = \"LC_MESSAGES\";\n    break;\n  default:\n    /* If you have a better idea for a default value let me know.  */\n    retval = \"LC_XXX\";\n  }\n\n  return retval;\n}",
      "lines": 32,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ncategory_to_name (int category)",
        "*"
      ]
    },
    "search": {
      "start_point": [
        575,
        0
      ],
      "end_point": [
        631,
        1
      ],
      "content": "static void\nsearch (const struct table_entry *table, size_t table_size, const char *string,\n        range_t *result)\n{\n  /* The table is sorted.  Perform a binary search.  */\n  size_t hi = table_size;\n  size_t lo = 0;\n  while (lo < hi)\n    {\n      /* Invariant:\n         for i < lo, strcmp (table[i].code, string) < 0,\n         for i >= hi, strcmp (table[i].code, string) > 0.  */\n      size_t mid = (hi + lo) >> 1; /* >= lo, < hi */\n      int cmp = strcmp (table[mid].code, string);\n      if (cmp < 0)\n        lo = mid + 1;\n      else if (cmp > 0)\n        hi = mid;\n      else\n        {\n          /* Found an i with\n               strcmp (language_table[i].code, string) == 0.\n             Find the entire interval of such i.  */\n          {\n            size_t i;\n\n            for (i = mid; i > lo; )\n              {\n                i--;\n                if (strcmp (table[i].code, string) < 0)\n                  {\n                    lo = i + 1;\n                    break;\n                  }\n              }\n          }\n          {\n            size_t i;\n\n            for (i = mid; i < hi; i++)\n              {\n                if (strcmp (table[i].code, string) > 0)\n                  {\n                    hi = i;\n                    break;\n                  }\n              }\n          }\n          /* The set of i with\n               strcmp (language_table[i].code, string) == 0\n             is the interval [lo, hi-1].  */\n          break;\n        }\n    }\n  result->lo = lo;\n  result->hi = hi;\n}",
      "lines": 57,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "setlocale_unixlike": {
      "start_point": [
        635,
        0
      ],
      "end_point": [
        784,
        1
      ],
      "content": "static char *\nsetlocale_unixlike (int category, const char *locale)\n{\n  char *result;\n  char llCC_buf[64];\n  char ll_buf[64];\n  char CC_buf[64];\n\n  /* First, try setlocale with the original argument unchanged.  */\n  result = setlocale (category, locale);\n  if (result != NULL)\n    return result;\n\n  /* Otherwise, assume the argument is in the form\n       language[_territory][.codeset][@modifier]\n     and try to map it using the tables.  */\n  if (strlen (locale) < sizeof (llCC_buf))\n    {\n      /* Second try: Remove the codeset part.  */\n      {\n        const char *p = locale;\n        char *q = llCC_buf;\n\n        /* Copy the part before the dot.  */\n        for (; *p != '\\0' && *p != '.'; p++, q++)\n          *q = *p;\n        if (*p == '.')\n          /* Skip the part up to the '@', if any.  */\n          for (; *p != '\\0' && *p != '@'; p++)\n            ;\n        /* Copy the part starting with '@', if any.  */\n        for (; *p != '\\0'; p++, q++)\n          *q = *p;\n        *q = '\\0';\n      }\n      /* llCC_buf now contains\n           language[_territory][@modifier]\n       */\n      if (strcmp (llCC_buf, locale) != 0)\n        {\n          result = setlocale (category, llCC_buf);\n          if (result != NULL)\n            return result;\n        }\n      /* Look it up in language_table.  */\n      {\n        range_t range;\n        size_t i;\n\n        search (language_table,\n                sizeof (language_table) / sizeof (language_table[0]),\n                llCC_buf,\n                &range);\n\n        for (i = range.lo; i < range.hi; i++)\n          {\n            /* Try the replacement in language_table[i].  */\n            result = setlocale (category, language_table[i].english);\n            if (result != NULL)\n              return result;\n          }\n      }\n      /* Split language[_territory][@modifier]\n         into  ll_buf = language[@modifier]\n         and   CC_buf = territory\n       */\n      {\n        const char *underscore = strchr (llCC_buf, '_');\n        if (underscore != NULL)\n          {\n            const char *territory_start = underscore + 1;\n            const char *territory_end = strchr (territory_start, '@');\n            if (territory_end == NULL)\n              territory_end = territory_start + strlen (territory_start);\n\n            memcpy (ll_buf, llCC_buf, underscore - llCC_buf);\n            strcpy (ll_buf + (underscore - llCC_buf), territory_end);\n\n            memcpy (CC_buf, territory_start, territory_end - territory_start);\n            CC_buf[territory_end - territory_start] = '\\0';\n\n            {\n              /* Look up ll_buf in language_table\n                 and CC_buf in country_table.  */\n              range_t language_range;\n\n              search (language_table,\n                      sizeof (language_table) / sizeof (language_table[0]),\n                      ll_buf,\n                      &language_range);\n              if (language_range.lo < language_range.hi)\n                {\n                  range_t country_range;\n\n                  search (country_table,\n                          sizeof (country_table) / sizeof (country_table[0]),\n                          CC_buf,\n                          &country_range);\n                  if (country_range.lo < country_range.hi)\n                    {\n                      size_t i;\n                      size_t j;\n\n                      for (i = language_range.lo; i < language_range.hi; i++)\n                        for (j = country_range.lo; j < country_range.hi; j++)\n                          {\n                            /* Concatenate the replacements.  */\n                            const char *part1 = language_table[i].english;\n                            size_t part1_len = strlen (part1);\n                            const char *part2 = country_table[j].english;\n                            size_t part2_len = strlen (part2) + 1;\n                            char buf[64+64];\n\n                            if (!(part1_len + 1 + part2_len <= sizeof (buf)))\n                              abort ();\n                            memcpy (buf, part1, part1_len);\n                            buf[part1_len] = '_';\n                            memcpy (buf + part1_len + 1, part2, part2_len);\n\n                            /* Try the concatenated replacements.  */\n                            result = setlocale (category, buf);\n                            if (result != NULL)\n                              return result;\n                          }\n                    }\n\n                  /* Try omitting the country entirely.  This may set a locale\n                     corresponding to the wrong country, but is better than\n                     failing entirely.  */\n                  {\n                    size_t i;\n\n                    for (i = language_range.lo; i < language_range.hi; i++)\n                      {\n                        /* Try only the language replacement.  */\n                        result =\n                          setlocale (category, language_table[i].english);\n                        if (result != NULL)\n                          return result;\n                      }\n                  }\n                }\n            }\n          }\n      }\n    }\n\n  /* Failed.  */\n  return NULL;\n}",
      "lines": 150,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nsetlocale_unixlike (int category, const char *locale)",
        "*"
      ]
    },
    "setlocale_single": {
      "start_point": [
        796,
        0
      ],
      "end_point": [
        810,
        1
      ],
      "content": "static char *\nsetlocale_single (int category, const char *locale)\n{\n  if (category == LC_MESSAGES)\n    {\n      if (locale != NULL)\n        {\n          lc_messages_name[sizeof (lc_messages_name) - 1] = '\\0';\n          strncpy (lc_messages_name, locale, sizeof (lc_messages_name) - 1);\n        }\n      return lc_messages_name;\n    }\n  else\n    return setlocale_unixlike (category, locale);\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nsetlocale_single (int category, const char *locale)",
        "*"
      ]
    },
    "libintl_setlocale": {
      "start_point": [
        816,
        0
      ],
      "end_point": [
        956,
        1
      ],
      "content": "DLL_EXPORTED\nchar *\nlibintl_setlocale (int category, const char *locale)\n{\n  if (locale != NULL && locale[0] == '\\0')\n    {\n      /* A request to the set the current locale to the default locale.  */\n      if (category == LC_ALL)\n        {\n          /* Set LC_CTYPE first.  Then the other categories.  */\n          static int const categories[] =\n            {\n              LC_NUMERIC,\n              LC_TIME,\n              LC_COLLATE,\n              LC_MONETARY,\n              LC_MESSAGES\n            };\n          char *saved_locale;\n          const char *base_name;\n          unsigned int i;\n\n          /* Back up the old locale, in case one of the steps fails.  */\n          saved_locale = setlocale (LC_ALL, NULL);\n          if (saved_locale == NULL)\n            return NULL;\n          saved_locale = strdup (saved_locale);\n          if (saved_locale == NULL)\n            return NULL;\n\n          /* Set LC_CTYPE category.  Set all other categories (except possibly\n             LC_MESSAGES) to the same value in the same call; this is likely to\n             save calls.  */\n          base_name =\n            gl_locale_name_environ (LC_CTYPE, category_to_name (LC_CTYPE));\n          if (base_name == NULL)\n            base_name = gl_locale_name_default ();\n\n          if (setlocale_unixlike (LC_ALL, base_name) == NULL)\n            goto fail;\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n          /* On native Windows, setlocale(LC_ALL,...) may succeed but set the\n             LC_CTYPE category to an invalid value (\"C\") when it does not\n             support the specified encoding.  Report a failure instead.  */\n          if (strchr (base_name, '.') != NULL\n              && strcmp (setlocale (LC_CTYPE, NULL), \"C\") == 0)\n            goto fail;\n# endif\n\n          for (i = 0; i < sizeof (categories) / sizeof (categories[0]); i++)\n            {\n              int cat = categories[i];\n              const char *name;\n\n              name = gl_locale_name_environ (cat, category_to_name (cat));\n              if (name == NULL)\n                name = gl_locale_name_default ();\n\n              /* If name is the same as base_name, it has already been set\n                 through the setlocale call before the loop.  */\n              if (strcmp (name, base_name) != 0\n# if LC_MESSAGES == 1729\n                  || cat == LC_MESSAGES\n# endif\n                 )\n                if (setlocale_single (cat, name) == NULL)\n                  goto fail;\n            }\n\n          /* All steps were successful.  */\n          ++_nl_msg_cat_cntr;\n          free (saved_locale);\n          return setlocale (LC_ALL, NULL);\n\n        fail:\n          if (saved_locale[0] != '\\0') /* don't risk an endless recursion */\n            setlocale (LC_ALL, saved_locale);\n          free (saved_locale);\n          return NULL;\n        }\n      else\n        {\n          char *result;\n          const char *name =\n            gl_locale_name_environ (category, category_to_name (category));\n          if (name == NULL)\n            name = gl_locale_name_default ();\n\n          result = setlocale_single (category, name);\n          if (result != NULL)\n            ++_nl_msg_cat_cntr;\n          return result;\n        }\n    }\n  else\n    {\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n      if (category == LC_ALL && locale != NULL && strchr (locale, '.') != NULL)\n        {\n          char *saved_locale;\n\n          /* Back up the old locale.  */\n          saved_locale = setlocale (LC_ALL, NULL);\n          if (saved_locale == NULL)\n            return NULL;\n          saved_locale = strdup (saved_locale);\n          if (saved_locale == NULL)\n            return NULL;\n\n          if (setlocale_unixlike (LC_ALL, locale) == NULL)\n            {\n              free (saved_locale);\n              return NULL;\n            }\n\n          /* On native Windows, setlocale(LC_ALL,...) may succeed but set the\n             LC_CTYPE category to an invalid value (\"C\") when it does not\n             support the specified encoding.  Report a failure instead.  */\n          if (strcmp (setlocale (LC_CTYPE, NULL), \"C\") == 0)\n            {\n              if (saved_locale[0] != '\\0') /* don't risk an endless recursion */\n                setlocale (LC_ALL, saved_locale);\n              free (saved_locale);\n              return NULL;\n            }\n\n          /* It was really successful.  */\n          ++_nl_msg_cat_cntr;\n          free (saved_locale);\n          return setlocale (LC_ALL, NULL);\n        }\n      else\n# endif\n        {\n          char *result = setlocale_single (category, locale);\n          if (result != NULL)\n            ++_nl_msg_cat_cntr;\n          return result;\n        }\n    }\n}",
      "lines": 141,
      "depth": 16,
      "decorators": [
        "DLL_EXPORTED",
        "char",
        "char",
        "*\nlibintl_setlocale (int category, const char *locale)",
        "*"
      ]
    },
    "libintl_newlocale": {
      "start_point": [
        960,
        0
      ],
      "end_point": [
        1065,
        1
      ],
      "content": "DLL_EXPORTED\nlocale_t\nlibintl_newlocale (int category_mask, const char *locale, locale_t base)\n{\n  if (category_mask != 0 && locale != NULL && locale[0] == '\\0')\n    {\n      /* A request to construct a locale_t object that refers to the default\n         locale.  */\n\n      /* Set LC_CTYPE first.  Then the other categories.  */\n      static struct { int cat; int mask; } const categories[] =\n        {\n          { LC_CTYPE,    LC_CTYPE_MASK },\n          { LC_NUMERIC,  LC_NUMERIC_MASK },\n          { LC_TIME,     LC_TIME_MASK },\n          { LC_COLLATE,  LC_COLLATE_MASK },\n          { LC_MONETARY, LC_MONETARY_MASK },\n          { LC_MESSAGES, LC_MESSAGES_MASK }\n        };\n\n      locale_t orig_base = base;\n\n      if ((LC_ALL_MASK & ~category_mask) == 0)\n        {\n          const char *base_name;\n          unsigned int i;\n\n          /* Set LC_CTYPE category.  Set all other categories (except possibly\n             LC_MESSAGES) to the same value in the same call; this is likely to\n             save calls.  */\n          base_name =\n            gl_locale_name_environ (LC_CTYPE, category_to_name (LC_CTYPE));\n          if (base_name == NULL)\n            base_name = gl_locale_name_default ();\n\n          base = newlocale (LC_ALL_MASK, base_name, base);\n          if (base == NULL)\n            return NULL;\n\n          for (i = 1; i < sizeof (categories) / sizeof (categories[0]); i++)\n            {\n              int category = categories[i].cat;\n              int category_mask = categories[i].mask;\n              const char *name;\n\n              name =\n                gl_locale_name_environ (category, category_to_name (category));\n              if (name == NULL)\n                name = gl_locale_name_default ();\n\n              /* If name is the same as base_name, it has already been set\n                 through the setlocale call before the loop.  */\n              if (strcmp (name, base_name) != 0)\n                {\n                  locale_t copy = newlocale (category_mask, name, base);\n                  if (copy == NULL)\n                    goto fail;\n                  /* No need to call freelocale (base) if copy != base; the\n                     newlocale function already takes care of doing it.  */\n                  base = copy;\n                }\n            }\n        }\n      else\n        {\n          unsigned int i;\n\n          for (i = 0; i < sizeof (categories) / sizeof (categories[0]); i++)\n            {\n              int cat_mask = categories[i].mask;\n\n              if ((category_mask & cat_mask) != 0)\n                {\n                  int cat = categories[i].cat;\n                  const char *name;\n                  locale_t copy;\n\n                  name = gl_locale_name_environ (cat, category_to_name (cat));\n                  if (name == NULL)\n                    name = gl_locale_name_default ();\n\n                  copy = newlocale (cat_mask, name, base);\n                  if (copy == NULL)\n                    goto fail;\n                  /* No need to call freelocale (base) if copy != base; the\n                     newlocale function already takes care of doing it.  */\n                  base = copy;\n                }\n            }\n        }\n\n      /* All steps were successful.  */\n      return base;\n\n    fail:\n      if (base != NULL && orig_base == NULL)\n        {\n          int saved_errno = errno;\n          freelocale (base);\n          errno = saved_errno;\n        }\n      return NULL;\n    }\n  else\n    return newlocale (category_mask, locale, base);\n}",
      "lines": 106,
      "depth": 17,
      "decorators": [
        "DLL_EXPORTED",
        "locale_t",
        "locale_t"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/textdomain.c": {
    "TEXTDOMAIN": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "char *\nTEXTDOMAIN (const char *domainname)\n{\n  char *new_domain;\n  char *old_domain;\n\n  /* A NULL pointer requests the current setting.  */\n  if (domainname == NULL)\n    return (char *) _nl_current_default_domain;\n\n  gl_rwlock_wrlock (_nl_state_lock);\n\n  old_domain = (char *) _nl_current_default_domain;\n\n  /* If domain name is the null string set to default domain \"messages\".  */\n  if (domainname[0] == '\\0'\n      || strcmp (domainname, _nl_default_default_domain) == 0)\n    {\n      _nl_current_default_domain = _nl_default_default_domain;\n      new_domain = (char *) _nl_current_default_domain;\n    }\n  else if (strcmp (domainname, old_domain) == 0)\n    /* This can happen and people will use it to signal that some\n       environment variable changed.  */\n    new_domain = old_domain;\n  else\n    {\n      /* If the following malloc fails `_nl_current_default_domain'\n\t will be NULL.  This value will be returned and so signals we\n\t are out of core.  */\n#if defined _LIBC || defined HAVE_STRDUP\n      new_domain = strdup (domainname);\n#else\n      size_t len = strlen (domainname) + 1;\n      new_domain = (char *) malloc (len);\n      if (new_domain != NULL)\n\tmemcpy (new_domain, domainname, len);\n#endif\n\n      if (new_domain != NULL)\n\t_nl_current_default_domain = new_domain;\n    }\n\n  /* We use this possibility to signal a change of the loaded catalogs\n     since this is most likely the case and there is no other easy we\n     to do it.  Do it only when the call was successful.  */\n  if (new_domain != NULL)\n    {\n      ++_nl_msg_cat_cntr;\n\n      if (old_domain != new_domain && old_domain != _nl_default_default_domain)\n\tfree (old_domain);\n    }\n\n  gl_rwlock_unlock (_nl_state_lock);\n\n  return new_domain;\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "char",
        "*\nTEXTDOMAIN (const char *domainname)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/threadlib.c": {
    "dummy_thread_func": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static void *\ndummy_thread_func (void *arg)\n{\n  return arg;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndummy_thread_func (void *arg)",
        "*"
      ]
    },
    "glthread_in_use": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\nglthread_in_use (void)\n{\n  static int tested;\n  static int result; /* 1: linked with -lpthread, 0: only with libc */\n\n  if (!tested)\n    {\n      pthread_t thread;\n\n      if (pthread_create (&thread, NULL, dummy_thread_func, NULL) != 0)\n        /* Thread creation failed.  */\n        result = 0;\n      else\n        {\n          /* Thread creation works.  */\n          void *retval;\n          if (pthread_join (thread, &retval) != 0)\n            abort ();\n          result = 1;\n        }\n      tested = 1;\n    }\n  return result;\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/tsearch.c": {
    "check_tree_recurse": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "static void\ncheck_tree_recurse (node p, int d_sofar, int d_total)\n{\n  if (p == NULL)\n    {\n      assert (d_sofar == d_total);\n      return;\n    }\n\n  check_tree_recurse (p->left, d_sofar + (p->left && !p->left->red), d_total);\n  check_tree_recurse (p->right, d_sofar + (p->right && !p->right->red), d_total);\n  if (p->left)\n    assert (!(p->left->red && p->red));\n  if (p->right)\n    assert (!(p->right->red && p->red));\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_tree": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "static void\ncheck_tree (node root)\n{\n  int cnt = 0;\n  node p;\n  if (root == NULL)\n    return;\n  root->red = 0;\n  for(p = root->left; p; p = p->left)\n    cnt += !p->red;\n  check_tree_recurse (root, 0, cnt);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "maybe_split_for_insert": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "static void\nmaybe_split_for_insert (node *rootp, node *parentp, node *gparentp,\n                        int p_r, int gp_r, int mode)\n{\n  node root = *rootp;\n  node *rp, *lp;\n  rp = &(*rootp)->right;\n  lp = &(*rootp)->left;\n\n  /* See if we have to split this node (both successors red).  */\n  if (mode == 1\n      || ((*rp) != NULL && (*lp) != NULL && (*rp)->red && (*lp)->red))\n    {\n      /* This node becomes red, its successors black.  */\n      root->red = 1;\n      if (*rp)\n        (*rp)->red = 0;\n      if (*lp)\n        (*lp)->red = 0;\n\n      /* If the parent of this node is also red, we have to do\n         rotations.  */\n      if (parentp != NULL && (*parentp)->red)\n        {\n          node gp = *gparentp;\n          node p = *parentp;\n          /* There are two main cases:\n             1. The edge types (left or right) of the two red edges differ.\n             2. Both red edges are of the same type.\n             There exist two symmetries of each case, so there is a total of\n             4 cases.  */\n          if ((p_r > 0) != (gp_r > 0))\n            {\n              /* Put the child at the top of the tree, with its parent\n                 and grandparent as successors.  */\n              p->red = 1;\n              gp->red = 1;\n              root->red = 0;\n              if (p_r < 0)\n                {\n                  /* Child is left of parent.  */\n                  p->left = *rp;\n                  *rp = p;\n                  gp->right = *lp;\n                  *lp = gp;\n                }\n              else\n                {\n                  /* Child is right of parent.  */\n                  p->right = *lp;\n                  *lp = p;\n                  gp->left = *rp;\n                  *rp = gp;\n                }\n              *gparentp = root;\n            }\n          else\n            {\n              *gparentp = *parentp;\n              /* Parent becomes the top of the tree, grandparent and\n                 child are its successors.  */\n              p->red = 0;\n              gp->red = 1;\n              if (p_r < 0)\n                {\n                  /* Left edges.  */\n                  gp->left = p->right;\n                  p->right = gp;\n                }\n              else\n                {\n                  /* Right edges.  */\n                  gp->right = p->left;\n                  p->left = gp;\n                }\n            }\n        }\n    }\n}",
      "lines": 79,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "__tsearch": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        318,
        1
      ],
      "content": "void *\n__tsearch (const void *key, void **vrootp, __compar_fn_t compar)\n{\n  node q;\n  node *parentp = NULL, *gparentp = NULL;\n  node *rootp = (node *) vrootp;\n  node *nextp;\n  int r = 0, p_r = 0, gp_r = 0; /* No they might not, Mr Compiler.  */\n\n  if (rootp == NULL)\n    return NULL;\n\n  /* This saves some additional tests below.  */\n  if (*rootp != NULL)\n    (*rootp)->red = 0;\n\n  CHECK_TREE (*rootp);\n\n  nextp = rootp;\n  while (*nextp != NULL)\n    {\n      node root = *rootp;\n      r = (*compar) (key, root->key);\n      if (r == 0)\n        return root;\n\n      maybe_split_for_insert (rootp, parentp, gparentp, p_r, gp_r, 0);\n      /* If that did any rotations, parentp and gparentp are now garbage.\n         That doesn't matter, because the values they contain are never\n         used again in that case.  */\n\n      nextp = r < 0 ? &root->left : &root->right;\n      if (*nextp == NULL)\n        break;\n\n      gparentp = parentp;\n      parentp = rootp;\n      rootp = nextp;\n\n      gp_r = p_r;\n      p_r = r;\n    }\n\n  q = (struct node_t *) malloc (sizeof (struct node_t));\n  if (q != NULL)\n    {\n      *nextp = q;                       /* link new node to old */\n      q->key = key;                     /* initialize new node */\n      q->red = 1;\n      q->left = q->right = NULL;\n\n      if (nextp != rootp)\n        /* There may be two red edges in a row now, which we must avoid by\n           rotating the tree.  */\n        maybe_split_for_insert (nextp, rootp, parentp, r, p_r, 1);\n    }\n\n  return q;\n}",
      "lines": 59,
      "depth": 11,
      "decorators": [
        "void",
        "*\n__tsearch (const void *key, void **vrootp, __compar_fn_t compar)",
        "*"
      ]
    },
    "__tdelete": {
      "start_point": [
        361,
        0
      ],
      "end_point": [
        604,
        1
      ],
      "content": "void *\n__tdelete (const void *key, void **vrootp, __compar_fn_t compar)\n{\n  node p, q, r, retval;\n  int cmp;\n  node *rootp = (node *) vrootp;\n  node root, unchained;\n  /* Stack of nodes so we remember the parents without recursion.  It's\n     _very_ unlikely that there are paths longer than 40 nodes.  The tree\n     would need to have around 250.000 nodes.  */\n  int stacksize = 100;\n  int sp = 0;\n  node *nodestack[100];\n\n  if (rootp == NULL)\n    return NULL;\n  p = *rootp;\n  if (p == NULL)\n    return NULL;\n\n  CHECK_TREE (p);\n\n  while ((cmp = (*compar) (key, (*rootp)->key)) != 0)\n    {\n      if (sp == stacksize)\n        abort ();\n\n      nodestack[sp++] = rootp;\n      p = *rootp;\n      rootp = ((cmp < 0)\n               ? &(*rootp)->left\n               : &(*rootp)->right);\n      if (*rootp == NULL)\n        return NULL;\n    }\n\n  /* This is bogus if the node to be deleted is the root... this routine\n     really should return an integer with 0 for success, -1 for failure\n     and errno = ESRCH or something.  */\n  retval = p;\n\n  /* We don't unchain the node we want to delete. Instead, we overwrite\n     it with its successor and unchain the successor.  If there is no\n     successor, we really unchain the node to be deleted.  */\n\n  root = *rootp;\n\n  r = root->right;\n  q = root->left;\n\n  if (q == NULL || r == NULL)\n    unchained = root;\n  else\n    {\n      node *parent = rootp, *up = &root->right;\n      for (;;)\n        {\n          if (sp == stacksize)\n            abort ();\n          nodestack[sp++] = parent;\n          parent = up;\n          if ((*up)->left == NULL)\n            break;\n          up = &(*up)->left;\n        }\n      unchained = *up;\n    }\n\n  /* We know that either the left or right successor of UNCHAINED is NULL.\n     R becomes the other one, it is chained into the parent of UNCHAINED.  */\n  r = unchained->left;\n  if (r == NULL)\n    r = unchained->right;\n  if (sp == 0)\n    *rootp = r;\n  else\n    {\n      q = *nodestack[sp-1];\n      if (unchained == q->right)\n        q->right = r;\n      else\n        q->left = r;\n    }\n\n  if (unchained != root)\n    root->key = unchained->key;\n  if (!unchained->red)\n    {\n      /* Now we lost a black edge, which means that the number of black\n         edges on every path is no longer constant.  We must balance the\n         tree.  */\n      /* NODESTACK now contains all parents of R.  R is likely to be NULL\n         in the first iteration.  */\n      /* NULL nodes are considered black throughout - this is necessary for\n         correctness.  */\n      while (sp > 0 && (r == NULL || !r->red))\n        {\n          node *pp = nodestack[sp - 1];\n          p = *pp;\n          /* Two symmetric cases.  */\n          if (r == p->left)\n            {\n              /* Q is R's brother, P is R's parent.  The subtree with root\n                 R has one black edge less than the subtree with root Q.  */\n              q = p->right;\n              if (q->red)\n                {\n                  /* If Q is red, we know that P is black. We rotate P left\n                     so that Q becomes the top node in the tree, with P below\n                     it.  P is colored red, Q is colored black.\n                     This action does not change the black edge count for any\n                     leaf in the tree, but we will be able to recognize one\n                     of the following situations, which all require that Q\n                     is black.  */\n                  q->red = 0;\n                  p->red = 1;\n                  /* Left rotate p.  */\n                  p->right = q->left;\n                  q->left = p;\n                  *pp = q;\n                  /* Make sure pp is right if the case below tries to use\n                     it.  */\n                  nodestack[sp++] = pp = &q->left;\n                  q = p->right;\n                }\n              /* We know that Q can't be NULL here.  We also know that Q is\n                 black.  */\n              if ((q->left == NULL || !q->left->red)\n                  && (q->right == NULL || !q->right->red))\n                {\n                  /* Q has two black successors.  We can simply color Q red.\n                     The whole subtree with root P is now missing one black\n                     edge.  Note that this action can temporarily make the\n                     tree invalid (if P is red).  But we will exit the loop\n                     in that case and set P black, which both makes the tree\n                     valid and also makes the black edge count come out\n                     right.  If P is black, we are at least one step closer\n                     to the root and we'll try again the next iteration.  */\n                  q->red = 1;\n                  r = p;\n                }\n              else\n                {\n                  /* Q is black, one of Q's successors is red.  We can\n                     repair the tree with one operation and will exit the\n                     loop afterwards.  */\n                  if (q->right == NULL || !q->right->red)\n                    {\n                      /* The left one is red.  We perform the same action as\n                         in maybe_split_for_insert where two red edges are\n                         adjacent but point in different directions:\n                         Q's left successor (let's call it Q2) becomes the\n                         top of the subtree we are looking at, its parent (Q)\n                         and grandparent (P) become its successors. The former\n                         successors of Q2 are placed below P and Q.\n                         P becomes black, and Q2 gets the color that P had.\n                         This changes the black edge count only for node R and\n                         its successors.  */\n                      node q2 = q->left;\n                      q2->red = p->red;\n                      p->right = q2->left;\n                      q->left = q2->right;\n                      q2->right = q;\n                      q2->left = p;\n                      *pp = q2;\n                      p->red = 0;\n                    }\n                  else\n                    {\n                      /* It's the right one.  Rotate P left. P becomes black,\n                         and Q gets the color that P had.  Q's right successor\n                         also becomes black.  This changes the black edge\n                         count only for node R and its successors.  */\n                      q->red = p->red;\n                      p->red = 0;\n\n                      q->right->red = 0;\n\n                      /* left rotate p */\n                      p->right = q->left;\n                      q->left = p;\n                      *pp = q;\n                    }\n\n                  /* We're done.  */\n                  sp = 1;\n                  r = NULL;\n                }\n            }\n          else\n            {\n              /* Comments: see above.  */\n              q = p->left;\n              if (q->red)\n                {\n                  q->red = 0;\n                  p->red = 1;\n                  p->left = q->right;\n                  q->right = p;\n                  *pp = q;\n                  nodestack[sp++] = pp = &q->right;\n                  q = p->left;\n                }\n              if ((q->right == NULL || !q->right->red)\n                       && (q->left == NULL || !q->left->red))\n                {\n                  q->red = 1;\n                  r = p;\n                }\n              else\n                {\n                  if (q->left == NULL || !q->left->red)\n                    {\n                      node q2 = q->right;\n                      q2->red = p->red;\n                      p->left = q2->right;\n                      q->right = q2->left;\n                      q2->left = q;\n                      q2->right = p;\n                      *pp = q2;\n                      p->red = 0;\n                    }\n                  else\n                    {\n                      q->red = p->red;\n                      p->red = 0;\n                      q->left->red = 0;\n                      p->left = q->right;\n                      q->right = p;\n                      *pp = q;\n                    }\n                  sp = 1;\n                  r = NULL;\n                }\n            }\n          --sp;\n        }\n      if (r != NULL)\n        r->red = 0;\n    }\n\n  free (unchained);\n  return retval;\n}",
      "lines": 244,
      "depth": 17,
      "decorators": [
        "void",
        "*\n__tdelete (const void *key, void **vrootp, __compar_fn_t compar)",
        "*"
      ]
    },
    "internal_function": {
      "start_point": [
        613,
        0
      ],
      "end_point": [
        631,
        1
      ],
      "content": "static void\ninternal_function\ntrecurse (const void *vroot, __action_fn_t action, int level)\n{\n  const_node root = (const_node) vroot;\n\n  if (root->left == NULL && root->right == NULL)\n    (*action) (root, leaf, level);\n  else\n    {\n      (*action) (root, preorder, level);\n      if (root->left != NULL)\n        trecurse (root->left, action, level + 1);\n      (*action) (root, postorder, level);\n      if (root->right != NULL)\n        trecurse (root->right, action, level + 1);\n      (*action) (root, endorder, level);\n    }\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "__twalk": {
      "start_point": [
        637,
        0
      ],
      "end_point": [
        646,
        1
      ],
      "content": "void\n__twalk (const void *vroot, __action_fn_t action)\n{\n  const_node root = (const_node) vroot;\n\n  CHECK_TREE (root);\n\n  if (root != NULL && action != NULL)\n    trecurse (root, action, 0);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "tdestroy_recurse": {
      "start_point": [
        656,
        0
      ],
      "end_point": [
        667,
        1
      ],
      "content": "static void\ninternal_function\ntdestroy_recurse (node root, __free_fn_t freefct)\n{\n  if (root->left != NULL)\n    tdestroy_recurse (root->left, freefct);\n  if (root->right != NULL)\n    tdestroy_recurse (root->right, freefct);\n  (*freefct) ((void *) root->key);\n  /* Free the node itself.  */\n  free (root);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "__tdestroy": {
      "start_point": [
        669,
        0
      ],
      "end_point": [
        678,
        1
      ],
      "content": "void\n__tdestroy (void *vroot, __free_fn_t freefct)\n{\n  node root = (node) vroot;\n\n  CHECK_TREE (root);\n\n  if (root != NULL)\n    tdestroy_recurse (root, freefct);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/tsearch.h": {},
  "sharutils/sharutils-4.15.2/intl/vasnprintf.c": {
    "local_strnlen": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "static size_t\nlocal_strnlen (const char *string, size_t maxlen)\n{\n  const char *end = memchr (string, '\\0', maxlen);\n  return end ? (size_t) (end - string) : maxlen;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "local_wcslen": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "static size_t\nlocal_wcslen (const wchar_t *s)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; *ptr != (wchar_t) 0; ptr++)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "local_wcsnlen": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "static size_t\nlocal_wcsnlen (const wchar_t *s, size_t maxlen)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; maxlen > 0 && *ptr != (wchar_t) 0; ptr++, maxlen--)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "decimal_point_char": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "static char\ndecimal_point_char (void)\n{\n  const char *point;\n  /* Determine it in a multithread-safe way.  We know nl_langinfo is\n     multithread-safe on glibc systems and Mac OS X systems, but is not required\n     to be multithread-safe by POSIX.  sprintf(), however, is multithread-safe.\n     localeconv() is rarely multithread-safe.  */\n#  if HAVE_NL_LANGINFO && (__GLIBC__ || defined __UCLIBC__ || (defined __APPLE__ && defined __MACH__))\n  point = nl_langinfo (RADIXCHAR);\n#  elif 1\n  char pointbuf[5];\n  sprintf (pointbuf, \"%#.0f\", 1.0);\n  point = &pointbuf[1];\n#  else\n  point = localeconv () -> decimal_point;\n#  endif\n  /* The decimal point is always a single byte: either '.' or ','.  */\n  return (point[0] != '\\0' ? point[0] : '.');\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "is_infinite_or_zero": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        302,
        1
      ],
      "content": "static int\nis_infinite_or_zero (double x)\n{\n  return isnand (x) || x + x == x;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_infinite_or_zerol": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "static int\nis_infinite_or_zerol (long double x)\n{\n  return isnanl (x) || x + x == x;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "multiply": {
      "start_point": [
        341,
        0
      ],
      "end_point": [
        404,
        1
      ],
      "content": "static void *\nmultiply (mpn_t src1, mpn_t src2, mpn_t *dest)\n{\n  const mp_limb_t *p1;\n  const mp_limb_t *p2;\n  size_t len1;\n  size_t len2;\n\n  if (src1.nlimbs <= src2.nlimbs)\n    {\n      len1 = src1.nlimbs;\n      p1 = src1.limbs;\n      len2 = src2.nlimbs;\n      p2 = src2.limbs;\n    }\n  else\n    {\n      len1 = src2.nlimbs;\n      p1 = src2.limbs;\n      len2 = src1.nlimbs;\n      p2 = src1.limbs;\n    }\n  /* Now 0 <= len1 <= len2.  */\n  if (len1 == 0)\n    {\n      /* src1 or src2 is zero.  */\n      dest->nlimbs = 0;\n      dest->limbs = (mp_limb_t *) malloc (1);\n    }\n  else\n    {\n      /* Here 1 <= len1 <= len2.  */\n      size_t dlen;\n      mp_limb_t *dp;\n      size_t k, i, j;\n\n      dlen = len1 + len2;\n      dp = (mp_limb_t *) malloc (dlen * sizeof (mp_limb_t));\n      if (dp == NULL)\n        return NULL;\n      for (k = len2; k > 0; )\n        dp[--k] = 0;\n      for (i = 0; i < len1; i++)\n        {\n          mp_limb_t digit1 = p1[i];\n          mp_twolimb_t carry = 0;\n          for (j = 0; j < len2; j++)\n            {\n              mp_limb_t digit2 = p2[j];\n              carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n              carry += dp[i + j];\n              dp[i + j] = (mp_limb_t) carry;\n              carry = carry >> GMP_LIMB_BITS;\n            }\n          dp[i + len2] = (mp_limb_t) carry;\n        }\n      /* Normalise.  */\n      while (dlen > 0 && dp[dlen - 1] == 0)\n        dlen--;\n      dest->nlimbs = dlen;\n      dest->limbs = dp;\n    }\n  return dest->limbs;\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nmultiply (mpn_t src1, mpn_t src2, mpn_t *dest)",
        "*"
      ]
    },
    "divide": {
      "start_point": [
        413,
        0
      ],
      "end_point": [
        836,
        1
      ],
      "content": "static void *\ndivide (mpn_t a, mpn_t b, mpn_t *q)\n{\n  /* Algorithm:\n     First normalise a and b: a=[a[m-1],...,a[0]], b=[b[n-1],...,b[0]]\n     with m>=0 and n>0 (in base beta = 2^GMP_LIMB_BITS).\n     If m<n, then q:=0 and r:=a.\n     If m>=n=1, perform a single-precision division:\n       r:=0, j:=m,\n       while j>0 do\n         {Here (q[m-1]*beta^(m-1)+...+q[j]*beta^j) * b[0] + r*beta^j =\n               = a[m-1]*beta^(m-1)+...+a[j]*beta^j und 0<=r<b[0]<beta}\n         j:=j-1, r:=r*beta+a[j], q[j]:=floor(r/b[0]), r:=r-b[0]*q[j].\n       Normalise [q[m-1],...,q[0]], yields q.\n     If m>=n>1, perform a multiple-precision division:\n       We have a/b < beta^(m-n+1).\n       s:=intDsize-1-(highest bit in b[n-1]), 0<=s<intDsize.\n       Shift a and b left by s bits, copying them. r:=a.\n       r=[r[m],...,r[0]], b=[b[n-1],...,b[0]] with b[n-1]>=beta/2.\n       For j=m-n,...,0: {Here 0 <= r < b*beta^(j+1).}\n         Compute q* :\n           q* := floor((r[j+n]*beta+r[j+n-1])/b[n-1]).\n           In case of overflow (q* >= beta) set q* := beta-1.\n           Compute c2 := ((r[j+n]*beta+r[j+n-1]) - q* * b[n-1])*beta + r[j+n-2]\n           and c3 := b[n-2] * q*.\n           {We have 0 <= c2 < 2*beta^2, even 0 <= c2 < beta^2 if no overflow\n            occurred.  Furthermore 0 <= c3 < beta^2.\n            If there was overflow and\n            r[j+n]*beta+r[j+n-1] - q* * b[n-1] >= beta, i.e. c2 >= beta^2,\n            the next test can be skipped.}\n           While c3 > c2, {Here 0 <= c2 < c3 < beta^2}\n             Put q* := q* - 1, c2 := c2 + b[n-1]*beta, c3 := c3 - b[n-2].\n           If q* > 0:\n             Put r := r - b * q* * beta^j. In detail:\n               [r[n+j],...,r[j]] := [r[n+j],...,r[j]] - q* * [b[n-1],...,b[0]].\n               hence: u:=0, for i:=0 to n-1 do\n                              u := u + q* * b[i],\n                              r[j+i]:=r[j+i]-(u mod beta) (+ beta, if carry),\n                              u:=u div beta (+ 1, if carry in subtraction)\n                      r[n+j]:=r[n+j]-u.\n               {Since always u = (q* * [b[i-1],...,b[0]] div beta^i) + 1\n                               < q* + 1 <= beta,\n                the carry u does not overflow.}\n             If a negative carry occurs, put q* := q* - 1\n               and [r[n+j],...,r[j]] := [r[n+j],...,r[j]] + [0,b[n-1],...,b[0]].\n         Set q[j] := q*.\n       Normalise [q[m-n],..,q[0]]; this yields the quotient q.\n       Shift [r[n-1],...,r[0]] right by s bits and normalise; this yields the\n       rest r.\n       The room for q[j] can be allocated at the memory location of r[n+j].\n     Finally, round-to-even:\n       Shift r left by 1 bit.\n       If r > b or if r = b and q[0] is odd, q := q+1.\n   */\n  const mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  const mp_limb_t *b_ptr = b.limbs;\n  size_t b_len = b.nlimbs;\n  mp_limb_t *roomptr;\n  mp_limb_t *tmp_roomptr = NULL;\n  mp_limb_t *q_ptr;\n  size_t q_len;\n  mp_limb_t *r_ptr;\n  size_t r_len;\n\n  /* Allocate room for a_len+2 digits.\n     (Need a_len+1 digits for the real division and 1 more digit for the\n     final rounding of q.)  */\n  roomptr = (mp_limb_t *) malloc ((a_len + 2) * sizeof (mp_limb_t));\n  if (roomptr == NULL)\n    return NULL;\n\n  /* Normalise a.  */\n  while (a_len > 0 && a_ptr[a_len - 1] == 0)\n    a_len--;\n\n  /* Normalise b.  */\n  for (;;)\n    {\n      if (b_len == 0)\n        /* Division by zero.  */\n        abort ();\n      if (b_ptr[b_len - 1] == 0)\n        b_len--;\n      else\n        break;\n    }\n\n  /* Here m = a_len >= 0 and n = b_len > 0.  */\n\n  if (a_len < b_len)\n    {\n      /* m<n: trivial case.  q=0, r := copy of a.  */\n      r_ptr = roomptr;\n      r_len = a_len;\n      memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n      q_ptr = roomptr + a_len;\n      q_len = 0;\n    }\n  else if (b_len == 1)\n    {\n      /* n=1: single precision division.\n         beta^(m-1) <= a < beta^m  ==>  beta^(m-2) <= a/b < beta^m  */\n      r_ptr = roomptr;\n      q_ptr = roomptr + 1;\n      {\n        mp_limb_t den = b_ptr[0];\n        mp_limb_t remainder = 0;\n        const mp_limb_t *sourceptr = a_ptr + a_len;\n        mp_limb_t *destptr = q_ptr + a_len;\n        size_t count;\n        for (count = a_len; count > 0; count--)\n          {\n            mp_twolimb_t num =\n              ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--sourceptr;\n            *--destptr = num / den;\n            remainder = num % den;\n          }\n        /* Normalise and store r.  */\n        if (remainder > 0)\n          {\n            r_ptr[0] = remainder;\n            r_len = 1;\n          }\n        else\n          r_len = 0;\n        /* Normalise q.  */\n        q_len = a_len;\n        if (q_ptr[q_len - 1] == 0)\n          q_len--;\n      }\n    }\n  else\n    {\n      /* n>1: multiple precision division.\n         beta^(m-1) <= a < beta^m, beta^(n-1) <= b < beta^n  ==>\n         beta^(m-n-1) <= a/b < beta^(m-n+1).  */\n      /* Determine s.  */\n      size_t s;\n      {\n        mp_limb_t msd = b_ptr[b_len - 1]; /* = b[n-1], > 0 */\n        /* Determine s = GMP_LIMB_BITS - integer_length (msd).\n           Code copied from gnulib's integer_length.c.  */\n# if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)\n        s = __builtin_clz (msd);\n# else\n#  if defined DBL_EXPBIT0_WORD && defined DBL_EXPBIT0_BIT\n        if (GMP_LIMB_BITS <= DBL_MANT_BIT)\n          {\n            /* Use 'double' operations.\n               Assumes an IEEE 754 'double' implementation.  */\n#   define DBL_EXP_MASK ((DBL_MAX_EXP - DBL_MIN_EXP) | 7)\n#   define DBL_EXP_BIAS (DBL_EXP_MASK / 2 - 1)\n#   define NWORDS \\\n     ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n            union { double value; unsigned int word[NWORDS]; } m;\n\n            /* Use a single integer to floating-point conversion.  */\n            m.value = msd;\n\n            s = GMP_LIMB_BITS\n                - (((m.word[DBL_EXPBIT0_WORD] >> DBL_EXPBIT0_BIT) & DBL_EXP_MASK)\n                   - DBL_EXP_BIAS);\n          }\n        else\n#   undef NWORDS\n#  endif\n          {\n            s = 31;\n            if (msd >= 0x10000)\n              {\n                msd = msd >> 16;\n                s -= 16;\n              }\n            if (msd >= 0x100)\n              {\n                msd = msd >> 8;\n                s -= 8;\n              }\n            if (msd >= 0x10)\n              {\n                msd = msd >> 4;\n                s -= 4;\n              }\n            if (msd >= 0x4)\n              {\n                msd = msd >> 2;\n                s -= 2;\n              }\n            if (msd >= 0x2)\n              {\n                msd = msd >> 1;\n                s -= 1;\n              }\n          }\n# endif\n      }\n      /* 0 <= s < GMP_LIMB_BITS.\n         Copy b, shifting it left by s bits.  */\n      if (s > 0)\n        {\n          tmp_roomptr = (mp_limb_t *) malloc (b_len * sizeof (mp_limb_t));\n          if (tmp_roomptr == NULL)\n            {\n              free (roomptr);\n              return NULL;\n            }\n          {\n            const mp_limb_t *sourceptr = b_ptr;\n            mp_limb_t *destptr = tmp_roomptr;\n            mp_twolimb_t accu = 0;\n            size_t count;\n            for (count = b_len; count > 0; count--)\n              {\n                accu += (mp_twolimb_t) *sourceptr++ << s;\n                *destptr++ = (mp_limb_t) accu;\n                accu = accu >> GMP_LIMB_BITS;\n              }\n            /* accu must be zero, since that was how s was determined.  */\n            if (accu != 0)\n              abort ();\n          }\n          b_ptr = tmp_roomptr;\n        }\n      /* Copy a, shifting it left by s bits, yields r.\n         Memory layout:\n         At the beginning: r = roomptr[0..a_len],\n         at the end: r = roomptr[0..b_len-1], q = roomptr[b_len..a_len]  */\n      r_ptr = roomptr;\n      if (s == 0)\n        {\n          memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n          r_ptr[a_len] = 0;\n        }\n      else\n        {\n          const mp_limb_t *sourceptr = a_ptr;\n          mp_limb_t *destptr = r_ptr;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              accu += (mp_twolimb_t) *sourceptr++ << s;\n              *destptr++ = (mp_limb_t) accu;\n              accu = accu >> GMP_LIMB_BITS;\n            }\n          *destptr++ = (mp_limb_t) accu;\n        }\n      q_ptr = roomptr + b_len;\n      q_len = a_len - b_len + 1; /* q will have m-n+1 limbs */\n      {\n        size_t j = a_len - b_len; /* m-n */\n        mp_limb_t b_msd = b_ptr[b_len - 1]; /* b[n-1] */\n        mp_limb_t b_2msd = b_ptr[b_len - 2]; /* b[n-2] */\n        mp_twolimb_t b_msdd = /* b[n-1]*beta+b[n-2] */\n          ((mp_twolimb_t) b_msd << GMP_LIMB_BITS) | b_2msd;\n        /* Division loop, traversed m-n+1 times.\n           j counts down, b is unchanged, beta/2 <= b[n-1] < beta.  */\n        for (;;)\n          {\n            mp_limb_t q_star;\n            mp_limb_t c1;\n            if (r_ptr[j + b_len] < b_msd) /* r[j+n] < b[n-1] ? */\n              {\n                /* Divide r[j+n]*beta+r[j+n-1] by b[n-1], no overflow.  */\n                mp_twolimb_t num =\n                  ((mp_twolimb_t) r_ptr[j + b_len] << GMP_LIMB_BITS)\n                  | r_ptr[j + b_len - 1];\n                q_star = num / b_msd;\n                c1 = num % b_msd;\n              }\n            else\n              {\n                /* Overflow, hence r[j+n]*beta+r[j+n-1] >= beta*b[n-1].  */\n                q_star = (mp_limb_t)~(mp_limb_t)0; /* q* = beta-1 */\n                /* Test whether r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] >= beta\n                   <==> r[j+n]*beta+r[j+n-1] + b[n-1] >= beta*b[n-1]+beta\n                   <==> b[n-1] < floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta)\n                        {<= beta !}.\n                   If yes, jump directly to the subtraction loop.\n                   (Otherwise, r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] < beta\n                    <==> floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta) = b[n-1] ) */\n                if (r_ptr[j + b_len] > b_msd\n                    || (c1 = r_ptr[j + b_len - 1] + b_msd) < b_msd)\n                  /* r[j+n] >= b[n-1]+1 or\n                     r[j+n] = b[n-1] and the addition r[j+n-1]+b[n-1] gives a\n                     carry.  */\n                  goto subtract;\n              }\n            /* q_star = q*,\n               c1 = (r[j+n]*beta+r[j+n-1]) - q* * b[n-1] (>=0, <beta).  */\n            {\n              mp_twolimb_t c2 = /* c1*beta+r[j+n-2] */\n                ((mp_twolimb_t) c1 << GMP_LIMB_BITS) | r_ptr[j + b_len - 2];\n              mp_twolimb_t c3 = /* b[n-2] * q* */\n                (mp_twolimb_t) b_2msd * (mp_twolimb_t) q_star;\n              /* While c2 < c3, increase c2 and decrease c3.\n                 Consider c3-c2.  While it is > 0, decrease it by\n                 b[n-1]*beta+b[n-2].  Because of b[n-1]*beta+b[n-2] >= beta^2/2\n                 this can happen only twice.  */\n              if (c3 > c2)\n                {\n                  q_star = q_star - 1; /* q* := q* - 1 */\n                  if (c3 - c2 > b_msdd)\n                    q_star = q_star - 1; /* q* := q* - 1 */\n                }\n            }\n            if (q_star > 0)\n              subtract:\n              {\n                /* Subtract r := r - b * q* * beta^j.  */\n                mp_limb_t cr;\n                {\n                  const mp_limb_t *sourceptr = b_ptr;\n                  mp_limb_t *destptr = r_ptr + j;\n                  mp_twolimb_t carry = 0;\n                  size_t count;\n                  for (count = b_len; count > 0; count--)\n                    {\n                      /* Here 0 <= carry <= q*.  */\n                      carry =\n                        carry\n                        + (mp_twolimb_t) q_star * (mp_twolimb_t) *sourceptr++\n                        + (mp_limb_t) ~(*destptr);\n                      /* Here 0 <= carry <= beta*q* + beta-1.  */\n                      *destptr++ = ~(mp_limb_t) carry;\n                      carry = carry >> GMP_LIMB_BITS; /* <= q* */\n                    }\n                  cr = (mp_limb_t) carry;\n                }\n                /* Subtract cr from r_ptr[j + b_len], then forget about\n                   r_ptr[j + b_len].  */\n                if (cr > r_ptr[j + b_len])\n                  {\n                    /* Subtraction gave a carry.  */\n                    q_star = q_star - 1; /* q* := q* - 1 */\n                    /* Add b back.  */\n                    {\n                      const mp_limb_t *sourceptr = b_ptr;\n                      mp_limb_t *destptr = r_ptr + j;\n                      mp_limb_t carry = 0;\n                      size_t count;\n                      for (count = b_len; count > 0; count--)\n                        {\n                          mp_limb_t source1 = *sourceptr++;\n                          mp_limb_t source2 = *destptr;\n                          *destptr++ = source1 + source2 + carry;\n                          carry =\n                            (carry\n                             ? source1 >= (mp_limb_t) ~source2\n                             : source1 > (mp_limb_t) ~source2);\n                        }\n                    }\n                    /* Forget about the carry and about r[j+n].  */\n                  }\n              }\n            /* q* is determined.  Store it as q[j].  */\n            q_ptr[j] = q_star;\n            if (j == 0)\n              break;\n            j--;\n          }\n      }\n      r_len = b_len;\n      /* Normalise q.  */\n      if (q_ptr[q_len - 1] == 0)\n        q_len--;\n# if 0 /* Not needed here, since we need r only to compare it with b/2, and\n          b is shifted left by s bits.  */\n      /* Shift r right by s bits.  */\n      if (s > 0)\n        {\n          mp_limb_t ptr = r_ptr + r_len;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = r_len; count > 0; count--)\n            {\n              accu = (mp_twolimb_t) (mp_limb_t) accu << GMP_LIMB_BITS;\n              accu += (mp_twolimb_t) *--ptr << (GMP_LIMB_BITS - s);\n              *ptr = (mp_limb_t) (accu >> GMP_LIMB_BITS);\n            }\n        }\n# endif\n      /* Normalise r.  */\n      while (r_len > 0 && r_ptr[r_len - 1] == 0)\n        r_len--;\n    }\n  /* Compare r << 1 with b.  */\n  if (r_len > b_len)\n    goto increment_q;\n  {\n    size_t i;\n    for (i = b_len;;)\n      {\n        mp_limb_t r_i =\n          (i <= r_len && i > 0 ? r_ptr[i - 1] >> (GMP_LIMB_BITS - 1) : 0)\n          | (i < r_len ? r_ptr[i] << 1 : 0);\n        mp_limb_t b_i = (i < b_len ? b_ptr[i] : 0);\n        if (r_i > b_i)\n          goto increment_q;\n        if (r_i < b_i)\n          goto keep_q;\n        if (i == 0)\n          break;\n        i--;\n      }\n  }\n  if (q_len > 0 && ((q_ptr[0] & 1) != 0))\n    /* q is odd.  */\n    increment_q:\n    {\n      size_t i;\n      for (i = 0; i < q_len; i++)\n        if (++(q_ptr[i]) != 0)\n          goto keep_q;\n      q_ptr[q_len++] = 1;\n    }\n  keep_q:\n  if (tmp_roomptr != NULL)\n    free (tmp_roomptr);\n  q->limbs = q_ptr;\n  q->nlimbs = q_len;\n  return roomptr;\n}",
      "lines": 424,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndivide (mpn_t a, mpn_t b, mpn_t *q)",
        "*"
      ]
    },
    "convert_to_decimal": {
      "start_point": [
        844,
        0
      ],
      "end_point": [
        890,
        1
      ],
      "content": "static char *\nconvert_to_decimal (mpn_t a, size_t extra_zeroes)\n{\n  mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  /* 0.03345 is slightly larger than log(2)/(9*log(10)).  */\n  size_t c_len = 9 * ((size_t)(a_len * (GMP_LIMB_BITS * 0.03345f)) + 1);\n  char *c_ptr = (char *) malloc (xsum (c_len, extra_zeroes));\n  if (c_ptr != NULL)\n    {\n      char *d_ptr = c_ptr;\n      for (; extra_zeroes > 0; extra_zeroes--)\n        *d_ptr++ = '0';\n      while (a_len > 0)\n        {\n          /* Divide a by 10^9, in-place.  */\n          mp_limb_t remainder = 0;\n          mp_limb_t *ptr = a_ptr + a_len;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              mp_twolimb_t num =\n                ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--ptr;\n              *ptr = num / 1000000000;\n              remainder = num % 1000000000;\n            }\n          /* Store the remainder as 9 decimal digits.  */\n          for (count = 9; count > 0; count--)\n            {\n              *d_ptr++ = '0' + (remainder % 10);\n              remainder = remainder / 10;\n            }\n          /* Normalize a.  */\n          if (a_ptr[a_len - 1] == 0)\n            a_len--;\n        }\n      /* Remove leading zeroes.  */\n      while (d_ptr > c_ptr && d_ptr[-1] == '0')\n        d_ptr--;\n      /* But keep at least one zero.  */\n      if (d_ptr == c_ptr)\n        *d_ptr++ = '0';\n      /* Terminate the string.  */\n      *d_ptr = '\\0';\n    }\n  return c_ptr;\n}",
      "lines": 47,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nconvert_to_decimal (mpn_t a, size_t extra_zeroes)",
        "*"
      ]
    },
    "decode_long_double": {
      "start_point": [
        898,
        0
      ],
      "end_point": [
        976,
        1
      ],
      "content": "static void *\ndecode_long_double (long double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  long double y;\n  size_t i;\n\n  /* Allocate memory for result.  */\n  m.nlimbs = (LDBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n  /* Split into exponential part and mantissa.  */\n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n  /* x = 2^exp * y = 2^(exp - LDBL_MANT_BIT) * (y * 2^LDBL_MANT_BIT), and the\n     latter is an integer.  */\n  /* Convert the mantissa (y * 2^LDBL_MANT_BIT) to a sequence of limbs.\n     I'm not sure whether it's safe to cast a 'long double' value between\n     2^31 and 2^32 to 'unsigned int', therefore play safe and cast only\n     'long double' values between 0 and 2^16 (to 'unsigned int' or 'int',\n     doesn't matter).  */\n#  if (LDBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (LDBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = LDBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#  if 0 /* On FreeBSD 6.1/x86, 'long double' numbers sometimes have excess\n           precision.  */\n  if (!(y == 0.0L))\n    abort ();\n#  endif\n  /* Normalise.  */\n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - LDBL_MANT_BIT;\n  return m.limbs;\n}",
      "lines": 79,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndecode_long_double (long double x, int *ep, mpn_t *mp)",
        "*"
      ]
    },
    "decode_double": {
      "start_point": [
        986,
        0
      ],
      "end_point": [
        1061,
        1
      ],
      "content": "static void *\ndecode_double (double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  double y;\n  size_t i;\n\n  /* Allocate memory for result.  */\n  m.nlimbs = (DBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n  /* Split into exponential part and mantissa.  */\n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n  /* x = 2^exp * y = 2^(exp - DBL_MANT_BIT) * (y * 2^DBL_MANT_BIT), and the\n     latter is an integer.  */\n  /* Convert the mantissa (y * 2^DBL_MANT_BIT) to a sequence of limbs.\n     I'm not sure whether it's safe to cast a 'double' value between\n     2^31 and 2^32 to 'unsigned int', therefore play safe and cast only\n     'double' values between 0 and 2^16 (to 'unsigned int' or 'int',\n     doesn't matter).  */\n#  if (DBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (DBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = DBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n  if (!(y == 0.0))\n    abort ();\n  /* Normalise.  */\n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - DBL_MANT_BIT;\n  return m.limbs;\n}",
      "lines": 76,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndecode_double (double x, int *ep, mpn_t *mp)",
        "*"
      ]
    },
    "scale10_round_decimal_decoded": {
      "start_point": [
        1070,
        0
      ],
      "end_point": [
        1283,
        1
      ],
      "content": "static char *\nscale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)\n{\n  int s;\n  size_t extra_zeroes;\n  unsigned int abs_n;\n  unsigned int abs_s;\n  mp_limb_t *pow5_ptr;\n  size_t pow5_len;\n  unsigned int s_limbs;\n  unsigned int s_bits;\n  mpn_t pow5;\n  mpn_t z;\n  void *z_memory;\n  char *digits;\n\n  if (memory == NULL)\n    return NULL;\n  /* x = 2^e * m, hence\n     y = round (2^e * 10^n * m) = round (2^(e+n) * 5^n * m)\n       = round (2^s * 5^n * m).  */\n  s = e + n;\n  extra_zeroes = 0;\n  /* Factor out a common power of 10 if possible.  */\n  if (s > 0 && n > 0)\n    {\n      extra_zeroes = (s < n ? s : n);\n      s -= extra_zeroes;\n      n -= extra_zeroes;\n    }\n  /* Here y = round (2^s * 5^n * m) * 10^extra_zeroes.\n     Before converting to decimal, we need to compute\n     z = round (2^s * 5^n * m).  */\n  /* Compute 5^|n|, possibly shifted by |s| bits if n and s have the same\n     sign.  2.322 is slightly larger than log(5)/log(2).  */\n  abs_n = (n >= 0 ? n : -n);\n  abs_s = (s >= 0 ? s : -s);\n  pow5_ptr = (mp_limb_t *) malloc (((int)(abs_n * (2.322f / GMP_LIMB_BITS)) + 1\n                                    + abs_s / GMP_LIMB_BITS + 1)\n                                   * sizeof (mp_limb_t));\n  if (pow5_ptr == NULL)\n    {\n      free (memory);\n      return NULL;\n    }\n  /* Initialize with 1.  */\n  pow5_ptr[0] = 1;\n  pow5_len = 1;\n  /* Multiply with 5^|n|.  */\n  if (abs_n > 0)\n    {\n      static mp_limb_t const small_pow5[13 + 1] =\n        {\n          1, 5, 25, 125, 625, 3125, 15625, 78125, 390625, 1953125, 9765625,\n          48828125, 244140625, 1220703125\n        };\n      unsigned int n13;\n      for (n13 = 0; n13 <= abs_n; n13 += 13)\n        {\n          mp_limb_t digit1 = small_pow5[n13 + 13 <= abs_n ? 13 : abs_n - n13];\n          size_t j;\n          mp_twolimb_t carry = 0;\n          for (j = 0; j < pow5_len; j++)\n            {\n              mp_limb_t digit2 = pow5_ptr[j];\n              carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n              pow5_ptr[j] = (mp_limb_t) carry;\n              carry = carry >> GMP_LIMB_BITS;\n            }\n          if (carry > 0)\n            pow5_ptr[pow5_len++] = (mp_limb_t) carry;\n        }\n    }\n  s_limbs = abs_s / GMP_LIMB_BITS;\n  s_bits = abs_s % GMP_LIMB_BITS;\n  if (n >= 0 ? s >= 0 : s <= 0)\n    {\n      /* Multiply with 2^|s|.  */\n      if (s_bits > 0)\n        {\n          mp_limb_t *ptr = pow5_ptr;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = pow5_len; count > 0; count--)\n            {\n              accu += (mp_twolimb_t) *ptr << s_bits;\n              *ptr++ = (mp_limb_t) accu;\n              accu = accu >> GMP_LIMB_BITS;\n            }\n          if (accu > 0)\n            {\n              *ptr = (mp_limb_t) accu;\n              pow5_len++;\n            }\n        }\n      if (s_limbs > 0)\n        {\n          size_t count;\n          for (count = pow5_len; count > 0;)\n            {\n              count--;\n              pow5_ptr[s_limbs + count] = pow5_ptr[count];\n            }\n          for (count = s_limbs; count > 0;)\n            {\n              count--;\n              pow5_ptr[count] = 0;\n            }\n          pow5_len += s_limbs;\n        }\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n        {\n          /* Multiply m with pow5.  No division needed.  */\n          z_memory = multiply (m, pow5, &z);\n        }\n      else\n        {\n          /* Divide m by pow5 and round.  */\n          z_memory = divide (m, pow5, &z);\n        }\n    }\n  else\n    {\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n        {\n          /* n >= 0, s < 0.\n             Multiply m with pow5, then divide by 2^|s|.  */\n          mpn_t numerator;\n          mpn_t denominator;\n          void *tmp_memory;\n          tmp_memory = multiply (m, pow5, &numerator);\n          if (tmp_memory == NULL)\n            {\n              free (pow5_ptr);\n              free (memory);\n              return NULL;\n            }\n          /* Construct 2^|s|.  */\n          {\n            mp_limb_t *ptr = pow5_ptr + pow5_len;\n            size_t i;\n            for (i = 0; i < s_limbs; i++)\n              ptr[i] = 0;\n            ptr[s_limbs] = (mp_limb_t) 1 << s_bits;\n            denominator.limbs = ptr;\n            denominator.nlimbs = s_limbs + 1;\n          }\n          z_memory = divide (numerator, denominator, &z);\n          free (tmp_memory);\n        }\n      else\n        {\n          /* n < 0, s > 0.\n             Multiply m with 2^s, then divide by pow5.  */\n          mpn_t numerator;\n          mp_limb_t *num_ptr;\n          num_ptr = (mp_limb_t *) malloc ((m.nlimbs + s_limbs + 1)\n                                          * sizeof (mp_limb_t));\n          if (num_ptr == NULL)\n            {\n              free (pow5_ptr);\n              free (memory);\n              return NULL;\n            }\n          {\n            mp_limb_t *destptr = num_ptr;\n            {\n              size_t i;\n              for (i = 0; i < s_limbs; i++)\n                *destptr++ = 0;\n            }\n            if (s_bits > 0)\n              {\n                const mp_limb_t *sourceptr = m.limbs;\n                mp_twolimb_t accu = 0;\n                size_t count;\n                for (count = m.nlimbs; count > 0; count--)\n                  {\n                    accu += (mp_twolimb_t) *sourceptr++ << s_bits;\n                    *destptr++ = (mp_limb_t) accu;\n                    accu = accu >> GMP_LIMB_BITS;\n                  }\n                if (accu > 0)\n                  *destptr++ = (mp_limb_t) accu;\n              }\n            else\n              {\n                const mp_limb_t *sourceptr = m.limbs;\n                size_t count;\n                for (count = m.nlimbs; count > 0; count--)\n                  *destptr++ = *sourceptr++;\n              }\n            numerator.limbs = num_ptr;\n            numerator.nlimbs = destptr - num_ptr;\n          }\n          z_memory = divide (numerator, pow5, &z);\n          free (num_ptr);\n        }\n    }\n  free (pow5_ptr);\n  free (memory);\n\n  /* Here y = round (x * 10^n) = z * 10^extra_zeroes.  */\n\n  if (z_memory == NULL)\n    return NULL;\n  digits = convert_to_decimal (z, extra_zeroes);\n  free (z_memory);\n  return digits;\n}",
      "lines": 214,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)",
        "*"
      ]
    },
    "scale10_round_decimal_long_double": {
      "start_point": [
        1292,
        0
      ],
      "end_point": [
        1299,
        1
      ],
      "content": "static char *\nscale10_round_decimal_long_double (long double x, int n)\n{\n  int e IF_LINT(= 0);\n  mpn_t m;\n  void *memory = decode_long_double (x, &e, &m);\n  return scale10_round_decimal_decoded (e, m, memory, n);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_long_double (long double x, int n)",
        "*"
      ]
    },
    "scale10_round_decimal_double": {
      "start_point": [
        1310,
        0
      ],
      "end_point": [
        1317,
        1
      ],
      "content": "static char *\nscale10_round_decimal_double (double x, int n)\n{\n  int e IF_LINT(= 0);\n  mpn_t m;\n  void *memory = decode_double (x, &e, &m);\n  return scale10_round_decimal_decoded (e, m, memory, n);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_double (double x, int n)",
        "*"
      ]
    },
    "floorlog10l": {
      "start_point": [
        1326,
        0
      ],
      "end_point": [
        1408,
        1
      ],
      "content": "static int\nfloorlog10l (long double x)\n{\n  int exp;\n  long double y;\n  double z;\n  double l;\n\n  /* Split into exponential part and mantissa.  */\n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n  if (y == 0.0L)\n    return INT_MIN;\n  if (y < 0.5L)\n    {\n      while (y < (1.0L / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n        {\n          y *= 1.0L * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n          exp -= GMP_LIMB_BITS;\n        }\n      if (y < (1.0L / (1 << 16)))\n        {\n          y *= 1.0L * (1 << 16);\n          exp -= 16;\n        }\n      if (y < (1.0L / (1 << 8)))\n        {\n          y *= 1.0L * (1 << 8);\n          exp -= 8;\n        }\n      if (y < (1.0L / (1 << 4)))\n        {\n          y *= 1.0L * (1 << 4);\n          exp -= 4;\n        }\n      if (y < (1.0L / (1 << 2)))\n        {\n          y *= 1.0L * (1 << 2);\n          exp -= 2;\n        }\n      if (y < (1.0L / (1 << 1)))\n        {\n          y *= 1.0L * (1 << 1);\n          exp -= 1;\n        }\n    }\n  if (!(y >= 0.5L && y < 1.0L))\n    abort ();\n  /* Compute an approximation for l = log2(x) = exp + log2(y).  */\n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n  /* Now 0.95 <= z <= 1.01.  */\n  z = 1 - z;\n  /* log2(1-z) = 1/log(2) * (- z - z^2/2 - z^3/3 - z^4/4 - ...)\n     Four terms are enough to get an approximation with error < 10^-7.  */\n  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n  /* Finally multiply with log(2)/log(10), yields an approximation for\n     log10(x).  */\n  l *= 0.30102999566398119523;\n  /* Round down to the next integer.  */\n  return (int) l + (l < 0 ? -1 : 0);\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "floorlog10": {
      "start_point": [
        1417,
        0
      ],
      "end_point": [
        1499,
        1
      ],
      "content": "static int\nfloorlog10 (double x)\n{\n  int exp;\n  double y;\n  double z;\n  double l;\n\n  /* Split into exponential part and mantissa.  */\n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n  if (y == 0.0)\n    return INT_MIN;\n  if (y < 0.5)\n    {\n      while (y < (1.0 / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n        {\n          y *= 1.0 * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n          exp -= GMP_LIMB_BITS;\n        }\n      if (y < (1.0 / (1 << 16)))\n        {\n          y *= 1.0 * (1 << 16);\n          exp -= 16;\n        }\n      if (y < (1.0 / (1 << 8)))\n        {\n          y *= 1.0 * (1 << 8);\n          exp -= 8;\n        }\n      if (y < (1.0 / (1 << 4)))\n        {\n          y *= 1.0 * (1 << 4);\n          exp -= 4;\n        }\n      if (y < (1.0 / (1 << 2)))\n        {\n          y *= 1.0 * (1 << 2);\n          exp -= 2;\n        }\n      if (y < (1.0 / (1 << 1)))\n        {\n          y *= 1.0 * (1 << 1);\n          exp -= 1;\n        }\n    }\n  if (!(y >= 0.5 && y < 1.0))\n    abort ();\n  /* Compute an approximation for l = log2(x) = exp + log2(y).  */\n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n  /* Now 0.95 <= z <= 1.01.  */\n  z = 1 - z;\n  /* log2(1-z) = 1/log(2) * (- z - z^2/2 - z^3/3 - z^4/4 - ...)\n     Four terms are enough to get an approximation with error < 10^-7.  */\n  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n  /* Finally multiply with log(2)/log(10), yields an approximation for\n     log10(x).  */\n  l *= 0.30102999566398119523;\n  /* Round down to the next integer.  */\n  return (int) l + (l < 0 ? -1 : 0);\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_borderline": {
      "start_point": [
        1505,
        0
      ],
      "end_point": [
        1515,
        1
      ],
      "content": "static int\nis_borderline (const char *digits, size_t precision)\n{\n  for (; precision > 0; precision--, digits++)\n    if (*digits != '0')\n      return 0;\n  if (*digits != '1')\n    return 0;\n  digits++;\n  return *digits == '\\0';\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MAX_ROOM_NEEDED": {
      "start_point": [
        1532,
        0
      ],
      "end_point": [
        1767,
        1
      ],
      "content": "static size_t\nMAX_ROOM_NEEDED (const arguments *ap, size_t arg_index, FCHAR_T conversion,\n                 arg_type type, int flags, size_t width, int has_precision,\n                 size_t precision, int pad_ourselves)\n{\n  size_t tmp_length;\n\n  switch (conversion)\n    {\n    case 'd': case 'i': case 'u':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Multiply by 2, as an estimate for FLAG_GROUP.  */\n      tmp_length = xsum (tmp_length, tmp_length);\n      /* Add 1, to account for a leading sign.  */\n      tmp_length = xsum (tmp_length, 1);\n      break;\n\n    case 'o':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Add 1, to account for a leading sign.  */\n      tmp_length = xsum (tmp_length, 1);\n      break;\n\n    case 'x': case 'X':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Add 2, to account for a leading sign or alternate form.  */\n      tmp_length = xsum (tmp_length, 2);\n      break;\n\n    case 'f': case 'F':\n      if (type == TYPE_LONGDOUBLE)\n        tmp_length =\n          (unsigned int) (LDBL_MAX_EXP\n                          * 0.30103 /* binary -> decimal */\n                          * 2 /* estimate for FLAG_GROUP */\n                         )\n          + 1 /* turn floor into ceil */\n          + 10; /* sign, decimal point etc. */\n      else\n        tmp_length =\n          (unsigned int) (DBL_MAX_EXP\n                          * 0.30103 /* binary -> decimal */\n                          * 2 /* estimate for FLAG_GROUP */\n                         )\n          + 1 /* turn floor into ceil */\n          + 10; /* sign, decimal point etc. */\n      tmp_length = xsum (tmp_length, precision);\n      break;\n\n    case 'e': case 'E': case 'g': case 'G':\n      tmp_length =\n        12; /* sign, decimal point, exponent etc. */\n      tmp_length = xsum (tmp_length, precision);\n      break;\n\n    case 'a': case 'A':\n      if (type == TYPE_LONGDOUBLE)\n        tmp_length =\n          (unsigned int) (LDBL_DIG\n                          * 0.831 /* decimal -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (DBL_DIG\n                          * 0.831 /* decimal -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Account for sign, decimal point etc. */\n      tmp_length = xsum (tmp_length, 12);\n      break;\n\n    case 'c':\n# if HAVE_WINT_T && !WIDE_CHAR_VERSION\n      if (type == TYPE_WIDE_CHAR)\n        tmp_length = MB_CUR_MAX;\n      else\n# endif\n        tmp_length = 1;\n      break;\n\n    case 's':\n# if HAVE_WCHAR_T\n      if (type == TYPE_WIDE_STRING)\n        {\n#  if WIDE_CHAR_VERSION\n          /* ISO C says about %ls in fwprintf:\n               \"If the precision is not specified or is greater than the size\n                of the array, the array shall contain a null wide character.\"\n             So if there is a precision, we must not use wcslen.  */\n          const wchar_t *arg = ap->arg[arg_index].a.a_wide_string;\n\n          if (has_precision)\n            tmp_length = local_wcsnlen (arg, precision);\n          else\n            tmp_length = local_wcslen (arg);\n#  else\n          /* ISO C says about %ls in fprintf:\n               \"If a precision is specified, no more than that many bytes are\n                written (including shift sequences, if any), and the array\n                shall contain a null wide character if, to equal the multibyte\n                character sequence length given by the precision, the function\n                would need to access a wide character one past the end of the\n                array.\"\n             So if there is a precision, we must not use wcslen.  */\n          /* This case has already been handled separately in VASNPRINTF.  */\n          abort ();\n#  endif\n        }\n      else\n# endif\n        {\n# if WIDE_CHAR_VERSION\n          /* ISO C says about %s in fwprintf:\n               \"If the precision is not specified or is greater than the size\n                of the converted array, the converted array shall contain a\n                null wide character.\"\n             So if there is a precision, we must not use strlen.  */\n          /* This case has already been handled separately in VASNPRINTF.  */\n          abort ();\n# else\n          /* ISO C says about %s in fprintf:\n               \"If the precision is not specified or greater than the size of\n                the array, the array shall contain a null character.\"\n             So if there is a precision, we must not use strlen.  */\n          const char *arg = ap->arg[arg_index].a.a_string;\n\n          if (has_precision)\n            tmp_length = local_strnlen (arg, precision);\n          else\n            tmp_length = strlen (arg);\n# endif\n        }\n      break;\n\n    case 'p':\n      tmp_length =\n        (unsigned int) (sizeof (void *) * CHAR_BIT\n                        * 0.25 /* binary -> hexadecimal */\n                       )\n          + 1 /* turn floor into ceil */\n          + 2; /* account for leading 0x */\n      break;\n\n    default:\n      abort ();\n    }\n\n  if (!pad_ourselves)\n    {\n# if ENABLE_UNISTDIO\n      /* Padding considers the number of characters, therefore the number of\n         elements after padding may be\n           > max (tmp_length, width)\n         but is certainly\n           <= tmp_length + width.  */\n      tmp_length = xsum (tmp_length, width);\n# else\n      /* Padding considers the number of elements, says POSIX.  */\n      if (tmp_length < width)\n        tmp_length = width;\n# endif\n    }\n\n  tmp_length = xsum (tmp_length, 1); /* account for trailing NUL */\n\n  return tmp_length;\n}",
      "lines": 236,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "xsum": {
      "start_point": [
        4614,
        16
      ],
      "end_point": [
        5530,
        15
      ],
      "content": "int prefixes[2] IF_LINT (= { 0 });\n                int orig_errno;\n#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif\n\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n#endif\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif\n\n                /* Decide whether to handle the precision ourselves.  */\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif\n\n                /* Decide whether to perform the padding ourselves.  */\n#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif\n\n#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif\n\n                /* Construct the format string for calling snprintf or\n                   sprintf.  */\n                fbp = buf;\n                *fbp++ = '%';\n#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif\n                if (flags & FLAG_LEFT)\n                  *fbp++ = '-';\n                if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';\n                if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';\n                if (flags & FLAG_ALT)\n                  *fbp++ = '#';\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif\n                if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n                if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n\n                switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }\n#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif\n                  *fbp = dp->conversion;\n#if USE_SNPRINTF\n# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif\n\n                /* Construct the arguments for calling snprintf or sprintf.  */\n                prefix_count = 0;\n                if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }\n                if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }\n\n#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif\n\n                orig_errno = errno;\n\n                for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }\n                errno = orig_errno;\n#undef pad_ourselves\n#undef prec_ourselves\n              }",
      "lines": 917,
      "depth": 24,
      "decorators": [
        "int",
        "prefixes[2]",
        "prefixes",
        "[",
        "2",
        "]",
        "IF_LINT (=",
        "IF_LINT",
        "(",
        "=",
        "{ 0 });\n                int orig_errno;\n#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif\n\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n#endif\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif\n\n                /* Decide whether to handle the precision ourselves.  */\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif\n\n                /* Decide whether to perform the padding ourselves.  */\n#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif\n\n#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif\n\n                /* Construct the format string for calling snprintf or\n                   sprintf.  */\n                fbp = buf;\n                *fbp++ = '%';\n#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif\n                if (flags & FLAG_LEFT)\n                  *fbp++ = '-';\n                if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';\n                if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';\n                if (flags & FLAG_ALT)\n                  *fbp++ = '#';\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif\n                if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n                if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n\n                switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }\n#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif\n                  *fbp = dp->conversion;\n#if USE_SNPRINTF\n# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif\n\n                /* Construct the arguments for calling snprintf or sprintf.  */\n                prefix_count = 0;\n                if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }\n                if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }\n\n#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif\n\n                orig_errno = errno;\n\n                for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }\n                errno = orig_errno;\n#undef pad_ourselves\n#undef prec_ourselves\n              }",
        "{",
        "0 });",
        "0",
        "})",
        "}",
        ")",
        ";",
        "int orig_errno;",
        "int",
        "orig_errno",
        ";",
        "#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "size_t tmp_length;",
        "size_t",
        "tmp_length",
        ";",
        "TCHAR_T tmpbuf[700];",
        "TCHAR_T",
        "tmpbuf[700]",
        "tmpbuf",
        "[",
        "700",
        "]",
        ";",
        "TCHAR_T *tmp;",
        "TCHAR_T",
        "*tmp",
        "*",
        "tmp",
        ";",
        "#endif",
        "#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_width = 0;",
        "has_width = 0",
        "has_width",
        "=",
        "0",
        ";",
        "#endif",
        "#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "||",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "width = 0;",
        "width = 0",
        "width",
        "=",
        "0",
        ";",
        "if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }",
        "if",
        "(dp->width_start != dp->width_end)",
        "(",
        "dp->width_start != dp->width_end",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        "{\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }",
        "{",
        "if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }",
        "if",
        "(dp->width_arg_index != ARG_NONE)",
        "(",
        "dp->width_arg_index != ARG_NONE",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }",
        "{",
        "int arg;",
        "int",
        "arg",
        ";",
        "if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();",
        "if",
        "(!(a.arg[dp->width_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->width_arg_index].type == TYPE_INT",
        "a.arg[dp->width_arg_index].type",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "arg = a.arg[dp->width_arg_index].a.a_int;",
        "arg = a.arg[dp->width_arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->width_arg_index].a.a_int",
        "a.arg[dp->width_arg_index].a",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "width = arg;",
        "width = arg",
        "width",
        "=",
        "arg",
        ";",
        "if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }",
        "if",
        "(arg < 0)",
        "(",
        "arg < 0",
        "arg",
        "<",
        "0",
        ")",
        "{\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }",
        "{",
        "/* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */",
        "flags |= FLAG_LEFT;",
        "flags |= FLAG_LEFT",
        "flags",
        "|=",
        "FLAG_LEFT",
        ";",
        "width = -width;",
        "width = -width",
        "width",
        "=",
        "-width",
        "-",
        "width",
        ";",
        "}",
        "}",
        "else",
        "{\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }",
        "{",
        "const FCHAR_T *digitp = dp->width_start;",
        "const",
        "const",
        "FCHAR_T",
        "*digitp = dp->width_start",
        "*digitp",
        "*",
        "digitp",
        "=",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);",
        "do",
        "width = xsum (xtimes (width, 10), *digitp++ - '0');",
        "width = xsum (xtimes (width, 10), *digitp++ - '0')",
        "width",
        "=",
        "xsum (xtimes (width, 10), *digitp++ - '0')",
        "xsum",
        "(xtimes (width, 10), *digitp++ - '0')",
        "(",
        "xtimes (width, 10)",
        "xtimes",
        "(width, 10)",
        "(",
        "width",
        ",",
        "10",
        ")",
        ",",
        "*digitp++ - '0'",
        "*digitp++",
        "*",
        "digitp++",
        "digitp",
        "++",
        "-",
        "'0'",
        "'",
        "'",
        ")",
        ";",
        "while",
        "(digitp != dp->width_end)",
        "(",
        "digitp != dp->width_end",
        "digitp",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        ";",
        "}",
        "#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_width = 1;",
        "has_width = 1",
        "has_width",
        "=",
        "1",
        ";",
        "#endif",
        "}",
        "#endif",
        "#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "||",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_precision = 0;",
        "has_precision = 0",
        "has_precision",
        "=",
        "0",
        ";",
        "precision = 6;",
        "precision = 6",
        "precision",
        "=",
        "6",
        ";",
        "if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }",
        "if",
        "(dp->precision_start != dp->precision_end)",
        "(",
        "dp->precision_start != dp->precision_end",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "{\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }",
        "{",
        "if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }",
        "if",
        "(dp->precision_arg_index != ARG_NONE)",
        "(",
        "dp->precision_arg_index != ARG_NONE",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }",
        "{",
        "int arg;",
        "int",
        "arg",
        ";",
        "if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();",
        "if",
        "(!(a.arg[dp->precision_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->precision_arg_index].type == TYPE_INT",
        "a.arg[dp->precision_arg_index].type",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "arg = a.arg[dp->precision_arg_index].a.a_int;",
        "arg = a.arg[dp->precision_arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->precision_arg_index].a.a_int",
        "a.arg[dp->precision_arg_index].a",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "/* \"A negative precision is taken as if the precision\n                            were omitted.\"  */",
        "if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }",
        "if",
        "(arg >= 0)",
        "(",
        "arg >= 0",
        "arg",
        ">=",
        "0",
        ")",
        "{\n                            precision = arg;\n                            has_precision = 1;\n                          }",
        "{",
        "precision = arg;",
        "precision = arg",
        "precision",
        "=",
        "arg",
        ";",
        "has_precision = 1;",
        "has_precision = 1",
        "has_precision",
        "=",
        "1",
        ";",
        "}",
        "}",
        "else",
        "{\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }",
        "{",
        "const FCHAR_T *digitp = dp->precision_start + 1;",
        "const",
        "const",
        "FCHAR_T",
        "*digitp = dp->precision_start + 1",
        "*digitp",
        "*",
        "digitp",
        "=",
        "dp->precision_start + 1",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "+",
        "1",
        ";",
        "precision = 0;",
        "precision = 0",
        "precision",
        "=",
        "0",
        ";",
        "while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');",
        "while",
        "(digitp != dp->precision_end)",
        "(",
        "digitp != dp->precision_end",
        "digitp",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "precision = xsum (xtimes (precision, 10), *digitp++ - '0');",
        "precision = xsum (xtimes (precision, 10), *digitp++ - '0')",
        "precision",
        "=",
        "xsum (xtimes (precision, 10), *digitp++ - '0')",
        "xsum",
        "(xtimes (precision, 10), *digitp++ - '0')",
        "(",
        "xtimes (precision, 10)",
        "xtimes",
        "(precision, 10)",
        "(",
        "precision",
        ",",
        "10",
        ")",
        ",",
        "*digitp++ - '0'",
        "*digitp++",
        "*",
        "digitp++",
        "digitp",
        "++",
        "-",
        "'0'",
        "'",
        "'",
        ")",
        ";",
        "has_precision = 1;",
        "has_precision = 1",
        "has_precision",
        "=",
        "1",
        ";",
        "}",
        "}",
        "#endif",
        "/* Decide whether to handle the precision ourselves.  */",
        "#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif",
        "#if",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }",
        "switch",
        "(dp->conversion)",
        "(",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ")",
        "{\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }",
        "{",
        "case 'd':",
        "case",
        "'d'",
        "'",
        "'",
        ":",
        "case 'i':",
        "case",
        "'i'",
        "'",
        "'",
        ":",
        "case 'u':",
        "case",
        "'u'",
        "'",
        "'",
        ":",
        "case 'o':",
        "case",
        "'o'",
        "'",
        "'",
        ":",
        "case 'x':",
        "case",
        "'x'",
        "'",
        "'",
        ":",
        "case 'X':",
        "case",
        "'X'",
        "'",
        "'",
        ":",
        "case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;",
        "case",
        "'p'",
        "'",
        "'",
        ":",
        "prec_ourselves = has_precision && (precision > 0);",
        "prec_ourselves = has_precision && (precision > 0)",
        "prec_ourselves",
        "=",
        "has_precision && (precision > 0)",
        "has_precision",
        "&&",
        "(precision > 0)",
        "(",
        "precision > 0",
        "precision",
        ">",
        "0",
        ")",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    prec_ourselves = 0;\n                    break;",
        "default",
        ":",
        "prec_ourselves = 0;",
        "prec_ourselves = 0",
        "prec_ourselves",
        "=",
        "0",
        ";",
        "break;",
        "break",
        ";",
        "}",
        "#endif",
        "/* Decide whether to perform the padding ourselves.  */",
        "#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif",
        "#if",
        "!NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)",
        "!NEED_PRINTF_FLAG_LEFTADJUST",
        "!",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "&&",
        "(!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)",
        "(",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        ")",
        "\n",
        "switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }",
        "switch",
        "(dp->conversion)",
        "(",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ")",
        "{\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }",
        "{",
        "# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif",
        "# if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "\n",
        "/* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */",
        "case 'c':",
        "case",
        "'c'",
        "'",
        "'",
        ":",
        "case 's':",
        "case",
        "'s'",
        "'",
        "'",
        ":",
        "# endif",
        "# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif",
        "# if",
        "NEED_PRINTF_FLAG_ZERO",
        "\n",
        "case 'f':",
        "case",
        "'f'",
        "'",
        "'",
        ":",
        "case 'F':",
        "case",
        "'F'",
        "'",
        "'",
        ":",
        "case 'e':",
        "case",
        "'e'",
        "'",
        "'",
        ":",
        "case 'E':",
        "case",
        "'E'",
        "'",
        "'",
        ":",
        "case 'g':",
        "case",
        "'g'",
        "'",
        "'",
        ":",
        "case 'G':",
        "case",
        "'G'",
        "'",
        "'",
        ":",
        "case 'a':",
        "case",
        "'a'",
        "'",
        "'",
        ":",
        "case 'A':",
        "case",
        "'A'",
        "'",
        "'",
        ":",
        "# endif",
        "pad_ourselves = 1;",
        "pad_ourselves = 1",
        "pad_ourselves",
        "=",
        "1",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    pad_ourselves = prec_ourselves;\n                    break;",
        "default",
        ":",
        "pad_ourselves = prec_ourselves;",
        "pad_ourselves = prec_ourselves",
        "pad_ourselves",
        "=",
        "prec_ourselves",
        ";",
        "break;",
        "break",
        ";",
        "}",
        "#endif",
        "#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "/* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */",
        "tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);",
        "tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "tmp_length",
        "=",
        "MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "MAX_ROOM_NEEDED",
        "(&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "(",
        "&a",
        "&",
        "a",
        ",",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        ",",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ",",
        "type",
        ",",
        "flags",
        ",",
        "width",
        ",",
        "has_precision",
        ",",
        "precision",
        ",",
        "pad_ourselves",
        ")",
        ";",
        "if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }",
        "if",
        "(tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))",
        "(",
        "tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T)",
        "tmp_length",
        "<=",
        "sizeof (tmpbuf) / sizeof (TCHAR_T)",
        "sizeof (tmpbuf)",
        "sizeof",
        "(",
        "tmpbuf",
        "tmpbuf",
        ")",
        "/",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "tmp = tmpbuf;",
        "tmp = tmpbuf",
        "tmp",
        "=",
        "tmpbuf",
        ";",
        "else",
        "{\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }",
        "{",
        "size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));",
        "size_t",
        "tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T))",
        "tmp_memsize",
        "=",
        "xtimes (tmp_length, sizeof (TCHAR_T))",
        "xtimes",
        "(tmp_length, sizeof (TCHAR_T))",
        "(",
        "tmp_length",
        ",",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;",
        "if",
        "(size_overflow_p (tmp_memsize))",
        "(",
        "size_overflow_p (tmp_memsize)",
        "size_overflow_p",
        "(tmp_memsize)",
        "(",
        "tmp_memsize",
        ")",
        ")",
        "/* Overflow, would lead to out of memory.  */",
        "goto out_of_memory;",
        "goto",
        "out_of_memory",
        ";",
        "tmp = (TCHAR_T *) malloc (tmp_memsize);",
        "tmp = (TCHAR_T *) malloc (tmp_memsize)",
        "tmp",
        "=",
        "(TCHAR_T *) malloc (tmp_memsize)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "malloc (tmp_memsize)",
        "malloc",
        "(tmp_memsize)",
        "(",
        "tmp_memsize",
        ")",
        ";",
        "if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;",
        "if",
        "(tmp == NULL)",
        "(",
        "tmp == NULL",
        "tmp",
        "==",
        "NULL",
        ")",
        "/* Out of memory.  */",
        "goto out_of_memory;",
        "goto",
        "out_of_memory",
        ";",
        "}",
        "#endif",
        "/* Construct the format string for calling snprintf or\n                   sprintf.  */",
        "fbp = buf;",
        "fbp = buf",
        "fbp",
        "=",
        "buf",
        ";",
        "*fbp++ = '%';",
        "*fbp++ = '%'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'%'",
        "'",
        "'",
        ";",
        "#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif",
        "#if",
        "NEED_PRINTF_FLAG_GROUPING",
        "\n",
        "/* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */",
        "#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';",
        "#else",
        "if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';",
        "if",
        "(flags & FLAG_GROUP)",
        "(",
        "flags & FLAG_GROUP",
        "flags",
        "&",
        "FLAG_GROUP",
        ")",
        "*fbp++ = '\\'';",
        "*fbp++ = '\\''",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'\\''",
        "'",
        "\\'",
        "'",
        ";",
        "#endif",
        "if (flags & FLAG_LEFT)\n                  *fbp++ = '-';",
        "if",
        "(flags & FLAG_LEFT)",
        "(",
        "flags & FLAG_LEFT",
        "flags",
        "&",
        "FLAG_LEFT",
        ")",
        "*fbp++ = '-';",
        "*fbp++ = '-'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'-'",
        "'",
        "'",
        ";",
        "if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';",
        "if",
        "(flags & FLAG_SHOWSIGN)",
        "(",
        "flags & FLAG_SHOWSIGN",
        "flags",
        "&",
        "FLAG_SHOWSIGN",
        ")",
        "*fbp++ = '+';",
        "*fbp++ = '+'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'+'",
        "'",
        "'",
        ";",
        "if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';",
        "if",
        "(flags & FLAG_SPACE)",
        "(",
        "flags & FLAG_SPACE",
        "flags",
        "&",
        "FLAG_SPACE",
        ")",
        "*fbp++ = ' ';",
        "*fbp++ = ' '",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "' '",
        "'",
        "'",
        ";",
        "if (flags & FLAG_ALT)\n                  *fbp++ = '#';",
        "if",
        "(flags & FLAG_ALT)",
        "(",
        "flags & FLAG_ALT",
        "flags",
        "&",
        "FLAG_ALT",
        ")",
        "*fbp++ = '#';",
        "*fbp++ = '#'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'#'",
        "'",
        "'",
        ";",
        "#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif",
        "#if",
        "__GLIBC__ >= 2 && !defined __UCLIBC__",
        "__GLIBC__ >= 2",
        "__GLIBC__",
        ">=",
        "2",
        "&&",
        "!defined __UCLIBC__",
        "!",
        "defined __UCLIBC__",
        "defined",
        "__UCLIBC__",
        "\n",
        "if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';",
        "if",
        "(flags & FLAG_LOCALIZED)",
        "(",
        "flags & FLAG_LOCALIZED",
        "flags",
        "&",
        "FLAG_LOCALIZED",
        ")",
        "*fbp++ = 'I';",
        "*fbp++ = 'I'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'I'",
        "'",
        "'",
        ";",
        "#endif",
        "if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "if",
        "(!pad_ourselves)",
        "(",
        "!pad_ourselves",
        "!",
        "pad_ourselves",
        ")",
        "{\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "{",
        "if (flags & FLAG_ZERO)\n                      *fbp++ = '0';",
        "if",
        "(flags & FLAG_ZERO)",
        "(",
        "flags & FLAG_ZERO",
        "flags",
        "&",
        "FLAG_ZERO",
        ")",
        "*fbp++ = '0';",
        "*fbp++ = '0'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'0'",
        "'",
        "'",
        ";",
        "if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "if",
        "(dp->width_start != dp->width_end)",
        "(",
        "dp->width_start != dp->width_end",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        "{\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "{",
        "size_t n = dp->width_end - dp->width_start;",
        "size_t",
        "n = dp->width_end - dp->width_start",
        "n",
        "=",
        "dp->width_end - dp->width_start",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        "-",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "/* The width specification is known to consist only\n                           of standard ASCII characters.  */",
        "if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }",
        "if",
        "(sizeof (FCHAR_T) == sizeof (TCHAR_T))",
        "(",
        "sizeof (FCHAR_T) == sizeof (TCHAR_T)",
        "sizeof (FCHAR_T)",
        "sizeof",
        "(FCHAR_T)",
        "(",
        "FCHAR_T",
        ")",
        "==",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "{\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }",
        "{",
        "memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));",
        "memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T))",
        "memcpy",
        "(fbp, dp->width_start, n * sizeof (TCHAR_T))",
        "(",
        "fbp",
        ",",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ",",
        "n * sizeof (TCHAR_T)",
        "n",
        "*",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "fbp += n;",
        "fbp += n",
        "fbp",
        "+=",
        "n",
        ";",
        "}",
        "else",
        "{\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }",
        "{",
        "const FCHAR_T *mp = dp->width_start;",
        "const",
        "const",
        "FCHAR_T",
        "*mp = dp->width_start",
        "*mp",
        "*",
        "mp",
        "=",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);",
        "do",
        "*fbp++ = (unsigned char) *mp++;",
        "*fbp++ = (unsigned char) *mp++",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "(unsigned char) *mp++",
        "(",
        "unsigned char",
        "unsigned char",
        "unsigned",
        "char",
        ")",
        "*mp++",
        "*",
        "mp++",
        "mp",
        "++",
        ";",
        "while",
        "(--n > 0)",
        "(",
        "--n > 0",
        "--n",
        "--",
        "n",
        ">",
        "0",
        ")",
        ";",
        "}",
        "}",
        "}",
        "if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "if",
        "(!prec_ourselves)",
        "(",
        "!prec_ourselves",
        "!",
        "prec_ourselves",
        ")",
        "{\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "{",
        "if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "if",
        "(dp->precision_start != dp->precision_end)",
        "(",
        "dp->precision_start != dp->precision_end",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "{\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "{",
        "size_t n = dp->precision_end - dp->precision_start;",
        "size_t",
        "n = dp->precision_end - dp->precision_start",
        "n",
        "=",
        "dp->precision_end - dp->precision_start",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        "-",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ";",
        "/* The precision specification is known to consist only\n                           of standard ASCII characters.  */",
        "if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }",
        "if",
        "(sizeof (FCHAR_T) == sizeof (TCHAR_T))",
        "(",
        "sizeof (FCHAR_T) == sizeof (TCHAR_T)",
        "sizeof (FCHAR_T)",
        "sizeof",
        "(FCHAR_T)",
        "(",
        "FCHAR_T",
        ")",
        "==",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "{\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }",
        "{",
        "memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));",
        "memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T))",
        "memcpy",
        "(fbp, dp->precision_start, n * sizeof (TCHAR_T))",
        "(",
        "fbp",
        ",",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ",",
        "n * sizeof (TCHAR_T)",
        "n",
        "*",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "fbp += n;",
        "fbp += n",
        "fbp",
        "+=",
        "n",
        ";",
        "}",
        "else",
        "{\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }",
        "{",
        "const FCHAR_T *mp = dp->precision_start;",
        "const",
        "const",
        "FCHAR_T",
        "*mp = dp->precision_start",
        "*mp",
        "*",
        "mp",
        "=",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ";",
        "do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);",
        "do",
        "*fbp++ = (unsigned char) *mp++;",
        "*fbp++ = (unsigned char) *mp++",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "(unsigned char) *mp++",
        "(",
        "unsigned char",
        "unsigned char",
        "unsigned",
        "char",
        ")",
        "*mp++",
        "*",
        "mp++",
        "mp",
        "++",
        ";",
        "while",
        "(--n > 0)",
        "(",
        "--n > 0",
        "--n",
        "--",
        "n",
        ">",
        "0",
        ")",
        ";",
        "}",
        "}",
        "}",
        "switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }",
        "switch",
        "(type)",
        "(",
        "type",
        ")",
        "{\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }",
        "{",
        "#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif",
        "#if",
        "HAVE_LONG_LONG_INT",
        "\n",
        "case TYPE_LONGLONGINT:",
        "case",
        "TYPE_LONGLONGINT",
        ":",
        "case TYPE_ULONGLONGINT:",
        "case",
        "TYPE_ULONGLONGINT",
        ":",
        "# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif",
        "# if",
        "(defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__",
        "(defined _WIN32 || defined __WIN32__)",
        "(",
        "defined _WIN32 || defined __WIN32__",
        "defined _WIN32",
        "defined",
        "_WIN32",
        "||",
        "defined __WIN32__",
        "defined",
        "__WIN32__",
        ")",
        "&&",
        "! defined __CYGWIN__",
        "!",
        "defined __CYGWIN__",
        "defined",
        "__CYGWIN__",
        "\n",
        "*fbp++ = 'I';",
        "*fbp++ = 'I'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'I'",
        "'",
        "'",
        ";",
        "*fbp++ = '6';",
        "*fbp++ = '6'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'6'",
        "'",
        "'",
        ";",
        "*fbp++ = '4';",
        "*fbp++ = '4'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'4'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "# else\n                    *fbp++ = 'l';",
        "# else",
        "*fbp++ = 'l';",
        "*fbp++ = 'l'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'l'",
        "'",
        "'",
        ";",
        "/*FALLTHROUGH*/",
        "# endif",
        "#endif",
        "case TYPE_LONGINT:",
        "case",
        "TYPE_LONGINT",
        ":",
        "case TYPE_ULONGINT:",
        "case",
        "TYPE_ULONGINT",
        ":",
        "#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif",
        "#if",
        "HAVE_WINT_T",
        "\n",
        "case TYPE_WIDE_CHAR:",
        "case",
        "TYPE_WIDE_CHAR",
        ":",
        "#endif",
        "#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif",
        "#if",
        "HAVE_WCHAR_T",
        "\n",
        "case TYPE_WIDE_STRING:",
        "case",
        "TYPE_WIDE_STRING",
        ":",
        "#endif",
        "*fbp++ = 'l';",
        "*fbp++ = 'l'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'l'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;",
        "case",
        "TYPE_LONGDOUBLE",
        ":",
        "*fbp++ = 'L';",
        "*fbp++ = 'L'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'L'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    break;",
        "default",
        ":",
        "break;",
        "break",
        ";",
        "}",
        "#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif",
        "#if",
        "NEED_PRINTF_DIRECTIVE_F",
        "\n",
        "if (dp->conversion == 'F')\n                  *fbp = 'f';",
        "if",
        "(dp->conversion == 'F')",
        "(",
        "dp->conversion == 'F'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'F'",
        "'",
        "'",
        ")",
        "*fbp = 'f';",
        "*fbp = 'f'",
        "*fbp",
        "*",
        "fbp",
        "=",
        "'f'",
        "'",
        "'",
        ";",
        "else",
        "else",
        "#endif",
        "*fbp = dp->conversion;",
        "*fbp = dp->conversion",
        "*fbp",
        "*",
        "fbp",
        "=",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ";",
        "#if USE_SNPRINTF\n# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif",
        "# if",
        "!(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))",
        "!",
        "(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))",
        "(",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__)",
        "(",
        "(__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__",
        "(__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))",
        "(",
        "__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)",
        "__GLIBC__ > 2",
        "__GLIBC__",
        ">",
        "2",
        "||",
        "(__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)",
        "(",
        "__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3",
        "__GLIBC__ == 2",
        "__GLIBC__",
        "==",
        "2",
        "&&",
        "__GLIBC_MINOR__ >= 3",
        "__GLIBC_MINOR__",
        ">=",
        "3",
        ")",
        ")",
        "&&",
        "!defined __UCLIBC__",
        "!",
        "defined __UCLIBC__",
        "defined",
        "__UCLIBC__",
        ")",
        "||",
        "((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)",
        "(",
        "(defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__",
        "(defined _WIN32 || defined __WIN32__)",
        "(",
        "defined _WIN32 || defined __WIN32__",
        "defined _WIN32",
        "defined",
        "_WIN32",
        "||",
        "defined __WIN32__",
        "defined",
        "__WIN32__",
        ")",
        "&&",
        "! defined __CYGWIN__",
        "!",
        "defined __CYGWIN__",
        "defined",
        "__CYGWIN__",
        ")",
        ")",
        "\n",
        "fbp[1] = '%';",
        "fbp[1] = '%'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'%'",
        "'",
        "'",
        ";",
        "fbp[2] = 'n';",
        "fbp[2] = 'n'",
        "fbp[2]",
        "fbp",
        "[",
        "2",
        "]",
        "=",
        "'n'",
        "'",
        "'",
        ";",
        "fbp[3] = '\\0';",
        "fbp[3] = '\\0'",
        "fbp[3]",
        "fbp",
        "[",
        "3",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';",
        "# else",
        "/* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */",
        "/* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "# endif",
        "#else\n                fbp[1] = '\\0';",
        "#else",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "#endif",
        "/* Construct the arguments for calling snprintf or sprintf.  */",
        "prefix_count = 0;",
        "prefix_count = 0",
        "prefix_count",
        "=",
        "0",
        ";",
        "if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }",
        "if",
        "(!pad_ourselves && dp->width_arg_index != ARG_NONE)",
        "(",
        "!pad_ourselves && dp->width_arg_index != ARG_NONE",
        "!pad_ourselves",
        "!",
        "pad_ourselves",
        "&&",
        "dp->width_arg_index != ARG_NONE",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }",
        "{",
        "if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();",
        "if",
        "(!(a.arg[dp->width_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->width_arg_index].type == TYPE_INT",
        "a.arg[dp->width_arg_index].type",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;",
        "prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int",
        "prefixes[prefix_count++]",
        "prefixes",
        "[",
        "prefix_count++",
        "prefix_count",
        "++",
        "]",
        "=",
        "a.arg[dp->width_arg_index].a.a_int",
        "a.arg[dp->width_arg_index].a",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "}",
        "if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }",
        "if",
        "(!prec_ourselves && dp->precision_arg_index != ARG_NONE)",
        "(",
        "!prec_ourselves && dp->precision_arg_index != ARG_NONE",
        "!prec_ourselves",
        "!",
        "prec_ourselves",
        "&&",
        "dp->precision_arg_index != ARG_NONE",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }",
        "{",
        "if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();",
        "if",
        "(!(a.arg[dp->precision_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->precision_arg_index].type == TYPE_INT",
        "a.arg[dp->precision_arg_index].type",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;",
        "prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int",
        "prefixes[prefix_count++]",
        "prefixes",
        "[",
        "prefix_count++",
        "prefix_count",
        "++",
        "]",
        "=",
        "a.arg[dp->precision_arg_index].a.a_int",
        "a.arg[dp->precision_arg_index].a",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "}",
        "#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */",
        "# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n",
        "# define",
        "TCHARS_PER_DCHAR",
        " (sizeof (DCHAR_T) / sizeof (TCHAR_T))",
        "\n",
        "/* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */",
        "ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));",
        "ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR))",
        "ENSURE_ALLOCATION",
        "(xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR))",
        "(",
        "xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "(2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR",
        "(2 + TCHARS_PER_DCHAR - 1)",
        "(",
        "2 + TCHARS_PER_DCHAR - 1",
        "2 + TCHARS_PER_DCHAR",
        "2",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ")",
        ";",
        "/* Prepare checking whether snprintf returns the count\n                   via %n.  */",
        "*(TCHAR_T *) (result + length) = '\\0';",
        "*(TCHAR_T *) (result + length) = '\\0'",
        "*(TCHAR_T *) (result + length)",
        "*",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "#endif",
        "orig_errno = errno;",
        "orig_errno = errno",
        "orig_errno",
        "=",
        "errno",
        ";",
        "for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }",
        "for",
        "(",
        ";",
        ";",
        ")",
        "{\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }",
        "{",
        "int count = -1;",
        "int",
        "count = -1",
        "count",
        "=",
        "-1",
        ";",
        "#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "int retcount = 0;",
        "int",
        "retcount = 0",
        "retcount",
        "=",
        "0",
        ";",
        "size_t maxlen = allocated - length;",
        "size_t",
        "maxlen = allocated - length",
        "maxlen",
        "=",
        "allocated - length",
        "allocated",
        "-",
        "length",
        ";",
        "/* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */",
        "if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;",
        "if",
        "(maxlen > INT_MAX / TCHARS_PER_DCHAR)",
        "(",
        "maxlen > INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        ">",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        "maxlen = INT_MAX / TCHARS_PER_DCHAR;",
        "maxlen = INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        "=",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "maxlen = maxlen * TCHARS_PER_DCHAR;",
        "maxlen = maxlen * TCHARS_PER_DCHAR",
        "maxlen",
        "=",
        "maxlen * TCHARS_PER_DCHAR",
        "maxlen",
        "*",
        "TCHARS_PER_DCHAR",
        ";",
        "# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "# define",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        " \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }",
        "\n",
        "#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "#else",
        "# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "# define",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        " \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }",
        "\n",
        "#endif",
        "errno = 0;",
        "errno = 0",
        "errno",
        "=",
        "0",
        ";",
        "switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }",
        "switch",
        "(type)",
        "(",
        "type",
        ")",
        "{\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }",
        "{",
        "case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_SCHAR",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_schar;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_schar",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_schar",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_schar",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_UCHAR",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_uchar;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_uchar",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_uchar",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_uchar",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_SHORT",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_short;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_short",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_short",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_short",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_USHORT",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_ushort;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ushort",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ushort",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ushort",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_INT",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_int;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_int",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_UINT",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_uint;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_uint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_uint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_uint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGINT",
        ":",
        "{\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long int arg = a.arg[dp->arg_index].a.a_longint;",
        "long int",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_longint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_ULONGINT",
        ":",
        "{\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;",
        "unsigned long int",
        "unsigned",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ulongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ulongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ulongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_LONG_LONG_INT",
        "\n",
        "case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGLONGINT",
        ":",
        "{\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long long int arg = a.arg[dp->arg_index].a.a_longlongint;",
        "long long int",
        "long",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_longlongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longlongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longlongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_ULONGLONGINT",
        ":",
        "{\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;",
        "unsigned long long int",
        "unsigned",
        "long",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ulonglongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ulonglongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ulonglongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_DOUBLE",
        ":",
        "{\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "double arg = a.arg[dp->arg_index].a.a_double;",
        "double",
        "arg = a.arg[dp->arg_index].a.a_double",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_double",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_double",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGDOUBLE",
        ":",
        "{\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long double arg = a.arg[dp->arg_index].a.a_longdouble;",
        "long double",
        "long",
        "double",
        "arg = a.arg[dp->arg_index].a.a_longdouble",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longdouble",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longdouble",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_CHAR",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_char;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_char",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_char",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_char",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_WINT_T",
        "\n",
        "case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_WIDE_CHAR",
        ":",
        "{\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "wint_t arg = a.arg[dp->arg_index].a.a_wide_char;",
        "wint_t",
        "arg = a.arg[dp->arg_index].a.a_wide_char",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_wide_char",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_wide_char",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_STRING",
        ":",
        "{\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "const char *arg = a.arg[dp->arg_index].a.a_string;",
        "const",
        "const",
        "char",
        "*arg = a.arg[dp->arg_index].a.a_string",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_string",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_string",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_WCHAR_T",
        "\n",
        "case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_WIDE_STRING",
        ":",
        "{\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;",
        "const",
        "const",
        "wchar_t",
        "*arg = a.arg[dp->arg_index].a.a_wide_string",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_wide_string",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_wide_string",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_POINTER",
        ":",
        "{\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "void *arg = a.arg[dp->arg_index].a.a_pointer;",
        "void",
        "*arg = a.arg[dp->arg_index].a.a_pointer",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_pointer",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_pointer",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "default:\n                        abort ();",
        "default",
        ":",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "}",
        "#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */",
        "if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }",
        "if",
        "(count >= 0)",
        "(",
        "count >= 0",
        "count",
        ">=",
        "0",
        ")",
        "{\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }",
        "{",
        "/* Verify that snprintf() has NUL-terminated its\n                           result.  */",
        "if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();",
        "if",
        "(count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')",
        "(",
        "count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0'",
        "count < maxlen",
        "count",
        "<",
        "maxlen",
        "&&",
        "((TCHAR_T *) (result + length)) [count] != '\\0'",
        "((TCHAR_T *) (result + length)) [count]",
        "((TCHAR_T *) (result + length))",
        "(",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ")",
        "[",
        "count",
        "]",
        "!=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "/* Portability hack.  */",
        "if (retcount > count)\n                          count = retcount;",
        "if",
        "(retcount > count)",
        "(",
        "retcount > count",
        "retcount",
        ">",
        "count",
        ")",
        "count = retcount;",
        "count = retcount",
        "count",
        "=",
        "retcount",
        ";",
        "}",
        "else",
        "{\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }",
        "{",
        "/* snprintf() doesn't understand the '%n'\n                           directive.  */",
        "if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }",
        "if",
        "(fbp[1] != '\\0')",
        "(",
        "fbp[1] != '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "!=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ")",
        "{\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }",
        "{",
        "/* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "else",
        "{\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }",
        "{",
        "/* Look at the snprintf() return value.  */",
        "if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;",
        "if",
        "(retcount < 0)",
        "(",
        "retcount < 0",
        "retcount",
        "<",
        "0",
        ")",
        "{\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }",
        "{",
        "# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif",
        "# if",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "\n",
        "/* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */",
        "size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);",
        "size_t",
        "tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "tmp_length",
        "=",
        "MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "MAX_ROOM_NEEDED",
        "(&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "(",
        "&a",
        "&",
        "a",
        ",",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        ",",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ",",
        "type",
        ",",
        "flags",
        ",",
        "width",
        ",",
        "has_precision",
        ",",
        "precision",
        ",",
        "pad_ourselves",
        ")",
        ";",
        "if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }",
        "if",
        "(maxlen < tmp_length)",
        "(",
        "maxlen < tmp_length",
        "maxlen",
        "<",
        "tmp_length",
        ")",
        "{\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }",
        "{",
        "/* Make more room.  But try to do through\n                                       this reallocation only once.  */",
        "size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);",
        "size_t",
        "bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "bigger_need",
        "=",
        "xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR",
        "xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)",
        "xsum",
        "(tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)",
        "(",
        "tmp_length",
        ",",
        "TCHARS_PER_DCHAR - 1",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ";",
        "/* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */",
        "size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);",
        "size_t",
        "bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12)",
        "bigger_need2",
        "=",
        "xsum (xtimes (allocated, 2), 12)",
        "xsum",
        "(xtimes (allocated, 2), 12)",
        "(",
        "xtimes (allocated, 2)",
        "xtimes",
        "(allocated, 2)",
        "(",
        "allocated",
        ",",
        "2",
        ")",
        ",",
        "12",
        ")",
        ";",
        "if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;",
        "if",
        "(bigger_need < bigger_need2)",
        "(",
        "bigger_need < bigger_need2",
        "bigger_need",
        "<",
        "bigger_need2",
        ")",
        "bigger_need = bigger_need2;",
        "bigger_need = bigger_need2",
        "bigger_need",
        "=",
        "bigger_need2",
        ";",
        "ENSURE_ALLOCATION (bigger_need);",
        "ENSURE_ALLOCATION (bigger_need)",
        "ENSURE_ALLOCATION",
        "(bigger_need)",
        "(",
        "bigger_need",
        ")",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "# endif",
        "}",
        "else",
        "count = retcount;",
        "count = retcount",
        "count",
        "=",
        "retcount",
        ";",
        "}",
        "}",
        "#endif",
        "/* Attempt to handle failure.  */",
        "if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }",
        "if",
        "(count < 0)",
        "(",
        "count < 0",
        "count",
        "<",
        "0",
        ")",
        "{\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }",
        "{",
        "/* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */",
        "int saved_errno = errno;",
        "int",
        "saved_errno = errno",
        "saved_errno",
        "=",
        "errno",
        ";",
        "if (!(result == resultbuf || result == NULL))\n                          free (result);",
        "if",
        "(!(result == resultbuf || result == NULL))",
        "(",
        "!(result == resultbuf || result == NULL)",
        "!",
        "(result == resultbuf || result == NULL)",
        "(",
        "result == resultbuf || result == NULL",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        "||",
        "result == NULL",
        "result",
        "==",
        "NULL",
        ")",
        ")",
        "free (result);",
        "free (result)",
        "free",
        "(result)",
        "(",
        "result",
        ")",
        ";",
        "if (buf_malloced != NULL)\n                          free (buf_malloced);",
        "if",
        "(buf_malloced != NULL)",
        "(",
        "buf_malloced != NULL",
        "buf_malloced",
        "!=",
        "NULL",
        ")",
        "free (buf_malloced);",
        "free (buf_malloced)",
        "free",
        "(buf_malloced)",
        "(",
        "buf_malloced",
        ")",
        ";",
        "CLEANUP ();",
        "CLEANUP ()",
        "CLEANUP",
        "()",
        "(",
        ")",
        ";",
        "errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));",
        "errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL))",
        "errno",
        "=",
        "(saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL))",
        "(",
        "saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL)",
        "saved_errno != 0",
        "saved_errno",
        "!=",
        "0",
        "?",
        "saved_errno",
        ":",
        "(dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL)",
        "(",
        "dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL",
        "dp->conversion == 'c' || dp->conversion == 's'",
        "dp->conversion == 'c'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'c'",
        "'",
        "'",
        "||",
        "dp->conversion == 's'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'s'",
        "'",
        "'",
        "?",
        "EILSEQ",
        ":",
        "EINVAL",
        ")",
        ")",
        ";",
        "return NULL;",
        "return",
        "NULL",
        ";",
        "}",
        "#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */",
        "if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }",
        "if",
        "((unsigned int) count + 1 >= maxlen)",
        "(",
        "(unsigned int) count + 1 >= maxlen",
        "(unsigned int) count + 1",
        "(unsigned int) count",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "count",
        "+",
        "1",
        ">=",
        "maxlen",
        ")",
        "{\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }",
        "{",
        "/* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */",
        "if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }",
        "if",
        "(maxlen == INT_MAX / TCHARS_PER_DCHAR)",
        "(",
        "maxlen == INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        "==",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        "goto overflow;",
        "goto",
        "overflow",
        ";",
        "else",
        "{\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }",
        "{",
        "/* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */",
        "size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));",
        "size_t",
        "n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "n",
        "=",
        "xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "xmax",
        "(xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "(",
        "xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR",
        "((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)",
        "(",
        "(unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1",
        "(unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR",
        "(unsigned int) count + 2",
        "(unsigned int) count",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "count",
        "+",
        "2",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ",",
        "xtimes (allocated, 2)",
        "xtimes",
        "(allocated, 2)",
        "(",
        "allocated",
        ",",
        "2",
        ")",
        ")",
        ";",
        "ENSURE_ALLOCATION (n);",
        "ENSURE_ALLOCATION (n)",
        "ENSURE_ALLOCATION",
        "(n)",
        "(",
        "n",
        ")",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "}",
        "#endif",
        "#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif",
        "#if",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }",
        "if",
        "(prec_ourselves)",
        "(",
        "prec_ourselves",
        ")",
        "{\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }",
        "{",
        "/* Handle the precision.  */",
        "TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);",
        "TCHAR_T",
        "*prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length)",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "=",
        "# if",
        "# if",
        "USE_SNPRINTF\n                          (TCHAR_T *) (result + length)",
        "USE_SNPRINTF\n                          (TCHAR_T *)",
        "USE_SNPRINTF",
        "(TCHAR_T *)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# else\n                          tmp;\n",
        "# else",
        "\n                          tmp;",
        "\n",
        "# endif\n                        size_t prefix_count;\n",
        "# endif",
        "\n                        size_t prefix_count;",
        "\n",
        "size_t move;",
        "size_t",
        "move",
        ";",
        "prefix_count = 0;",
        "prefix_count = 0",
        "prefix_count",
        "=",
        "0",
        ";",
        "/* Put the additional zeroes after the sign.  */",
        "if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;",
        "if",
        "(count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))",
        "(",
        "count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' ')",
        "count >= 1",
        "count",
        ">=",
        "1",
        "&&",
        "(*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' ')",
        "(",
        "*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '",
        "*prec_ptr == '-' || *prec_ptr == '+'",
        "*prec_ptr == '-'",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "'-'",
        "'",
        "'",
        "||",
        "*prec_ptr == '+'",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "'+'",
        "'",
        "'",
        "||",
        "*prec_ptr == ' '",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "' '",
        "'",
        "'",
        ")",
        ")",
        "prefix_count = 1;",
        "prefix_count = 1",
        "prefix_count",
        "=",
        "1",
        ";",
        "/* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */",
        "else",
        "if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;",
        "if",
        "(count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))",
        "(",
        "count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X')",
        "count >= 2\n                                 && prec_ptr[0] == '0'",
        "count >= 2",
        "count",
        ">=",
        "2",
        "&&",
        "prec_ptr[0] == '0'",
        "prec_ptr[0]",
        "prec_ptr",
        "[",
        "0",
        "]",
        "==",
        "'0'",
        "'",
        "'",
        "&&",
        "(prec_ptr[1] == 'x' || prec_ptr[1] == 'X')",
        "(",
        "prec_ptr[1] == 'x' || prec_ptr[1] == 'X'",
        "prec_ptr[1] == 'x'",
        "prec_ptr[1]",
        "prec_ptr",
        "[",
        "1",
        "]",
        "==",
        "'x'",
        "'",
        "'",
        "||",
        "prec_ptr[1] == 'X'",
        "prec_ptr[1]",
        "prec_ptr",
        "[",
        "1",
        "]",
        "==",
        "'X'",
        "'",
        "'",
        ")",
        ")",
        "prefix_count = 2;",
        "prefix_count = 2",
        "prefix_count",
        "=",
        "2",
        ";",
        "move = count - prefix_count;",
        "move = count - prefix_count",
        "move",
        "=",
        "count - prefix_count",
        "count",
        "-",
        "prefix_count",
        ";",
        "if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }",
        "if",
        "(precision > move)",
        "(",
        "precision > move",
        "precision",
        ">",
        "move",
        ")",
        "{\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }",
        "{",
        "/* Insert zeroes.  */",
        "size_t insert = precision - move;",
        "size_t",
        "insert = precision - move",
        "insert",
        "=",
        "precision - move",
        "precision",
        "-",
        "move",
        ";",
        "TCHAR_T *prec_end;",
        "TCHAR_T",
        "*prec_end",
        "*",
        "prec_end",
        ";",
        "# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);",
        "size_t",
        "n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "n",
        "=",
        "xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "(count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR",
        "(count + insert + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + insert + TCHARS_PER_DCHAR - 1",
        "count + insert + TCHARS_PER_DCHAR",
        "count + insert",
        "count",
        "+",
        "insert",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ";",
        "length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;",
        "length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "length",
        "+=",
        "(count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "(count + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + TCHARS_PER_DCHAR - 1",
        "count + TCHARS_PER_DCHAR",
        "count",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "ENSURE_ALLOCATION (n);",
        "ENSURE_ALLOCATION (n)",
        "ENSURE_ALLOCATION",
        "(n)",
        "(",
        "n",
        ")",
        ";",
        "length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;",
        "length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "length",
        "-=",
        "(count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "(count + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + TCHARS_PER_DCHAR - 1",
        "count + TCHARS_PER_DCHAR",
        "count",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "prec_ptr = (TCHAR_T *) (result + length);",
        "prec_ptr = (TCHAR_T *) (result + length)",
        "prec_ptr",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# endif",
        "prec_end = prec_ptr + count;",
        "prec_end = prec_ptr + count",
        "prec_end",
        "=",
        "prec_ptr + count",
        "prec_ptr",
        "+",
        "count",
        ";",
        "prec_ptr += prefix_count;",
        "prec_ptr += prefix_count",
        "prec_ptr",
        "+=",
        "prefix_count",
        ";",
        "while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }",
        "while",
        "(prec_end > prec_ptr)",
        "(",
        "prec_end > prec_ptr",
        "prec_end",
        ">",
        "prec_ptr",
        ")",
        "{\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }",
        "{",
        "prec_end--;",
        "prec_end--",
        "prec_end",
        "--",
        ";",
        "prec_end[insert] = prec_end[0];",
        "prec_end[insert] = prec_end[0]",
        "prec_end[insert]",
        "prec_end",
        "[",
        "insert",
        "]",
        "=",
        "prec_end[0]",
        "prec_end",
        "[",
        "0",
        "]",
        ";",
        "}",
        "prec_end += insert;",
        "prec_end += insert",
        "prec_end",
        "+=",
        "insert",
        ";",
        "do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);",
        "do",
        "*--prec_end = '0';",
        "*--prec_end = '0'",
        "*--prec_end",
        "*",
        "--prec_end",
        "--",
        "prec_end",
        "=",
        "'0'",
        "'",
        "'",
        ";",
        "while",
        "(prec_end > prec_ptr)",
        "(",
        "prec_end > prec_ptr",
        "prec_end",
        ">",
        "prec_ptr",
        ")",
        ";",
        "count += insert;",
        "count += insert",
        "count",
        "+=",
        "insert",
        ";",
        "}",
        "}",
        "#endif",
        "#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();",
        "if",
        "(count >= tmp_length)",
        "(",
        "count >= tmp_length",
        "count",
        ">=",
        "tmp_length",
        ")",
        "/* tmp_length was incorrectly calculated - fix the\n                         code above!  */",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "#endif",
        "#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "\n",
        "/* Convert from TCHAR_T[] to DCHAR_T[].  */",
        "if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }",
        "if",
        "(dp->conversion == 'c' || dp->conversion == 's')",
        "(",
        "dp->conversion == 'c' || dp->conversion == 's'",
        "dp->conversion == 'c'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'c'",
        "'",
        "'",
        "||",
        "dp->conversion == 's'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'s'",
        "'",
        "'",
        ")",
        "{\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }",
        "{",
        "/* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */",
        "const TCHAR_T *tmpsrc;",
        "const",
        "const",
        "TCHAR_T",
        "*tmpsrc",
        "*",
        "tmpsrc",
        ";",
        "DCHAR_T *tmpdst;",
        "DCHAR_T",
        "*tmpdst",
        "*",
        "tmpdst",
        ";",
        "size_t tmpdst_len;",
        "size_t",
        "tmpdst_len",
        ";",
        "/* This code assumes that TCHAR_T is 'char'.  */",
        "verify (sizeof (TCHAR_T) == 1);",
        "verify (sizeof (TCHAR_T) == 1)",
        "verify",
        "(sizeof (TCHAR_T) == 1)",
        "(",
        "sizeof (TCHAR_T) == 1",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        "==",
        "1",
        ")",
        ";",
        "# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "tmpsrc = (TCHAR_T *) (result + length);",
        "tmpsrc = (TCHAR_T *) (result + length)",
        "tmpsrc",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# else\n                        tmpsrc = tmp;",
        "# else",
        "tmpsrc = tmp;",
        "tmpsrc = tmp",
        "tmpsrc",
        "=",
        "tmp",
        ";",
        "# endif",
        "tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);",
        "tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "tmpdst",
        "=",
        "DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "DCHAR_CONV_FROM_ENCODING",
        "(locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "(",
        "locale_charset ()",
        "locale_charset",
        "()",
        "(",
        ")",
        ",",
        "iconveh_question_mark",
        ",",
        "tmpsrc",
        ",",
        "count",
        ",",
        "NULL",
        ",",
        "NULL",
        ",",
        "&tmpdst_len",
        "&",
        "tmpdst_len",
        ")",
        ";",
        "if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }",
        "if",
        "(tmpdst == NULL)",
        "(",
        "tmpdst == NULL",
        "tmpdst",
        "==",
        "NULL",
        ")",
        "{\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }",
        "{",
        "int saved_errno = errno;",
        "int",
        "saved_errno = errno",
        "saved_errno",
        "=",
        "errno",
        ";",
        "if (!(result == resultbuf || result == NULL))\n                              free (result);",
        "if",
        "(!(result == resultbuf || result == NULL))",
        "(",
        "!(result == resultbuf || result == NULL)",
        "!",
        "(result == resultbuf || result == NULL)",
        "(",
        "result == resultbuf || result == NULL",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        "||",
        "result == NULL",
        "result",
        "==",
        "NULL",
        ")",
        ")",
        "free (result);",
        "free (result)",
        "free",
        "(result)",
        "(",
        "result",
        ")",
        ";",
        "if (buf_malloced != NULL)\n                              free (buf_malloced);",
        "if",
        "(buf_malloced != NULL)",
        "(",
        "buf_malloced != NULL",
        "buf_malloced",
        "!=",
        "NULL",
        ")",
        "free (buf_malloced);",
        "free (buf_malloced)",
        "free",
        "(buf_malloced)",
        "(",
        "buf_malloced",
        ")",
        ";",
        "CLEANUP ();",
        "CLEANUP ()",
        "CLEANUP",
        "()",
        "(",
        ")",
        ";",
        "errno = saved_errno;",
        "errno = saved_errno",
        "errno",
        "=",
        "saved_errno",
        ";",
        "return NULL;",
        "return",
        "NULL",
        ";",
        "}",
        "ENSURE_ALLOCATION (xsum (length, tmpdst_len));",
        "ENSURE_ALLOCATION (xsum (length, tmpdst_len))",
        "ENSURE_ALLOCATION",
        "(xsum (length, tmpdst_len))",
        "(",
        "xsum (length, tmpdst_len)",
        "xsum",
        "(length, tmpdst_len)",
        "(",
        "length",
        ",",
        "tmpdst_len",
        ")",
        ")",
        ";",
        "DCHAR_CPY (result + length, tmpdst, tmpdst_len);",
        "DCHAR_CPY (result + length, tmpdst, tmpdst_len)",
        "DCHAR_CPY",
        "(result + length, tmpdst, tmpdst_len)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ",",
        "tmpdst",
        ",",
        "tmpdst_len",
        ")",
        ";",
        "free (tmpdst);",
        "free (tmpdst)",
        "free",
        "(tmpdst)",
        "(",
        "tmpdst",
        ")",
        ";",
        "count = tmpdst_len;",
        "count = tmpdst_len",
        "count",
        "=",
        "tmpdst_len",
        ";",
        "}",
        "else",
        "{\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }",
        "{",
        "/* The result string is ASCII.\n                           Simple 1:1 conversion.  */",
        "# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "/* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */",
        "if (sizeof (DCHAR_T) != sizeof (TCHAR_T))",
        "if",
        "(sizeof (DCHAR_T) != sizeof (TCHAR_T))",
        "(",
        "sizeof (DCHAR_T) != sizeof (TCHAR_T)",
        "sizeof (DCHAR_T)",
        "sizeof",
        "(DCHAR_T)",
        "(",
        "DCHAR_T",
        ")",
        "!=",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "",
        "",
        "# endif",
        "{\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }",
        "{",
        "const TCHAR_T *tmpsrc;",
        "const",
        "const",
        "TCHAR_T",
        "*tmpsrc",
        "*",
        "tmpsrc",
        ";",
        "DCHAR_T *tmpdst;",
        "DCHAR_T",
        "*tmpdst",
        "*",
        "tmpdst",
        ";",
        "size_t n;",
        "size_t",
        "n",
        ";",
        "# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }",
        "if",
        "(result == resultbuf)",
        "(",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        ")",
        "{\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }",
        "{",
        "tmpsrc = (TCHAR_T *) (result + length);",
        "tmpsrc = (TCHAR_T *) (result + length)",
        "tmpsrc",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "/* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */",
        "ENSURE_ALLOCATION (xsum (length, count));",
        "ENSURE_ALLOCATION",
        "(xsum (length, count))",
        "("
      ]
    }
  },
  "sharutils/sharutils-4.15.2/intl/vasnprintf.h": {},
  "sharutils/sharutils-4.15.2/intl/vasnwprintf.h": {},
  "sharutils/sharutils-4.15.2/intl/verify.h": {},
  "sharutils/sharutils-4.15.2/intl/version.c": {},
  "sharutils/sharutils-4.15.2/intl/wprintf-parse.h": {},
  "sharutils/sharutils-4.15.2/intl/xsize.c": {},
  "sharutils/sharutils-4.15.2/intl/xsize.h": {
    "size_t": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "__attribute__ ((__pure__))\n#endif\nxsum (size_t size1, size_t size2)\n{\n  size_t sum = size1 + size2;\n  return (sum >= size1 ? sum : SIZE_MAX);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": null
    },
    "__pure__": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "__attribute__ ((__pure__))\n#endif\nxmax (size_t size1, size_t size2)\n{\n  /* No explicit check is needed here, because for any n:\n     max (SIZE_MAX, n) == SIZE_MAX and max (n, SIZE_MAX) == SIZE_MAX.  */\n  return (size1 >= size2 ? size1 : size2);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": null
    }
  },
  "sharutils/sharutils-4.15.2/lib/alloca.c": {
    "find_stack_direction": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static int\nfind_stack_direction (int *addr, int depth)\n{\n  int dir, dummy = 0;\n  if (! addr)\n    addr = &dummy;\n  *addr = addr < &dummy ? 1 : addr == &dummy ? 0 : -1;\n  dir = depth ? find_stack_direction (addr, depth - 1) : 0;\n  return dir + dummy;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "alloca": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "void *\nalloca (size_t size)\n{\n  auto char probe;              /* Probes stack depth: */\n  register char *depth = ADDRESS_FUNCTION (probe);\n\n#  if STACK_DIRECTION == 0\n  if (STACK_DIR == 0)           /* Unknown growth direction.  */\n    STACK_DIR = find_stack_direction (NULL, (size & 1) + 20);\n#  endif\n\n  /* Reclaim garbage, defined as all alloca'd storage that\n     was allocated from deeper in the stack than currently.  */\n\n  {\n    register header *hp;        /* Traverses linked list.  */\n\n#  ifdef emacs\n    BLOCK_INPUT;\n#  endif\n\n    for (hp = last_alloca_header; hp != NULL;)\n      if ((STACK_DIR > 0 && hp->h.deep > depth)\n          || (STACK_DIR < 0 && hp->h.deep < depth))\n        {\n          register header *np = hp->h.next;\n\n          free (hp);            /* Collect garbage.  */\n\n          hp = np;              /* -> next header.  */\n        }\n      else\n        break;                  /* Rest are not deeper.  */\n\n    last_alloca_header = hp;    /* -> last valid storage.  */\n\n#  ifdef emacs\n    UNBLOCK_INPUT;\n#  endif\n  }\n\n  if (size == 0)\n    return NULL;                /* No allocation required.  */\n\n  /* Allocate combined header + user data storage.  */\n\n  {\n    /* Address of header.  */\n    register header *new;\n\n    size_t combined_size = sizeof (header) + size;\n    if (combined_size < sizeof (header))\n      memory_full ();\n\n    new = malloc (combined_size);\n\n    if (! new)\n      memory_full ();\n\n    new->h.next = last_alloca_header;\n    new->h.deep = depth;\n\n    last_alloca_header = new;\n\n    /* User storage begins just after header.  */\n\n    return (void *) (new + 1);\n  }\n}",
      "lines": 69,
      "depth": 13,
      "decorators": [
        "void",
        "*\nalloca (size_t size)",
        "*"
      ]
    },
    "i00afunc": [
      {
        "start_point": [
          328,
          0
        ],
        "end_point": [
          393,
          1
        ],
        "content": "static long\ni00afunc (long *address)\n{\n  struct stk_stat status;\n  struct stk_trailer *trailer;\n  long *block, size;\n  long result = 0;\n\n  /* We want to iterate through all of the segments.  The first\n     step is to get the stack status structure.  We could do this\n     more quickly and more directly, perhaps, by referencing the\n     $LM00 common block, but I know that this works.  */\n\n  STKSTAT (&status);\n\n  /* Set up the iteration.  */\n\n  trailer = (struct stk_trailer *) (status.current_address\n                                    + status.current_size\n                                    - 15);\n\n  /* There must be at least one stack segment.  Therefore it is\n     a fatal error if \"trailer\" is null.  */\n\n  if (trailer == 0)\n    abort ();\n\n  /* Discard segments that do not contain our argument address.  */\n\n  while (trailer != 0)\n    {\n      block = (long *) trailer->this_address;\n      size = trailer->this_size;\n      if (block == 0 || size == 0)\n        abort ();\n      trailer = (struct stk_trailer *) trailer->link;\n      if ((block <= address) && (address < (block + size)))\n        break;\n    }\n\n  /* Set the result to the offset in this segment and add the sizes\n     of all predecessor segments.  */\n\n  result = address - block;\n\n  if (trailer == 0)\n    {\n      return result;\n    }\n\n  do\n    {\n      if (trailer->this_size <= 0)\n        abort ();\n      result += trailer->this_size;\n      trailer = (struct stk_trailer *) trailer->link;\n    }\n  while (trailer != 0);\n\n  /* We are done.  Note that if you present a bogus address (one\n     not in any segment), you will get a different number back, formed\n     from subtracting the address of the first block.  This is probably\n     not what you want.  */\n\n  return (result);\n}",
        "lines": 66,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "long",
          "long"
        ]
      },
      {
        "start_point": [
          402,
          0
        ],
        "end_point": [
          471,
          1
        ],
        "content": "static long\ni00afunc (long address)\n{\n  long stkl = 0;\n\n  long size, pseg, this_segment, stack;\n  long result = 0;\n\n  struct stack_segment_linkage *ssptr;\n\n  /* Register B67 contains the address of the end of the\n     current stack segment.  If you (as a subprogram) store\n     your registers on the stack and find that you are past\n     the contents of B67, you have overflowed the segment.\n\n     B67 also points to the stack segment linkage control\n     area, which is what we are really interested in.  */\n\n  stkl = CRAY_STACKSEG_END ();\n  ssptr = (struct stack_segment_linkage *) stkl;\n\n  /* If one subtracts 'size' from the end of the segment,\n     one has the address of the first word of the segment.\n\n     If this is not the first segment, 'pseg' will be\n     nonzero.  */\n\n  pseg = ssptr->sspseg;\n  size = ssptr->sssize;\n\n  this_segment = stkl - size;\n\n  /* It is possible that calling this routine itself caused\n     a stack overflow.  Discard stack segments which do not\n     contain the target address.  */\n\n  while (!(this_segment <= address && address <= stkl))\n    {\n#    ifdef DEBUG_I00AFUNC\n      fprintf (stderr, \"%011o %011o %011o\\n\", this_segment, address, stkl);\n#    endif\n      if (pseg == 0)\n        break;\n      stkl = stkl - pseg;\n      ssptr = (struct stack_segment_linkage *) stkl;\n      size = ssptr->sssize;\n      pseg = ssptr->sspseg;\n      this_segment = stkl - size;\n    }\n\n  result = address - this_segment;\n\n  /* If you subtract pseg from the current end of the stack,\n     you get the address of the previous stack segment's end.\n     This seems a little convoluted to me, but I'll bet you save\n     a cycle somewhere.  */\n\n  while (pseg != 0)\n    {\n#    ifdef DEBUG_I00AFUNC\n      fprintf (stderr, \"%011o %011o\\n\", pseg, size);\n#    endif\n      stkl = stkl - pseg;\n      ssptr = (struct stack_segment_linkage *) stkl;\n      size = ssptr->sssize;\n      pseg = ssptr->sspseg;\n      result += size;\n    }\n  return (result);\n}",
        "lines": 70,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "long",
          "long"
        ]
      }
    ]
  },
  "sharutils/sharutils-4.15.2/lib/alloca.in.h": {},
  "sharutils/sharutils-4.15.2/lib/anytostr.c": {
    "__attribute_warn_unused_result__": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "char * __attribute_warn_unused_result__\nanytostr (inttype i, char *buf)\n{\n  char *p = buf + INT_STRLEN_BOUND (inttype);\n  *p = 0;\n\n  if (i < 0)\n    {\n      do\n        *--p = '0' - i % 10;\n      while ((i /= 10) != 0);\n\n      *--p = '-';\n    }\n  else\n    {\n      do\n        *--p = '0' + i % 10;\n      while ((i /= 10) != 0);\n    }\n\n  return p;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "char",
        "* __attribute_warn_unused_result__\nanytostr (inttype i, char *buf)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/assure.h": {},
  "sharutils/sharutils-4.15.2/lib/at-func.c": {
    "AT_FUNC_NAME": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "FUNC_RESULT\nAT_FUNC_NAME (int fd, char const *file AT_FUNC_POST_FILE_PARAM_DECLS)\n{\n  VALIDATE_FLAG (flag);\n\n  if (fd == AT_FDCWD || IS_ABSOLUTE_FILE_NAME (file))\n    return CALL_FUNC (file);\n\n#ifdef GNULIB_SUPPORT_ONLY_AT_FDCWD\n  errno = ENOTSUP;\n  return FUNC_FAIL;\n#else\n  {\n  /* Be careful to choose names unlikely to conflict with\n     AT_FUNC_POST_FILE_PARAM_DECLS.  */\n  struct saved_cwd saved_cwd;\n  int saved_errno;\n  FUNC_RESULT err;\n\n  {\n    char proc_buf[OPENAT_BUFFER_SIZE];\n    char *proc_file = openat_proc_name (proc_buf, fd, file);\n    if (proc_file)\n      {\n        FUNC_RESULT proc_result = CALL_FUNC (proc_file);\n        int proc_errno = errno;\n        if (proc_file != proc_buf)\n          free (proc_file);\n        /* If the syscall succeeds, or if it fails with an unexpected\n           errno value, then return right away.  Otherwise, fall through\n           and resort to using save_cwd/restore_cwd.  */\n        if (FUNC_FAIL != proc_result)\n          return proc_result;\n        if (! EXPECTED_ERRNO (proc_errno))\n          {\n            errno = proc_errno;\n            return proc_result;\n          }\n      }\n  }\n\n  if (save_cwd (&saved_cwd) != 0)\n    openat_save_fail (errno);\n  if (0 <= fd && fd == saved_cwd.desc)\n    {\n      /* If saving the working directory collides with the user's\n         requested fd, then the user's fd must have been closed to\n         begin with.  */\n      free_cwd (&saved_cwd);\n      errno = EBADF;\n      return FUNC_FAIL;\n    }\n\n  if (fchdir (fd) != 0)\n    {\n      saved_errno = errno;\n      free_cwd (&saved_cwd);\n      errno = saved_errno;\n      return FUNC_FAIL;\n    }\n\n  err = CALL_FUNC (file);\n  saved_errno = (err == FUNC_FAIL ? errno : 0);\n\n  if (restore_cwd (&saved_cwd) != 0)\n    openat_restore_fail (errno);\n\n  free_cwd (&saved_cwd);\n\n  if (saved_errno)\n    errno = saved_errno;\n  return err;\n  }\n#endif\n}",
      "lines": 75,
      "depth": 14,
      "decorators": [
        "FUNC_RESULT"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/base64.c": {
    "to_uchar": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static unsigned char\nto_uchar (char ch)\n{\n  return ch;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "base64_encode_fast": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static void\nbase64_encode_fast (const char *restrict in, size_t inlen, char *restrict out)\n{\n  while (inlen)\n    {\n      *out++ = b64c[to_uchar (in[0]) >> 2];\n      *out++ = b64c[((to_uchar (in[0]) << 4) + (to_uchar (in[1]) >> 4)) & 0x3f];\n      *out++ = b64c[((to_uchar (in[1]) << 2) + (to_uchar (in[2]) >> 6)) & 0x3f];\n      *out++ = b64c[to_uchar (in[2]) & 0x3f];\n\n      inlen -= 3;\n      in += 3;\n    }\n}",
      "lines": 14,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "base64_encode": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "void\nbase64_encode (const char *restrict in, size_t inlen,\n               char *restrict out, size_t outlen)\n{\n  /* Note this outlen constraint can be enforced at compile time.\n     I.E. that the output buffer is exactly large enough to hold\n     the encoded inlen bytes.  The inlen constraints (of corresponding\n     to outlen, and being a multiple of 3) can change at runtime\n     at the end of input.  However the common case when reading\n     large inputs is to have both constraints satisfied, so we depend\n     on both in base_encode_fast().  */\n  if (outlen % 4 == 0 && inlen == outlen / 4 * 3)\n    {\n      base64_encode_fast (in, inlen, out);\n      return;\n    }\n\n  while (inlen && outlen)\n    {\n      *out++ = b64c[to_uchar (in[0]) >> 2];\n      if (!--outlen)\n        break;\n      *out++ = b64c[((to_uchar (in[0]) << 4)\n                       + (--inlen ? to_uchar (in[1]) >> 4 : 0))\n                      & 0x3f];\n      if (!--outlen)\n        break;\n      *out++ =\n        (inlen\n         ? b64c[((to_uchar (in[1]) << 2)\n                   + (--inlen ? to_uchar (in[2]) >> 6 : 0))\n                  & 0x3f]\n         : '=');\n      if (!--outlen)\n        break;\n      *out++ = inlen ? b64c[to_uchar (in[2]) & 0x3f] : '=';\n      if (!--outlen)\n        break;\n      if (inlen)\n        inlen--;\n      if (inlen)\n        in += 3;\n    }\n\n  if (outlen)\n    *out = '\\0';\n}",
      "lines": 47,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "base64_encode_alloc": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "size_t\nbase64_encode_alloc (const char *in, size_t inlen, char **out)\n{\n  size_t outlen = 1 + BASE64_LENGTH (inlen);\n\n  /* Check for overflow in outlen computation.\n   *\n   * If there is no overflow, outlen >= inlen.\n   *\n   * If the operation (inlen + 2) overflows then it yields at most +1, so\n   * outlen is 0.\n   *\n   * If the multiplication overflows, we lose at least half of the\n   * correct value, so the result is < ((inlen + 2) / 3) * 2, which is\n   * less than (inlen + 2) * 0.66667, which is less than inlen as soon as\n   * (inlen > 4).\n   */\n  if (inlen > outlen)\n    {\n      *out = NULL;\n      return 0;\n    }\n\n  *out = malloc (outlen);\n  if (!*out)\n    return outlen;\n\n  base64_encode (in, inlen, *out, outlen);\n\n  return outlen - 1;\n}",
      "lines": 31,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "isbase64": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        331,
        1
      ],
      "content": "bool\nisbase64 (char ch)\n{\n  return uchar_in_range (to_uchar (ch)) && 0 <= b64[to_uchar (ch)];\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "base64_decode_ctx_init": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        338,
        1
      ],
      "content": "void\nbase64_decode_ctx_init (struct base64_decode_context *ctx)\n{\n  ctx->i = 0;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "get_4": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "static char *\nget_4 (struct base64_decode_context *ctx,\n       char const *restrict *in, char const *restrict in_end,\n       size_t *n_non_newline)\n{\n  if (ctx->i == 4)\n    ctx->i = 0;\n\n  if (ctx->i == 0)\n    {\n      char const *t = *in;\n      if (4 <= in_end - *in && memchr (t, '\\n', 4) == NULL)\n        {\n          /* This is the common case: no newline.  */\n          *in += 4;\n          *n_non_newline = 4;\n          return (char *) t;\n        }\n    }\n\n  {\n    /* Copy non-newline bytes into BUF.  */\n    char const *p = *in;\n    while (p < in_end)\n      {\n        char c = *p++;\n        if (c != '\\n')\n          {\n            ctx->buf[ctx->i++] = c;\n            if (ctx->i == 4)\n              break;\n          }\n      }\n\n    *in = p;\n    *n_non_newline = ctx->i;\n    return ctx->buf;\n  }\n}",
      "lines": 39,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_4 (struct base64_decode_context *ctx,\n       char const *restrict *in, char const *restrict in_end,\n       size_t *n_non_newline)",
        "*"
      ]
    },
    "decode_4": {
      "start_point": [
        401,
        0
      ],
      "end_point": [
        466,
        1
      ],
      "content": "static bool\ndecode_4 (char const *restrict in, size_t inlen,\n          char *restrict *outp, size_t *outleft)\n{\n  char *out = *outp;\n  if (inlen < 2)\n    return false;\n\n  if (!isbase64 (in[0]) || !isbase64 (in[1]))\n    return false;\n\n  if (*outleft)\n    {\n      *out++ = ((b64[to_uchar (in[0])] << 2)\n                | (b64[to_uchar (in[1])] >> 4));\n      --*outleft;\n    }\n\n  if (inlen == 2)\n    return_false;\n\n  if (in[2] == '=')\n    {\n      if (inlen != 4)\n        return_false;\n\n      if (in[3] != '=')\n        return_false;\n    }\n  else\n    {\n      if (!isbase64 (in[2]))\n        return_false;\n\n      if (*outleft)\n        {\n          *out++ = (((b64[to_uchar (in[1])] << 4) & 0xf0)\n                    | (b64[to_uchar (in[2])] >> 2));\n          --*outleft;\n        }\n\n      if (inlen == 3)\n        return_false;\n\n      if (in[3] == '=')\n        {\n          if (inlen != 4)\n            return_false;\n        }\n      else\n        {\n          if (!isbase64 (in[3]))\n            return_false;\n\n          if (*outleft)\n            {\n              *out++ = (((b64[to_uchar (in[2])] << 6) & 0xc0)\n                        | b64[to_uchar (in[3])]);\n              --*outleft;\n            }\n        }\n    }\n\n  *outp = out;\n  return true;\n}",
      "lines": 66,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "base64_decode_ctx": {
      "start_point": [
        486,
        0
      ],
      "end_point": [
        564,
        1
      ],
      "content": "bool\nbase64_decode_ctx (struct base64_decode_context *ctx,\n                   const char *restrict in, size_t inlen,\n                   char *restrict out, size_t *outlen)\n{\n  size_t outleft = *outlen;\n  bool ignore_newlines = ctx != NULL;\n  bool flush_ctx = false;\n  unsigned int ctx_i = 0;\n\n  if (ignore_newlines)\n    {\n      ctx_i = ctx->i;\n      flush_ctx = inlen == 0;\n    }\n\n\n  while (true)\n    {\n      size_t outleft_save = outleft;\n      if (ctx_i == 0 && !flush_ctx)\n        {\n          while (true)\n            {\n              /* Save a copy of outleft, in case we need to re-parse this\n                 block of four bytes.  */\n              outleft_save = outleft;\n              if (!decode_4 (in, inlen, &out, &outleft))\n                break;\n\n              in += 4;\n              inlen -= 4;\n            }\n        }\n\n      if (inlen == 0 && !flush_ctx)\n        break;\n\n      /* Handle the common case of 72-byte wrapped lines.\n         This also handles any other multiple-of-4-byte wrapping.  */\n      if (inlen && *in == '\\n' && ignore_newlines)\n        {\n          ++in;\n          --inlen;\n          continue;\n        }\n\n      /* Restore OUT and OUTLEFT.  */\n      out -= outleft_save - outleft;\n      outleft = outleft_save;\n\n      {\n        char const *in_end = in + inlen;\n        char const *non_nl;\n\n        if (ignore_newlines)\n          non_nl = get_4 (ctx, &in, in_end, &inlen);\n        else\n          non_nl = in;  /* Might have nl in this case. */\n\n        /* If the input is empty or consists solely of newlines (0 non-newlines),\n           then we're done.  Likewise if there are fewer than 4 bytes when not\n           flushing context and not treating newlines as garbage.  */\n        if (inlen == 0 || (inlen < 4 && !flush_ctx && ignore_newlines))\n          {\n            inlen = 0;\n            break;\n          }\n        if (!decode_4 (non_nl, inlen, &out, &outleft))\n          break;\n\n        inlen = in_end - in;\n      }\n    }\n\n  *outlen -= outleft;\n\n  return inlen == 0;\n}",
      "lines": 79,
      "depth": 15,
      "decorators": [
        "bool"
      ]
    },
    "base64_decode_alloc_ctx": {
      "start_point": [
        577,
        0
      ],
      "end_point": [
        604,
        1
      ],
      "content": "bool\nbase64_decode_alloc_ctx (struct base64_decode_context *ctx,\n                         const char *in, size_t inlen, char **out,\n                         size_t *outlen)\n{\n  /* This may allocate a few bytes too many, depending on input,\n     but it's not worth the extra CPU time to compute the exact size.\n     The exact size is 3 * (inlen + (ctx ? ctx->i : 0)) / 4, minus 1 if the\n     input ends with \"=\" and minus another 1 if the input ends with \"==\".\n     Dividing before multiplying avoids the possibility of overflow.  */\n  size_t needlen = 3 * (inlen / 4) + 3;\n\n  *out = malloc (needlen);\n  if (!*out)\n    return true;\n\n  if (!base64_decode_ctx (ctx, in, inlen, *out, &needlen))\n    {\n      free (*out);\n      *out = NULL;\n      return false;\n    }\n\n  if (outlen)\n    *outlen = needlen;\n\n  return true;\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/base64.h": {},
  "sharutils/sharutils-4.15.2/lib/basename-lgpl.c": {
    "last_component": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "char *\nlast_component (char const *name)\n{\n  char const *base = name + FILE_SYSTEM_PREFIX_LEN (name);\n  char const *p;\n  bool saw_slash = false;\n\n  while (ISSLASH (*base))\n    base++;\n\n  for (p = base; *p; p++)\n    {\n      if (ISSLASH (*p))\n        saw_slash = true;\n      else if (saw_slash)\n        {\n          base = p;\n          saw_slash = false;\n        }\n    }\n\n  return (char *) base;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "char",
        "*\nlast_component (char const *name)",
        "*"
      ]
    },
    "base_len": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "size_t\nbase_len (char const *name)\n{\n  size_t len;\n  size_t prefix_len = FILE_SYSTEM_PREFIX_LEN (name);\n\n  for (len = strlen (name);  1 < len && ISSLASH (name[len - 1]);  len--)\n    continue;\n\n  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && len == 1\n      && ISSLASH (name[0]) && ISSLASH (name[1]) && ! name[2])\n    return 2;\n\n  if (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE && prefix_len\n      && len == prefix_len && ISSLASH (name[prefix_len]))\n    return prefix_len + 1;\n\n  return len;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/basename.c": {
    "base_name": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "char *\nbase_name (char const *name)\n{\n  char const *base = last_component (name);\n  size_t length;\n\n  /* If there is no last component, then name is a file system root or the\n     empty string.  */\n  if (! *base)\n    return xstrndup (name, base_len (name));\n\n  /* Collapse a sequence of trailing slashes into one.  */\n  length = base_len (base);\n  if (ISSLASH (base[length]))\n    length++;\n\n  /* On systems with drive letters, \"a/b:c\" must return \"./b:c\" rather\n     than \"b:c\" to avoid confusion with a drive letter.  On systems\n     with pure POSIX semantics, this is not an issue.  */\n  if (FILE_SYSTEM_PREFIX_LEN (base))\n    {\n      char *p = xmalloc (length + 3);\n      p[0] = '.';\n      p[1] = '/';\n      memcpy (p + 2, base, length);\n      p[length + 2] = '\\0';\n      return p;\n    }\n\n  /* Finally, copy the basename.  */\n  return xstrndup (base, length);\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "char",
        "*\nbase_name (char const *name)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/binary-io.c": {},
  "sharutils/sharutils-4.15.2/lib/binary-io.h": {
    "set_binary_mode": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "BINARY_IO_INLINE int\nset_binary_mode (int fd, int mode)\n{\n  (void) fd;\n  (void) mode;\n  return O_BINARY;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "BINARY_IO_INLINE",
        "int",
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/c-ctype.c": {
    "c_isascii": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "bool\nc_isascii (int c)\n{\n  return (c >= 0x00 && c <= 0x7f);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    },
    "c_isalnum": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "bool\nc_isalnum (int c)\n{\n#if C_CTYPE_CONSECUTIVE_DIGITS \\\n    && C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n#if C_CTYPE_ASCII\n  return ((c >= '0' && c <= '9')\n          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z'));\n#else\n  return ((c >= '0' && c <= '9')\n          || (c >= 'A' && c <= 'Z')\n          || (c >= 'a' && c <= 'z'));\n#endif\n#else\n  switch (c)\n    {\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 34,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    },
    "c_isalpha": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "bool\nc_isalpha (int c)\n{\n#if C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n#if C_CTYPE_ASCII\n  return ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');\n#else\n  return ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'));\n#endif\n#else\n  switch (c)\n    {\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    },
    "c_isblank": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "bool\nc_isblank (int c)\n{\n  return (c == ' ' || c == '\\t');\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "c_iscntrl": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "bool\nc_iscntrl (int c)\n{\n#if C_CTYPE_ASCII\n  return ((c & ~0x1f) == 0 || c == 0x7f);\n#else\n  switch (c)\n    {\n    case ' ': case '!': case '\"': case '#': case '$': case '%':\n    case '&': case '\\'': case '(': case ')': case '*': case '+':\n    case ',': case '-': case '.': case '/':\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case ':': case ';': case '<': case '=': case '>': case '?':\n    case '@':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case '[': case '\\\\': case ']': case '^': case '_': case '`':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n    case '{': case '|': case '}': case '~':\n      return 0;\n    default:\n      return 1;\n    }\n#endif\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "c_isdigit": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "bool\nc_isdigit (int c)\n{\n#if C_CTYPE_CONSECUTIVE_DIGITS\n  return (c >= '0' && c <= '9');\n#else\n  switch (c)\n    {\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_islower": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "bool\nc_islower (int c)\n{\n#if C_CTYPE_CONSECUTIVE_LOWERCASE\n  return (c >= 'a' && c <= 'z');\n#else\n  switch (c)\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_isgraph": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "bool\nc_isgraph (int c)\n{\n#if C_CTYPE_ASCII\n  return (c >= '!' && c <= '~');\n#else\n  switch (c)\n    {\n    case '!': case '\"': case '#': case '$': case '%': case '&':\n    case '\\'': case '(': case ')': case '*': case '+': case ',':\n    case '-': case '.': case '/':\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case ':': case ';': case '<': case '=': case '>': case '?':\n    case '@':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case '[': case '\\\\': case ']': case '^': case '_': case '`':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n    case '{': case '|': case '}': case '~':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_isprint": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "bool\nc_isprint (int c)\n{\n#if C_CTYPE_ASCII\n  return (c >= ' ' && c <= '~');\n#else\n  switch (c)\n    {\n    case ' ': case '!': case '\"': case '#': case '$': case '%':\n    case '&': case '\\'': case '(': case ')': case '*': case '+':\n    case ',': case '-': case '.': case '/':\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case ':': case ';': case '<': case '=': case '>': case '?':\n    case '@':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case '[': case '\\\\': case ']': case '^': case '_': case '`':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n    case '{': case '|': case '}': case '~':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_ispunct": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "bool\nc_ispunct (int c)\n{\n#if C_CTYPE_ASCII\n  return ((c >= '!' && c <= '~')\n          && !((c >= '0' && c <= '9')\n               || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z')));\n#else\n  switch (c)\n    {\n    case '!': case '\"': case '#': case '$': case '%': case '&':\n    case '\\'': case '(': case ')': case '*': case '+': case ',':\n    case '-': case '.': case '/':\n    case ':': case ';': case '<': case '=': case '>': case '?':\n    case '@':\n    case '[': case '\\\\': case ']': case '^': case '_': case '`':\n    case '{': case '|': case '}': case '~':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 23,
      "depth": 16,
      "decorators": [
        "bool"
      ]
    },
    "c_isspace": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "bool\nc_isspace (int c)\n{\n  return (c == ' ' || c == '\\t'\n          || c == '\\n' || c == '\\v' || c == '\\f' || c == '\\r');\n}",
      "lines": 6,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "c_isupper": {
      "start_point": [
        271,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "bool\nc_isupper (int c)\n{\n#if C_CTYPE_CONSECUTIVE_UPPERCASE\n  return (c >= 'A' && c <= 'Z');\n#else\n  switch (c)\n    {\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_isxdigit": {
      "start_point": [
        291,
        0
      ],
      "end_point": [
        316,
        1
      ],
      "content": "bool\nc_isxdigit (int c)\n{\n#if C_CTYPE_CONSECUTIVE_DIGITS \\\n    && C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n#if C_CTYPE_ASCII\n  return ((c >= '0' && c <= '9')\n          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));\n#else\n  return ((c >= '0' && c <= '9')\n          || (c >= 'A' && c <= 'F')\n          || (c >= 'a' && c <= 'f'));\n#endif\n#else\n  switch (c)\n    {\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 26,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    },
    "c_tolower": {
      "start_point": [
        318,
        0
      ],
      "end_point": [
        355,
        1
      ],
      "content": "int\nc_tolower (int c)\n{\n#if C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);\n#else\n  switch (c)\n    {\n    case 'A': return 'a';\n    case 'B': return 'b';\n    case 'C': return 'c';\n    case 'D': return 'd';\n    case 'E': return 'e';\n    case 'F': return 'f';\n    case 'G': return 'g';\n    case 'H': return 'h';\n    case 'I': return 'i';\n    case 'J': return 'j';\n    case 'K': return 'k';\n    case 'L': return 'l';\n    case 'M': return 'm';\n    case 'N': return 'n';\n    case 'O': return 'o';\n    case 'P': return 'p';\n    case 'Q': return 'q';\n    case 'R': return 'r';\n    case 'S': return 's';\n    case 'T': return 't';\n    case 'U': return 'u';\n    case 'V': return 'v';\n    case 'W': return 'w';\n    case 'X': return 'x';\n    case 'Y': return 'y';\n    case 'Z': return 'z';\n    default: return c;\n    }\n#endif\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "c_toupper": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        394,
        1
      ],
      "content": "int\nc_toupper (int c)\n{\n#if C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n  return (c >= 'a' && c <= 'z' ? c - 'a' + 'A' : c);\n#else\n  switch (c)\n    {\n    case 'a': return 'A';\n    case 'b': return 'B';\n    case 'c': return 'C';\n    case 'd': return 'D';\n    case 'e': return 'E';\n    case 'f': return 'F';\n    case 'g': return 'G';\n    case 'h': return 'H';\n    case 'i': return 'I';\n    case 'j': return 'J';\n    case 'k': return 'K';\n    case 'l': return 'L';\n    case 'm': return 'M';\n    case 'n': return 'N';\n    case 'o': return 'O';\n    case 'p': return 'P';\n    case 'q': return 'Q';\n    case 'r': return 'R';\n    case 's': return 'S';\n    case 't': return 'T';\n    case 'u': return 'U';\n    case 'v': return 'V';\n    case 'w': return 'W';\n    case 'x': return 'X';\n    case 'y': return 'Y';\n    case 'z': return 'Z';\n    default: return c;\n    }\n#endif\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/c-ctype.h": {},
  "sharutils/sharutils-4.15.2/lib/c-strcase.h": {},
  "sharutils/sharutils-4.15.2/lib/c-strcasecmp.c": {
    "c_strcasecmp": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nc_strcasecmp (const char *s1, const char *s2)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2)\n    return 0;\n\n  do\n    {\n      c1 = c_tolower (*p1);\n      c2 = c_tolower (*p2);\n\n      if (c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/c-strcaseeq.h": {
    "strcaseeq9": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "static inline int\nstrcaseeq9 (const char *s1, const char *s2)\n{\n  return c_strcasecmp (s1 + 9, s2 + 9) == 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq8": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static inline int\nstrcaseeq8 (const char *s1, const char *s2, char s28)\n{\n  if (CASEEQ (s1[8], s28))\n    {\n      if (s28 == 0)\n        return 1;\n      else\n        return strcaseeq9 (s1, s2);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq7": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "static inline int\nstrcaseeq7 (const char *s1, const char *s2, char s27, char s28)\n{\n  if (CASEEQ (s1[7], s27))\n    {\n      if (s27 == 0)\n        return 1;\n      else\n        return strcaseeq8 (s1, s2, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq6": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static inline int\nstrcaseeq6 (const char *s1, const char *s2, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[6], s26))\n    {\n      if (s26 == 0)\n        return 1;\n      else\n        return strcaseeq7 (s1, s2, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq5": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static inline int\nstrcaseeq5 (const char *s1, const char *s2, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[5], s25))\n    {\n      if (s25 == 0)\n        return 1;\n      else\n        return strcaseeq6 (s1, s2, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq4": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "static inline int\nstrcaseeq4 (const char *s1, const char *s2, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[4], s24))\n    {\n      if (s24 == 0)\n        return 1;\n      else\n        return strcaseeq5 (s1, s2, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq3": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "static inline int\nstrcaseeq3 (const char *s1, const char *s2, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[3], s23))\n    {\n      if (s23 == 0)\n        return 1;\n      else\n        return strcaseeq4 (s1, s2, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq2": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "static inline int\nstrcaseeq2 (const char *s1, const char *s2, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[2], s22))\n    {\n      if (s22 == 0)\n        return 1;\n      else\n        return strcaseeq3 (s1, s2, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq1": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "static inline int\nstrcaseeq1 (const char *s1, const char *s2, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[1], s21))\n    {\n      if (s21 == 0)\n        return 1;\n      else\n        return strcaseeq2 (s1, s2, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq0": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "static inline int\nstrcaseeq0 (const char *s1, const char *s2, char s20, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[0], s20))\n    {\n      if (s20 == 0)\n        return 1;\n      else\n        return strcaseeq1 (s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/c-strncasecmp.c": {
    "c_strncasecmp": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nc_strncasecmp (const char *s1, const char *s2, size_t n)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2 || n == 0)\n    return 0;\n\n  do\n    {\n      c1 = c_tolower (*p1);\n      c2 = c_tolower (*p2);\n\n      if (--n == 0 || c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/chdir-long.c": {
    "cdb_init": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "static void\ncdb_init (struct cd_buf *cdb)\n{\n  cdb->fd = AT_FDCWD;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cdb_fchdir": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "static int\ncdb_fchdir (struct cd_buf const *cdb)\n{\n  return fchdir (cdb->fd);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cdb_free": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static void\ncdb_free (struct cd_buf const *cdb)\n{\n  if (0 <= cdb->fd)\n    {\n      bool close_fail = close (cdb->fd);\n      assure (! close_fail);\n    }\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cdb_advance_fd": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "static int\ncdb_advance_fd (struct cd_buf *cdb, char const *dir)\n{\n  int new_fd = openat (cdb->fd, dir,\n                       O_SEARCH | O_DIRECTORY | O_NOCTTY | O_NONBLOCK);\n  if (new_fd < 0)\n    return -1;\n\n  cdb_free (cdb);\n  cdb->fd = new_fd;\n\n  return 0;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "find_non_slash": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static char * _GL_ATTRIBUTE_PURE\nfind_non_slash (char const *s)\n{\n  size_t n_slash = strspn (s, \"/\");\n  return (char *) s + n_slash;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "* _GL_ATTRIBUTE_PURE\nfind_non_slash (char const *s)",
        "*",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "chdir_long": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "int\nchdir_long (char *dir)\n{\n  int e = chdir (dir);\n  if (e == 0 || errno != ENAMETOOLONG)\n    return e;\n\n  {\n    size_t len = strlen (dir);\n    char *dir_end = dir + len;\n    struct cd_buf cdb;\n    size_t n_leading_slash;\n\n    cdb_init (&cdb);\n\n    /* If DIR is the empty string, then the chdir above\n       must have failed and set errno to ENOENT.  */\n    assure (0 < len);\n    assure (PATH_MAX <= len);\n\n    /* Count leading slashes.  */\n    n_leading_slash = strspn (dir, \"/\");\n\n    /* Handle any leading slashes as well as any name that matches\n       the regular expression, m!^//hostname[/]*! .  Handling this\n       prefix separately usually results in a single additional\n       cdb_advance_fd call, but it's worthwhile, since it makes the\n       code in the following loop cleaner.  */\n    if (n_leading_slash == 2)\n      {\n        int err;\n        /* Find next slash.\n           We already know that dir[2] is neither a slash nor '\\0'.  */\n        char *slash = memchr (dir + 3, '/', dir_end - (dir + 3));\n        if (slash == NULL)\n          {\n            errno = ENAMETOOLONG;\n            return -1;\n          }\n        *slash = '\\0';\n        err = cdb_advance_fd (&cdb, dir);\n        *slash = '/';\n        if (err != 0)\n          goto Fail;\n        dir = find_non_slash (slash + 1);\n      }\n    else if (n_leading_slash)\n      {\n        if (cdb_advance_fd (&cdb, \"/\") != 0)\n          goto Fail;\n        dir += n_leading_slash;\n      }\n\n    assure (*dir != '/');\n    assure (dir <= dir_end);\n\n    while (PATH_MAX <= dir_end - dir)\n      {\n        int err;\n        /* Find a slash that is PATH_MAX or fewer bytes away from dir.\n           I.e. see if there is a slash that will give us a name of\n           length PATH_MAX-1 or less.  */\n        char *slash = memrchr (dir, '/', PATH_MAX);\n        if (slash == NULL)\n          {\n            errno = ENAMETOOLONG;\n            return -1;\n          }\n\n        *slash = '\\0';\n        assure (slash - dir < PATH_MAX);\n        err = cdb_advance_fd (&cdb, dir);\n        *slash = '/';\n        if (err != 0)\n          goto Fail;\n\n        dir = find_non_slash (slash + 1);\n      }\n\n    if (dir < dir_end)\n      {\n        if (cdb_advance_fd (&cdb, dir) != 0)\n          goto Fail;\n      }\n\n    if (cdb_fchdir (&cdb) != 0)\n      goto Fail;\n\n    cdb_free (&cdb);\n    return 0;\n\n   Fail:\n    {\n      int saved_errno = errno;\n      cdb_free (&cdb);\n      errno = saved_errno;\n      return -1;\n    }\n  }\n}",
      "lines": 100,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        259,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  char *line = NULL;\n  size_t n = 0;\n  int len;\n\n  program_name = argv[0];\n  atexit (close_stdout);\n\n  len = getline (&line, &n, stdin);\n  if (len < 0)\n    {\n      int saved_errno = errno;\n      if (feof (stdin))\n        exit (0);\n\n      error (EXIT_FAILURE, saved_errno,\n             \"reading standard input\");\n    }\n  else if (len == 0)\n    exit (0);\n\n  if (line[len-1] == '\\n')\n    line[len-1] = '\\0';\n\n  if (chdir_long (line) != 0)\n    error (EXIT_FAILURE, errno,\n           \"chdir_long failed: %s\", line);\n\n  if (argc <= 1)\n    {\n      /* Using 'pwd' here makes sense only if it is a robust implementation,\n         like the one in coreutils after the 2004-04-19 changes.  */\n      char const *cmd = \"pwd\";\n      execlp (cmd, (char *) NULL);\n      error (EXIT_FAILURE, errno, \"%s\", cmd);\n    }\n\n  fclose (stdin);\n  fclose (stderr);\n\n  exit (EXIT_SUCCESS);\n}",
      "lines": 44,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/chdir-long.h": {},
  "sharutils/sharutils-4.15.2/lib/cloexec.c": {
    "set_cloexec_flag": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nset_cloexec_flag (int desc, bool value)\n{\n#ifdef F_SETFD\n\n  int flags = fcntl (desc, F_GETFD, 0);\n\n  if (0 <= flags)\n    {\n      int newflags = (value ? flags | FD_CLOEXEC : flags & ~FD_CLOEXEC);\n\n      if (flags == newflags\n          || fcntl (desc, F_SETFD, newflags) != -1)\n        return 0;\n    }\n\n  return -1;\n\n#else /* !F_SETFD */\n\n  /* Use dup2 to reject invalid file descriptors; the cloexec flag\n     will be unaffected.  */\n  if (desc < 0)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  if (dup2 (desc, desc) < 0)\n    /* errno is EBADF here.  */\n    return -1;\n\n  /* There is nothing we can do on this kind of platform.  Punt.  */\n  return 0;\n#endif /* !F_SETFD */\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "dup_cloexec": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "int\ndup_cloexec (int fd)\n{\n  return fcntl (fd, F_DUPFD_CLOEXEC, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/cloexec.h": {},
  "sharutils/sharutils-4.15.2/lib/close.c": {
    "close_nothrow": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        37,
        5
      ],
      "content": "static int\nclose_nothrow (int fd)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = close (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_close": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int\nrpl_close (int fd)\n{\n#if WINDOWS_SOCKETS\n  int retval = execute_all_close_hooks (close_nothrow, fd);\n#else\n  int retval = close_nothrow (fd);\n#endif\n\n#if REPLACE_FCHDIR\n  if (retval >= 0)\n    _gl_unregister_fd (fd);\n#endif\n\n  return retval;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/closedir.c": {
    "closedir": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "int\nclosedir (DIR *dirp)\n{\n# if REPLACE_FCHDIR\n  int fd = dirfd (dirp);\n# endif\n  int retval;\n\n#if HAVE_CLOSEDIR\n# undef closedir\n\n  retval = closedir (dirp);\n\n#else\n\n  if (dirp->current != INVALID_HANDLE_VALUE)\n    FindClose (dirp->current);\n  free (dirp);\n\n  retval = 0;\n\n#endif\n\n#if REPLACE_FCHDIR\n  if (retval >= 0)\n    _gl_unregister_fd (fd);\n#endif\n  return retval;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/ctype.in.h": {},
  "sharutils/sharutils-4.15.2/lib/dirent-private.h": {},
  "sharutils/sharutils-4.15.2/lib/dirent.in.h": {
    "dirfd": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        164,
        58
      ],
      "content": "static inline int (dirfd) (DIR *dp) { return dirfd (dp); }",
      "lines": 1,
      "depth": 6,
      "decorators": null
    }
  },
  "sharutils/sharutils-4.15.2/lib/dirfd.c": {
    "dirfd": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "int\ndirfd (DIR *dir_p)\n{\n  int fd = DIR_TO_FD (dir_p);\n  if (fd == -1)\n    errno = ENOTSUP;\n  return fd;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/dirname-lgpl.c": {
    "dir_len": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "size_t\ndir_len (char const *file)\n{\n  size_t prefix_length = FILE_SYSTEM_PREFIX_LEN (file);\n  size_t length;\n\n  /* Advance prefix_length beyond important leading slashes.  */\n  prefix_length += (prefix_length != 0\n                    ? (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                       && ISSLASH (file[prefix_length]))\n                    : (ISSLASH (file[0])\n                       ? ((DOUBLE_SLASH_IS_DISTINCT_ROOT\n                           && ISSLASH (file[1]) && ! ISSLASH (file[2])\n                           ? 2 : 1))\n                       : 0));\n\n  /* Strip the basename and any redundant slashes before it.  */\n  for (length = last_component (file) - file;\n       prefix_length < length; length--)\n    if (! ISSLASH (file[length - 1]))\n      break;\n  return length;\n}",
      "lines": 23,
      "depth": 17,
      "decorators": [
        "size_t"
      ]
    },
    "mdir_name": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "char *\nmdir_name (char const *file)\n{\n  size_t length = dir_len (file);\n  bool append_dot = (length == 0\n                     || (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                         && length == FILE_SYSTEM_PREFIX_LEN (file)\n                         && file[2] != '\\0' && ! ISSLASH (file[2])));\n  char *dir = malloc (length + append_dot + 1);\n  if (!dir)\n    return NULL;\n  memcpy (dir, file, length);\n  if (append_dot)\n    dir[length++] = '.';\n  dir[length] = '\\0';\n  return dir;\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "char",
        "*\nmdir_name (char const *file)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/dirname.c": {
    "dir_name": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "char *\ndir_name (char const *file)\n{\n  char *result = mdir_name (file);\n  if (!result)\n    xalloc_die ();\n  return result;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\ndir_name (char const *file)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/dirname.h": {},
  "sharutils/sharutils-4.15.2/lib/dosname.h": {},
  "sharutils/sharutils-4.15.2/lib/dup-safer-flag.c": {
    "dup_safer_flag": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "int\ndup_safer_flag (int fd, int flag)\n{\n  return fcntl (fd, (flag & O_CLOEXEC) ? F_DUPFD_CLOEXEC : F_DUPFD,\n                STDERR_FILENO + 1);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/dup-safer.c": {
    "dup_safer": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\ndup_safer (int fd)\n{\n  return fcntl (fd, F_DUPFD, STDERR_FILENO + 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/dup.c": {
    "dup_nothrow": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        37,
        5
      ],
      "content": "static int\ndup_nothrow (int fd)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = dup (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_dup": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nrpl_dup (int fd)\n{\n  int result = dup_nothrow (fd);\n#if REPLACE_FCHDIR\n  if (result >= 0)\n    result = _gl_register_dup (fd, result);\n#endif\n  return result;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/dup2.c": {
    "ms_windows_dup2": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        71,
        5
      ],
      "content": "static int\nms_windows_dup2 (int fd, int desired_fd)\n{\n  int result;\n\n  /* If fd is closed, mingw hangs on dup2 (fd, fd).  If fd is open,\n     dup2 (fd, fd) returns 0, but all further attempts to use fd in\n     future dup2 calls will hang.  */\n  if (fd == desired_fd)\n    {\n      if ((HANDLE) _get_osfhandle (fd) == INVALID_HANDLE_VALUE)\n        {\n          errno = EBADF;\n          return -1;\n        }\n      return fd;\n    }\n\n  /* Wine 1.0.1 return 0 when desired_fd is negative but not -1:\n     http://bugs.winehq.org/show_bug.cgi?id=21289 */\n  if (desired_fd < 0)\n    {\n      errno = EBADF;\n      return -1;\n    }\n\n  TRY_MSVC_INVAL\n    {\n      result = dup2 (fd, desired_fd);\n    }",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_dup2": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "int\nrpl_dup2 (int fd, int desired_fd)\n{\n  int result;\n\n# ifdef F_GETFL\n  /* On Linux kernels 2.6.26-2.6.29, dup2 (fd, fd) returns -EBADF.\n     On Cygwin 1.5.x, dup2 (1, 1) returns 0.\n     On Cygwin 1.7.17, dup2 (1, -1) dumps core.\n     On Cygwin 1.7.25, dup2 (1, 256) can dump core.\n     On Haiku, dup2 (fd, fd) mistakenly clears FD_CLOEXEC.  */\n#  if HAVE_SETDTABLESIZE\n  setdtablesize (desired_fd + 1);\n#  endif\n  if (desired_fd < 0)\n    fd = desired_fd;\n  if (fd == desired_fd)\n    return fcntl (fd, F_GETFL) == -1 ? -1 : fd;\n# endif\n\n  result = dup2 (fd, desired_fd);\n\n  /* Correct an errno value on FreeBSD 6.1 and Cygwin 1.5.x.  */\n  if (result == -1 && errno == EMFILE)\n    errno = EBADF;\n# if REPLACE_FCHDIR\n  if (fd != desired_fd && result != -1)\n    result = _gl_register_dup (fd, result);\n# endif\n  return result;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "dupfd": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "static int\ndupfd (int fd, int desired_fd)\n{\n  int duplicated_fd = dup (fd);\n  if (duplicated_fd < 0 || duplicated_fd == desired_fd)\n    return duplicated_fd;\n  else\n    {\n      int r = dupfd (fd, desired_fd);\n      int e = errno;\n      close (duplicated_fd);\n      errno = e;\n      return r;\n    }\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dup2": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "int\ndup2 (int fd, int desired_fd)\n{\n  int result = fcntl (fd, F_GETFL) < 0 ? -1 : fd;\n  if (result == -1 || fd == desired_fd)\n    return result;\n  close (desired_fd);\n# ifdef F_DUPFD\n  result = fcntl (fd, F_DUPFD, desired_fd);\n#  if REPLACE_FCHDIR\n  if (0 <= result)\n    result = _gl_register_dup (fd, result);\n#  endif\n# else\n  result = dupfd (fd, desired_fd);\n# endif\n  if (result == -1 && (errno == EMFILE || errno == EINVAL))\n    errno = EBADF;\n  return result;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/errno.in.h": {},
  "sharutils/sharutils-4.15.2/lib/error.c": {
    "is_open": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "static int\nis_open (int fd)\n{\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows: The initial state of unassigned standard file\n     descriptors is that they are open but point to an INVALID_HANDLE_VALUE.\n     There is no fcntl, and the gnulib replacement fcntl does not support\n     F_GETFL.  */\n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n# else\n#  ifndef F_GETFL\n#   error Please port fcntl to your platform\n#  endif\n  return 0 <= fcntl (fd, F_GETFL);\n# endif\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "flush_stdout": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "static void\nflush_stdout (void)\n{\n#if !_LIBC\n  int stdout_fd;\n\n# if GNULIB_FREOPEN_SAFER\n  /* Use of gnulib's freopen-safer module normally ensures that\n       fileno (stdout) == 1\n     whenever stdout is open.  */\n  stdout_fd = STDOUT_FILENO;\n# else\n  /* POSIX states that fileno (stdout) after fclose is unspecified.  But in\n     practice it is not a problem, because stdout is statically allocated and\n     the fd of a FILE stream is stored as a field in its allocated memory.  */\n  stdout_fd = fileno (stdout);\n# endif\n  /* POSIX states that fflush (stdout) after fclose is unspecified; it\n     is safe in glibc, but not on all other platforms.  fflush (NULL)\n     is always defined, but too draconian.  */\n  if (0 <= stdout_fd && is_open (stdout_fd))\n#endif\n    fflush (stdout);\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_errno_message": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "static void\nprint_errno_message (int errnum)\n{\n  char const *s;\n\n#if defined HAVE_STRERROR_R || _LIBC\n  char errbuf[1024];\n# if _LIBC || STRERROR_R_CHAR_P\n  s = __strerror_r (errnum, errbuf, sizeof errbuf);\n# else\n  if (__strerror_r (errnum, errbuf, sizeof errbuf) == 0)\n    s = errbuf;\n  else\n    s = 0;\n# endif\n#else\n  s = strerror (errnum);\n#endif\n\n#if !_LIBC\n  if (! s)\n    s = _(\"Unknown system error\");\n#endif\n\n#if _LIBC\n  __fxprintf (NULL, \": %s\", s);\n#else\n  fprintf (stderr, \": %s\", s);\n#endif\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "error_tail": {
      "start_point": [
        201,
        42
      ],
      "end_point": [
        283,
        1
      ],
      "content": "char *message, va_list args)\n{\n#if _LIBC\n  if (_IO_fwide (stderr, 0) > 0)\n    {\n      size_t len = strlen (message) + 1;\n      wchar_t *wmessage = NULL;\n      mbstate_t st;\n      size_t res;\n      const char *tmp;\n      bool use_malloc = false;\n\n      while (1)\n        {\n          if (__libc_use_alloca (len * sizeof (wchar_t)))\n            wmessage = (wchar_t *) alloca (len * sizeof (wchar_t));\n          else\n            {\n              if (!use_malloc)\n                wmessage = NULL;\n\n              wchar_t *p = (wchar_t *) realloc (wmessage,\n                                                len * sizeof (wchar_t));\n              if (p == NULL)\n                {\n                  free (wmessage);\n                  fputws_unlocked (L\"out of memory\\n\", stderr);\n                  return;\n                }\n              wmessage = p;\n              use_malloc = true;\n            }\n\n          memset (&st, '\\0', sizeof (st));\n          tmp = message;\n\n          res = mbsrtowcs (wmessage, &tmp, len, &st);\n          if (res != len)\n            break;\n\n          if (__builtin_expect (len >= SIZE_MAX / sizeof (wchar_t) / 2, 0))\n            {\n              /* This really should not happen if everything is fine.  */\n              res = (size_t) -1;\n              break;\n            }\n\n          len *= 2;\n        }\n\n      if (res == (size_t) -1)\n        {\n          /* The string cannot be converted.  */\n          if (use_malloc)\n            {\n              free (wmessage);\n              use_malloc = false;\n            }\n          wmessage = (wchar_t *) L\"???\";\n        }\n\n      __vfwprintf (stderr, wmessage, args);\n\n      if (use_malloc)\n        free (wmessage);\n    }\n  else\n#endif\n    vfprintf (stderr, message, args);\n  va_end (args);\n\n  ++error_message_count;\n  if (errnum)\n    print_errno_message (errnum);\n#if _LIBC\n  __fxprintf (NULL, \"\\n\");\n#else\n  putc ('\\n', stderr);\n#endif\n  fflush (stderr);\n  if (status)\n    exit (status);\n}",
      "lines": 83,
      "depth": 18,
      "decorators": null
    },
    "error": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        327,
        1
      ],
      "content": "void\nerror (int status, int errnum, const char *message, ...)\n{\n  va_list args;\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s: \", program_name);\n#else\n      fprintf (stderr, \"%s: \", program_name);\n#endif\n    }\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "error_at_line": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        397,
        1
      ],
      "content": "void\nerror_at_line (int status, int errnum, const char *file_name,\n               unsigned int line_number, const char *message, ...)\n{\n  va_list args;\n\n  if (error_one_per_line)\n    {\n      static const char *old_file_name;\n      static unsigned int old_line_number;\n\n      if (old_line_number == line_number\n          && (file_name == old_file_name\n              || (old_file_name != NULL\n                  && file_name != NULL\n                  && strcmp (old_file_name, file_name) == 0)))\n\n        /* Simply return and print nothing.  */\n        return;\n\n      old_file_name = file_name;\n      old_line_number = line_number;\n    }\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s:\", program_name);\n#else\n      fprintf (stderr, \"%s:\", program_name);\n#endif\n    }\n\n#if _LIBC\n  __fxprintf (NULL, file_name != NULL ? \"%s:%d: \" : \" \",\n              file_name, line_number);\n#else\n  fprintf (stderr, file_name != NULL ? \"%s:%d: \" : \" \",\n           file_name, line_number);\n#endif\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 65,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/error.h": {},
  "sharutils/sharutils-4.15.2/lib/exitfail.c": {},
  "sharutils/sharutils-4.15.2/lib/exitfail.h": {},
  "sharutils/sharutils-4.15.2/lib/fatal-signal.c": {
    "init_fatal_signals": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static void\ninit_fatal_signals (void)\n{\n  static bool fatal_signals_initialized = false;\n  if (!fatal_signals_initialized)\n    {\n      size_t i;\n\n      for (i = 0; i < num_fatal_signals; i++)\n        {\n          struct sigaction action;\n\n          if (sigaction (fatal_signals[i], NULL, &action) >= 0\n              && get_handler (&action) == SIG_IGN)\n            fatal_signals[i] = -1;\n        }\n\n      fatal_signals_initialized = true;\n    }\n}",
      "lines": 20,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "uninstall_handlers": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "static void\nuninstall_handlers (void)\n{\n  size_t i;\n\n  for (i = 0; i < num_fatal_signals; i++)\n    if (fatal_signals[i] >= 0)\n      {\n        int sig = fatal_signals[i];\n        if (saved_sigactions[sig].sa_handler == SIG_IGN)\n          saved_sigactions[sig].sa_handler = SIG_DFL;\n        sigaction (sig, &saved_sigactions[sig], NULL);\n      }\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fatal_signal_handler": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "static void\nfatal_signal_handler (int sig)\n{\n  for (;;)\n    {\n      /* Get the last registered cleanup action, in a reentrant way.  */\n      action_t action;\n      size_t n = actions_count;\n      if (n == 0)\n        break;\n      n--;\n      actions_count = n;\n      action = actions[n].action;\n      /* Execute the action.  */\n      action ();\n    }\n\n  /* Now execute the signal's default action.\n     If the signal being delivered was blocked, the re-raised signal would be\n     delivered when this handler returns.  But the way we install this handler,\n     no signal is blocked, and the re-raised signal is delivered already\n     during raise().  */\n  uninstall_handlers ();\n  raise (sig);\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "install_handlers": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "static void\ninstall_handlers (void)\n{\n  size_t i;\n  struct sigaction action;\n\n  action.sa_handler = &fatal_signal_handler;\n  /* If we get a fatal signal while executing fatal_signal_handler, enter\n     fatal_signal_handler recursively, since it is reentrant.  Hence no\n     SA_RESETHAND.  */\n  action.sa_flags = SA_NODEFER;\n  sigemptyset (&action.sa_mask);\n  for (i = 0; i < num_fatal_signals; i++)\n    if (fatal_signals[i] >= 0)\n      {\n        int sig = fatal_signals[i];\n\n        if (!(sig < sizeof (saved_sigactions) / sizeof (saved_sigactions[0])))\n          abort ();\n        sigaction (sig, &action, &saved_sigactions[sig]);\n      }\n}",
      "lines": 22,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "at_fatal_signal": {
      "start_point": [
        204,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "void\nat_fatal_signal (action_t action)\n{\n  static bool cleanup_initialized = false;\n  if (!cleanup_initialized)\n    {\n      init_fatal_signals ();\n      install_handlers ();\n      cleanup_initialized = true;\n    }\n\n  if (actions_count == actions_allocated)\n    {\n      /* Extend the actions array.  Note that we cannot use xrealloc(),\n         because then the cleanup() function could access an already\n         deallocated array.  */\n      actions_entry_t *old_actions = actions;\n      size_t old_actions_allocated = actions_allocated;\n      size_t new_actions_allocated = 2 * actions_allocated;\n      actions_entry_t *new_actions =\n        XNMALLOC (new_actions_allocated, actions_entry_t);\n      size_t k;\n\n      /* Don't use memcpy() here, because memcpy takes non-volatile arguments\n         and is therefore not guaranteed to complete all memory stores before\n         the next statement.  */\n      for (k = 0; k < old_actions_allocated; k++)\n        new_actions[k] = old_actions[k];\n      actions = new_actions;\n      actions_allocated = new_actions_allocated;\n      /* Now we can free the old actions array.  */\n      if (old_actions != static_actions)\n        free (old_actions);\n    }\n  /* The two uses of 'volatile' in the types above (and ISO C 99 section\n     5.1.2.3.(5)) ensure that we increment the actions_count only after\n     the new action has been written to the memory location\n     actions[actions_count].  */\n  actions[actions_count].action = action;\n  actions_count++;\n}",
      "lines": 41,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "init_fatal_signal_set": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "static void\ninit_fatal_signal_set (void)\n{\n  static bool fatal_signal_set_initialized = false;\n  if (!fatal_signal_set_initialized)\n    {\n      size_t i;\n\n      init_fatal_signals ();\n\n      sigemptyset (&fatal_signal_set);\n      for (i = 0; i < num_fatal_signals; i++)\n        if (fatal_signals[i] >= 0)\n          sigaddset (&fatal_signal_set, fatal_signals[i]);\n\n      fatal_signal_set_initialized = true;\n    }\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "block_fatal_signals": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "void\nblock_fatal_signals (void)\n{\n  init_fatal_signal_set ();\n  sigprocmask (SIG_BLOCK, &fatal_signal_set, NULL);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "unblock_fatal_signals": {
      "start_point": [
        280,
        0
      ],
      "end_point": [
        285,
        1
      ],
      "content": "void\nunblock_fatal_signals (void)\n{\n  init_fatal_signal_set ();\n  sigprocmask (SIG_UNBLOCK, &fatal_signal_set, NULL);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/fatal-signal.h": {},
  "sharutils/sharutils-4.15.2/lib/fchdir.c": {
    "ensure_dirs_slot": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "static bool\nensure_dirs_slot (size_t fd)\n{\n  if (fd < dirs_allocated)\n    free (dirs[fd].name);\n  else\n    {\n      size_t new_allocated;\n      dir_info_t *new_dirs;\n\n      new_allocated = 2 * dirs_allocated + 1;\n      if (new_allocated <= fd)\n        new_allocated = fd + 1;\n      new_dirs =\n        (dirs != NULL\n         ? (dir_info_t *) realloc (dirs, new_allocated * sizeof *dirs)\n         : (dir_info_t *) malloc (new_allocated * sizeof *dirs));\n      if (new_dirs == NULL)\n        return false;\n      memset (new_dirs + dirs_allocated, 0,\n              (new_allocated - dirs_allocated) * sizeof *dirs);\n      dirs = new_dirs;\n      dirs_allocated = new_allocated;\n    }\n  return true;\n}",
      "lines": 26,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "get_name": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static char *\nget_name (char const *dir)\n{\n  char *cwd;\n  char *result;\n  int saved_errno;\n\n  if (IS_ABSOLUTE_FILE_NAME (dir))\n    return strdup (dir);\n\n  /* We often encounter \".\"; treat it as a special case.  */\n  cwd = getcwd (NULL, 0);\n  if (!cwd || (dir[0] == '.' && dir[1] == '\\0'))\n    return cwd;\n\n  result = mfile_name_concat (cwd, dir, NULL);\n  saved_errno = errno;\n  free (cwd);\n  errno = saved_errno;\n  return result;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_name (char const *dir)",
        "*"
      ]
    },
    "_gl_unregister_fd": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "void\n_gl_unregister_fd (int fd)\n{\n  if (fd >= 0 && fd < dirs_allocated)\n    {\n      free (dirs[fd].name);\n      dirs[fd].name = NULL;\n    }\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "_gl_register_fd": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "int\n_gl_register_fd (int fd, const char *filename)\n{\n  struct stat statbuf;\n\n  assure (0 <= fd);\n  if (REPLACE_OPEN_DIRECTORY\n      || (fstat (fd, &statbuf) == 0 && S_ISDIR (statbuf.st_mode)))\n    {\n      if (!ensure_dirs_slot (fd)\n          || (dirs[fd].name = get_name (filename)) == NULL)\n        {\n          int saved_errno = errno;\n          close (fd);\n          errno = saved_errno;\n          return -1;\n        }\n    }\n  return fd;\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "_gl_register_dup": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "int\n_gl_register_dup (int oldfd, int newfd)\n{\n  assure (0 <= oldfd && 0 <= newfd && oldfd != newfd);\n  if (oldfd < dirs_allocated && dirs[oldfd].name)\n    {\n      /* Duplicated a directory; must ensure newfd is allocated.  */\n      if (!ensure_dirs_slot (newfd)\n          || (dirs[newfd].name = strdup (dirs[oldfd].name)) == NULL)\n        {\n          int saved_errno = errno;\n          close (newfd);\n          errno = saved_errno;\n          newfd = -1;\n        }\n    }\n  else if (newfd < dirs_allocated)\n    {\n      /* Duplicated a non-directory; ensure newfd is cleared.  */\n      free (dirs[newfd].name);\n      dirs[newfd].name = NULL;\n    }\n  return newfd;\n}",
      "lines": 24,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "_gl_directory_name": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "const char *\n_gl_directory_name (int fd)\n{\n  if (0 <= fd && fd < dirs_allocated && dirs[fd].name != NULL)\n    return dirs[fd].name;\n  /* At this point, fd is either invalid, or open but not a directory.\n     If dup2 fails, errno is correctly EBADF.  */\n  if (0 <= fd)\n    {\n      if (dup2 (fd, fd) == fd)\n        errno = ENOTDIR;\n    }\n  else\n    errno = EBADF;\n  return NULL;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\n_gl_directory_name (int fd)",
        "*"
      ]
    },
    "fchdir": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "int\nfchdir (int fd)\n{\n  const char *name = _gl_directory_name (fd);\n  return name ? chdir (name) : -1;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/fcntl.c": {
    "dupfd": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "static int\ndupfd (int oldfd, int newfd, int flags)\n{\n  /* Mingw has no way to create an arbitrary fd.  Iterate until all\n     file descriptors less than newfd are filled up.  */\n  HANDLE curr_process = GetCurrentProcess ();\n  HANDLE old_handle = (HANDLE) _get_osfhandle (oldfd);\n  unsigned char fds_to_close[OPEN_MAX_MAX / CHAR_BIT];\n  unsigned int fds_to_close_bound = 0;\n  int result;\n  BOOL inherit = flags & O_CLOEXEC ? FALSE : TRUE;\n  int mode;\n\n  if (newfd < 0 || getdtablesize () <= newfd)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  if (old_handle == INVALID_HANDLE_VALUE\n      || (mode = setmode (oldfd, O_BINARY)) == -1)\n    {\n      /* oldfd is not open, or is an unassigned standard file\n         descriptor.  */\n      errno = EBADF;\n      return -1;\n    }\n  setmode (oldfd, mode);\n  flags |= mode;\n\n  for (;;)\n    {\n      HANDLE new_handle;\n      int duplicated_fd;\n      unsigned int index;\n\n      if (!DuplicateHandle (curr_process,           /* SourceProcessHandle */\n                            old_handle,             /* SourceHandle */\n                            curr_process,           /* TargetProcessHandle */\n                            (PHANDLE) &new_handle,  /* TargetHandle */\n                            (DWORD) 0,              /* DesiredAccess */\n                            inherit,                /* InheritHandle */\n                            DUPLICATE_SAME_ACCESS)) /* Options */\n        {\n          switch (GetLastError ())\n            {\n              case ERROR_TOO_MANY_OPEN_FILES:\n                errno = EMFILE;\n                break;\n              case ERROR_INVALID_HANDLE:\n              case ERROR_INVALID_TARGET_HANDLE:\n              case ERROR_DIRECT_ACCESS_HANDLE:\n                errno = EBADF;\n                break;\n              case ERROR_INVALID_PARAMETER:\n              case ERROR_INVALID_FUNCTION:\n              case ERROR_INVALID_ACCESS:\n                errno = EINVAL;\n                break;\n              default:\n                errno = EACCES;\n                break;\n            }\n          result = -1;\n          break;\n        }\n      duplicated_fd = _open_osfhandle ((intptr_t) new_handle, flags);\n      if (duplicated_fd < 0)\n        {\n          CloseHandle (new_handle);\n          result = -1;\n          break;\n        }\n      if (newfd <= duplicated_fd)\n        {\n          result = duplicated_fd;\n          break;\n        }\n\n      /* Set the bit duplicated_fd in fds_to_close[].  */\n      index = (unsigned int) duplicated_fd / CHAR_BIT;\n      if (fds_to_close_bound <= index)\n        {\n          if (sizeof fds_to_close <= index)\n            /* Need to increase OPEN_MAX_MAX.  */\n            abort ();\n          memset (fds_to_close + fds_to_close_bound, '\\0',\n                  index + 1 - fds_to_close_bound);\n          fds_to_close_bound = index + 1;\n        }\n      fds_to_close[index] |= 1 << ((unsigned int) duplicated_fd % CHAR_BIT);\n    }\n\n  /* Close the previous fds that turned out to be too small.  */\n  {\n    int saved_errno = errno;\n    unsigned int duplicated_fd;\n\n    for (duplicated_fd = 0;\n         duplicated_fd < fds_to_close_bound * CHAR_BIT;\n         duplicated_fd++)\n      if ((fds_to_close[duplicated_fd / CHAR_BIT]\n           >> (duplicated_fd % CHAR_BIT))\n          & 1)\n        close (duplicated_fd);\n\n    errno = saved_errno;\n  }\n\n# if REPLACE_FCHDIR\n  if (0 <= result)\n    result = _gl_register_dup (oldfd, result);\n# endif\n  return result;\n}",
      "lines": 114,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_fcntl": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        326,
        1
      ],
      "content": "int\nrpl_fcntl (int fd, int action, /* arg */...)\n{\n  va_list arg;\n  int result = -1;\n  va_start (arg, action);\n  switch (action)\n    {\n\n#if !HAVE_FCNTL\n    case F_DUPFD:\n      {\n        int target = va_arg (arg, int);\n        result = dupfd (fd, target, 0);\n        break;\n      }\n#elif FCNTL_DUPFD_BUGGY || REPLACE_FCHDIR\n    case F_DUPFD:\n      {\n        int target = va_arg (arg, int);\n        /* Detect invalid target; needed for cygwin 1.5.x.  */\n        if (target < 0 || getdtablesize () <= target)\n          errno = EINVAL;\n        else\n          {\n            /* Haiku alpha 2 loses fd flags on original.  */\n            int flags = fcntl (fd, F_GETFD);\n            if (flags < 0)\n              {\n                result = -1;\n                break;\n              }\n            result = fcntl (fd, action, target);\n            if (0 <= result && fcntl (fd, F_SETFD, flags) == -1)\n              {\n                int saved_errno = errno;\n                close (result);\n                result = -1;\n                errno = saved_errno;\n              }\n# if REPLACE_FCHDIR\n            if (0 <= result)\n              result = _gl_register_dup (fd, result);\n# endif\n          }\n        break;\n      } /* F_DUPFD */\n#endif /* FCNTL_DUPFD_BUGGY || REPLACE_FCHDIR */\n\n    case F_DUPFD_CLOEXEC:\n      {\n        int target = va_arg (arg, int);\n\n#if !HAVE_FCNTL\n        result = dupfd (fd, target, O_CLOEXEC);\n        break;\n#else /* HAVE_FCNTL */\n        /* Try the system call first, if the headers claim it exists\n           (that is, if GNULIB_defined_F_DUPFD_CLOEXEC is 0), since we\n           may be running with a glibc that has the macro but with an\n           older kernel that does not support it.  Cache the\n           information on whether the system call really works, but\n           avoid caching failure if the corresponding F_DUPFD fails\n           for any reason.  0 = unknown, 1 = yes, -1 = no.  */\n        static int have_dupfd_cloexec = GNULIB_defined_F_DUPFD_CLOEXEC ? -1 : 0;\n        if (0 <= have_dupfd_cloexec)\n          {\n            result = fcntl (fd, action, target);\n            if (0 <= result || errno != EINVAL)\n              {\n                have_dupfd_cloexec = 1;\n# if REPLACE_FCHDIR\n                if (0 <= result)\n                  result = _gl_register_dup (fd, result);\n# endif\n              }\n            else\n              {\n                result = rpl_fcntl (fd, F_DUPFD, target);\n                if (result < 0)\n                  break;\n                have_dupfd_cloexec = -1;\n              }\n          }\n        else\n          result = rpl_fcntl (fd, F_DUPFD, target);\n        if (0 <= result && have_dupfd_cloexec == -1)\n          {\n            int flags = fcntl (result, F_GETFD);\n            if (flags < 0 || fcntl (result, F_SETFD, flags | FD_CLOEXEC) == -1)\n              {\n                int saved_errno = errno;\n                close (result);\n                errno = saved_errno;\n                result = -1;\n              }\n          }\n        break;\n#endif /* HAVE_FCNTL */\n      } /* F_DUPFD_CLOEXEC */\n\n#if !HAVE_FCNTL\n    case F_GETFD:\n      {\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n        HANDLE handle = (HANDLE) _get_osfhandle (fd);\n        DWORD flags;\n        if (handle == INVALID_HANDLE_VALUE\n            || GetHandleInformation (handle, &flags) == 0)\n          errno = EBADF;\n        else\n          result = (flags & HANDLE_FLAG_INHERIT) ? 0 : FD_CLOEXEC;\n# else /* !W32 */\n        /* Use dup2 to reject invalid file descriptors.  No way to\n           access this information, so punt.  */\n        if (0 <= dup2 (fd, fd))\n          result = 0;\n# endif /* !W32 */\n        break;\n      } /* F_GETFD */\n#endif /* !HAVE_FCNTL */\n\n      /* Implementing F_SETFD on mingw is not trivial - there is no\n         API for changing the O_NOINHERIT bit on an fd, and merely\n         changing the HANDLE_FLAG_INHERIT bit on the underlying handle\n         can lead to odd state.  It may be possible by duplicating the\n         handle, using _open_osfhandle with the right flags, then\n         using dup2 to move the duplicate onto the original, but that\n         is not supported for now.  */\n\n    default:\n      {\n#if HAVE_FCNTL\n        void *p = va_arg (arg, void *);\n        result = fcntl (fd, action, p);\n#else\n        errno = EINVAL;\n#endif\n        break;\n      }\n    }\n  va_end (arg);\n  return result;\n}",
      "lines": 144,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/fcntl.in.h": {},
  "sharutils/sharutils-4.15.2/lib/fd-hook.c": {
    "execute_close_hooks": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "int\nexecute_close_hooks (const struct fd_hook *remaining_list, gl_close_fn primary,\n                     int fd)\n{\n  if (remaining_list == &anchor)\n    /* End of list reached.  */\n    return primary (fd);\n  else\n    return remaining_list->private_close_fn (remaining_list->private_next,\n                                             primary, fd);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "execute_all_close_hooks": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nexecute_all_close_hooks (gl_close_fn primary, int fd)\n{\n  return execute_close_hooks (anchor.private_next, primary, fd);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "execute_ioctl_hooks": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nexecute_ioctl_hooks (const struct fd_hook *remaining_list, gl_ioctl_fn primary,\n                     int fd, int request, void *arg)\n{\n  if (remaining_list == &anchor)\n    /* End of list reached.  */\n    return primary (fd, request, arg);\n  else\n    return remaining_list->private_ioctl_fn (remaining_list->private_next,\n                                             primary, fd, request, arg);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "execute_all_ioctl_hooks": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\nexecute_all_ioctl_hooks (gl_ioctl_fn primary,\n                         int fd, int request, void *arg)\n{\n  return execute_ioctl_hooks (anchor.private_next, primary, fd, request, arg);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "register_fd_hook": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "void\nregister_fd_hook (close_hook_fn close_hook, ioctl_hook_fn ioctl_hook, struct fd_hook *link)\n{\n  if (close_hook == NULL)\n    close_hook = execute_close_hooks;\n  if (ioctl_hook == NULL)\n    ioctl_hook = execute_ioctl_hooks;\n\n  if (link->private_next == NULL && link->private_prev == NULL)\n    {\n      /* Add the link to the doubly linked list.  */\n      link->private_next = anchor.private_next;\n      link->private_prev = &anchor;\n      link->private_close_fn = close_hook;\n      link->private_ioctl_fn = ioctl_hook;\n      anchor.private_next->private_prev = link;\n      anchor.private_next = link;\n    }\n  else\n    {\n      /* The link is already in use.  */\n      if (link->private_close_fn != close_hook\n          || link->private_ioctl_fn != ioctl_hook)\n        abort ();\n    }\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "unregister_fd_hook": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void\nunregister_fd_hook (struct fd_hook *link)\n{\n  struct fd_hook *next = link->private_next;\n  struct fd_hook *prev = link->private_prev;\n\n  if (next != NULL && prev != NULL)\n    {\n      /* The link is in use.  Remove it from the doubly linked list.  */\n      prev->private_next = next;\n      next->private_prev = prev;\n      /* Clear the link, to mark it unused.  */\n      link->private_next = NULL;\n      link->private_prev = NULL;\n      link->private_close_fn = NULL;\n      link->private_ioctl_fn = NULL;\n    }\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/fd-hook.h": {},
  "sharutils/sharutils-4.15.2/lib/fd-safer-flag.c": {
    "fd_safer_flag": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\nfd_safer_flag (int fd, int flag)\n{\n  if (STDIN_FILENO <= fd && fd <= STDERR_FILENO)\n    {\n      int f = dup_safer_flag (fd, flag);\n      int e = errno;\n      close (fd);\n      errno = e;\n      fd = f;\n    }\n\n  return fd;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/fd-safer.c": {
    "fd_safer": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nfd_safer (int fd)\n{\n  if (STDIN_FILENO <= fd && fd <= STDERR_FILENO)\n    {\n      int f = dup_safer (fd);\n      int e = errno;\n      close (fd);\n      errno = e;\n      fd = f;\n    }\n\n  return fd;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/fdopendir.c": {
    "fdopendir": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "DIR *\nfdopendir (int fd)\n{\n  DIR *dir = fdopendir_with_dup (fd, -1, NULL);\n\n  if (! REPLACE_FCHDIR && ! dir)\n    {\n      int saved_errno = errno;\n      if (EXPECTED_ERRNO (saved_errno))\n        {\n          struct saved_cwd cwd;\n          if (save_cwd (&cwd) != 0)\n            openat_save_fail (errno);\n          dir = fdopendir_with_dup (fd, -1, &cwd);\n          saved_errno = errno;\n          free_cwd (&cwd);\n          errno = saved_errno;\n        }\n    }\n\n  return dir;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "DIR",
        "*\nfdopendir (int fd)",
        "*"
      ]
    },
    "fdopendir_with_dup": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "static DIR *\nfdopendir_with_dup (int fd, int older_dupfd, struct saved_cwd const *cwd)\n{\n  int dupfd = dup (fd);\n  if (dupfd < 0 && errno == EMFILE)\n    dupfd = older_dupfd;\n  if (dupfd < 0)\n    return NULL;\n  else\n    {\n      DIR *dir;\n      int saved_errno;\n      if (dupfd < fd - 1 && dupfd != older_dupfd)\n        {\n          dir = fdopendir_with_dup (fd, dupfd, cwd);\n          saved_errno = errno;\n        }\n      else\n        {\n          close (fd);\n          dir = fd_clone_opendir (dupfd, cwd);\n          saved_errno = errno;\n          if (! dir)\n            {\n              int fd1 = dup (dupfd);\n              if (fd1 != fd)\n                openat_save_fail (fd1 < 0 ? errno : EBADF);\n            }\n        }\n\n      if (dupfd != older_dupfd)\n        close (dupfd);\n      errno = saved_errno;\n      return dir;\n    }\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "DIR",
        "*\nfdopendir_with_dup (int fd, int older_dupfd, struct saved_cwd const *cwd)",
        "*"
      ]
    },
    "fd_clone_opendir": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "static DIR *\nfd_clone_opendir (int fd, struct saved_cwd const *cwd)\n{\n  if (REPLACE_FCHDIR || ! cwd)\n    {\n      DIR *dir = NULL;\n      int saved_errno = EOPNOTSUPP;\n      char buf[OPENAT_BUFFER_SIZE];\n      char *proc_file = openat_proc_name (buf, fd, \".\");\n      if (proc_file)\n        {\n          dir = opendir (proc_file);\n          saved_errno = errno;\n          if (proc_file != buf)\n            free (proc_file);\n        }\n# if REPLACE_FCHDIR\n      if (! dir && EXPECTED_ERRNO (saved_errno))\n        {\n          char const *name = _gl_directory_name (fd);\n          DIR *dp = name ? opendir (name) : NULL;\n\n          /* The caller has done an elaborate dance to arrange for opendir to\n             consume just the right file descriptor.  If dirfd returns -1,\n             though, we're on a system like mingw where opendir does not\n             consume a file descriptor.  Consume it via 'dup' instead.  */\n          if (dp && dirfd (dp) < 0)\n            dup (fd);\n\n          return dp;\n        }\n# endif\n      errno = saved_errno;\n      return dir;\n    }\n  else\n    {\n      if (fchdir (fd) != 0)\n        return NULL;\n      else\n        {\n          DIR *dir = opendir (\".\");\n          int saved_errno = errno;\n          if (restore_cwd (cwd) != 0)\n            openat_restore_fail (errno);\n          errno = saved_errno;\n          return dir;\n        }\n    }\n}",
      "lines": 50,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "DIR",
        "*\nfd_clone_opendir (int fd, struct saved_cwd const *cwd)",
        "*"
      ]
    },
    "rpl_fdopendir": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "DIR *\nrpl_fdopendir (int fd)\n{\n  struct stat st;\n  if (fstat (fd, &st))\n    return NULL;\n  if (!S_ISDIR (st.st_mode))\n    {\n      errno = ENOTDIR;\n      return NULL;\n    }\n  return fdopendir (fd);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "DIR",
        "*\nrpl_fdopendir (int fd)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/fflush.c": {
    "clear_ungetc_buffer_preserving_position": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static void\nclear_ungetc_buffer_preserving_position (FILE *fp)\n{\n  if (fp->_flags & _IO_IN_BACKUP)\n    /* _IO_free_backup_area is a bit complicated.  Simply call fseek.  */\n    fseeko (fp, 0, SEEK_CUR);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "clear_ungetc_buffer": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "static void\nclear_ungetc_buffer (FILE *fp)\n{\n# if defined __sferror || defined __DragonFly__ || defined __ANDROID__\n  /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Android */\n  if (HASUB (fp))\n    {\n      fp_->_p += fp_->_r;\n      fp_->_r = 0;\n    }\n# elif defined __EMX__              /* emx+gcc */\n  if (fp->_ungetc_count > 0)\n    {\n      fp->_ungetc_count = 0;\n      fp->_rcount = - fp->_rcount;\n    }\n# elif defined _IOERR               /* Minix, AIX, HP-UX, IRIX, OSF/1, Solaris, OpenServer, mingw, NonStop Kernel */\n  /* Nothing to do.  */\n# else                              /* other implementations */\n  fseeko (fp, 0, SEEK_CUR);\n# endif\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "disable_seek_optimization": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static int\ndisable_seek_optimization (FILE *fp)\n{\n  int saved_flags = fp_->_flags & (__SOPT | __SNPT);\n  fp_->_flags = (fp_->_flags & ~__SOPT) | __SNPT;\n  return saved_flags;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "restore_seek_optimization": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static void\nrestore_seek_optimization (FILE *fp, int saved_flags)\n{\n  fp_->_flags = (fp_->_flags & ~(__SOPT | __SNPT)) | saved_flags;\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "update_fpos_cache": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "static void\nupdate_fpos_cache (FILE *fp _GL_UNUSED_PARAMETER,\n                   off_t pos _GL_UNUSED_PARAMETER)\n{\n#  if defined __sferror || defined __DragonFly__ || defined __ANDROID__\n  /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Android */\n#   if defined __CYGWIN__\n  /* fp_->_offset is typed as an integer.  */\n  fp_->_offset = pos;\n#   else\n  /* fp_->_offset is an fpos_t.  */\n  /* Use a union, since on NetBSD, the compilation flags determine\n     whether fpos_t is typedef'd to off_t or a struct containing a\n     single off_t member.  */\n  union\n    {\n      fpos_t f;\n      off_t o;\n    } u;\n  u.o = pos;\n  fp_->_offset = u.f;\n#   endif\n  fp_->_flags |= __SOFF;\n#  endif\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rpl_fflush": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        228,
        1
      ],
      "content": "int\nrpl_fflush (FILE *stream)\n{\n  /* When stream is NULL, POSIX and C99 only require flushing of \"output\n     streams and update streams in which the most recent operation was not\n     input\", and all implementations do this.\n\n     When stream is \"an output stream or an update stream in which the most\n     recent operation was not input\", POSIX and C99 requires that fflush\n     writes out any buffered data, and all implementations do this.\n\n     When stream is, however, an input stream or an update stream in\n     which the most recent operation was input, C99 specifies nothing,\n     and POSIX only specifies behavior if the stream is seekable.\n     mingw, in particular, drops the input buffer, leaving the file\n     descriptor positioned at the end of the input buffer. I.e. ftell\n     (stream) is lost.  We don't want to call the implementation's\n     fflush in this case.\n\n     We test ! freading (stream) here, rather than fwriting (stream), because\n     what we need to know is whether the stream holds a \"read buffer\", and on\n     mingw this is indicated by _IOREAD, regardless of _IOWRT.  */\n  if (stream == NULL || ! freading (stream))\n    return fflush (stream);\n\n#if defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */\n\n  clear_ungetc_buffer_preserving_position (stream);\n\n  return fflush (stream);\n\n#else\n  {\n    /* Notes about the file-position indicator:\n       1) The file position indicator is incremented by fgetc() and decremented\n          by ungetc():\n          <http://www.opengroup.org/susv3/functions/fgetc.html>\n            \"... the fgetc() function shall ... advance the associated file\n             position indicator for the stream ...\"\n          <http://www.opengroup.org/susv3/functions/ungetc.html>\n            \"The file-position indicator is decremented by each successful\n             call to ungetc()...\"\n       2) <http://www.opengroup.org/susv3/functions/ungetc.html> says:\n            \"The value of the file-position indicator for the stream after\n             reading or discarding all pushed-back bytes shall be the same\n             as it was before the bytes were pushed back.\"\n          Here we are discarding all pushed-back bytes.  But more specifically,\n       3) <http://www.opengroup.org/austin/aardvark/latest/xshbug3.txt> says:\n            \"[After fflush(),] the file offset of the underlying open file\n             description shall be set to the file position of the stream, and\n             any characters pushed back onto the stream by ungetc() ... shall\n             be discarded.\"  */\n\n    /* POSIX does not specify fflush behavior for non-seekable input\n       streams.  Some implementations purge unread data, some return\n       EBADF, some do nothing.  */\n    off_t pos = ftello (stream);\n    if (pos == -1)\n      {\n        errno = EBADF;\n        return EOF;\n      }\n\n    /* Clear the ungetc buffer.  */\n    clear_ungetc_buffer (stream);\n\n    /* To get here, we must be flushing a seekable input stream, so the\n       semantics of fpurge are now appropriate to clear the buffer.  To\n       avoid losing data, the lseek is also necessary.  */\n    {\n      int result = fpurge (stream);\n      if (result != 0)\n        return result;\n    }\n\n# if (defined __sferror || defined __DragonFly__ || defined __ANDROID__) && defined __SNPT\n    /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Android */\n\n    {\n      /* Disable seek optimization for the next fseeko call.  This tells the\n         following fseeko call to seek to the desired position directly, rather\n         than to seek to a block-aligned boundary.  */\n      int saved_flags = disable_seek_optimization (stream);\n      int result = fseeko (stream, pos, SEEK_SET);\n\n      restore_seek_optimization (stream, saved_flags);\n      return result;\n    }\n\n# else\n\n    pos = lseek (fileno (stream), pos, SEEK_SET);\n    if (pos == -1)\n      return EOF;\n    /* After a successful lseek, update the file descriptor's position cache\n       in the stream.  */\n    update_fpos_cache (stream, pos);\n\n    return 0;\n\n# endif\n  }\n#endif\n}",
      "lines": 104,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/filename.h": {},
  "sharutils/sharutils-4.15.2/lib/filenamecat-lgpl.c": {
    "longest_relative_suffix": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "static char const * _GL_ATTRIBUTE_PURE\nlongest_relative_suffix (char const *f)\n{\n  for (f += FILE_SYSTEM_PREFIX_LEN (f); ISSLASH (*f); f++)\n    continue;\n  return f;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "* _GL_ATTRIBUTE_PURE\nlongest_relative_suffix (char const *f)",
        "*",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "mfile_name_concat": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "char *\nmfile_name_concat (char const *dir, char const *abase, char **base_in_result)\n{\n  char const *dirbase = last_component (dir);\n  size_t dirbaselen = base_len (dirbase);\n  size_t dirlen = dirbase - dir + dirbaselen;\n  size_t needs_separator = (dirbaselen && ! ISSLASH (dirbase[dirbaselen - 1]));\n\n  char const *base = longest_relative_suffix (abase);\n  size_t baselen = strlen (base);\n\n  char *p_concat = malloc (dirlen + needs_separator + baselen + 1);\n  char *p;\n\n  if (p_concat == NULL)\n    return NULL;\n\n  p = mempcpy (p_concat, dir, dirlen);\n  *p = DIRECTORY_SEPARATOR;\n  p += needs_separator;\n\n  if (base_in_result)\n    *base_in_result = p - IS_ABSOLUTE_FILE_NAME (abase);\n\n  p = mempcpy (p, base, baselen);\n  *p = '\\0';\n\n  return p_concat;\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "char",
        "*\nmfile_name_concat (char const *dir, char const *abase, char **base_in_result)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/filenamecat.h": {},
  "sharutils/sharutils-4.15.2/lib/fpurge.c": {
    "fpurge": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "int\nfpurge (FILE *fp)\n{\n#if HAVE___FPURGE                   /* glibc >= 2.2, Haiku, Solaris >= 7, musl libc */\n\n  __fpurge (fp);\n  /* The __fpurge function does not have a return value.  */\n  return 0;\n\n#elif HAVE_FPURGE                   /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin 1.7 */\n\n  /* Call the system's fpurge function.  */\n# undef fpurge\n# if !HAVE_DECL_FPURGE\n  extern int fpurge (FILE *);\n# endif\n  int result = fpurge (fp);\n# if defined __sferror || defined __DragonFly__ || defined __ANDROID__\n  /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Android */\n  if (result == 0)\n    /* Correct the invariants that fpurge broke.\n       <stdio.h> on BSD systems says:\n         \"The following always hold: if _flags & __SRD, _w is 0.\"\n       If this invariant is not fulfilled and the stream is read-write but\n       currently reading, subsequent putc or fputc calls will write directly\n       into the buffer, although they shouldn't be allowed to.  */\n    if ((fp_->_flags & __SRD) != 0)\n      fp_->_w = 0;\n# endif\n  return result;\n\n#else\n\n  /* Most systems provide FILE as a struct and the necessary bitmask in\n     <stdio.h>, because they need it for implementing getc() and putc() as\n     fast macros.  */\n# if defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */\n  fp->_IO_read_end = fp->_IO_read_ptr;\n  fp->_IO_write_ptr = fp->_IO_write_base;\n  /* Avoid memory leak when there is an active ungetc buffer.  */\n  if (fp->_IO_save_base != NULL)\n    {\n      free (fp->_IO_save_base);\n      fp->_IO_save_base = NULL;\n    }\n  return 0;\n# elif defined __sferror || defined __DragonFly__ || defined __ANDROID__\n  /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Android */\n  fp_->_p = fp_->_bf._base;\n  fp_->_r = 0;\n  fp_->_w = ((fp_->_flags & (__SLBF | __SNBF | __SRD)) == 0 /* fully buffered and not currently reading? */\n             ? fp_->_bf._size\n             : 0);\n  /* Avoid memory leak when there is an active ungetc buffer.  */\n  if (fp_ub._base != NULL)\n    {\n      if (fp_ub._base != fp_->_ubuf)\n        free (fp_ub._base);\n      fp_ub._base = NULL;\n    }\n  return 0;\n# elif defined __EMX__              /* emx+gcc */\n  fp->_ptr = fp->_buffer;\n  fp->_rcount = 0;\n  fp->_wcount = 0;\n  fp->_ungetc_count = 0;\n  return 0;\n# elif defined __minix              /* Minix */\n  fp->_ptr = fp->_buf;\n  if (fp->_ptr != NULL)\n    fp->_count = 0;\n  return 0;\n# elif defined _IOERR               /* AIX, HP-UX, IRIX, OSF/1, Solaris, OpenServer, mingw, NonStop Kernel */\n  fp->_ptr = fp->_base;\n  if (fp->_ptr != NULL)\n    fp->_cnt = 0;\n  return 0;\n# elif defined __UCLIBC__           /* uClibc */\n#  ifdef __STDIO_BUFFERS\n  if (fp->__modeflags & __FLAG_WRITING)\n    fp->__bufpos = fp->__bufstart;\n  else if (fp->__modeflags & (__FLAG_READONLY | __FLAG_READING))\n    fp->__bufpos = fp->__bufread;\n#  endif\n  return 0;\n# elif defined __QNX__              /* QNX */\n  fp->_Rback = fp->_Back + sizeof (fp->_Back);\n  fp->_Rsave = NULL;\n  if (fp->_Mode & 0x2000 /* _MWRITE */)\n    /* fp->_Buf <= fp->_Next <= fp->_Wend */\n    fp->_Next = fp->_Buf;\n  else\n    /* fp->_Buf <= fp->_Next <= fp->_Rend */\n    fp->_Rend = fp->_Next;\n  return 0;\n# elif defined __MINT__             /* Atari FreeMiNT */\n  if (fp->__pushed_back)\n    {\n      fp->__bufp = fp->__pushback_bufp;\n      fp->__pushed_back = 0;\n    }\n  /* Preserve the current file position.  */\n  if (fp->__target != -1)\n    fp->__target += fp->__bufp - fp->__buffer;\n  fp->__bufp = fp->__buffer;\n  /* Nothing in the buffer, next getc is nontrivial.  */\n  fp->__get_limit = fp->__bufp;\n  /* Nothing in the buffer, next putc is nontrivial.  */\n  fp->__put_limit = fp->__buffer;\n  return 0;\n# elif defined EPLAN9               /* Plan9 */\n  fp->rp = fp->wp = fp->lp = fp->buf;\n  return 0;\n# else\n#  error \"Please port gnulib fpurge.c to your platform! Look at the definitions of fflush, setvbuf and ungetc on your system, then report this to bug-gnulib.\"\n# endif\n\n#endif\n}",
      "lines": 119,
      "depth": 20,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/freading.c": {
    "freading": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "bool\nfreading (FILE *fp)\n{\n  /* Most systems provide FILE as a struct and the necessary bitmask in\n     <stdio.h>, because they need it for implementing getc() and putc() as\n     fast macros.  */\n# if defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */\n  return ((fp->_flags & _IO_NO_WRITES) != 0\n          || ((fp->_flags & (_IO_NO_READS | _IO_CURRENTLY_PUTTING)) == 0\n              && fp->_IO_read_base != NULL));\n# elif defined __sferror || defined __DragonFly__ || defined __ANDROID__\n  /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Android */\n  return (fp_->_flags & __SRD) != 0;\n# elif defined __EMX__               /* emx+gcc */\n  return (fp->_flags & _IOREAD) != 0;\n# elif defined __minix               /* Minix */\n  return (fp->_flags & _IOREADING) != 0;\n# elif defined _IOERR                /* AIX, HP-UX, IRIX, OSF/1, Solaris, OpenServer, mingw, NonStop Kernel */\n#  if defined __sun                  /* Solaris */\n  return (fp->_flag & _IOREAD) != 0 && (fp->_flag & _IOWRT) == 0;\n#  else\n  return (fp->_flag & _IOREAD) != 0;\n#  endif\n# elif defined __UCLIBC__            /* uClibc */\n  return (fp->__modeflags & (__FLAG_READONLY | __FLAG_READING)) != 0;\n# elif defined __QNX__               /* QNX */\n  return ((fp->_Mode & 0x2 /* _MOPENW */) == 0\n          || (fp->_Mode & 0x1000 /* _MREAD */) != 0);\n# elif defined __MINT__              /* Atari FreeMiNT */\n  if (!fp->__mode.__write)\n    return 1;\n  if (!fp->__mode.__read)\n    return 0;\n#  ifdef _IO_CURRENTLY_GETTING /* Flag added on 2009-02-28 */\n  return (fp->__flags & _IO_CURRENTLY_GETTING) != 0;\n#  else\n  return (fp->__buffer < fp->__get_limit /*|| fp->__bufp == fp->__put_limit ??*/);\n#  endif\n# elif defined EPLAN9                /* Plan9 */\n  if (fp->state == 0 /* CLOSED */ || fp->state == 4 /* WR */)\n    return 0;\n  return (fp->state == 3 /* RD */ && (fp->bufl == 0 || fp->rp < fp->wp));\n# else\n#  error \"Please port gnulib freading.c to your platform!\"\n# endif\n}",
      "lines": 46,
      "depth": 19,
      "decorators": [
        "bool"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/freading.h": {},
  "sharutils/sharutils-4.15.2/lib/freopen.c": {
    "orig_freopen": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "static FILE *\norig_freopen (const char *filename, const char *mode, FILE *stream)\n{\n  return freopen (filename, mode, stream);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "FILE",
        "*\norig_freopen (const char *filename, const char *mode, FILE *stream)",
        "*"
      ]
    },
    "rpl_freopen": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "FILE *\nrpl_freopen (const char *filename, const char *mode, FILE *stream)\n{\n  FILE *result;\n\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  if (filename != NULL && strcmp (filename, \"/dev/null\") == 0)\n    filename = \"NUL\";\n#endif\n\n  /* Clear errno to check the success of freopen() with it */\n  errno = 0;\n\n  result = orig_freopen (filename, mode, stream);\n\n#ifdef __KLIBC__\n  /* On OS/2 kLIBC, freopen() returns NULL even if it is successful\n     if filename is NULL. */\n  if (!filename && !result && !errno)\n    result = stream;\n#endif\n\n  return result;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "FILE",
        "*\nrpl_freopen (const char *filename, const char *mode, FILE *stream)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/fseek.c": {
    "fseek": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "int\nfseek (FILE *fp, long offset, int whence)\n{\n  /* Use the replacement fseeko function with all its workarounds.  */\n  return fseeko (fp, (off_t)offset, whence);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/fseeko.c": {},
  "sharutils/sharutils-4.15.2/lib/fstat.c": {
    "orig_fstat": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static int\norig_fstat (int fd, struct stat *buf)\n{\n  return fstat (fd, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fstat_nothrow": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        61,
        5
      ],
      "content": "static int\nfstat_nothrow (int fd, struct stat *buf)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = orig_fstat (fd, buf);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_fstat": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "int\nrpl_fstat (int fd, struct stat *buf)\n{\n#if REPLACE_FCHDIR && REPLACE_OPEN_DIRECTORY\n  /* Handle the case when rpl_open() used a dummy file descriptor to work\n     around an open() that can't normally visit directories.  */\n  const char *name = _gl_directory_name (fd);\n  if (name != NULL)\n    return stat (name, buf);\n#endif\n\n  return fstat_nothrow (fd, buf);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/fstatat.c": {
    "orig_fstatat": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "static int\norig_fstatat (int fd, char const *filename, struct stat *buf, int flags)\n{\n  return fstatat (fd, filename, buf, flags);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_fstatat": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "int\nrpl_fstatat (int fd, char const *file, struct stat *st, int flag)\n{\n  int result = orig_fstatat (fd, file, st, flag);\n  size_t len;\n\n  if (LSTAT_FOLLOWS_SLASHED_SYMLINK || result != 0)\n    return result;\n  len = strlen (file);\n  if (flag & AT_SYMLINK_NOFOLLOW)\n    {\n      /* Fix lstat behavior.  */\n      if (file[len - 1] != '/' || S_ISDIR (st->st_mode))\n        return 0;\n      if (!S_ISLNK (st->st_mode))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n      result = orig_fstatat (fd, file, st, flag & ~AT_SYMLINK_NOFOLLOW);\n    }\n  /* Fix stat behavior.  */\n  if (result == 0 && !S_ISDIR (st->st_mode) && file[len - 1] == '/')\n    {\n      errno = ENOTDIR;\n      return -1;\n    }\n  return result;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "stat_func": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static int\nstat_func (char const *name, struct stat *st)\n{\n  return stat (name, st);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/ftell.c": {
    "ftell": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "long\nftell (FILE *fp)\n{\n  /* Use the replacement ftello function with all its workarounds.  */\n  off_t offset = ftello (fp);\n  if (LONG_MIN <= offset && offset <= LONG_MAX)\n    return /* (long) */ offset;\n  else\n    {\n      errno = EOVERFLOW;\n      return -1;\n    }\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "long",
        "long"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/ftello.c": {},
  "sharutils/sharutils-4.15.2/lib/getcwd-lgpl.c": {
    "rpl_getcwd": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "char *\nrpl_getcwd (char *buf, size_t size)\n{\n  char *ptr;\n  char *result;\n\n  /* Handle single size operations.  */\n  if (buf)\n    {\n      if (!size)\n        {\n          errno = EINVAL;\n          return NULL;\n        }\n      return getcwd (buf, size);\n    }\n\n  if (size)\n    {\n      buf = malloc (size);\n      if (!buf)\n        {\n          errno = ENOMEM;\n          return NULL;\n        }\n      result = getcwd (buf, size);\n      if (!result)\n        {\n          int saved_errno = errno;\n          free (buf);\n          errno = saved_errno;\n        }\n      return result;\n    }\n\n  /* Flexible sizing requested.  Avoid over-allocation for the common\n     case of a name that fits within a 4k page, minus some space for\n     local variables, to be sure we don't skip over a guard page.  */\n  {\n    char tmp[4032];\n    size = sizeof tmp;\n    ptr = getcwd (tmp, size);\n    if (ptr)\n      {\n        result = strdup (ptr);\n        if (!result)\n          errno = ENOMEM;\n        return result;\n      }\n    if (errno != ERANGE)\n      return NULL;\n  }\n\n  /* My what a large directory name we have.  */\n  do\n    {\n      size <<= 1;\n      ptr = realloc (buf, size);\n      if (ptr == NULL)\n        {\n          free (buf);\n          errno = ENOMEM;\n          return NULL;\n        }\n      buf = ptr;\n      result = getcwd (buf, size);\n    }\n  while (!result && errno == ERANGE);\n\n  if (!result)\n    {\n      int saved_errno = errno;\n      free (buf);\n      errno = saved_errno;\n    }\n  else\n    {\n      /* Trim to fit, if possible.  */\n      result = realloc (buf, strlen (buf) + 1);\n      if (!result)\n        result = buf;\n    }\n  return result;\n}",
      "lines": 84,
      "depth": 12,
      "decorators": [
        "char",
        "*\nrpl_getcwd (char *buf, size_t size)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/getcwd.c": {
    "__getcwd": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        441,
        1
      ],
      "content": "char *\n__getcwd (char *buf, size_t size)\n{\n  /* Lengths of big file name components and entire file names, and a\n     deep level of file name nesting.  These numbers are not upper\n     bounds; they are merely large values suitable for initial\n     allocations, designed to be large enough for most real-world\n     uses.  */\n  enum\n    {\n      BIG_FILE_NAME_COMPONENT_LENGTH = 255,\n      BIG_FILE_NAME_LENGTH = MIN (4095, PATH_MAX - 1),\n      DEEP_NESTING = 100\n    };\n\n#if HAVE_OPENAT_SUPPORT\n  int fd = AT_FDCWD;\n  bool fd_needs_closing = false;\n#else\n  char dots[DEEP_NESTING * sizeof \"..\" + BIG_FILE_NAME_COMPONENT_LENGTH + 1];\n  char *dotlist = dots;\n  size_t dotsize = sizeof dots;\n  size_t dotlen = 0;\n#endif\n  DIR *dirstream = NULL;\n  dev_t rootdev, thisdev;\n  ino_t rootino, thisino;\n  char *dir;\n  register char *dirp;\n  struct stat st;\n  size_t allocated = size;\n  size_t used;\n\n#if HAVE_MINIMALLY_WORKING_GETCWD\n  /* If AT_FDCWD is not defined, the algorithm below is O(N**2) and\n     this is much slower than the system getcwd (at least on\n     GNU/Linux).  So trust the system getcwd's results unless they\n     look suspicious.\n\n     Use the system getcwd even if we have openat support, since the\n     system getcwd works even when a parent is unreadable, while the\n     openat-based approach does not.\n\n     But on AIX 5.1..7.1, the system getcwd is not even minimally\n     working: If the current directory name is slightly longer than\n     PATH_MAX, it omits the first directory component and returns\n     this wrong result with errno = 0.  */\n\n# undef getcwd\n  dir = getcwd (buf, size);\n  if (dir || (size && errno == ERANGE))\n    return dir;\n\n  /* Solaris getcwd (NULL, 0) fails with errno == EINVAL, but it has\n     internal magic that lets it work even if an ancestor directory is\n     inaccessible, which is better in many cases.  So in this case try\n     again with a buffer that's almost always big enough.  */\n  if (errno == EINVAL && buf == NULL && size == 0)\n    {\n      char big_buffer[BIG_FILE_NAME_LENGTH + 1];\n      dir = getcwd (big_buffer, sizeof big_buffer);\n      if (dir)\n        return strdup (dir);\n    }\n\n# if HAVE_PARTLY_WORKING_GETCWD\n  /* The system getcwd works, except it sometimes fails when it\n     shouldn't, setting errno to ERANGE, ENAMETOOLONG, or ENOENT.    */\n  if (errno != ERANGE && errno != ENAMETOOLONG && errno != ENOENT)\n    return NULL;\n# endif\n#endif\n\n  if (size == 0)\n    {\n      if (buf != NULL)\n        {\n          __set_errno (EINVAL);\n          return NULL;\n        }\n\n      allocated = BIG_FILE_NAME_LENGTH + 1;\n    }\n\n  if (buf == NULL)\n    {\n      dir = malloc (allocated);\n      if (dir == NULL)\n        return NULL;\n    }\n  else\n    dir = buf;\n\n  dirp = dir + allocated;\n  *--dirp = '\\0';\n\n  if (__lstat (\".\", &st) < 0)\n    goto lose;\n  thisdev = st.st_dev;\n  thisino = st.st_ino;\n\n  if (__lstat (\"/\", &st) < 0)\n    goto lose;\n  rootdev = st.st_dev;\n  rootino = st.st_ino;\n\n  while (!(thisdev == rootdev && thisino == rootino))\n    {\n      struct dirent *d;\n      dev_t dotdev;\n      ino_t dotino;\n      bool mount_point;\n      int parent_status;\n      size_t dirroom;\n      size_t namlen;\n      bool use_d_ino = true;\n\n      /* Look at the parent directory.  */\n#if HAVE_OPENAT_SUPPORT\n      fd = openat (fd, \"..\", O_RDONLY);\n      if (fd < 0)\n        goto lose;\n      fd_needs_closing = true;\n      parent_status = fstat (fd, &st);\n#else\n      dotlist[dotlen++] = '.';\n      dotlist[dotlen++] = '.';\n      dotlist[dotlen] = '\\0';\n      parent_status = __lstat (dotlist, &st);\n#endif\n      if (parent_status != 0)\n        goto lose;\n\n      if (dirstream && __closedir (dirstream) != 0)\n        {\n          dirstream = NULL;\n          goto lose;\n        }\n\n      /* Figure out if this directory is a mount point.  */\n      dotdev = st.st_dev;\n      dotino = st.st_ino;\n      mount_point = dotdev != thisdev;\n\n      /* Search for the last directory.  */\n#if HAVE_OPENAT_SUPPORT\n      dirstream = fdopendir (fd);\n      if (dirstream == NULL)\n        goto lose;\n      fd_needs_closing = false;\n#else\n      dirstream = __opendir (dotlist);\n      if (dirstream == NULL)\n        goto lose;\n      dotlist[dotlen++] = '/';\n#endif\n      for (;;)\n        {\n          /* Clear errno to distinguish EOF from error if readdir returns\n             NULL.  */\n          __set_errno (0);\n          d = __readdir (dirstream);\n\n          /* When we've iterated through all directory entries without finding\n             one with a matching d_ino, rewind the stream and consider each\n             name again, but this time, using lstat.  This is necessary in a\n             chroot on at least one system (glibc-2.3.6 + linux 2.6.12), where\n             .., ../.., ../../.., etc. all had the same device number, yet the\n             d_ino values for entries in / did not match those obtained\n             via lstat.  */\n          if (d == NULL && errno == 0 && use_d_ino)\n            {\n              use_d_ino = false;\n              rewinddir (dirstream);\n              d = __readdir (dirstream);\n            }\n\n          if (d == NULL)\n            {\n              if (errno == 0)\n                /* EOF on dirstream, which can mean e.g., that the current\n                   directory has been removed.  */\n                __set_errno (ENOENT);\n              goto lose;\n            }\n          if (d->d_name[0] == '.' &&\n              (d->d_name[1] == '\\0' ||\n               (d->d_name[1] == '.' && d->d_name[2] == '\\0')))\n            continue;\n\n          if (use_d_ino)\n            {\n              bool match = (MATCHING_INO (d, thisino) || mount_point);\n              if (! match)\n                continue;\n            }\n\n          {\n            int entry_status;\n#if HAVE_OPENAT_SUPPORT\n            entry_status = fstatat (fd, d->d_name, &st, AT_SYMLINK_NOFOLLOW);\n#else\n            /* Compute size needed for this file name, or for the file\n               name \"..\" in the same directory, whichever is larger.\n               Room for \"..\" might be needed the next time through\n               the outer loop.  */\n            size_t name_alloc = _D_ALLOC_NAMLEN (d);\n            size_t filesize = dotlen + MAX (sizeof \"..\", name_alloc);\n\n            if (filesize < dotlen)\n              goto memory_exhausted;\n\n            if (dotsize < filesize)\n              {\n                /* My, what a deep directory tree you have, Grandma.  */\n                size_t newsize = MAX (filesize, dotsize * 2);\n                size_t i;\n                if (newsize < dotsize)\n                  goto memory_exhausted;\n                if (dotlist != dots)\n                  free (dotlist);\n                dotlist = malloc (newsize);\n                if (dotlist == NULL)\n                  goto lose;\n                dotsize = newsize;\n\n                i = 0;\n                do\n                  {\n                    dotlist[i++] = '.';\n                    dotlist[i++] = '.';\n                    dotlist[i++] = '/';\n                  }\n                while (i < dotlen);\n              }\n\n            memcpy (dotlist + dotlen, d->d_name, _D_ALLOC_NAMLEN (d));\n            entry_status = __lstat (dotlist, &st);\n#endif\n            /* We don't fail here if we cannot stat() a directory entry.\n               This can happen when (network) file systems fail.  If this\n               entry is in fact the one we are looking for we will find\n               out soon as we reach the end of the directory without\n               having found anything.  */\n            if (entry_status == 0 && S_ISDIR (st.st_mode)\n                && st.st_dev == thisdev && st.st_ino == thisino)\n              break;\n          }\n        }\n\n      dirroom = dirp - dir;\n      namlen = _D_EXACT_NAMLEN (d);\n\n      if (dirroom <= namlen)\n        {\n          if (size != 0)\n            {\n              __set_errno (ERANGE);\n              goto lose;\n            }\n          else\n            {\n              char *tmp;\n              size_t oldsize = allocated;\n\n              allocated += MAX (allocated, namlen);\n              if (allocated < oldsize\n                  || ! (tmp = realloc (dir, allocated)))\n                goto memory_exhausted;\n\n              /* Move current contents up to the end of the buffer.\n                 This is guaranteed to be non-overlapping.  */\n              dirp = memcpy (tmp + allocated - (oldsize - dirroom),\n                             tmp + dirroom,\n                             oldsize - dirroom);\n              dir = tmp;\n            }\n        }\n      dirp -= namlen;\n      memcpy (dirp, d->d_name, namlen);\n      *--dirp = '/';\n\n      thisdev = dotdev;\n      thisino = dotino;\n    }\n\n  if (dirstream && __closedir (dirstream) != 0)\n    {\n      dirstream = NULL;\n      goto lose;\n    }\n\n  if (dirp == &dir[allocated - 1])\n    *--dirp = '/';\n\n#if ! HAVE_OPENAT_SUPPORT\n  if (dotlist != dots)\n    free (dotlist);\n#endif\n\n  used = dir + allocated - dirp;\n  memmove (dir, dirp, used);\n\n  if (size == 0)\n    /* Ensure that the buffer is only as large as necessary.  */\n    buf = realloc (dir, used);\n\n  if (buf == NULL)\n    /* Either buf was NULL all along, or 'realloc' failed but\n       we still have the original string.  */\n    buf = dir;\n\n  return buf;\n\n memory_exhausted:\n  __set_errno (ENOMEM);\n lose:\n  {\n    int save = errno;\n    if (dirstream)\n      __closedir (dirstream);\n#if HAVE_OPENAT_SUPPORT\n    if (fd_needs_closing)\n      close (fd);\n#else\n    if (dotlist != dots)\n      free (dotlist);\n#endif\n    if (buf == NULL)\n      free (dir);\n    __set_errno (save);\n  }\n  return NULL;\n}",
      "lines": 334,
      "depth": 18,
      "decorators": [
        "char",
        "*\n__getcwd (char *buf, size_t size)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/getdtablesize.c": {
    "_setmaxstdio_nothrow": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        37,
        5
      ],
      "content": "static int\n_setmaxstdio_nothrow (int newmax)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _setmaxstdio (newmax);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "getdtablesize": [
      {
        "start_point": [
          53,
          0
        ],
        "end_point": [
          84,
          1
        ],
        "content": "int\ngetdtablesize (void)\n{\n  if (dtablesize == 0)\n    {\n      /* We are looking for the number N such that the valid file descriptors\n         are 0..N-1.  It can be obtained through a loop as follows:\n           {\n             int fd;\n             for (fd = 3; fd < 65536; fd++)\n               if (dup2 (0, fd) == -1)\n                 break;\n             return fd;\n           }\n         On Windows XP, the result is 2048.\n         The drawback of this loop is that it allocates memory for a libc\n         internal array that is never freed.\n\n         The number N can also be obtained as the upper bound for\n         _getmaxstdio ().  _getmaxstdio () returns the maximum number of open\n         FILE objects.  The sanity check in _setmaxstdio reveals the maximum\n         number of file descriptors.  This too allocates memory, but it is\n         freed when we call _setmaxstdio with the original value.  */\n      int orig_max_stdio = _getmaxstdio ();\n      unsigned int bound;\n      for (bound = 0x10000; _setmaxstdio (bound) < 0; bound = bound / 2)\n        ;\n      _setmaxstdio (orig_max_stdio);\n      dtablesize = bound;\n    }\n  return dtablesize;\n}",
        "lines": 32,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          105,
          0
        ],
        "end_point": [
          118,
          1
        ],
        "content": "int\ngetdtablesize (void)\n{\n  struct rlimit lim;\n\n  if (getrlimit (RLIMIT_NOFILE, &lim) == 0\n      && 0 <= lim.rlim_cur && lim.rlim_cur <= INT_MAX\n      && lim.rlim_cur != RLIM_INFINITY\n      && lim.rlim_cur != RLIM_SAVED_CUR\n      && lim.rlim_cur != RLIM_SAVED_MAX)\n    return lim.rlim_cur;\n\n  return INT_MAX;\n}",
        "lines": 14,
        "depth": 14,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "sharutils/sharutils-4.15.2/lib/gethostname.c": {
    "gethostname": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "int\ngethostname (char *name, size_t len)\n{\n#ifdef HAVE_UNAME\n  struct utsname uts;\n\n  if (uname (&uts) == -1)\n    return -1;\n  if (len > sizeof (uts.nodename))\n    {\n      /* More space than we need is available.  */\n      name[sizeof (uts.nodename)] = '\\0';\n      len = sizeof (uts.nodename);\n    }\n  strncpy (name, uts.nodename, len);\n#else\n  strcpy (name, \"\");            /* Hardcode your system name if you want.  */\n#endif\n  return 0;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "rpl_gethostname": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "int\nrpl_gethostname (char *name, size_t len)\n{\n  int r;\n\n  if (len > INT_MAX)\n    len = INT_MAX;\n  gl_sockets_startup (SOCKETS_1_1);\n  r = gethostname (name, (int) len);\n  if (r < 0)\n    set_winsock_errno ();\n\n  return r;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/getopt.c": {
    "exchange": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "static void\nexchange (char **argv, struct _getopt_data *d)\n{\n  int bottom = d->__first_nonopt;\n  int middle = d->__last_nonopt;\n  int top = d->optind;\n  char *tem;\n\n  /* Exchange the shorter segment with the far end of the longer segment.\n     That puts the shorter segment into the right place.\n     It leaves the longer segment in the right place overall,\n     but it consists of two parts that need to be swapped next.  */\n\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n  /* First make sure the handling of the '__getopt_nonoption_flags'\n     string can work normally.  Our top argument must be in the range\n     of the string.  */\n  if (d->__nonoption_flags_len > 0 && top >= d->__nonoption_flags_max_len)\n    {\n      /* We must extend the array.  The user plays games with us and\n         presents new arguments.  */\n      char *new_str = malloc (top + 1);\n      if (new_str == NULL)\n        d->__nonoption_flags_len = d->__nonoption_flags_max_len = 0;\n      else\n        {\n          memset (__mempcpy (new_str, __getopt_nonoption_flags,\n                             d->__nonoption_flags_max_len),\n                  '\\0', top + 1 - d->__nonoption_flags_max_len);\n          d->__nonoption_flags_max_len = top + 1;\n          __getopt_nonoption_flags = new_str;\n        }\n    }\n#endif\n\n  while (top > middle && middle > bottom)\n    {\n      if (top - middle > middle - bottom)\n        {\n          /* Bottom segment is the short one.  */\n          int len = middle - bottom;\n          register int i;\n\n          /* Swap it with the top part of the top segment.  */\n          for (i = 0; i < len; i++)\n            {\n              tem = argv[bottom + i];\n              argv[bottom + i] = argv[top - (middle - bottom) + i];\n              argv[top - (middle - bottom) + i] = tem;\n              SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);\n            }\n          /* Exclude the moved bottom segment from further swapping.  */\n          top -= len;\n        }\n      else\n        {\n          /* Top segment is the short one.  */\n          int len = top - middle;\n          register int i;\n\n          /* Swap it with the bottom part of the bottom segment.  */\n          for (i = 0; i < len; i++)\n            {\n              tem = argv[bottom + i];\n              argv[bottom + i] = argv[middle + i];\n              argv[middle + i] = tem;\n              SWAP_FLAGS (bottom + i, middle + i);\n            }\n          /* Exclude the moved top segment from further swapping.  */\n          bottom += len;\n        }\n    }\n\n  /* Update records for the slots the non-options now occupy.  */\n\n  d->__first_nonopt += (d->optind - d->__last_nonopt);\n  d->__last_nonopt = d->optind;\n}",
      "lines": 78,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_getopt_initialize": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "static const char *\n_getopt_initialize (int argc _GL_UNUSED,\n                    char **argv _GL_UNUSED, const char *optstring,\n                    struct _getopt_data *d, int posixly_correct)\n{\n  /* Start processing options with ARGV-element 1 (since ARGV-element 0\n     is the program name); the sequence of previously skipped\n     non-option ARGV-elements is empty.  */\n\n  d->__first_nonopt = d->__last_nonopt = d->optind;\n\n  d->__nextchar = NULL;\n\n  d->__posixly_correct = posixly_correct || !!getenv (\"POSIXLY_CORRECT\");\n\n  /* Determine how to handle the ordering of options and nonoptions.  */\n\n  if (optstring[0] == '-')\n    {\n      d->__ordering = RETURN_IN_ORDER;\n      ++optstring;\n    }\n  else if (optstring[0] == '+')\n    {\n      d->__ordering = REQUIRE_ORDER;\n      ++optstring;\n    }\n  else if (d->__posixly_correct)\n    d->__ordering = REQUIRE_ORDER;\n  else\n    d->__ordering = PERMUTE;\n\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n  if (!d->__posixly_correct\n      && argc == __libc_argc && argv == __libc_argv)\n    {\n      if (d->__nonoption_flags_max_len == 0)\n        {\n          if (__getopt_nonoption_flags == NULL\n              || __getopt_nonoption_flags[0] == '\\0')\n            d->__nonoption_flags_max_len = -1;\n          else\n            {\n              const char *orig_str = __getopt_nonoption_flags;\n              int len = d->__nonoption_flags_max_len = strlen (orig_str);\n              if (d->__nonoption_flags_max_len < argc)\n                d->__nonoption_flags_max_len = argc;\n              __getopt_nonoption_flags =\n                (char *) malloc (d->__nonoption_flags_max_len);\n              if (__getopt_nonoption_flags == NULL)\n                d->__nonoption_flags_max_len = -1;\n              else\n                memset (__mempcpy (__getopt_nonoption_flags, orig_str, len),\n                        '\\0', d->__nonoption_flags_max_len - len);\n            }\n        }\n      d->__nonoption_flags_len = d->__nonoption_flags_max_len;\n    }\n  else\n    d->__nonoption_flags_len = 0;\n#endif\n\n  return optstring;\n}",
      "lines": 64,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\n_getopt_initialize (int argc _GL_UNUSED,\n                    char **argv _GL_UNUSED, const char *optstring,\n                    struct _getopt_data *d, int posixly_correct)",
        "*"
      ]
    },
    "_getopt_internal_r": {
      "start_point": [
        344,
        0
      ],
      "end_point": [
        1154,
        1
      ],
      "content": "int\n_getopt_internal_r (int argc, char **argv, const char *optstring,\n                    const struct option *longopts, int *longind,\n                    int long_only, struct _getopt_data *d, int posixly_correct)\n{\n  int print_errors = d->opterr;\n\n  if (argc < 1)\n    return -1;\n\n  d->optarg = NULL;\n\n  if (d->optind == 0 || !d->__initialized)\n    {\n      if (d->optind == 0)\n        d->optind = 1;  /* Don't scan ARGV[0], the program name.  */\n      optstring = _getopt_initialize (argc, argv, optstring, d,\n                                      posixly_correct);\n      d->__initialized = 1;\n    }\n  else if (optstring[0] == '-' || optstring[0] == '+')\n    optstring++;\n  if (optstring[0] == ':')\n    print_errors = 0;\n\n  /* Test whether ARGV[optind] points to a non-option argument.\n     Either it does not have option syntax, or there is an environment flag\n     from the shell indicating it is not an option.  The later information\n     is only used when the used in the GNU libc.  */\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n# define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0' \\\n                      || (d->optind < d->__nonoption_flags_len                \\\n                          && __getopt_nonoption_flags[d->optind] == '1'))\n#else\n# define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0')\n#endif\n\n  if (d->__nextchar == NULL || *d->__nextchar == '\\0')\n    {\n      /* Advance to the next ARGV-element.  */\n\n      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been\n         moved back by the user (who may also have changed the arguments).  */\n      if (d->__last_nonopt > d->optind)\n        d->__last_nonopt = d->optind;\n      if (d->__first_nonopt > d->optind)\n        d->__first_nonopt = d->optind;\n\n      if (d->__ordering == PERMUTE)\n        {\n          /* If we have just processed some options following some non-options,\n             exchange them so that the options come first.  */\n\n          if (d->__first_nonopt != d->__last_nonopt\n              && d->__last_nonopt != d->optind)\n            exchange ((char **) argv, d);\n          else if (d->__last_nonopt != d->optind)\n            d->__first_nonopt = d->optind;\n\n          /* Skip any additional non-options\n             and extend the range of non-options previously skipped.  */\n\n          while (d->optind < argc && NONOPTION_P)\n            d->optind++;\n          d->__last_nonopt = d->optind;\n        }\n\n      /* The special ARGV-element '--' means premature end of options.\n         Skip it like a null option,\n         then exchange with previous non-options as if it were an option,\n         then skip everything else like a non-option.  */\n\n      if (d->optind != argc && !strcmp (argv[d->optind], \"--\"))\n        {\n          d->optind++;\n\n          if (d->__first_nonopt != d->__last_nonopt\n              && d->__last_nonopt != d->optind)\n            exchange ((char **) argv, d);\n          else if (d->__first_nonopt == d->__last_nonopt)\n            d->__first_nonopt = d->optind;\n          d->__last_nonopt = argc;\n\n          d->optind = argc;\n        }\n\n      /* If we have done all the ARGV-elements, stop the scan\n         and back over any non-options that we skipped and permuted.  */\n\n      if (d->optind == argc)\n        {\n          /* Set the next-arg-index to point at the non-options\n             that we previously skipped, so the caller will digest them.  */\n          if (d->__first_nonopt != d->__last_nonopt)\n            d->optind = d->__first_nonopt;\n          return -1;\n        }\n\n      /* If we have come to a non-option and did not permute it,\n         either stop the scan or describe it to the caller and pass it by.  */\n\n      if (NONOPTION_P)\n        {\n          if (d->__ordering == REQUIRE_ORDER)\n            return -1;\n          d->optarg = argv[d->optind++];\n          return 1;\n        }\n\n      /* We have found another option-ARGV-element.\n         Skip the initial punctuation.  */\n\n      d->__nextchar = (argv[d->optind] + 1\n                  + (longopts != NULL && argv[d->optind][1] == '-'));\n    }\n\n  /* Decode the current option-ARGV-element.  */\n\n  /* Check whether the ARGV-element is a long option.\n\n     If long_only and the ARGV-element has the form \"-f\", where f is\n     a valid short option, don't consider it an abbreviated form of\n     a long option that starts with f.  Otherwise there would be no\n     way to give the -f short option.\n\n     On the other hand, if there's a long option \"fubar\" and\n     the ARGV-element is \"-fu\", do consider that an abbreviation of\n     the long option, just like \"--fu\", and not \"-f\" with arg \"u\".\n\n     This distinction seems to be the most useful approach.  */\n\n  if (longopts != NULL\n      && (argv[d->optind][1] == '-'\n          || (long_only && (argv[d->optind][2]\n                            || !strchr (optstring, argv[d->optind][1])))))\n    {\n      char *nameend;\n      unsigned int namelen;\n      const struct option *p;\n      const struct option *pfound = NULL;\n      struct option_list\n      {\n        const struct option *p;\n        struct option_list *next;\n      } *ambig_list = NULL;\n#ifdef _LIBC\n/* malloc() not used for _LIBC to simplify failure messages.  */\n# define free_option_list(l)\n#else\n# define free_option_list(l)\t\t\t\\\n      while (l != NULL)\t\t\t\t\\\n        {\t\t\t\t\t\\\n          struct option_list *pn = l->next;\t\\\n          free (l);\t\t\t\t\\\n          l = pn;\t\t\t\t\\\n        }\n#endif\n      int exact = 0;\n      int ambig = 0;\n      int indfound = -1;\n      int option_index;\n\n      for (nameend = d->__nextchar; *nameend && *nameend != '='; nameend++)\n        /* Do nothing.  */ ;\n      namelen = nameend - d->__nextchar;\n\n      /* Test all long options for either exact match\n         or abbreviated matches.  */\n      for (p = longopts, option_index = 0; p->name; p++, option_index++)\n        if (!strncmp (p->name, d->__nextchar, namelen))\n          {\n            if (namelen == (unsigned int) strlen (p->name))\n              {\n                /* Exact match found.  */\n                pfound = p;\n                indfound = option_index;\n                exact = 1;\n                break;\n              }\n            else if (pfound == NULL)\n              {\n                /* First nonexact match found.  */\n                pfound = p;\n                indfound = option_index;\n              }\n            else if (ambig)\n              ; /* Taking simpler path to handling ambiguities.  */\n            else if (long_only\n                     || pfound->has_arg != p->has_arg\n                     || pfound->flag != p->flag\n                     || pfound->val != p->val)\n              {\n                /* Second or later nonexact match found.  */\n#ifdef _LIBC\n                struct option_list *newp = alloca (sizeof (*newp));\n#else\n                struct option_list *newp = malloc (sizeof (*newp));\n                if (newp == NULL)\n                  {\n                    free_option_list (ambig_list);\n                    ambig_list = NULL;\n                    ambig = 1; /* Use simpler fallback message.  */\n                  }\n                else\n#endif\n                  {\n                    newp->p = p;\n                    newp->next = ambig_list;\n                    ambig_list = newp;\n                  }\n              }\n          }\n\n      if ((ambig || ambig_list) && !exact)\n        {\n          if (print_errors && ambig_list)\n            {\n              struct option_list first;\n              first.p = pfound;\n              first.next = ambig_list;\n              ambig_list = &first;\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf = NULL;\n              size_t buflen = 0;\n\n              FILE *fp = open_memstream (&buf, &buflen);\n              if (fp != NULL)\n                {\n                  fprintf (fp,\n                           _(\"%s: option '%s' is ambiguous; possibilities:\"),\n                           argv[0], argv[d->optind]);\n\n                  do\n                    {\n                      fprintf (fp, \" '--%s'\", ambig_list->p->name);\n                      ambig_list = ambig_list->next;\n                    }\n                  while (ambig_list != NULL);\n\n                  fputc_unlocked ('\\n', fp);\n\n                  if (__builtin_expect (fclose (fp) != EOF, 1))\n                    {\n                      _IO_flockfile (stderr);\n\n                      int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                      ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                      __fxprintf (NULL, \"%s\", buf);\n\n                      ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                      _IO_funlockfile (stderr);\n\n                      free (buf);\n                    }\n                }\n#else\n              fprintf (stderr,\n                       _(\"%s: option '%s' is ambiguous; possibilities:\"),\n                       argv[0], argv[d->optind]);\n              do\n                {\n                  fprintf (stderr, \" '--%s'\", ambig_list->p->name);\n                  ambig_list = ambig_list->next;\n                }\n              while (ambig_list != NULL);\n\n              fputc ('\\n', stderr);\n#endif\n            }\n          else if (print_errors && ambig)\n            {\n              fprintf (stderr,\n                       _(\"%s: option '%s' is ambiguous\\n\"),\n                       argv[0], argv[d->optind]);\n            }\n          d->__nextchar += strlen (d->__nextchar);\n          d->optind++;\n          d->optopt = 0;\n          free_option_list (ambig_list);\n          return '?';\n        }\n\n      free_option_list (ambig_list);\n\n      if (pfound != NULL)\n        {\n          option_index = indfound;\n          d->optind++;\n          if (*nameend)\n            {\n              /* Don't test has_arg with >, because some C compilers don't\n                 allow it to be used on enums.  */\n              if (pfound->has_arg)\n                d->optarg = nameend + 1;\n              else\n                {\n                  if (print_errors)\n                    {\n#if defined _LIBC && defined USE_IN_LIBIO\n                      char *buf;\n                      int n;\n#endif\n\n                      if (argv[d->optind - 1][1] == '-')\n                        {\n                          /* --option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                          n = __asprintf (&buf, _(\"\\\n%s: option '--%s' doesn't allow an argument\\n\"),\n                                          argv[0], pfound->name);\n#else\n                          fprintf (stderr, _(\"\\\n%s: option '--%s' doesn't allow an argument\\n\"),\n                                   argv[0], pfound->name);\n#endif\n                        }\n                      else\n                        {\n                          /* +option or -option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                          n = __asprintf (&buf, _(\"\\\n%s: option '%c%s' doesn't allow an argument\\n\"),\n                                          argv[0], argv[d->optind - 1][0],\n                                          pfound->name);\n#else\n                          fprintf (stderr, _(\"\\\n%s: option '%c%s' doesn't allow an argument\\n\"),\n                                   argv[0], argv[d->optind - 1][0],\n                                   pfound->name);\n#endif\n                        }\n\n#if defined _LIBC && defined USE_IN_LIBIO\n                      if (n >= 0)\n                        {\n                          _IO_flockfile (stderr);\n\n                          int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                          ((_IO_FILE *) stderr)->_flags2\n                            |= _IO_FLAGS2_NOTCANCEL;\n\n                          __fxprintf (NULL, \"%s\", buf);\n\n                          ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                          _IO_funlockfile (stderr);\n\n                          free (buf);\n                        }\n#endif\n                    }\n\n                  d->__nextchar += strlen (d->__nextchar);\n\n                  d->optopt = pfound->val;\n                  return '?';\n                }\n            }\n          else if (pfound->has_arg == 1)\n            {\n              if (d->optind < argc)\n                d->optarg = argv[d->optind++];\n              else\n                {\n                  if (print_errors)\n                    {\n#if defined _LIBC && defined USE_IN_LIBIO\n                      char *buf;\n\n                      if (__asprintf (&buf, _(\"\\\n%s: option '--%s' requires an argument\\n\"),\n                                      argv[0], pfound->name) >= 0)\n                        {\n                          _IO_flockfile (stderr);\n\n                          int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                          ((_IO_FILE *) stderr)->_flags2\n                            |= _IO_FLAGS2_NOTCANCEL;\n\n                          __fxprintf (NULL, \"%s\", buf);\n\n                          ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                          _IO_funlockfile (stderr);\n\n                          free (buf);\n                        }\n#else\n                      fprintf (stderr,\n                               _(\"%s: option '--%s' requires an argument\\n\"),\n                               argv[0], pfound->name);\n#endif\n                    }\n                  d->__nextchar += strlen (d->__nextchar);\n                  d->optopt = pfound->val;\n                  return optstring[0] == ':' ? ':' : '?';\n                }\n            }\n          d->__nextchar += strlen (d->__nextchar);\n          if (longind != NULL)\n            *longind = option_index;\n          if (pfound->flag)\n            {\n              *(pfound->flag) = pfound->val;\n              return 0;\n            }\n          return pfound->val;\n        }\n\n      /* Can't find it as a long option.  If this is not getopt_long_only,\n         or the option starts with '--' or is not a valid short\n         option, then it's an error.\n         Otherwise interpret it as a short option.  */\n      if (!long_only || argv[d->optind][1] == '-'\n          || strchr (optstring, *d->__nextchar) == NULL)\n        {\n          if (print_errors)\n            {\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf;\n              int n;\n#endif\n\n              if (argv[d->optind][1] == '-')\n                {\n                  /* --option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                  n = __asprintf (&buf, _(\"%s: unrecognized option '--%s'\\n\"),\n                                  argv[0], d->__nextchar);\n#else\n                  fprintf (stderr, _(\"%s: unrecognized option '--%s'\\n\"),\n                           argv[0], d->__nextchar);\n#endif\n                }\n              else\n                {\n                  /* +option or -option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                  n = __asprintf (&buf, _(\"%s: unrecognized option '%c%s'\\n\"),\n                                  argv[0], argv[d->optind][0], d->__nextchar);\n#else\n                  fprintf (stderr, _(\"%s: unrecognized option '%c%s'\\n\"),\n                           argv[0], argv[d->optind][0], d->__nextchar);\n#endif\n                }\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              if (n >= 0)\n                {\n                  _IO_flockfile (stderr);\n\n                  int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                  ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                  __fxprintf (NULL, \"%s\", buf);\n\n                  ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                  _IO_funlockfile (stderr);\n\n                  free (buf);\n                }\n#endif\n            }\n          d->__nextchar = (char *) \"\";\n          d->optind++;\n          d->optopt = 0;\n          return '?';\n        }\n    }\n\n  /* Look at and handle the next short option-character.  */\n\n  {\n    char c = *d->__nextchar++;\n    const char *temp = strchr (optstring, c);\n\n    /* Increment 'optind' when we start to process its last character.  */\n    if (*d->__nextchar == '\\0')\n      ++d->optind;\n\n    if (temp == NULL || c == ':' || c == ';')\n      {\n        if (print_errors)\n          {\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf;\n              int n;\n#endif\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              n = __asprintf (&buf, _(\"%s: invalid option -- '%c'\\n\"),\n                              argv[0], c);\n#else\n              fprintf (stderr, _(\"%s: invalid option -- '%c'\\n\"), argv[0], c);\n#endif\n\n#if defined _LIBC && defined USE_IN_LIBIO\n            if (n >= 0)\n              {\n                _IO_flockfile (stderr);\n\n                int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                __fxprintf (NULL, \"%s\", buf);\n\n                ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                _IO_funlockfile (stderr);\n\n                free (buf);\n              }\n#endif\n          }\n        d->optopt = c;\n        return '?';\n      }\n    /* Convenience. Treat POSIX -W foo same as long option --foo */\n    if (temp[0] == 'W' && temp[1] == ';')\n      {\n        char *nameend;\n        const struct option *p;\n        const struct option *pfound = NULL;\n        int exact = 0;\n        int ambig = 0;\n        int indfound = 0;\n        int option_index;\n\n        if (longopts == NULL)\n          goto no_longs;\n\n        /* This is an option that requires an argument.  */\n        if (*d->__nextchar != '\\0')\n          {\n            d->optarg = d->__nextchar;\n            /* If we end this ARGV-element by taking the rest as an arg,\n               we must advance to the next element now.  */\n            d->optind++;\n          }\n        else if (d->optind == argc)\n          {\n            if (print_errors)\n              {\n#if defined _LIBC && defined USE_IN_LIBIO\n                char *buf;\n\n                if (__asprintf (&buf,\n                                _(\"%s: option requires an argument -- '%c'\\n\"),\n                                argv[0], c) >= 0)\n                  {\n                    _IO_flockfile (stderr);\n\n                    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                    __fxprintf (NULL, \"%s\", buf);\n\n                    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                    _IO_funlockfile (stderr);\n\n                    free (buf);\n                  }\n#else\n                fprintf (stderr,\n                         _(\"%s: option requires an argument -- '%c'\\n\"),\n                         argv[0], c);\n#endif\n              }\n            d->optopt = c;\n            if (optstring[0] == ':')\n              c = ':';\n            else\n              c = '?';\n            return c;\n          }\n        else\n          /* We already incremented 'd->optind' once;\n             increment it again when taking next ARGV-elt as argument.  */\n          d->optarg = argv[d->optind++];\n\n        /* optarg is now the argument, see if it's in the\n           table of longopts.  */\n\n        for (d->__nextchar = nameend = d->optarg; *nameend && *nameend != '=';\n             nameend++)\n          /* Do nothing.  */ ;\n\n        /* Test all long options for either exact match\n           or abbreviated matches.  */\n        for (p = longopts, option_index = 0; p->name; p++, option_index++)\n          if (!strncmp (p->name, d->__nextchar, nameend - d->__nextchar))\n            {\n              if ((unsigned int) (nameend - d->__nextchar) == strlen (p->name))\n                {\n                  /* Exact match found.  */\n                  pfound = p;\n                  indfound = option_index;\n                  exact = 1;\n                  break;\n                }\n              else if (pfound == NULL)\n                {\n                  /* First nonexact match found.  */\n                  pfound = p;\n                  indfound = option_index;\n                }\n              else if (long_only\n                       || pfound->has_arg != p->has_arg\n                       || pfound->flag != p->flag\n                       || pfound->val != p->val)\n                /* Second or later nonexact match found.  */\n                ambig = 1;\n            }\n        if (ambig && !exact)\n          {\n            if (print_errors)\n              {\n#if defined _LIBC && defined USE_IN_LIBIO\n                char *buf;\n\n                if (__asprintf (&buf, _(\"%s: option '-W %s' is ambiguous\\n\"),\n                                argv[0], d->optarg) >= 0)\n                  {\n                    _IO_flockfile (stderr);\n\n                    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                    __fxprintf (NULL, \"%s\", buf);\n\n                    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                    _IO_funlockfile (stderr);\n\n                    free (buf);\n                  }\n#else\n                fprintf (stderr, _(\"%s: option '-W %s' is ambiguous\\n\"),\n                         argv[0], d->optarg);\n#endif\n              }\n            d->__nextchar += strlen (d->__nextchar);\n            d->optind++;\n            return '?';\n          }\n        if (pfound != NULL)\n          {\n            option_index = indfound;\n            if (*nameend)\n              {\n                /* Don't test has_arg with >, because some C compilers don't\n                   allow it to be used on enums.  */\n                if (pfound->has_arg)\n                  d->optarg = nameend + 1;\n                else\n                  {\n                    if (print_errors)\n                      {\n#if defined _LIBC && defined USE_IN_LIBIO\n                        char *buf;\n\n                        if (__asprintf (&buf, _(\"\\\n%s: option '-W %s' doesn't allow an argument\\n\"),\n                                        argv[0], pfound->name) >= 0)\n                          {\n                            _IO_flockfile (stderr);\n\n                            int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                            ((_IO_FILE *) stderr)->_flags2\n                              |= _IO_FLAGS2_NOTCANCEL;\n\n                            __fxprintf (NULL, \"%s\", buf);\n\n                            ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                            _IO_funlockfile (stderr);\n\n                            free (buf);\n                          }\n#else\n                        fprintf (stderr, _(\"\\\n%s: option '-W %s' doesn't allow an argument\\n\"),\n                                 argv[0], pfound->name);\n#endif\n                      }\n\n                    d->__nextchar += strlen (d->__nextchar);\n                    return '?';\n                  }\n              }\n            else if (pfound->has_arg == 1)\n              {\n                if (d->optind < argc)\n                  d->optarg = argv[d->optind++];\n                else\n                  {\n                    if (print_errors)\n                      {\n#if defined _LIBC && defined USE_IN_LIBIO\n                        char *buf;\n\n                        if (__asprintf (&buf, _(\"\\\n%s: option '-W %s' requires an argument\\n\"),\n                                        argv[0], pfound->name) >= 0)\n                          {\n                            _IO_flockfile (stderr);\n\n                            int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                            ((_IO_FILE *) stderr)->_flags2\n                              |= _IO_FLAGS2_NOTCANCEL;\n\n                            __fxprintf (NULL, \"%s\", buf);\n\n                            ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                            _IO_funlockfile (stderr);\n\n                            free (buf);\n                          }\n#else\n                        fprintf (stderr, _(\"\\\n%s: option '-W %s' requires an argument\\n\"),\n                                 argv[0], pfound->name);\n#endif\n                      }\n                    d->__nextchar += strlen (d->__nextchar);\n                    return optstring[0] == ':' ? ':' : '?';\n                  }\n              }\n            else\n              d->optarg = NULL;\n            d->__nextchar += strlen (d->__nextchar);\n            if (longind != NULL)\n              *longind = option_index;\n            if (pfound->flag)\n              {\n                *(pfound->flag) = pfound->val;\n                return 0;\n              }\n            return pfound->val;\n          }\n\n      no_longs:\n        d->__nextchar = NULL;\n        return 'W';   /* Let the application handle it.   */\n      }\n    if (temp[1] == ':')\n      {\n        if (temp[2] == ':')\n          {\n            /* This is an option that accepts an argument optionally.  */\n            if (*d->__nextchar != '\\0')\n              {\n                d->optarg = d->__nextchar;\n                d->optind++;\n              }\n            else\n              d->optarg = NULL;\n            d->__nextchar = NULL;\n          }\n        else\n          {\n            /* This is an option that requires an argument.  */\n            if (*d->__nextchar != '\\0')\n              {\n                d->optarg = d->__nextchar;\n                /* If we end this ARGV-element by taking the rest as an arg,\n                   we must advance to the next element now.  */\n                d->optind++;\n              }\n            else if (d->optind == argc)\n              {\n                if (print_errors)\n                  {\n#if defined _LIBC && defined USE_IN_LIBIO\n                    char *buf;\n\n                    if (__asprintf (&buf, _(\"\\\n%s: option requires an argument -- '%c'\\n\"),\n                                    argv[0], c) >= 0)\n                      {\n                        _IO_flockfile (stderr);\n\n                        int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                        ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                        __fxprintf (NULL, \"%s\", buf);\n\n                        ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                        _IO_funlockfile (stderr);\n\n                        free (buf);\n                      }\n#else\n                    fprintf (stderr,\n                             _(\"%s: option requires an argument -- '%c'\\n\"),\n                             argv[0], c);\n#endif\n                  }\n                d->optopt = c;\n                if (optstring[0] == ':')\n                  c = ':';\n                else\n                  c = '?';\n              }\n            else\n              /* We already incremented 'optind' once;\n                 increment it again when taking next ARGV-elt as argument.  */\n              d->optarg = argv[d->optind++];\n            d->__nextchar = NULL;\n          }\n      }\n    return c;\n  }\n}",
      "lines": 811,
      "depth": 25,
      "decorators": [
        "int"
      ]
    },
    "_getopt_internal": {
      "start_point": [
        1156,
        0
      ],
      "end_point": [
        1175,
        1
      ],
      "content": "int\n_getopt_internal (int argc, char **argv, const char *optstring,\n                  const struct option *longopts, int *longind, int long_only,\n                  int posixly_correct)\n{\n  int result;\n\n  getopt_data.optind = optind;\n  getopt_data.opterr = opterr;\n\n  result = _getopt_internal_r (argc, argv, optstring, longopts,\n                               longind, long_only, &getopt_data,\n                               posixly_correct);\n\n  optind = getopt_data.optind;\n  optarg = getopt_data.optarg;\n  optopt = getopt_data.optopt;\n\n  return result;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "getopt": {
      "start_point": [
        1185,
        0
      ],
      "end_point": [
        1192,
        1
      ],
      "content": "int\ngetopt (int argc, char *const *argv, const char *optstring)\n{\n  return _getopt_internal (argc, (char **) argv, optstring,\n                           (const struct option *) 0,\n                           (int *) 0,\n                           0, POSIXLY_CORRECT);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "__posix_getopt": {
      "start_point": [
        1195,
        0
      ],
      "end_point": [
        1202,
        1
      ],
      "content": "int\n__posix_getopt (int argc, char *const *argv, const char *optstring)\n{\n  return _getopt_internal (argc, argv, optstring,\n                           (const struct option *) 0,\n                           (int *) 0,\n                           0, 1);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        1211,
        0
      ],
      "end_point": [
        1272,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n\n      c = getopt (argc, argv, \"abc:d:0123456789\");\n      if (c == -1)\n        break;\n\n      switch (c)\n        {\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (digit_optind != 0 && digit_optind != this_option_optind)\n            printf (\"digits occur in two different argv-elements.\\n\");\n          digit_optind = this_option_optind;\n          printf (\"option %c\\n\", c);\n          break;\n\n        case 'a':\n          printf (\"option a\\n\");\n          break;\n\n        case 'b':\n          printf (\"option b\\n\");\n          break;\n\n        case 'c':\n          printf (\"option c with value '%s'\\n\", optarg);\n          break;\n\n        case '?':\n          break;\n\n        default:\n          printf (\"?? getopt returned character code 0%o ??\\n\", c);\n        }\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n        printf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/getopt.in.h": {},
  "sharutils/sharutils-4.15.2/lib/getopt1.c": {
    "getopt_long": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "int\ngetopt_long (int argc, char *__getopt_argv_const *argv, const char *options,\n             const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n                           opt_index, 0, 0);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_r": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\n_getopt_long_r (int argc, char **argv, const char *options,\n                const struct option *long_options, int *opt_index,\n                struct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n                             0, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "getopt_long_only": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\ngetopt_long_only (int argc, char *__getopt_argv_const *argv,\n                  const char *options,\n                  const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n                           opt_index, 1, 0);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_only_r": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "int\n_getopt_long_only_r (int argc, char **argv, const char *options,\n                     const struct option *long_options, int *opt_index,\n                     struct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n                             1, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n      int option_index = 0;\n      static const struct option long_options[] =\n      {\n        {\"add\", 1, 0, 0},\n        {\"append\", 0, 0, 0},\n        {\"delete\", 1, 0, 0},\n        {\"verbose\", 0, 0, 0},\n        {\"create\", 0, 0, 0},\n        {\"file\", 1, 0, 0},\n        {0, 0, 0, 0}\n      };\n\n      c = getopt_long (argc, argv, \"abc:d:0123456789\",\n                       long_options, &option_index);\n      if (c == -1)\n        break;\n\n      switch (c)\n        {\n        case 0:\n          printf (\"option %s\", long_options[option_index].name);\n          if (optarg)\n            printf (\" with arg %s\", optarg);\n          printf (\"\\n\");\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (digit_optind != 0 && digit_optind != this_option_optind)\n            printf (\"digits occur in two different argv-elements.\\n\");\n          digit_optind = this_option_optind;\n          printf (\"option %c\\n\", c);\n          break;\n\n        case 'a':\n          printf (\"option a\\n\");\n          break;\n\n        case 'b':\n          printf (\"option b\\n\");\n          break;\n\n        case 'c':\n          printf (\"option c with value '%s'\\n\", optarg);\n          break;\n\n        case 'd':\n          printf (\"option d with value '%s'\\n\", optarg);\n          break;\n\n        case '?':\n          break;\n\n        default:\n          printf (\"?? getopt returned character code 0%o ??\\n\", c);\n        }\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n        printf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 85,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/getopt_int.h": {},
  "sharutils/sharutils-4.15.2/lib/gettext.h": {
    "pgettext_aux": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static const char *\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)\n{\n  const char *translation = dcgettext (domain, msg_ctxt_id, category);\n  if (translation == msg_ctxt_id)\n    return msgid;\n  else\n    return translation;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)",
        "*"
      ]
    },
    "npgettext_aux": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "static const char *\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)\n{\n  const char *translation =\n    dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n  if (translation == msg_ctxt_id || translation == msgid_plural)\n    return (n == 1 ? msgid : msgid_plural);\n  else\n    return translation;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)",
        "*"
      ]
    },
    "dcpgettext_expr": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "static const char *\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcgettext (domain, msg_ctxt_id, category);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (translation != msg_ctxt_id)\n        return translation;\n    }\n  return msgid;\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)",
        "*"
      ]
    },
    "dcnpgettext_expr": {
      "start_point": [
        253,
        0
      ],
      "end_point": [
        285,
        1
      ],
      "content": "static const char *\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (!(translation == msg_ctxt_id || translation == msgid_plural))\n        return translation;\n    }\n  return (n == 1 ? msgid : msgid_plural);\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/gettimeofday.c": {
    "rpl_localtime": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "struct tm *\nrpl_localtime (time_t const *timep)\n{\n  struct tm *tm = localtime (timep);\n\n  if (localtime_buffer_addr == &tm_zero_buffer)\n    localtime_buffer_addr = tm;\n\n  return tm;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nrpl_localtime (time_t const *timep)",
        "*"
      ]
    },
    "rpl_gmtime": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "struct tm *\nrpl_gmtime (time_t const *timep)\n{\n  struct tm *tm = gmtime (timep);\n\n  if (localtime_buffer_addr == &tm_zero_buffer)\n    localtime_buffer_addr = tm;\n\n  return tm;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nrpl_gmtime (time_t const *timep)",
        "*"
      ]
    },
    "rpl_tzset": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "void\nrpl_tzset (void)\n{\n  /* Save and restore the contents of the buffer used for localtime's\n     result around the call to tzset.  */\n  struct tm save = *localtime_buffer_addr;\n  tzset ();\n  *localtime_buffer_addr = save;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gettimeofday": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "int\ngettimeofday (struct timeval *restrict tv, void *restrict tz)\n{\n#undef gettimeofday\n#if HAVE_GETTIMEOFDAY\n# if GETTIMEOFDAY_CLOBBERS_LOCALTIME\n  /* Save and restore the contents of the buffer used for localtime's\n     result around the call to gettimeofday.  */\n  struct tm save = *localtime_buffer_addr;\n# endif\n\n# if defined timeval /* 'struct timeval' overridden by gnulib?  */\n#  undef timeval\n  struct timeval otv;\n  int result = gettimeofday (&otv, (struct timezone *) tz);\n  if (result == 0)\n    {\n      tv->tv_sec = otv.tv_sec;\n      tv->tv_usec = otv.tv_usec;\n    }\n# else\n  int result = gettimeofday (tv, (struct timezone *) tz);\n# endif\n\n# if GETTIMEOFDAY_CLOBBERS_LOCALTIME\n  *localtime_buffer_addr = save;\n# endif\n\n  return result;\n\n#else\n\n# if HAVE__FTIME\n\n  struct _timeb timebuf;\n  _ftime (&timebuf);\n  tv->tv_sec = timebuf.time;\n  tv->tv_usec = timebuf.millitm * 1000;\n\n# else\n\n#  if !defined OK_TO_USE_1S_CLOCK\n#   error \"Only 1-second nominal clock resolution found.  Is that intended?\" \\\n          \"If so, compile with the -DOK_TO_USE_1S_CLOCK option.\"\n#  endif\n  tv->tv_sec = time (NULL);\n  tv->tv_usec = 0;\n\n# endif\n\n  return 0;\n\n#endif\n}",
      "lines": 54,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/gl_openssl.h": {
    "GL_CRYPTO_FN": [
      {
        "start_point": [
          76,
          0
        ],
        "end_point": [
          78,
          48
        ],
        "content": "GL_OPENSSL_INLINE void\nGL_CRYPTO_FN (_init_ctx) (struct _gl_ctx *ctx)\n{ (void) OPENSSL_FN (_Init) ((_gl_CTX *) ctx); }",
        "lines": 3,
        "depth": 10,
        "decorators": [
          "GL_OPENSSL_INLINE",
          "void",
          "void"
        ]
      },
      {
        "start_point": [
          82,
          0
        ],
        "end_point": [
          84,
          53
        ],
        "content": "GL_OPENSSL_INLINE void\nGL_CRYPTO_FN (_process_bytes) (const void *buf, size_t len, struct _gl_ctx *ctx)\n{ OPENSSL_FN (_Update) ((_gl_CTX *) ctx, buf, len); }",
        "lines": 3,
        "depth": 9,
        "decorators": [
          "GL_OPENSSL_INLINE",
          "void",
          "void"
        ]
      },
      {
        "start_point": [
          86,
          0
        ],
        "end_point": [
          88,
          50
        ],
        "content": "GL_OPENSSL_INLINE void\nGL_CRYPTO_FN (_process_block) (const void *buf, size_t len, struct _gl_ctx *ctx)\n{ GL_CRYPTO_FN (_process_bytes) (buf, len, ctx); }",
        "lines": 3,
        "depth": 7,
        "decorators": [
          "GL_OPENSSL_INLINE",
          "void",
          "void"
        ]
      },
      {
        "start_point": [
          91,
          0
        ],
        "end_point": [
          93,
          77
        ],
        "content": "GL_OPENSSL_INLINE void *\nGL_CRYPTO_FN (_finish_ctx) (struct _gl_ctx *ctx, void *res)\n{ OPENSSL_FN (_Final) ((unsigned char *) res, (_gl_CTX *) ctx); return res; }",
        "lines": 3,
        "depth": 9,
        "decorators": [
          "GL_OPENSSL_INLINE",
          "void",
          "void",
          "*\nGL_CRYPTO_FN (_finish_ctx) (struct _gl_ctx *ctx, void *res)",
          "*"
        ]
      },
      {
        "start_point": [
          95,
          0
        ],
        "end_point": [
          97,
          83
        ],
        "content": "GL_OPENSSL_INLINE void *\nGL_CRYPTO_FN (_buffer) (const char *buf, size_t len, void *res)\n{ return OPENSSL_FN () ((const unsigned char *) buf, len, (unsigned char *) res); }",
        "lines": 3,
        "depth": 9,
        "decorators": [
          "GL_OPENSSL_INLINE",
          "void",
          "void",
          "*\nGL_CRYPTO_FN (_buffer) (const char *buf, size_t len, void *res)",
          "*"
        ]
      },
      {
        "start_point": [
          99,
          0
        ],
        "end_point": [
          106,
          1
        ],
        "content": "GL_OPENSSL_INLINE void *\nGL_CRYPTO_FN (_read_ctx) (const struct _gl_ctx *ctx, void *res)\n{\n  /* Assume any unprocessed bytes in ctx are not to be ignored.  */\n  _gl_CTX tmp_ctx = *(_gl_CTX *) ctx;\n  OPENSSL_FN (_Final) ((unsigned char *) res, &tmp_ctx);\n  return res;\n}",
        "lines": 8,
        "depth": 9,
        "decorators": [
          "GL_OPENSSL_INLINE",
          "void",
          "void",
          "*\nGL_CRYPTO_FN (_read_ctx) (const struct _gl_ctx *ctx, void *res)",
          "*"
        ]
      }
    ]
  },
  "sharutils/sharutils-4.15.2/lib/idcache.c": {
    "getuser": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "char *\ngetuser (uid_t uid)\n{\n  struct userid *tail;\n  struct userid *match = NULL;\n\n  for (tail = user_alist; tail; tail = tail->next)\n    {\n      if (tail->id.u == uid)\n        {\n          match = tail;\n          break;\n        }\n    }\n\n  if (match == NULL)\n    {\n      struct passwd *pwent = getpwuid (uid);\n      char const *name = pwent ? pwent->pw_name : \"\";\n      match = xmalloc (offsetof (struct userid, name) + strlen (name) + 1);\n      match->id.u = uid;\n      strcpy (match->name, name);\n\n      /* Add to the head of the list, so most recently used is first.  */\n      match->next = user_alist;\n      user_alist = match;\n    }\n\n  return match->name[0] ? match->name : NULL;\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "char",
        "*\ngetuser (uid_t uid)",
        "*"
      ]
    },
    "getuidbyname": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "uid_t *\ngetuidbyname (const char *user)\n{\n  struct userid *tail;\n  struct passwd *pwent;\n\n  for (tail = user_alist; tail; tail = tail->next)\n    /* Avoid a function call for the most common case.  */\n    if (*tail->name == *user && !strcmp (tail->name, user))\n      return &tail->id.u;\n\n  for (tail = nouser_alist; tail; tail = tail->next)\n    /* Avoid a function call for the most common case.  */\n    if (*tail->name == *user && !strcmp (tail->name, user))\n      return NULL;\n\n  pwent = getpwnam (user);\n#ifdef __DJGPP__\n  /* We need to pretend to be the user USER, to make\n     pwd functions know about an arbitrary user name.  */\n  if (!pwent && strspn (user, digits) < strlen (user))\n    {\n      setenv (\"USER\", user, 1);\n      pwent = getpwnam (user);  /* now it will succeed */\n    }\n#endif\n\n  tail = xmalloc (offsetof (struct userid, name) + strlen (user) + 1);\n  strcpy (tail->name, user);\n\n  /* Add to the head of the list, so most recently used is first.  */\n  if (pwent)\n    {\n      tail->id.u = pwent->pw_uid;\n      tail->next = user_alist;\n      user_alist = tail;\n      return &tail->id.u;\n    }\n\n  tail->next = nouser_alist;\n  nouser_alist = tail;\n  return NULL;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "uid_t",
        "*\ngetuidbyname (const char *user)",
        "*"
      ]
    },
    "getgroup": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "char *\ngetgroup (gid_t gid)\n{\n  struct userid *tail;\n  struct userid *match = NULL;\n\n  for (tail = group_alist; tail; tail = tail->next)\n    {\n      if (tail->id.g == gid)\n        {\n          match = tail;\n          break;\n        }\n    }\n\n  if (match == NULL)\n    {\n      struct group *grent = getgrgid (gid);\n      char const *name = grent ? grent->gr_name : \"\";\n      match = xmalloc (offsetof (struct userid, name) + strlen (name) + 1);\n      match->id.g = gid;\n      strcpy (match->name, name);\n\n      /* Add to the head of the list, so most recently used is first.  */\n      match->next = group_alist;\n      group_alist = match;\n    }\n\n  return match->name[0] ? match->name : NULL;\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "char",
        "*\ngetgroup (gid_t gid)",
        "*"
      ]
    },
    "getgidbyname": {
      "start_point": [
        184,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "gid_t *\ngetgidbyname (const char *group)\n{\n  struct userid *tail;\n  struct group *grent;\n\n  for (tail = group_alist; tail; tail = tail->next)\n    /* Avoid a function call for the most common case.  */\n    if (*tail->name == *group && !strcmp (tail->name, group))\n      return &tail->id.g;\n\n  for (tail = nogroup_alist; tail; tail = tail->next)\n    /* Avoid a function call for the most common case.  */\n    if (*tail->name == *group && !strcmp (tail->name, group))\n      return NULL;\n\n  grent = getgrnam (group);\n#ifdef __DJGPP__\n  /* We need to pretend to belong to group GROUP, to make\n     grp functions know about an arbitrary group name.  */\n  if (!grent && strspn (group, digits) < strlen (group))\n    {\n      setenv (\"GROUP\", group, 1);\n      grent = getgrnam (group); /* now it will succeed */\n    }\n#endif\n\n  tail = xmalloc (offsetof (struct userid, name) + strlen (group) + 1);\n  strcpy (tail->name, group);\n\n  /* Add to the head of the list, so most recently used is first.  */\n  if (grent)\n    {\n      tail->id.g = grent->gr_gid;\n      tail->next = group_alist;\n      group_alist = tail;\n      return &tail->id.g;\n    }\n\n  tail->next = nogroup_alist;\n  nogroup_alist = tail;\n  return NULL;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "gid_t",
        "*\ngetgidbyname (const char *group)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/idcache.h": {},
  "sharutils/sharutils-4.15.2/lib/imaxtostr.c": {},
  "sharutils/sharutils-4.15.2/lib/intprops.h": {},
  "sharutils/sharutils-4.15.2/lib/inttostr.c": {},
  "sharutils/sharutils-4.15.2/lib/inttostr.h": {},
  "sharutils/sharutils-4.15.2/lib/inttypes.in.h": {},
  "sharutils/sharutils-4.15.2/lib/liballoca.h": {},
  "sharutils/sharutils-4.15.2/lib/localcharset.c": {
    "get_charset_aliases": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        380,
        1
      ],
      "content": "static const char *\nget_charset_aliases (void)\n{\n  const char *cp;\n\n  cp = charset_aliases;\n  if (cp == NULL)\n    {\n#if !(defined DARWIN7 || defined VMS || defined WINDOWS_NATIVE || defined __CYGWIN__ || defined OS2)\n      const char *dir;\n      const char *base = \"charset.alias\";\n      char *file_name;\n\n      /* Make it possible to override the charset.alias location.  This is\n         necessary for running the testsuite before \"make install\".  */\n      dir = getenv (\"CHARSETALIASDIR\");\n      if (dir == NULL || dir[0] == '\\0')\n        dir = relocate (LIBDIR);\n\n      /* Concatenate dir and base into freshly allocated file_name.  */\n      {\n        size_t dir_len = strlen (dir);\n        size_t base_len = strlen (base);\n        int add_slash = (dir_len > 0 && !ISSLASH (dir[dir_len - 1]));\n        file_name = (char *) malloc (dir_len + add_slash + base_len + 1);\n        if (file_name != NULL)\n          {\n            memcpy (file_name, dir, dir_len);\n            if (add_slash)\n              file_name[dir_len] = DIRECTORY_SEPARATOR;\n            memcpy (file_name + dir_len + add_slash, base, base_len + 1);\n          }\n      }\n\n      if (file_name == NULL)\n        /* Out of memory.  Treat the file as empty.  */\n        cp = \"\";\n      else\n        {\n          int fd;\n\n          /* Open the file.  Reject symbolic links on platforms that support\n             O_NOFOLLOW.  This is a security feature.  Without it, an attacker\n             could retrieve parts of the contents (namely, the tail of the\n             first line that starts with \"* \") of an arbitrary file by placing\n             a symbolic link to that file under the name \"charset.alias\" in\n             some writable directory and defining the environment variable\n             CHARSETALIASDIR to point to that directory.  */\n          fd = open (file_name,\n                     O_RDONLY | (HAVE_WORKING_O_NOFOLLOW ? O_NOFOLLOW : 0));\n          if (fd < 0)\n            /* File not found.  Treat it as empty.  */\n            cp = \"\";\n          else\n            {\n              FILE *fp;\n\n              fp = fdopen (fd, \"r\");\n              if (fp == NULL)\n                {\n                  /* Out of memory.  Treat the file as empty.  */\n                  close (fd);\n                  cp = \"\";\n                }\n              else\n                {\n                  /* Parse the file's contents.  */\n                  char *res_ptr = NULL;\n                  size_t res_size = 0;\n\n                  for (;;)\n                    {\n                      int c;\n                      char buf1[50+1];\n                      char buf2[50+1];\n                      size_t l1, l2;\n                      char *old_res_ptr;\n\n                      c = getc (fp);\n                      if (c == EOF)\n                        break;\n                      if (c == '\\n' || c == ' ' || c == '\\t')\n                        continue;\n                      if (c == '#')\n                        {\n                          /* Skip comment, to end of line.  */\n                          do\n                            c = getc (fp);\n                          while (!(c == EOF || c == '\\n'));\n                          if (c == EOF)\n                            break;\n                          continue;\n                        }\n                      ungetc (c, fp);\n                      if (fscanf (fp, \"%50s %50s\", buf1, buf2) < 2)\n                        break;\n                      l1 = strlen (buf1);\n                      l2 = strlen (buf2);\n                      old_res_ptr = res_ptr;\n                      if (res_size == 0)\n                        {\n                          res_size = l1 + 1 + l2 + 1;\n                          res_ptr = (char *) malloc (res_size + 1);\n                        }\n                      else\n                        {\n                          res_size += l1 + 1 + l2 + 1;\n                          res_ptr = (char *) realloc (res_ptr, res_size + 1);\n                        }\n                      if (res_ptr == NULL)\n                        {\n                          /* Out of memory. */\n                          res_size = 0;\n                          free (old_res_ptr);\n                          break;\n                        }\n                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);\n                      strcpy (res_ptr + res_size - (l2 + 1), buf2);\n                    }\n                  fclose (fp);\n                  if (res_size == 0)\n                    cp = \"\";\n                  else\n                    {\n                      *(res_ptr + res_size) = '\\0';\n                      cp = res_ptr;\n                    }\n                }\n            }\n\n          free (file_name);\n        }\n\n#else\n\n# if defined DARWIN7\n      /* To avoid the trouble of installing a file that is shared by many\n         GNU packages -- many packaging systems have problems with this --,\n         simply inline the aliases here.  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-4\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"ISO8859-13\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"ISO8859-15\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"KOI8-R\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"KOI8-U\" \"\\0\" \"KOI8-U\" \"\\0\"\n           \"CP866\" \"\\0\" \"CP866\" \"\\0\"\n           \"CP949\" \"\\0\" \"CP949\" \"\\0\"\n           \"CP1131\" \"\\0\" \"CP1131\" \"\\0\"\n           \"CP1251\" \"\\0\" \"CP1251\" \"\\0\"\n           \"eucCN\" \"\\0\" \"GB2312\" \"\\0\"\n           \"GB2312\" \"\\0\" \"GB2312\" \"\\0\"\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"eucKR\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"Big5\" \"\\0\" \"BIG5\" \"\\0\"\n           \"Big5HKSCS\" \"\\0\" \"BIG5-HKSCS\" \"\\0\"\n           \"GBK\" \"\\0\" \"GBK\" \"\\0\"\n           \"GB18030\" \"\\0\" \"GB18030\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"ARMSCII-8\" \"\\0\" \"ARMSCII-8\" \"\\0\"\n           \"PT154\" \"\\0\" \"PT154\" \"\\0\"\n         /*\"ISCII-DEV\" \"\\0\" \"?\" \"\\0\"*/\n           \"*\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n\n# if defined VMS\n      /* To avoid the troubles of an extra file charset.alias_vms in the\n         sources of many GNU packages, simply inline the aliases here.  */\n      /* The list of encodings is taken from the OpenVMS 7.3-1 documentation\n         \"Compaq C Run-Time Library Reference Manual for OpenVMS systems\"\n         section 10.7 \"Handling Different Character Sets\".  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-8\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           /* Japanese */\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"DECKANJI\" \"\\0\" \"DEC-KANJI\" \"\\0\"\n           \"SDECKANJI\" \"\\0\" \"EUC-JP\" \"\\0\"\n           /* Chinese */\n           \"eucTW\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"DECHANYU\" \"\\0\" \"DEC-HANYU\" \"\\0\"\n           \"DECHANZI\" \"\\0\" \"GB2312\" \"\\0\"\n           /* Korean */\n           \"DECKOREAN\" \"\\0\" \"EUC-KR\" \"\\0\";\n# endif\n\n# if defined WINDOWS_NATIVE || defined __CYGWIN__\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      cp = \"CP936\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP1361\" \"\\0\" \"JOHAB\" \"\\0\"\n           \"CP20127\" \"\\0\" \"ASCII\" \"\\0\"\n           \"CP20866\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP20936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP21866\" \"\\0\" \"KOI8-RU\" \"\\0\"\n           \"CP28591\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP28592\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP28593\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP28594\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP28595\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP28596\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP28597\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP28598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP28599\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP28605\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP38598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP51932\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP51936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP51949\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP51950\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP54936\" \"\\0\" \"GB18030\" \"\\0\"\n           \"CP65001\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n# if defined OS2\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      /* The list of encodings is taken from \"List of OS/2 Codepages\"\n         by Alex Taylor:\n         <http://altsan.org/os2/toolkits/uls/index.html#codepages>.\n         See also \"IBM Globalization - Code page identifiers\":\n         <http://www-01.ibm.com/software/globalization/cp/cp_cpgid.html>.  */\n      cp = \"CP813\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP878\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP819\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP912\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP913\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP914\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP915\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP916\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP920\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP921\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"CP923\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP954\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP964\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP970\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP1089\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP1208\" \"\\0\" \"UTF-8\" \"\\0\"\n           \"CP1381\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP1386\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP3372\" \"\\0\" \"EUC-JP\" \"\\0\";\n# endif\n#endif\n\n      charset_aliases = cp;\n    }\n\n  return cp;\n}",
      "lines": 259,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nget_charset_aliases (void)",
        "*"
      ]
    },
    "locale_charset": {
      "start_point": [
        391,
        0
      ],
      "end_point": [
        612,
        1
      ],
      "content": "const char *\nlocale_charset (void)\n{\n  const char *codeset;\n  const char *aliases;\n\n#if !(defined WINDOWS_NATIVE || defined OS2)\n\n# if HAVE_LANGINFO_CODESET\n\n  /* Most systems support nl_langinfo (CODESET) nowadays.  */\n  codeset = nl_langinfo (CODESET);\n\n#  ifdef __CYGWIN__\n  /* Cygwin < 1.7 does not have locales.  nl_langinfo (CODESET) always\n     returns \"US-ASCII\".  Return the suffix of the locale name from the\n     environment variables (if present) or the codepage as a number.  */\n  if (codeset != NULL && strcmp (codeset, \"US-ASCII\") == 0)\n    {\n      const char *locale;\n      static char buf[2 + 10 + 1];\n\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n      if (locale != NULL && locale[0] != '\\0')\n        {\n          /* If the locale name contains an encoding after the dot, return\n             it.  */\n          const char *dot = strchr (locale, '.');\n\n          if (dot != NULL)\n            {\n              const char *modifier;\n\n              dot++;\n              /* Look for the possible @... trailer and remove it, if any.  */\n              modifier = strchr (dot, '@');\n              if (modifier == NULL)\n                return dot;\n              if (modifier - dot < sizeof (buf))\n                {\n                  memcpy (buf, dot, modifier - dot);\n                  buf [modifier - dot] = '\\0';\n                  return buf;\n                }\n            }\n        }\n\n      /* The Windows API has a function returning the locale's codepage as a\n         number: GetACP().  This encoding is used by Cygwin, unless the user\n         has set the environment variable CYGWIN=codepage:oem (which very few\n         people do).\n         Output directed to console windows needs to be converted (to\n         GetOEMCP() if the console is using a raster font, or to\n         GetConsoleOutputCP() if it is using a TrueType font).  Cygwin does\n         this conversion transparently (see winsup/cygwin/fhandler_console.cc),\n         converting to GetConsoleOutputCP().  This leads to correct results,\n         except when SetConsoleOutputCP has been called and a raster font is\n         in use.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n      codeset = buf;\n    }\n#  endif\n\n# else\n\n  /* On old systems which lack it, use setlocale or getenv.  */\n  const char *locale = NULL;\n\n  /* But most old systems don't have a complete set of locales.  Some\n     (like SunOS 4 or DJGPP) have only the C locale.  Therefore we don't\n     use setlocale here; it would return \"C\" when it doesn't support the\n     locale name the user has set.  */\n#  if 0\n  locale = setlocale (LC_CTYPE, NULL);\n#  endif\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n    }\n\n  /* On some old systems, one used to set locale = \"iso8859_1\". On others,\n     you set it to \"language_COUNTRY.charset\". In any case, we resolve it\n     through the charset.alias file.  */\n  codeset = locale;\n\n# endif\n\n#elif defined WINDOWS_NATIVE\n\n  static char buf[2 + 10 + 1];\n\n  /* The Windows API has a function returning the locale's codepage as\n     a number, but the value doesn't change according to what the\n     'setlocale' call specified.  So we use it as a last resort, in\n     case the string returned by 'setlocale' doesn't specify the\n     codepage.  */\n  char *current_locale = setlocale (LC_ALL, NULL);\n  char *pdot;\n\n  /* If they set different locales for different categories,\n     'setlocale' will return a semi-colon separated list of locale\n     values.  To make sure we use the correct one, we choose LC_CTYPE.  */\n  if (strchr (current_locale, ';'))\n    current_locale = setlocale (LC_CTYPE, NULL);\n\n  pdot = strrchr (current_locale, '.');\n  if (pdot)\n    sprintf (buf, \"CP%s\", pdot + 1);\n  else\n    {\n      /* The Windows API has a function returning the locale's codepage as a\n        number: GetACP().\n        When the output goes to a console window, it needs to be provided in\n        GetOEMCP() encoding if the console is using a raster font, or in\n        GetConsoleOutputCP() encoding if it is using a TrueType font.\n        But in GUI programs and for output sent to files and pipes, GetACP()\n        encoding is the best bet.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n    }\n  codeset = buf;\n\n#elif defined OS2\n\n  const char *locale;\n  static char buf[2 + 10 + 1];\n  ULONG cp[3];\n  ULONG cplen;\n\n  codeset = NULL;\n\n  /* Allow user to override the codeset, as set in the operating system,\n     with standard language environment variables.  */\n  locale = getenv (\"LC_ALL\");\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_CTYPE\");\n      if (locale == NULL || locale[0] == '\\0')\n        locale = getenv (\"LANG\");\n    }\n  if (locale != NULL && locale[0] != '\\0')\n    {\n      /* If the locale name contains an encoding after the dot, return it.  */\n      const char *dot = strchr (locale, '.');\n\n      if (dot != NULL)\n        {\n          const char *modifier;\n\n          dot++;\n          /* Look for the possible @... trailer and remove it, if any.  */\n          modifier = strchr (dot, '@');\n          if (modifier == NULL)\n            return dot;\n          if (modifier - dot < sizeof (buf))\n            {\n              memcpy (buf, dot, modifier - dot);\n              buf [modifier - dot] = '\\0';\n              return buf;\n            }\n        }\n\n      /* For the POSIX locale, don't use the system's codepage.  */\n      if (strcmp (locale, \"C\") == 0 || strcmp (locale, \"POSIX\") == 0)\n        codeset = \"\";\n    }\n\n  if (codeset == NULL)\n    {\n      /* OS/2 has a function returning the locale's codepage as a number.  */\n      if (DosQueryCp (sizeof (cp), cp, &cplen))\n        codeset = \"\";\n      else\n        {\n          sprintf (buf, \"CP%u\", cp[0]);\n          codeset = buf;\n        }\n    }\n\n#endif\n\n  if (codeset == NULL)\n    /* The canonical name cannot be determined.  */\n    codeset = \"\";\n\n  /* Resolve alias. */\n  for (aliases = get_charset_aliases ();\n       *aliases != '\\0';\n       aliases += strlen (aliases) + 1, aliases += strlen (aliases) + 1)\n    if (strcmp (codeset, aliases) == 0\n        || (aliases[0] == '*' && aliases[1] == '\\0'))\n      {\n        codeset = aliases + strlen (aliases) + 1;\n        break;\n      }\n\n  /* Don't return an empty string.  GNU libc and GNU libiconv interpret\n     the empty string as denoting \"the locale's character encoding\",\n     thus GNU libiconv would call this function a second time.  */\n  if (codeset[0] == '\\0')\n    codeset = \"ASCII\";\n\n#ifdef DARWIN7\n  /* Mac OS X sets MB_CUR_MAX to 1 when LC_ALL=C, and \"UTF-8\"\n     (the default codeset) does not work when MB_CUR_MAX is 1.  */\n  if (strcmp (codeset, \"UTF-8\") == 0 && MB_CUR_MAX_L (uselocale (NULL)) <= 1)\n    codeset = \"ASCII\";\n#endif\n\n  return codeset;\n}",
      "lines": 222,
      "depth": 18,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nlocale_charset (void)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/localcharset.h": {},
  "sharutils/sharutils-4.15.2/lib/lseek.c": {
    "rpl_lseek": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "off_t\nrpl_lseek (int fd, off_t offset, int whence)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* mingw lseek mistakenly succeeds on pipes, sockets, and terminals.  */\n  HANDLE h = (HANDLE) _get_osfhandle (fd);\n  if (h == INVALID_HANDLE_VALUE)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  if (GetFileType (h) != FILE_TYPE_DISK)\n    {\n      errno = ESPIPE;\n      return -1;\n    }\n#else\n  /* BeOS lseek mistakenly succeeds on pipes...  */\n  struct stat statbuf;\n  if (fstat (fd, &statbuf) < 0)\n    return -1;\n  if (!S_ISREG (statbuf.st_mode))\n    {\n      errno = ESPIPE;\n      return -1;\n    }\n#endif\n#if _GL_WINDOWS_64_BIT_OFF_T\n  return _lseeki64 (fd, offset, whence);\n#else\n  return lseek (fd, offset, whence);\n#endif\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "off_t"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/lstat.c": {
    "orig_lstat": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "static int\norig_lstat (const char *filename, struct stat *buf)\n{\n  return lstat (filename, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_lstat": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "int\nrpl_lstat (const char *file, struct stat *sbuf)\n{\n  size_t len;\n  int lstat_result = orig_lstat (file, sbuf);\n\n  if (lstat_result != 0)\n    return lstat_result;\n\n  /* This replacement file can blindly check against '/' rather than\n     using the ISSLASH macro, because all platforms with '\\\\' either\n     lack symlinks (mingw) or have working lstat (cygwin) and thus do\n     not compile this file.  0 len should have already been filtered\n     out above, with a failure return of ENOENT.  */\n  len = strlen (file);\n  if (file[len - 1] != '/' || S_ISDIR (sbuf->st_mode))\n    return 0;\n\n  /* At this point, a trailing slash is only permitted on\n     symlink-to-dir; but it should have found information on the\n     directory, not the symlink.  Call stat() to get info about the\n     link's referent.  Our replacement stat guarantees valid results,\n     even if the symlink is not pointing to a directory.  */\n  if (!S_ISLNK (sbuf->st_mode))\n    {\n      errno = ENOTDIR;\n      return -1;\n    }\n  return stat (file, sbuf);\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/malloc.c": {
    "rpl_malloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void *\nrpl_malloc (size_t n)\n{\n  void *result;\n\n#if NEED_MALLOC_GNU\n  if (n == 0)\n    n = 1;\n#endif\n\n  result = malloc (n);\n\n#if !HAVE_MALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "void",
        "*\nrpl_malloc (size_t n)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/mbrtowc.c": {
    "mbrtowc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "size_t\nmbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n  char *pstate = (char *)ps;\n\n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n\n  if (n == 0)\n    return (size_t)(-2);\n\n  /* Here n > 0.  */\n\n  if (pstate == NULL)\n    pstate = internal_state;\n\n  {\n    size_t nstate = pstate[0];\n    char buf[4];\n    const char *p;\n    size_t m;\n\n    switch (nstate)\n      {\n      case 0:\n        p = s;\n        m = n;\n        break;\n      case 3:\n        buf[2] = pstate[3];\n        /*FALLTHROUGH*/\n      case 2:\n        buf[1] = pstate[2];\n        /*FALLTHROUGH*/\n      case 1:\n        buf[0] = pstate[1];\n        p = buf;\n        m = nstate;\n        buf[m++] = s[0];\n        if (n >= 2 && m < 4)\n          {\n            buf[m++] = s[1];\n            if (n >= 3 && m < 4)\n              buf[m++] = s[2];\n          }\n        break;\n      default:\n        errno = EINVAL;\n        return (size_t)(-1);\n      }\n\n    /* Here m > 0.  */\n\n# if __GLIBC__ || defined __UCLIBC__\n    /* Work around bug <http://sourceware.org/bugzilla/show_bug.cgi?id=9674> */\n    mbtowc (NULL, NULL, 0);\n# endif\n    {\n      int res = mbtowc (pwc, p, m);\n\n      if (res >= 0)\n        {\n          if (pwc != NULL && ((*pwc == 0) != (res == 0)))\n            abort ();\n          if (nstate >= (res > 0 ? res : 1))\n            abort ();\n          res -= nstate;\n          pstate[0] = 0;\n          return res;\n        }\n\n      /* mbtowc does not distinguish between invalid and incomplete multibyte\n         sequences.  But mbrtowc needs to make this distinction.\n         There are two possible approaches:\n           - Use iconv() and its return value.\n           - Use built-in knowledge about the possible encodings.\n         Given the low quality of implementation of iconv() on the systems that\n         lack mbrtowc(), we use the second approach.\n         The possible encodings are:\n           - 8-bit encodings,\n           - EUC-JP, EUC-KR, GB2312, EUC-TW, BIG5, GB18030, SJIS,\n           - UTF-8.\n         Use specialized code for each.  */\n      if (m >= 4 || m >= MB_CUR_MAX)\n        goto invalid;\n      /* Here MB_CUR_MAX > 1 and 0 < m < 4.  */\n      {\n        const char *encoding = locale_charset ();\n\n        if (STREQ_OPT (encoding, \"UTF-8\", 'U', 'T', 'F', '-', '8', 0, 0, 0, 0))\n          {\n            /* Cf. unistr/u8-mblen.c.  */\n            unsigned char c = (unsigned char) p[0];\n\n            if (c >= 0xc2)\n              {\n                if (c < 0xe0)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                  }\n                else if (c < 0xf0)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                    if (m == 2)\n                      {\n                        unsigned char c2 = (unsigned char) p[1];\n\n                        if ((c2 ^ 0x80) < 0x40\n                            && (c >= 0xe1 || c2 >= 0xa0)\n                            && (c != 0xed || c2 < 0xa0))\n                          goto incomplete;\n                      }\n                  }\n                else if (c <= 0xf4)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                    else /* m == 2 || m == 3 */\n                      {\n                        unsigned char c2 = (unsigned char) p[1];\n\n                        if ((c2 ^ 0x80) < 0x40\n                            && (c >= 0xf1 || c2 >= 0x90)\n                            && (c < 0xf4 || (c == 0xf4 && c2 < 0x90)))\n                          {\n                            if (m == 2)\n                              goto incomplete;\n                            else /* m == 3 */\n                              {\n                                unsigned char c3 = (unsigned char) p[2];\n\n                                if ((c3 ^ 0x80) < 0x40)\n                                  goto incomplete;\n                              }\n                          }\n                      }\n                  }\n              }\n            goto invalid;\n          }\n\n        /* As a reference for this code, you can use the GNU libiconv\n           implementation.  Look for uses of the RET_TOOFEW macro.  */\n\n        if (STREQ_OPT (encoding,\n                       \"EUC-JP\", 'E', 'U', 'C', '-', 'J', 'P', 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0xa1 && c < 0xff) || c == 0x8e || c == 0x8f)\n                  goto incomplete;\n              }\n            if (m == 2)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c == 0x8f)\n                  {\n                    unsigned char c2 = (unsigned char) p[1];\n\n                    if (c2 >= 0xa1 && c2 < 0xff)\n                      goto incomplete;\n                  }\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"EUC-KR\", 'E', 'U', 'C', '-', 'K', 'R', 0, 0, 0)\n            || STREQ_OPT (encoding,\n                          \"GB2312\", 'G', 'B', '2', '3', '1', '2', 0, 0, 0)\n            || STREQ_OPT (encoding,\n                          \"BIG5\", 'B', 'I', 'G', '5', 0, 0, 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c >= 0xa1 && c < 0xff)\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"EUC-TW\", 'E', 'U', 'C', '-', 'T', 'W', 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0xa1 && c < 0xff) || c == 0x8e)\n                  goto incomplete;\n              }\n            else /* m == 2 || m == 3 */\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c == 0x8e)\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"GB18030\", 'G', 'B', '1', '8', '0', '3', '0', 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0x90 && c <= 0xe3) || (c >= 0xf8 && c <= 0xfe))\n                  goto incomplete;\n              }\n            else /* m == 2 || m == 3 */\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c >= 0x90 && c <= 0xe3)\n                  {\n                    unsigned char c2 = (unsigned char) p[1];\n\n                    if (c2 >= 0x30 && c2 <= 0x39)\n                      {\n                        if (m == 2)\n                          goto incomplete;\n                        else /* m == 3 */\n                          {\n                            unsigned char c3 = (unsigned char) p[2];\n\n                            if (c3 >= 0x81 && c3 <= 0xfe)\n                              goto incomplete;\n                          }\n                      }\n                  }\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding, \"SJIS\", 'S', 'J', 'I', 'S', 0, 0, 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0x81 && c <= 0x9f) || (c >= 0xe0 && c <= 0xea)\n                    || (c >= 0xf0 && c <= 0xf9))\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n\n        /* An unknown multibyte encoding.  */\n        goto incomplete;\n      }\n\n     incomplete:\n      {\n        size_t k = nstate;\n        /* Here 0 <= k < m < 4.  */\n        pstate[++k] = s[0];\n        if (k < m)\n          {\n            pstate[++k] = s[1];\n            if (k < m)\n              pstate[++k] = s[2];\n          }\n        if (k != m)\n          abort ();\n      }\n      pstate[0] = m;\n      return (size_t)(-2);\n\n     invalid:\n      errno = EILSEQ;\n      /* The conversion state is undefined, says POSIX.  */\n      return (size_t)(-1);\n    }\n  }\n}",
      "lines": 284,
      "depth": 25,
      "decorators": [
        "size_t"
      ]
    },
    "rpl_mbrtowc": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        404,
        1
      ],
      "content": "size_t\nrpl_mbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n# if MBRTOWC_NULL_ARG2_BUG || MBRTOWC_RETVAL_BUG || MBRTOWC_EMPTY_INPUT_BUG\n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n# endif\n\n# if MBRTOWC_EMPTY_INPUT_BUG\n  if (n == 0)\n    return (size_t) -2;\n# endif\n\n# if MBRTOWC_RETVAL_BUG\n  {\n    static mbstate_t internal_state;\n\n    /* Override mbrtowc's internal state.  We cannot call mbsinit() on the\n       hidden internal state, but we can call it on our variable.  */\n    if (ps == NULL)\n      ps = &internal_state;\n\n    if (!mbsinit (ps))\n      {\n        /* Parse the rest of the multibyte character byte for byte.  */\n        size_t count = 0;\n        for (; n > 0; s++, n--)\n          {\n            wchar_t wc;\n            size_t ret = mbrtowc (&wc, s, 1, ps);\n\n            if (ret == (size_t)(-1))\n              return (size_t)(-1);\n            count++;\n            if (ret != (size_t)(-2))\n              {\n                /* The multibyte character has been completed.  */\n                if (pwc != NULL)\n                  *pwc = wc;\n                return (wc == 0 ? 0 : count);\n              }\n          }\n        return (size_t)(-2);\n      }\n  }\n# endif\n\n# if MBRTOWC_NUL_RETVAL_BUG\n  {\n    wchar_t wc;\n    size_t ret = mbrtowc (&wc, s, n, ps);\n\n    if (ret != (size_t)(-1) && ret != (size_t)(-2))\n      {\n        if (pwc != NULL)\n          *pwc = wc;\n        if (wc == 0)\n          ret = 0;\n      }\n    return ret;\n  }\n# else\n  {\n#   if MBRTOWC_NULL_ARG1_BUG\n    wchar_t dummy;\n\n    if (pwc == NULL)\n      pwc = &dummy;\n#   endif\n\n    return mbrtowc (pwc, s, n, ps);\n  }\n# endif\n}",
      "lines": 78,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/mbsinit.c": {
    "mbsinit": [
      {
        "start_point": [
          28,
          0
        ],
        "end_point": [
          32,
          1
        ],
        "content": "int\nmbsinit (const mbstate_t *ps)\n{\n  return ps == NULL || *ps == 0;\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          52,
          0
        ],
        "end_point": [
          58,
          1
        ],
        "content": "int\nmbsinit (const mbstate_t *ps)\n{\n  const char *pstate = (const char *)ps;\n\n  return pstate == NULL || pstate[0] == 0;\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "sharutils/sharutils-4.15.2/lib/md5.c": {
    "md5_init_ctx": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "void\nmd5_init_ctx (struct md5_ctx *ctx)\n{\n  ctx->A = 0x67452301;\n  ctx->B = 0xefcdab89;\n  ctx->C = 0x98badcfe;\n  ctx->D = 0x10325476;\n\n  ctx->total[0] = ctx->total[1] = 0;\n  ctx->buflen = 0;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "set_uint32": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static void\nset_uint32 (char *cp, uint32_t v)\n{\n  memcpy (cp, &v, sizeof v);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "md5_read_ctx": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "void *\nmd5_read_ctx (const struct md5_ctx *ctx, void *resbuf)\n{\n  char *r = resbuf;\n  set_uint32 (r + 0 * sizeof ctx->A, SWAP (ctx->A));\n  set_uint32 (r + 1 * sizeof ctx->B, SWAP (ctx->B));\n  set_uint32 (r + 2 * sizeof ctx->C, SWAP (ctx->C));\n  set_uint32 (r + 3 * sizeof ctx->D, SWAP (ctx->D));\n\n  return resbuf;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void",
        "*\nmd5_read_ctx (const struct md5_ctx *ctx, void *resbuf)",
        "*"
      ]
    },
    "md5_finish_ctx": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "void *\nmd5_finish_ctx (struct md5_ctx *ctx, void *resbuf)\n{\n  /* Take yet unprocessed bytes into account.  */\n  uint32_t bytes = ctx->buflen;\n  size_t size = (bytes < 56) ? 64 / 4 : 64 * 2 / 4;\n\n  /* Now count remaining bytes.  */\n  ctx->total[0] += bytes;\n  if (ctx->total[0] < bytes)\n    ++ctx->total[1];\n\n  /* Put the 64-bit file length in *bits* at the end of the buffer.  */\n  ctx->buffer[size - 2] = SWAP (ctx->total[0] << 3);\n  ctx->buffer[size - 1] = SWAP ((ctx->total[1] << 3) | (ctx->total[0] >> 29));\n\n  memcpy (&((char *) ctx->buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);\n\n  /* Process last bytes.  */\n  md5_process_block (ctx->buffer, size * 4, ctx);\n\n  return md5_read_ctx (ctx, resbuf);\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "void",
        "*\nmd5_finish_ctx (struct md5_ctx *ctx, void *resbuf)",
        "*"
      ]
    },
    "md5_stream": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "int\nmd5_stream (FILE *stream, void *resblock)\n{\n  struct md5_ctx ctx;\n  size_t sum;\n\n  char *buffer = malloc (BLOCKSIZE + 72);\n  if (!buffer)\n    return 1;\n\n  /* Initialize the computation context.  */\n  md5_init_ctx (&ctx);\n\n  /* Iterate over full file contents.  */\n  while (1)\n    {\n      /* We read the file in blocks of BLOCKSIZE bytes.  One call of the\n         computation function processes the whole buffer so that with the\n         next round of the loop another block can be read.  */\n      size_t n;\n      sum = 0;\n\n      /* Read block.  Take care for partial reads.  */\n      while (1)\n        {\n          n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);\n\n          sum += n;\n\n          if (sum == BLOCKSIZE)\n            break;\n\n          if (n == 0)\n            {\n              /* Check for the error flag IFF N == 0, so that we don't\n                 exit the loop after a partial read due to e.g., EAGAIN\n                 or EWOULDBLOCK.  */\n              if (ferror (stream))\n                {\n                  free (buffer);\n                  return 1;\n                }\n              goto process_partial_block;\n            }\n\n          /* We've read at least one byte, so ignore errors.  But always\n             check for EOF, since feof may be true even though N > 0.\n             Otherwise, we could end up calling fread after EOF.  */\n          if (feof (stream))\n            goto process_partial_block;\n        }\n\n      /* Process buffer with BLOCKSIZE bytes.  Note that\n         BLOCKSIZE % 64 == 0\n       */\n      md5_process_block (buffer, BLOCKSIZE, &ctx);\n    }\n\nprocess_partial_block:\n\n  /* Process any remaining bytes.  */\n  if (sum > 0)\n    md5_process_bytes (buffer, sum, &ctx);\n\n  /* Construct result in desired memory.  */\n  md5_finish_ctx (&ctx, resblock);\n  free (buffer);\n  return 0;\n}",
      "lines": 69,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "md5_buffer": {
      "start_point": [
        214,
        0
      ],
      "end_point": [
        227,
        1
      ],
      "content": "void *\nmd5_buffer (const char *buffer, size_t len, void *resblock)\n{\n  struct md5_ctx ctx;\n\n  /* Initialize the computation context.  */\n  md5_init_ctx (&ctx);\n\n  /* Process whole buffer but last len % 64 bytes.  */\n  md5_process_bytes (buffer, len, &ctx);\n\n  /* Put result in desired memory area.  */\n  return md5_finish_ctx (&ctx, resblock);\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "void",
        "*\nmd5_buffer (const char *buffer, size_t len, void *resblock)",
        "*"
      ]
    },
    "md5_process_bytes": {
      "start_point": [
        230,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "void\nmd5_process_bytes (const void *buffer, size_t len, struct md5_ctx *ctx)\n{\n  /* When we already have some bits in our internal buffer concatenate\n     both inputs first.  */\n  if (ctx->buflen != 0)\n    {\n      size_t left_over = ctx->buflen;\n      size_t add = 128 - left_over > len ? len : 128 - left_over;\n\n      memcpy (&((char *) ctx->buffer)[left_over], buffer, add);\n      ctx->buflen += add;\n\n      if (ctx->buflen > 64)\n        {\n          md5_process_block (ctx->buffer, ctx->buflen & ~63, ctx);\n\n          ctx->buflen &= 63;\n          /* The regions in the following copy operation cannot overlap.  */\n          memcpy (ctx->buffer,\n                  &((char *) ctx->buffer)[(left_over + add) & ~63],\n                  ctx->buflen);\n        }\n\n      buffer = (const char *) buffer + add;\n      len -= add;\n    }\n\n  /* Process available complete blocks.  */\n  if (len >= 64)\n    {\n#if !_STRING_ARCH_unaligned\n# define UNALIGNED_P(p) ((uintptr_t) (p) % alignof (uint32_t) != 0)\n      if (UNALIGNED_P (buffer))\n        while (len > 64)\n          {\n            md5_process_block (memcpy (ctx->buffer, buffer, 64), 64, ctx);\n            buffer = (const char *) buffer + 64;\n            len -= 64;\n          }\n      else\n#endif\n        {\n          md5_process_block (buffer, len & ~63, ctx);\n          buffer = (const char *) buffer + (len & ~63);\n          len &= 63;\n        }\n    }\n\n  /* Move remaining bytes in internal buffer.  */\n  if (len > 0)\n    {\n      size_t left_over = ctx->buflen;\n\n      memcpy (&((char *) ctx->buffer)[left_over], buffer, len);\n      left_over += len;\n      if (left_over >= 64)\n        {\n          md5_process_block (ctx->buffer, 64, ctx);\n          left_over -= 64;\n          memcpy (ctx->buffer, &ctx->buffer[16], left_over);\n        }\n      ctx->buflen = left_over;\n    }\n}",
      "lines": 65,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "md5_process_block": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        466,
        1
      ],
      "content": "void\nmd5_process_block (const void *buffer, size_t len, struct md5_ctx *ctx)\n{\n  uint32_t correct_words[16];\n  const uint32_t *words = buffer;\n  size_t nwords = len / sizeof (uint32_t);\n  const uint32_t *endp = words + nwords;\n  uint32_t A = ctx->A;\n  uint32_t B = ctx->B;\n  uint32_t C = ctx->C;\n  uint32_t D = ctx->D;\n  uint32_t lolen = len;\n\n  /* First increment the byte count.  RFC 1321 specifies the possible\n     length of the file up to 2^64 bits.  Here we only compute the\n     number of bytes.  Do a double word increment.  */\n  ctx->total[0] += lolen;\n  ctx->total[1] += (len >> 31 >> 1) + (ctx->total[0] < lolen);\n\n  /* Process all bytes in the buffer with 64 bytes in each round of\n     the loop.  */\n  while (words < endp)\n    {\n      uint32_t *cwp = correct_words;\n      uint32_t A_save = A;\n      uint32_t B_save = B;\n      uint32_t C_save = C;\n      uint32_t D_save = D;\n\n      /* First round: using the given function, the context and a constant\n         the next context is computed.  Because the algorithms processing\n         unit is a 32-bit word and it is determined to work on words in\n         little endian byte order we perhaps have to change the byte order\n         before the computation.  To reduce the work for the next steps\n         we store the swapped words in the array CORRECT_WORDS.  */\n\n#define OP(a, b, c, d, s, T)                                            \\\n      do                                                                \\\n        {                                                               \\\n          a += FF (b, c, d) + (*cwp++ = SWAP (*words)) + T;             \\\n          ++words;                                                      \\\n          CYCLIC (a, s);                                                \\\n          a += b;                                                       \\\n        }                                                               \\\n      while (0)\n\n      /* It is unfortunate that C does not provide an operator for\n         cyclic rotation.  Hope the C compiler is smart enough.  */\n#define CYCLIC(w, s) (w = (w << s) | (w >> (32 - s)))\n\n      /* Before we start, one word to the strange constants.\n         They are defined in RFC 1321 as\n\n         T[i] = (int) (4294967296.0 * fabs (sin (i))), i=1..64\n\n         Here is an equivalent invocation using Perl:\n\n         perl -e 'foreach(1..64){printf \"0x%08x\\n\", int (4294967296 * abs (sin $_))}'\n       */\n\n      /* Round 1.  */\n      OP (A, B, C, D, 7, 0xd76aa478);\n      OP (D, A, B, C, 12, 0xe8c7b756);\n      OP (C, D, A, B, 17, 0x242070db);\n      OP (B, C, D, A, 22, 0xc1bdceee);\n      OP (A, B, C, D, 7, 0xf57c0faf);\n      OP (D, A, B, C, 12, 0x4787c62a);\n      OP (C, D, A, B, 17, 0xa8304613);\n      OP (B, C, D, A, 22, 0xfd469501);\n      OP (A, B, C, D, 7, 0x698098d8);\n      OP (D, A, B, C, 12, 0x8b44f7af);\n      OP (C, D, A, B, 17, 0xffff5bb1);\n      OP (B, C, D, A, 22, 0x895cd7be);\n      OP (A, B, C, D, 7, 0x6b901122);\n      OP (D, A, B, C, 12, 0xfd987193);\n      OP (C, D, A, B, 17, 0xa679438e);\n      OP (B, C, D, A, 22, 0x49b40821);\n\n      /* For the second to fourth round we have the possibly swapped words\n         in CORRECT_WORDS.  Redefine the macro to take an additional first\n         argument specifying the function to use.  */\n#undef OP\n#define OP(f, a, b, c, d, k, s, T)                                      \\\n      do                                                                \\\n        {                                                               \\\n          a += f (b, c, d) + correct_words[k] + T;                      \\\n          CYCLIC (a, s);                                                \\\n          a += b;                                                       \\\n        }                                                               \\\n      while (0)\n\n      /* Round 2.  */\n      OP (FG, A, B, C, D, 1, 5, 0xf61e2562);\n      OP (FG, D, A, B, C, 6, 9, 0xc040b340);\n      OP (FG, C, D, A, B, 11, 14, 0x265e5a51);\n      OP (FG, B, C, D, A, 0, 20, 0xe9b6c7aa);\n      OP (FG, A, B, C, D, 5, 5, 0xd62f105d);\n      OP (FG, D, A, B, C, 10, 9, 0x02441453);\n      OP (FG, C, D, A, B, 15, 14, 0xd8a1e681);\n      OP (FG, B, C, D, A, 4, 20, 0xe7d3fbc8);\n      OP (FG, A, B, C, D, 9, 5, 0x21e1cde6);\n      OP (FG, D, A, B, C, 14, 9, 0xc33707d6);\n      OP (FG, C, D, A, B, 3, 14, 0xf4d50d87);\n      OP (FG, B, C, D, A, 8, 20, 0x455a14ed);\n      OP (FG, A, B, C, D, 13, 5, 0xa9e3e905);\n      OP (FG, D, A, B, C, 2, 9, 0xfcefa3f8);\n      OP (FG, C, D, A, B, 7, 14, 0x676f02d9);\n      OP (FG, B, C, D, A, 12, 20, 0x8d2a4c8a);\n\n      /* Round 3.  */\n      OP (FH, A, B, C, D, 5, 4, 0xfffa3942);\n      OP (FH, D, A, B, C, 8, 11, 0x8771f681);\n      OP (FH, C, D, A, B, 11, 16, 0x6d9d6122);\n      OP (FH, B, C, D, A, 14, 23, 0xfde5380c);\n      OP (FH, A, B, C, D, 1, 4, 0xa4beea44);\n      OP (FH, D, A, B, C, 4, 11, 0x4bdecfa9);\n      OP (FH, C, D, A, B, 7, 16, 0xf6bb4b60);\n      OP (FH, B, C, D, A, 10, 23, 0xbebfbc70);\n      OP (FH, A, B, C, D, 13, 4, 0x289b7ec6);\n      OP (FH, D, A, B, C, 0, 11, 0xeaa127fa);\n      OP (FH, C, D, A, B, 3, 16, 0xd4ef3085);\n      OP (FH, B, C, D, A, 6, 23, 0x04881d05);\n      OP (FH, A, B, C, D, 9, 4, 0xd9d4d039);\n      OP (FH, D, A, B, C, 12, 11, 0xe6db99e5);\n      OP (FH, C, D, A, B, 15, 16, 0x1fa27cf8);\n      OP (FH, B, C, D, A, 2, 23, 0xc4ac5665);\n\n      /* Round 4.  */\n      OP (FI, A, B, C, D, 0, 6, 0xf4292244);\n      OP (FI, D, A, B, C, 7, 10, 0x432aff97);\n      OP (FI, C, D, A, B, 14, 15, 0xab9423a7);\n      OP (FI, B, C, D, A, 5, 21, 0xfc93a039);\n      OP (FI, A, B, C, D, 12, 6, 0x655b59c3);\n      OP (FI, D, A, B, C, 3, 10, 0x8f0ccc92);\n      OP (FI, C, D, A, B, 10, 15, 0xffeff47d);\n      OP (FI, B, C, D, A, 1, 21, 0x85845dd1);\n      OP (FI, A, B, C, D, 8, 6, 0x6fa87e4f);\n      OP (FI, D, A, B, C, 15, 10, 0xfe2ce6e0);\n      OP (FI, C, D, A, B, 6, 15, 0xa3014314);\n      OP (FI, B, C, D, A, 13, 21, 0x4e0811a1);\n      OP (FI, A, B, C, D, 4, 6, 0xf7537e82);\n      OP (FI, D, A, B, C, 11, 10, 0xbd3af235);\n      OP (FI, C, D, A, B, 2, 15, 0x2ad7d2bb);\n      OP (FI, B, C, D, A, 9, 21, 0xeb86d391);\n\n      /* Add the starting values of the context.  */\n      A += A_save;\n      B += B_save;\n      C += C_save;\n      D += D_save;\n    }\n\n  /* Put checksum in context given as argument.  */\n  ctx->A = A;\n  ctx->B = B;\n  ctx->C = C;\n  ctx->D = D;\n}",
      "lines": 158,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/md5.h": {},
  "sharutils/sharutils-4.15.2/lib/memchr.c": {
    "__memchr": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "void *\n__memchr (void const *s, int c_in, size_t n)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned reg_char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;\n       --n, ++char_ptr)\n    if (*char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will test a\n     longword at a time.  The tricky part is testing if *any of the four*\n     bytes in the longword in question are equal to c.  We first use an xor\n     with repeated_c.  This reduces the task to testing whether *any of the\n     four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     So, the test whether any byte in longword1 is zero is equivalent to\n     testing whether tmp is nonzero.  */\n\n  while (n >= sizeof (longword))\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n      n -= sizeof (longword);\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that either n < sizeof (longword), or one of the\n     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian\n     machines, we could determine the first such byte without any further\n     memory accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.  Choose code\n     that works in both cases.  */\n\n  for (; n > 0; --n, ++char_ptr)\n    {\n      if (*char_ptr == c)\n        return (void *) char_ptr;\n    }\n\n  return NULL;\n}",
      "lines": 112,
      "depth": 14,
      "decorators": [
        "void",
        "*\n__memchr (void const *s, int c_in, size_t n)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/mempcpy.c": {
    "mempcpy": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "void *\nmempcpy (void *dest, const void *src, size_t n)\n{\n  return (char *) memcpy (dest, src, n) + n;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nmempcpy (void *dest, const void *src, size_t n)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/memrchr.c": {
    "__memrchr": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "void *\n__memrchr (void const *s, int c_in, size_t n)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned reg_char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the last few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s + n;\n       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;\n       --n)\n    if (*--char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will test a\n     longword at a time.  The tricky part is testing if *any of the four*\n     bytes in the longword in question are equal to c.  We first use an xor\n     with repeated_c.  This reduces the task to testing whether *any of the\n     four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     So, the test whether any byte in longword1 is zero is equivalent to\n     testing whether tmp is nonzero.  */\n\n  while (n >= sizeof (longword))\n    {\n      longword longword1 = *--longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        {\n          longword_ptr++;\n          break;\n        }\n      n -= sizeof (longword);\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that either n < sizeof (longword), or one of the\n     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian\n     machines, we could determine the first such byte without any further\n     memory accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.  Choose code\n     that works in both cases.  */\n\n  while (n-- > 0)\n    {\n      if (*--char_ptr == c)\n        return (void *) char_ptr;\n    }\n\n  return NULL;\n}",
      "lines": 114,
      "depth": 14,
      "decorators": [
        "void",
        "*\n__memrchr (void const *s, int c_in, size_t n)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/mkstemp.c": {
    "mkstemp": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nmkstemp (char *xtemplate)\n{\n  return __gen_tempname (xtemplate, 0, 0, __GT_FILE);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/mktime-internal.h": {},
  "sharutils/sharutils-4.15.2/lib/mktime.c": {
    "leapyear": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "static int\nleapyear (long_int year)\n{\n  /* Don't add YEAR to TM_YEAR_BASE, as that might overflow.\n     Also, work even if YEAR is negative.  */\n  return\n    ((year & 3) == 0\n     && (year % 100 != 0\n\t || ((year / 100) & 3) == (- (TM_YEAR_BASE / 100) & 3)));\n}",
      "lines": 10,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "isdst_differ": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "static int\nisdst_differ (int a, int b)\n{\n  return (!a != !b) && (0 <= a) && (0 <= b);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ydhms_diff": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "static time_t\nydhms_diff (long_int year1, long_int yday1, int hour1, int min1, int sec1,\n\t    int year0, int yday0, int hour0, int min0, int sec0)\n{\n  verify (C99_integer_division, -1 / 2 == 0);\n\n  /* Compute intervening leap days correctly even if year is negative.\n     Take care to avoid integer overflow here.  */\n  int a4 = SHR (year1, 2) + SHR (TM_YEAR_BASE, 2) - ! (year1 & 3);\n  int b4 = SHR (year0, 2) + SHR (TM_YEAR_BASE, 2) - ! (year0 & 3);\n  int a100 = a4 / 25 - (a4 % 25 < 0);\n  int b100 = b4 / 25 - (b4 % 25 < 0);\n  int a400 = SHR (a100, 2);\n  int b400 = SHR (b100, 2);\n  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n\n  /* Compute the desired time in time_t precision.  Overflow might\n     occur here.  */\n  time_t tyear1 = year1;\n  time_t years = tyear1 - year0;\n  time_t days = 365 * years + yday1 - yday0 + intervening_leap_days;\n  time_t hours = 24 * days + hour1 - hour0;\n  time_t minutes = 60 * hours + min1 - min0;\n  time_t seconds = 60 * minutes + sec1 - sec0;\n  return seconds;\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "time_t"
      ]
    },
    "time_t_avg": {
      "start_point": [
        226,
        0
      ],
      "end_point": [
        230,
        1
      ],
      "content": "static time_t\ntime_t_avg (time_t a, time_t b)\n{\n  return SHR (a, 1) + SHR (b, 1) + (a & b & 1);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "time_t"
      ]
    },
    "time_t_add_ok": {
      "start_point": [
        235,
        0
      ],
      "end_point": [
        253,
        1
      ],
      "content": "static int\ntime_t_add_ok (time_t a, time_t b)\n{\n  if (! TYPE_SIGNED (time_t))\n    {\n      time_t sum = a + b;\n      return (sum < a) == (TIME_T_MIDPOINT <= b);\n    }\n  else if (WRAPV)\n    {\n      time_t sum = a + b;\n      return (sum < a) == (b < 0);\n    }\n  else\n    {\n      time_t avg = time_t_avg (a, b);\n      return TIME_T_MIN / 2 <= avg && avg <= TIME_T_MAX / 2;\n    }\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "time_t_int_add_ok": {
      "start_point": [
        256,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "static int\ntime_t_int_add_ok (time_t a, int b)\n{\n  verify (int_no_wider_than_time_t, INT_MAX <= TIME_T_MAX);\n  if (WRAPV)\n    {\n      time_t sum = a + b;\n      return (sum < a) == (b < 0);\n    }\n  else\n    {\n      int a_odd = a & 1;\n      time_t avg = SHR (a, 1) + (SHR (b, 1) + (a_odd & b));\n      return TIME_T_MIN / 2 <= avg && avg <= TIME_T_MAX / 2;\n    }\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "guess_time_tm": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        300,
        1
      ],
      "content": "static time_t\nguess_time_tm (long_int year, long_int yday, int hour, int min, int sec,\n\t       const time_t *t, const struct tm *tp)\n{\n  if (tp)\n    {\n      time_t d = ydhms_diff (year, yday, hour, min, sec,\n\t\t\t     tp->tm_year, tp->tm_yday,\n\t\t\t     tp->tm_hour, tp->tm_min, tp->tm_sec);\n      if (time_t_add_ok (*t, d))\n\treturn *t + d;\n    }\n\n  /* Overflow occurred one way or another.  Return the nearest result\n     that is actually in range, except don't report a zero difference\n     if the actual difference is nonzero, as that would cause a false\n     match; and don't oscillate between two values, as that would\n     confuse the spring-forward gap detector.  */\n  return (*t < TIME_T_MIDPOINT\n\t  ? (*t <= TIME_T_MIN + 1 ? *t + 1 : TIME_T_MIN)\n\t  : (TIME_T_MAX - 1 <= *t ? *t - 1 : TIME_T_MAX));\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "time_t"
      ]
    },
    "ranged_convert": {
      "start_point": [
        305,
        0
      ],
      "end_point": [
        339,
        1
      ],
      "content": "static struct tm *\nranged_convert (struct tm *(*convert) (const time_t *, struct tm *),\n\t\ttime_t *t, struct tm *tp)\n{\n  struct tm *r = convert (t, tp);\n\n  if (!r && *t)\n    {\n      time_t bad = *t;\n      time_t ok = 0;\n\n      /* BAD is a known unconvertible time_t, and OK is a known good one.\n\t Use binary search to narrow the range between BAD and OK until\n\t they differ by 1.  */\n      while (bad != ok + (bad < 0 ? -1 : 1))\n\t{\n\t  time_t mid = *t = time_t_avg (ok, bad);\n\t  r = convert (t, tp);\n\t  if (r)\n\t    ok = mid;\n\t  else\n\t    bad = mid;\n\t}\n\n      if (!r && ok)\n\t{\n\t  /* The last conversion attempt failed;\n\t     revert to the most recent successful attempt.  */\n\t  *t = ok;\n\t  r = convert (t, tp);\n\t}\n    }\n\n  return r;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "struct tm",
        "struct",
        "tm",
        "*\nranged_convert (struct tm *(*convert) (const time_t *, struct tm *),\n\t\ttime_t *t, struct tm *tp)",
        "*"
      ]
    },
    "__mktime_internal": {
      "start_point": [
        348,
        0
      ],
      "end_point": [
        570,
        1
      ],
      "content": "time_t\n__mktime_internal (struct tm *tp,\n\t\t   struct tm *(*convert) (const time_t *, struct tm *),\n\t\t   time_t *offset)\n{\n  time_t t, gt, t0, t1, t2;\n  struct tm tm;\n\n  /* The maximum number of probes (calls to CONVERT) should be enough\n     to handle any combinations of time zone rule changes, solar time,\n     leap seconds, and oscillations around a spring-forward gap.\n     POSIX.1 prohibits leap seconds, but some hosts have them anyway.  */\n  int remaining_probes = 6;\n\n  /* Time requested.  Copy it in case CONVERT modifies *TP; this can\n     occur if TP is localtime's returned value and CONVERT is localtime.  */\n  int sec = tp->tm_sec;\n  int min = tp->tm_min;\n  int hour = tp->tm_hour;\n  int mday = tp->tm_mday;\n  int mon = tp->tm_mon;\n  int year_requested = tp->tm_year;\n  int isdst = tp->tm_isdst;\n\n  /* 1 if the previous probe was DST.  */\n  int dst2;\n\n  /* Ensure that mon is in range, and set year accordingly.  */\n  int mon_remainder = mon % 12;\n  int negative_mon_remainder = mon_remainder < 0;\n  int mon_years = mon / 12 - negative_mon_remainder;\n  long_int lyear_requested = year_requested;\n  long_int year = lyear_requested + mon_years;\n\n  /* The other values need not be in range:\n     the remaining code handles minor overflows correctly,\n     assuming int and time_t arithmetic wraps around.\n     Major overflows are caught at the end.  */\n\n  /* Calculate day of year from year, month, and day of month.\n     The result need not be in range.  */\n  int mon_yday = ((__mon_yday[leapyear (year)]\n\t\t   [mon_remainder + 12 * negative_mon_remainder])\n\t\t  - 1);\n  long_int lmday = mday;\n  long_int yday = mon_yday + lmday;\n\n  time_t guessed_offset = *offset;\n\n  int sec_requested = sec;\n\n  if (LEAP_SECONDS_POSSIBLE)\n    {\n      /* Handle out-of-range seconds specially,\n\t since ydhms_tm_diff assumes every minute has 60 seconds.  */\n      if (sec < 0)\n\tsec = 0;\n      if (59 < sec)\n\tsec = 59;\n    }\n\n  /* Invert CONVERT by probing.  First assume the same offset as last\n     time.  */\n\n  t0 = ydhms_diff (year, yday, hour, min, sec,\n\t\t   EPOCH_YEAR - TM_YEAR_BASE, 0, 0, 0, - guessed_offset);\n\n  if (TIME_T_MAX / INT_MAX / 366 / 24 / 60 / 60 < 3)\n    {\n      /* time_t isn't large enough to rule out overflows, so check\n\t for major overflows.  A gross check suffices, since if t0\n\t has overflowed, it is off by a multiple of TIME_T_MAX -\n\t TIME_T_MIN + 1.  So ignore any component of the difference\n\t that is bounded by a small value.  */\n\n      /* Approximate log base 2 of the number of time units per\n\t biennium.  A biennium is 2 years; use this unit instead of\n\t years to avoid integer overflow.  For example, 2 average\n\t Gregorian years are 2 * 365.2425 * 24 * 60 * 60 seconds,\n\t which is 63113904 seconds, and rint (log2 (63113904)) is\n\t 26.  */\n      int ALOG2_SECONDS_PER_BIENNIUM = 26;\n      int ALOG2_MINUTES_PER_BIENNIUM = 20;\n      int ALOG2_HOURS_PER_BIENNIUM = 14;\n      int ALOG2_DAYS_PER_BIENNIUM = 10;\n      int LOG2_YEARS_PER_BIENNIUM = 1;\n\n      int approx_requested_biennia =\n\t(SHR (year_requested, LOG2_YEARS_PER_BIENNIUM)\n\t - SHR (EPOCH_YEAR - TM_YEAR_BASE, LOG2_YEARS_PER_BIENNIUM)\n\t + SHR (mday, ALOG2_DAYS_PER_BIENNIUM)\n\t + SHR (hour, ALOG2_HOURS_PER_BIENNIUM)\n\t + SHR (min, ALOG2_MINUTES_PER_BIENNIUM)\n\t + (LEAP_SECONDS_POSSIBLE\n\t    ? 0\n\t    : SHR (sec, ALOG2_SECONDS_PER_BIENNIUM)));\n\n      int approx_biennia = SHR (t0, ALOG2_SECONDS_PER_BIENNIUM);\n      int diff = approx_biennia - approx_requested_biennia;\n      int approx_abs_diff = diff < 0 ? -1 - diff : diff;\n\n      /* IRIX 4.0.5 cc miscalculates TIME_T_MIN / 3: it erroneously\n\t gives a positive value of 715827882.  Setting a variable\n\t first then doing math on it seems to work.\n\t (ghazi@caip.rutgers.edu) */\n      time_t time_t_max = TIME_T_MAX;\n      time_t time_t_min = TIME_T_MIN;\n      time_t overflow_threshold =\n\t(time_t_max / 3 - time_t_min / 3) >> ALOG2_SECONDS_PER_BIENNIUM;\n\n      if (overflow_threshold < approx_abs_diff)\n\t{\n\t  /* Overflow occurred.  Try repairing it; this might work if\n\t     the time zone offset is enough to undo the overflow.  */\n\t  time_t repaired_t0 = -1 - t0;\n\t  approx_biennia = SHR (repaired_t0, ALOG2_SECONDS_PER_BIENNIUM);\n\t  diff = approx_biennia - approx_requested_biennia;\n\t  approx_abs_diff = diff < 0 ? -1 - diff : diff;\n\t  if (overflow_threshold < approx_abs_diff)\n\t    return -1;\n\t  guessed_offset += repaired_t0 - t0;\n\t  t0 = repaired_t0;\n\t}\n    }\n\n  /* Repeatedly use the error to improve the guess.  */\n\n  for (t = t1 = t2 = t0, dst2 = 0;\n       (gt = guess_time_tm (year, yday, hour, min, sec, &t,\n\t\t\t    ranged_convert (convert, &t, &tm)),\n\tt != gt);\n       t1 = t2, t2 = t, t = gt, dst2 = tm.tm_isdst != 0)\n    if (t == t1 && t != t2\n\t&& (tm.tm_isdst < 0\n\t    || (isdst < 0\n\t\t? dst2 <= (tm.tm_isdst != 0)\n\t\t: (isdst != 0) != (tm.tm_isdst != 0))))\n      /* We can't possibly find a match, as we are oscillating\n\t between two values.  The requested time probably falls\n\t within a spring-forward gap of size GT - T.  Follow the common\n\t practice in this case, which is to return a time that is GT - T\n\t away from the requested time, preferring a time whose\n\t tm_isdst differs from the requested value.  (If no tm_isdst\n\t was requested and only one of the two values has a nonzero\n\t tm_isdst, prefer that value.)  In practice, this is more\n\t useful than returning -1.  */\n      goto offset_found;\n    else if (--remaining_probes == 0)\n      return -1;\n\n  /* We have a match.  Check whether tm.tm_isdst has the requested\n     value, if any.  */\n  if (isdst_differ (isdst, tm.tm_isdst))\n    {\n      /* tm.tm_isdst has the wrong value.  Look for a neighboring\n\t time with the right value, and use its UTC offset.\n\n\t Heuristic: probe the adjacent timestamps in both directions,\n\t looking for the desired isdst.  This should work for all real\n\t time zone histories in the tz database.  */\n\n      /* Distance between probes when looking for a DST boundary.  In\n\t tzdata2003a, the shortest period of DST is 601200 seconds\n\t (e.g., America/Recife starting 2000-10-08 01:00), and the\n\t shortest period of non-DST surrounded by DST is 694800\n\t seconds (Africa/Tunis starting 1943-04-17 01:00).  Use the\n\t minimum of these two values, so we don't miss these short\n\t periods when probing.  */\n      int stride = 601200;\n\n      /* The longest period of DST in tzdata2003a is 536454000 seconds\n\t (e.g., America/Jujuy starting 1946-10-01 01:00).  The longest\n\t period of non-DST is much longer, but it makes no real sense\n\t to search for more than a year of non-DST, so use the DST\n\t max.  */\n      int duration_max = 536454000;\n\n      /* Search in both directions, so the maximum distance is half\n\t the duration; add the stride to avoid off-by-1 problems.  */\n      int delta_bound = duration_max / 2 + stride;\n\n      int delta, direction;\n\n      for (delta = stride; delta < delta_bound; delta += stride)\n\tfor (direction = -1; direction <= 1; direction += 2)\n\t  if (time_t_int_add_ok (t, delta * direction))\n\t    {\n\t      time_t ot = t + delta * direction;\n\t      struct tm otm;\n\t      ranged_convert (convert, &ot, &otm);\n\t      if (! isdst_differ (isdst, otm.tm_isdst))\n\t\t{\n\t\t  /* We found the desired tm_isdst.\n\t\t     Extrapolate back to the desired time.  */\n\t\t  t = guess_time_tm (year, yday, hour, min, sec, &ot, &otm);\n\t\t  ranged_convert (convert, &t, &tm);\n\t\t  goto offset_found;\n\t\t}\n\t    }\n    }\n\n offset_found:\n  *offset = guessed_offset + t - t0;\n\n  if (LEAP_SECONDS_POSSIBLE && sec_requested != tm.tm_sec)\n    {\n      /* Adjust time to reflect the tm_sec requested, not the normalized value.\n\t Also, repair any damage from a false match due to a leap second.  */\n      int sec_adjustment = (sec == 0 && tm.tm_sec == 60) - sec;\n      if (! time_t_int_add_ok (t, sec_requested))\n\treturn -1;\n      t1 = t + sec_requested;\n      if (! time_t_int_add_ok (t1, sec_adjustment))\n\treturn -1;\n      t2 = t1 + sec_adjustment;\n      if (! convert (&t2, &tm))\n\treturn -1;\n      t = t2;\n    }\n\n  *tp = tm;\n  return t;\n}",
      "lines": 223,
      "depth": 16,
      "decorators": [
        "time_t"
      ]
    },
    "mktime": {
      "start_point": [
        580,
        0
      ],
      "end_point": [
        591,
        1
      ],
      "content": "time_t\nmktime (struct tm *tp)\n{\n#ifdef _LIBC\n  /* POSIX.1 8.1.1 requires that whenever mktime() is called, the\n     time zone names contained in the external variable 'tzname' shall\n     be set as if the tzset() function had been called.  */\n  __tzset ();\n#endif\n\n  return __mktime_internal (tp, __localtime_r, &localtime_offset);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "time_t"
      ]
    },
    "not_equal_tm": {
      "start_point": [
        604,
        0
      ],
      "end_point": [
        615,
        1
      ],
      "content": "static int\nnot_equal_tm (const struct tm *a, const struct tm *b)\n{\n  return ((a->tm_sec ^ b->tm_sec)\n\t  | (a->tm_min ^ b->tm_min)\n\t  | (a->tm_hour ^ b->tm_hour)\n\t  | (a->tm_mday ^ b->tm_mday)\n\t  | (a->tm_mon ^ b->tm_mon)\n\t  | (a->tm_year ^ b->tm_year)\n\t  | (a->tm_yday ^ b->tm_yday)\n\t  | isdst_differ (a->tm_isdst, b->tm_isdst));\n}",
      "lines": 12,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "print_tm": {
      "start_point": [
        617,
        0
      ],
      "end_point": [
        627,
        1
      ],
      "content": "static void\nprint_tm (const struct tm *tp)\n{\n  if (tp)\n    printf (\"%04d-%02d-%02d %02d:%02d:%02d yday %03d wday %d isdst %d\",\n\t    tp->tm_year + TM_YEAR_BASE, tp->tm_mon + 1, tp->tm_mday,\n\t    tp->tm_hour, tp->tm_min, tp->tm_sec,\n\t    tp->tm_yday, tp->tm_wday, tp->tm_isdst);\n  else\n    printf (\"0\");\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_result": {
      "start_point": [
        629,
        0
      ],
      "end_point": [
        643,
        1
      ],
      "content": "static int\ncheck_result (time_t tk, struct tm tmk, time_t tl, const struct tm *lt)\n{\n  if (tk != tl || !lt || not_equal_tm (&tmk, lt))\n    {\n      printf (\"mktime (\");\n      print_tm (lt);\n      printf (\")\\nyields (\");\n      print_tm (&tmk);\n      printf (\") == %ld, should be %ld\\n\", (long int) tk, (long int) tl);\n      return 1;\n    }\n\n  return 0;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        645,
        0
      ],
      "end_point": [
        732,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int status = 0;\n  struct tm tm, tmk, tml;\n  struct tm *lt;\n  time_t tk, tl, tl1;\n  char trailer;\n\n  if ((argc == 3 || argc == 4)\n      && (sscanf (argv[1], \"%d-%d-%d%c\",\n\t\t  &tm.tm_year, &tm.tm_mon, &tm.tm_mday, &trailer)\n\t  == 3)\n      && (sscanf (argv[2], \"%d:%d:%d%c\",\n\t\t  &tm.tm_hour, &tm.tm_min, &tm.tm_sec, &trailer)\n\t  == 3))\n    {\n      tm.tm_year -= TM_YEAR_BASE;\n      tm.tm_mon--;\n      tm.tm_isdst = argc == 3 ? -1 : atoi (argv[3]);\n      tmk = tm;\n      tl = mktime (&tmk);\n      lt = localtime (&tl);\n      if (lt)\n\t{\n\t  tml = *lt;\n\t  lt = &tml;\n\t}\n      printf (\"mktime returns %ld == \", (long int) tl);\n      print_tm (&tmk);\n      printf (\"\\n\");\n      status = check_result (tl, tmk, tl, lt);\n    }\n  else if (argc == 4 || (argc == 5 && strcmp (argv[4], \"-\") == 0))\n    {\n      time_t from = atol (argv[1]);\n      time_t by = atol (argv[2]);\n      time_t to = atol (argv[3]);\n\n      if (argc == 4)\n\tfor (tl = from; by < 0 ? to <= tl : tl <= to; tl = tl1)\n\t  {\n\t    lt = localtime (&tl);\n\t    if (lt)\n\t      {\n\t\ttmk = tml = *lt;\n\t\ttk = mktime (&tmk);\n\t\tstatus |= check_result (tk, tmk, tl, &tml);\n\t      }\n\t    else\n\t      {\n\t\tprintf (\"localtime (%ld) yields 0\\n\", (long int) tl);\n\t\tstatus = 1;\n\t      }\n\t    tl1 = tl + by;\n\t    if ((tl1 < tl) != (by < 0))\n\t      break;\n\t  }\n      else\n\tfor (tl = from; by < 0 ? to <= tl : tl <= to; tl = tl1)\n\t  {\n\t    /* Null benchmark.  */\n\t    lt = localtime (&tl);\n\t    if (lt)\n\t      {\n\t\ttmk = tml = *lt;\n\t\ttk = tl;\n\t\tstatus |= check_result (tk, tmk, tl, &tml);\n\t      }\n\t    else\n\t      {\n\t\tprintf (\"localtime (%ld) yields 0\\n\", (long int) tl);\n\t\tstatus = 1;\n\t      }\n\t    tl1 = tl + by;\n\t    if ((tl1 < tl) != (by < 0))\n\t      break;\n\t  }\n    }\n  else\n    printf (\"Usage:\\\n\\t%s YYYY-MM-DD HH:MM:SS [ISDST] # Test given time.\\n\\\n\\t%s FROM BY TO # Test values FROM, FROM+BY, ..., TO.\\n\\\n\\t%s FROM BY TO - # Do not test those values (for benchmark).\\n\",\n\t    argv[0], argv[0], argv[0]);\n\n  return status;\n}",
      "lines": 88,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/msvc-inval.c": {
    "gl_msvc_invalid_parameter_handler": [
      {
        "start_point": [
          30,
          0
        ],
        "end_point": [
          37,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n}",
        "lines": 8,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          47,
          0
        ],
        "end_point": [
          55,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 9,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          96,
          0
        ],
        "end_point": [
          110,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  struct gl_msvc_inval_per_thread *current = gl_msvc_inval_current ();\n  if (current->restart_valid)\n    longjmp (current->restart, 1);\n  else\n    /* An invalid parameter notification from outside the gnulib code.\n       Give the caller a chance to intervene.  */\n    RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      }
    ],
    "gl_msvc_inval_current": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "struct gl_msvc_inval_per_thread *\ngl_msvc_inval_current (void)\n{\n  if (!tls_initialized)\n    {\n      tls_index = TlsAlloc ();\n      tls_initialized = 1;\n    }\n  if (tls_index == TLS_OUT_OF_INDEXES)\n    /* TlsAlloc had failed.  */\n    return &not_per_thread;\n  else\n    {\n      struct gl_msvc_inval_per_thread *pointer =\n        (struct gl_msvc_inval_per_thread *) TlsGetValue (tls_index);\n      if (pointer == NULL)\n        {\n          /* First call.  Allocate a new 'struct gl_msvc_inval_per_thread'.  */\n          pointer =\n            (struct gl_msvc_inval_per_thread *)\n            malloc (sizeof (struct gl_msvc_inval_per_thread));\n          if (pointer == NULL)\n            /* Could not allocate memory.  Use the global storage.  */\n            pointer = &not_per_thread;\n          TlsSetValue (tls_index, pointer);\n        }\n      return pointer;\n    }\n}",
      "lines": 29,
      "depth": 15,
      "decorators": [
        "struct gl_msvc_inval_per_thread",
        "struct",
        "gl_msvc_inval_per_thread",
        "*\ngl_msvc_inval_current (void)",
        "*"
      ]
    },
    "gl_msvc_inval_ensure_handler": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "void\ngl_msvc_inval_ensure_handler (void)\n{\n  if (gl_msvc_inval_initialized == 0)\n    {\n      _set_invalid_parameter_handler (gl_msvc_invalid_parameter_handler);\n      gl_msvc_inval_initialized = 1;\n    }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/msvc-inval.h": {},
  "sharutils/sharutils-4.15.2/lib/msvc-nothrow.c": {
    "_gl_nothrow_get_osfhandle": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        39,
        5
      ],
      "content": "intptr_t\n_gl_nothrow_get_osfhandle (int fd)\n{\n  intptr_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _get_osfhandle (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "intptr_t"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/msvc-nothrow.h": {},
  "sharutils/sharutils-4.15.2/lib/offtostr.c": {},
  "sharutils/sharutils-4.15.2/lib/open.c": {
    "orig_open": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "static int\norig_open (const char *filename, int flags, mode_t mode)\n{\n  return open (filename, flags, mode);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "open": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "int\nopen (const char *filename, int flags, ...)\n{\n  mode_t mode;\n  int fd;\n\n  mode = 0;\n  if (flags & O_CREAT)\n    {\n      va_list arg;\n      va_start (arg, flags);\n\n      /* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4\n         creates crashing code when 'mode_t' is smaller than 'int'.  */\n      mode = va_arg (arg, PROMOTED_MODE_T);\n\n      va_end (arg);\n    }\n\n#if GNULIB_defined_O_NONBLOCK\n  /* The only known platform that lacks O_NONBLOCK is mingw, but it\n     also lacks named pipes and Unix sockets, which are the only two\n     file types that require non-blocking handling in open().\n     Therefore, it is safe to ignore O_NONBLOCK here.  It is handy\n     that mingw also lacks openat(), so that is also covered here.  */\n  flags &= ~O_NONBLOCK;\n#endif\n\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  if (strcmp (filename, \"/dev/null\") == 0)\n    filename = \"NUL\";\n#endif\n\n#if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and one of O_CREAT, O_WRONLY, O_RDWR\n     is specified, then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file already exists as a directory, then\n       - if O_CREAT is specified, open() must fail because of the semantics\n         of O_CREAT,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because POSIX\n         <http://www.opengroup.org/susv3/functions/open.html> says that it\n         fails with errno = EISDIR in this case.\n     If the named file does not exist or does not name a directory, then\n       - if O_CREAT is specified, open() must fail since open() cannot create\n         directories,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because the\n         file does not contain a '.' directory.  */\n  if (flags & (O_CREAT | O_WRONLY | O_RDWR))\n    {\n      size_t len = strlen (filename);\n      if (len > 0 && filename[len - 1] == '/')\n        {\n          errno = EISDIR;\n          return -1;\n        }\n    }\n#endif\n\n  fd = orig_open (filename, flags, mode);\n\n#if REPLACE_FCHDIR\n  /* Implementing fchdir and fdopendir requires the ability to open a\n     directory file descriptor.  If open doesn't support that (as on\n     mingw), we use a dummy file that behaves the same as directories\n     on Linux (ie. always reports EOF on attempts to read()), and\n     override fstat() in fchdir.c to hide the fact that we have a\n     dummy.  */\n  if (REPLACE_OPEN_DIRECTORY && fd < 0 && errno == EACCES\n      && ((flags & O_ACCMODE) == O_RDONLY\n          || (O_SEARCH != O_RDONLY && (flags & O_ACCMODE) == O_SEARCH)))\n    {\n      struct stat statbuf;\n      if (stat (filename, &statbuf) == 0 && S_ISDIR (statbuf.st_mode))\n        {\n          /* Maximum recursion depth of 1.  */\n          fd = open (\"/dev/null\", flags, mode);\n          if (0 <= fd)\n            fd = _gl_register_fd (fd, filename);\n        }\n      else\n        errno = EACCES;\n    }\n#endif\n\n#if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and fd does not refer to a directory,\n     then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file without the slash is not a directory, open() must fail\n     with ENOTDIR.  */\n  if (fd >= 0)\n    {\n      /* We know len is positive, since open did not fail with ENOENT.  */\n      size_t len = strlen (filename);\n      if (filename[len - 1] == '/')\n        {\n          struct stat statbuf;\n\n          if (fstat (fd, &statbuf) >= 0 && !S_ISDIR (statbuf.st_mode))\n            {\n              close (fd);\n              errno = ENOTDIR;\n              return -1;\n            }\n        }\n    }\n#endif\n\n#if REPLACE_FCHDIR\n  if (!REPLACE_OPEN_DIRECTORY && 0 <= fd)\n    fd = _gl_register_fd (fd, filename);\n#endif\n\n  return fd;\n}",
      "lines": 130,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/openat-die.c": {
    "openat_save_fail": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "_Noreturn void\nopenat_save_fail (int errnum)\n{\n#ifndef GNULIB_LIBPOSIX\n  error (exit_failure, errnum,\n         _(\"unable to record current working directory\"));\n#endif\n  /* _Noreturn cannot be applied to error, since it returns\n     when its first argument is 0.  To help compilers understand that this\n     function does not return, call abort.  Also, the abort is a\n     safety feature if exit_failure is 0 (which shouldn't happen).  */\n  abort ();\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "_Noreturn",
        "void",
        "void"
      ]
    },
    "openat_restore_fail": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "_Noreturn void\nopenat_restore_fail (int errnum)\n{\n#ifndef GNULIB_LIBPOSIX\n  error (exit_failure, errnum,\n         _(\"failed to return to initial working directory\"));\n#endif\n\n  /* As above.  */\n  abort ();\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "_Noreturn",
        "void",
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/openat-priv.h": {},
  "sharutils/sharutils-4.15.2/lib/openat-proc.c": {
    "openat_proc_name": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "char *\nopenat_proc_name (char buf[OPENAT_BUFFER_SIZE], int fd, char const *file)\n{\n  static int proc_status = 0;\n\n  /* Make sure the caller gets ENOENT when appropriate.  */\n  if (!*file)\n    {\n      buf[0] = '\\0';\n      return buf;\n    }\n\n  if (! proc_status)\n    {\n      /* Set PROC_STATUS to a positive value if /proc/self/fd is\n         reliable, and a negative value otherwise.  Solaris 10\n         /proc/self/fd mishandles \"..\", and any file name might expand\n         to \"..\" after symbolic link expansion, so avoid /proc/self/fd\n         if it mishandles \"..\".  Solaris 10 has openat, but this\n         problem is exhibited on code that built on Solaris 8 and\n         running on Solaris 10.  */\n\n      int proc_self_fd = open (\"/proc/self/fd\",\n                               O_SEARCH | O_DIRECTORY | O_NOCTTY | O_NONBLOCK);\n      if (proc_self_fd < 0)\n        proc_status = -1;\n      else\n        {\n          /* Detect whether /proc/self/fd/%i/../fd exists, where %i is the\n             number of a file descriptor open on /proc/self/fd.  On Linux,\n             that name resolves to /proc/self/fd, which was opened above.\n             However, on Solaris, it may resolve to /proc/self/fd/fd, which\n             cannot exist, since all names in /proc/self/fd are numeric.  */\n          char dotdot_buf[PROC_SELF_FD_NAME_SIZE_BOUND (sizeof \"../fd\" - 1)];\n          sprintf (dotdot_buf, PROC_SELF_FD_FORMAT, proc_self_fd, \"../fd\");\n          proc_status = access (dotdot_buf, F_OK) ? -1 : 1;\n          close (proc_self_fd);\n        }\n    }\n\n  if (proc_status < 0)\n    return NULL;\n  else\n    {\n      size_t bufsize = PROC_SELF_FD_NAME_SIZE_BOUND (strlen (file));\n      char *result = buf;\n      if (OPENAT_BUFFER_SIZE < bufsize)\n        {\n          result = malloc (bufsize);\n          if (! result)\n            return NULL;\n        }\n      sprintf (result, PROC_SELF_FD_FORMAT, fd, file);\n      return result;\n    }\n}",
      "lines": 56,
      "depth": 14,
      "decorators": [
        "char",
        "*\nopenat_proc_name (char buf[OPENAT_BUFFER_SIZE], int fd, char const *file)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/openat.c": {
    "orig_openat": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "static int\norig_openat (int fd, char const *filename, int flags, mode_t mode)\n{\n  return openat (fd, filename, flags, mode);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_openat": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "int\nrpl_openat (int dfd, char const *filename, int flags, ...)\n{\n  mode_t mode;\n  int fd;\n\n  mode = 0;\n  if (flags & O_CREAT)\n    {\n      va_list arg;\n      va_start (arg, flags);\n\n      /* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4\n         creates crashing code when 'mode_t' is smaller than 'int'.  */\n      mode = va_arg (arg, PROMOTED_MODE_T);\n\n      va_end (arg);\n    }\n\n# if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and one of O_CREAT, O_WRONLY, O_RDWR\n     is specified, then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file already exists as a directory, then\n       - if O_CREAT is specified, open() must fail because of the semantics\n         of O_CREAT,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because POSIX\n         <http://www.opengroup.org/susv3/functions/open.html> says that it\n         fails with errno = EISDIR in this case.\n     If the named file does not exist or does not name a directory, then\n       - if O_CREAT is specified, open() must fail since open() cannot create\n         directories,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because the\n         file does not contain a '.' directory.  */\n  if (flags & (O_CREAT | O_WRONLY | O_RDWR))\n    {\n      size_t len = strlen (filename);\n      if (len > 0 && filename[len - 1] == '/')\n        {\n          errno = EISDIR;\n          return -1;\n        }\n    }\n# endif\n\n  fd = orig_openat (dfd, filename, flags, mode);\n\n# if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and fd does not refer to a directory,\n     then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file without the slash is not a directory, open() must fail\n     with ENOTDIR.  */\n  if (fd >= 0)\n    {\n      /* We know len is positive, since open did not fail with ENOENT.  */\n      size_t len = strlen (filename);\n      if (filename[len - 1] == '/')\n        {\n          struct stat statbuf;\n\n          if (fstat (fd, &statbuf) >= 0 && !S_ISDIR (statbuf.st_mode))\n            {\n              close (fd);\n              errno = ENOTDIR;\n              return -1;\n            }\n        }\n    }\n# endif\n\n  return fd;\n}",
      "lines": 87,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "openat": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "int\nopenat (int fd, char const *file, int flags, ...)\n{\n  mode_t mode = 0;\n\n  if (flags & O_CREAT)\n    {\n      va_list arg;\n      va_start (arg, flags);\n\n      /* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4\n         creates crashing code when 'mode_t' is smaller than 'int'.  */\n      mode = va_arg (arg, PROMOTED_MODE_T);\n\n      va_end (arg);\n    }\n\n  return openat_permissive (fd, file, flags, mode, NULL);\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "openat_permissive": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        259,
        1
      ],
      "content": "int\nopenat_permissive (int fd, char const *file, int flags, mode_t mode,\n                   int *cwd_errno)\n{\n  struct saved_cwd saved_cwd;\n  int saved_errno;\n  int err;\n  bool save_ok;\n\n  if (fd == AT_FDCWD || IS_ABSOLUTE_FILE_NAME (file))\n    return open (file, flags, mode);\n\n  {\n    char buf[OPENAT_BUFFER_SIZE];\n    char *proc_file = openat_proc_name (buf, fd, file);\n    if (proc_file)\n      {\n        int open_result = open (proc_file, flags, mode);\n        int open_errno = errno;\n        if (proc_file != buf)\n          free (proc_file);\n        /* If the syscall succeeds, or if it fails with an unexpected\n           errno value, then return right away.  Otherwise, fall through\n           and resort to using save_cwd/restore_cwd.  */\n        if (0 <= open_result || ! EXPECTED_ERRNO (open_errno))\n          {\n            errno = open_errno;\n            return open_result;\n          }\n      }\n  }\n\n  save_ok = (save_cwd (&saved_cwd) == 0);\n  if (! save_ok)\n    {\n      if (! cwd_errno)\n        openat_save_fail (errno);\n      *cwd_errno = errno;\n    }\n  if (0 <= fd && fd == saved_cwd.desc)\n    {\n      /* If saving the working directory collides with the user's\n         requested fd, then the user's fd must have been closed to\n         begin with.  */\n      free_cwd (&saved_cwd);\n      errno = EBADF;\n      return -1;\n    }\n\n  err = fchdir (fd);\n  saved_errno = errno;\n\n  if (! err)\n    {\n      err = open (file, flags, mode);\n      saved_errno = errno;\n      if (save_ok && restore_cwd (&saved_cwd) != 0)\n        {\n          if (! cwd_errno)\n            {\n              /* Don't write a message to just-created fd 2.  */\n              saved_errno = errno;\n              if (err == STDERR_FILENO)\n                close (err);\n              openat_restore_fail (saved_errno);\n            }\n          *cwd_errno = errno;\n        }\n    }\n\n  free_cwd (&saved_cwd);\n  errno = saved_errno;\n  return err;\n}",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "openat_needs_fchdir": {
      "start_point": [
        263,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "bool\nopenat_needs_fchdir (void)\n{\n  bool needs_fchdir = true;\n  int fd = open (\"/\", O_SEARCH);\n\n  if (0 <= fd)\n    {\n      char buf[OPENAT_BUFFER_SIZE];\n      char *proc_file = openat_proc_name (buf, fd, \".\");\n      if (proc_file)\n        {\n          needs_fchdir = false;\n          if (proc_file != buf)\n            free (proc_file);\n        }\n      close (fd);\n    }\n\n  return needs_fchdir;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/openat.h": {
    "chownat": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "FCHOWNAT_INLINE int\nchownat (int fd, char const *file, uid_t owner, gid_t group)\n{\n  return fchownat (fd, file, owner, group, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "FCHOWNAT_INLINE",
        "int",
        "int"
      ]
    },
    "lchownat": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "FCHOWNAT_INLINE int\nlchownat (int fd, char const *file, uid_t owner, gid_t group)\n{\n  return fchownat (fd, file, owner, group, AT_SYMLINK_NOFOLLOW);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "FCHOWNAT_INLINE",
        "int",
        "int"
      ]
    },
    "chmodat": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "FCHMODAT_INLINE int\nchmodat (int fd, char const *file, mode_t mode)\n{\n  return fchmodat (fd, file, mode, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "FCHMODAT_INLINE",
        "int",
        "int"
      ]
    },
    "lchmodat": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "FCHMODAT_INLINE int\nlchmodat (int fd, char const *file, mode_t mode)\n{\n  return fchmodat (fd, file, mode, AT_SYMLINK_NOFOLLOW);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "FCHMODAT_INLINE",
        "int",
        "int"
      ]
    },
    "statat": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "STATAT_INLINE int\nstatat (int fd, char const *name, struct stat *st)\n{\n  return fstatat (fd, name, st, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "STATAT_INLINE",
        "int",
        "int"
      ]
    },
    "lstatat": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "STATAT_INLINE int\nlstatat (int fd, char const *name, struct stat *st)\n{\n  return fstatat (fd, name, st, AT_SYMLINK_NOFOLLOW);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "STATAT_INLINE",
        "int",
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/opendir.c": {
    "opendir": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "DIR *\nopendir (const char *dir_name)\n{\n#if HAVE_OPENDIR\n# undef opendir\n  DIR *dirp;\n\n  dirp = opendir (dir_name);\n  if (dirp == NULL)\n    return NULL;\n\n#else\n\n  char dir_name_mask[MAX_PATH + 1 + 1 + 1];\n  int status;\n  HANDLE current;\n  WIN32_FIND_DATA entry;\n  struct gl_directory *dirp;\n\n  if (dir_name[0] == '\\0')\n    {\n      errno = ENOENT;\n      return NULL;\n    }\n\n  /* Make the dir_name absolute, so that we continue reading the same\n     directory if the current directory changed between this opendir()\n     call and a subsequent rewinddir() call.  */\n  if (!GetFullPathName (dir_name, MAX_PATH, dir_name_mask, NULL))\n    {\n      errno = EINVAL;\n      return NULL;\n    }\n\n  /* Append the mask.\n     \"*\" and \"*.*\" appear to be equivalent.  */\n  {\n    char *p;\n\n    p = dir_name_mask + strlen (dir_name_mask);\n    if (p > dir_name_mask && !ISSLASH (p[-1]))\n      *p++ = '\\\\';\n    *p++ = '*';\n    *p = '\\0';\n  }\n\n  /* Start searching the directory.  */\n  status = -1;\n  current = FindFirstFile (dir_name_mask, &entry);\n  if (current == INVALID_HANDLE_VALUE)\n    {\n      switch (GetLastError ())\n        {\n        case ERROR_FILE_NOT_FOUND:\n          status = -2;\n          break;\n        case ERROR_PATH_NOT_FOUND:\n          errno = ENOENT;\n          return NULL;\n        case ERROR_DIRECTORY:\n          errno = ENOTDIR;\n          return NULL;\n        case ERROR_ACCESS_DENIED:\n          errno = EACCES;\n          return NULL;\n        default:\n          errno = EIO;\n          return NULL;\n        }\n    }\n\n  /* Allocate the result.  */\n  dirp =\n    (struct gl_directory *)\n    malloc (offsetof (struct gl_directory, dir_name_mask[0])\n            + strlen (dir_name_mask) + 1);\n  if (dirp == NULL)\n    {\n      if (current != INVALID_HANDLE_VALUE)\n        FindClose (current);\n      errno = ENOMEM;\n      return NULL;\n    }\n  dirp->status = status;\n  dirp->current = current;\n  if (status == -1)\n    memcpy (&dirp->entry, &entry, sizeof (WIN32_FIND_DATA));\n  strcpy (dirp->dir_name_mask, dir_name_mask);\n\n#endif\n\n#if REPLACE_FCHDIR\n  {\n    int fd = dirfd (dirp);\n    if (0 <= fd && _gl_register_fd (fd, dir_name) != fd)\n      {\n        int saved_errno = errno;\n        closedir (dirp);\n        errno = saved_errno;\n        return NULL;\n      }\n  }\n#endif\n\n  return dirp;\n}",
      "lines": 106,
      "depth": 15,
      "decorators": [
        "DIR",
        "*\nopendir (const char *dir_name)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/pathmax.h": {},
  "sharutils/sharutils-4.15.2/lib/pipe-safer.c": {
    "pipe_safer": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\npipe_safer (int fd[2])\n{\n#if HAVE_PIPE\n  if (pipe (fd) == 0)\n    {\n      int i;\n      for (i = 0; i < 2; i++)\n        {\n          fd[i] = fd_safer (fd[i]);\n          if (fd[i] < 0)\n            {\n              int e = errno;\n              close (fd[1 - i]);\n              errno = e;\n              return -1;\n            }\n        }\n\n      return 0;\n    }\n#else\n  errno = ENOSYS;\n#endif\n\n  return -1;\n}",
      "lines": 27,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/pipe.h": {},
  "sharutils/sharutils-4.15.2/lib/pipe2-safer.c": {
    "pipe2_safer": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\npipe2_safer (int fd[2], int flags)\n{\n  /* This is a generalization of the pipe_safer implementation.  */\n  if (pipe2 (fd, flags) == 0)\n    {\n      int i;\n      for (i = 0; i < 2; i++)\n        {\n          fd[i] = fd_safer_flag (fd[i], flags);\n          if (fd[i] < 0)\n            {\n              int e = errno;\n              close (fd[1 - i]);\n              errno = e;\n              return -1;\n            }\n        }\n\n      return 0;\n    }\n  return -1;\n}",
      "lines": 23,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/pipe2.c": {
    "pipe2": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "int\npipe2 (int fd[2], int flags)\n{\n  /* Mingw _pipe() corrupts fd on failure; also, if we succeed at\n     creating the pipe but later fail at changing fcntl, we want\n     to leave fd unchanged: http://austingroupbugs.net/view.php?id=467  */\n  int tmp[2];\n  tmp[0] = fd[0];\n  tmp[1] = fd[1];\n\n#if HAVE_PIPE2\n# undef pipe2\n  /* Try the system call first, if it exists.  (We may be running with a glibc\n     that has the function but with an older kernel that lacks it.)  */\n  {\n    /* Cache the information whether the system call really exists.  */\n    static int have_pipe2_really; /* 0 = unknown, 1 = yes, -1 = no */\n    if (have_pipe2_really >= 0)\n      {\n        int result = pipe2 (fd, flags);\n        if (!(result < 0 && errno == ENOSYS))\n          {\n            have_pipe2_really = 1;\n            return result;\n          }\n        have_pipe2_really = -1;\n      }\n  }\n#endif\n\n  /* Check the supported flags.  */\n  if ((flags & ~(O_CLOEXEC | O_NONBLOCK | O_BINARY | O_TEXT)) != 0)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n/* Native Windows API.  */\n\n  if (_pipe (fd, 4096, flags & ~O_NONBLOCK) < 0)\n    {\n      fd[0] = tmp[0];\n      fd[1] = tmp[1];\n      return -1;\n    }\n\n  /* O_NONBLOCK handling.\n     On native Windows platforms, O_NONBLOCK is defined by gnulib.  Use the\n     functions defined by the gnulib module 'nonblocking'.  */\n# if GNULIB_defined_O_NONBLOCK\n  if (flags & O_NONBLOCK)\n    {\n      if (set_nonblocking_flag (fd[0], true) != 0\n          || set_nonblocking_flag (fd[1], true) != 0)\n        goto fail;\n    }\n# else\n  {\n    verify (O_NONBLOCK == 0);\n  }\n# endif\n\n  return 0;\n\n#else\n/* Unix API.  */\n\n  if (pipe (fd) < 0)\n    return -1;\n\n  /* POSIX <http://www.opengroup.org/onlinepubs/9699919799/functions/pipe.html>\n     says that initially, the O_NONBLOCK and FD_CLOEXEC flags are cleared on\n     both fd[0] and fd[1].  */\n\n  /* O_NONBLOCK handling.\n     On Unix platforms, O_NONBLOCK is defined by the system.  Use fcntl().  */\n  if (flags & O_NONBLOCK)\n    {\n      int fcntl_flags;\n\n      if ((fcntl_flags = fcntl (fd[1], F_GETFL, 0)) < 0\n          || fcntl (fd[1], F_SETFL, fcntl_flags | O_NONBLOCK) == -1\n          || (fcntl_flags = fcntl (fd[0], F_GETFL, 0)) < 0\n          || fcntl (fd[0], F_SETFL, fcntl_flags | O_NONBLOCK) == -1)\n        goto fail;\n    }\n\n  if (flags & O_CLOEXEC)\n    {\n      int fcntl_flags;\n\n      if ((fcntl_flags = fcntl (fd[1], F_GETFD, 0)) < 0\n          || fcntl (fd[1], F_SETFD, fcntl_flags | FD_CLOEXEC) == -1\n          || (fcntl_flags = fcntl (fd[0], F_GETFD, 0)) < 0\n          || fcntl (fd[0], F_SETFD, fcntl_flags | FD_CLOEXEC) == -1)\n        goto fail;\n    }\n\n# if O_BINARY\n  if (flags & O_BINARY)\n    {\n      set_binary_mode (fd[1], O_BINARY);\n      set_binary_mode (fd[0], O_BINARY);\n    }\n  else if (flags & O_TEXT)\n    {\n      set_binary_mode (fd[1], O_TEXT);\n      set_binary_mode (fd[0], O_TEXT);\n    }\n# endif\n\n  return 0;\n\n#endif\n\n#if GNULIB_defined_O_NONBLOCK || \\\n  !((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)\n fail:\n  {\n    int saved_errno = errno;\n    close (fd[0]);\n    close (fd[1]);\n    fd[0] = tmp[0];\n    fd[1] = tmp[1];\n    errno = saved_errno;\n    return -1;\n  }\n#endif\n}",
      "lines": 130,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/popen.c": {
    "popen": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "FILE *\npopen (const char *filename, const char *mode)\n{\n  /* Use binary mode by default.  */\n  if (strcmp (mode, \"r\") == 0)\n    mode = \"rb\";\n  else if (strcmp (mode, \"w\") == 0)\n    mode = \"wb\";\n\n  return _popen (filename, mode);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "FILE",
        "*\npopen (const char *filename, const char *mode)",
        "*"
      ]
    },
    "rpl_popen": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "FILE *\nrpl_popen (const char *filename, const char *mode)\n{\n  /* All other platforms have popen and fcntl.\n     The bug of the child clobbering its own file descriptors if stdin\n     or stdout was closed in the parent can be worked around by\n     opening those two fds as close-on-exec to begin with.  */\n  /* Cygwin 1.5.x also has a bug where the popen fd is improperly\n     marked close-on-exec, and if the application undoes this, then\n     the fd leaks into subsequent popen calls.  We could work around\n     this by maintaining a list of all fd's opened by popen, and\n     temporarily marking them cloexec around the real popen call, but\n     we would also have to override pclose, and the bookkeeping seems\n     extreme given that cygwin 1.7 no longer has the bug.  */\n  FILE *result;\n  int cloexec0 = fcntl (STDIN_FILENO, F_GETFD);\n  int cloexec1 = fcntl (STDOUT_FILENO, F_GETFD);\n  int saved_errno;\n\n  /* If either stdin or stdout was closed (that is, fcntl failed),\n     then we open a dummy close-on-exec fd to occupy that slot.  That\n     way, popen's internal use of pipe() will not contain either fd 0\n     or 1, overcoming the fact that the child process blindly calls\n     close() on the parent's end of the pipe without first checking\n     whether it is clobbering the fd just placed there via dup2(); the\n     exec will get rid of the dummy fd's in the child.  Fortunately,\n     closed stderr in the parent does not cause problems in the\n     child.  */\n  if (cloexec0 < 0)\n    {\n      if (open (\"/dev/null\", O_RDONLY) != STDIN_FILENO\n          || fcntl (STDIN_FILENO, F_SETFD,\n                    fcntl (STDIN_FILENO, F_GETFD) | FD_CLOEXEC) == -1)\n        abort ();\n    }\n  if (cloexec1 < 0)\n    {\n      if (open (\"/dev/null\", O_RDONLY) != STDOUT_FILENO\n          || fcntl (STDOUT_FILENO, F_SETFD,\n                    fcntl (STDOUT_FILENO, F_GETFD) | FD_CLOEXEC) == -1)\n        abort ();\n    }\n  result = popen (filename, mode);\n  /* Now, close any dummy fd's created in the parent.  */\n  saved_errno = errno;\n  if (cloexec0 < 0)\n    close (STDIN_FILENO);\n  if (cloexec1 < 0)\n    close (STDOUT_FILENO);\n  errno = saved_errno;\n  return result;\n}",
      "lines": 52,
      "depth": 14,
      "decorators": [
        "FILE",
        "*\nrpl_popen (const char *filename, const char *mode)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/quote.h": {},
  "sharutils/sharutils-4.15.2/lib/quotearg.c": {
    "clone_quoting_options": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "struct quoting_options *\nclone_quoting_options (struct quoting_options *o)\n{\n  int e = errno;\n  struct quoting_options *p = xmemdup (o ? o : &default_quoting_options,\n                                       sizeof *o);\n  errno = e;\n  return p;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "struct quoting_options",
        "struct",
        "quoting_options",
        "*\nclone_quoting_options (struct quoting_options *o)",
        "*"
      ]
    },
    "get_quoting_style": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "enum quoting_style\nget_quoting_style (struct quoting_options *o)\n{\n  return (o ? o : &default_quoting_options)->style;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "enum quoting_style",
        "enum",
        "quoting_style"
      ]
    },
    "set_quoting_style": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "void\nset_quoting_style (struct quoting_options *o, enum quoting_style s)\n{\n  (o ? o : &default_quoting_options)->style = s;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "set_char_quoting": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "int\nset_char_quoting (struct quoting_options *o, char c, int i)\n{\n  unsigned char uc = c;\n  unsigned int *p =\n    (o ? o : &default_quoting_options)->quote_these_too + uc / INT_BITS;\n  int shift = uc % INT_BITS;\n  int r = (*p >> shift) & 1;\n  *p ^= ((i & 1) ^ r) << shift;\n  return r;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "set_quoting_flags": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "int\nset_quoting_flags (struct quoting_options *o, int i)\n{\n  int r;\n  if (!o)\n    o = &default_quoting_options;\n  r = o->flags;\n  o->flags = i;\n  return r;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "set_custom_quoting": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "void\nset_custom_quoting (struct quoting_options *o,\n                    char const *left_quote, char const *right_quote)\n{\n  if (!o)\n    o = &default_quoting_options;\n  o->style = custom_quoting_style;\n  if (!left_quote || !right_quote)\n    abort ();\n  o->left_quote = left_quote;\n  o->right_quote = right_quote;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "quoting_options_from_style": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "static struct quoting_options /* NOT PURE!! */\nquoting_options_from_style (enum quoting_style style)\n{\n  struct quoting_options o = { literal_quoting_style, 0, { 0 }, NULL, NULL };\n  if (style == custom_quoting_style)\n    abort ();\n  o.style = style;\n  return o;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct quoting_options",
        "struct",
        "quoting_options",
        "/* NOT PURE!! */"
      ]
    },
    "gettext_quote": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "static char const *\ngettext_quote (char const *msgid, enum quoting_style s)\n{\n  char const *translation = _(msgid);\n  char const *locale_code;\n\n  if (translation != msgid)\n    return translation;\n\n  /* For UTF-8 and GB-18030, use single quotes U+2018 and U+2019.\n     Here is a list of other locales that include U+2018 and U+2019:\n\n        ISO-8859-7   0xA1                 KOI8-T       0x91\n        CP869        0x8B                 CP874        0x91\n        CP932        0x81 0x65            CP936        0xA1 0xAE\n        CP949        0xA1 0xAE            CP950        0xA1 0xA5\n        CP1250       0x91                 CP1251       0x91\n        CP1252       0x91                 CP1253       0x91\n        CP1254       0x91                 CP1255       0x91\n        CP1256       0x91                 CP1257       0x91\n        EUC-JP       0xA1 0xC6            EUC-KR       0xA1 0xAE\n        EUC-TW       0xA1 0xE4            BIG5         0xA1 0xA5\n        BIG5-HKSCS   0xA1 0xA5            EUC-CN       0xA1 0xAE\n        GBK          0xA1 0xAE            Georgian-PS  0x91\n        PT154        0x91\n\n     None of these is still in wide use; using iconv is overkill.  */\n  locale_code = locale_charset ();\n  if (STRCASEEQ (locale_code, \"UTF-8\", 'U','T','F','-','8',0,0,0,0))\n    return msgid[0] == '`' ? \"\\xe2\\x80\\x98\": \"\\xe2\\x80\\x99\";\n  if (STRCASEEQ (locale_code, \"GB18030\", 'G','B','1','8','0','3','0',0,0))\n    return msgid[0] == '`' ? \"\\xa1\\ae\": \"\\xa1\\xaf\";\n\n  return (s == clocale_quoting_style ? \"\\\"\" : \"'\");\n}",
      "lines": 35,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ngettext_quote (char const *msgid, enum quoting_style s)",
        "*"
      ]
    },
    "quotearg_buffer_restyled": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        660,
        1
      ],
      "content": "static size_t\nquotearg_buffer_restyled (char *buffer, size_t buffersize,\n                          char const *arg, size_t argsize,\n                          enum quoting_style quoting_style, int flags,\n                          unsigned int const *quote_these_too,\n                          char const *left_quote,\n                          char const *right_quote)\n{\n  size_t i;\n  size_t len = 0;\n  char const *quote_string = 0;\n  size_t quote_string_len = 0;\n  bool backslash_escapes = false;\n  bool unibyte_locale = MB_CUR_MAX == 1;\n  bool elide_outer_quotes = (flags & QA_ELIDE_OUTER_QUOTES) != 0;\n\n#define STORE(c) \\\n    do \\\n      { \\\n        if (len < buffersize) \\\n          buffer[len] = (c); \\\n        len++; \\\n      } \\\n    while (0)\n\n  switch (quoting_style)\n    {\n    case c_maybe_quoting_style:\n      quoting_style = c_quoting_style;\n      elide_outer_quotes = true;\n      /* Fall through.  */\n    case c_quoting_style:\n      if (!elide_outer_quotes)\n        STORE ('\"');\n      backslash_escapes = true;\n      quote_string = \"\\\"\";\n      quote_string_len = 1;\n      break;\n\n    case escape_quoting_style:\n      backslash_escapes = true;\n      elide_outer_quotes = false;\n      break;\n\n    case locale_quoting_style:\n    case clocale_quoting_style:\n    case custom_quoting_style:\n      {\n        if (quoting_style != custom_quoting_style)\n          {\n            /* TRANSLATORS:\n               Get translations for open and closing quotation marks.\n               The message catalog should translate \"`\" to a left\n               quotation mark suitable for the locale, and similarly for\n               \"'\".  For example, a French Unicode local should translate\n               these to U+00AB (LEFT-POINTING DOUBLE ANGLE\n               QUOTATION MARK), and U+00BB (RIGHT-POINTING DOUBLE ANGLE\n               QUOTATION MARK), respectively.\n\n               If the catalog has no translation, we will try to\n               use Unicode U+2018 (LEFT SINGLE QUOTATION MARK) and\n               Unicode U+2019 (RIGHT SINGLE QUOTATION MARK).  If the\n               current locale is not Unicode, locale_quoting_style\n               will quote 'like this', and clocale_quoting_style will\n               quote \"like this\".  You should always include translations\n               for \"`\" and \"'\" even if U+2018 and U+2019 are appropriate\n               for your locale.\n\n               If you don't know what to put here, please see\n               <http://en.wikipedia.org/wiki/Quotation_marks_in_other_languages>\n               and use glyphs suitable for your language.  */\n            left_quote = gettext_quote (N_(\"`\"), quoting_style);\n            right_quote = gettext_quote (N_(\"'\"), quoting_style);\n          }\n        if (!elide_outer_quotes)\n          for (quote_string = left_quote; *quote_string; quote_string++)\n            STORE (*quote_string);\n        backslash_escapes = true;\n        quote_string = right_quote;\n        quote_string_len = strlen (quote_string);\n      }\n      break;\n\n    case shell_quoting_style:\n      quoting_style = shell_always_quoting_style;\n      elide_outer_quotes = true;\n      /* Fall through.  */\n    case shell_always_quoting_style:\n      if (!elide_outer_quotes)\n        STORE ('\\'');\n      quote_string = \"'\";\n      quote_string_len = 1;\n      break;\n\n    case literal_quoting_style:\n      elide_outer_quotes = false;\n      break;\n\n    default:\n      abort ();\n    }\n\n  for (i = 0;  ! (argsize == SIZE_MAX ? arg[i] == '\\0' : i == argsize);  i++)\n    {\n      unsigned char c;\n      unsigned char esc;\n      bool is_right_quote = false;\n\n      if (backslash_escapes\n          && quote_string_len\n          && (i + quote_string_len\n              <= (argsize == SIZE_MAX && 1 < quote_string_len\n                  /* Use strlen only if we must: when argsize is SIZE_MAX,\n                     and when the quote string is more than 1 byte long.\n                     If we do call strlen, save the result.  */\n                  ? (argsize = strlen (arg)) : argsize))\n          && memcmp (arg + i, quote_string, quote_string_len) == 0)\n        {\n          if (elide_outer_quotes)\n            goto force_outer_quoting_style;\n          is_right_quote = true;\n        }\n\n      c = arg[i];\n      switch (c)\n        {\n        case '\\0':\n          if (backslash_escapes)\n            {\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n              STORE ('\\\\');\n              /* If quote_string were to begin with digits, we'd need to\n                 test for the end of the arg as well.  However, it's\n                 hard to imagine any locale that would use digits in\n                 quotes, and set_custom_quoting is documented not to\n                 accept them.  */\n              if (i + 1 < argsize && '0' <= arg[i + 1] && arg[i + 1] <= '9')\n                {\n                  STORE ('0');\n                  STORE ('0');\n                }\n              c = '0';\n              /* We don't have to worry that this last '0' will be\n                 backslash-escaped because, again, quote_string should\n                 not start with it and because quote_these_too is\n                 documented as not accepting it.  */\n            }\n          else if (flags & QA_ELIDE_NULL_BYTES)\n            continue;\n          break;\n\n        case '?':\n          switch (quoting_style)\n            {\n            case shell_always_quoting_style:\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n              break;\n\n            case c_quoting_style:\n              if ((flags & QA_SPLIT_TRIGRAPHS)\n                  && i + 2 < argsize && arg[i + 1] == '?')\n                switch (arg[i + 2])\n                  {\n                  case '!': case '\\'':\n                  case '(': case ')': case '-': case '/':\n                  case '<': case '=': case '>':\n                    /* Escape the second '?' in what would otherwise be\n                       a trigraph.  */\n                    if (elide_outer_quotes)\n                      goto force_outer_quoting_style;\n                    c = arg[i + 2];\n                    i += 2;\n                    STORE ('?');\n                    STORE ('\"');\n                    STORE ('\"');\n                    STORE ('?');\n                    break;\n\n                  default:\n                    break;\n                  }\n              break;\n\n            default:\n              break;\n            }\n          break;\n\n        case '\\a': esc = 'a'; goto c_escape;\n        case '\\b': esc = 'b'; goto c_escape;\n        case '\\f': esc = 'f'; goto c_escape;\n        case '\\n': esc = 'n'; goto c_and_shell_escape;\n        case '\\r': esc = 'r'; goto c_and_shell_escape;\n        case '\\t': esc = 't'; goto c_and_shell_escape;\n        case '\\v': esc = 'v'; goto c_escape;\n        case '\\\\': esc = c;\n          /* No need to escape the escape if we are trying to elide\n             outer quotes and nothing else is problematic.  */\n          if (backslash_escapes && elide_outer_quotes && quote_string_len)\n            goto store_c;\n\n        c_and_shell_escape:\n          if (quoting_style == shell_always_quoting_style\n              && elide_outer_quotes)\n            goto force_outer_quoting_style;\n          /* Fall through.  */\n        c_escape:\n          if (backslash_escapes)\n            {\n              c = esc;\n              goto store_escape;\n            }\n          break;\n\n        case '{': case '}': /* sometimes special if isolated */\n          if (! (argsize == SIZE_MAX ? arg[1] == '\\0' : argsize == 1))\n            break;\n          /* Fall through.  */\n        case '#': case '~':\n          if (i != 0)\n            break;\n          /* Fall through.  */\n        case ' ':\n        case '!': /* special in bash */\n        case '\"': case '$': case '&':\n        case '(': case ')': case '*': case ';':\n        case '<':\n        case '=': /* sometimes special in 0th or (with \"set -k\") later args */\n        case '>': case '[':\n        case '^': /* special in old /bin/sh, e.g. SunOS 4.1.4 */\n        case '`': case '|':\n          /* A shell special character.  In theory, '$' and '`' could\n             be the first bytes of multibyte characters, which means\n             we should check them with mbrtowc, but in practice this\n             doesn't happen so it's not worth worrying about.  */\n          if (quoting_style == shell_always_quoting_style\n              && elide_outer_quotes)\n            goto force_outer_quoting_style;\n          break;\n\n        case '\\'':\n          if (quoting_style == shell_always_quoting_style)\n            {\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n              STORE ('\\'');\n              STORE ('\\\\');\n              STORE ('\\'');\n            }\n          break;\n\n        case '%': case '+': case ',': case '-': case '.': case '/':\n        case '0': case '1': case '2': case '3': case '4': case '5':\n        case '6': case '7': case '8': case '9': case ':':\n        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n        case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n        case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n        case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n        case 'Y': case 'Z': case ']': case '_': case 'a': case 'b':\n        case 'c': case 'd': case 'e': case 'f': case 'g': case 'h':\n        case 'i': case 'j': case 'k': case 'l': case 'm': case 'n':\n        case 'o': case 'p': case 'q': case 'r': case 's': case 't':\n        case 'u': case 'v': case 'w': case 'x': case 'y': case 'z':\n          /* These characters don't cause problems, no matter what the\n             quoting style is.  They cannot start multibyte sequences.\n             A digit or a special letter would cause trouble if it\n             appeared at the beginning of quote_string because we'd then\n             escape by prepending a backslash.  However, it's hard to\n             imagine any locale that would use digits or letters as\n             quotes, and set_custom_quoting is documented not to accept\n             them.  Also, a digit or a special letter would cause\n             trouble if it appeared in quote_these_too, but that's also\n             documented as not accepting them.  */\n          break;\n\n        default:\n          /* If we have a multibyte sequence, copy it until we reach\n             its end, find an error, or come back to the initial shift\n             state.  For C-like styles, if the sequence has\n             unprintable characters, escape the whole sequence, since\n             we can't easily escape single characters within it.  */\n          {\n            /* Length of multibyte sequence found so far.  */\n            size_t m;\n\n            bool printable;\n\n            if (unibyte_locale)\n              {\n                m = 1;\n                printable = isprint (c) != 0;\n              }\n            else\n              {\n                mbstate_t mbstate;\n                memset (&mbstate, 0, sizeof mbstate);\n\n                m = 0;\n                printable = true;\n                if (argsize == SIZE_MAX)\n                  argsize = strlen (arg);\n\n                do\n                  {\n                    wchar_t w;\n                    size_t bytes = mbrtowc (&w, &arg[i + m],\n                                            argsize - (i + m), &mbstate);\n                    if (bytes == 0)\n                      break;\n                    else if (bytes == (size_t) -1)\n                      {\n                        printable = false;\n                        break;\n                      }\n                    else if (bytes == (size_t) -2)\n                      {\n                        printable = false;\n                        while (i + m < argsize && arg[i + m])\n                          m++;\n                        break;\n                      }\n                    else\n                      {\n                        /* Work around a bug with older shells that \"see\" a '\\'\n                           that is really the 2nd byte of a multibyte character.\n                           In practice the problem is limited to ASCII\n                           chars >= '@' that are shell special chars.  */\n                        if ('[' == 0x5b && elide_outer_quotes\n                            && quoting_style == shell_always_quoting_style)\n                          {\n                            size_t j;\n                            for (j = 1; j < bytes; j++)\n                              switch (arg[i + m + j])\n                                {\n                                case '[': case '\\\\': case '^':\n                                case '`': case '|':\n                                  goto force_outer_quoting_style;\n\n                                default:\n                                  break;\n                                }\n                          }\n\n                        if (! iswprint (w))\n                          printable = false;\n                        m += bytes;\n                      }\n                  }\n                while (! mbsinit (&mbstate));\n              }\n\n            if (1 < m || (backslash_escapes && ! printable))\n              {\n                /* Output a multibyte sequence, or an escaped\n                   unprintable unibyte character.  */\n                size_t ilim = i + m;\n\n                for (;;)\n                  {\n                    if (backslash_escapes && ! printable)\n                      {\n                        if (elide_outer_quotes)\n                          goto force_outer_quoting_style;\n                        STORE ('\\\\');\n                        STORE ('0' + (c >> 6));\n                        STORE ('0' + ((c >> 3) & 7));\n                        c = '0' + (c & 7);\n                      }\n                    else if (is_right_quote)\n                      {\n                        STORE ('\\\\');\n                        is_right_quote = false;\n                      }\n                    if (ilim <= i + 1)\n                      break;\n                    STORE (c);\n                    c = arg[++i];\n                  }\n\n                goto store_c;\n              }\n          }\n        }\n\n      if (! ((backslash_escapes || elide_outer_quotes)\n             && quote_these_too\n             && quote_these_too[c / INT_BITS] >> (c % INT_BITS) & 1)\n          && !is_right_quote)\n        goto store_c;\n\n    store_escape:\n      if (elide_outer_quotes)\n        goto force_outer_quoting_style;\n      STORE ('\\\\');\n\n    store_c:\n      STORE (c);\n    }\n\n  if (len == 0 && quoting_style == shell_always_quoting_style\n      && elide_outer_quotes)\n    goto force_outer_quoting_style;\n\n  if (quote_string && !elide_outer_quotes)\n    for (; *quote_string; quote_string++)\n      STORE (*quote_string);\n\n  if (len < buffersize)\n    buffer[len] = '\\0';\n  return len;\n\n force_outer_quoting_style:\n  /* Don't reuse quote_these_too, since the addition of outer quotes\n     sufficiently quotes the specified characters.  */\n  return quotearg_buffer_restyled (buffer, buffersize, arg, argsize,\n                                   quoting_style,\n                                   flags & ~QA_ELIDE_OUTER_QUOTES, NULL,\n                                   left_quote, right_quote);\n}",
      "lines": 421,
      "depth": 25,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "quotearg_buffer": {
      "start_point": [
        671,
        0
      ],
      "end_point": [
        683,
        1
      ],
      "content": "size_t\nquotearg_buffer (char *buffer, size_t buffersize,\n                 char const *arg, size_t argsize,\n                 struct quoting_options const *o)\n{\n  struct quoting_options const *p = o ? o : &default_quoting_options;\n  int e = errno;\n  size_t r = quotearg_buffer_restyled (buffer, buffersize, arg, argsize,\n                                       p->style, p->flags, p->quote_these_too,\n                                       p->left_quote, p->right_quote);\n  errno = e;\n  return r;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "quotearg_alloc": {
      "start_point": [
        686,
        0
      ],
      "end_point": [
        691,
        1
      ],
      "content": "char *\nquotearg_alloc (char const *arg, size_t argsize,\n                struct quoting_options const *o)\n{\n  return quotearg_alloc_mem (arg, argsize, NULL, o);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_alloc (char const *arg, size_t argsize,\n                struct quoting_options const *o)",
        "*"
      ]
    },
    "quotearg_alloc_mem": {
      "start_point": [
        699,
        0
      ],
      "end_point": [
        719,
        1
      ],
      "content": "char *\nquotearg_alloc_mem (char const *arg, size_t argsize, size_t *size,\n                    struct quoting_options const *o)\n{\n  struct quoting_options const *p = o ? o : &default_quoting_options;\n  int e = errno;\n  /* Elide embedded null bytes if we can't return a size.  */\n  int flags = p->flags | (size ? 0 : QA_ELIDE_NULL_BYTES);\n  size_t bufsize = quotearg_buffer_restyled (0, 0, arg, argsize, p->style,\n                                             flags, p->quote_these_too,\n                                             p->left_quote,\n                                             p->right_quote) + 1;\n  char *buf = xcharalloc (bufsize);\n  quotearg_buffer_restyled (buf, bufsize, arg, argsize, p->style, flags,\n                            p->quote_these_too,\n                            p->left_quote, p->right_quote);\n  errno = e;\n  if (size)\n    *size = bufsize - 1;\n  return buf;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "char",
        "*\nquotearg_alloc_mem (char const *arg, size_t argsize, size_t *size,\n                    struct quoting_options const *o)",
        "*"
      ]
    },
    "quotearg_free": {
      "start_point": [
        735,
        0
      ],
      "end_point": [
        754,
        1
      ],
      "content": "void\nquotearg_free (void)\n{\n  struct slotvec *sv = slotvec;\n  unsigned int i;\n  for (i = 1; i < nslots; i++)\n    free (sv[i].val);\n  if (sv[0].val != slot0)\n    {\n      free (sv[0].val);\n      slotvec0.size = sizeof slot0;\n      slotvec0.val = slot0;\n    }\n  if (sv != &slotvec0)\n    {\n      free (sv);\n      slotvec = &slotvec0;\n    }\n  nslots = 1;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "quotearg_n_options": {
      "start_point": [
        764,
        0
      ],
      "end_point": [
        822,
        1
      ],
      "content": "static char *\nquotearg_n_options (int n, char const *arg, size_t argsize,\n                    struct quoting_options const *options)\n{\n  int e = errno;\n\n  unsigned int n0 = n;\n  struct slotvec *sv = slotvec;\n\n  if (n < 0)\n    abort ();\n\n  if (nslots <= n0)\n    {\n      /* FIXME: technically, the type of n1 should be 'unsigned int',\n         but that evokes an unsuppressible warning from gcc-4.0.1 and\n         older.  If gcc ever provides an option to suppress that warning,\n         revert to the original type, so that the test in xalloc_oversized\n         is once again performed only at compile time.  */\n      size_t n1 = n0 + 1;\n      bool preallocated = (sv == &slotvec0);\n\n      if (xalloc_oversized (n1, sizeof *sv))\n        xalloc_die ();\n\n      slotvec = sv = xrealloc (preallocated ? NULL : sv, n1 * sizeof *sv);\n      if (preallocated)\n        *sv = slotvec0;\n      memset (sv + nslots, 0, (n1 - nslots) * sizeof *sv);\n      nslots = n1;\n    }\n\n  {\n    size_t size = sv[n].size;\n    char *val = sv[n].val;\n    /* Elide embedded null bytes since we don't return a size.  */\n    int flags = options->flags | QA_ELIDE_NULL_BYTES;\n    size_t qsize = quotearg_buffer_restyled (val, size, arg, argsize,\n                                             options->style, flags,\n                                             options->quote_these_too,\n                                             options->left_quote,\n                                             options->right_quote);\n\n    if (size <= qsize)\n      {\n        sv[n].size = size = qsize + 1;\n        if (val != slot0)\n          free (val);\n        sv[n].val = val = xcharalloc (size);\n        quotearg_buffer_restyled (val, size, arg, argsize, options->style,\n                                  flags, options->quote_these_too,\n                                  options->left_quote,\n                                  options->right_quote);\n      }\n\n    errno = e;\n    return val;\n  }\n}",
      "lines": 59,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nquotearg_n_options (int n, char const *arg, size_t argsize,\n                    struct quoting_options const *options)",
        "*"
      ]
    },
    "quotearg_n": {
      "start_point": [
        824,
        0
      ],
      "end_point": [
        828,
        1
      ],
      "content": "char *\nquotearg_n (int n, char const *arg)\n{\n  return quotearg_n_options (n, arg, SIZE_MAX, &default_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n (int n, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_mem": {
      "start_point": [
        830,
        0
      ],
      "end_point": [
        834,
        1
      ],
      "content": "char *\nquotearg_n_mem (int n, char const *arg, size_t argsize)\n{\n  return quotearg_n_options (n, arg, argsize, &default_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_mem (int n, char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg": {
      "start_point": [
        836,
        0
      ],
      "end_point": [
        840,
        1
      ],
      "content": "char *\nquotearg (char const *arg)\n{\n  return quotearg_n (0, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg (char const *arg)",
        "*"
      ]
    },
    "quotearg_mem": {
      "start_point": [
        842,
        0
      ],
      "end_point": [
        846,
        1
      ],
      "content": "char *\nquotearg_mem (char const *arg, size_t argsize)\n{\n  return quotearg_n_mem (0, arg, argsize);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_mem (char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_n_style": {
      "start_point": [
        848,
        0
      ],
      "end_point": [
        853,
        1
      ],
      "content": "char *\nquotearg_n_style (int n, enum quoting_style s, char const *arg)\n{\n  struct quoting_options const o = quoting_options_from_style (s);\n  return quotearg_n_options (n, arg, SIZE_MAX, &o);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_style (int n, enum quoting_style s, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_style_mem": {
      "start_point": [
        855,
        0
      ],
      "end_point": [
        861,
        1
      ],
      "content": "char *\nquotearg_n_style_mem (int n, enum quoting_style s,\n                      char const *arg, size_t argsize)\n{\n  struct quoting_options const o = quoting_options_from_style (s);\n  return quotearg_n_options (n, arg, argsize, &o);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_style_mem (int n, enum quoting_style s,\n                      char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_style": {
      "start_point": [
        863,
        0
      ],
      "end_point": [
        867,
        1
      ],
      "content": "char *\nquotearg_style (enum quoting_style s, char const *arg)\n{\n  return quotearg_n_style (0, s, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_style (enum quoting_style s, char const *arg)",
        "*"
      ]
    },
    "quotearg_style_mem": {
      "start_point": [
        869,
        0
      ],
      "end_point": [
        873,
        1
      ],
      "content": "char *\nquotearg_style_mem (enum quoting_style s, char const *arg, size_t argsize)\n{\n  return quotearg_n_style_mem (0, s, arg, argsize);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_style_mem (enum quoting_style s, char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_char_mem": {
      "start_point": [
        875,
        0
      ],
      "end_point": [
        882,
        1
      ],
      "content": "char *\nquotearg_char_mem (char const *arg, size_t argsize, char ch)\n{\n  struct quoting_options options;\n  options = default_quoting_options;\n  set_char_quoting (&options, ch, 1);\n  return quotearg_n_options (0, arg, argsize, &options);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_char_mem (char const *arg, size_t argsize, char ch)",
        "*"
      ]
    },
    "quotearg_char": {
      "start_point": [
        884,
        0
      ],
      "end_point": [
        888,
        1
      ],
      "content": "char *\nquotearg_char (char const *arg, char ch)\n{\n  return quotearg_char_mem (arg, SIZE_MAX, ch);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_char (char const *arg, char ch)",
        "*"
      ]
    },
    "quotearg_colon": {
      "start_point": [
        890,
        0
      ],
      "end_point": [
        894,
        1
      ],
      "content": "char *\nquotearg_colon (char const *arg)\n{\n  return quotearg_char (arg, ':');\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_colon (char const *arg)",
        "*"
      ]
    },
    "quotearg_colon_mem": {
      "start_point": [
        896,
        0
      ],
      "end_point": [
        900,
        1
      ],
      "content": "char *\nquotearg_colon_mem (char const *arg, size_t argsize)\n{\n  return quotearg_char_mem (arg, argsize, ':');\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_colon_mem (char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_n_custom": {
      "start_point": [
        902,
        0
      ],
      "end_point": [
        908,
        1
      ],
      "content": "char *\nquotearg_n_custom (int n, char const *left_quote,\n                   char const *right_quote, char const *arg)\n{\n  return quotearg_n_custom_mem (n, left_quote, right_quote, arg,\n                                SIZE_MAX);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_custom (int n, char const *left_quote,\n                   char const *right_quote, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_custom_mem": {
      "start_point": [
        910,
        0
      ],
      "end_point": [
        918,
        1
      ],
      "content": "char *\nquotearg_n_custom_mem (int n, char const *left_quote,\n                       char const *right_quote,\n                       char const *arg, size_t argsize)\n{\n  struct quoting_options o = default_quoting_options;\n  set_custom_quoting (&o, left_quote, right_quote);\n  return quotearg_n_options (n, arg, argsize, &o);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_custom_mem (int n, char const *left_quote,\n                       char const *right_quote,\n                       char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_custom": {
      "start_point": [
        920,
        0
      ],
      "end_point": [
        925,
        1
      ],
      "content": "char *\nquotearg_custom (char const *left_quote, char const *right_quote,\n                 char const *arg)\n{\n  return quotearg_n_custom (0, left_quote, right_quote, arg);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_custom (char const *left_quote, char const *right_quote,\n                 char const *arg)",
        "*"
      ]
    },
    "quotearg_custom_mem": {
      "start_point": [
        927,
        0
      ],
      "end_point": [
        933,
        1
      ],
      "content": "char *\nquotearg_custom_mem (char const *left_quote, char const *right_quote,\n                     char const *arg, size_t argsize)\n{\n  return quotearg_n_custom_mem (0, left_quote, right_quote, arg,\n                                argsize);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_custom_mem (char const *left_quote, char const *right_quote,\n                     char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quote_n_mem": {
      "start_point": [
        945,
        0
      ],
      "end_point": [
        949,
        1
      ],
      "content": "char const *\nquote_n_mem (int n, char const *arg, size_t argsize)\n{\n  return quotearg_n_options (n, arg, argsize, &quote_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote_n_mem (int n, char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quote_mem": {
      "start_point": [
        951,
        0
      ],
      "end_point": [
        955,
        1
      ],
      "content": "char const *\nquote_mem (char const *arg, size_t argsize)\n{\n  return quote_n_mem (0, arg, argsize);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote_mem (char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quote_n": {
      "start_point": [
        957,
        0
      ],
      "end_point": [
        961,
        1
      ],
      "content": "char const *\nquote_n (int n, char const *arg)\n{\n  return quote_n_mem (n, arg, SIZE_MAX);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote_n (int n, char const *arg)",
        "*"
      ]
    },
    "quote": {
      "start_point": [
        963,
        0
      ],
      "end_point": [
        967,
        1
      ],
      "content": "char const *\nquote (char const *arg)\n{\n  return quote_n (0, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote (char const *arg)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/quotearg.h": {},
  "sharutils/sharutils-4.15.2/lib/raise.c": {
    "raise_nothrow": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        42,
        5
      ],
      "content": "static int\nraise_nothrow (int sig)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = raise (sig);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_raise": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int\nrpl_raise (int sig)\n{\n#if GNULIB_defined_signal_blocking && GNULIB_defined_SIGPIPE\n  if (sig == SIGPIPE)\n    return _gl_raise_SIGPIPE ();\n#endif\n\n#if HAVE_RAISE\n  return raise_nothrow (sig);\n#else\n  return kill (getpid (), sig);\n#endif\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/rawmemchr.c": {
    "rawmemchr": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "void *\nrawmemchr (const void *s, int c_in)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       (size_t) char_ptr % sizeof (longword) != 0;\n       ++char_ptr)\n    if (*char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will\n     test a longword at a time.  The tricky part is testing if *any of\n     the four* bytes in the longword in question are equal to NUL or\n     c.  We first use an xor with repeated_c.  This reduces the task\n     to testing whether *any of the four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     The test whether any byte in longword1 is zero is equivalent\n     to testing whether tmp is nonzero.\n\n     This test can read beyond the end of a string, depending on where\n     C_IN is encountered.  However, this is considered safe since the\n     initialization phase ensured that the read will be aligned,\n     therefore, the read will not cross page boundaries and will not\n     cause a fault.  */\n\n  while (1)\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that one of the sizeof (longword) bytes\n     starting at char_ptr is == c.  On little-endian machines, we\n     could determine the first such byte without any further memory\n     accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.\n     Choose code that works in both cases.  */\n\n  char_ptr = (unsigned char *) longword_ptr;\n  while (*char_ptr != c)\n    char_ptr++;\n  return (void *) char_ptr;\n}",
      "lines": 114,
      "depth": 14,
      "decorators": [
        "void",
        "*\nrawmemchr (const void *s, int c_in)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/readdir.c": {
    "readdir": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "struct dirent *\nreaddir (DIR *dirp)\n{\n  char type;\n  struct dirent *result;\n\n  /* There is no need to add code to produce entries for \".\" and \"..\".\n     According to the POSIX:2008 section \"4.12 Pathname Resolution\"\n     <http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html>\n     \".\" and \"..\" are syntactic entities.\n     POSIX also says:\n       \"If entries for dot or dot-dot exist, one entry shall be returned\n        for dot and one entry shall be returned for dot-dot; otherwise,\n        they shall not be returned.\"  */\n\n  switch (dirp->status)\n    {\n    case -2:\n      /* End of directory already reached.  */\n      return NULL;\n    case -1:\n      break;\n    case 0:\n      if (!FindNextFile (dirp->current, &dirp->entry))\n        {\n          switch (GetLastError ())\n            {\n            case ERROR_NO_MORE_FILES:\n              dirp->status = -2;\n              return NULL;\n            default:\n              errno = EIO;\n              return NULL;\n            }\n        }\n      break;\n    default:\n      errno = dirp->status;\n      return NULL;\n    }\n\n  dirp->status = 0;\n\n  if (dirp->entry.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)\n    type = DT_DIR;\n  else if (dirp->entry.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)\n    type = DT_LNK;\n  else if ((dirp->entry.dwFileAttributes\n            & ~(FILE_ATTRIBUTE_READONLY\n                | FILE_ATTRIBUTE_HIDDEN\n                | FILE_ATTRIBUTE_SYSTEM\n                | FILE_ATTRIBUTE_ARCHIVE\n                | FILE_ATTRIBUTE_NORMAL\n                | FILE_ATTRIBUTE_TEMPORARY\n                | FILE_ATTRIBUTE_SPARSE_FILE\n                | FILE_ATTRIBUTE_COMPRESSED\n                | FILE_ATTRIBUTE_NOT_CONTENT_INDEXED\n                | FILE_ATTRIBUTE_ENCRYPTED)) == 0)\n    /* Devices like COM1, LPT1, NUL would also have the attributes 0x20 but\n       they cannot occur here.  */\n    type = DT_REG;\n  else\n    type = DT_UNKNOWN;\n\n  /* Reuse the memory of dirp->entry for the result.  */\n  result =\n    (struct dirent *)\n    ((char *) dirp->entry.cFileName - offsetof (struct dirent, d_name[0]));\n  result->d_type = type;\n\n  return result;\n}",
      "lines": 72,
      "depth": 21,
      "decorators": [
        "struct dirent",
        "struct",
        "dirent",
        "*\nreaddir (DIR *dirp)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/realloc.c": {
    "rpl_realloc": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void *\nrpl_realloc (void *p, size_t n)\n{\n  void *result;\n\n#if NEED_REALLOC_GNU\n  if (n == 0)\n    {\n      n = 1;\n\n      /* In theory realloc might fail, so don't rely on it to free.  */\n      free (p);\n      p = NULL;\n    }\n#endif\n\n  if (p == NULL)\n    {\n#if GNULIB_REALLOC_GNU && !NEED_REALLOC_GNU && !SYSTEM_MALLOC_GLIBC_COMPATIBLE\n      if (n == 0)\n        n = 1;\n#endif\n      result = malloc (n);\n    }\n  else\n    result = realloc (p, n);\n\n#if !HAVE_REALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "void",
        "*\nrpl_realloc (void *p, size_t n)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/rewinddir.c": {
    "rewinddir": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\nrewinddir (DIR *dirp)\n{\n  /* Like in closedir().  */\n  if (dirp->current != INVALID_HANDLE_VALUE)\n    FindClose (dirp->current);\n\n  /* Like in opendir().  */\n  dirp->status = -1;\n  dirp->current = FindFirstFile (dirp->dir_name_mask, &dirp->entry);\n  if (dirp->current == INVALID_HANDLE_VALUE)\n    {\n      switch (GetLastError ())\n        {\n        case ERROR_FILE_NOT_FOUND:\n          dirp->status = -2;\n          break;\n        default:\n          /* Save the error code for the next readdir() call.  */\n          dirp->status = ENOENT;\n          break;\n        }\n    }\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/save-cwd.c": {
    "save_cwd": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nsave_cwd (struct saved_cwd *cwd)\n{\n  cwd->name = NULL;\n\n  cwd->desc = open (\".\", O_SEARCH);\n  if (!GNULIB_FCNTL_SAFER)\n    cwd->desc = fd_safer (cwd->desc);\n  if (cwd->desc < 0)\n    {\n      cwd->name = getcwd (NULL, 0);\n      return cwd->name ? 0 : -1;\n    }\n\n  set_cloexec_flag (cwd->desc, true);\n  return 0;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "restore_cwd": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "int\nrestore_cwd (const struct saved_cwd *cwd)\n{\n  if (0 <= cwd->desc)\n    return fchdir (cwd->desc);\n  else\n    return chdir_long (cwd->name);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "free_cwd": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "void\nfree_cwd (struct saved_cwd *cwd)\n{\n  if (cwd->desc >= 0)\n    close (cwd->desc);\n  free (cwd->name);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/save-cwd.h": {},
  "sharutils/sharutils-4.15.2/lib/sched.in.h": {},
  "sharutils/sharutils-4.15.2/lib/secure_getenv.c": {
    "secure_getenv": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "char *\nsecure_getenv (char const *name)\n{\n#if HAVE___SECURE_GETENV\n  return __secure_getenv (name);\n#else\n  if (issetugid ())\n    return 0;\n  return getenv (name);\n#endif\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "char",
        "*\nsecure_getenv (char const *name)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/sig-handler.c": {},
  "sharutils/sharutils-4.15.2/lib/sig-handler.h": {
    "get_handler": {
      "start_point": [
        36,
        32
      ],
      "end_point": [
        49,
        1
      ],
      "content": "_GL_ATTRIBUTE_PURE\nget_handler (struct sigaction const *a)\n{\n#ifdef SA_SIGINFO\n  /* POSIX says that special values like SIG_IGN can only occur when\n     action.sa_flags does not contain SA_SIGINFO.  But in Linux 2.4,\n     for example, sa_sigaction and sa_handler are aliases and a signal\n     is ignored if sa_sigaction (after casting) equals SIG_IGN.  So\n     use (and cast) sa_sigaction in that case.  */\n  if (a->sa_flags & SA_SIGINFO)\n    return (sa_handler_t) a->sa_sigaction;\n#endif\n  return a->sa_handler;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "_GL_ATTRIBUTE_PURE"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/sigaction.c": {
    "sigaction_handler": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "static void\nsigaction_handler (int sig)\n{\n  handler_t handler;\n  sigset_t mask;\n  sigset_t oldmask;\n  int saved_errno = errno;\n  if (sig < 0 || NSIG <= sig || !action_array[sig].sa_handler)\n    {\n      /* Unexpected situation; be careful to avoid recursive abort.  */\n      if (sig == SIGABRT)\n        signal (SIGABRT, SIG_DFL);\n      abort ();\n    }\n\n  /* Reinstall the signal handler when required; otherwise update the\n     bookkeeping so that the user's handler may call sigaction and get\n     accurate results.  We know the signal isn't currently blocked, or\n     we wouldn't be in its handler, therefore we know that we are not\n     interrupting a sigaction() call.  There is a race where any\n     asynchronous instance of the same signal occurring before we\n     reinstall the handler will trigger the default handler; oh\n     well.  */\n  handler = action_array[sig].sa_handler;\n  if ((action_array[sig].sa_flags & SA_RESETHAND) == 0)\n    signal (sig, sigaction_handler);\n  else\n    action_array[sig].sa_handler = NULL;\n\n  /* Block appropriate signals.  */\n  mask = action_array[sig].sa_mask;\n  if ((action_array[sig].sa_flags & SA_NODEFER) == 0)\n    sigaddset (&mask, sig);\n  sigprocmask (SIG_BLOCK, &mask, &oldmask);\n\n  /* Invoke the user's handler, then restore prior mask.  */\n  errno = saved_errno;\n  handler (sig);\n  saved_errno = errno;\n  sigprocmask (SIG_SETMASK, &oldmask, NULL);\n  errno = saved_errno;\n}",
      "lines": 42,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sigaction": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "int\nsigaction (int sig, const struct sigaction *restrict act,\n           struct sigaction *restrict oact)\n{\n  sigset_t mask;\n  sigset_t oldmask;\n  int saved_errno;\n\n  if (sig < 0 || NSIG <= sig || sig == SIGKILL || sig == SIGSTOP\n      || (act && act->sa_handler == SIG_ERR))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n#ifdef SIGABRT_COMPAT\n  if (sig == SIGABRT_COMPAT)\n    sig = SIGABRT;\n#endif\n\n  /* POSIX requires sigaction() to be async-signal-safe.  In other\n     words, if an asynchronous signal can occur while we are anywhere\n     inside this function, the user's handler could then call\n     sigaction() recursively and expect consistent results.  We meet\n     this rule by using sigprocmask to block all signals before\n     modifying any data structure that could be read from a signal\n     handler; this works since we know that the gnulib sigprocmask\n     replacement does not try to use sigaction() from its handler.  */\n  if (!act && !oact)\n    return 0;\n  sigfillset (&mask);\n  sigprocmask (SIG_BLOCK, &mask, &oldmask);\n  if (oact)\n    {\n      if (action_array[sig].sa_handler)\n        *oact = action_array[sig];\n      else\n        {\n          /* Safe to change the handler at will here, since all\n             signals are currently blocked.  */\n          oact->sa_handler = signal (sig, SIG_DFL);\n          if (oact->sa_handler == SIG_ERR)\n            goto failure;\n          signal (sig, oact->sa_handler);\n          oact->sa_flags = SA_RESETHAND | SA_NODEFER;\n          sigemptyset (&oact->sa_mask);\n        }\n    }\n\n  if (act)\n    {\n      /* Safe to install the handler before updating action_array,\n         since all signals are currently blocked.  */\n      if (act->sa_handler == SIG_DFL || act->sa_handler == SIG_IGN)\n        {\n          if (signal (sig, act->sa_handler) == SIG_ERR)\n            goto failure;\n          action_array[sig].sa_handler = NULL;\n        }\n      else\n        {\n          if (signal (sig, sigaction_handler) == SIG_ERR)\n            goto failure;\n          action_array[sig] = *act;\n        }\n    }\n  sigprocmask (SIG_SETMASK, &oldmask, NULL);\n  return 0;\n\n failure:\n  saved_errno = errno;\n  sigprocmask (SIG_SETMASK, &oldmask, NULL);\n  errno = saved_errno;\n  return -1;\n}",
      "lines": 75,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/signal.in.h": {},
  "sharutils/sharutils-4.15.2/lib/sigprocmask.c": {
    "signal_nothrow": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        73,
        5
      ],
      "content": "static handler_t\nsignal_nothrow (int sig, handler_t handler)\n{\n  handler_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = signal (sig, handler);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "handler_t"
      ]
    },
    "ext_signal": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static handler_t\next_signal (int sig, handler_t handler)\n{\n  switch (sig)\n    {\n    case SIGPIPE:\n      {\n        handler_t old_handler = SIGPIPE_handler;\n        SIGPIPE_handler = handler;\n        return old_handler;\n      }\n    default: /* System defined signal */\n      return signal (sig, handler);\n    }\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "handler_t"
      ]
    },
    "sigismember": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "int\nsigismember (const sigset_t *set, int sig)\n{\n  if (sig >= 0 && sig < NSIG)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      return (*set >> sig) & 1;\n    }\n  else\n    return 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "sigemptyset": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "int\nsigemptyset (sigset_t *set)\n{\n  *set = 0;\n  return 0;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "sigaddset": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "int\nsigaddset (sigset_t *set, int sig)\n{\n  if (sig >= 0 && sig < NSIG)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      *set |= 1U << sig;\n      return 0;\n    }\n  else\n    {\n      errno = EINVAL;\n      return -1;\n    }\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "sigdelset": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "int\nsigdelset (sigset_t *set, int sig)\n{\n  if (sig >= 0 && sig < NSIG)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      *set &= ~(1U << sig);\n      return 0;\n    }\n  else\n    {\n      errno = EINVAL;\n      return -1;\n    }\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "sigfillset": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "int\nsigfillset (sigset_t *set)\n{\n  *set = ((2U << (NSIG - 1)) - 1) & ~ SIGABRT_COMPAT_MASK;\n  return 0;\n}",
      "lines": 6,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "blocked_handler": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "static void\nblocked_handler (int sig)\n{\n  /* Reinstall the handler, in case the signal occurs multiple times\n     while blocked.  There is an inherent race where an asynchronous\n     signal in between when the kernel uninstalled the handler and\n     when we reinstall it will trigger the default handler; oh\n     well.  */\n  signal (sig, blocked_handler);\n  if (sig >= 0 && sig < NSIG)\n    pending_array[sig] = 1;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sigpending": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "int\nsigpending (sigset_t *set)\n{\n  sigset_t pending = 0;\n  int sig;\n\n  for (sig = 0; sig < NSIG; sig++)\n    if (pending_array[sig])\n      pending |= 1U << sig;\n  *set = pending;\n  return 0;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "sigprocmask": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "int\nsigprocmask (int operation, const sigset_t *set, sigset_t *old_set)\n{\n  if (old_set != NULL)\n    *old_set = blocked_set;\n\n  if (set != NULL)\n    {\n      sigset_t new_blocked_set;\n      sigset_t to_unblock;\n      sigset_t to_block;\n\n      switch (operation)\n        {\n        case SIG_BLOCK:\n          new_blocked_set = blocked_set | *set;\n          break;\n        case SIG_SETMASK:\n          new_blocked_set = *set;\n          break;\n        case SIG_UNBLOCK:\n          new_blocked_set = blocked_set & ~*set;\n          break;\n        default:\n          errno = EINVAL;\n          return -1;\n        }\n      to_unblock = blocked_set & ~new_blocked_set;\n      to_block = new_blocked_set & ~blocked_set;\n\n      if (to_block != 0)\n        {\n          int sig;\n\n          for (sig = 0; sig < NSIG; sig++)\n            if ((to_block >> sig) & 1)\n              {\n                pending_array[sig] = 0;\n                if ((old_handlers[sig] = signal (sig, blocked_handler)) != SIG_ERR)\n                  blocked_set |= 1U << sig;\n              }\n        }\n\n      if (to_unblock != 0)\n        {\n          sig_atomic_t received[NSIG];\n          int sig;\n\n          for (sig = 0; sig < NSIG; sig++)\n            if ((to_unblock >> sig) & 1)\n              {\n                if (signal (sig, old_handlers[sig]) != blocked_handler)\n                  /* The application changed a signal handler while the signal\n                     was blocked, bypassing our rpl_signal replacement.\n                     We don't support this.  */\n                  abort ();\n                received[sig] = pending_array[sig];\n                blocked_set &= ~(1U << sig);\n                pending_array[sig] = 0;\n              }\n            else\n              received[sig] = 0;\n\n          for (sig = 0; sig < NSIG; sig++)\n            if (received[sig])\n              raise (sig);\n        }\n    }\n  return 0;\n}",
      "lines": 70,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "rpl_signal": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "handler_t\nrpl_signal (int sig, handler_t handler)\n{\n  /* We must provide a wrapper, so that a user can query what handler\n     they installed even if that signal is currently blocked.  */\n  if (sig >= 0 && sig < NSIG && sig != SIGKILL && sig != SIGSTOP\n      && handler != SIG_ERR)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      if (blocked_set & (1U << sig))\n        {\n          /* POSIX states that sigprocmask and signal are both\n             async-signal-safe.  This is not true of our\n             implementation - there is a slight data race where an\n             asynchronous interrupt on signal A can occur after we\n             install blocked_handler but before we have updated\n             old_handlers for signal B, such that handler A can see\n             stale information if it calls signal(B).  Oh well -\n             signal handlers really shouldn't try to manipulate the\n             installed handlers of unrelated signals.  */\n          handler_t result = old_handlers[sig];\n          old_handlers[sig] = handler;\n          return result;\n        }\n      else\n        return signal (sig, handler);\n    }\n  else\n    {\n      errno = EINVAL;\n      return SIG_ERR;\n    }\n}",
      "lines": 37,
      "depth": 10,
      "decorators": [
        "handler_t"
      ]
    },
    "_gl_raise_SIGPIPE": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        347,
        1
      ],
      "content": "int\n_gl_raise_SIGPIPE (void)\n{\n  if (blocked_set & (1U << SIGPIPE))\n    pending_array[SIGPIPE] = 1;\n  else\n    {\n      handler_t handler = SIGPIPE_handler;\n      if (handler == SIG_DFL)\n        exit (128 + SIGPIPE);\n      else if (handler != SIG_IGN)\n        (*handler) (SIGPIPE);\n    }\n  return 0;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/sockets.c": {
    "close_fd_maybe_socket": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static int\nclose_fd_maybe_socket (const struct fd_hook *remaining_list,\n                       gl_close_fn primary,\n                       int fd)\n{\n  /* Note about multithread-safety: There is a race condition where, between\n     our calls to closesocket() and the primary close(), some other thread\n     could make system calls that allocate precisely the same HANDLE value\n     as sock; then the primary close() would call CloseHandle() on it.  */\n  SOCKET sock;\n  WSANETWORKEVENTS ev;\n\n  /* Test whether fd refers to a socket.  */\n  sock = FD_TO_SOCKET (fd);\n  ev.lNetworkEvents = 0xDEADBEEF;\n  WSAEnumNetworkEvents (sock, NULL, &ev);\n  if (ev.lNetworkEvents != 0xDEADBEEF)\n    {\n      /* fd refers to a socket.  */\n      /* FIXME: other applications, like squid, use an undocumented\n         _free_osfhnd free function.  But this is not enough: The 'osfile'\n         flags for fd also needs to be cleared, but it is hard to access it.\n         Instead, here we just close twice the file descriptor.  */\n      if (closesocket (sock))\n        {\n          set_winsock_errno ();\n          return -1;\n        }\n      else\n        {\n          /* This call frees the file descriptor and does a\n             CloseHandle ((HANDLE) _get_osfhandle (fd)), which fails.  */\n          _close (fd);\n          return 0;\n        }\n    }\n  else\n    /* Some other type of file descriptor.  */\n    return execute_close_hooks (remaining_list, primary, fd);\n}",
      "lines": 40,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ioctl_fd_maybe_socket": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "static int\nioctl_fd_maybe_socket (const struct fd_hook *remaining_list,\n                       gl_ioctl_fn primary,\n                       int fd, int request, void *arg)\n{\n  SOCKET sock;\n  WSANETWORKEVENTS ev;\n\n  /* Test whether fd refers to a socket.  */\n  sock = FD_TO_SOCKET (fd);\n  ev.lNetworkEvents = 0xDEADBEEF;\n  WSAEnumNetworkEvents (sock, NULL, &ev);\n  if (ev.lNetworkEvents != 0xDEADBEEF)\n    {\n      /* fd refers to a socket.  */\n      if (ioctlsocket (sock, request, arg) < 0)\n        {\n          set_winsock_errno ();\n          return -1;\n        }\n      else\n        return 0;\n    }\n  else\n    /* Some other type of file descriptor.  */\n    return execute_ioctl_hooks (remaining_list, primary, fd, request, arg);\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gl_sockets_startup": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "int\ngl_sockets_startup (int version _GL_UNUSED)\n{\n#if WINDOWS_SOCKETS\n  if (version > initialized_sockets_version)\n    {\n      WSADATA data;\n      int err;\n\n      err = WSAStartup (version, &data);\n      if (err != 0)\n        return 1;\n\n      if (data.wVersion < version)\n        return 2;\n\n      if (initialized_sockets_version == 0)\n        register_fd_hook (close_fd_maybe_socket, ioctl_fd_maybe_socket,\n                          &fd_sockets_hook);\n\n      initialized_sockets_version = version;\n    }\n#endif\n\n  return 0;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "gl_sockets_cleanup": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "int\ngl_sockets_cleanup (void)\n{\n#if WINDOWS_SOCKETS\n  int err;\n\n  initialized_sockets_version = 0;\n\n  unregister_fd_hook (&fd_sockets_hook);\n\n  err = WSACleanup ();\n  if (err != 0)\n    return 1;\n#endif\n\n  return 0;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/sockets.h": {
    "gl_fd_to_handle": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static inline SOCKET\ngl_fd_to_handle (int fd)\n{\n  return _get_osfhandle (fd);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "SOCKET"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/spawn-pipe.c": {
    "nonintr_close": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static int\nnonintr_close (int fd)\n{\n  int retval;\n\n  do\n    retval = close (fd);\n  while (retval < 0 && errno == EINTR);\n\n  return retval;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "nonintr_open": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static int\nnonintr_open (const char *pathname, int oflag, mode_t mode)\n{\n  int retval;\n\n  do\n    retval = open (pathname, oflag, mode);\n  while (retval < 0 && errno == EINTR);\n\n  return retval;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "create_pipe": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        376,
        1
      ],
      "content": "static pid_t\ncreate_pipe (const char *progname,\n             const char *prog_path, char **prog_argv,\n             bool pipe_stdin, bool pipe_stdout,\n             const char *prog_stdin, const char *prog_stdout,\n             bool null_stderr,\n             bool slave_process, bool exit_on_error,\n             int fd[2])\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n\n  /* Native Windows API.\n     This uses _pipe(), dup2(), and spawnv().  It could also be implemented\n     using the low-level functions CreatePipe(), DuplicateHandle(),\n     CreateProcess() and _open_osfhandle(); see the GNU make and GNU clisp\n     and cvs source code.  */\n  int ifd[2];\n  int ofd[2];\n  int orig_stdin;\n  int orig_stdout;\n  int orig_stderr;\n  int child;\n  int nulloutfd;\n  int stdinfd;\n  int stdoutfd;\n  int saved_errno;\n\n  /* FIXME: Need to free memory allocated by prepare_spawn.  */\n  prog_argv = prepare_spawn (prog_argv);\n\n  if (pipe_stdout)\n    if (pipe2_safer (ifd, O_BINARY | O_CLOEXEC) < 0)\n      error (EXIT_FAILURE, errno, _(\"cannot create pipe\"));\n  if (pipe_stdin)\n    if (pipe2_safer (ofd, O_BINARY | O_CLOEXEC) < 0)\n      error (EXIT_FAILURE, errno, _(\"cannot create pipe\"));\n/* Data flow diagram:\n *\n *           write        system         read\n *    parent  ->   ofd[1]   ->   ofd[0]   ->   child       if pipe_stdin\n *    parent  <-   ifd[0]   <-   ifd[1]   <-   child       if pipe_stdout\n *           read         system         write\n *\n */\n\n  /* Save standard file handles of parent process.  */\n  if (pipe_stdin || prog_stdin != NULL)\n    orig_stdin = dup_safer_noinherit (STDIN_FILENO);\n  if (pipe_stdout || prog_stdout != NULL)\n    orig_stdout = dup_safer_noinherit (STDOUT_FILENO);\n  if (null_stderr)\n    orig_stderr = dup_safer_noinherit (STDERR_FILENO);\n  child = -1;\n\n  /* Create standard file handles of child process.  */\n  nulloutfd = -1;\n  stdinfd = -1;\n  stdoutfd = -1;\n  if ((!pipe_stdin || dup2 (ofd[0], STDIN_FILENO) >= 0)\n      && (!pipe_stdout || dup2 (ifd[1], STDOUT_FILENO) >= 0)\n      && (!null_stderr\n          || ((nulloutfd = open (\"NUL\", O_RDWR, 0)) >= 0\n              && (nulloutfd == STDERR_FILENO\n                  || (dup2 (nulloutfd, STDERR_FILENO) >= 0\n                      && close (nulloutfd) >= 0))))\n      && (pipe_stdin\n          || prog_stdin == NULL\n          || ((stdinfd = open (prog_stdin, O_RDONLY, 0)) >= 0\n              && (stdinfd == STDIN_FILENO\n                  || (dup2 (stdinfd, STDIN_FILENO) >= 0\n                      && close (stdinfd) >= 0))))\n      && (pipe_stdout\n          || prog_stdout == NULL\n          || ((stdoutfd = open (prog_stdout, O_WRONLY, 0)) >= 0\n              && (stdoutfd == STDOUT_FILENO\n                  || (dup2 (stdoutfd, STDOUT_FILENO) >= 0\n                      && close (stdoutfd) >= 0)))))\n    /* The child process doesn't inherit ifd[0], ifd[1], ofd[0], ofd[1],\n       but it inherits all open()ed or dup2()ed file handles (which is what\n       we want in the case of STD*_FILENO).  */\n    /* Use spawnvpe and pass the environment explicitly.  This is needed if\n       the program has modified the environment using putenv() or [un]setenv().\n       On Windows, programs have two environments, one in the \"environment\n       block\" of the process and managed through SetEnvironmentVariable(), and\n       one inside the process, in the location retrieved by the 'environ'\n       macro.  When using spawnvp() without 'e', the child process inherits a\n       copy of the environment block - ignoring the effects of putenv() and\n       [un]setenv().  */\n    {\n      child = spawnvpe (P_NOWAIT, prog_path, (const char **) prog_argv,\n                        (const char **) environ);\n      if (child < 0 && errno == ENOEXEC)\n        {\n          /* prog is not a native executable.  Try to execute it as a\n             shell script.  Note that prepare_spawn() has already prepended\n             a hidden element \"sh.exe\" to prog_argv.  */\n          --prog_argv;\n          child = spawnvpe (P_NOWAIT, prog_argv[0], (const char **) prog_argv,\n                            (const char **) environ);\n        }\n    }\n  if (child == -1)\n    saved_errno = errno;\n  if (stdinfd >= 0)\n    close (stdinfd);\n  if (stdoutfd >= 0)\n    close (stdoutfd);\n  if (nulloutfd >= 0)\n    close (nulloutfd);\n\n  /* Restore standard file handles of parent process.  */\n  if (null_stderr)\n    undup_safer_noinherit (orig_stderr, STDERR_FILENO);\n  if (pipe_stdout || prog_stdout != NULL)\n    undup_safer_noinherit (orig_stdout, STDOUT_FILENO);\n  if (pipe_stdin || prog_stdin != NULL)\n    undup_safer_noinherit (orig_stdin, STDIN_FILENO);\n\n  if (pipe_stdin)\n    close (ofd[0]);\n  if (pipe_stdout)\n    close (ifd[1]);\n  if (child == -1)\n    {\n      if (exit_on_error || !null_stderr)\n        error (exit_on_error ? EXIT_FAILURE : 0, saved_errno,\n               _(\"%s subprocess failed\"), progname);\n      if (pipe_stdout)\n        close (ifd[0]);\n      if (pipe_stdin)\n        close (ofd[1]);\n      errno = saved_errno;\n      return -1;\n    }\n\n  if (pipe_stdout)\n    fd[0] = ifd[0];\n  if (pipe_stdin)\n    fd[1] = ofd[1];\n  return child;\n\n#else\n\n  /* Unix API.  */\n  int ifd[2];\n  int ofd[2];\n  sigset_t blocked_signals;\n  posix_spawn_file_actions_t actions;\n  bool actions_allocated;\n  posix_spawnattr_t attrs;\n  bool attrs_allocated;\n  int err;\n  pid_t child;\n\n  if (pipe_stdout)\n    if (pipe_safer (ifd) < 0)\n      error (EXIT_FAILURE, errno, _(\"cannot create pipe\"));\n  if (pipe_stdin)\n    if (pipe_safer (ofd) < 0)\n      error (EXIT_FAILURE, errno, _(\"cannot create pipe\"));\n/* Data flow diagram:\n *\n *           write        system         read\n *    parent  ->   ofd[1]   ->   ofd[0]   ->   child       if pipe_stdin\n *    parent  <-   ifd[0]   <-   ifd[1]   <-   child       if pipe_stdout\n *           read         system         write\n *\n */\n\n  if (slave_process)\n    {\n      sigprocmask (SIG_SETMASK, NULL, &blocked_signals);\n      block_fatal_signals ();\n    }\n  actions_allocated = false;\n  attrs_allocated = false;\n  if ((err = posix_spawn_file_actions_init (&actions)) != 0\n      || (actions_allocated = true,\n          (pipe_stdin\n           && (err = posix_spawn_file_actions_adddup2 (&actions,\n                                                       ofd[0], STDIN_FILENO))\n              != 0)\n          || (pipe_stdout\n              && (err = posix_spawn_file_actions_adddup2 (&actions,\n                                                          ifd[1], STDOUT_FILENO))\n                 != 0)\n          || (pipe_stdin\n              && (err = posix_spawn_file_actions_addclose (&actions, ofd[0]))\n                 != 0)\n          || (pipe_stdout\n              && (err = posix_spawn_file_actions_addclose (&actions, ifd[1]))\n                 != 0)\n          || (pipe_stdin\n              && (err = posix_spawn_file_actions_addclose (&actions, ofd[1]))\n                 != 0)\n          || (pipe_stdout\n              && (err = posix_spawn_file_actions_addclose (&actions, ifd[0]))\n                 != 0)\n          || (null_stderr\n              && (err = posix_spawn_file_actions_addopen (&actions,\n                                                          STDERR_FILENO,\n                                                          \"/dev/null\", O_RDWR,\n                                                          0))\n                 != 0)\n          || (!pipe_stdin\n              && prog_stdin != NULL\n              && (err = posix_spawn_file_actions_addopen (&actions,\n                                                          STDIN_FILENO,\n                                                          prog_stdin, O_RDONLY,\n                                                          0))\n                 != 0)\n          || (!pipe_stdout\n              && prog_stdout != NULL\n              && (err = posix_spawn_file_actions_addopen (&actions,\n                                                          STDOUT_FILENO,\n                                                          prog_stdout, O_WRONLY,\n                                                          0))\n                 != 0)\n          || (slave_process\n              && ((err = posix_spawnattr_init (&attrs)) != 0\n                  || (attrs_allocated = true,\n                      (err = posix_spawnattr_setsigmask (&attrs,\n                                                         &blocked_signals))\n                      != 0\n                      || (err = posix_spawnattr_setflags (&attrs,\n                                                        POSIX_SPAWN_SETSIGMASK))\n                         != 0)))\n          || (err = posix_spawnp (&child, prog_path, &actions,\n                                  attrs_allocated ? &attrs : NULL, prog_argv,\n                                  environ))\n             != 0))\n    {\n      if (actions_allocated)\n        posix_spawn_file_actions_destroy (&actions);\n      if (attrs_allocated)\n        posix_spawnattr_destroy (&attrs);\n      if (slave_process)\n        unblock_fatal_signals ();\n      if (exit_on_error || !null_stderr)\n        error (exit_on_error ? EXIT_FAILURE : 0, err,\n               _(\"%s subprocess failed\"), progname);\n      if (pipe_stdout)\n        {\n          close (ifd[0]);\n          close (ifd[1]);\n        }\n      if (pipe_stdin)\n        {\n          close (ofd[0]);\n          close (ofd[1]);\n        }\n      errno = err;\n      return -1;\n    }\n  posix_spawn_file_actions_destroy (&actions);\n  if (attrs_allocated)\n    posix_spawnattr_destroy (&attrs);\n  if (slave_process)\n    {\n      register_slave_subprocess (child);\n      unblock_fatal_signals ();\n    }\n  if (pipe_stdin)\n    close (ofd[0]);\n  if (pipe_stdout)\n    close (ifd[1]);\n\n  if (pipe_stdout)\n    fd[0] = ifd[0];\n  if (pipe_stdin)\n    fd[1] = ofd[1];\n  return child;\n\n#endif\n}",
      "lines": 275,
      "depth": 28,
      "decorators": [
        "static",
        "static",
        "pid_t"
      ]
    },
    "create_pipe_bidi": {
      "start_point": [
        386,
        0
      ],
      "end_point": [
        398,
        1
      ],
      "content": "pid_t\ncreate_pipe_bidi (const char *progname,\n                  const char *prog_path, char **prog_argv,\n                  bool null_stderr,\n                  bool slave_process, bool exit_on_error,\n                  int fd[2])\n{\n  pid_t result = create_pipe (progname, prog_path, prog_argv,\n                              true, true, NULL, NULL,\n                              null_stderr, slave_process, exit_on_error,\n                              fd);\n  return result;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "pid_t"
      ]
    },
    "create_pipe_in": {
      "start_point": [
        407,
        0
      ],
      "end_point": [
        422,
        1
      ],
      "content": "pid_t\ncreate_pipe_in (const char *progname,\n                const char *prog_path, char **prog_argv,\n                const char *prog_stdin, bool null_stderr,\n                bool slave_process, bool exit_on_error,\n                int fd[1])\n{\n  int iofd[2];\n  pid_t result = create_pipe (progname, prog_path, prog_argv,\n                              false, true, prog_stdin, NULL,\n                              null_stderr, slave_process, exit_on_error,\n                              iofd);\n  if (result != -1)\n    fd[0] = iofd[0];\n  return result;\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "pid_t"
      ]
    },
    "create_pipe_out": {
      "start_point": [
        431,
        0
      ],
      "end_point": [
        446,
        1
      ],
      "content": "pid_t\ncreate_pipe_out (const char *progname,\n                 const char *prog_path, char **prog_argv,\n                 const char *prog_stdout, bool null_stderr,\n                 bool slave_process, bool exit_on_error,\n                 int fd[1])\n{\n  int iofd[2];\n  pid_t result = create_pipe (progname, prog_path, prog_argv,\n                              true, false, NULL, prog_stdout,\n                              null_stderr, slave_process, exit_on_error,\n                              iofd);\n  if (result != -1)\n    fd[0] = iofd[1];\n  return result;\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "pid_t"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/spawn-pipe.h": {},
  "sharutils/sharutils-4.15.2/lib/spawn.in.h": {},
  "sharutils/sharutils-4.15.2/lib/spawnattr_destroy.c": {
    "posix_spawnattr_destroy": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "int\nposix_spawnattr_destroy (posix_spawnattr_t *attr)\n{\n  /* Nothing to do in the moment.  */\n  return 0;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/spawnattr_init.c": {
    "posix_spawnattr_init": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nposix_spawnattr_init (posix_spawnattr_t *attr)\n{\n  /* All elements have to be initialized to the default values which\n     is generally zero.  */\n  memset (attr, '\\0', sizeof (*attr));\n\n  return 0;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/spawnattr_setflags.c": {
    "posix_spawnattr_setflags": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "int\nposix_spawnattr_setflags (posix_spawnattr_t *attr, short int flags)\n{\n  /* Check no invalid bits are set.  */\n  if (flags & ~ALL_FLAGS)\n    return EINVAL;\n\n  /* Store the flag word.  */\n  attr->_flags = flags;\n\n  return 0;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/spawnattr_setsigmask.c": {
    "posix_spawnattr_setsigmask": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nposix_spawnattr_setsigmask (posix_spawnattr_t *attr,\n                            const sigset_t *sigmask)\n{\n  /* Copy the sigset_t data to the user buffer.  */\n  memcpy (&attr->_ss, sigmask, sizeof (sigset_t));\n\n  return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/spawni.c": {
    "__spawni": [
      {
        "start_point": [
          94,
          0
        ],
        "end_point": [
          102,
          1
        ],
        "content": "int\n__spawni (pid_t *pid, const char *file,\n          const posix_spawn_file_actions_t *file_actions,\n          const posix_spawnattr_t *attrp, char *const argv[],\n          char *const envp[], int use_path)\n{\n  /* Not yet implemented.  */\n  return ENOSYS;\n}",
        "lines": 9,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          137,
          0
        ],
        "end_point": [
          371,
          1
        ],
        "content": "int\n__spawni (pid_t *pid, const char *file,\n          const posix_spawn_file_actions_t *file_actions,\n          const posix_spawnattr_t *attrp, char *const argv[],\n          char *const envp[], int use_path)\n{\n  pid_t new_pid;\n  char *path, *p, *name;\n  size_t len;\n  size_t pathlen;\n\n  /* Do this once.  */\n  short int flags = attrp == NULL ? 0 : attrp->_flags;\n\n  /* Avoid gcc warning\n       \"variable 'flags' might be clobbered by 'longjmp' or 'vfork'\"  */\n  (void) &flags;\n\n  /* Generate the new process.  */\n#if HAVE_VFORK\n  if ((flags & POSIX_SPAWN_USEVFORK) != 0\n      /* If no major work is done, allow using vfork.  Note that we\n         might perform the path searching.  But this would be done by\n         a call to execvp(), too, and such a call must be OK according\n         to POSIX.  */\n      || ((flags & (POSIX_SPAWN_SETSIGMASK | POSIX_SPAWN_SETSIGDEF\n                    | POSIX_SPAWN_SETSCHEDPARAM | POSIX_SPAWN_SETSCHEDULER\n                    | POSIX_SPAWN_SETPGROUP | POSIX_SPAWN_RESETIDS)) == 0\n          && file_actions == NULL))\n    new_pid = vfork ();\n  else\n#endif\n    new_pid = fork ();\n\n  if (new_pid != 0)\n    {\n      if (new_pid < 0)\n        return errno;\n\n      /* The call was successful.  Store the PID if necessary.  */\n      if (pid != NULL)\n        *pid = new_pid;\n\n      return 0;\n    }\n\n  /* Set signal mask.  */\n  if ((flags & POSIX_SPAWN_SETSIGMASK) != 0\n      && sigprocmask (SIG_SETMASK, &attrp->_ss, NULL) != 0)\n    _exit (SPAWN_ERROR);\n\n  /* Set signal default action.  */\n  if ((flags & POSIX_SPAWN_SETSIGDEF) != 0)\n    {\n      /* We have to iterate over all signals.  This could possibly be\n         done better but it requires system specific solutions since\n         the sigset_t data type can be very different on different\n         architectures.  */\n      int sig;\n      struct sigaction sa;\n\n      memset (&sa, '\\0', sizeof (sa));\n      sa.sa_handler = SIG_DFL;\n\n      for (sig = 1; sig <= NSIG; ++sig)\n        if (sigismember (&attrp->_sd, sig) != 0\n            && sigaction (sig, &sa, NULL) != 0)\n          _exit (SPAWN_ERROR);\n\n    }\n\n#if (_LIBC ? defined _POSIX_PRIORITY_SCHEDULING : HAVE_SCHED_SETPARAM && HAVE_SCHED_SETSCHEDULER)\n  /* Set the scheduling algorithm and parameters.  */\n  if ((flags & (POSIX_SPAWN_SETSCHEDPARAM | POSIX_SPAWN_SETSCHEDULER))\n      == POSIX_SPAWN_SETSCHEDPARAM)\n    {\n      if (sched_setparam (0, &attrp->_sp) == -1)\n        _exit (SPAWN_ERROR);\n    }\n  else if ((flags & POSIX_SPAWN_SETSCHEDULER) != 0)\n    {\n      if (sched_setscheduler (0, attrp->_policy,\n                              (flags & POSIX_SPAWN_SETSCHEDPARAM) != 0\n                              ? &attrp->_sp : NULL) == -1)\n        _exit (SPAWN_ERROR);\n    }\n#endif\n\n  /* Set the process group ID.  */\n  if ((flags & POSIX_SPAWN_SETPGROUP) != 0\n      && setpgid (0, attrp->_pgrp) != 0)\n    _exit (SPAWN_ERROR);\n\n  /* Set the effective user and group IDs.  */\n  if ((flags & POSIX_SPAWN_RESETIDS) != 0\n      && (local_seteuid (getuid ()) != 0\n          || local_setegid (getgid ()) != 0))\n    _exit (SPAWN_ERROR);\n\n  /* Execute the file actions.  */\n  if (file_actions != NULL)\n    {\n      int cnt;\n\n      for (cnt = 0; cnt < file_actions->_used; ++cnt)\n        {\n          struct __spawn_action *action = &file_actions->_actions[cnt];\n\n          switch (action->tag)\n            {\n            case spawn_do_close:\n              if (close_not_cancel (action->action.close_action.fd) != 0)\n                /* Signal the error.  */\n                _exit (SPAWN_ERROR);\n              break;\n\n            case spawn_do_open:\n              {\n                int new_fd = open_not_cancel (action->action.open_action.path,\n                                              action->action.open_action.oflag\n                                              | O_LARGEFILE,\n                                              action->action.open_action.mode);\n\n                if (new_fd == -1)\n                  /* The 'open' call failed.  */\n                  _exit (SPAWN_ERROR);\n\n                /* Make sure the desired file descriptor is used.  */\n                if (new_fd != action->action.open_action.fd)\n                  {\n                    if (dup2 (new_fd, action->action.open_action.fd)\n                        != action->action.open_action.fd)\n                      /* The 'dup2' call failed.  */\n                      _exit (SPAWN_ERROR);\n\n                    if (close_not_cancel (new_fd) != 0)\n                      /* The 'close' call failed.  */\n                      _exit (SPAWN_ERROR);\n                  }\n              }\n              break;\n\n            case spawn_do_dup2:\n              if (dup2 (action->action.dup2_action.fd,\n                        action->action.dup2_action.newfd)\n                  != action->action.dup2_action.newfd)\n                /* The 'dup2' call failed.  */\n                _exit (SPAWN_ERROR);\n              break;\n            }\n        }\n    }\n\n  if (! use_path || strchr (file, '/') != NULL)\n    {\n      /* The FILE parameter is actually a path.  */\n      execve (file, argv, envp);\n\n      if (errno == ENOEXEC)\n        script_execute (file, argv, envp);\n\n      /* Oh, oh.  'execve' returns.  This is bad.  */\n      _exit (SPAWN_ERROR);\n    }\n\n  /* We have to search for FILE on the path.  */\n  path = getenv (\"PATH\");\n  if (path == NULL)\n    {\n#if HAVE_CONFSTR\n      /* There is no 'PATH' in the environment.\n         The default search path is the current directory\n         followed by the path 'confstr' returns for '_CS_PATH'.  */\n      len = confstr (_CS_PATH, (char *) NULL, 0);\n      path = (char *) alloca (1 + len);\n      path[0] = ':';\n      (void) confstr (_CS_PATH, path + 1, len);\n#else\n      /* Pretend that the PATH contains only the current directory.  */\n      path = \"\";\n#endif\n    }\n\n  len = strlen (file) + 1;\n  pathlen = strlen (path);\n  name = alloca (pathlen + len + 1);\n  /* Copy the file name at the top.  */\n  name = (char *) memcpy (name + pathlen + 1, file, len);\n  /* And add the slash.  */\n  *--name = '/';\n\n  p = path;\n  do\n    {\n      char *startp;\n\n      path = p;\n      p = strchrnul (path, ':');\n\n      if (p == path)\n        /* Two adjacent colons, or a colon at the beginning or the end\n           of 'PATH' means to search the current directory.  */\n        startp = name + 1;\n      else\n        startp = (char *) memcpy (name - (p - path), path, p - path);\n\n      /* Try to execute this name.  If it works, execv will not return.  */\n      execve (startp, argv, envp);\n\n      if (errno == ENOEXEC)\n        script_execute (startp, argv, envp);\n\n      switch (errno)\n        {\n        case EACCES:\n        case ENOENT:\n        case ESTALE:\n        case ENOTDIR:\n          /* Those errors indicate the file is missing or not executable\n             by us, in which case we want to just try the next path\n             directory.  */\n          break;\n\n        default:\n          /* Some other error means we found an executable file, but\n             something went wrong executing it; return the error to our\n             caller.  */\n          _exit (SPAWN_ERROR);\n        }\n    }\n  while (*p++ != '\\0');\n\n  /* Return with an error.  */\n  _exit (SPAWN_ERROR);\n}",
        "lines": 235,
        "depth": 21,
        "decorators": [
          "int"
        ]
      }
    ],
    "script_execute": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "static void\ninternal_function\nscript_execute (const char *file, char *const argv[], char *const envp[])\n{\n  /* Count the arguments.  */\n  int argc = 0;\n  while (argv[argc++])\n    ;\n\n  /* Construct an argument list for the shell.  */\n  {\n    char **new_argv = (char **) alloca ((argc + 1) * sizeof (char *));\n    new_argv[0] = (char *) _PATH_BSHELL;\n    new_argv[1] = (char *) file;\n    while (argc > 1)\n      {\n        new_argv[argc] = argv[argc - 1];\n        --argc;\n      }\n\n    /* Execute the shell.  */\n    execve (new_argv[0], new_argv, envp);\n  }\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/spawnp.c": {
    "posix_spawnp": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nposix_spawnp (pid_t *pid, const char *file,\n              const posix_spawn_file_actions_t *file_actions,\n              const posix_spawnattr_t *attrp, char *const argv[],\n              char *const envp[])\n{\n  return __spawni (pid, file, file_actions, attrp, argv, envp, 1);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/spawn_faction_addclose.c": {},
  "sharutils/sharutils-4.15.2/lib/spawn_faction_adddup2.c": {},
  "sharutils/sharutils-4.15.2/lib/spawn_faction_addopen.c": {},
  "sharutils/sharutils-4.15.2/lib/spawn_faction_destroy.c": {
    "posix_spawn_file_actions_destroy": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "int\nposix_spawn_file_actions_destroy (posix_spawn_file_actions_t *file_actions)\n{\n  /* Free the memory allocated.  */\n  free (file_actions->_actions);\n  return 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/spawn_faction_init.c": {
    "__posix_spawn_file_actions_realloc": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "int\n__posix_spawn_file_actions_realloc (posix_spawn_file_actions_t *file_actions)\n{\n  int newalloc = file_actions->_allocated + 8;\n  void *newmem = realloc (file_actions->_actions,\n                          newalloc * sizeof (struct __spawn_action));\n\n  if (newmem == NULL)\n    /* Not enough memory.  */\n    return ENOMEM;\n\n  file_actions->_actions = (struct __spawn_action *) newmem;\n  file_actions->_allocated = newalloc;\n\n  return 0;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "posix_spawn_file_actions_init": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nposix_spawn_file_actions_init (posix_spawn_file_actions_t *file_actions)\n{\n  /* Simply clear all the elements.  */\n  memset (file_actions, '\\0', sizeof (*file_actions));\n  return 0;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/spawn_int.h": {},
  "sharutils/sharutils-4.15.2/lib/stat.c": {
    "orig_stat": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "static int\norig_stat (const char *filename, struct stat *buf)\n{\n  return stat (filename, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_stat": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "int\nrpl_stat (char const *name, struct stat *st)\n{\n  int result = orig_stat (name, st);\n#if REPLACE_FUNC_STAT_FILE\n  /* Solaris 9 mistakenly succeeds when given a non-directory with a\n     trailing slash.  */\n  if (result == 0 && !S_ISDIR (st->st_mode))\n    {\n      size_t len = strlen (name);\n      if (ISSLASH (name[len - 1]))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n    }\n#endif /* REPLACE_FUNC_STAT_FILE */\n#if REPLACE_FUNC_STAT_DIR\n\n  if (result == -1 && errno == ENOENT)\n    {\n      /* Due to mingw's oddities, there are some directories (like\n         c:\\) where stat() only succeeds with a trailing slash, and\n         other directories (like c:\\windows) where stat() only\n         succeeds without a trailing slash.  But we want the two to be\n         synonymous, since chdir() manages either style.  Likewise, Mingw also\n         reports ENOENT for names longer than PATH_MAX, when we want\n         ENAMETOOLONG, and for stat(\"file/\"), when we want ENOTDIR.\n         Fortunately, mingw PATH_MAX is small enough for stack\n         allocation.  */\n      char fixed_name[PATH_MAX + 1] = {0};\n      size_t len = strlen (name);\n      bool check_dir = false;\n      verify (PATH_MAX <= 4096);\n      if (PATH_MAX <= len)\n        errno = ENAMETOOLONG;\n      else if (len)\n        {\n          strcpy (fixed_name, name);\n          if (ISSLASH (fixed_name[len - 1]))\n            {\n              check_dir = true;\n              while (len && ISSLASH (fixed_name[len - 1]))\n                fixed_name[--len] = '\\0';\n              if (!len)\n                fixed_name[0] = '/';\n            }\n          else\n            fixed_name[len++] = '/';\n          result = orig_stat (fixed_name, st);\n          if (result == 0 && check_dir && !S_ISDIR (st->st_mode))\n            {\n              result = -1;\n              errno = ENOTDIR;\n            }\n        }\n    }\n#endif /* REPLACE_FUNC_STAT_DIR */\n  return result;\n}",
      "lines": 60,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/stdalign.in.h": {},
  "sharutils/sharutils-4.15.2/lib/stdbool.in.h": {},
  "sharutils/sharutils-4.15.2/lib/stddef.in.h": {},
  "sharutils/sharutils-4.15.2/lib/stdint.in.h": {},
  "sharutils/sharutils-4.15.2/lib/stdio-impl.h": {},
  "sharutils/sharutils-4.15.2/lib/stdio.in.h": {},
  "sharutils/sharutils-4.15.2/lib/stdlib.in.h": {},
  "sharutils/sharutils-4.15.2/lib/stdnoreturn.in.h": {},
  "sharutils/sharutils-4.15.2/lib/stpcpy.c": {
    "__stpcpy": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "char *\n__stpcpy (char *dest, const char *src)\n{\n  register char *d = dest;\n  register const char *s = src;\n\n  do\n    *d++ = *s;\n  while (*s++ != '\\0');\n\n  return d - 1;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "char",
        "*\n__stpcpy (char *dest, const char *src)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/strchrnul.c": {
    "strchrnul": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "char *\nstrchrnul (const char *s, int c_in)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned char c;\n\n  c = (unsigned char) c_in;\n  if (!c)\n    return rawmemchr (s, 0);\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       (size_t) char_ptr % sizeof (longword) != 0;\n       ++char_ptr)\n    if (!*char_ptr || *char_ptr == c)\n      return (char *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will\n     test a longword at a time.  The tricky part is testing if *any of\n     the four* bytes in the longword in question are equal to NUL or\n     c.  We first use an xor with repeated_c.  This reduces the task\n     to testing whether *any of the four* bytes in longword1 or\n     longword2 is zero.\n\n     Let's consider longword1.  We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     The test whether any byte in longword1 or longword2 is zero is equivalent\n     to testing whether tmp1 is nonzero or tmp2 is nonzero.  We can combine\n     this into a single test, whether (tmp1 | tmp2) is nonzero.\n\n     This test can read more than one byte beyond the end of a string,\n     depending on where the terminating NUL is encountered.  However,\n     this is considered safe since the initialization phase ensured\n     that the read will be aligned, therefore, the read will not cross\n     page boundaries and will not cause a fault.  */\n\n  while (1)\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n      longword longword2 = *longword_ptr;\n\n      if (((((longword1 - repeated_one) & ~longword1)\n            | ((longword2 - repeated_one) & ~longword2))\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that one of the sizeof (longword) bytes\n     starting at char_ptr is == 0 or == c.  On little-endian machines,\n     we could determine the first such byte without any further memory\n     accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.\n     Choose code that works in both cases.  */\n\n  char_ptr = (unsigned char *) longword_ptr;\n  while (*char_ptr && (*char_ptr != c))\n    char_ptr++;\n  return (char *) char_ptr;\n}",
      "lines": 120,
      "depth": 16,
      "decorators": [
        "char",
        "*\nstrchrnul (const char *s, int c_in)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/strdup.c": {
    "__strdup": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "char *\n__strdup (const char *s)\n{\n  size_t len = strlen (s) + 1;\n  void *new = malloc (len);\n\n  if (new == NULL)\n    return NULL;\n\n  return (char *) memcpy (new, s, len);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "char",
        "*\n__strdup (const char *s)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/streq.h": {
    "streq9": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static inline int\nstreq9 (const char *s1, const char *s2)\n{\n  return strcmp (s1 + 9, s2 + 9) == 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq8": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static inline int\nstreq8 (const char *s1, const char *s2, char s28)\n{\n  if (s1[8] == s28)\n    {\n      if (s28 == 0)\n        return 1;\n      else\n        return streq9 (s1, s2);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq7": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static inline int\nstreq7 (const char *s1, const char *s2, char s27, char s28)\n{\n  if (s1[7] == s27)\n    {\n      if (s27 == 0)\n        return 1;\n      else\n        return streq8 (s1, s2, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq6": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static inline int\nstreq6 (const char *s1, const char *s2, char s26, char s27, char s28)\n{\n  if (s1[6] == s26)\n    {\n      if (s26 == 0)\n        return 1;\n      else\n        return streq7 (s1, s2, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq5": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static inline int\nstreq5 (const char *s1, const char *s2, char s25, char s26, char s27, char s28)\n{\n  if (s1[5] == s25)\n    {\n      if (s25 == 0)\n        return 1;\n      else\n        return streq6 (s1, s2, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq4": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static inline int\nstreq4 (const char *s1, const char *s2, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[4] == s24)\n    {\n      if (s24 == 0)\n        return 1;\n      else\n        return streq5 (s1, s2, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq3": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static inline int\nstreq3 (const char *s1, const char *s2, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[3] == s23)\n    {\n      if (s23 == 0)\n        return 1;\n      else\n        return streq4 (s1, s2, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq2": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static inline int\nstreq2 (const char *s1, const char *s2, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[2] == s22)\n    {\n      if (s22 == 0)\n        return 1;\n      else\n        return streq3 (s1, s2, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq1": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "static inline int\nstreq1 (const char *s1, const char *s2, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[1] == s21)\n    {\n      if (s21 == 0)\n        return 1;\n      else\n        return streq2 (s1, s2, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq0": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "static inline int\nstreq0 (const char *s1, const char *s2, char s20, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[0] == s20)\n    {\n      if (s20 == 0)\n        return 1;\n      else\n        return streq1 (s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/strerror-override.c": {
    "strerror_override": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "const char *\nstrerror_override (int errnum)\n{\n  /* These error messages are taken from glibc/sysdeps/gnu/errlist.c.  */\n  switch (errnum)\n    {\n#if REPLACE_STRERROR_0\n    case 0:\n      return \"Success\";\n#endif\n\n#if GNULIB_defined_ESOCK /* native Windows platforms with older <errno.h> */\n    case EINPROGRESS:\n      return \"Operation now in progress\";\n    case EALREADY:\n      return \"Operation already in progress\";\n    case ENOTSOCK:\n      return \"Socket operation on non-socket\";\n    case EDESTADDRREQ:\n      return \"Destination address required\";\n    case EMSGSIZE:\n      return \"Message too long\";\n    case EPROTOTYPE:\n      return \"Protocol wrong type for socket\";\n    case ENOPROTOOPT:\n      return \"Protocol not available\";\n    case EPROTONOSUPPORT:\n      return \"Protocol not supported\";\n    case EOPNOTSUPP:\n      return \"Operation not supported\";\n    case EAFNOSUPPORT:\n      return \"Address family not supported by protocol\";\n    case EADDRINUSE:\n      return \"Address already in use\";\n    case EADDRNOTAVAIL:\n      return \"Cannot assign requested address\";\n    case ENETDOWN:\n      return \"Network is down\";\n    case ENETUNREACH:\n      return \"Network is unreachable\";\n    case ECONNRESET:\n      return \"Connection reset by peer\";\n    case ENOBUFS:\n      return \"No buffer space available\";\n    case EISCONN:\n      return \"Transport endpoint is already connected\";\n    case ENOTCONN:\n      return \"Transport endpoint is not connected\";\n    case ETIMEDOUT:\n      return \"Connection timed out\";\n    case ECONNREFUSED:\n      return \"Connection refused\";\n    case ELOOP:\n      return \"Too many levels of symbolic links\";\n    case EHOSTUNREACH:\n      return \"No route to host\";\n    case EWOULDBLOCK:\n      return \"Operation would block\";\n#endif\n#if GNULIB_defined_ESTREAMS /* native Windows platforms with older <errno.h> */\n    case ETXTBSY:\n      return \"Text file busy\";\n    case ENODATA:\n      return \"No data available\";\n    case ENOSR:\n      return \"Out of streams resources\";\n    case ENOSTR:\n      return \"Device not a stream\";\n    case ETIME:\n      return \"Timer expired\";\n    case EOTHER:\n      return \"Other error\";\n#endif\n#if GNULIB_defined_EWINSOCK /* native Windows platforms */\n    case ESOCKTNOSUPPORT:\n      return \"Socket type not supported\";\n    case EPFNOSUPPORT:\n      return \"Protocol family not supported\";\n    case ESHUTDOWN:\n      return \"Cannot send after transport endpoint shutdown\";\n    case ETOOMANYREFS:\n      return \"Too many references: cannot splice\";\n    case EHOSTDOWN:\n      return \"Host is down\";\n    case EPROCLIM:\n      return \"Too many processes\";\n    case EUSERS:\n      return \"Too many users\";\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n    case ESTALE:\n      return \"Stale NFS file handle\";\n    case EREMOTE:\n      return \"Object is remote\";\n# if HAVE_WINSOCK2_H\n      /* WSA_INVALID_HANDLE maps to EBADF */\n      /* WSA_NOT_ENOUGH_MEMORY maps to ENOMEM */\n      /* WSA_INVALID_PARAMETER maps to EINVAL */\n    case WSA_OPERATION_ABORTED:\n      return \"Overlapped operation aborted\";\n    case WSA_IO_INCOMPLETE:\n      return \"Overlapped I/O event object not in signaled state\";\n    case WSA_IO_PENDING:\n      return \"Overlapped operations will complete later\";\n      /* WSAEINTR maps to EINTR */\n      /* WSAEBADF maps to EBADF */\n      /* WSAEACCES maps to EACCES */\n      /* WSAEFAULT maps to EFAULT */\n      /* WSAEINVAL maps to EINVAL */\n      /* WSAEMFILE maps to EMFILE */\n      /* WSAEWOULDBLOCK maps to EWOULDBLOCK */\n      /* WSAEINPROGRESS maps to EINPROGRESS */\n      /* WSAEALREADY maps to EALREADY */\n      /* WSAENOTSOCK maps to ENOTSOCK */\n      /* WSAEDESTADDRREQ maps to EDESTADDRREQ */\n      /* WSAEMSGSIZE maps to EMSGSIZE */\n      /* WSAEPROTOTYPE maps to EPROTOTYPE */\n      /* WSAENOPROTOOPT maps to ENOPROTOOPT */\n      /* WSAEPROTONOSUPPORT maps to EPROTONOSUPPORT */\n      /* WSAESOCKTNOSUPPORT is ESOCKTNOSUPPORT */\n      /* WSAEOPNOTSUPP maps to EOPNOTSUPP */\n      /* WSAEPFNOSUPPORT is EPFNOSUPPORT */\n      /* WSAEAFNOSUPPORT maps to EAFNOSUPPORT */\n      /* WSAEADDRINUSE maps to EADDRINUSE */\n      /* WSAEADDRNOTAVAIL maps to EADDRNOTAVAIL */\n      /* WSAENETDOWN maps to ENETDOWN */\n      /* WSAENETUNREACH maps to ENETUNREACH */\n      /* WSAENETRESET maps to ENETRESET */\n      /* WSAECONNABORTED maps to ECONNABORTED */\n      /* WSAECONNRESET maps to ECONNRESET */\n      /* WSAENOBUFS maps to ENOBUFS */\n      /* WSAEISCONN maps to EISCONN */\n      /* WSAENOTCONN maps to ENOTCONN */\n      /* WSAESHUTDOWN is ESHUTDOWN */\n      /* WSAETOOMANYREFS is ETOOMANYREFS */\n      /* WSAETIMEDOUT maps to ETIMEDOUT */\n      /* WSAECONNREFUSED maps to ECONNREFUSED */\n      /* WSAELOOP maps to ELOOP */\n      /* WSAENAMETOOLONG maps to ENAMETOOLONG */\n      /* WSAEHOSTDOWN is EHOSTDOWN */\n      /* WSAEHOSTUNREACH maps to EHOSTUNREACH */\n      /* WSAENOTEMPTY maps to ENOTEMPTY */\n      /* WSAEPROCLIM is EPROCLIM */\n      /* WSAEUSERS is EUSERS */\n      /* WSAEDQUOT is EDQUOT */\n      /* WSAESTALE is ESTALE */\n      /* WSAEREMOTE is EREMOTE */\n    case WSASYSNOTREADY:\n      return \"Network subsystem is unavailable\";\n    case WSAVERNOTSUPPORTED:\n      return \"Winsock.dll version out of range\";\n    case WSANOTINITIALISED:\n      return \"Successful WSAStartup not yet performed\";\n    case WSAEDISCON:\n      return \"Graceful shutdown in progress\";\n    case WSAENOMORE: case WSA_E_NO_MORE:\n      return \"No more results\";\n    case WSAECANCELLED: case WSA_E_CANCELLED:\n      return \"Call was canceled\";\n    case WSAEINVALIDPROCTABLE:\n      return \"Procedure call table is invalid\";\n    case WSAEINVALIDPROVIDER:\n      return \"Service provider is invalid\";\n    case WSAEPROVIDERFAILEDINIT:\n      return \"Service provider failed to initialize\";\n    case WSASYSCALLFAILURE:\n      return \"System call failure\";\n    case WSASERVICE_NOT_FOUND:\n      return \"Service not found\";\n    case WSATYPE_NOT_FOUND:\n      return \"Class type not found\";\n    case WSAEREFUSED:\n      return \"Database query was refused\";\n    case WSAHOST_NOT_FOUND:\n      return \"Host not found\";\n    case WSATRY_AGAIN:\n      return \"Nonauthoritative host not found\";\n    case WSANO_RECOVERY:\n      return \"Nonrecoverable error\";\n    case WSANO_DATA:\n      return \"Valid name, no data record of requested type\";\n      /* WSA_QOS_* omitted */\n# endif\n#endif\n\n#if GNULIB_defined_ENOMSG\n    case ENOMSG:\n      return \"No message of desired type\";\n#endif\n\n#if GNULIB_defined_EIDRM\n    case EIDRM:\n      return \"Identifier removed\";\n#endif\n\n#if GNULIB_defined_ENOLINK\n    case ENOLINK:\n      return \"Link has been severed\";\n#endif\n\n#if GNULIB_defined_EPROTO\n    case EPROTO:\n      return \"Protocol error\";\n#endif\n\n#if GNULIB_defined_EMULTIHOP\n    case EMULTIHOP:\n      return \"Multihop attempted\";\n#endif\n\n#if GNULIB_defined_EBADMSG\n    case EBADMSG:\n      return \"Bad message\";\n#endif\n\n#if GNULIB_defined_EOVERFLOW\n    case EOVERFLOW:\n      return \"Value too large for defined data type\";\n#endif\n\n#if GNULIB_defined_ENOTSUP\n    case ENOTSUP:\n      return \"Not supported\";\n#endif\n\n#if GNULIB_defined_ENETRESET\n    case ENETRESET:\n      return \"Network dropped connection on reset\";\n#endif\n\n#if GNULIB_defined_ECONNABORTED\n    case ECONNABORTED:\n      return \"Software caused connection abort\";\n#endif\n\n#if GNULIB_defined_ESTALE\n    case ESTALE:\n      return \"Stale NFS file handle\";\n#endif\n\n#if GNULIB_defined_EDQUOT\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n#endif\n\n#if GNULIB_defined_ECANCELED\n    case ECANCELED:\n      return \"Operation canceled\";\n#endif\n\n#if GNULIB_defined_EOWNERDEAD\n    case EOWNERDEAD:\n      return \"Owner died\";\n#endif\n\n#if GNULIB_defined_ENOTRECOVERABLE\n    case ENOTRECOVERABLE:\n      return \"State not recoverable\";\n#endif\n\n#if GNULIB_defined_EILSEQ\n    case EILSEQ:\n      return \"Invalid or incomplete multibyte or wide character\";\n#endif\n\n    default:\n      return NULL;\n    }\n}",
      "lines": 269,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nstrerror_override (int errnum)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/strerror-override.h": {},
  "sharutils/sharutils-4.15.2/lib/strerror.c": {},
  "sharutils/sharutils-4.15.2/lib/strftime.c": {
    "fwrite_lowcase": {
      "start_point": [
        296,
        0
      ],
      "end_point": [
        304,
        1
      ],
      "content": "static void\nfwrite_lowcase (FILE *fp, const CHAR_T *src, size_t len)\n{\n  while (len-- > 0)\n    {\n      fputc (TOLOWER ((UCHAR_T) *src, loc), fp);\n      ++src;\n    }\n}",
      "lines": 9,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fwrite_uppcase": {
      "start_point": [
        306,
        0
      ],
      "end_point": [
        314,
        1
      ],
      "content": "static void\nfwrite_uppcase (FILE *fp, const CHAR_T *src, size_t len)\n{\n  while (len-- > 0)\n    {\n      fputc (TOUPPER ((UCHAR_T) *src, loc), fp);\n      ++src;\n    }\n}",
      "lines": 9,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "memcpy_lowcase": {
      "start_point": [
        316,
        0
      ],
      "end_point": [
        323,
        1
      ],
      "content": "static CHAR_T *\nmemcpy_lowcase (CHAR_T *dest, const CHAR_T *src,\n                size_t len LOCALE_PARAM_PROTO)\n{\n  while (len-- > 0)\n    dest[len] = TOLOWER ((UCHAR_T) src[len], loc);\n  return dest;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "CHAR_T",
        "*\nmemcpy_lowcase (CHAR_T *dest, const CHAR_T *src,\n                size_t len LOCALE_PARAM_PROTO)",
        "*"
      ]
    },
    "memcpy_uppcase": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        332,
        1
      ],
      "content": "static CHAR_T *\nmemcpy_uppcase (CHAR_T *dest, const CHAR_T *src,\n                size_t len LOCALE_PARAM_PROTO)\n{\n  while (len-- > 0)\n    dest[len] = TOUPPER ((UCHAR_T) src[len], loc);\n  return dest;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "CHAR_T",
        "*\nmemcpy_uppcase (CHAR_T *dest, const CHAR_T *src,\n                size_t len LOCALE_PARAM_PROTO)",
        "*"
      ]
    },
    "tm_diff": {
      "start_point": [
        340,
        0
      ],
      "end_point": [
        359,
        1
      ],
      "content": "static int\ntm_diff (const struct tm *a, const struct tm *b)\n{\n  /* Compute intervening leap days correctly even if year is negative.\n     Take care to avoid int overflow in leap day calculations,\n     but it's OK to assume that A and B are close to each other.  */\n  int a4 = SHR (a->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (a->tm_year & 3);\n  int b4 = SHR (b->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (b->tm_year & 3);\n  int a100 = a4 / 25 - (a4 % 25 < 0);\n  int b100 = b4 / 25 - (b4 % 25 < 0);\n  int a400 = SHR (a100, 2);\n  int b400 = SHR (b100, 2);\n  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n  int years = a->tm_year - b->tm_year;\n  int days = (365 * years + intervening_leap_days\n              + (a->tm_yday - b->tm_yday));\n  return (60 * (60 * (24 * days + (a->tm_hour - b->tm_hour))\n                + (a->tm_min - b->tm_min))\n          + (a->tm_sec - b->tm_sec));\n}",
      "lines": 20,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso_week_days": {
      "start_point": [
        374,
        0
      ],
      "end_point": [
        382,
        1
      ],
      "content": "static int\niso_week_days (int yday, int wday)\n{\n  /* Add enough to the first operand of % to make it nonnegative.  */\n  int big_enough_multiple_of_7 = (-YDAY_MINIMUM / 7 + 2) * 7;\n  return (yday\n          - (yday - wday + ISO_WEEK1_WDAY + big_enough_multiple_of_7) % 7\n          + ISO_WEEK1_WDAY - ISO_WEEK_START_WDAY);\n}",
      "lines": 9,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "strftime_case_": {
      "start_point": [
        420,
        0
      ],
      "end_point": [
        1455,
        1
      ],
      "content": "static size_t\nstrftime_case_ (bool upcase, STREAM_OR_CHAR_T *s,\n                STRFTIME_ARG (size_t maxsize)\n                const CHAR_T *format,\n                const struct tm *tp extra_args_spec LOCALE_PARAM_PROTO)\n{\n#if defined _LIBC && defined USE_IN_EXTENDED_LOCALE_MODEL\n  struct locale_data *const current = loc->__locales[LC_TIME];\n#endif\n#if FPRINTFTIME\n  size_t maxsize = (size_t) -1;\n#endif\n\n  int hour12 = tp->tm_hour;\n#ifdef _NL_CURRENT\n  /* We cannot make the following values variables since we must delay\n     the evaluation of these values until really needed since some\n     expressions might not be valid in every situation.  The 'struct tm'\n     might be generated by a strptime() call that initialized\n     only a few elements.  Dereference the pointers only if the format\n     requires this.  Then it is ok to fail if the pointers are invalid.  */\n# define a_wkday \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ABDAY_1) + tp->tm_wday))\n# define f_wkday \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(DAY_1) + tp->tm_wday))\n# define a_month \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ABMON_1) + tp->tm_mon))\n# define f_month \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(MON_1) + tp->tm_mon))\n# define ampm \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, tp->tm_hour > 11                    \\\n                                 ? NLW(PM_STR) : NLW(AM_STR)))\n\n# define aw_len STRLEN (a_wkday)\n# define am_len STRLEN (a_month)\n# define ap_len STRLEN (ampm)\n#endif\n  const char *zone;\n  size_t i = 0;\n  STREAM_OR_CHAR_T *p = s;\n  const CHAR_T *f;\n#if DO_MULTIBYTE && !defined COMPILE_WIDE\n  const char *format_end = NULL;\n#endif\n\n#if ! defined _LIBC && ! HAVE_RUN_TZSET_TEST\n  /* Solaris 2.5.x and 2.6 tzset sometimes modify the storage returned\n     by localtime.  On such systems, we must either use the tzset and\n     localtime wrappers to work around the bug (which sets\n     HAVE_RUN_TZSET_TEST) or make a copy of the structure.  */\n  struct tm copy = *tp;\n  tp = &copy;\n#endif\n\n  zone = NULL;\n#if HAVE_TM_ZONE\n  /* The POSIX test suite assumes that setting\n     the environment variable TZ to a new value before calling strftime()\n     will influence the result (the %Z format) even if the information in\n     TP is computed with a totally different time zone.\n     This is bogus: though POSIX allows bad behavior like this,\n     POSIX does not require it.  Do the right thing instead.  */\n  zone = (const char *) tp->tm_zone;\n#endif\n#if HAVE_TZNAME\n  if (ut)\n    {\n      if (! (zone && *zone))\n        zone = \"GMT\";\n    }\n  else\n    {\n      /* POSIX.1 requires that local time zone information be used as\n         though strftime called tzset.  */\n# if HAVE_TZSET\n      tzset ();\n# endif\n    }\n#endif\n\n  if (hour12 > 12)\n    hour12 -= 12;\n  else\n    if (hour12 == 0)\n      hour12 = 12;\n\n  for (f = format; *f != '\\0'; ++f)\n    {\n      int pad = 0;              /* Padding for number ('-', '_', or 0).  */\n      int modifier;             /* Field modifier ('E', 'O', or 0).  */\n      int digits = 0;           /* Max digits for numeric format.  */\n      int number_value;         /* Numeric value to be printed.  */\n      unsigned int u_number_value; /* (unsigned int) number_value.  */\n      bool negative_number;     /* The number is negative.  */\n      bool always_output_a_sign; /* +/- should always be output.  */\n      int tz_colon_mask;        /* Bitmask of where ':' should appear.  */\n      const CHAR_T *subfmt;\n      CHAR_T sign_char;\n      CHAR_T *bufp;\n      CHAR_T buf[1\n                 + 2 /* for the two colons in a %::z or %:::z time zone */\n                 + (sizeof (int) < sizeof (time_t)\n                    ? INT_STRLEN_BOUND (time_t)\n                    : INT_STRLEN_BOUND (int))];\n      int width = -1;\n      bool to_lowcase = false;\n      bool to_uppcase = upcase;\n      size_t colons;\n      bool change_case = false;\n      int format_char;\n\n#if DO_MULTIBYTE && !defined COMPILE_WIDE\n      switch (*f)\n        {\n        case L_('%'):\n          break;\n\n        case L_('\\b'): case L_('\\t'): case L_('\\n'):\n        case L_('\\v'): case L_('\\f'): case L_('\\r'):\n        case L_(' '): case L_('!'): case L_('\"'): case L_('#'): case L_('&'):\n        case L_('\\''): case L_('('): case L_(')'): case L_('*'): case L_('+'):\n        case L_(','): case L_('-'): case L_('.'): case L_('/'): case L_('0'):\n        case L_('1'): case L_('2'): case L_('3'): case L_('4'): case L_('5'):\n        case L_('6'): case L_('7'): case L_('8'): case L_('9'): case L_(':'):\n        case L_(';'): case L_('<'): case L_('='): case L_('>'): case L_('?'):\n        case L_('A'): case L_('B'): case L_('C'): case L_('D'): case L_('E'):\n        case L_('F'): case L_('G'): case L_('H'): case L_('I'): case L_('J'):\n        case L_('K'): case L_('L'): case L_('M'): case L_('N'): case L_('O'):\n        case L_('P'): case L_('Q'): case L_('R'): case L_('S'): case L_('T'):\n        case L_('U'): case L_('V'): case L_('W'): case L_('X'): case L_('Y'):\n        case L_('Z'): case L_('['): case L_('\\\\'): case L_(']'): case L_('^'):\n        case L_('_'): case L_('a'): case L_('b'): case L_('c'): case L_('d'):\n        case L_('e'): case L_('f'): case L_('g'): case L_('h'): case L_('i'):\n        case L_('j'): case L_('k'): case L_('l'): case L_('m'): case L_('n'):\n        case L_('o'): case L_('p'): case L_('q'): case L_('r'): case L_('s'):\n        case L_('t'): case L_('u'): case L_('v'): case L_('w'): case L_('x'):\n        case L_('y'): case L_('z'): case L_('{'): case L_('|'): case L_('}'):\n        case L_('~'):\n          /* The C Standard requires these 98 characters (plus '%') to\n             be in the basic execution character set.  None of these\n             characters can start a multibyte sequence, so they need\n             not be analyzed further.  */\n          add1 (*f);\n          continue;\n\n        default:\n          /* Copy this multibyte sequence until we reach its end, find\n             an error, or come back to the initial shift state.  */\n          {\n            mbstate_t mbstate = mbstate_zero;\n            size_t len = 0;\n            size_t fsize;\n\n            if (! format_end)\n              format_end = f + strlen (f) + 1;\n            fsize = format_end - f;\n\n            do\n              {\n                size_t bytes = mbrlen (f + len, fsize - len, &mbstate);\n\n                if (bytes == 0)\n                  break;\n\n                if (bytes == (size_t) -2)\n                  {\n                    len += strlen (f + len);\n                    break;\n                  }\n\n                if (bytes == (size_t) -1)\n                  {\n                    len++;\n                    break;\n                  }\n\n                len += bytes;\n              }\n            while (! mbsinit (&mbstate));\n\n            cpy (len, f);\n            f += len - 1;\n            continue;\n          }\n        }\n\n#else /* ! DO_MULTIBYTE */\n\n      /* Either multibyte encodings are not supported, they are\n         safe for formats, so any non-'%' byte can be copied through,\n         or this is the wide character version.  */\n      if (*f != L_('%'))\n        {\n          add1 (*f);\n          continue;\n        }\n\n#endif /* ! DO_MULTIBYTE */\n\n      /* Check for flags that can modify a format.  */\n      while (1)\n        {\n          switch (*++f)\n            {\n              /* This influences the number formats.  */\n            case L_('_'):\n            case L_('-'):\n            case L_('0'):\n              pad = *f;\n              continue;\n\n              /* This changes textual output.  */\n            case L_('^'):\n              to_uppcase = true;\n              continue;\n            case L_('#'):\n              change_case = true;\n              continue;\n\n            default:\n              break;\n            }\n          break;\n        }\n\n      /* As a GNU extension we allow to specify the field width.  */\n      if (ISDIGIT (*f))\n        {\n          width = 0;\n          do\n            {\n              if (width > INT_MAX / 10\n                  || (width == INT_MAX / 10 && *f - L_('0') > INT_MAX % 10))\n                /* Avoid overflow.  */\n                width = INT_MAX;\n              else\n                {\n                  width *= 10;\n                  width += *f - L_('0');\n                }\n              ++f;\n            }\n          while (ISDIGIT (*f));\n        }\n\n      /* Check for modifiers.  */\n      switch (*f)\n        {\n        case L_('E'):\n        case L_('O'):\n          modifier = *f++;\n          break;\n\n        default:\n          modifier = 0;\n          break;\n        }\n\n      /* Now do the specified format.  */\n      format_char = *f;\n      switch (format_char)\n        {\n#define DO_NUMBER(d, v) \\\n          do                                                                  \\\n            {                                                                 \\\n              digits = d;                                                     \\\n              number_value = v;                                               \\\n              goto do_number;                                                 \\\n            }                                                                 \\\n          while (0)\n#define DO_SIGNED_NUMBER(d, negative, v) \\\n          do                                                                  \\\n            {                                                                 \\\n              digits = d;                                                     \\\n              negative_number = negative;                                     \\\n              u_number_value = v;                                             \\\n              goto do_signed_number;                                          \\\n            }                                                                 \\\n          while (0)\n\n          /* The mask is not what you might think.\n             When the ordinal i'th bit is set, insert a colon\n             before the i'th digit of the time zone representation.  */\n#define DO_TZ_OFFSET(d, negative, mask, v) \\\n          do                                                                  \\\n            {                                                                 \\\n              digits = d;                                                     \\\n              negative_number = negative;                                     \\\n              tz_colon_mask = mask;                                           \\\n              u_number_value = v;                                             \\\n              goto do_tz_offset;                                              \\\n            }                                                                 \\\n          while (0)\n#define DO_NUMBER_SPACEPAD(d, v) \\\n          do                                                                  \\\n            {                                                                 \\\n              digits = d;                                                     \\\n              number_value = v;                                               \\\n              goto do_number_spacepad;                                        \\\n            }                                                                 \\\n          while (0)\n\n        case L_('%'):\n          if (modifier != 0)\n            goto bad_format;\n          add1 (*f);\n          break;\n\n        case L_('a'):\n          if (modifier != 0)\n            goto bad_format;\n          if (change_case)\n            {\n              to_uppcase = true;\n              to_lowcase = false;\n            }\n#ifdef _NL_CURRENT\n          cpy (aw_len, a_wkday);\n          break;\n#else\n          goto underlying_strftime;\n#endif\n\n        case 'A':\n          if (modifier != 0)\n            goto bad_format;\n          if (change_case)\n            {\n              to_uppcase = true;\n              to_lowcase = false;\n            }\n#ifdef _NL_CURRENT\n          cpy (STRLEN (f_wkday), f_wkday);\n          break;\n#else\n          goto underlying_strftime;\n#endif\n\n        case L_('b'):\n        case L_('h'):\n          if (change_case)\n            {\n              to_uppcase = true;\n              to_lowcase = false;\n            }\n          if (modifier != 0)\n            goto bad_format;\n#ifdef _NL_CURRENT\n          cpy (am_len, a_month);\n          break;\n#else\n          goto underlying_strftime;\n#endif\n\n        case L_('B'):\n          if (modifier != 0)\n            goto bad_format;\n          if (change_case)\n            {\n              to_uppcase = true;\n              to_lowcase = false;\n            }\n#ifdef _NL_CURRENT\n          cpy (STRLEN (f_month), f_month);\n          break;\n#else\n          goto underlying_strftime;\n#endif\n\n        case L_('c'):\n          if (modifier == L_('O'))\n            goto bad_format;\n#ifdef _NL_CURRENT\n          if (! (modifier == 'E'\n                 && (*(subfmt =\n                       (const CHAR_T *) _NL_CURRENT (LC_TIME,\n                                                     NLW(ERA_D_T_FMT)))\n                     != '\\0')))\n            subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_T_FMT));\n#else\n          goto underlying_strftime;\n#endif\n\n        subformat:\n          {\n            size_t len = strftime_case_ (to_uppcase,\n                                         NULL, STRFTIME_ARG ((size_t) -1)\n                                         subfmt,\n                                         tp extra_args LOCALE_ARG);\n            add (len, strftime_case_ (to_uppcase, p,\n                                      STRFTIME_ARG (maxsize - i)\n                                      subfmt,\n                                      tp extra_args LOCALE_ARG));\n          }\n          break;\n\n#if !(defined _NL_CURRENT && HAVE_STRUCT_ERA_ENTRY)\n        underlying_strftime:\n          {\n            /* The relevant information is available only via the\n               underlying strftime implementation, so use that.  */\n            char ufmt[5];\n            char *u = ufmt;\n            char ubuf[1024]; /* enough for any single format in practice */\n            size_t len;\n            /* Make sure we're calling the actual underlying strftime.\n               In some cases, config.h contains something like\n               \"#define strftime rpl_strftime\".  */\n# ifdef strftime\n#  undef strftime\n            size_t strftime ();\n# endif\n\n            /* The space helps distinguish strftime failure from empty\n               output.  */\n            *u++ = ' ';\n            *u++ = '%';\n            if (modifier != 0)\n              *u++ = modifier;\n            *u++ = format_char;\n            *u = '\\0';\n            len = strftime (ubuf, sizeof ubuf, ufmt, tp);\n            if (len != 0)\n              cpy (len - 1, ubuf + 1);\n          }\n          break;\n#endif\n\n        case L_('C'):\n          if (modifier == L_('O'))\n            goto bad_format;\n          if (modifier == L_('E'))\n            {\n#if HAVE_STRUCT_ERA_ENTRY\n              struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n              if (era)\n                {\n# ifdef COMPILE_WIDE\n                  size_t len = __wcslen (era->era_wname);\n                  cpy (len, era->era_wname);\n# else\n                  size_t len = strlen (era->era_name);\n                  cpy (len, era->era_name);\n# endif\n                  break;\n                }\n#else\n              goto underlying_strftime;\n#endif\n            }\n\n          {\n            int century = tp->tm_year / 100 + TM_YEAR_BASE / 100;\n            century -= tp->tm_year % 100 < 0 && 0 < century;\n            DO_SIGNED_NUMBER (2, tp->tm_year < - TM_YEAR_BASE, century);\n          }\n\n        case L_('x'):\n          if (modifier == L_('O'))\n            goto bad_format;\n#ifdef _NL_CURRENT\n          if (! (modifier == L_('E')\n                 && (*(subfmt =\n                       (const CHAR_T *)_NL_CURRENT (LC_TIME, NLW(ERA_D_FMT)))\n                     != L_('\\0'))))\n            subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_FMT));\n          goto subformat;\n#else\n          goto underlying_strftime;\n#endif\n        case L_('D'):\n          if (modifier != 0)\n            goto bad_format;\n          subfmt = L_(\"%m/%d/%y\");\n          goto subformat;\n\n        case L_('d'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, tp->tm_mday);\n\n        case L_('e'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER_SPACEPAD (2, tp->tm_mday);\n\n          /* All numeric formats set DIGITS and NUMBER_VALUE (or U_NUMBER_VALUE)\n             and then jump to one of these labels.  */\n\n        do_tz_offset:\n          always_output_a_sign = true;\n          goto do_number_body;\n\n        do_number_spacepad:\n          /* Force '_' flag unless overridden by '0' or '-' flag.  */\n          if (pad != L_('0') && pad != L_('-'))\n            pad = L_('_');\n\n        do_number:\n          /* Format NUMBER_VALUE according to the MODIFIER flag.  */\n          negative_number = number_value < 0;\n          u_number_value = number_value;\n\n        do_signed_number:\n          always_output_a_sign = false;\n          tz_colon_mask = 0;\n\n        do_number_body:\n          /* Format U_NUMBER_VALUE according to the MODIFIER flag.\n             NEGATIVE_NUMBER is nonzero if the original number was\n             negative; in this case it was converted directly to\n             unsigned int (i.e., modulo (UINT_MAX + 1)) without\n             negating it.  */\n          if (modifier == L_('O') && !negative_number)\n            {\n#ifdef _NL_CURRENT\n              /* Get the locale specific alternate representation of\n                 the number.  If none exist NULL is returned.  */\n              const CHAR_T *cp = nl_get_alt_digit (u_number_value\n                                                   HELPER_LOCALE_ARG);\n\n              if (cp != NULL)\n                {\n                  size_t digitlen = STRLEN (cp);\n                  if (digitlen != 0)\n                    {\n                      cpy (digitlen, cp);\n                      break;\n                    }\n                }\n#else\n              goto underlying_strftime;\n#endif\n            }\n\n          bufp = buf + sizeof (buf) / sizeof (buf[0]);\n\n          if (negative_number)\n            u_number_value = - u_number_value;\n\n          do\n            {\n              if (tz_colon_mask & 1)\n                *--bufp = ':';\n              tz_colon_mask >>= 1;\n              *--bufp = u_number_value % 10 + L_('0');\n              u_number_value /= 10;\n            }\n          while (u_number_value != 0 || tz_colon_mask != 0);\n\n        do_number_sign_and_padding:\n          if (digits < width)\n            digits = width;\n\n          sign_char = (negative_number ? L_('-')\n                       : always_output_a_sign ? L_('+')\n                       : 0);\n\n          if (pad == L_('-'))\n            {\n              if (sign_char)\n                add1 (sign_char);\n            }\n          else\n            {\n              int padding = digits - (buf + (sizeof (buf) / sizeof (buf[0]))\n                                      - bufp) - !!sign_char;\n\n              if (padding > 0)\n                {\n                  if (pad == L_('_'))\n                    {\n                      if ((size_t) padding >= maxsize - i)\n                        return 0;\n\n                      if (p)\n                        memset_space (p, padding);\n                      i += padding;\n                      width = width > padding ? width - padding : 0;\n                      if (sign_char)\n                        add1 (sign_char);\n                    }\n                  else\n                    {\n                      if ((size_t) digits >= maxsize - i)\n                        return 0;\n\n                      if (sign_char)\n                        add1 (sign_char);\n\n                      if (p)\n                        memset_zero (p, padding);\n                      i += padding;\n                      width = 0;\n                    }\n                }\n              else\n                {\n                  if (sign_char)\n                    add1 (sign_char);\n                }\n            }\n\n          cpy (buf + sizeof (buf) / sizeof (buf[0]) - bufp, bufp);\n          break;\n\n        case L_('F'):\n          if (modifier != 0)\n            goto bad_format;\n          subfmt = L_(\"%Y-%m-%d\");\n          goto subformat;\n\n        case L_('H'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, tp->tm_hour);\n\n        case L_('I'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, hour12);\n\n        case L_('k'):           /* GNU extension.  */\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER_SPACEPAD (2, tp->tm_hour);\n\n        case L_('l'):           /* GNU extension.  */\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER_SPACEPAD (2, hour12);\n\n        case L_('j'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_SIGNED_NUMBER (3, tp->tm_yday < -1, tp->tm_yday + 1U);\n\n        case L_('M'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, tp->tm_min);\n\n        case L_('m'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_SIGNED_NUMBER (2, tp->tm_mon < -1, tp->tm_mon + 1U);\n\n#ifndef _LIBC\n        case L_('N'):           /* GNU extension.  */\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          number_value = ns;\n          if (width == -1)\n            width = 9;\n          else\n            {\n              /* Take an explicit width less than 9 as a precision.  */\n              int j;\n              for (j = width; j < 9; j++)\n                number_value /= 10;\n            }\n\n          DO_NUMBER (width, number_value);\n#endif\n\n        case L_('n'):\n          add1 (L_('\\n'));\n          break;\n\n        case L_('P'):\n          to_lowcase = true;\n#ifndef _NL_CURRENT\n          format_char = L_('p');\n#endif\n          /* FALLTHROUGH */\n\n        case L_('p'):\n          if (change_case)\n            {\n              to_uppcase = false;\n              to_lowcase = true;\n            }\n#ifdef _NL_CURRENT\n          cpy (ap_len, ampm);\n          break;\n#else\n          goto underlying_strftime;\n#endif\n\n        case L_('R'):\n          subfmt = L_(\"%H:%M\");\n          goto subformat;\n\n        case L_('r'):\n#ifdef _NL_CURRENT\n          if (*(subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME,\n                                                       NLW(T_FMT_AMPM)))\n              == L_('\\0'))\n            subfmt = L_(\"%I:%M:%S %p\");\n          goto subformat;\n#else\n          goto underlying_strftime;\n#endif\n\n        case L_('S'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, tp->tm_sec);\n\n        case L_('s'):           /* GNU extension.  */\n          {\n            struct tm ltm;\n            time_t t;\n\n            ltm = *tp;\n            t = mktime (&ltm);\n\n            /* Generate string value for T using time_t arithmetic;\n               this works even if sizeof (long) < sizeof (time_t).  */\n\n            bufp = buf + sizeof (buf) / sizeof (buf[0]);\n            negative_number = t < 0;\n\n            do\n              {\n                int d = t % 10;\n                t /= 10;\n                *--bufp = (negative_number ? -d : d) + L_('0');\n              }\n            while (t != 0);\n\n            digits = 1;\n            always_output_a_sign = false;\n            goto do_number_sign_and_padding;\n          }\n\n        case L_('X'):\n          if (modifier == L_('O'))\n            goto bad_format;\n#ifdef _NL_CURRENT\n          if (! (modifier == L_('E')\n                 && (*(subfmt =\n                       (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ERA_T_FMT)))\n                     != L_('\\0'))))\n            subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(T_FMT));\n          goto subformat;\n#else\n          goto underlying_strftime;\n#endif\n        case L_('T'):\n          subfmt = L_(\"%H:%M:%S\");\n          goto subformat;\n\n        case L_('t'):\n          add1 (L_('\\t'));\n          break;\n\n        case L_('u'):\n          DO_NUMBER (1, (tp->tm_wday - 1 + 7) % 7 + 1);\n\n        case L_('U'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, (tp->tm_yday - tp->tm_wday + 7) / 7);\n\n        case L_('V'):\n        case L_('g'):\n        case L_('G'):\n          if (modifier == L_('E'))\n            goto bad_format;\n          {\n            /* YEAR is a leap year if and only if (tp->tm_year + TM_YEAR_BASE)\n               is a leap year, except that YEAR and YEAR - 1 both work\n               correctly even when (tp->tm_year + TM_YEAR_BASE) would\n               overflow.  */\n            int year = (tp->tm_year\n                        + (tp->tm_year < 0\n                           ? TM_YEAR_BASE % 400\n                           : TM_YEAR_BASE % 400 - 400));\n            int year_adjust = 0;\n            int days = iso_week_days (tp->tm_yday, tp->tm_wday);\n\n            if (days < 0)\n              {\n                /* This ISO week belongs to the previous year.  */\n                year_adjust = -1;\n                days = iso_week_days (tp->tm_yday + (365 + __isleap (year - 1)),\n                                      tp->tm_wday);\n              }\n            else\n              {\n                int d = iso_week_days (tp->tm_yday - (365 + __isleap (year)),\n                                       tp->tm_wday);\n                if (0 <= d)\n                  {\n                    /* This ISO week belongs to the next year.  */\n                    year_adjust = 1;\n                    days = d;\n                  }\n              }\n\n            switch (*f)\n              {\n              case L_('g'):\n                {\n                  int yy = (tp->tm_year % 100 + year_adjust) % 100;\n                  DO_NUMBER (2, (0 <= yy\n                                 ? yy\n                                 : tp->tm_year < -TM_YEAR_BASE - year_adjust\n                                 ? -yy\n                                 : yy + 100));\n                }\n\n              case L_('G'):\n                DO_SIGNED_NUMBER (4, tp->tm_year < -TM_YEAR_BASE - year_adjust,\n                                  (tp->tm_year + (unsigned int) TM_YEAR_BASE\n                                   + year_adjust));\n\n              default:\n                DO_NUMBER (2, days / 7 + 1);\n              }\n          }\n\n        case L_('W'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, (tp->tm_yday - (tp->tm_wday - 1 + 7) % 7 + 7) / 7);\n\n        case L_('w'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (1, tp->tm_wday);\n\n        case L_('Y'):\n          if (modifier == 'E')\n            {\n#if HAVE_STRUCT_ERA_ENTRY\n              struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n              if (era)\n                {\n# ifdef COMPILE_WIDE\n                  subfmt = era->era_wformat;\n# else\n                  subfmt = era->era_format;\n# endif\n                  goto subformat;\n                }\n#else\n              goto underlying_strftime;\n#endif\n            }\n          if (modifier == L_('O'))\n            goto bad_format;\n\n          DO_SIGNED_NUMBER (4, tp->tm_year < -TM_YEAR_BASE,\n                            tp->tm_year + (unsigned int) TM_YEAR_BASE);\n\n        case L_('y'):\n          if (modifier == L_('E'))\n            {\n#if HAVE_STRUCT_ERA_ENTRY\n              struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n              if (era)\n                {\n                  int delta = tp->tm_year - era->start_date[0];\n                  DO_NUMBER (1, (era->offset\n                                 + delta * era->absolute_direction));\n                }\n#else\n              goto underlying_strftime;\n#endif\n            }\n\n          {\n            int yy = tp->tm_year % 100;\n            if (yy < 0)\n              yy = tp->tm_year < - TM_YEAR_BASE ? -yy : yy + 100;\n            DO_NUMBER (2, yy);\n          }\n\n        case L_('Z'):\n          if (change_case)\n            {\n              to_uppcase = false;\n              to_lowcase = true;\n            }\n\n#if HAVE_TZNAME\n          /* The tzset() call might have changed the value.  */\n          if (!(zone && *zone) && tp->tm_isdst >= 0)\n            zone = tzname[tp->tm_isdst != 0];\n#endif\n          if (! zone)\n            zone = \"\";\n\n#ifdef COMPILE_WIDE\n          {\n            /* The zone string is always given in multibyte form.  We have\n               to transform it first.  */\n            wchar_t *wczone;\n            size_t len;\n            widen (zone, wczone, len);\n            cpy (len, wczone);\n          }\n#else\n          cpy (strlen (zone), zone);\n#endif\n          break;\n\n        case L_(':'):\n          /* :, ::, and ::: are valid only just before 'z'.\n             :::: etc. are rejected later.  */\n          for (colons = 1; f[colons] == L_(':'); colons++)\n            continue;\n          if (f[colons] != L_('z'))\n            goto bad_format;\n          f += colons;\n          goto do_z_conversion;\n\n        case L_('z'):\n          colons = 0;\n\n        do_z_conversion:\n          if (tp->tm_isdst < 0)\n            break;\n\n          {\n            int diff;\n            int hour_diff;\n            int min_diff;\n            int sec_diff;\n#if HAVE_TM_GMTOFF\n            diff = tp->tm_gmtoff;\n#else\n            if (ut)\n              diff = 0;\n            else\n              {\n                struct tm gtm;\n                struct tm ltm;\n                time_t lt;\n\n                ltm = *tp;\n                lt = mktime (&ltm);\n\n                if (lt == (time_t) -1)\n                  {\n                    /* mktime returns -1 for errors, but -1 is also a\n                       valid time_t value.  Check whether an error really\n                       occurred.  */\n                    struct tm tm;\n\n                    if (! __localtime_r (&lt, &tm)\n                        || ((ltm.tm_sec ^ tm.tm_sec)\n                            | (ltm.tm_min ^ tm.tm_min)\n                            | (ltm.tm_hour ^ tm.tm_hour)\n                            | (ltm.tm_mday ^ tm.tm_mday)\n                            | (ltm.tm_mon ^ tm.tm_mon)\n                            | (ltm.tm_year ^ tm.tm_year)))\n                      break;\n                  }\n\n                if (! __gmtime_r (&lt, &gtm))\n                  break;\n\n                diff = tm_diff (&ltm, &gtm);\n              }\n#endif\n\n            hour_diff = diff / 60 / 60;\n            min_diff = diff / 60 % 60;\n            sec_diff = diff % 60;\n\n            switch (colons)\n              {\n              case 0: /* +hhmm */\n                DO_TZ_OFFSET (5, diff < 0, 0, hour_diff * 100 + min_diff);\n\n              case 1: tz_hh_mm: /* +hh:mm */\n                DO_TZ_OFFSET (6, diff < 0, 04, hour_diff * 100 + min_diff);\n\n              case 2: tz_hh_mm_ss: /* +hh:mm:ss */\n                DO_TZ_OFFSET (9, diff < 0, 024,\n                              hour_diff * 10000 + min_diff * 100 + sec_diff);\n\n              case 3: /* +hh if possible, else +hh:mm, else +hh:mm:ss */\n                if (sec_diff != 0)\n                  goto tz_hh_mm_ss;\n                if (min_diff != 0)\n                  goto tz_hh_mm;\n                DO_TZ_OFFSET (3, diff < 0, 0, hour_diff);\n\n              default:\n                goto bad_format;\n              }\n          }\n\n        case L_('\\0'):          /* GNU extension: % at end of format.  */\n            --f;\n            /* Fall through.  */\n        default:\n          /* Unknown format; output the format, including the '%',\n             since this is most likely the right thing to do if a\n             multibyte string has been misparsed.  */\n        bad_format:\n          {\n            int flen;\n            for (flen = 1; f[1 - flen] != L_('%'); flen++)\n              continue;\n            cpy (flen, &f[1 - flen]);\n          }\n          break;\n        }\n    }\n\n#if ! FPRINTFTIME\n  if (p && maxsize != 0)\n    *p = L_('\\0');\n#endif\n\n  return i;\n}",
      "lines": 1036,
      "depth": 27,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "my_strftime": {
      "start_point": [
        1463,
        0
      ],
      "end_point": [
        1470,
        1
      ],
      "content": "size_t\nmy_strftime (STREAM_OR_CHAR_T *s, STRFTIME_ARG (size_t maxsize)\n             const CHAR_T *format,\n             const struct tm *tp extra_args_spec LOCALE_PARAM_PROTO)\n{\n  return strftime_case_ (false, s, STRFTIME_ARG (maxsize)\n                         format, tp extra_args LOCALE_ARG);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "emacs_strftimeu": {
      "start_point": [
        1480,
        0
      ],
      "end_point": [
        1485,
        1
      ],
      "content": "size_t\nemacs_strftimeu (char *s, size_t maxsize, const char *format,\n                 const struct tm *tp, int ut)\n{\n  return my_strftime (s, maxsize, format, tp, ut, 0);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/strftime.h": {},
  "sharutils/sharutils-4.15.2/lib/string.in.h": {},
  "sharutils/sharutils-4.15.2/lib/stripslash.c": {
    "strip_trailing_slashes": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "bool\nstrip_trailing_slashes (char *file)\n{\n  char *base = last_component (file);\n  char *base_lim;\n  bool had_slash;\n\n  /* last_component returns \"\" for file system roots, but we need to turn\n     \"///\" into \"/\".  */\n  if (! *base)\n    base = file;\n  base_lim = base + base_len (base);\n  had_slash = (*base_lim != '\\0');\n  *base_lim = '\\0';\n  return had_slash;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/strndup.c": {
    "strndup": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "char *\nstrndup (char const *s, size_t n)\n{\n  size_t len = strnlen (s, n);\n  char *new = malloc (len + 1);\n\n  if (new == NULL)\n    return NULL;\n\n  new[len] = '\\0';\n  return memcpy (new, s, len);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "char",
        "*\nstrndup (char const *s, size_t n)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/strnlen.c": {
    "strnlen": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "size_t\nstrnlen (const char *string, size_t maxlen)\n{\n  const char *end = memchr (string, '\\0', maxlen);\n  return end ? (size_t) (end - string) : maxlen;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/strtoimax.c": {
    "Strtoimax": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "Int\nStrtoimax (char const *ptr, char **endptr, int base)\n{\n#if Have_long_long\n  verify (sizeof (Int) == sizeof (Unsigned long int)\n          || sizeof (Int) == sizeof (Unsigned long long int));\n\n  if (sizeof (Int) != sizeof (Unsigned long int))\n    return Strtoll (ptr, endptr, base);\n#else\n  verify (sizeof (Int) == sizeof (Unsigned long int));\n#endif\n\n  return Strtol (ptr, endptr, base);\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "Int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/strtol.c": {
    "INTERNAL": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        419,
        1
      ],
      "content": "INT\nINTERNAL (strtol) (const STRING_TYPE *nptr, STRING_TYPE **endptr,\n                   int base, int group LOCALE_PARAM_PROTO)\n{\n  int negative;\n  register unsigned LONG int cutoff;\n  register unsigned int cutlim;\n  register unsigned LONG int i;\n  register const STRING_TYPE *s;\n  register UCHAR_TYPE c;\n  const STRING_TYPE *save, *end;\n  int overflow;\n\n#ifdef USE_NUMBER_GROUPING\n# ifdef USE_IN_EXTENDED_LOCALE_MODEL\n  struct locale_data *current = loc->__locales[LC_NUMERIC];\n# endif\n  /* The thousands character of the current locale.  */\n  wchar_t thousands = L'\\0';\n  /* The numeric grouping specification of the current locale,\n     in the format described in <locale.h>.  */\n  const char *grouping;\n\n  if (group)\n    {\n      grouping = _NL_CURRENT (LC_NUMERIC, GROUPING);\n      if (*grouping <= 0 || *grouping == CHAR_MAX)\n        grouping = NULL;\n      else\n        {\n          /* Figure out the thousands separator character.  */\n# if defined _LIBC || defined _HAVE_BTOWC\n          thousands = __btowc (*_NL_CURRENT (LC_NUMERIC, THOUSANDS_SEP));\n          if (thousands == WEOF)\n            thousands = L'\\0';\n# endif\n          if (thousands == L'\\0')\n            grouping = NULL;\n        }\n    }\n  else\n    grouping = NULL;\n#endif\n\n  if (base < 0 || base == 1 || base > 36)\n    {\n      __set_errno (EINVAL);\n      return 0;\n    }\n\n  save = s = nptr;\n\n  /* Skip white space.  */\n  while (ISSPACE (*s))\n    ++s;\n  if (*s == L_('\\0'))\n    goto noconv;\n\n  /* Check for a sign.  */\n  if (*s == L_('-'))\n    {\n      negative = 1;\n      ++s;\n    }\n  else if (*s == L_('+'))\n    {\n      negative = 0;\n      ++s;\n    }\n  else\n    negative = 0;\n\n  /* Recognize number prefix and if BASE is zero, figure it out ourselves.  */\n  if (*s == L_('0'))\n    {\n      if ((base == 0 || base == 16) && TOUPPER (s[1]) == L_('X'))\n        {\n          s += 2;\n          base = 16;\n        }\n      else if (base == 0)\n        base = 8;\n    }\n  else if (base == 0)\n    base = 10;\n\n  /* Save the pointer so we can check later if anything happened.  */\n  save = s;\n\n#ifdef USE_NUMBER_GROUPING\n  if (group)\n    {\n      /* Find the end of the digit string and check its grouping.  */\n      end = s;\n      for (c = *end; c != L_('\\0'); c = *++end)\n        if ((wchar_t) c != thousands\n            && ((wchar_t) c < L_('0') || (wchar_t) c > L_('9'))\n            && (!ISALPHA (c) || (int) (TOUPPER (c) - L_('A') + 10) >= base))\n          break;\n      if (*s == thousands)\n        end = s;\n      else\n        end = correctly_grouped_prefix (s, end, thousands, grouping);\n    }\n  else\n#endif\n    end = NULL;\n\n  cutoff = STRTOL_ULONG_MAX / (unsigned LONG int) base;\n  cutlim = STRTOL_ULONG_MAX % (unsigned LONG int) base;\n\n  overflow = 0;\n  i = 0;\n  for (c = *s; c != L_('\\0'); c = *++s)\n    {\n      if (s == end)\n        break;\n      if (c >= L_('0') && c <= L_('9'))\n        c -= L_('0');\n      else if (ISALPHA (c))\n        c = TOUPPER (c) - L_('A') + 10;\n      else\n        break;\n      if ((int) c >= base)\n        break;\n      /* Check for overflow.  */\n      if (i > cutoff || (i == cutoff && c > cutlim))\n        overflow = 1;\n      else\n        {\n          i *= (unsigned LONG int) base;\n          i += c;\n        }\n    }\n\n  /* Check if anything actually happened.  */\n  if (s == save)\n    goto noconv;\n\n  /* Store in ENDPTR the address of one character\n     past the last character we converted.  */\n  if (endptr != NULL)\n    *endptr = (STRING_TYPE *) s;\n\n#if !UNSIGNED\n  /* Check for a value that is within the range of\n     'unsigned LONG int', but outside the range of 'LONG int'.  */\n  if (overflow == 0\n      && i > (negative\n              ? -((unsigned LONG int) (STRTOL_LONG_MIN + 1)) + 1\n              : (unsigned LONG int) STRTOL_LONG_MAX))\n    overflow = 1;\n#endif\n\n  if (overflow)\n    {\n      __set_errno (ERANGE);\n#if UNSIGNED\n      return STRTOL_ULONG_MAX;\n#else\n      return negative ? STRTOL_LONG_MIN : STRTOL_LONG_MAX;\n#endif\n    }\n\n  /* Return the result of the appropriate sign.  */\n  return negative ? -i : i;\n\nnoconv:\n  /* We must handle a special case here: the base is 0 or 16 and the\n     first two characters are '0' and 'x', but the rest are no\n     hexadecimal digits.  This is no error case.  We return 0 and\n     ENDPTR points to the 'x'.  */\n  if (endptr != NULL)\n    {\n      if (save - nptr >= 2 && TOUPPER (save[-1]) == L_('X')\n          && save[-2] == L_('0'))\n        *endptr = (STRING_TYPE *) &save[-1];\n      else\n        /*  There was no number to convert.  */\n        *endptr = (STRING_TYPE *) nptr;\n    }\n\n  return 0L;\n}",
      "lines": 184,
      "depth": 20,
      "decorators": [
        "INT"
      ]
    },
    "strtol": {
      "start_point": [
        426,
        0
      ],
      "end_point": [
        432,
        1
      ],
      "content": "weak_function\n#endif\nstrtol (const STRING_TYPE *nptr, STRING_TYPE **endptr,\n        int base LOCALE_PARAM_PROTO)\n{\n  return INTERNAL (strtol) (nptr, endptr, base, 0 LOCALE_PARAM);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "weak_function",
        "#endif",
        "#endif"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/strtoll.c": {},
  "sharutils/sharutils-4.15.2/lib/system.h": {},
  "sharutils/sharutils-4.15.2/lib/sys_socket.c": {},
  "sharutils/sharutils-4.15.2/lib/sys_socket.in.h": {
    "rpl_fd_isset": {
      "start_point": [
        211,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "_GL_SYS_SOCKET_INLINE int\nrpl_fd_isset (SOCKET fd, fd_set * set)\n{\n  u_int i;\n  if (set == NULL)\n    return 0;\n\n  for (i = 0; i < set->fd_count; i++)\n    if (set->fd_array[i] == fd)\n      return 1;\n\n  return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "_GL_SYS_SOCKET_INLINE",
        "int",
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/sys_stat.in.h": {
    "rpl_mkdir": {
      "start_point": [
        503,
        0
      ],
      "end_point": [
        507,
        1
      ],
      "content": "static int\nrpl_mkdir (char const *name, mode_t mode)\n{\n  return _mkdir (name);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/sys_time.in.h": {},
  "sharutils/sharutils-4.15.2/lib/sys_types.in.h": {},
  "sharutils/sharutils-4.15.2/lib/sys_uio.in.h": {},
  "sharutils/sharutils-4.15.2/lib/sys_utsname.in.h": {},
  "sharutils/sharutils-4.15.2/lib/sys_wait.in.h": {},
  "sharutils/sharutils-4.15.2/lib/tempname.c": {
    "direxists": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "static int\ndirexists (const char *dir)\n{\n  struct_stat64 buf;\n  return __xstat64 (_STAT_VER, dir, &buf) == 0 && S_ISDIR (buf.st_mode);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "__path_search": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "int\n__path_search (char *tmpl, size_t tmpl_len, const char *dir, const char *pfx,\n               int try_tmpdir)\n{\n  const char *d;\n  size_t dlen, plen;\n\n  if (!pfx || !pfx[0])\n    {\n      pfx = \"file\";\n      plen = 4;\n    }\n  else\n    {\n      plen = strlen (pfx);\n      if (plen > 5)\n        plen = 5;\n    }\n\n  if (try_tmpdir)\n    {\n      d = __secure_getenv (\"TMPDIR\");\n      if (d != NULL && direxists (d))\n        dir = d;\n      else if (dir != NULL && direxists (dir))\n        /* nothing */ ;\n      else\n        dir = NULL;\n    }\n  if (dir == NULL)\n    {\n      if (direxists (P_tmpdir))\n        dir = P_tmpdir;\n      else if (strcmp (P_tmpdir, \"/tmp\") != 0 && direxists (\"/tmp\"))\n        dir = \"/tmp\";\n      else\n        {\n          __set_errno (ENOENT);\n          return -1;\n        }\n    }\n\n  dlen = strlen (dir);\n  while (dlen > 1 && dir[dlen - 1] == '/')\n    dlen--;                     /* remove trailing slashes */\n\n  /* check we have room for \"${dir}/${pfx}XXXXXX\\0\" */\n  if (tmpl_len < dlen + 1 + plen + 6 + 1)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  sprintf (tmpl, \"%.*s/%.*sXXXXXX\", (int) dlen, dir, (int) plen, pfx);\n  return 0;\n}",
      "lines": 56,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "__try_tempname": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        259,
        1
      ],
      "content": "int\n__try_tempname (char *tmpl, int suffixlen, void *args,\n                int (*tryfunc) (char *, void *))\n{\n  int len;\n  char *XXXXXX;\n  static uint64_t value;\n  uint64_t random_time_bits;\n  unsigned int count;\n  int fd = -1;\n  int save_errno = errno;\n\n  /* A lower bound on the number of temporary files to attempt to\n     generate.  The maximum total number of temporary file names that\n     can exist for a given template is 62**6.  It should never be\n     necessary to try all of these combinations.  Instead if a reasonable\n     number of names is tried (we define reasonable as 62**3) fail to\n     give the system administrator the chance to remove the problems.  */\n#define ATTEMPTS_MIN (62 * 62 * 62)\n\n  /* The number of times to attempt to generate a temporary file.  To\n     conform to POSIX, this must be no smaller than TMP_MAX.  */\n#if ATTEMPTS_MIN < TMP_MAX\n  unsigned int attempts = TMP_MAX;\n#else\n  unsigned int attempts = ATTEMPTS_MIN;\n#endif\n\n  len = strlen (tmpl);\n  if (len < 6 + suffixlen || memcmp (&tmpl[len - 6 - suffixlen], \"XXXXXX\", 6))\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  /* This is where the Xs start.  */\n  XXXXXX = &tmpl[len - 6 - suffixlen];\n\n  /* Get some more or less random data.  */\n#ifdef RANDOM_BITS\n  RANDOM_BITS (random_time_bits);\n#else\n  {\n    struct timeval tv;\n    __gettimeofday (&tv, NULL);\n    random_time_bits = ((uint64_t) tv.tv_usec << 16) ^ tv.tv_sec;\n  }\n#endif\n  value += random_time_bits ^ __getpid ();\n\n  for (count = 0; count < attempts; value += 7777, ++count)\n    {\n      uint64_t v = value;\n\n      /* Fill in the random bits.  */\n      XXXXXX[0] = letters[v % 62];\n      v /= 62;\n      XXXXXX[1] = letters[v % 62];\n      v /= 62;\n      XXXXXX[2] = letters[v % 62];\n      v /= 62;\n      XXXXXX[3] = letters[v % 62];\n      v /= 62;\n      XXXXXX[4] = letters[v % 62];\n      v /= 62;\n      XXXXXX[5] = letters[v % 62];\n\n      fd = tryfunc (tmpl, args);\n      if (fd >= 0)\n        {\n          __set_errno (save_errno);\n          return fd;\n        }\n      else if (errno != EEXIST)\n        return -1;\n    }\n\n  /* We got out of the loop because we ran out of combinations to try.  */\n  __set_errno (EEXIST);\n  return -1;\n}",
      "lines": 81,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "try_file": {
      "start_point": [
        261,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "static int\ntry_file (char *tmpl, void *flags)\n{\n  int *openflags = flags;\n  return __open (tmpl,\n                 (*openflags & ~O_ACCMODE)\n                 | O_RDWR | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR);\n}",
      "lines": 8,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "try_dir": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        274,
        1
      ],
      "content": "static int\ntry_dir (char *tmpl, void *flags _GL_UNUSED)\n{\n  return __mkdir (tmpl, S_IRUSR | S_IWUSR | S_IXUSR);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "try_nocreate": {
      "start_point": [
        276,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "static int\ntry_nocreate (char *tmpl, void *flags _GL_UNUSED)\n{\n  struct_stat64 st;\n\n  if (__lxstat64 (_STAT_VER, tmpl, &st) == 0)\n    __set_errno (EEXIST);\n  return errno == ENOENT ? 0 : -1;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "__gen_tempname": {
      "start_point": [
        299,
        0
      ],
      "end_point": [
        323,
        1
      ],
      "content": "int\n__gen_tempname (char *tmpl, int suffixlen, int flags, int kind)\n{\n  int (*tryfunc) (char *, void *);\n\n  switch (kind)\n    {\n    case __GT_FILE:\n      tryfunc = try_file;\n      break;\n\n    case __GT_DIR:\n      tryfunc = try_dir;\n      break;\n\n    case __GT_NOCREATE:\n      tryfunc = try_nocreate;\n      break;\n\n    default:\n      assert (! \"invalid KIND in __gen_tempname\");\n      abort ();\n    }\n  return __try_tempname (tmpl, suffixlen, &flags, tryfunc);\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/tempname.h": {},
  "sharutils/sharutils-4.15.2/lib/time.in.h": {},
  "sharutils/sharutils-4.15.2/lib/time_r.c": {
    "copy_tm_result": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "static struct tm *\ncopy_tm_result (struct tm *dest, struct tm const *src)\n{\n  if (! src)\n    return 0;\n  *dest = *src;\n  return dest;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct tm",
        "struct",
        "tm",
        "*\ncopy_tm_result (struct tm *dest, struct tm const *src)",
        "*"
      ]
    },
    "gmtime_r": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "struct tm *\ngmtime_r (time_t const * restrict t, struct tm * restrict tp)\n{\n  return copy_tm_result (tp, gmtime (t));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\ngmtime_r (time_t const * restrict t, struct tm * restrict tp)",
        "*"
      ]
    },
    "localtime_r": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "struct tm *\nlocaltime_r (time_t const * restrict t, struct tm * restrict tp)\n{\n  return copy_tm_result (tp, localtime (t));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nlocaltime_r (time_t const * restrict t, struct tm * restrict tp)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/uinttostr.c": {},
  "sharutils/sharutils-4.15.2/lib/umaxtostr.c": {},
  "sharutils/sharutils-4.15.2/lib/uname.c": {
    "uname": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        265,
        1
      ],
      "content": "int\nuname (struct utsname *buf)\n{\n  OSVERSIONINFO version;\n  OSVERSIONINFOEX versionex;\n  BOOL have_versionex; /* indicates whether versionex is filled */\n  const char *super_version;\n\n  /* Preparation: Fill version and, if possible, also versionex.\n     But try to call GetVersionEx only once in the common case.  */\n  versionex.dwOSVersionInfoSize = sizeof (OSVERSIONINFOEX);\n  have_versionex = GetVersionEx ((OSVERSIONINFO *) &versionex);\n  if (have_versionex)\n    {\n      /* We know that OSVERSIONINFO is a subset of OSVERSIONINFOEX.  */\n      memcpy (&version, &versionex, sizeof (OSVERSIONINFO));\n    }\n  else\n    {\n      version.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);\n      if (!GetVersionEx (&version))\n        abort ();\n    }\n\n  /* Fill in nodename.  */\n  if (gethostname (buf->nodename, sizeof (buf->nodename)) < 0)\n    strcpy (buf->nodename, \"localhost\");\n\n  /* Determine major-major Windows version.  */\n  if (version.dwPlatformId == VER_PLATFORM_WIN32_NT)\n    {\n      /* Windows NT or newer.  */\n      super_version = \"NT\";\n    }\n  else if (version.dwPlatformId == VER_PLATFORM_WIN32_CE)\n    {\n      /* Windows CE or Embedded CE.  */\n      super_version = \"CE\";\n    }\n  else if (version.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)\n    {\n      /* Windows 95/98/ME.  */\n      switch (version.dwMinorVersion)\n        {\n        case 0:\n          super_version = \"95\";\n          break;\n        case 10:\n          super_version = \"98\";\n          break;\n        case 90:\n          super_version = \"ME\";\n          break;\n        default:\n          super_version = \"\";\n          break;\n        }\n    }\n  else\n    super_version = \"\";\n\n  /* Fill in sysname.  */\n#ifdef __MINGW32__\n  /* Returns a string compatible with the MSYS uname.exe program,\n     so that no further changes are needed to GNU config.guess.\n     For example,\n       $ ./uname.exe -s      => MINGW32_NT-5.1\n   */\n  sprintf (buf->sysname, \"MINGW32_%s-%u.%u\", super_version,\n           (unsigned int) version.dwMajorVersion,\n           (unsigned int) version.dwMinorVersion);\n#else\n  sprintf (buf->sysname, \"Windows%s\", super_version);\n#endif\n\n  /* Fill in release, version.  */\n  /* The MSYS uname.exe programs uses strings from a modified Cygwin runtime:\n       $ ./uname.exe -r      => 1.0.11(0.46/3/2)\n       $ ./uname.exe -v      => 2008-08-25 23:40\n     There is no point in imitating this behaviour.  */\n  if (version.dwPlatformId == VER_PLATFORM_WIN32_NT)\n    {\n      /* Windows NT or newer.  */\n      struct windows_version\n        {\n          int major;\n          int minor;\n          unsigned int server_offset;\n          const char *name;\n        };\n\n      /* Storing the workstation and server version names in a single\n         stream does not waste memory when they are the same.  These\n         macros abstract the representation.  VERSION1 is used if\n         version.wProductType does not matter, VERSION2 if it does.  */\n      #define VERSION1(major, minor, name) \\\n        { major, minor, 0, name }\n      #define VERSION2(major, minor, workstation, server) \\\n        { major, minor, sizeof workstation, workstation \"\\0\" server }\n      static const struct windows_version versions[] =\n        {\n          VERSION2 (3, -1, \"Windows NT Workstation\", \"Windows NT Server\"),\n          VERSION2 (4, -1, \"Windows NT Workstation\", \"Windows NT Server\"),\n          VERSION1 (5, 0, \"Windows 2000\"),\n          VERSION1 (5, 1, \"Windows XP\"),\n          VERSION1 (5, 2, \"Windows Server 2003\"),\n          VERSION2 (6, 0, \"Windows Vista\", \"Windows Server 2008\"),\n          VERSION2 (6, 1, \"Windows 7\", \"Windows Server 2008 R2\"),\n          VERSION2 (-1, -1, \"Windows\", \"Windows Server\")\n        };\n      const char *base;\n      const struct windows_version *v = versions;\n\n      /* Find a version that matches ours.  The last element is a\n         wildcard that always ends the loop.  */\n      while ((v->major != version.dwMajorVersion && v->major != -1)\n             || (v->minor != version.dwMinorVersion && v->minor != -1))\n        v++;\n\n      if (have_versionex && versionex.wProductType != VER_NT_WORKSTATION)\n        base = v->name + v->server_offset;\n      else\n        base = v->name;\n      if (v->major == -1 || v->minor == -1)\n        sprintf (buf->release, \"%s %u.%u\",\n                 base,\n                 (unsigned int) version.dwMajorVersion,\n                 (unsigned int) version.dwMinorVersion);\n      else\n        strcpy (buf->release, base);\n    }\n  else if (version.dwPlatformId == VER_PLATFORM_WIN32_CE)\n    {\n      /* Windows CE or Embedded CE.  */\n      sprintf (buf->release, \"Windows CE %u.%u\",\n               (unsigned int) version.dwMajorVersion,\n               (unsigned int) version.dwMinorVersion);\n    }\n  else\n    {\n      /* Windows 95/98/ME.  */\n      sprintf (buf->release, \"Windows %s\", super_version);\n    }\n  strcpy (buf->version, version.szCSDVersion);\n\n  /* Fill in machine.  */\n  {\n    SYSTEM_INFO info;\n\n    GetSystemInfo (&info);\n    /* Check for Windows NT or CE, since the info.wProcessorLevel is\n       garbage on Windows 95. */\n    if (version.dwPlatformId == VER_PLATFORM_WIN32_NT\n        || version.dwPlatformId == VER_PLATFORM_WIN32_CE)\n      {\n        /* Windows NT or newer, or Windows CE or Embedded CE.  */\n        switch (info.wProcessorArchitecture)\n          {\n          case PROCESSOR_ARCHITECTURE_AMD64:\n            strcpy (buf->machine, \"x86_64\");\n            break;\n          case PROCESSOR_ARCHITECTURE_IA64:\n            strcpy (buf->machine, \"ia64\");\n            break;\n          case PROCESSOR_ARCHITECTURE_INTEL:\n            strcpy (buf->machine, \"i386\");\n            if (info.wProcessorLevel >= 3)\n              buf->machine[1] =\n                '0' + (info.wProcessorLevel <= 6 ? info.wProcessorLevel : 6);\n            break;\n          case PROCESSOR_ARCHITECTURE_IA32_ON_WIN64:\n            strcpy (buf->machine, \"i686\");\n            break;\n          case PROCESSOR_ARCHITECTURE_MIPS:\n            strcpy (buf->machine, \"mips\");\n            break;\n          case PROCESSOR_ARCHITECTURE_ALPHA:\n          case PROCESSOR_ARCHITECTURE_ALPHA64:\n            strcpy (buf->machine, \"alpha\");\n            break;\n          case PROCESSOR_ARCHITECTURE_PPC:\n            strcpy (buf->machine, \"powerpc\");\n            break;\n          case PROCESSOR_ARCHITECTURE_SHX:\n            strcpy (buf->machine, \"sh\");\n            break;\n          case PROCESSOR_ARCHITECTURE_ARM:\n            strcpy (buf->machine, \"arm\");\n            break;\n          default:\n            strcpy (buf->machine, \"unknown\");\n            break;\n          }\n      }\n    else\n      {\n        /* Windows 95/98/ME.  */\n        switch (info.dwProcessorType)\n          {\n          case PROCESSOR_AMD_X8664:\n            strcpy (buf->machine, \"x86_64\");\n            break;\n          case PROCESSOR_INTEL_IA64:\n            strcpy (buf->machine, \"ia64\");\n            break;\n          default:\n            if (info.dwProcessorType % 100 == 86)\n              sprintf (buf->machine, \"i%u\",\n                       (unsigned int) info.dwProcessorType);\n            else\n              strcpy (buf->machine, \"unknown\");\n            break;\n          }\n      }\n  }\n\n  return 0;\n}",
      "lines": 218,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/unistd--.h": {},
  "sharutils/sharutils-4.15.2/lib/unistd-safer.h": {},
  "sharutils/sharutils-4.15.2/lib/unistd.c": {},
  "sharutils/sharutils-4.15.2/lib/unistd.in.h": {
    "rpl_environ": {
      "start_point": [
        423,
        0
      ],
      "end_point": [
        427,
        1
      ],
      "content": "_GL_UNISTD_INLINE char ***\nrpl_environ (void)\n{\n  return &environ;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "char",
        "char",
        "***\nrpl_environ (void)",
        "*",
        "**\nrpl_environ (void)",
        "*",
        "*\nrpl_environ (void)",
        "*"
      ]
    },
    "getpagesize": {
      "start_point": [
        890,
        0
      ],
      "end_point": [
        894,
        1
      ],
      "content": "_GL_UNISTD_INLINE int\ngetpagesize ()\n{\n  return _gl_getpagesize ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "int",
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/unlocked-io.h": {},
  "sharutils/sharutils-4.15.2/lib/verify.h": {},
  "sharutils/sharutils-4.15.2/lib/w32sock.h": {
    "set_winsock_errno": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static inline void\nset_winsock_errno (void)\n{\n  int err = WSAGetLastError ();\n\n  /* Map some WSAE* errors to the runtime library's error codes.  */\n  switch (err)\n    {\n    case WSA_INVALID_HANDLE:\n      errno = EBADF;\n      break;\n    case WSA_NOT_ENOUGH_MEMORY:\n      errno = ENOMEM;\n      break;\n    case WSA_INVALID_PARAMETER:\n      errno = EINVAL;\n      break;\n    case WSAENAMETOOLONG:\n      errno = ENAMETOOLONG;\n      break;\n    case WSAENOTEMPTY:\n      errno = ENOTEMPTY;\n      break;\n    case WSAEWOULDBLOCK:\n      errno = EWOULDBLOCK;\n      break;\n    case WSAEINPROGRESS:\n      errno = EINPROGRESS;\n      break;\n    case WSAEALREADY:\n      errno = EALREADY;\n      break;\n    case WSAENOTSOCK:\n      errno = ENOTSOCK;\n      break;\n    case WSAEDESTADDRREQ:\n      errno = EDESTADDRREQ;\n      break;\n    case WSAEMSGSIZE:\n      errno = EMSGSIZE;\n      break;\n    case WSAEPROTOTYPE:\n      errno = EPROTOTYPE;\n      break;\n    case WSAENOPROTOOPT:\n      errno = ENOPROTOOPT;\n      break;\n    case WSAEPROTONOSUPPORT:\n      errno = EPROTONOSUPPORT;\n      break;\n    case WSAEOPNOTSUPP:\n      errno = EOPNOTSUPP;\n      break;\n    case WSAEAFNOSUPPORT:\n      errno = EAFNOSUPPORT;\n      break;\n    case WSAEADDRINUSE:\n      errno = EADDRINUSE;\n      break;\n    case WSAEADDRNOTAVAIL:\n      errno = EADDRNOTAVAIL;\n      break;\n    case WSAENETDOWN:\n      errno = ENETDOWN;\n      break;\n    case WSAENETUNREACH:\n      errno = ENETUNREACH;\n      break;\n    case WSAENETRESET:\n      errno = ENETRESET;\n      break;\n    case WSAECONNABORTED:\n      errno = ECONNABORTED;\n      break;\n    case WSAECONNRESET:\n      errno = ECONNRESET;\n      break;\n    case WSAENOBUFS:\n      errno = ENOBUFS;\n      break;\n    case WSAEISCONN:\n      errno = EISCONN;\n      break;\n    case WSAENOTCONN:\n      errno = ENOTCONN;\n      break;\n    case WSAETIMEDOUT:\n      errno = ETIMEDOUT;\n      break;\n    case WSAECONNREFUSED:\n      errno = ECONNREFUSED;\n      break;\n    case WSAELOOP:\n      errno = ELOOP;\n      break;\n    case WSAEHOSTUNREACH:\n      errno = EHOSTUNREACH;\n      break;\n    default:\n      errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n      break;\n    }\n}",
      "lines": 103,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/w32spawn.h": {
    "dup_noinherit": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "static int\ndup_noinherit (int fd)\n{\n  fd = dup_cloexec (fd);\n  if (fd < 0 && errno == EMFILE)\n    error (EXIT_FAILURE, errno, _(\"_open_osfhandle failed\"));\n\n  return fd;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fd_safer_noinherit": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static int\nfd_safer_noinherit (int fd)\n{\n  if (STDIN_FILENO <= fd && fd <= STDERR_FILENO)\n    {\n      /* The recursion depth is at most 3.  */\n      int nfd = fd_safer_noinherit (dup_noinherit (fd));\n      int saved_errno = errno;\n      close (fd);\n      errno = saved_errno;\n      return nfd;\n    }\n  return fd;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dup_safer_noinherit": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static int\ndup_safer_noinherit (int fd)\n{\n  return fd_safer_noinherit (dup_noinherit (fd));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "undup_safer_noinherit": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static void\nundup_safer_noinherit (int tempfd, int origfd)\n{\n  if (tempfd >= 0)\n    {\n      if (dup2 (tempfd, origfd) < 0)\n        error (EXIT_FAILURE, errno, _(\"cannot restore fd %d: dup2 failed\"),\n               origfd);\n      close (tempfd);\n    }\n  else\n    {\n      /* origfd was closed or open to no handle at all.  Set it to a closed\n         state.  This is (nearly) equivalent to the original state.  */\n      close (origfd);\n    }\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "prepare_spawn": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "static char **\nprepare_spawn (char **argv)\n{\n  size_t argc;\n  char **new_argv;\n  size_t i;\n\n  /* Count number of arguments.  */\n  for (argc = 0; argv[argc] != NULL; argc++)\n    ;\n\n  /* Allocate new argument vector.  */\n  new_argv = XNMALLOC (1 + argc + 1, char *);\n\n  /* Add an element upfront that can be used when argv[0] turns out to be a\n     script, not a program.\n     On Unix, this would be \"/bin/sh\". On native Windows, \"sh\" is actually\n     \"sh.exe\".  We have to omit the directory part and rely on the search in\n     PATH, because the mingw \"mount points\" are not visible inside Windows\n     CreateProcess().  */\n  *new_argv++ = \"sh.exe\";\n\n  /* Put quoted arguments into the new argument vector.  */\n  for (i = 0; i < argc; i++)\n    {\n      const char *string = argv[i];\n\n      if (string[0] == '\\0')\n        new_argv[i] = xstrdup (\"\\\"\\\"\");\n      else if (strpbrk (string, SHELL_SPECIAL_CHARS) != NULL)\n        {\n          bool quote_around = (strpbrk (string, SHELL_SPACE_CHARS) != NULL);\n          size_t length;\n          unsigned int backslashes;\n          const char *s;\n          char *quoted_string;\n          char *p;\n\n          length = 0;\n          backslashes = 0;\n          if (quote_around)\n            length++;\n          for (s = string; *s != '\\0'; s++)\n            {\n              char c = *s;\n              if (c == '\"')\n                length += backslashes + 1;\n              length++;\n              if (c == '\\\\')\n                backslashes++;\n              else\n                backslashes = 0;\n            }\n          if (quote_around)\n            length += backslashes + 1;\n\n          quoted_string = (char *) xmalloc (length + 1);\n\n          p = quoted_string;\n          backslashes = 0;\n          if (quote_around)\n            *p++ = '\"';\n          for (s = string; *s != '\\0'; s++)\n            {\n              char c = *s;\n              if (c == '\"')\n                {\n                  unsigned int j;\n                  for (j = backslashes + 1; j > 0; j--)\n                    *p++ = '\\\\';\n                }\n              *p++ = c;\n              if (c == '\\\\')\n                backslashes++;\n              else\n                backslashes = 0;\n            }\n          if (quote_around)\n            {\n              unsigned int j;\n              for (j = backslashes; j > 0; j--)\n                *p++ = '\\\\';\n              *p++ = '\"';\n            }\n          *p = '\\0';\n\n          new_argv[i] = quoted_string;\n        }\n      else\n        new_argv[i] = (char *) string;\n    }\n  new_argv[argc] = NULL;\n\n  return new_argv;\n}",
      "lines": 95,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "char",
        "**\nprepare_spawn (char **argv)",
        "*",
        "*\nprepare_spawn (char **argv)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/wait-process.c": {
    "cleanup_slaves": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "static void\ncleanup_slaves (void)\n{\n  for (;;)\n    {\n      /* Get the last registered slave.  */\n      size_t n = slaves_count;\n      if (n == 0)\n        break;\n      n--;\n      slaves_count = n;\n      /* Skip unused entries in the slaves array.  */\n      if (slaves[n].used)\n        {\n          pid_t slave = slaves[n].child;\n\n          /* Kill the slave.  */\n          kill (slave, TERMINATOR);\n        }\n    }\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "register_slave_subprocess": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "void\nregister_slave_subprocess (pid_t child)\n{\n  static bool cleanup_slaves_registered = false;\n  if (!cleanup_slaves_registered)\n    {\n      atexit (cleanup_slaves);\n      at_fatal_signal (cleanup_slaves);\n      cleanup_slaves_registered = true;\n    }\n\n  /* Try to store the new slave in an unused entry of the slaves array.  */\n  {\n    slaves_entry_t *s = slaves;\n    slaves_entry_t *s_end = s + slaves_count;\n\n    for (; s < s_end; s++)\n      if (!s->used)\n        {\n          /* The two uses of 'volatile' in the slaves_entry_t type above\n             (and ISO C 99 section 5.1.2.3.(5)) ensure that we mark the\n             entry as used only after the child pid has been written to the\n             memory location s->child.  */\n          s->child = child;\n          s->used = 1;\n          return;\n        }\n  }\n\n  if (slaves_count == slaves_allocated)\n    {\n      /* Extend the slaves array.  Note that we cannot use xrealloc(),\n         because then the cleanup_slaves() function could access an already\n         deallocated array.  */\n      slaves_entry_t *old_slaves = slaves;\n      size_t new_slaves_allocated = 2 * slaves_allocated;\n      slaves_entry_t *new_slaves =\n        (slaves_entry_t *)\n        malloc (new_slaves_allocated * sizeof (slaves_entry_t));\n      if (new_slaves == NULL)\n        {\n          /* xalloc_die() will call exit() which will invoke cleanup_slaves().\n             Additionally we need to kill child, because it's not yet among\n             the slaves list.  */\n          kill (child, TERMINATOR);\n          xalloc_die ();\n        }\n      memcpy (new_slaves, old_slaves,\n              slaves_allocated * sizeof (slaves_entry_t));\n      slaves = new_slaves;\n      slaves_allocated = new_slaves_allocated;\n      /* Now we can free the old slaves array.  */\n      if (old_slaves != static_slaves)\n        free (old_slaves);\n    }\n  /* The three uses of 'volatile' in the types above (and ISO C 99 section\n     5.1.2.3.(5)) ensure that we increment the slaves_count only after the\n     new slave and its 'used' bit have been written to the memory locations\n     that make up slaves[slaves_count].  */\n  slaves[slaves_count].child = child;\n  slaves[slaves_count].used = 1;\n  slaves_count++;\n}",
      "lines": 63,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "unregister_slave_subprocess": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "static void\nunregister_slave_subprocess (pid_t child)\n{\n  /* The easiest way to remove an entry from a list that can be used by\n     an asynchronous signal handler is just to mark it as unused.  For this,\n     we rely on sig_atomic_t.  */\n  slaves_entry_t *s = slaves;\n  slaves_entry_t *s_end = s + slaves_count;\n\n  for (; s < s_end; s++)\n    if (s->used && s->child == child)\n      s->used = 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wait_subprocess": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        360,
        1
      ],
      "content": "int\nwait_subprocess (pid_t child, const char *progname,\n                 bool ignore_sigpipe, bool null_stderr,\n                 bool slave_process, bool exit_on_error,\n                 int *termsigp)\n{\n#if HAVE_WAITID && defined WNOWAIT && 0\n  /* Commented out because waitid() without WEXITED and with WNOWAIT doesn't\n     work: On Solaris 7 and OSF/1 4.0, it returns -1 and sets errno = ECHILD,\n     and on HP-UX 10.20 it just hangs.  */\n  /* Use of waitid() with WNOWAIT avoids a race condition: If slave_process is\n     true, and this process sleeps a very long time between the return from\n     waitpid() and the execution of unregister_slave_subprocess(), and\n     meanwhile another process acquires the same PID as child, and then - still\n     before unregister_slave_subprocess() - this process gets a fatal signal,\n     it would kill the other totally unrelated process.  */\n  siginfo_t info;\n\n  if (termsigp != NULL)\n    *termsigp = 0;\n  for (;;)\n    {\n      if (waitid (P_PID, child, &info, WEXITED | (slave_process ? WNOWAIT : 0))\n          < 0)\n        {\n# ifdef EINTR\n          if (errno == EINTR)\n            continue;\n# endif\n          if (exit_on_error || !null_stderr)\n            error (exit_on_error ? EXIT_FAILURE : 0, errno,\n                   _(\"%s subprocess\"), progname);\n          return 127;\n        }\n\n      /* info.si_code is set to one of CLD_EXITED, CLD_KILLED, CLD_DUMPED,\n         CLD_TRAPPED, CLD_STOPPED, CLD_CONTINUED.  Loop until the program\n         terminates.  */\n      if (info.si_code == CLD_EXITED\n          || info.si_code == CLD_KILLED || info.si_code == CLD_DUMPED)\n        break;\n    }\n\n  /* The child process has exited or was signalled.  */\n\n  if (slave_process)\n    {\n      /* Unregister the child from the list of slave subprocesses, so that\n         later, when we exit, we don't kill a totally unrelated process which\n         may have acquired the same pid.  */\n      unregister_slave_subprocess (child);\n\n      /* Now remove the zombie from the process list.  */\n      for (;;)\n        {\n          if (waitid (P_PID, child, &info, WEXITED) < 0)\n            {\n# ifdef EINTR\n              if (errno == EINTR)\n                continue;\n# endif\n              if (exit_on_error || !null_stderr)\n                error (exit_on_error ? EXIT_FAILURE : 0, errno,\n                       _(\"%s subprocess\"), progname);\n              return 127;\n            }\n          break;\n        }\n    }\n\n  switch (info.si_code)\n    {\n    case CLD_KILLED:\n    case CLD_DUMPED:\n      if (termsigp != NULL)\n        *termsigp = info.si_status; /* TODO: or info.si_signo? */\n# ifdef SIGPIPE\n      if (info.si_status == SIGPIPE && ignore_sigpipe)\n        return 0;\n# endif\n      if (exit_on_error || (!null_stderr && termsigp == NULL))\n        error (exit_on_error ? EXIT_FAILURE : 0, 0,\n               _(\"%s subprocess got fatal signal %d\"),\n               progname, info.si_status);\n      return 127;\n    case CLD_EXITED:\n      if (info.si_status == 127)\n        {\n          if (exit_on_error || !null_stderr)\n            error (exit_on_error ? EXIT_FAILURE : 0, 0,\n                   _(\"%s subprocess failed\"), progname);\n          return 127;\n        }\n      return info.si_status;\n    default:\n      abort ();\n    }\n#else\n  /* waitpid() is just as portable as wait() nowadays.  */\n  int status;\n\n  if (termsigp != NULL)\n    *termsigp = 0;\n  status = 0;\n  for (;;)\n    {\n      int result = waitpid (child, &status, 0);\n\n      if (result != child)\n        {\n# ifdef EINTR\n          if (errno == EINTR)\n            continue;\n# endif\n# if 0 /* defined ECHILD */\n          if (errno == ECHILD)\n            {\n              /* Child process nonexistent?! Assume it terminated\n                 successfully.  */\n              status = 0;\n              break;\n            }\n# endif\n          if (exit_on_error || !null_stderr)\n            error (exit_on_error ? EXIT_FAILURE : 0, errno,\n                   _(\"%s subprocess\"), progname);\n          return 127;\n        }\n\n      /* One of WIFSIGNALED (status), WIFEXITED (status), WIFSTOPPED (status)\n         must always be true, since we did not specify WCONTINUED in the\n         waitpid() call.  Loop until the program terminates.  */\n      if (!WIFSTOPPED (status))\n        break;\n    }\n\n  /* The child process has exited or was signalled.  */\n\n  if (slave_process)\n    /* Unregister the child from the list of slave subprocesses, so that\n       later, when we exit, we don't kill a totally unrelated process which\n       may have acquired the same pid.  */\n    unregister_slave_subprocess (child);\n\n  if (WIFSIGNALED (status))\n    {\n      if (termsigp != NULL)\n        *termsigp = WTERMSIG (status);\n# ifdef SIGPIPE\n      if (WTERMSIG (status) == SIGPIPE && ignore_sigpipe)\n        return 0;\n# endif\n      if (exit_on_error || (!null_stderr && termsigp == NULL))\n        error (exit_on_error ? EXIT_FAILURE : 0, 0,\n               _(\"%s subprocess got fatal signal %d\"),\n               progname, (int) WTERMSIG (status));\n      return 127;\n    }\n  if (!WIFEXITED (status))\n    abort ();\n  if (WEXITSTATUS (status) == 127)\n    {\n      if (exit_on_error || !null_stderr)\n        error (exit_on_error ? EXIT_FAILURE : 0, 0,\n               _(\"%s subprocess failed\"), progname);\n      return 127;\n    }\n  return WEXITSTATUS (status);\n#endif\n}",
      "lines": 170,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/wait-process.h": {},
  "sharutils/sharutils-4.15.2/lib/waitpid.c": {
    "waitpid": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "pid_t\nwaitpid (pid_t pid, int *statusp, int options)\n{\n  return _cwait (statusp, pid, WAIT_CHILD);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "pid_t"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/wchar.in.h": {},
  "sharutils/sharutils-4.15.2/lib/wctype-h.c": {},
  "sharutils/sharutils-4.15.2/lib/wctype.in.h": {
    "rpl_towlower": {
      "start_point": [
        353,
        0
      ],
      "end_point": [
        357,
        1
      ],
      "content": "_GL_WCTYPE_INLINE wint_t\nrpl_towlower (wint_t wc)\n{\n  return (wint_t) (wchar_t) towlower (wc);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_WCTYPE_INLINE",
        "wint_t",
        "wint_t"
      ]
    },
    "rpl_towupper": {
      "start_point": [
        362,
        0
      ],
      "end_point": [
        366,
        1
      ],
      "content": "_GL_WCTYPE_INLINE wint_t\nrpl_towupper (wint_t wc)\n{\n  return (wint_t) (wchar_t) towupper (wc);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_WCTYPE_INLINE",
        "wint_t",
        "wint_t"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/xalloc-die.c": {
    "xalloc_die": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "void\nxalloc_die (void)\n{\n  error (exit_failure, 0, \"%s\", _(\"memory exhausted\"));\n\n  /* _Noreturn cannot be given to error, since it may return if\n     its first argument is 0.  To help compilers understand the\n     xalloc_die does not return, call abort.  Also, the abort is a\n     safety feature if exit_failure is 0 (which shouldn't happen).  */\n  abort ();\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/xalloc-oversized.h": {},
  "sharutils/sharutils-4.15.2/lib/xalloc.h": {
    "xnmalloc": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "XALLOC_INLINE void *\nxnmalloc (size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xmalloc (n * s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "XALLOC_INLINE",
        "void",
        "void",
        "*\nxnmalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xnrealloc": [
      {
        "start_point": [
          115,
          0
        ],
        "end_point": [
          121,
          1
        ],
        "content": "XALLOC_INLINE void *\nxnrealloc (void *p, size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xrealloc (p, n * s);\n}",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "XALLOC_INLINE",
          "void",
          "void",
          "*\nxnrealloc (void *p, size_t n, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          235,
          29
        ],
        "end_point": [
          239,
          1
        ],
        "content": "T *\nxnrealloc (T *p, size_t n, size_t s)\n{\n  return (T *) xnrealloc ((void *) p, n, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nxnrealloc (T *p, size_t n, size_t s)",
          "*"
        ]
      }
    ],
    "x2nrealloc": [
      {
        "start_point": [
          177,
          0
        ],
        "end_point": [
          209,
          1
        ],
        "content": "XALLOC_INLINE void *\nx2nrealloc (void *p, size_t *pn, size_t s)\n{\n  size_t n = *pn;\n\n  if (! p)\n    {\n      if (! n)\n        {\n          /* The approximate size to use for initial small allocation\n             requests, when the invoking code specifies an old size of\n             zero.  This is the largest \"small\" request for the GNU C\n             library malloc.  */\n          enum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };\n\n          n = DEFAULT_MXFAST / s;\n          n += !n;\n        }\n    }\n  else\n    {\n      /* Set N = floor (1.5 * N) + 1 so that progress is made even if N == 0.\n         Check for overflow, so that N * S stays in size_t range.\n         The check may be slightly conservative, but an exact check isn't\n         worth the trouble.  */\n      if ((size_t) -1 / 3 * 2 / s <= n)\n        xalloc_die ();\n      n += n / 2 + 1;\n    }\n\n  *pn = n;\n  return xrealloc (p, n * s);\n}",
        "lines": 33,
        "depth": 14,
        "decorators": [
          "XALLOC_INLINE",
          "void",
          "void",
          "*\nx2nrealloc (void *p, size_t *pn, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          247,
          29
        ],
        "end_point": [
          251,
          1
        ],
        "content": "T *\nx2nrealloc (T *p, size_t *pn, size_t s)\n{\n  return (T *) x2nrealloc ((void *) p, pn, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nx2nrealloc (T *p, size_t *pn, size_t s)",
          "*"
        ]
      }
    ],
    "xcharalloc": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "XALLOC_INLINE char *\nxcharalloc (size_t n)\n{\n  return XNMALLOC (n, char);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "XALLOC_INLINE",
        "char",
        "char",
        "*\nxcharalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        229,
        29
      ],
      "end_point": [
        233,
        1
      ],
      "content": "T *\nxrealloc (T *p, size_t s)\n{\n  return (T *) xrealloc ((void *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxrealloc (T *p, size_t s)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        241,
        29
      ],
      "end_point": [
        245,
        1
      ],
      "content": "T *\nx2realloc (T *p, size_t *pn)\n{\n  return (T *) x2realloc ((void *) p, pn);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nx2realloc (T *p, size_t *pn)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        253,
        29
      ],
      "end_point": [
        257,
        1
      ],
      "content": "T *\nxmemdup (T const *p, size_t s)\n{\n  return (T *) xmemdup ((void const *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxmemdup (T const *p, size_t s)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/xgetcwd.c": {
    "xgetcwd": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "char *\nxgetcwd (void)\n{\n  char *cwd = getcwd (NULL, 0);\n  if (! cwd && errno == ENOMEM)\n    xalloc_die ();\n  return cwd;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nxgetcwd (void)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/xgetcwd.h": {},
  "sharutils/sharutils-4.15.2/lib/xmalloc.c": {
    "xmalloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void *\nxmalloc (size_t n)\n{\n  void *p = malloc (n);\n  if (!p && n != 0)\n    xalloc_die ();\n  return p;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void",
        "*\nxmalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void *\nxrealloc (void *p, size_t n)\n{\n  if (!n && p)\n    {\n      /* The GNU and C99 realloc behaviors disagree here.  Act like\n         GNU, even if the underlying realloc is C99.  */\n      free (p);\n      return NULL;\n    }\n\n  p = realloc (p, n);\n  if (!p && n)\n    xalloc_die ();\n  return p;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxrealloc (void *p, size_t n)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void *\nx2realloc (void *p, size_t *pn)\n{\n  return x2nrealloc (p, pn, 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void",
        "*\nx2realloc (void *p, size_t *pn)",
        "*"
      ]
    },
    "xzalloc": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "void *\nxzalloc (size_t s)\n{\n  return memset (xmalloc (s), 0, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxzalloc (size_t s)",
        "*"
      ]
    },
    "xcalloc": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "void *\nxcalloc (size_t n, size_t s)\n{\n  void *p;\n  /* Test for overflow, since some calloc implementations don't have\n     proper overflow checks.  But omit overflow and size-zero tests if\n     HAVE_GNU_CALLOC, since GNU calloc catches overflow and never\n     returns NULL if successful.  */\n  if ((! HAVE_GNU_CALLOC && xalloc_oversized (n, s))\n      || (! (p = calloc (n, s)) && (HAVE_GNU_CALLOC || n != 0)))\n    xalloc_die ();\n  return p;\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "void",
        "*\nxcalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void *\nxmemdup (void const *p, size_t s)\n{\n  return memcpy (xmalloc (s), p, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxmemdup (void const *p, size_t s)",
        "*"
      ]
    },
    "xstrdup": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "char *\nxstrdup (char const *string)\n{\n  return xmemdup (string, strlen (string) + 1);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "char",
        "*\nxstrdup (char const *string)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/xstrndup.c": {
    "xstrndup": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "char *\nxstrndup (const char *string, size_t n)\n{\n  char *s = strndup (string, n);\n  if (! s)\n    xalloc_die ();\n  return s;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nxstrndup (const char *string, size_t n)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/xstrndup.h": {},
  "sharutils/sharutils-4.15.2/lib/xstrtoimax.c": {},
  "sharutils/sharutils-4.15.2/lib/xstrtol-error.c": {
    "xstrtol_error": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static void\nxstrtol_error (enum strtol_error err,\n               int opt_idx, char c, struct option const *long_options,\n               char const *arg,\n               int exit_status)\n{\n  char const *hyphens = \"--\";\n  char const *msgid;\n  char const *option;\n  char option_buffer[2];\n\n  switch (err)\n    {\n    default:\n      abort ();\n\n    case LONGINT_INVALID:\n      msgid = N_(\"invalid %s%s argument '%s'\");\n      break;\n\n    case LONGINT_INVALID_SUFFIX_CHAR:\n    case LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW:\n      msgid = N_(\"invalid suffix in %s%s argument '%s'\");\n      break;\n\n    case LONGINT_OVERFLOW:\n      msgid = N_(\"%s%s argument '%s' too large\");\n      break;\n    }\n\n  if (opt_idx < 0)\n    {\n      hyphens -= opt_idx;\n      option_buffer[0] = c;\n      option_buffer[1] = '\\0';\n      option = option_buffer;\n    }\n  else\n    option = long_options[opt_idx].name;\n\n  error (exit_status, 0, gettext (msgid), hyphens, option, arg);\n}",
      "lines": 42,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xstrtol_fatal": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "void\nxstrtol_fatal (enum strtol_error err,\n               int opt_idx, char c, struct option const *long_options,\n               char const *arg)\n{\n  xstrtol_error (err, opt_idx, c, long_options, arg, exit_failure);\n  abort ();\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/xstrtol.c": {
    "bkm_scale": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "static strtol_error\nbkm_scale (__strtol_t *x, int scale_factor)\n{\n  if (TYPE_SIGNED (__strtol_t) && *x < STRTOL_T_MINIMUM / scale_factor)\n    {\n      *x = STRTOL_T_MINIMUM;\n      return LONGINT_OVERFLOW;\n    }\n  if (STRTOL_T_MAXIMUM / scale_factor < *x)\n    {\n      *x = STRTOL_T_MAXIMUM;\n      return LONGINT_OVERFLOW;\n    }\n  *x *= scale_factor;\n  return LONGINT_OK;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "strtol_error"
      ]
    },
    "bkm_scale_by_power": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "static strtol_error\nbkm_scale_by_power (__strtol_t *x, int base, int power)\n{\n  strtol_error err = LONGINT_OK;\n  while (power--)\n    err |= bkm_scale (x, base);\n  return err;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "strtol_error"
      ]
    },
    "__xstrtol": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "strtol_error\n__xstrtol (const char *s, char **ptr, int strtol_base,\n           __strtol_t *val, const char *valid_suffixes)\n{\n  char *t_ptr;\n  char **p;\n  __strtol_t tmp;\n  strtol_error err = LONGINT_OK;\n\n  assure (0 <= strtol_base && strtol_base <= 36);\n\n  p = (ptr ? ptr : &t_ptr);\n\n  errno = 0;\n\n  if (! TYPE_SIGNED (__strtol_t))\n    {\n      const char *q = s;\n      unsigned char ch = *q;\n      while (isspace (ch))\n        ch = *++q;\n      if (ch == '-')\n        return LONGINT_INVALID;\n    }\n\n  tmp = __strtol (s, p, strtol_base);\n\n  if (*p == s)\n    {\n      /* If there is no number but there is a valid suffix, assume the\n         number is 1.  The string is invalid otherwise.  */\n      if (valid_suffixes && **p && strchr (valid_suffixes, **p))\n        tmp = 1;\n      else\n        return LONGINT_INVALID;\n    }\n  else if (errno != 0)\n    {\n      if (errno != ERANGE)\n        return LONGINT_INVALID;\n      err = LONGINT_OVERFLOW;\n    }\n\n  /* Let valid_suffixes == NULL mean \"allow any suffix\".  */\n  /* FIXME: update all callers except the ones that allow suffixes\n     after the number, changing last parameter NULL to \"\".  */\n  if (!valid_suffixes)\n    {\n      *val = tmp;\n      return err;\n    }\n\n  if (**p != '\\0')\n    {\n      int base = 1024;\n      int suffixes = 1;\n      strtol_error overflow;\n\n      if (!strchr (valid_suffixes, **p))\n        {\n          *val = tmp;\n          return err | LONGINT_INVALID_SUFFIX_CHAR;\n        }\n\n      if (strchr (valid_suffixes, '0'))\n        {\n          /* The \"valid suffix\" '0' is a special flag meaning that\n             an optional second suffix is allowed, which can change\n             the base.  A suffix \"B\" (e.g. \"100MB\") stands for a power\n             of 1000, whereas a suffix \"iB\" (e.g. \"100MiB\") stands for\n             a power of 1024.  If no suffix (e.g. \"100M\"), assume\n             power-of-1024.  */\n\n          switch (p[0][1])\n            {\n            case 'i':\n              if (p[0][2] == 'B')\n                suffixes += 2;\n              break;\n\n            case 'B':\n            case 'D': /* 'D' is obsolescent */\n              base = 1000;\n              suffixes++;\n              break;\n            }\n        }\n\n      switch (**p)\n        {\n        case 'b':\n          overflow = bkm_scale (&tmp, 512);\n          break;\n\n        case 'B':\n          overflow = bkm_scale (&tmp, 1024);\n          break;\n\n        case 'c':\n          overflow = LONGINT_OK;\n          break;\n\n        case 'E': /* exa or exbi */\n          overflow = bkm_scale_by_power (&tmp, base, 6);\n          break;\n\n        case 'G': /* giga or gibi */\n        case 'g': /* 'g' is undocumented; for compatibility only */\n          overflow = bkm_scale_by_power (&tmp, base, 3);\n          break;\n\n        case 'k': /* kilo */\n        case 'K': /* kibi */\n          overflow = bkm_scale_by_power (&tmp, base, 1);\n          break;\n\n        case 'M': /* mega or mebi */\n        case 'm': /* 'm' is undocumented; for compatibility only */\n          overflow = bkm_scale_by_power (&tmp, base, 2);\n          break;\n\n        case 'P': /* peta or pebi */\n          overflow = bkm_scale_by_power (&tmp, base, 5);\n          break;\n\n        case 'T': /* tera or tebi */\n        case 't': /* 't' is undocumented; for compatibility only */\n          overflow = bkm_scale_by_power (&tmp, base, 4);\n          break;\n\n        case 'w':\n          overflow = bkm_scale (&tmp, 2);\n          break;\n\n        case 'Y': /* yotta or 2**80 */\n          overflow = bkm_scale_by_power (&tmp, base, 8);\n          break;\n\n        case 'Z': /* zetta or 2**70 */\n          overflow = bkm_scale_by_power (&tmp, base, 7);\n          break;\n\n        default:\n          *val = tmp;\n          return err | LONGINT_INVALID_SUFFIX_CHAR;\n        }\n\n      err |= overflow;\n      *p += suffixes;\n      if (**p)\n        err |= LONGINT_INVALID_SUFFIX_CHAR;\n    }\n\n  *val = tmp;\n  return err;\n}",
      "lines": 156,
      "depth": 15,
      "decorators": [
        "strtol_error"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/lib/xstrtol.h": {},
  "sharutils/sharutils-4.15.2/lib/xstrtoul.c": {},
  "sharutils/sharutils-4.15.2/libopts/ag-char-map.h": {
    "is_ag_char_map_char": {
      "start_point": [
        477,
        0
      ],
      "end_point": [
        482,
        1
      ],
      "content": "static inline int\nis_ag_char_map_char(char ch, ag_char_map_mask_t mask)\n{\n    unsigned int ix = (unsigned char)ch;\n    return ((ix < 128) && ((ag_char_map_table[ix] & mask) != 0));\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "spn_ag_char_map_chars": {
      "start_point": [
        484,
        0
      ],
      "end_point": [
        492,
        1
      ],
      "content": "static inline char *\nspn_ag_char_map_chars(char const * p, unsigned int mask_ix)\n{\n    unsigned char const * v = ag_char_map_spanners[mask_ix];\n    if (v == NULL)\n        v = calc_ag_char_map_spanners(mask_ix);\n    while (v[(unsigned char)*p])  p++;\n    return (char *)(uintptr_t)p;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "char",
        "*\nspn_ag_char_map_chars(char const * p, unsigned int mask_ix)",
        "*"
      ]
    },
    "brk_ag_char_map_chars": {
      "start_point": [
        494,
        0
      ],
      "end_point": [
        502,
        1
      ],
      "content": "static inline char *\nbrk_ag_char_map_chars(char const * p, unsigned int mask_ix)\n{\n    unsigned char const * v = ag_char_map_spanners[mask_ix];\n    if (v == NULL)\n        v = calc_ag_char_map_spanners(mask_ix);\n    while ((*p != '\\0') && (! v[(unsigned char)*p]))  p++;\n    return (char *)(uintptr_t)p;\n}",
      "lines": 9,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "char",
        "*\nbrk_ag_char_map_chars(char const * p, unsigned int mask_ix)",
        "*"
      ]
    },
    "spn_ag_char_map_back": {
      "start_point": [
        504,
        0
      ],
      "end_point": [
        513,
        1
      ],
      "content": "static inline char *\nspn_ag_char_map_back(char const * s, char const * e, unsigned int mask_ix)\n{\n    unsigned char const * v = ag_char_map_spanners[mask_ix];\n    if (v == NULL)\n        v = calc_ag_char_map_spanners(mask_ix);\n    if (s >= e) e = s + strlen(s);\n    while ((e > s) && v[(unsigned char)e[-1]])  e--;\n    return (char *)(uintptr_t)e;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "char",
        "*\nspn_ag_char_map_back(char const * s, char const * e, unsigned int mask_ix)",
        "*"
      ]
    },
    "brk_ag_char_map_back": {
      "start_point": [
        515,
        0
      ],
      "end_point": [
        524,
        1
      ],
      "content": "static inline char *\nbrk_ag_char_map_back(char const * s, char const * e, unsigned int mask_ix)\n{\n    unsigned char const * v = ag_char_map_spanners[mask_ix];\n    if (v == NULL)\n        v = calc_ag_char_map_spanners(mask_ix);\n    if (s == e) e += strlen(e);\n    while ((e > s) && (! v[(unsigned char)e[-1]]))  e--;\n    return (char *)(uintptr_t)e;\n}",
      "lines": 10,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "char",
        "*\nbrk_ag_char_map_back(char const * s, char const * e, unsigned int mask_ix)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/alias.c": {
    "too_many_occurrences": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "LOCAL tSuccess\ntoo_many_occurrences(tOptions * opts, tOptDesc * od)\n{\n    if ((opts->fOptSet & OPTPROC_ERRSTOP) != 0) {\n        char const * eqv = (od->optEquivIndex != NO_EQUIVALENT) ? zequiv : zNil;\n\n        fprintf(stderr, ztoo_often_fmt, opts->pzProgName);\n\n        if (od->optMaxCt > 1)\n            fprintf(stderr, zat_most, od->optMaxCt, od->pz_Name, eqv);\n        else\n            fprintf(stderr, zonly_one, od->pz_Name, eqv);\n        (*opts->pUsageProc)(opts, EXIT_FAILURE);\n        /* NOTREACHED */\n    }\n\n    return FAILURE;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "LOCAL",
        "tSuccess",
        "tSuccess"
      ]
    },
    "optionAlias": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "int\noptionAlias(tOptions * opts, tOptDesc * old_od, unsigned int alias)\n{\n    tOptDesc * new_od;\n\n    if (opts <= OPTPROC_EMIT_LIMIT)\n        return 0;\n\n    new_od = opts->pOptDesc + alias;\n    if ((unsigned)opts->optCt <= alias) {\n        fputs(zbad_alias_id, stderr);\n        option_exits(EXIT_FAILURE);\n    }\n\n    /*\n     *  Copy over the option instance flags\n     */\n    new_od->fOptState &= OPTST_PERSISTENT_MASK;\n    new_od->fOptState |= (old_od->fOptState & ~OPTST_PERSISTENT_MASK);\n    new_od->optArg.argString = old_od->optArg.argString;\n\n    /*\n     *  Keep track of count only for DEFINED (command line) options.\n     *  IF we have too many, build up an error message and bail.\n     */\n    if (  (new_od->fOptState & OPTST_DEFINED)\n       && (++new_od->optOccCt > new_od->optMaxCt)  )\n        return too_many_occurrences(opts, new_od);\n\n    /*\n     *  Clear the state bits and counters\n     */\n    old_od->fOptState &= OPTST_PERSISTENT_MASK;\n    old_od->optOccCt   = 0;\n\n    /*\n     *  If there is a procedure to call, call it\n     */\n    if (new_od->pOptProc != NULL)\n        (*new_od->pOptProc)(opts, new_od);\n    return 0;\n}",
      "lines": 42,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/ao-strs.c": {},
  "sharutils/sharutils-4.15.2/libopts/ao-strs.h": {},
  "sharutils/sharutils-4.15.2/libopts/autoopts.c": {
    "ao_malloc": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "LOCAL void *\nao_malloc(size_t sz)\n{\n    void * res = malloc(sz);\n    if (res == NULL) {\n        fprintf(stderr, zalloc_fail, (int)sz);\n        option_exits(EXIT_FAILURE);\n    }\n    return res;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "LOCAL",
        "void",
        "void",
        "*\nao_malloc(size_t sz)",
        "*"
      ]
    },
    "ao_realloc": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "LOCAL void *\nao_realloc(void *p, size_t sz)\n{\n    void * res = (p == NULL) ? malloc(sz) : realloc(p, sz);\n    if (res == NULL) {\n        fprintf(stderr, zrealloc_fail, (int)sz, p);\n        option_exits(EXIT_FAILURE);\n    }\n    return res;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "LOCAL",
        "void",
        "void",
        "*\nao_realloc(void *p, size_t sz)",
        "*"
      ]
    },
    "ao_strdup": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "LOCAL char *\nao_strdup(char const *str)\n{\n    char * res = strdup(str);\n    if (res == NULL) {\n        fprintf(stderr, zalloc_fail, (int)strlen(str));\n        option_exits(EXIT_FAILURE);\n    }\n    return res;\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "LOCAL",
        "char",
        "char",
        "*\nao_strdup(char const *str)",
        "*"
      ]
    },
    "handle_opt": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        208,
        1
      ],
      "content": "LOCAL tSuccess\nhandle_opt(tOptions * opts, tOptState * o_st)\n{\n    /*\n     *  Save a copy of the option procedure pointer.\n     *  If this is an equivalence class option, we still want this proc.\n     */\n    tOptDesc *  od = o_st->pOD;\n    tOptProc *  opt_proc = od->pOptProc;\n    if (od->fOptState & OPTST_ALLOC_ARG)\n        AGFREE(od->optArg.argString);\n\n    od->optArg.argString = o_st->pzOptArg;\n\n    /*\n     *  IF we are presetting options, then we will ignore any un-presettable\n     *  options.  They are the ones either marked as such.\n     */\n    if (  ((opts->fOptSet & OPTPROC_PRESETTING) != 0)\n       && ((od->fOptState & OPTST_NO_INIT) != 0)\n       )\n        return PROBLEM;\n\n    /*\n     *  IF this is an equivalence class option,\n     *  THEN\n     *      Save the option value that got us to this option\n     *      entry.  (It may not be od->optChar[0], if this is an\n     *      equivalence entry.)\n     *      set the pointer to the equivalence class base\n     */\n    if (od->optEquivIndex != NO_EQUIVALENT) {\n        tOptDesc * eqv_od = opts->pOptDesc + od->optEquivIndex;\n\n        /*\n         * IF the current option state has not been defined (set on the\n         *    command line), THEN we will allow continued resetting of\n         *    the value.  Once \"defined\", then it must not change.\n         */\n        if ((od->fOptState & OPTST_DEFINED) != 0) {\n            /*\n             *  The equivalenced-to option has been found on the command\n             *  line before.  Make sure new occurrences are the same type.\n             *\n             *  IF this option has been previously equivalenced and\n             *     it was not the same equivalenced-to option,\n             *  THEN we have a usage problem.\n             */\n            if (eqv_od->optActualIndex != od->optIndex) {\n                fprintf(stderr, zmultiway_bug, eqv_od->pz_Name, od->pz_Name,\n                        (opts->pOptDesc + eqv_od->optActualIndex)->pz_Name);\n                return FAILURE;\n            }\n        } else {\n            /*\n             *  Set the equivalenced-to actual option index to no-equivalent\n             *  so that we set all the entries below.  This option may either\n             *  never have been selected before, or else it was selected by\n             *  some sort of \"presetting\" mechanism.\n             */\n            eqv_od->optActualIndex = NO_EQUIVALENT;\n        }\n\n        if (eqv_od->optActualIndex != od->optIndex) {\n            /*\n             *  First time through, copy over the state\n             *  and add in the equivalence flag\n             */\n            eqv_od->optActualValue = od->optValue;\n            eqv_od->optActualIndex = od->optIndex;\n            o_st->flags |= OPTST_EQUIVALENCE;\n        }\n\n        /*\n         *  Copy the most recent option argument.  set membership state\n         *  is kept in 'eqv_od->optCookie'.  Do not overwrite.\n         */\n        eqv_od->optArg.argString = od->optArg.argString;\n        od = eqv_od;\n\n    } else {\n        od->optActualValue = od->optValue;\n        od->optActualIndex = od->optIndex;\n    }\n\n    od->fOptState &= OPTST_PERSISTENT_MASK;\n    od->fOptState |= (o_st->flags & ~OPTST_PERSISTENT_MASK);\n\n    /*\n     *  Keep track of count only for DEFINED (command line) options.\n     *  IF we have too many, build up an error message and bail.\n     */\n    if (  (od->fOptState & OPTST_DEFINED)\n       && (++od->optOccCt > od->optMaxCt)  )\n        return too_many_occurrences(opts, od);\n    /*\n     *  If provided a procedure to call, call it\n     */\n    if (opt_proc != NULL)\n        (*opt_proc)(opts, od);\n\n    return SUCCESS;\n}",
      "lines": 103,
      "depth": 16,
      "decorators": [
        "LOCAL",
        "tSuccess",
        "tSuccess"
      ]
    },
    "next_opt": {
      "start_point": [
        219,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "LOCAL tSuccess\nnext_opt(tOptions * opts, tOptState * o_st)\n{\n    {\n        tSuccess res = find_opt(opts, o_st);\n        if (! SUCCESSFUL(res))\n            return res;\n    }\n\n    if (  ((o_st->flags & OPTST_DEFINED) != 0)\n       && ((o_st->pOD->fOptState & OPTST_NO_COMMAND) != 0)) {\n        fprintf(stderr, zNotCmdOpt, o_st->pOD->pz_Name);\n        return FAILURE;\n    }\n\n    return get_opt_arg(opts, o_st);\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "LOCAL",
        "tSuccess",
        "tSuccess"
      ]
    },
    "regular_opts": {
      "start_point": [
        246,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "LOCAL tSuccess\nregular_opts(tOptions * opts)\n{\n    /* assert:  opts->fOptSet & OPTPROC_IMMEDIATE == 0 */\n    for (;;) {\n        tOptState opt_st = OPTSTATE_INITIALIZER(DEFINED);\n\n        switch (next_opt(opts, &opt_st)) {\n        case FAILURE: goto   failed_option;\n        case PROBLEM: return SUCCESS; /* no more args */\n        case SUCCESS: break;\n        }\n\n        /*\n         *  IF this is an immediate action option,\n         *  THEN skip it (unless we are supposed to do it a second time).\n         */\n        if (! DO_NORMALLY(opt_st.flags)) {\n            if (! DO_SECOND_TIME(opt_st.flags))\n                continue;\n            opt_st.pOD->optOccCt--; /* don't count this repetition */\n        }\n\n        if (! SUCCESSFUL(handle_opt(opts, &opt_st)))\n            break;\n    } failed_option:;\n\n    if ((opts->fOptSet & OPTPROC_ERRSTOP) != 0)\n        (*opts->pUsageProc)(opts, EXIT_FAILURE);\n\n    return FAILURE;\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "LOCAL",
        "tSuccess",
        "tSuccess"
      ]
    },
    "optionProcess": {
      "start_point": [
        331,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "int\noptionProcess(tOptions * opts, int a_ct, char ** a_v)\n{\n    if (! SUCCESSFUL(validate_struct(opts, a_v[0])))\n        ao_bug(zbad_data_msg);\n    \n    /*\n     *  Establish the real program name, the program full path,\n     *  and do all the presetting the first time thru only.\n     */\n    if (! ao_initialize(opts, a_ct, a_v))\n        return 0;\n\n    /*\n     *  IF we are (re)starting,\n     *  THEN reset option location\n     */\n    if (opts->curOptIdx <= 0) {\n        opts->curOptIdx = 1;\n        opts->pzCurOpt  = NULL;\n    }\n\n    if (! SUCCESSFUL(regular_opts(opts)))\n        return (int)opts->origArgCt;\n\n    /*\n     *  IF    there were no errors\n     *    AND we have RC/INI files\n     *    AND there is a request to save the files\n     *  THEN do that now before testing for conflicts.\n     *       (conflicts are ignored in preset options)\n     */\n    switch (opts->specOptIdx.save_opts) {\n    case 0:\n    case NO_EQUIVALENT:\n        break;\n    default:\n    {\n        tOptDesc * od = opts->pOptDesc + opts->specOptIdx.save_opts;\n\n        if (SELECTED_OPT(od)) {\n            optionSaveFile(opts);\n            option_exits(EXIT_SUCCESS);\n        }\n    }\n    }\n\n    /*\n     *  IF we are checking for errors,\n     *  THEN look for too few occurrences of required options\n     */\n    if (((opts->fOptSet & OPTPROC_ERRSTOP) != 0)\n       && (! is_consistent(opts)))\n        (*opts->pUsageProc)(opts, EXIT_FAILURE);\n\n    return (int)opts->curOptIdx;\n}",
      "lines": 57,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/autoopts.h": {},
  "sharutils/sharutils-4.15.2/libopts/boolean.c": {
    "optionBooleanVal": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "void\noptionBooleanVal(tOptions * opts, tOptDesc * od)\n{\n    char * pz;\n    bool   res = true;\n\n    if (INQUERY_CALL(opts, od))\n        return;\n\n    if (od->optArg.argString == NULL) {\n        od->optArg.argBool = false;\n        return;\n    }\n\n    switch (*(od->optArg.argString)) {\n    case '0':\n    {\n        long  val = strtol(od->optArg.argString, &pz, 0);\n        if ((val != 0) || (*pz != NUL))\n            break;\n        /* FALLTHROUGH */\n    }\n    case 'N':\n    case 'n':\n    case 'F':\n    case 'f':\n    case NUL:\n        res = false;\n        break;\n    case '#':\n        if (od->optArg.argString[1] != 'f')\n            break;\n        res = false;\n    }\n\n    if (od->fOptState & OPTST_ALLOC_ARG) {\n        AGFREE(od->optArg.argString);\n        od->fOptState &= ~OPTST_ALLOC_ARG;\n    }\n    od->optArg.argBool = res;\n}",
      "lines": 41,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/check.c": {
    "has_conflict": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static bool\nhas_conflict(tOptions * pOpts, tOptDesc * od)\n{\n    if (od->pOptMust != NULL) {\n        int const * must = od->pOptMust;\n\n        while (*must != NO_EQUIVALENT) {\n            tOptDesc * p = pOpts->pOptDesc + *(must++);\n            if (UNUSED_OPT(p)) {\n                const tOptDesc * ood = pOpts->pOptDesc + must[-1];\n                fprintf(stderr, zneed_fmt, pOpts->pzProgName,\n                        od->pz_Name, ood->pz_Name);\n                return true;\n            }\n        }\n    }\n\n    if (od->pOptCant != NULL) {\n        int const * cant = od->pOptCant;\n\n        while (*cant != NO_EQUIVALENT) {\n            tOptDesc * p = pOpts->pOptDesc + *(cant++);\n            if (SELECTED_OPT(p)) {\n                const tOptDesc * ood = pOpts->pOptDesc + cant[-1];\n                fprintf(stderr, zconflict_fmt, pOpts->pzProgName,\n                        od->pz_Name, ood->pz_Name);\n                return true;\n            }\n        }\n    }\n\n    return false;\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "occurs_enough": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "static bool\noccurs_enough(tOptions * pOpts, tOptDesc * pOD)\n{\n    (void)pOpts;\n\n    /*\n     *  IF the occurrence counts have been satisfied,\n     *  THEN there is no problem.\n     */\n    if (pOD->optOccCt >= pOD->optMinCt)\n        return true;\n\n    /*\n     *  IF MUST_SET means SET and PRESET are okay,\n     *  so min occurrence count doesn't count\n     */\n    if (  (pOD->fOptState & OPTST_MUST_SET)\n       && (pOD->fOptState & (OPTST_PRESET | OPTST_SET)) )\n        return true;\n\n    if (pOD->optMinCt > 1)\n         fprintf(stderr, zneed_more, pOpts->pzProgName, pOD->pz_Name,\n                 pOD->optMinCt);\n    else fprintf(stderr, zneed_one,  pOpts->pzProgName, pOD->pz_Name);\n    return false;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "is_consistent": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "LOCAL bool\nis_consistent(tOptions * pOpts)\n{\n    tOptDesc * pOD   = pOpts->pOptDesc;\n    int        oCt   = pOpts->presetOptCt;\n\n    /*\n     *  FOR each of \"oCt\" options, ...\n     */\n    for (;;) {\n        /*\n         *  IF the current option was provided on the command line\n         *  THEN ensure that any \"MUST\" requirements are not\n         *       \"DEFAULT\" (unspecified) *AND* ensure that any\n         *       \"CANT\" options have not been SET or DEFINED.\n         */\n        if (SELECTED_OPT(pOD)) {\n            if (has_conflict(pOpts, pOD))\n                return false;\n        }\n\n        /*\n         *  IF       this option is not equivalenced to another,\n         *        OR it is equivalenced to itself (is the equiv. root)\n         *  THEN we need to make sure it occurs often enough.\n         */\n        if (  (pOD->optEquivIndex == NO_EQUIVALENT)\n           || (pOD->optEquivIndex == pOD->optIndex) )\n\n            if (! occurs_enough(pOpts, pOD))\n                return false;\n\n        if (--oCt <= 0)\n            break;\n        pOD++;\n    }\n\n    /*\n     *  IF we are stopping on errors, check to see if any remaining\n     *  arguments are required to be there or prohibited from being there.\n     */\n    if ((pOpts->fOptSet & OPTPROC_ERRSTOP) != 0) {\n\n        /*\n         *  Check for prohibition\n         */\n        if ((pOpts->fOptSet & OPTPROC_NO_ARGS) != 0) {\n            if (pOpts->origArgCt > pOpts->curOptIdx) {\n                fprintf(stderr, zNoArgs, pOpts->pzProgName);\n                return false;\n            }\n        }\n\n        /*\n         *  ELSE not prohibited, check for being required\n         */\n        else if ((pOpts->fOptSet & OPTPROC_ARGS_REQ) != 0) {\n            if (pOpts->origArgCt <= pOpts->curOptIdx) {\n                fprintf(stderr, zargs_must, pOpts->pzProgName);\n                return false;\n            }\n        }\n    }\n\n    return true;\n}",
      "lines": 66,
      "depth": 14,
      "decorators": [
        "LOCAL",
        "bool",
        "bool"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/configfile.c": {
    "skip_unkn": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "inline static char const *\nskip_unkn(char const * txt)\n{\n    txt = BRK_END_XML_TOKEN_CHARS(txt);\n    return (*txt == NUL) ? NULL : txt;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "inline",
        "inline",
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\nskip_unkn(char const * txt)",
        "*"
      ]
    },
    "configFileLoad": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "const tOptionValue *\nconfigFileLoad(char const * fname)\n{\n    tmap_info_t    cfgfile;\n    tOptionValue * res = NULL;\n    tOptionLoadMode save_mode = option_load_mode;\n\n    char * txt = text_mmap(fname, PROT_READ, MAP_PRIVATE, &cfgfile);\n\n    if (TEXT_MMAP_FAILED_ADDR(txt))\n        return NULL; /* errno is set */\n\n    option_load_mode = OPTION_LOAD_COOKED;\n    res = optionLoadNested(txt, fname, strlen(fname));\n\n    if (res == NULL) {\n        int err = errno;\n        text_munmap(&cfgfile);\n        errno = err;\n    } else\n        text_munmap(&cfgfile);\n\n    option_load_mode = save_mode;\n    return res;\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "const",
        "const",
        "tOptionValue",
        "*\nconfigFileLoad(char const * fname)",
        "*"
      ]
    },
    "optionFindValue": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        215,
        1
      ],
      "content": "const tOptionValue *\noptionFindValue(const tOptDesc * odesc, char const * name, char const * val)\n{\n    const tOptionValue * res = NULL;\n\n    if (  (odesc == NULL)\n       || (OPTST_GET_ARGTYPE(odesc->fOptState) != OPARG_TYPE_HIERARCHY))  {\n        errno = EINVAL;\n    }\n\n    else if (odesc->optCookie == NULL) {\n        errno = ENOENT;\n    }\n\n    else do {\n        tArgList * argl  = odesc->optCookie;\n        int        argct = argl->useCt;\n        void **    poptv = (void **)(argl->apzArgs);\n\n        if (argct == 0) {\n            errno = ENOENT;\n            break;\n        }\n\n        if (name == NULL) {\n            res = (tOptionValue *)*poptv;\n            break;\n        }\n\n        while (--argct >= 0) {\n            const tOptionValue * ov = *(poptv++);\n            const tOptionValue * rv = optionGetValue(ov, name);\n\n            if (rv == NULL)\n                continue;\n\n            if (val == NULL) {\n                res = ov;\n                break;\n            }\n        }\n        if (res == NULL)\n            errno = ENOENT;\n    } while (false);\n\n    return res;\n}",
      "lines": 47,
      "depth": 14,
      "decorators": [
        "const",
        "const",
        "tOptionValue",
        "*\noptionFindValue(const tOptDesc * odesc, char const * name, char const * val)",
        "*"
      ]
    },
    "optionFindNextValue": {
      "start_point": [
        246,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "tOptionValue const *\noptionFindNextValue(const tOptDesc * odesc, const tOptionValue * pPrevVal,\n                    char const * pzName, char const * pzVal)\n{\n    bool old_found = false;\n    tOptionValue * res = NULL;\n\n    (void)pzName;\n    (void)pzVal;\n\n    if (  (odesc == NULL)\n       || (OPTST_GET_ARGTYPE(odesc->fOptState) != OPARG_TYPE_HIERARCHY))  {\n        errno = EINVAL;\n    }\n\n    else if (odesc->optCookie == NULL) {\n        errno = ENOENT;\n    }\n\n    else do {\n        tArgList * argl = odesc->optCookie;\n        int        ct   = argl->useCt;\n        void **   poptv = (void **)argl->apzArgs;\n\n        while (--ct >= 0) {\n            tOptionValue * pOV = *(poptv++);\n            if (old_found) {\n                res = pOV;\n                break;\n            }\n            if (pOV == pPrevVal)\n                old_found = true;\n        }\n        if (res == NULL)\n            errno = ENOENT;\n    } while (false);\n\n    return res;\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "tOptionValue",
        "const",
        "const",
        "*\noptionFindNextValue(const tOptDesc * odesc, const tOptionValue * pPrevVal,\n                    char const * pzName, char const * pzVal)",
        "*"
      ]
    },
    "optionGetValue": {
      "start_point": [
        314,
        0
      ],
      "end_point": [
        344,
        1
      ],
      "content": "tOptionValue const *\noptionGetValue(tOptionValue const * oov, char const * vname)\n{\n    tArgList *     arg_list;\n    tOptionValue * res = NULL;\n\n    if ((oov == NULL) || (oov->valType != OPARG_TYPE_HIERARCHY)) {\n        errno = EINVAL;\n        return res;\n    }\n    arg_list = oov->v.nestVal;\n\n    if (arg_list->useCt > 0) {\n        int     ct     = arg_list->useCt;\n        void ** ovlist = (void **)(arg_list->apzArgs);\n\n        if (vname == NULL) {\n            res = (tOptionValue *)*ovlist;\n\n        } else do {\n            tOptionValue * opt_val = *(ovlist++);\n            if (strcmp(opt_val->pzName, vname) == 0) {\n                res = opt_val;\n                break;\n            }\n        } while (--ct > 0);\n    }\n    if (res == NULL)\n        errno = ENOENT;\n    return res;\n}",
      "lines": 31,
      "depth": 14,
      "decorators": [
        "tOptionValue",
        "const",
        "const",
        "*\noptionGetValue(tOptionValue const * oov, char const * vname)",
        "*"
      ]
    },
    "optionNextValue": {
      "start_point": [
        373,
        0
      ],
      "end_point": [
        406,
        1
      ],
      "content": "tOptionValue const *\noptionNextValue(tOptionValue const * ov_list,tOptionValue const * oov )\n{\n    tArgList *     arg_list;\n    tOptionValue * res = NULL;\n    int            err = EINVAL;\n\n    if ((ov_list == NULL) || (ov_list->valType != OPARG_TYPE_HIERARCHY)) {\n        errno = EINVAL;\n        return NULL;\n    }\n    arg_list = ov_list->v.nestVal;\n    {\n        int     ct    = arg_list->useCt;\n        void ** o_list = (void **)(arg_list->apzArgs);\n\n        while (ct-- > 0) {\n            tOptionValue * nov = *(o_list++);\n            if (nov == oov) {\n                if (ct == 0) {\n                    err = ENOENT;\n\n                } else {\n                    err = 0;\n                    res = (tOptionValue *)*o_list;\n                }\n                break;\n            }\n        }\n    }\n    if (err != 0)\n        errno = err;\n    return res;\n}",
      "lines": 34,
      "depth": 15,
      "decorators": [
        "tOptionValue",
        "const",
        "const",
        "*\noptionNextValue(tOptionValue const * ov_list,tOptionValue const * oov )",
        "*"
      ]
    },
    "file_preset": {
      "start_point": [
        411,
        0
      ],
      "end_point": [
        492,
        1
      ],
      "content": "static void\nfile_preset(tOptions * opts, char const * fname, int dir)\n{\n    tmap_info_t       cfgfile;\n    tOptState         optst = OPTSTATE_INITIALIZER(PRESET);\n    opt_state_mask_t  st_flags = optst.flags;\n    opt_state_mask_t  fl_save  = opts->fOptSet;\n    char *            ftext =\n        text_mmap(fname, PROT_READ|PROT_WRITE, MAP_PRIVATE, &cfgfile);\n\n    if (TEXT_MMAP_FAILED_ADDR(ftext))\n        return;\n\n    /*\n     * While processing config files, we ignore errors.\n     */\n    opts->fOptSet &= ~OPTPROC_ERRSTOP;\n\n    if (dir == DIRECTION_CALLED) {\n        st_flags = OPTST_DEFINED;\n        dir   = DIRECTION_PROCESS;\n    }\n\n    /*\n     *  IF this is called via \"optionProcess\", then we are presetting.\n     *  This is the default and the PRESETTING bit will be set.\n     *  If this is called via \"optionFileLoad\", then the bit is not set\n     *  and we consider stuff set herein to be \"set\" by the client program.\n     */\n    if ((opts->fOptSet & OPTPROC_PRESETTING) == 0)\n        st_flags = OPTST_SET;\n\n    do  {\n        optst.flags = st_flags;\n        ftext = SPN_WHITESPACE_CHARS(ftext);\n\n        if (IS_VAR_FIRST_CHAR(*ftext)) {\n            ftext = handle_cfg(opts, &optst, ftext, dir);\n\n        } else switch (*ftext) {\n        case '<':\n            if (IS_VAR_FIRST_CHAR(ftext[1]))\n                ftext = handle_struct(opts, &optst, ftext, dir);\n\n            else switch (ftext[1]) {\n            case '?':\n                ftext = handle_directive(opts, ftext);\n                break;\n\n            case '!':\n                ftext = handle_comment(ftext);\n                break;\n\n            case '/':\n                ftext = strchr(ftext + 2, '>');\n                if (ftext++ != NULL)\n                    break;\n\n            default:\n                ftext = NULL;\n            }\n            if (ftext == NULL)\n                goto all_done;\n            break;\n\n        case '[':\n            ftext = handle_section(opts, ftext);\n            break;\n\n        case '#':\n            ftext = strchr(ftext + 1, NL);\n            break;\n\n        default:\n            goto all_done; /* invalid format */\n        }\n    } while (ftext != NULL);\n\n all_done:\n    text_munmap(&cfgfile);\n    opts->fOptSet = fl_save;\n}",
      "lines": 82,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "handle_comment": {
      "start_point": [
        499,
        0
      ],
      "end_point": [
        506,
        1
      ],
      "content": "static char *\nhandle_comment(char * txt)\n{\n    char * pz = strstr(txt, \"-->\");\n    if (pz != NULL)\n        pz += 3;\n    return pz;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nhandle_comment(char * txt)",
        "*"
      ]
    },
    "handle_cfg": {
      "start_point": [
        514,
        0
      ],
      "end_point": [
        587,
        1
      ],
      "content": "static char *\nhandle_cfg(tOptions * opts, tOptState * ost, char * txt, int dir)\n{\n    char * pzName = txt++;\n    char * pzEnd  = strchr(txt, NL);\n\n    if (pzEnd == NULL)\n        return txt + strlen(txt);\n\n    txt = SPN_VALUE_NAME_CHARS(txt);\n    txt = SPN_WHITESPACE_CHARS(txt);\n    if (txt > pzEnd) {\n    name_only:\n        *pzEnd++ = NUL;\n        load_opt_line(opts, ost, pzName, dir, OPTION_LOAD_UNCOOKED);\n        return pzEnd;\n    }\n\n    /*\n     *  Either the first character after the name is a ':' or '=',\n     *  or else we must have skipped over white space.  Anything else\n     *  is an invalid format and we give up parsing the text.\n     */\n    if ((*txt == '=') || (*txt == ':')) {\n        txt = SPN_WHITESPACE_CHARS(txt+1);\n        if (txt > pzEnd)\n            goto name_only;\n    } else if (! IS_WHITESPACE_CHAR(txt[-1]))\n        return NULL;\n\n    /*\n     *  IF the value is continued, remove the backslash escape and push \"pzEnd\"\n     *  on to a newline *not* preceded by a backslash.\n     */\n    if (pzEnd[-1] == '\\\\') {\n        char * pcD = pzEnd-1;\n        char * pcS = pzEnd;\n\n        for (;;) {\n            char ch = *(pcS++);\n            switch (ch) {\n            case NUL:\n                pcS = NULL;\n                /* FALLTHROUGH */\n\n            case NL:\n                *pcD = NUL;\n                pzEnd = pcS;\n                goto copy_done;\n\n            case '\\\\':\n                if (*pcS == NL)\n                    ch = *(pcS++);\n                /* FALLTHROUGH */\n            default:\n                *(pcD++) = ch;\n            }\n        } copy_done:;\n\n    } else {\n        /*\n         *  The newline was not preceded by a backslash.  NUL it out\n         */\n        *(pzEnd++) = NUL;\n    }\n\n    /*\n     *  \"pzName\" points to what looks like text for one option/configurable.\n     *  It is NUL terminated.  Process it.\n     */\n    load_opt_line(opts, ost, pzName, dir, OPTION_LOAD_UNCOOKED);\n\n    return pzEnd;\n}",
      "lines": 74,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nhandle_cfg(tOptions * opts, tOptState * ost, char * txt, int dir)",
        "*"
      ]
    },
    "handle_directive": {
      "start_point": [
        598,
        0
      ],
      "end_point": [
        641,
        1
      ],
      "content": "static char *\nhandle_directive(tOptions * opts, char * txt)\n{\n#   define DIRECTIVE_TABLE                      \\\n    _dt_(zCfgProg,     program_directive)       \\\n    _dt_(zCfgAO_Flags, aoflags_directive)\n\n    typedef char * (directive_func_t)(tOptions *, char *);\n#   define _dt_(_s, _fn) _fn,\n    static directive_func_t * dir_disp[] = {\n        DIRECTIVE_TABLE\n    };\n#   undef  _dt_\n\n#   define _dt_(_s, _fn) 1 +\n    static int  const   dir_ct  = DIRECTIVE_TABLE 0;\n    static char const * dir_names[DIRECTIVE_TABLE 0];\n#   undef _dt_\n\n    int    ix;\n\n    if (dir_names[0] == NULL) {\n        ix = 0;\n#   define _dt_(_s, _fn) dir_names[ix++] = _s;\n        DIRECTIVE_TABLE;\n#   undef _dt_\n    }\n\n    for (ix = 0; ix < dir_ct; ix++) {\n        size_t len = strlen(dir_names[ix]);\n        if (  (strncmp(txt + 2, dir_names[ix], len) == 0)\n           && (! IS_VALUE_NAME_CHAR(txt[len+2])) )\n            return dir_disp[ix](opts, txt + len + 2);\n    }\n\n    /*\n     *  We don't know what this is.  Skip it.\n     */\n    txt = strchr(txt+2, '>');\n    if (txt != NULL)\n        txt++;\n    return txt;\n#   undef DIRECTIVE_TABLE\n}",
      "lines": 44,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nhandle_directive(tOptions * opts, char * txt)",
        "*"
      ]
    },
    "aoflags_directive": {
      "start_point": [
        650,
        0
      ],
      "end_point": [
        671,
        1
      ],
      "content": "static char *\naoflags_directive(tOptions * opts, char * txt)\n{\n    char * pz;\n\n    pz = SPN_WHITESPACE_CHARS(txt+1);\n    txt = strchr(pz, '>');\n    if (txt != NULL) {\n\n        size_t len  = (unsigned)(txt - pz);\n        char * ftxt = AGALOC(len + 1, \"aoflags\");\n\n        memcpy(ftxt, pz, len);\n        ftxt[len] = NUL;\n        set_usage_flags(opts, ftxt);\n        AGFREE(ftxt);\n\n        txt++;\n    }\n\n    return txt;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\naoflags_directive(tOptions * opts, char * txt)",
        "*"
      ]
    },
    "program_directive": {
      "start_point": [
        680,
        0
      ],
      "end_point": [
        715,
        1
      ],
      "content": "static char *\nprogram_directive(tOptions * opts, char * txt)\n{\n    static char const ttlfmt[] = \"<?\";\n    size_t ttl_len  = sizeof(ttlfmt) + strlen(zCfgProg);\n    char * ttl      = AGALOC(ttl_len, \"prog title\");\n    size_t name_len = strlen(opts->pzProgName);\n\n    memcpy(ttl, ttlfmt, sizeof(ttlfmt) - 1);\n    memcpy(ttl + sizeof(ttlfmt) - 1, zCfgProg, ttl_len - (sizeof(ttlfmt) - 1));\n\n    do  {\n        txt = SPN_WHITESPACE_CHARS(txt+1);\n\n        if (  (strneqvcmp(txt, opts->pzProgName, (int)name_len) == 0)\n           && (IS_END_XML_TOKEN_CHAR(txt[name_len])) ) {\n            txt += name_len;\n            break;\n        }\n\n        txt = strstr(txt, ttl);\n    } while (txt != NULL);\n\n    AGFREE(ttl);\n    if (txt != NULL)\n        for (;;) {\n            if (*txt == NUL) {\n                txt = NULL;\n                break;\n            }\n            if (*(txt++) == '>')\n                break;\n        }\n\n    return txt;\n}",
      "lines": 36,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nprogram_directive(tOptions * opts, char * txt)",
        "*"
      ]
    },
    "handle_section": {
      "start_point": [
        726,
        0
      ],
      "end_point": [
        746,
        1
      ],
      "content": "static char *\nhandle_section(tOptions * opts, char * txt)\n{\n    size_t len = strlen(opts->pzPROGNAME);\n    if (   (strncmp(txt+1, opts->pzPROGNAME, len) == 0)\n        && (txt[len+1] == ']'))\n        return strchr(txt + len + 2, NL);\n\n    if (len > 16)\n        return NULL;\n\n    {\n        char z[24];\n        sprintf(z, \"[%s]\", opts->pzPROGNAME);\n        txt = strstr(txt, z);\n    }\n\n    if (txt != NULL)\n        txt = strchr(txt, NL);\n    return txt;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nhandle_section(tOptions * opts, char * txt)",
        "*"
      ]
    },
    "parse_xml_encoding": {
      "start_point": [
        751,
        0
      ],
      "end_point": [
        831,
        1
      ],
      "content": "static int\nparse_xml_encoding(char ** ppz)\n{\n#   define XMLTABLE             \\\n        _xmlNm_(amp,   '&')     \\\n        _xmlNm_(lt,    '<')     \\\n        _xmlNm_(gt,    '>')     \\\n        _xmlNm_(ff,    '\\f')    \\\n        _xmlNm_(ht,    '\\t')    \\\n        _xmlNm_(cr,    '\\r')    \\\n        _xmlNm_(vt,    '\\v')    \\\n        _xmlNm_(bel,   '\\a')    \\\n        _xmlNm_(nl,    NL)      \\\n        _xmlNm_(space, ' ')     \\\n        _xmlNm_(quot,  '\"')     \\\n        _xmlNm_(apos,  '\\'')\n\n    static struct {\n        char const * const  nm_str;\n        unsigned short      nm_len;\n        short               nm_val;\n    } const xml_names[] = {\n#   define _xmlNm_(_n, _v) { #_n \";\", sizeof(#_n), _v },\n        XMLTABLE\n#   undef  _xmlNm_\n#   undef XMLTABLE\n    };\n\n    static int const nm_ct = sizeof(xml_names) / sizeof(xml_names[0]);\n    int    base = 10;\n\n    char * pz = *ppz;\n\n    if (*pz == '#') {\n        pz++;\n        goto parse_number;\n    }\n\n    if (IS_DEC_DIGIT_CHAR(*pz)) {\n        unsigned long v;\n\n    parse_number:\n        switch (*pz) {\n        case 'x': case 'X':\n            /*\n             * Some forms specify hex with:  &#xNN;\n             */\n            base = 16;\n            pz++;\n            break;\n\n        case '0':\n            /*\n             *  &#0022; is hex and &#22; is decimal.  Cool.\n             *  Ya gotta love it.\n             */\n            if (pz[1] == '0')\n                base = 16;\n            break;\n        }\n\n        v = strtoul(pz, &pz, base);\n        if ((*pz != ';') || (v > 0x7F))\n            return NUL;\n        *ppz = pz + 1;\n        return (int)v;\n    }\n\n    {\n        int ix = 0;\n        do  {\n            if (strncmp(pz, xml_names[ix].nm_str, xml_names[ix].nm_len)\n                == 0) {\n                *ppz = pz + xml_names[ix].nm_len;\n                return xml_names[ix].nm_val;\n            }\n        } while (++ix < nm_ct);\n    }\n\n    return NUL;\n}",
      "lines": 81,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "trim_xml_text": {
      "start_point": [
        838,
        0
      ],
      "end_point": [
        868,
        1
      ],
      "content": "static char *\ntrim_xml_text(char * intxt, char const * pznm, tOptionLoadMode mode)\n{\n    static char const fmt[] = \"</%s>\";\n    size_t len = strlen(pznm) + sizeof(fmt) - 2 /* for %s */;\n    char * etext;\n\n    {\n        char z[64], *pz = z;\n        if (len >= sizeof(z))\n            pz = AGALOC(len, \"scan name\");\n\n        len = (size_t)sprintf(pz, fmt, pznm);\n        *intxt = ' ';\n        etext = strstr(intxt, pz);\n        if (pz != z) AGFREE(pz);\n    }\n\n    if (etext == NULL)\n        return etext;\n\n    {\n        char * result = etext + len;\n\n        if (mode != OPTION_LOAD_UNCOOKED)\n            etext = SPN_WHITESPACE_BACK(intxt, etext);\n\n        *etext = NUL;\n        return result;\n    }\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ntrim_xml_text(char * intxt, char const * pznm, tOptionLoadMode mode)",
        "*"
      ]
    },
    "cook_xml_text": {
      "start_point": [
        872,
        0
      ],
      "end_point": [
        909,
        1
      ],
      "content": "static void\ncook_xml_text(char * pzData)\n{\n    char * pzs = pzData;\n    char * pzd = pzData;\n    char   bf[4];\n    bf[2] = NUL;\n\n    for (;;) {\n        int ch = ((int)*(pzs++)) & 0xFF;\n        switch (ch) {\n        case NUL:\n            *pzd = NUL;\n            return;\n\n        case '&':\n            ch = parse_xml_encoding(&pzs);\n            *(pzd++) = (char)ch;\n            if (ch == NUL)\n                return;\n            break;\n\n        case '%':\n            bf[0] = *(pzs++);\n            bf[1] = *(pzs++);\n            if ((bf[0] == NUL) || (bf[1] == NUL)) {\n                *pzd = NUL;\n                return;\n            }\n\n            ch = (int)strtoul(bf, NULL, 16);\n            /* FALLTHROUGH */\n\n        default:\n            *(pzd++) = (char)ch;\n        }\n    }\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "handle_struct": {
      "start_point": [
        916,
        0
      ],
      "end_point": [
        992,
        1
      ],
      "content": "static char *\nhandle_struct(tOptions * opts, tOptState * ost, char * txt, int dir)\n{\n    tOptionLoadMode mode = option_load_mode;\n    tOptionValue    valu;\n\n    char * pzName = ++txt;\n    char * pzData;\n    char * pcNulPoint;\n\n    txt = SPN_VALUE_NAME_CHARS(txt);\n    pcNulPoint = txt;\n    valu.valType = OPARG_TYPE_STRING;\n\n    switch (*txt) {\n    case ' ':\n    case '\\t':\n        txt = VOIDP(parse_attrs(\n            opts, SPN_WHITESPACE_CHARS(txt), &mode, &valu));\n        if (txt == NULL)\n            return txt;\n        if (*txt == '>')\n            break;\n        if (*txt != '/')\n            return NULL;\n        /* FALLTHROUGH */\n\n    case '/':\n        if (txt[1] != '>')\n            return NULL;\n        *txt = NUL;\n        txt += 2;\n        load_opt_line(opts, ost, pzName, dir, mode);\n        return txt;\n\n    case '>':\n        break;\n\n    default:\n        txt = strchr(txt, '>');\n        if (txt != NULL)\n            txt++;\n        return txt;\n    }\n\n    /*\n     *  If we are here, we have a value.  \"txt\" points to a closing angle\n     *  bracket.  Separate the name from the value for a moment.\n     */\n    *pcNulPoint = NUL;\n    pzData = ++txt;\n    txt = trim_xml_text(txt, pzName, mode);\n    if (txt == NULL)\n        return txt;\n\n    /*\n     *  Rejoin the name and value for parsing by \"load_opt_line()\".\n     *  Erase any attributes parsed by \"parse_attrs()\".\n     */\n    memset(pcNulPoint, ' ', (size_t)(pzData - pcNulPoint));\n\n    /*\n     *  If we are getting a \"string\" value that is to be cooked,\n     *  then process the XML-ish &xx; XML-ish and %XX hex characters.\n     */\n    if (  (valu.valType == OPARG_TYPE_STRING)\n       && (mode == OPTION_LOAD_COOKED))\n        cook_xml_text(pzData);\n\n    /*\n     *  \"pzName\" points to what looks like text for one option/configurable.\n     *  It is NUL terminated.  Process it.\n     */\n    load_opt_line(opts, ost, pzName, dir, mode);\n\n    return txt;\n}",
      "lines": 77,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nhandle_struct(tOptions * opts, tOptState * ost, char * txt, int dir)",
        "*"
      ]
    },
    "intern_file_load": {
      "start_point": [
        999,
        0
      ],
      "end_point": [
        1092,
        1
      ],
      "content": "LOCAL void\nintern_file_load(tOptions * opts)\n{\n    uint32_t  svfl;\n    int       idx;\n    int       inc;\n    char      f_name[ AG_PATH_MAX+1 ];\n\n    if (opts->papzHomeList == NULL)\n        return;\n\n    svfl = opts->fOptSet;\n    inc  = DIRECTION_PRESET;\n\n    /*\n     *  Never stop on errors in config files.\n     */\n    opts->fOptSet &= ~OPTPROC_ERRSTOP;\n\n    /*\n     *  Find the last RC entry (highest priority entry)\n     */\n    for (idx = 0; opts->papzHomeList[ idx+1 ] != NULL; ++idx)  ;\n\n    /*\n     *  For every path in the home list, ...  *TWICE* We start at the last\n     *  (highest priority) entry, work our way down to the lowest priority,\n     *  handling the immediate options.\n     *  Then we go back up, doing the normal options.\n     */\n    for (;;) {\n        struct stat sb;\n        cch_t *  path;\n\n        /*\n         *  IF we've reached the bottom end, change direction\n         */\n        if (idx < 0) {\n            inc = DIRECTION_PROCESS;\n            idx = 0;\n        }\n\n        path = opts->papzHomeList[ idx ];\n\n        /*\n         *  IF we've reached the top end, bail out\n         */\n        if (path == NULL)\n            break;\n\n        idx += inc;\n\n        if (! optionMakePath(f_name, (int)sizeof(f_name),\n                             path, opts->pzProgPath))\n            continue;\n\n        /*\n         *  IF the file name we constructed is a directory,\n         *  THEN append the Resource Configuration file name\n         *  ELSE we must have the complete file name\n         */\n        if (stat(f_name, &sb) != 0)\n            continue; /* bogus name - skip the home list entry */\n\n        if (S_ISDIR(sb.st_mode)) {\n            size_t len = strlen(f_name);\n            size_t nln = strlen(opts->pzRcName) + 1;\n            char * pz  = f_name + len;\n\n            if (len + 1 + nln >= sizeof(f_name))\n                continue;\n\n            if (pz[-1] != DIRCH)\n                *(pz++) = DIRCH;\n            memcpy(pz, opts->pzRcName, nln);\n        }\n\n        file_preset(opts, f_name, inc);\n\n        /*\n         *  IF we are now to skip config files AND we are presetting,\n         *  THEN change direction.  We must go the other way.\n         */\n        {\n            tOptDesc * od = opts->pOptDesc + opts->specOptIdx.save_opts + 1;\n            if (DISABLED_OPT(od) && PRESETTING(inc)) {\n                idx -= inc;  /* go back and reprocess current file */\n                inc =  DIRECTION_PROCESS;\n            }\n        }\n    } /* twice for every path in the home list, ... */\n\n    opts->fOptSet = svfl;\n}",
      "lines": 94,
      "depth": 13,
      "decorators": [
        "LOCAL",
        "void",
        "void"
      ]
    },
    "optionFileLoad": {
      "start_point": [
        1127,
        0
      ],
      "end_point": [
        1145,
        1
      ],
      "content": "int\noptionFileLoad(tOptions * opts, char const * prog)\n{\n    if (! SUCCESSFUL(validate_struct(opts, prog)))\n        return -1;\n\n    /*\n     * The pointer to the program name is \"const\".  However, the\n     * structure is in writable memory, so we coerce the address\n     * of this pointer to point to writable memory.\n     */\n    {\n        char const ** pp = VOIDP(&(opts->pzProgName));\n        *pp = prog;\n    }\n\n    intern_file_load(opts);\n    return 0;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "optionLoadOpt": {
      "start_point": [
        1158,
        0
      ],
      "end_point": [
        1193,
        1
      ],
      "content": "void\noptionLoadOpt(tOptions * opts, tOptDesc * odesc)\n{\n    struct stat sb;\n\n    if (opts <= OPTPROC_EMIT_LIMIT)\n        return;\n\n    /*\n     *  IF the option is not being disabled, THEN load the file.  There must\n     *  be a file.  (If it is being disabled, then the disablement processing\n     *  already took place.  It must be done to suppress preloading of ini/rc\n     *  files.)\n     */\n    if (  DISABLED_OPT(odesc)\n       || ((odesc->fOptState & OPTST_RESET) != 0))\n        return;\n\n    if (stat(odesc->optArg.argString, &sb) != 0) {\n        if ((opts->fOptSet & OPTPROC_ERRSTOP) == 0)\n            return;\n\n        fserr_exit(opts->pzProgName, \"stat\", odesc->optArg.argString);\n        /* NOT REACHED */\n    }\n\n    if (! S_ISREG(sb.st_mode)) {\n        if ((opts->fOptSet & OPTPROC_ERRSTOP) == 0)\n            return;\n        errno = EINVAL;\n        fserr_exit(opts->pzProgName, \"stat\", odesc->optArg.argString);\n        /* NOT REACHED */\n    }\n\n    file_preset(opts, odesc->optArg.argString, DIRECTION_CALLED);\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "parse_attrs": {
      "start_point": [
        1200,
        0
      ],
      "end_point": [
        1270,
        1
      ],
      "content": "LOCAL char const *\nparse_attrs(tOptions * opts, char const * txt, tOptionLoadMode * pMode,\n            tOptionValue * pType)\n{\n    size_t len = 0;\n\n    for (;;) {\n        len = (size_t)(SPN_LOWER_CASE_CHARS(txt) - txt);\n\n        /*\n         * The enumeration used in this switch is derived from this switch\n         * statement itself.  The \"find_option_xat_attribute_cmd\" function\n         * will return XAT_CMD_MEMBERS for the \"txt\" string value\n         * \"members\", etc.\n         */\n        switch (find_option_xat_attribute_cmd(txt, len)) {\n        case XAT_CMD_TYPE:\n            txt = parse_value(txt+len, pType);\n            break;\n\n        case XAT_CMD_WORDS:\n            txt = parse_keyword(opts, txt+len, pType);\n            break;\n\n        case XAT_CMD_MEMBERS:\n            txt = parse_set_mem(opts, txt+len, pType);\n            break;\n\n        case XAT_CMD_COOKED:\n            txt += len;\n            if (! IS_END_XML_TOKEN_CHAR(*txt))\n                goto invalid_kwd;\n\n            *pMode = OPTION_LOAD_COOKED;\n            break;\n\n        case XAT_CMD_UNCOOKED:\n            txt += len;\n            if (! IS_END_XML_TOKEN_CHAR(*txt))\n                goto invalid_kwd;\n\n            *pMode = OPTION_LOAD_UNCOOKED;\n            break;\n\n        case XAT_CMD_KEEP:\n            txt += len;\n            if (! IS_END_XML_TOKEN_CHAR(*txt))\n                goto invalid_kwd;\n\n            *pMode = OPTION_LOAD_KEEP;\n            break;\n\n        default:\n        case XAT_INVALID_CMD:\n        invalid_kwd:\n            pType->valType = OPARG_TYPE_NONE;\n            return skip_unkn(txt);\n        }\n\n        if (txt == NULL)\n            return NULL;\n        txt = SPN_WHITESPACE_CHARS(txt);\n        switch (*txt) {\n            case '/': pType->valType = OPARG_TYPE_NONE;\n                      /* FALLTHROUGH */\n            case '>': return txt;\n        }\n        if (! IS_LOWER_CASE_CHAR(*txt))\n            return NULL;\n    }\n}",
      "lines": 71,
      "depth": 14,
      "decorators": [
        "LOCAL",
        "char const",
        "char",
        "const",
        "*\nparse_attrs(tOptions * opts, char const * txt, tOptionLoadMode * pMode,\n            tOptionValue * pType)",
        "*"
      ]
    },
    "parse_keyword": {
      "start_point": [
        1281,
        0
      ],
      "end_point": [
        1288,
        1
      ],
      "content": "static char const *\nparse_keyword(tOptions * opts, char const * txt, tOptionValue * typ)\n{\n    (void)opts;\n    (void)typ;\n\n    return skip_unkn(txt);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\nparse_keyword(tOptions * opts, char const * txt, tOptionValue * typ)",
        "*"
      ]
    },
    "parse_set_mem": {
      "start_point": [
        1300,
        0
      ],
      "end_point": [
        1307,
        1
      ],
      "content": "static char const *\nparse_set_mem(tOptions * opts, char const * txt, tOptionValue * typ)\n{\n    (void)opts;\n    (void)typ;\n\n    return skip_unkn(txt);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\nparse_set_mem(tOptions * opts, char const * txt, tOptionValue * typ)",
        "*"
      ]
    },
    "parse_value": {
      "start_point": [
        1317,
        0
      ],
      "end_point": [
        1371,
        1
      ],
      "content": "static char const *\nparse_value(char const * txt, tOptionValue * typ)\n{\n    size_t len = 0;\n\n    if (*(txt++) != '=')\n        goto woops;\n\n    len = (size_t)(SPN_OPTION_NAME_CHARS(txt) - txt);\n\n    if ((len == 0) || (! IS_END_XML_TOKEN_CHAR(txt[len]))) {\n    woops:\n        typ->valType = OPARG_TYPE_NONE;\n        return skip_unkn(txt + len);\n    }\n\n    /*\n     * The enumeration used in this switch is derived from this switch\n     * statement itself.  The \"find_option_value_type_cmd\" function\n     * will return VTP_CMD_INTEGER for the \"txt\" string value\n     * \"integer\", etc.\n     */\n    switch (find_option_value_type_cmd(txt, len)) {\n    default:\n    case VTP_INVALID_CMD: goto woops;\n\n    case VTP_CMD_STRING:\n        typ->valType = OPARG_TYPE_STRING;\n        break;\n\n    case VTP_CMD_INTEGER:\n        typ->valType = OPARG_TYPE_NUMERIC;\n        break;\n\n    case VTP_CMD_BOOL:\n    case VTP_CMD_BOOLEAN:\n        typ->valType = OPARG_TYPE_BOOLEAN;\n        break;\n\n    case VTP_CMD_KEYWORD:\n        typ->valType = OPARG_TYPE_ENUMERATION;\n        break;\n\n    case VTP_CMD_SET:\n    case VTP_CMD_SET_MEMBERSHIP:\n        typ->valType = OPARG_TYPE_MEMBERSHIP;\n        break;\n\n    case VTP_CMD_NESTED:\n    case VTP_CMD_HIERARCHY:\n        typ->valType = OPARG_TYPE_HIERARCHY;\n    }\n\n    return txt + len;\n}",
      "lines": 55,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\nparse_value(char const * txt, tOptionValue * typ)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/cook.c": {
    "ao_string_cook_escape_char": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "unsigned int\nao_string_cook_escape_char(char const * pzIn, char * pRes, uint_t nl)\n{\n    unsigned int res = 1;\n\n    switch (*pRes = *pzIn++) {\n    case NUL:         /* NUL - end of input string */\n        return 0;\n    case '\\r':\n        if (*pzIn != NL)\n            return 1;\n        res++;\n        /* FALLTHROUGH */\n    case NL:        /* NL  - emit newline        */\n        *pRes = (char)nl;\n        return res;\n\n    case 'a': *pRes = '\\a'; break;\n    case 'b': *pRes = '\\b'; break;\n    case 'f': *pRes = '\\f'; break;\n    case 'n': *pRes = NL;   break;\n    case 'r': *pRes = '\\r'; break;\n    case 't': *pRes = '\\t'; break;\n    case 'v': *pRes = '\\v'; break;\n\n    case 'x':\n    case 'X':         /* HEX Escape       */\n        if (IS_HEX_DIGIT_CHAR(*pzIn))  {\n            char z[4];\n            unsigned int ct = 0;\n\n            do  {\n                z[ct] = pzIn[ct];\n                if (++ct >= 2)\n                    break;\n            } while (IS_HEX_DIGIT_CHAR(pzIn[ct]));\n            z[ct] = NUL;\n            *pRes = (char)strtoul(z, NULL, 16);\n            return ct + 1;\n        }\n        break;\n\n    case '0': case '1': case '2': case '3':\n    case '4': case '5': case '6': case '7':\n    {\n        /*\n         *  IF the character copied was an octal digit,\n         *  THEN set the output character to an octal value.\n         *  The 3 octal digit result might exceed 0xFF, so check it.\n         */\n        char z[4];\n        unsigned long val;\n        unsigned int  ct = 0;\n\n        z[ct++] = *--pzIn;\n        while (IS_OCT_DIGIT_CHAR(pzIn[ct])) {\n            z[ct] = pzIn[ct];\n            if (++ct >= 3)\n                break;\n        }\n\n        z[ct] = NUL;\n        val = strtoul(z, NULL, 8);\n        if (val > 0xFF)\n            val = 0xFF;\n        *pRes = (char)val;\n        return ct;\n    }\n\n    default: /* quoted character is result character */;\n    }\n\n    return res;\n}",
      "lines": 74,
      "depth": 14,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "contiguous_quote": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "static bool\ncontiguous_quote(char ** pps, char * pq, int * lnct_p)\n{\n    char * ps = *pps + 1;\n\n    for (;;) {\n        while (IS_WHITESPACE_CHAR(*ps))\n            if (*(ps++) == NL)\n                (*lnct_p)++;\n\n        /*\n         *  IF the next character is a quote character,\n         *  THEN we will concatenate the strings.\n         */\n        switch (*ps) {\n        case '\"':\n        case '\\'':\n            *pq  = *(ps++);  /* assign new quote character and return */\n            *pps = ps;\n            return true;\n\n        case '/':\n            /*\n             *  Allow for a comment embedded in the concatenated string.\n             */\n            switch (ps[1]) {\n            default:\n                *pps = NULL;\n                return false;\n\n            case '/':\n                /*\n                 *  Skip to end of line\n                 */\n                ps = strchr(ps, NL);\n                if (ps == NULL) {\n                    *pps = NULL;\n                    return false;\n                }\n                break;\n\n            case '*':\n            {\n                char * p = strstr( ps+2, \"*/\" );\n                /*\n                 *  Skip to terminating star slash\n                 */\n                if (p == NULL) {\n                    *pps = NULL;\n                    return false;\n                }\n\n                while (ps < p) {\n                    if (*(ps++) == NL)\n                        (*lnct_p)++;\n                }\n\n                ps = p + 2;\n            }\n            }\n            continue;\n\n        default:\n            /*\n             *  The next non-whitespace character is not a quote.\n             *  The series of quoted strings has come to an end.\n             */\n            *pps = ps;\n            return false;\n        }\n    }\n}",
      "lines": 72,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "ao_string_cook": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        315,
        1
      ],
      "content": "char *\nao_string_cook(char * pzScan, int * lnct_p)\n{\n    int   l = 0;\n    char  q = *pzScan;\n\n    /*\n     *  It is a quoted string.  Process the escape sequence characters\n     *  (in the set \"abfnrtv\") and make sure we find a closing quote.\n     */\n    char * pzD = pzScan++;\n    char * pzS = pzScan;\n\n    if (lnct_p == NULL)\n        lnct_p = &l;\n\n    for (;;) {\n        /*\n         *  IF the next character is the quote character, THEN we may end the\n         *  string.  We end it unless the next non-blank character *after* the\n         *  string happens to also be a quote.  If it is, then we will change\n         *  our quote character to the new quote character and continue\n         *  condensing text.\n         */\n        while (*pzS == q) {\n            *pzD = NUL; /* This is probably the end of the line */\n            if (! contiguous_quote(&pzS, &q, lnct_p))\n                return pzS;\n        }\n\n        /*\n         *  We are inside a quoted string.  Copy text.\n         */\n        switch (*(pzD++) = *(pzS++)) {\n        case NUL:\n            return NULL;\n\n        case NL:\n            (*lnct_p)++;\n            break;\n\n        case '\\\\':\n            /*\n             *  IF we are escaping a new line,\n             *  THEN drop both the escape and the newline from\n             *       the result string.\n             */\n            if (*pzS == NL) {\n                pzS++;\n                pzD--;\n                (*lnct_p)++;\n            }\n\n            /*\n             *  ELSE IF the quote character is '\"' or '`',\n             *  THEN we do the full escape character processing\n             */\n            else if (q != '\\'') {\n                unsigned int ct;\n                ct = ao_string_cook_escape_char(pzS, pzD-1, (uint_t)NL);\n                if (ct == 0)\n                    return NULL;\n\n                pzS += ct;\n            }     /* if (q != '\\'')                  */\n\n            /*\n             *  OTHERWISE, we only process \"\\\\\", \"\\'\" and \"\\#\" sequences.\n             *  The latter only to easily hide preprocessing directives.\n             */\n            else switch (*pzS) {\n            case '\\\\':\n            case '\\'':\n            case '#':\n                pzD[-1] = *pzS++;\n            }\n        }     /* switch (*(pzD++) = *(pzS++))    */\n    }         /* for (;;)                        */\n}",
      "lines": 79,
      "depth": 17,
      "decorators": [
        "char",
        "*\nao_string_cook(char * pzScan, int * lnct_p)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/enum.c": {
    "enum_err": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "static void\nenum_err(tOptions * pOpts, tOptDesc * pOD,\n         char const * const * paz_names, int name_ct)\n{\n    size_t max_len = 0;\n    size_t ttl_len = 0;\n    int    ct_down = name_ct;\n    int    hidden  = 0;\n\n    /*\n     *  A real \"pOpts\" pointer means someone messed up.  Give a real error.\n     */\n    if (pOpts > OPTPROC_EMIT_LIMIT)\n        fprintf(option_usage_fp, pz_enum_err_fmt, pOpts->pzProgName,\n                pOD->optArg.argString, pOD->pz_Name);\n\n    fprintf(option_usage_fp, zValidKeys, pOD->pz_Name);\n\n    /*\n     *  If the first name starts with this funny character, then we have\n     *  a first value with an unspellable name.  You cannot specify it.\n     *  So, we don't list it either.\n     */\n    if (**paz_names == 0x7F) {\n        paz_names++;\n        hidden  = 1;\n        ct_down = --name_ct;\n    }\n\n    /*\n     *  Figure out the maximum length of any name, plus the total length\n     *  of all the names.\n     */\n    {\n        char const * const * paz = paz_names;\n\n        do  {\n            size_t len = strlen(*(paz++)) + 1;\n            if (len > max_len)\n                max_len = len;\n            ttl_len += len;\n        } while (--ct_down > 0);\n\n        ct_down = name_ct;\n    }\n\n    /*\n     *  IF any one entry is about 1/2 line or longer, print one per line\n     */\n    if (max_len > 35) {\n        do  {\n            fprintf(option_usage_fp, ENUM_ERR_LINE, *(paz_names++));\n        } while (--ct_down > 0);\n    }\n\n    /*\n     *  ELSE IF they all fit on one line, then do so.\n     */\n    else if (ttl_len < 76) {\n        fputc(' ', option_usage_fp);\n        do  {\n            fputc(' ', option_usage_fp);\n            fputs(*(paz_names++), option_usage_fp);\n        } while (--ct_down > 0);\n        fputc(NL, option_usage_fp);\n    }\n\n    /*\n     *  Otherwise, columnize the output\n     */\n    else {\n        unsigned int ent_no = 0;\n        char  zFmt[16];  /* format for all-but-last entries on a line */\n\n        sprintf(zFmt, ENUM_ERR_WIDTH, (int)max_len);\n        max_len = 78 / max_len; /* max_len is now max entries on a line */\n        fputs(TWO_SPACES_STR, option_usage_fp);\n\n        /*\n         *  Loop through all but the last entry\n         */\n        ct_down = name_ct;\n        while (--ct_down > 0) {\n            if (++ent_no == max_len) {\n                /*\n                 *  Last entry on a line.  Start next line, too.\n                 */\n                fprintf(option_usage_fp, NLSTR_SPACE_FMT, *(paz_names++));\n                ent_no = 0;\n            }\n\n            else\n                fprintf(option_usage_fp, zFmt, *(paz_names++) );\n        }\n        fprintf(option_usage_fp, NLSTR_FMT, *paz_names);\n    }\n\n    if (pOpts > OPTPROC_EMIT_LIMIT) {\n        fprintf(option_usage_fp, zIntRange, hidden, name_ct - 1 + hidden);\n\n        (*(pOpts->pUsageProc))(pOpts, EXIT_FAILURE);\n        /* NOTREACHED */\n    }\n\n    if (OPTST_GET_ARGTYPE(pOD->fOptState) == OPARG_TYPE_MEMBERSHIP) {\n        fprintf(option_usage_fp, zLowerBits, name_ct);\n        fputs(zSetMemberSettings, option_usage_fp);\n    } else {\n        fprintf(option_usage_fp, zIntRange, hidden, name_ct - 1 + hidden);\n    }\n}",
      "lines": 111,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "find_name": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "static uintptr_t\nfind_name(char const * name, tOptions * pOpts, tOptDesc * pOD,\n          char const * const *  paz_names, unsigned int name_ct)\n{\n    /*\n     *  Return the matching index as a pointer sized integer.\n     *  The result gets stashed in a char * pointer.\n     */\n    uintptr_t   res = name_ct;\n    size_t      len = strlen((char *)name);\n    uintptr_t   idx;\n\n    if (IS_DEC_DIGIT_CHAR(*name)) {\n        char * pz = VOIDP(name);\n        unsigned long val = strtoul(pz, &pz, 0);\n        if ((*pz == NUL) && (val < name_ct))\n            return (uintptr_t)val;\n        pz_enum_err_fmt = znum_too_large;\n        option_usage_fp = stderr;\n        enum_err(pOpts, pOD, paz_names, (int)name_ct);\n        return name_ct;\n    }\n\n    if (IS_INVERSION_CHAR(*name) && (name[2] == NUL)) {\n        if (  ((name[0] == '~') && (name[1] == '0'))\n           || ((name[0] == '-') && (name[1] == '1')))\n        return (uintptr_t)(name_ct - 1);\n        goto oops;\n    }\n\n    /*\n     *  Look for an exact match, but remember any partial matches.\n     *  Multiple partial matches means we have an ambiguous match.\n     */\n    for (idx = 0; idx < name_ct; idx++) {\n        if (strncmp((char *)paz_names[idx], (char *)name, len) == 0) {\n            if (paz_names[idx][len] == NUL)\n                return idx;  /* full match */\n\n            if (res == name_ct)\n                res = idx; /* save partial match */\n            else\n                res = (uintptr_t)~0;  /* may yet find full match */\n        }\n    }\n\n    if (res < name_ct)\n        return res; /* partial match */\n\n oops:\n\n    pz_enum_err_fmt = (res == name_ct) ? zNoKey : zambiguous_key;\n    option_usage_fp = stderr;\n    enum_err(pOpts, pOD, paz_names, (int)name_ct);\n    return name_ct;\n}",
      "lines": 56,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "uintptr_t"
      ]
    },
    "optionKeywordName": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        260,
        1
      ],
      "content": "char const *\noptionKeywordName(tOptDesc * pOD, unsigned int enum_val)\n{\n    tOptDesc od = { 0 };\n    od.optArg.argEnum = enum_val;\n\n    (*(pOD->pOptProc))(OPTPROC_RETURN_VALNAME, &od );\n    return od.optArg.argString;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "char",
        "const",
        "const",
        "*\noptionKeywordName(tOptDesc * pOD, unsigned int enum_val)",
        "*"
      ]
    },
    "optionEnumerationVal": {
      "start_point": [
        281,
        0
      ],
      "end_point": [
        340,
        1
      ],
      "content": "uintptr_t\noptionEnumerationVal(tOptions * pOpts, tOptDesc * pOD,\n                     char const * const * paz_names, unsigned int name_ct)\n{\n    uintptr_t res = 0UL;\n\n    /*\n     *  IF the program option descriptor pointer is invalid,\n     *  then it is some sort of special request.\n     */\n    switch ((uintptr_t)pOpts) {\n    case (uintptr_t)OPTPROC_EMIT_USAGE:\n        /*\n         *  print the list of enumeration names.\n         */\n        enum_err(pOpts, pOD, paz_names, (int)name_ct);\n        break;\n\n    case (uintptr_t)OPTPROC_EMIT_SHELL:\n    {\n        unsigned int ix = (unsigned int)pOD->optArg.argEnum;\n        /*\n         *  print the name string.\n         */\n        if (ix >= name_ct)\n            printf(INVALID_FMT, ix);\n        else\n            fputs(paz_names[ ix ], stdout);\n\n        break;\n    }\n\n    case (uintptr_t)OPTPROC_RETURN_VALNAME:\n    {\n        unsigned int ix = (unsigned int)pOD->optArg.argEnum;\n        /*\n         *  Replace the enumeration value with the name string.\n         */\n        if (ix >= name_ct)\n            return (uintptr_t)INVALID_STR;\n\n        pOD->optArg.argString = paz_names[ix];\n        break;\n    }\n\n    default:\n        if ((pOD->fOptState & OPTST_RESET) != 0)\n            break;\n\n        res = find_name(pOD->optArg.argString, pOpts, pOD, paz_names, name_ct);\n\n        if (pOD->fOptState & OPTST_ALLOC_ARG) {\n            AGFREE(pOD->optArg.argString);\n            pOD->fOptState &= ~OPTST_ALLOC_ARG;\n            pOD->optArg.argString = NULL;\n        }\n    }\n\n    return res;\n}",
      "lines": 60,
      "depth": 13,
      "decorators": [
        "uintptr_t"
      ]
    },
    "set_memb_shell": {
      "start_point": [
        342,
        0
      ],
      "end_point": [
        364,
        1
      ],
      "content": "static void\nset_memb_shell(tOptions * pOpts, tOptDesc * pOD, char const * const * paz_names,\n               unsigned int name_ct)\n{\n    /*\n     *  print the name string.\n     */\n    unsigned int ix =  0;\n    uintptr_t  bits = (uintptr_t)pOD->optCookie;\n    size_t     len  = 0;\n\n    (void)pOpts;\n    bits &= ((uintptr_t)1 << (uintptr_t)name_ct) - (uintptr_t)1;\n\n    while (bits != 0) {\n        if (bits & 1) {\n            if (len++ > 0) fputs(OR_STR, stdout);\n            fputs(paz_names[ix], stdout);\n        }\n        if (++ix >= name_ct) break;\n        bits >>= 1;\n    }\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_memb_names": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        412,
        1
      ],
      "content": "static void\nset_memb_names(tOptions * opts, tOptDesc * od, char const * const * nm_list,\n               unsigned int nm_ct)\n{\n    char *     pz;\n    uintptr_t  mask = (1UL << (uintptr_t)nm_ct) - 1UL;\n    uintptr_t  bits = (uintptr_t)od->optCookie & mask;\n    unsigned int ix = 0;\n    size_t     len  = 1;\n\n    /*\n     *  Replace the enumeration value with the name string.\n     *  First, determine the needed length, then allocate and fill in.\n     */\n    while (bits != 0) {\n        if (bits & 1)\n            len += strlen(nm_list[ix]) + PLUS_STR_LEN + 1;\n        if (++ix >= nm_ct) break;\n        bits >>= 1;\n    }\n\n    od->optArg.argString = pz = AGALOC(len, \"enum\");\n    bits = (uintptr_t)od->optCookie & mask;\n    if (bits == 0) {\n        *pz = NUL;\n        return;\n    }\n\n    for (ix = 0; ; ix++) {\n        size_t nln;\n        int    doit = bits & 1;\n\n        bits >>= 1;\n        if (doit == 0)\n            continue;\n\n        nln = strlen(nm_list[ix]);\n        memcpy(pz, nm_list[ix], nln);\n        pz += nln;\n        if (bits == 0)\n            break;\n        memcpy(pz, PLUS_STR, PLUS_STR_LEN);\n        pz += PLUS_STR_LEN;\n    }\n    *pz = NUL;\n    (void)opts;\n}",
      "lines": 47,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_membership_start": {
      "start_point": [
        428,
        0
      ],
      "end_point": [
        473,
        1
      ],
      "content": "static uintptr_t\ncheck_membership_start(tOptDesc * od, char const ** argp, bool * invert)\n{\n    uintptr_t    res = (uintptr_t)od->optCookie;\n    char const * arg = SPN_WHITESPACE_CHARS(od->optArg.argString);\n    if ((arg == NULL) || (*arg == NUL))\n        goto member_start_fail;\n\n    *invert = false;\n\n    switch (*arg) {\n    case '=':\n        res = 0UL;\n        arg = SPN_WHITESPACE_CHARS(arg + 1);\n        switch (*arg) {\n        case '=': case ',':\n            goto member_start_fail;\n        case '^':\n            goto inversion;\n        default:\n            break;\n        }\n        break;\n\n    case '^':\n    inversion:\n        *invert = true;\n        arg = SPN_WHITESPACE_CHARS(arg + 1);\n        if (*arg != ',')\n            break;\n        /* FALLTHROUGH */\n\n    case ',':\n        goto member_start_fail;\n\n    default:\n        break;\n    }\n\n    *argp = arg;\n    return res;\n\nmember_start_fail:\n    *argp = NULL;\n    return 0UL;\n}",
      "lines": 46,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "uintptr_t"
      ]
    },
    "find_member_bit": {
      "start_point": [
        487,
        0
      ],
      "end_point": [
        504,
        1
      ],
      "content": "static uintptr_t\nfind_member_bit(tOptions * opts, tOptDesc * od, char const * pz, int len,\n                char const * const * nm_list, unsigned int nm_ct)\n{\n    char nm_buf[ AO_NAME_SIZE ];\n\n    memcpy(nm_buf, pz, len);\n    nm_buf[len] = NUL;\n\n    {\n        unsigned int shift_ct = (unsigned int)\n            find_name(nm_buf, opts, od, nm_list, nm_ct);\n        if (shift_ct >= nm_ct)\n            return 0UL;\n\n        return 1UL << shift_ct;\n    }\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "uintptr_t"
      ]
    },
    "optionMemberList": {
      "start_point": [
        517,
        0
      ],
      "end_point": [
        526,
        1
      ],
      "content": "char *\noptionMemberList(tOptDesc * od)\n{\n    uintptr_t    sv = od->optArg.argIntptr;\n    char * res;\n    (*(od->pOptProc))(OPTPROC_RETURN_VALNAME, od);\n    res = VOIDP(od->optArg.argString);\n    od->optArg.argIntptr = sv;\n    return res;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "char",
        "*\noptionMemberList(tOptDesc * od)",
        "*"
      ]
    },
    "optionSetMembers": {
      "start_point": [
        544,
        0
      ],
      "end_point": [
        642,
        1
      ],
      "content": "void\noptionSetMembers(tOptions * opts, tOptDesc * od,\n                 char const * const * nm_list, unsigned int nm_ct)\n{\n    /*\n     *  IF the program option descriptor pointer is invalid,\n     *  then it is some sort of special request.\n     */\n    switch ((uintptr_t)opts) {\n    case (uintptr_t)OPTPROC_EMIT_USAGE:\n        enum_err(OPTPROC_EMIT_USAGE, od, nm_list, nm_ct);\n        return;\n\n    case (uintptr_t)OPTPROC_EMIT_SHELL:\n        set_memb_shell(opts, od, nm_list, nm_ct);\n        return;\n\n    case (uintptr_t)OPTPROC_RETURN_VALNAME:\n        set_memb_names(opts, od, nm_list, nm_ct);\n        return;\n\n    default:\n        break;\n    }\n\n    if ((od->fOptState & OPTST_RESET) != 0)\n        return;\n\n    {\n        char const * arg;\n        bool         invert;\n        uintptr_t    res = check_membership_start(od, &arg, &invert);\n        if (arg == NULL)\n            goto fail_return;\n\n        while (*arg != NUL) {\n            bool inv_val = false;\n            int  len;\n\n            switch (*arg) {\n            case ',':\n                arg = SPN_WHITESPACE_CHARS(arg+1);\n                if ((*arg == ',') || (*arg == '|'))\n                    goto fail_return;\n                continue;\n\n            case '-':\n            case '!':\n                inv_val = true;\n                /* FALLTHROUGH */\n\n            case '+':\n            case '|':\n                arg = SPN_WHITESPACE_CHARS(arg+1);\n            }\n\n            len = (int)(BRK_SET_SEPARATOR_CHARS(arg) - arg);\n            if (len == 0)\n                break;\n\n            if ((len == 3) && (strncmp(arg, zAll, 3) == 0)) {\n                if (inv_val)\n                     res = 0;\n                else res = ~0UL;\n            }\n            else if ((len == 4) && (strncmp(arg, zNone, 4) == 0)) {\n                if (! inv_val)\n                    res = 0;\n            }\n            else do {\n                char *    pz;\n                uintptr_t bit = strtoul(arg, &pz, 0);\n\n                if (pz != arg + len) {\n                    bit = find_member_bit(opts, od, pz, len, nm_list, nm_ct);\n                    if (bit == 0UL)\n                        goto fail_return;\n                }\n                if (inv_val)\n                     res &= ~bit;\n                else res |= bit;\n            } while (false);\n\n            arg = SPN_WHITESPACE_CHARS(arg + len);\n        }\n\n        if (invert)\n            res ^= ~0UL;\n\n        if (nm_ct < (8 * sizeof(uintptr_t)))\n            res &= (1UL << nm_ct) - 1UL;\n\n        od->optCookie = VOIDP(res);\n    }\n    return;\n\nfail_return:\n    od->optCookie = VOIDP(0);\n}",
      "lines": 99,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/env.c": {
    "doPrognameEnv": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "LOCAL void\ndoPrognameEnv(tOptions * pOpts, teEnvPresetType type)\n{\n    char const *        env_opts = getenv(pOpts->pzPROGNAME);\n    token_list_t *      pTL;\n    int                 sv_argc;\n    proc_state_mask_t   sv_flag;\n    char **             sv_argv;\n\n    /*\n     *  No such beast?  Then bail now.\n     */\n    if (env_opts == NULL)\n        return;\n\n    /*\n     *  Tokenize the string.  If there's nothing of interest, we'll bail\n     *  here immediately.\n     */\n    pTL = ao_string_tokenize(env_opts);\n    if (pTL == NULL)\n        return;\n\n    /*\n     *  Substitute our $PROGNAME argument list for the real one\n     */\n    sv_argc = (int)pOpts->origArgCt;\n    sv_argv = pOpts->origArgVect;\n    sv_flag = pOpts->fOptSet;\n\n    /*\n     *  We add a bogus pointer to the start of the list.  The program name\n     *  has already been pulled from \"argv\", so it won't get dereferenced.\n     *  The option scanning code will skip the \"program name\" at the start\n     *  of this list of tokens, so we accommodate this way ....\n     */\n    {\n        uintptr_t v = (uintptr_t)(pTL->tkn_list);\n        pOpts->origArgVect = VOIDP(v - sizeof(char *));\n    }\n    pOpts->origArgCt   = (unsigned int)pTL->tkn_ct   + 1;\n    pOpts->fOptSet    &= ~OPTPROC_ERRSTOP;\n\n    pOpts->curOptIdx   = 1;\n    pOpts->pzCurOpt    = NULL;\n\n    switch (type) {\n    case ENV_IMM:\n        (void)immediate_opts(pOpts);\n        break;\n\n    case ENV_ALL:\n        (void)immediate_opts(pOpts);\n        pOpts->curOptIdx = 1;\n        pOpts->pzCurOpt  = NULL;\n        /* FALLTHROUGH */\n\n    case ENV_NON_IMM:\n        (void)regular_opts(pOpts);\n    }\n\n    /*\n     *  Free up the temporary arg vector and restore the original program args.\n     */\n    free(pTL);\n    pOpts->origArgVect = sv_argv;\n    pOpts->origArgCt   = (unsigned int)sv_argc;\n    pOpts->fOptSet     = sv_flag;\n}",
      "lines": 69,
      "depth": 12,
      "decorators": [
        "LOCAL",
        "void",
        "void"
      ]
    },
    "do_env_opt": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "static void\ndo_env_opt(tOptState * os, char * env_name,\n            tOptions * pOpts, teEnvPresetType type)\n{\n    os->pzOptArg = getenv(env_name);\n    if (os->pzOptArg == NULL)\n        return;\n\n    os->flags   = OPTST_PRESET | OPTST_ALLOC_ARG | os->pOD->fOptState;\n    os->optType = TOPT_UNDEFINED;\n\n    if (  (os->pOD->pz_DisablePfx != NULL)\n       && (streqvcmp(os->pzOptArg, os->pOD->pz_DisablePfx) == 0)) {\n        os->flags |= OPTST_DISABLED;\n        os->pzOptArg = NULL;\n        handle_opt(pOpts, os);\n        return;\n    }\n\n    switch (type) {\n    case ENV_IMM:\n        /*\n         *  Process only immediate actions\n         */\n        if (DO_IMMEDIATELY(os->flags))\n            break;\n        return;\n\n    case ENV_NON_IMM:\n        /*\n         *  Process only NON immediate actions\n         */\n        if (DO_NORMALLY(os->flags) || DO_SECOND_TIME(os->flags))\n            break;\n        return;\n\n    default: /* process everything */\n        break;\n    }\n\n    /*\n     *  Make sure the option value string is persistent and consistent.\n     *\n     *  The interpretation of the option value depends\n     *  on the type of value argument the option takes\n     */\n    if (OPTST_GET_ARGTYPE(os->pOD->fOptState) == OPARG_TYPE_NONE) {\n        /*\n         *  Ignore any value.\n         */\n        os->pzOptArg = NULL;\n\n    } else if (os->pzOptArg[0] == NUL) {\n        /*\n         * If the argument is the empty string and the argument is\n         * optional, then treat it as if the option was not specified.\n         */\n        if ((os->pOD->fOptState & OPTST_ARG_OPTIONAL) == 0)\n            return;\n        os->pzOptArg = NULL;\n\n    } else {\n        AGDUPSTR(os->pzOptArg, os->pzOptArg, \"option argument\");\n        os->flags |= OPTST_ALLOC_ARG;\n    }\n\n    handle_opt(pOpts, os);\n}",
      "lines": 68,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "env_presets": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "LOCAL void\nenv_presets(tOptions * pOpts, teEnvPresetType type)\n{\n    int        ct;\n    tOptState  st;\n    char *     pzFlagName;\n    size_t     spaceLeft;\n    char       zEnvName[ AO_NAME_SIZE ];\n\n    /*\n     *  Finally, see if we are to look at the environment\n     *  variables for initial values.\n     */\n    if ((pOpts->fOptSet & OPTPROC_ENVIRON) == 0)\n        return;\n\n    doPrognameEnv(pOpts, type);\n\n    ct  = pOpts->presetOptCt;\n    st.pOD = pOpts->pOptDesc;\n\n    pzFlagName = zEnvName\n        + snprintf(zEnvName, sizeof(zEnvName), \"%s_\", pOpts->pzPROGNAME);\n    spaceLeft = AO_NAME_SIZE - (unsigned long)(pzFlagName - zEnvName) - 1;\n\n    for (;ct-- > 0; st.pOD++) {\n        size_t nln;\n\n        /*\n         *  If presetting is disallowed, then skip this entry\n         */\n        if (  ((st.pOD->fOptState & OPTST_NO_INIT) != 0)\n           || (st.pOD->optEquivIndex != NO_EQUIVALENT)  )\n            continue;\n\n        /*\n         *  IF there is no such environment variable,\n         *  THEN skip this entry, too.\n         */\n        nln = strlen(st.pOD->pz_NAME) + 1;\n        if (nln <= spaceLeft) {\n            /*\n             *  Set up the option state\n             */\n            memcpy(pzFlagName, st.pOD->pz_NAME, nln);\n            do_env_opt(&st, zEnvName, pOpts, type);\n        }\n    }\n\n    /*\n     *  Special handling for ${PROGNAME_LOAD_OPTS}\n     */\n    if (  (pOpts->specOptIdx.save_opts != NO_EQUIVALENT)\n       && (pOpts->specOptIdx.save_opts != 0)) {\n        size_t nln;\n        st.pOD = pOpts->pOptDesc + pOpts->specOptIdx.save_opts + 1;\n\n        if (st.pOD->pz_NAME == NULL)\n            return;\n\n        nln = strlen(st.pOD->pz_NAME) + 1;\n\n        if (nln > spaceLeft)\n            return;\n\n        memcpy(pzFlagName, st.pOD->pz_NAME, nln);\n        do_env_opt(&st, zEnvName, pOpts, type);\n    }\n}",
      "lines": 69,
      "depth": 14,
      "decorators": [
        "LOCAL",
        "void",
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/file.c": {
    "check_existence": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static void\ncheck_existence(teOptFileType ftype, tOptions * pOpts, tOptDesc * pOD)\n{\n    char const * fname = pOD->optArg.argString;\n    struct stat sb;\n\n    errno = 0;\n\n    switch (ftype & FTYPE_MODE_EXIST_MASK) {\n    case FTYPE_MODE_MUST_NOT_EXIST:\n        if ((stat(fname, &sb) == 0) || (errno != ENOENT)) {\n            if (errno == 0)\n                errno = EINVAL;\n            fserr_exit(pOpts->pzProgName, \"stat\", fname);\n            /* NOTREACHED */\n        }\n        /* FALLTHROUGH */\n\n    default:\n    case FTYPE_MODE_MAY_EXIST:\n    {\n        char * p = strrchr(fname, DIRCH);\n        size_t l;\n\n        if (p == NULL)\n            /*\n             *  The file may or may not exist and its directory is \".\".\n             *  Assume that \".\" exists.\n             */\n            break;\n\n        l = (size_t)(p - fname);\n        p = AGALOC(l + 1, \"fname\");\n        memcpy(p, fname, l);\n        p[l] = NUL;\n\n        if ((stat(p, &sb) != 0) || (errno = EINVAL, ! S_ISDIR(sb.st_mode)))\n            fserr_exit(pOpts->pzProgName, \"stat\", p);\n            /* NOTREACHED */\n\n        AGFREE(p);\n        break;\n    }\n\n    case FTYPE_MODE_MUST_EXIST:\n        if (  (stat(fname, &sb) != 0)\n           || (errno = EINVAL, ! S_ISREG(sb.st_mode))  )\n            fserr_exit(pOpts->pzProgName, \"stat\", fname);\n            /* NOTREACHED */\n\n        break;\n    }\n}",
      "lines": 53,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "open_file_fd": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "static void\nopen_file_fd(tOptions * pOpts, tOptDesc * pOD, tuFileMode mode)\n{\n    int fd = open(pOD->optArg.argString, mode.file_flags);\n    if (fd < 0)\n        fserr_exit(pOpts->pzProgName, \"open\", pOD->optArg.argString);\n        /* NOTREACHED */\n\n    if ((pOD->fOptState & OPTST_ALLOC_ARG) != 0)\n        pOD->optCookie = VOIDP(pOD->optArg.argString);\n    else\n        AGDUPSTR(pOD->optCookie, pOD->optArg.argString, \"file name\");\n\n    pOD->optArg.argFd = fd;\n    pOD->fOptState &= ~OPTST_ALLOC_ARG;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fopen_file_fp": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "static void\nfopen_file_fp(tOptions * pOpts, tOptDesc * pOD, tuFileMode mode)\n{\n    FILE * fp = fopen(pOD->optArg.argString, mode.file_mode);\n    if (fp == NULL)\n        fserr_exit(pOpts->pzProgName, \"fopen\", pOD->optArg.argString);\n        /* NOTREACHED */\n\n    if ((pOD->fOptState & OPTST_ALLOC_ARG) != 0)\n        pOD->optCookie = VOIDP(pOD->optArg.argString);\n    else\n        AGDUPSTR(pOD->optCookie, pOD->optArg.argString, \"file name\");\n\n    pOD->optArg.argFp = fp;\n    pOD->fOptState &= ~OPTST_ALLOC_ARG;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "optionFileCheck": {
      "start_point": [
        157,
        0
      ],
      "end_point": [
        191,
        1
      ],
      "content": "void\noptionFileCheck(tOptions * pOpts, tOptDesc * pOD,\n                teOptFileType ftype, tuFileMode mode)\n{\n    if (pOpts <= OPTPROC_EMIT_LIMIT) {\n        if (pOpts != OPTPROC_EMIT_USAGE)\n            return;\n\n        switch (ftype & FTYPE_MODE_EXIST_MASK) {\n        case FTYPE_MODE_MUST_NOT_EXIST:\n            fputs(zFileCannotExist + tab_skip_ct, option_usage_fp);\n            break;\n\n        case FTYPE_MODE_MUST_EXIST:\n            fputs(zFileMustExist + tab_skip_ct, option_usage_fp);\n            break;\n        }\n        return;\n    }\n\n    if ((pOD->fOptState & OPTST_RESET) != 0) {\n        if (pOD->optCookie != NULL)\n            AGFREE(pOD->optCookie);\n        return;\n    }\n\n    check_existence(ftype, pOpts, pOD);\n\n    switch (ftype & FTYPE_MODE_OPEN_MASK) {\n    default:\n    case FTYPE_MODE_NO_OPEN:  break;\n    case FTYPE_MODE_OPEN_FD:  open_file_fd( pOpts, pOD, mode); break;\n    case FTYPE_MODE_FOPEN_FP: fopen_file_fp(pOpts, pOD, mode); break;\n    }\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/find.c": {
    "parse_opt": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "static int\nparse_opt(char const ** nm_pp, char ** arg_pp, char * buf, size_t bufsz)\n{\n    int  res = 0;\n    char const * p = *nm_pp;\n    *arg_pp  = NULL;\n\n    for (;;) {\n        switch (*(p++)) {\n        case NUL: return res;\n\n        case '=':\n            memcpy(buf, *nm_pp, (size_t)res);\n\n            buf[res] = NUL;\n            *nm_pp   = buf;\n            *arg_pp  = (char *)p;\n            return res;\n\n        default:\n            if (++res >= (int)bufsz)\n                return -1;\n        }\n    }\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "opt_ambiguities": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "static void\nopt_ambiguities(tOptions * opts, char const * name, int nm_len)\n{\n    char const * const hyph =\n        NAMED_OPTS(opts) ? \"\" : LONG_OPT_MARKER;\n\n    tOptDesc * pOD = opts->pOptDesc;\n    int        idx = 0;\n\n    fputs(zambig_list_msg, stderr);\n    do  {\n        if (pOD->pz_Name == NULL)\n            continue; /* doc option */\n\n        if (strneqvcmp(name, pOD->pz_Name, nm_len) == 0)\n            fprintf(stderr, zambig_file, hyph, pOD->pz_Name);\n\n        else if (  (pOD->pz_DisableName != NULL)\n                && (strneqvcmp(name, pOD->pz_DisableName, nm_len) == 0)\n                )\n            fprintf(stderr, zambig_file, hyph, pOD->pz_DisableName);\n    } while (pOD++, (++idx < opts->optCt));\n}",
      "lines": 23,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "opt_match_ct": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "static int\nopt_match_ct(tOptions * opts, char const * name, int nm_len,\n             int * ixp, bool * disable)\n{\n    int   matchCt  = 0;\n    int   idx      = 0;\n    int   idxLim   = opts->optCt;\n    tOptDesc * pOD = opts->pOptDesc;\n\n    do  {\n        /*\n         *  If option disabled or a doc option, skip to next\n         */\n        if (pOD->pz_Name == NULL)\n            continue;\n\n        if (  SKIP_OPT(pOD)\n           && (pOD->fOptState != (OPTST_OMITTED | OPTST_NO_INIT)))\n            continue;\n\n        if (strneqvcmp(name, pOD->pz_Name, nm_len) == 0) {\n            /*\n             *  IF we have a complete match\n             *  THEN it takes priority over any already located partial\n             */\n            if (pOD->pz_Name[ nm_len ] == NUL) {\n                *ixp = idx;\n                return 1;\n            }\n        }\n\n        /*\n         *  IF       there is a disable name\n         *     *AND* the option name matches the disable name\n         *  THEN ...\n         */\n        else if (  (pOD->pz_DisableName != NULL)\n                && (strneqvcmp(name, pOD->pz_DisableName, nm_len) == 0)\n                )  {\n            *disable = true;\n\n            /*\n             *  IF we have a complete match\n             *  THEN it takes priority over any already located partial\n             */\n            if (pOD->pz_DisableName[ nm_len ] == NUL) {\n                *ixp = idx;\n                return 1;\n            }\n        }\n\n        else\n            continue; /* does not match any option */\n\n        /*\n         *  We found a full or partial match, either regular or disabling.\n         *  Remember the index for later.\n         */\n        *ixp = idx;\n        ++matchCt;\n\n    } while (pOD++, (++idx < idxLim));\n\n    return matchCt;\n}",
      "lines": 65,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "opt_set": {
      "start_point": [
        207,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "static tSuccess\nopt_set(tOptions * opts, char * arg, int idx, bool disable, tOptState * st)\n{\n    tOptDesc * pOD = opts->pOptDesc + idx;\n\n    if (SKIP_OPT(pOD)) {\n        if ((opts->fOptSet & OPTPROC_ERRSTOP) == 0)\n            return FAILURE;\n\n        fprintf(stderr, zDisabledErr, opts->pzProgName, pOD->pz_Name);\n        if (pOD->pzText != NULL)\n            fprintf(stderr, SET_OFF_FMT, pOD->pzText);\n        fputc(NL, stderr);\n        (*opts->pUsageProc)(opts, EXIT_FAILURE);\n        /* NOTREACHED */\n        _exit(EXIT_FAILURE); /* to be certain */\n    }\n\n    /*\n     *  IF we found a disablement name,\n     *  THEN set the bit in the callers' flag word\n     */\n    if (disable)\n        st->flags |= OPTST_DISABLED;\n\n    st->pOD      = pOD;\n    st->pzOptArg = arg;\n    st->optType  = TOPT_LONG;\n\n    return SUCCESS;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "tSuccess"
      ]
    },
    "opt_unknown": {
      "start_point": [
        250,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "static tSuccess\nopt_unknown(tOptions * opts, char const * name, char * arg, tOptState * st)\n{\n    /*\n     *  IF there is no equal sign\n     *     *AND* we are using named arguments\n     *     *AND* there is a default named option,\n     *  THEN return that option.\n     */\n    if (  (arg == NULL)\n       && NAMED_OPTS(opts)\n       && (opts->specOptIdx.default_opt != NO_EQUIVALENT)) {\n\n        st->pOD      = opts->pOptDesc + opts->specOptIdx.default_opt;\n        st->pzOptArg = name;\n        st->optType  = TOPT_DEFAULT;\n        return SUCCESS;\n    }\n\n    if ((opts->fOptSet & OPTPROC_ERRSTOP) != 0) {\n        fprintf(stderr, zIllOptStr, opts->pzProgPath, name);\n        (*opts->pUsageProc)(opts, EXIT_FAILURE);\n        /* NOTREACHED */\n        _exit(EXIT_FAILURE); /* to be certain */\n    }\n\n    return FAILURE;\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "tSuccess"
      ]
    },
    "opt_ambiguous": {
      "start_point": [
        288,
        0
      ],
      "end_point": [
        300,
        1
      ],
      "content": "static tSuccess\nopt_ambiguous(tOptions * opts, char const * name, int match_ct)\n{\n    if ((opts->fOptSet & OPTPROC_ERRSTOP) != 0) {\n        fprintf(stderr, zambig_opt_fmt, opts->pzProgPath, name, match_ct);\n        if (match_ct <= 4)\n            opt_ambiguities(opts, name, (int)strlen(name));\n        (*opts->pUsageProc)(opts, EXIT_FAILURE);\n        /* NOTREACHED */\n        _exit(EXIT_FAILURE); /* to be certain */\n    }\n    return FAILURE;\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "tSuccess"
      ]
    },
    "optionVendorOption": {
      "start_point": [
        315,
        0
      ],
      "end_point": [
        358,
        1
      ],
      "content": "void\noptionVendorOption(tOptions * pOpts, tOptDesc * pOD)\n{\n    tOptState     opt_st   = OPTSTATE_INITIALIZER(PRESET);\n    char const *  vopt_str = pOD->optArg.argString;\n\n    if (pOpts <= OPTPROC_EMIT_LIMIT)\n        return;\n\n    if ((pOD->fOptState & OPTST_RESET) != 0)\n        return;\n\n    if ((pOD->fOptState & OPTPROC_IMMEDIATE) == 0)\n        opt_st.flags = OPTST_DEFINED;\n\n    if (  ((pOpts->fOptSet & OPTPROC_VENDOR_OPT) == 0)\n       || ! SUCCESSFUL(opt_find_long(pOpts, vopt_str, &opt_st))\n       || ! SUCCESSFUL(get_opt_arg(pOpts, &opt_st)) )\n    {\n        fprintf(stderr, zIllVendOptStr, pOpts->pzProgName, vopt_str);\n        (*pOpts->pUsageProc)(pOpts, EXIT_FAILURE);\n        /* NOTREACHED */\n        _exit(EXIT_FAILURE); /* to be certain */\n    }\n\n    /*\n     *  See if we are in immediate handling state.\n     */\n    if (pOpts->fOptSet & OPTPROC_IMMEDIATE) {\n        /*\n         *  See if the enclosed option is okay with that state.\n         */\n        if (DO_IMMEDIATELY(opt_st.flags))\n            (void)handle_opt(pOpts, &opt_st);\n\n    } else {\n        /*\n         *  non-immediate direction.\n         *  See if the enclosed option is okay with that state.\n         */\n        if (DO_NORMALLY(opt_st.flags) || DO_SECOND_TIME(opt_st.flags))\n            (void)handle_opt(pOpts, &opt_st);\n    }\n}",
      "lines": 44,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "opt_find_long": {
      "start_point": [
        369,
        0
      ],
      "end_point": [
        400,
        1
      ],
      "content": "LOCAL tSuccess\nopt_find_long(tOptions * opts, char const * opt_name, tOptState * state)\n{\n    char    name_buf[128];\n    char *  opt_arg;\n    int     nm_len = parse_opt(&opt_name, &opt_arg, name_buf, sizeof(name_buf));\n\n    int     idx = 0;\n    bool    disable  = false;\n    int     ct;\n\n    if (nm_len <= 1) {\n        if ((opts->fOptSet & OPTPROC_ERRSTOP) == 0)\n            return FAILURE;\n        \n        fprintf(stderr, zInvalOptName, opts->pzProgName, opt_name);\n        (*opts->pUsageProc)(opts, EXIT_FAILURE);\n        /* NOTREACHED */\n        _exit(EXIT_FAILURE); /* to be certain */\n    }\n\n    ct = opt_match_ct(opts, opt_name, nm_len, &idx, &disable);\n\n    /*\n     *  See if we found one match, no matches or multiple matches.\n     */\n    switch (ct) {\n    case 1:  return opt_set(opts, opt_arg, idx, disable, state);\n    case 0:  return opt_unknown(opts, opt_name, opt_arg, state);\n    default: return opt_ambiguous(opts, opt_name, ct);\n    }\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "LOCAL",
        "tSuccess",
        "tSuccess"
      ]
    },
    "opt_find_short": {
      "start_point": [
        410,
        0
      ],
      "end_point": [
        475,
        1
      ],
      "content": "LOCAL tSuccess\nopt_find_short(tOptions * pOpts, uint_t optValue, tOptState * pOptState)\n{\n    tOptDesc * pRes = pOpts->pOptDesc;\n    int        ct   = pOpts->optCt;\n\n    /*\n     *  Search the option list\n     */\n    do  {\n        if (optValue != pRes->optValue)\n            continue;\n\n        if (SKIP_OPT(pRes)) {\n            if (  (pRes->fOptState == (OPTST_OMITTED | OPTST_NO_INIT))\n               && (pRes->pz_Name != NULL)) {\n                if ((pOpts->fOptSet & OPTPROC_ERRSTOP) == 0)\n                    return FAILURE;\n        \n                fprintf(stderr, zDisabledErr, pOpts->pzProgPath, pRes->pz_Name);\n                if (pRes->pzText != NULL)\n                    fprintf(stderr, SET_OFF_FMT, pRes->pzText);\n                fputc(NL, stderr);\n                (*pOpts->pUsageProc)(pOpts, EXIT_FAILURE);\n                /* NOTREACHED */\n                _exit(EXIT_FAILURE); /* to be certain */\n            }\n            goto short_opt_error;\n        }\n\n        pOptState->pOD     = pRes;\n        pOptState->optType = TOPT_SHORT;\n        return SUCCESS;\n\n    } while (pRes++, --ct > 0);\n\n    /*\n     *  IF    the character value is a digit\n     *    AND there is a special number option (\"-n\")\n     *  THEN the result is the \"option\" itself and the\n     *       option is the specially marked \"number\" option.\n     */\n    if (  IS_DEC_DIGIT_CHAR(optValue)\n       && (pOpts->specOptIdx.number_option != NO_EQUIVALENT) ) {\n        pOptState->pOD = \\\n        pRes           = pOpts->pOptDesc + pOpts->specOptIdx.number_option;\n        (pOpts->pzCurOpt)--;\n        pOptState->optType = TOPT_SHORT;\n        return SUCCESS;\n    }\n\n short_opt_error:\n\n    /*\n     *  IF we are to stop on errors (the default, actually)\n     *  THEN call the usage procedure.\n     */\n    if ((pOpts->fOptSet & OPTPROC_ERRSTOP) != 0) {\n        fprintf(stderr, zIllOptChr, pOpts->pzProgPath, optValue);\n        (*pOpts->pUsageProc)(pOpts, EXIT_FAILURE);\n        /* NOTREACHED */\n        _exit(EXIT_FAILURE); /* to be certain */\n    }\n\n    return FAILURE;\n}",
      "lines": 66,
      "depth": 15,
      "decorators": [
        "LOCAL",
        "tSuccess",
        "tSuccess"
      ]
    },
    "get_opt_arg_must": {
      "start_point": [
        486,
        0
      ],
      "end_point": [
        532,
        1
      ],
      "content": "static tSuccess\nget_opt_arg_must(tOptions * opts, tOptState * o_st)\n{\n    switch (o_st->optType) {\n    case TOPT_SHORT:\n        /*\n         *  See if an arg string follows the flag character\n         */\n        if (*++(opts->pzCurOpt) == NUL)\n            opts->pzCurOpt = opts->origArgVect[ opts->curOptIdx++ ];\n        o_st->pzOptArg = opts->pzCurOpt;\n        break;\n\n    case TOPT_LONG:\n        /*\n         *  See if an arg string has already been assigned (glued on\n         *  with an `=' character)\n         */\n        if (o_st->pzOptArg == NULL)\n            o_st->pzOptArg = opts->origArgVect[ opts->curOptIdx++ ];\n        break;\n\n    default:\n#ifdef DEBUG\n        fputs(\"AutoOpts lib error: option type not selected\\n\", stderr);\n        option_exits(EXIT_FAILURE);\n#endif\n\n    case TOPT_DEFAULT:\n        /*\n         *  The option was selected by default.  The current token is\n         *  the option argument.\n         */\n        break;\n    }\n\n    /*\n     *  Make sure we did not overflow the argument list.\n     */\n    if (opts->curOptIdx > opts->origArgCt) {\n        fprintf(stderr, zMisArg, opts->pzProgPath, o_st->pOD->pz_Name);\n        return FAILURE;\n    }\n\n    opts->pzCurOpt = NULL;  /* next time advance to next arg */\n    return SUCCESS;\n}",
      "lines": 47,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "tSuccess"
      ]
    },
    "get_opt_arg_may": {
      "start_point": [
        545,
        0
      ],
      "end_point": [
        608,
        1
      ],
      "content": "static tSuccess\nget_opt_arg_may(tOptions * pOpts, tOptState * o_st)\n{\n    /*\n     *  An option argument is optional.\n     */\n    switch (o_st->optType) {\n    case TOPT_SHORT:\n        if (*++pOpts->pzCurOpt != NUL)\n            o_st->pzOptArg = pOpts->pzCurOpt;\n        else {\n            char * pzLA = pOpts->origArgVect[ pOpts->curOptIdx ];\n\n            /*\n             *  BECAUSE it is optional, we must make sure\n             *  we did not find another flag and that there\n             *  is such an argument.\n             */\n            if ((pzLA == NULL) || (*pzLA == '-'))\n                o_st->pzOptArg = NULL;\n            else {\n                pOpts->curOptIdx++; /* argument found */\n                o_st->pzOptArg = pzLA;\n            }\n        }\n        break;\n\n    case TOPT_LONG:\n        /*\n         *  Look for an argument if we don't already have one (glued on\n         *  with a `=' character) *AND* we are not in named argument mode\n         */\n        if (  (o_st->pzOptArg == NULL)\n           && (! NAMED_OPTS(pOpts))) {\n            char * pzLA = pOpts->origArgVect[ pOpts->curOptIdx ];\n\n            /*\n             *  BECAUSE it is optional, we must make sure\n             *  we did not find another flag and that there\n             *  is such an argument.\n             */\n            if ((pzLA == NULL) || (*pzLA == '-'))\n                o_st->pzOptArg = NULL;\n            else {\n                pOpts->curOptIdx++; /* argument found */\n                o_st->pzOptArg = pzLA;\n            }\n        }\n        break;\n\n    default:\n    case TOPT_DEFAULT:\n        ao_bug(zbad_default_msg);\n    }\n\n    /*\n     *  After an option with an optional argument, we will\n     *  *always* start with the next option because if there\n     *  were any characters following the option name/flag,\n     *  they would be interpreted as the argument.\n     */\n    pOpts->pzCurOpt = NULL;\n    return SUCCESS;\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "tSuccess"
      ]
    },
    "get_opt_arg_none": {
      "start_point": [
        617,
        0
      ],
      "end_point": [
        641,
        1
      ],
      "content": "static tSuccess\nget_opt_arg_none(tOptions * pOpts, tOptState * o_st)\n{\n    /*\n     *  No option argument.  Make sure next time around we find\n     *  the correct option flag character for short options\n     */\n    if (o_st->optType == TOPT_SHORT)\n        (pOpts->pzCurOpt)++;\n\n    /*\n     *  It is a long option.  Make sure there was no ``=xxx'' argument\n     */\n    else if (o_st->pzOptArg != NULL) {\n        fprintf(stderr, zNoArg, pOpts->pzProgPath, o_st->pOD->pz_Name);\n        return FAILURE;\n    }\n\n    /*\n     *  It is a long option.  Advance to next command line argument.\n     */\n    else\n        pOpts->pzCurOpt = NULL;\n    return SUCCESS;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "tSuccess"
      ]
    },
    "get_opt_arg": {
      "start_point": [
        650,
        0
      ],
      "end_point": [
        668,
        1
      ],
      "content": "LOCAL tSuccess\nget_opt_arg(tOptions * opts, tOptState * o_st)\n{\n    o_st->flags |= (o_st->pOD->fOptState & OPTST_PERSISTENT_MASK);\n\n    /*\n     * Disabled options and options specified to not have arguments\n     * are handled with the \"none\" procedure.  Otherwise, check the\n     * optional flag and call either the \"may\" or \"must\" function.\n     */\n    if (  ((o_st->flags & OPTST_DISABLED) != 0)\n       || (OPTST_GET_ARGTYPE(o_st->flags) == OPARG_TYPE_NONE))\n        return get_opt_arg_none(opts, o_st);\n    \n    if (o_st->flags & OPTST_ARG_OPTIONAL)\n        return get_opt_arg_may( opts, o_st);\n    \n    return get_opt_arg_must(opts, o_st);\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "LOCAL",
        "tSuccess",
        "tSuccess"
      ]
    },
    "find_opt": {
      "start_point": [
        677,
        0
      ],
      "end_point": [
        770,
        1
      ],
      "content": "LOCAL tSuccess\nfind_opt(tOptions * opts, tOptState * o_st)\n{\n    /*\n     *  IF we are continuing a short option list (e.g. -xyz...)\n     *  THEN continue a single flag option.\n     *  OTHERWISE see if there is room to advance and then do so.\n     */\n    if ((opts->pzCurOpt != NULL) && (*opts->pzCurOpt != NUL))\n        return opt_find_short(opts, (uint8_t)*(opts->pzCurOpt), o_st);\n\n    if (opts->curOptIdx >= opts->origArgCt)\n        return PROBLEM; /* NORMAL COMPLETION */\n\n    opts->pzCurOpt = opts->origArgVect[ opts->curOptIdx ];\n\n    /*\n     *  IF all arguments must be named options, ...\n     */\n    if (NAMED_OPTS(opts)) {\n        char *      pz  = opts->pzCurOpt;\n        int         def;\n        tSuccess    res;\n        uint16_t *  def_opt;\n\n        opts->curOptIdx++;\n\n        if (*pz != '-')\n            return opt_find_long(opts, pz, o_st);\n\n        /*\n         *  The name is prefixed with one or more hyphens.  Strip them off\n         *  and disable the \"default_opt\" setting.  Use heavy recasting to\n         *  strip off the \"const\" quality of the \"default_opt\" field.\n         */\n        while (*(++pz) == '-')   ;\n        def_opt  = VOIDP(&(opts->specOptIdx.default_opt));\n        def      = *def_opt;\n        *def_opt = NO_EQUIVALENT;\n        res      = opt_find_long(opts, pz, o_st);\n        *def_opt = (uint16_t)def;\n        return res;\n    }\n\n    /*\n     *  Note the kind of flag/option marker\n     */\n    if (*((opts->pzCurOpt)++) != '-')\n        return PROBLEM; /* NORMAL COMPLETION - this + rest are operands */\n\n    /*\n     *  Special hack for a hyphen by itself\n     */\n    if (*(opts->pzCurOpt) == NUL)\n        return PROBLEM; /* NORMAL COMPLETION - this + rest are operands */\n\n    /*\n     *  The current argument is to be processed as an option argument\n     */\n    opts->curOptIdx++;\n\n    /*\n     *  We have an option marker.\n     *  Test the next character for long option indication\n     */\n    if (opts->pzCurOpt[0] == '-') {\n        if (*++(opts->pzCurOpt) == NUL)\n            /*\n             *  NORMAL COMPLETION - NOT this arg, but rest are operands\n             */\n            return PROBLEM;\n\n        /*\n         *  We do not allow the hyphen to be used as a flag value.\n         *  Therefore, if long options are not to be accepted, we punt.\n         */\n        if ((opts->fOptSet & OPTPROC_LONGOPT) == 0) {\n            fprintf(stderr, zIllOptStr, opts->pzProgPath, opts->pzCurOpt-2);\n            return FAILURE;\n        }\n\n        return opt_find_long(opts, opts->pzCurOpt, o_st);\n    }\n\n    /*\n     *  If short options are not allowed, then do long\n     *  option processing.  Otherwise the character must be a\n     *  short (i.e. single character) option.\n     */\n    if ((opts->fOptSet & OPTPROC_SHORTOPT) != 0)\n        return opt_find_short(opts, (uint8_t)*(opts->pzCurOpt), o_st);\n\n    return opt_find_long(opts, opts->pzCurOpt, o_st);\n}",
      "lines": 94,
      "depth": 13,
      "decorators": [
        "LOCAL",
        "tSuccess",
        "tSuccess"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/genshell.c": {
    "doUsageOpt": {
      "start_point": [
        285,
        0
      ],
      "end_point": [
        295,
        1
      ],
      "content": "static void\ndoUsageOpt(tOptions * opts, tOptDesc * od)\n{\n    int ex_code;\n    ex_code = GENSHELLOPT_EXIT_SUCCESS;\n    genshelloptUsage(&genshelloptOptions, ex_code);\n    /* NOTREACHED */\n    exit(1);\n    (void)opts;\n    (void)od;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "AO_gettext": {
      "start_point": [
        393,
        0
      ],
      "end_point": [
        422,
        1
      ],
      "content": "static char *\nAO_gettext(char const * pz)\n{\n    char * res;\n    if (pz == NULL)\n        return NULL;\n#ifdef HAVE_DCGETTEXT\n    /*\n     * While processing the option_xlateable_txt data, try to use the\n     * \"libopts\" domain.  Once we switch to the option descriptor data,\n     * do *not* use that domain.\n     */\n    if (option_xlateable_txt.field_ct != 0) {\n        res = dgettext(\"libopts\", pz);\n        if (res == pz)\n            res = (char *)VOIDP(_(pz));\n    } else\n        res = (char *)VOIDP(_(pz));\n#else\n    res = (char *)VOIDP(_(pz));\n#endif\n    if (res == pz)\n        return res;\n    res = strdup(res);\n    if (res == NULL) {\n        fputs(_(\"No memory for duping translated strings\\n\"), stderr);\n        exit(GENSHELLOPT_EXIT_FAILURE);\n    }\n    return res;\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nAO_gettext(char const * pz)",
        "*"
      ]
    },
    "coerce_it": {
      "start_point": [
        428,
        0
      ],
      "end_point": [
        429,
        1
      ],
      "content": "static void coerce_it(void ** s) { *s = AO_gettext(*s);\n}",
      "lines": 2,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "translate_option_strings": {
      "start_point": [
        435,
        0
      ],
      "end_point": [
        471,
        1
      ],
      "content": "static void\ntranslate_option_strings(void)\n{\n    tOptions * const opts = &genshelloptOptions;\n\n    /*\n     *  Guard against re-translation.  It won't work.  The strings will have\n     *  been changed by the first pass through this code.  One shot only.\n     */\n    if (option_xlateable_txt.field_ct != 0) {\n        /*\n         *  Do the translations.  The first pointer follows the field count\n         *  field.  The field count field is the size of a pointer.\n         */\n        char ** ppz = (char**)VOIDP(&(option_xlateable_txt));\n        int     ix  = option_xlateable_txt.field_ct;\n\n        do {\n            ppz++; /* skip over field_ct */\n            *ppz = AO_gettext(*ppz);\n        } while (--ix > 0);\n        /* prevent re-translation and disable \"libopts\" domain lookup */\n        option_xlateable_txt.field_ct = 0;\n\n        coerce_it(VOIDP(&(opts->pzCopyright)));\n        coerce_it(VOIDP(&(opts->pzCopyNotice)));\n        coerce_it(VOIDP(&(opts->pzFullVersion)));\n        coerce_it(VOIDP(&(opts->pzUsageTitle)));\n        coerce_it(VOIDP(&(opts->pzExplain)));\n        coerce_it(VOIDP(&(opts->pzDetail)));\n        {\n            tOptDesc * od = opts->pOptDesc;\n            for (ix = opts->optCt; ix > 0; ix--, od++)\n                coerce_it(VOIDP(&(od->pzText)));\n        }\n    }\n}",
      "lines": 37,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bogus_function": {
      "start_point": [
        476,
        0
      ],
      "end_point": [
        841,
        1
      ],
      "content": "static void bogus_function(void) {\n  /* TRANSLATORS:\n\n     The following dummy function was crated solely so that xgettext can\n     extract the correct strings.  These strings are actually referenced\n     by a field name in the genshelloptOptions structure noted in the\n     comments below.  The literal text is defined in genshellopt_opt_strs.\n   \n     NOTE: the strings below are segmented with respect to the source string\n     genshellopt_opt_strs.  The strings above are handed off for translation\n     at run time a paragraph at a time.  Consequently, they are presented here\n     for translation a paragraph at a time.\n   \n     ALSO: often the description for an option will reference another option\n     by name.  These are set off with apostrophe quotes (I hope).  Do not\n     translate option names.\n   */\n  /* referenced via genshelloptOptions.pzCopyright */\n  puts(_(\"genshellopt 1\\n\\\nCopyright (C) 1999-2014 Bruce Korb, all rights reserved.\\n\\\nThis is free software. It is licensed for use, modification and\\n\\\nredistribution under the terms of the GNU Lesser General Public License,\\n\\\nversion 2 or later <http://www.gnu.org/licenses/old-licenses/lgpl-2.0.html>\\n\"));\n\n  /* referenced via genshelloptOptions.pzCopyNotice */\n  puts(_(\"The genshellopt library is free software; you can redistribute it and/or\\n\\\nmodify it under the terms of the GNU Library General Public License as\\n\\\npublished by the Free Software Foundation; either version 2 of the License,\\n\\\nor (at your option) any later version.\\n\\n\"));\n  puts(_(\"This library is distributed in the hope that it will be useful, but WITHOUT\\n\\\nANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\\n\\\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public\\n\\\nLicense for more details.\\n\\n\"));\n  puts(_(\"You should have received a copy of the GNU Library General Public License\\n\\\nalong with this library; if not, see\\n\\\n<http://www.gnu.org/licenses/old-licenses/lgpl-2.0.html>\\n\"));\n\n  /* referenced via genshelloptOptions.pOptDesc->pzText */\n  puts(_(\"Output Script File\"));\n\n  /* referenced via genshelloptOptions.pOptDesc->pzText */\n  puts(_(\"Shell name (follows \\\"#!\\\" magic)\"));\n\n  /* referenced via genshelloptOptions.pOptDesc->pzText */\n  puts(_(\"display extended usage information and exit\"));\n\n  /* referenced via genshelloptOptions.pOptDesc->pzText */\n  puts(_(\"extended usage information passed thru pager\"));\n\n  /* referenced via genshelloptOptions.pOptDesc->pzText */\n  puts(_(\"output version information and exit\"));\n\n  /* referenced via genshelloptOptions.pzUsageTitle */\n  puts(_(\"genshellopt - Generate Shell Option Processing Script - Ver. 1\\n\\\nUsage:  %s [ -<flag> [<val>] | --<name>[{=| }<val>] ]...\\n\"));\n\n  /* referenced via genshelloptOptions.pzExplain */\n  puts(_(\"Note that 'shell' is only useful if the output file does not already exist.\\n\\\nIf it does, then the shell name and optional first argument will be\\n\\\nextracted from the script file.\\n\"));\n\n  /* referenced via genshelloptOptions.pzDetail */\n  puts(_(\"If the script file already exists and contains Automated Option Processing\\n\\\ntext, the second line of the file through the ending tag will be replaced\\n\\\nby the newly generated text.  The first '#!' line will be regenerated.\\n\"));\n\n  /* referenced via genshelloptOptions.pzFullVersion */\n  puts(_(\"genshellopt 1\"));\n\n  /* referenced via genshelloptOptions.pzFullUsage */\n  puts(_(\"<<<NOT-FOUND>>>\"));\n\n  /* referenced via genshelloptOptions.pzShortUsage */\n  puts(_(\"<<<NOT-FOUND>>>\"));\n  /* LIBOPTS-MESSAGES: */\n#line 67 \"../autoopts.c\"\n  puts(_(\"allocation of %d bytes failed\\n\"));\n#line 93 \"../autoopts.c\"\n  puts(_(\"allocation of %d bytes failed\\n\"));\n#line 53 \"../init.c\"\n  puts(_(\"AutoOpts function called without option descriptor\\n\"));\n#line 86 \"../init.c\"\n  puts(_(\"\\tThis exceeds the compiled library version:  \"));\n#line 84 \"../init.c\"\n  puts(_(\"Automated Options Processing Error!\\n\"\n       \"\\t%s called AutoOpts function with structure version %d:%d:%d.\\n\"));\n#line 80 \"../autoopts.c\"\n  puts(_(\"realloc of %d bytes at 0x%p failed\\n\"));\n#line 88 \"../init.c\"\n  puts(_(\"\\tThis is less than the minimum library version:  \"));\n#line 121 \"../version.c\"\n  puts(_(\"Automated Options version %s\\n\"\n       \"\\tCopyright (C) 1999-2014 by Bruce Korb - all rights reserved\\n\"));\n#line 87 \"../makeshell.c\"\n  puts(_(\"(AutoOpts bug):  %s.\\n\"));\n#line 90 \"../reset.c\"\n  puts(_(\"optionResetOpt() called, but reset-option not configured\"));\n#line 292 \"../usage.c\"\n  puts(_(\"could not locate the 'help' option\"));\n#line 336 \"../autoopts.c\"\n  puts(_(\"optionProcess() was called with invalid data\"));\n#line 748 \"../usage.c\"\n  puts(_(\"invalid argument type specified\"));\n#line 598 \"../find.c\"\n  puts(_(\"defaulted to option with optional arg\"));\n#line 76 \"../alias.c\"\n  puts(_(\"aliasing option is out of range.\"));\n#line 234 \"../enum.c\"\n  puts(_(\"%s error:  the keyword '%s' is ambiguous for %s\\n\"));\n#line 108 \"../find.c\"\n  puts(_(\"  The following options match:\\n\"));\n#line 293 \"../find.c\"\n  puts(_(\"%s: ambiguous option name: %s (matches %d options)\\n\"));\n#line 161 \"../check.c\"\n  puts(_(\"%s: Command line arguments required\\n\"));\n#line 43 \"../alias.c\"\n  puts(_(\"%d %s%s options allowed\\n\"));\n#line 94 \"../makeshell.c\"\n  puts(_(\"%s error %d (%s) calling %s for '%s'\\n\"));\n#line 306 \"../makeshell.c\"\n  puts(_(\"interprocess pipe\"));\n#line 168 \"../version.c\"\n  puts(_(\"error: version option argument '%c' invalid.  Use:\\n\"\n       \"\\t'v' - version only\\n\"\n       \"\\t'c' - version and copyright\\n\"\n       \"\\t'n' - version and full copyright notice\\n\"));\n#line 58 \"../check.c\"\n  puts(_(\"%s error:  the '%s' and '%s' options conflict\\n\"));\n#line 217 \"../find.c\"\n  puts(_(\"%s: The '%s' option has been disabled.\"));\n#line 430 \"../find.c\"\n  puts(_(\"%s: The '%s' option has been disabled.\"));\n#line 38 \"../alias.c\"\n  puts(_(\"-equivalence\"));\n#line 469 \"../find.c\"\n  puts(_(\"%s: illegal option -- %c\\n\"));\n#line 110 \"../reset.c\"\n  puts(_(\"%s: illegal option -- %c\\n\"));\n#line 271 \"../find.c\"\n  puts(_(\"%s: illegal option -- %s\\n\"));\n#line 755 \"../find.c\"\n  puts(_(\"%s: illegal option -- %s\\n\"));\n#line 118 \"../reset.c\"\n  puts(_(\"%s: illegal option -- %s\\n\"));\n#line 335 \"../find.c\"\n  puts(_(\"%s: unknown vendor extension option -- %s\\n\"));\n#line 159 \"../enum.c\"\n  puts(_(\"  or an integer from %d through %d\\n\"));\n#line 169 \"../enum.c\"\n  puts(_(\"  or an integer from %d through %d\\n\"));\n#line 747 \"../usage.c\"\n  puts(_(\"%s error:  invalid option descriptor for %s\\n\"));\n#line 1081 \"../usage.c\"\n  puts(_(\"%s error:  invalid option descriptor for %s\\n\"));\n#line 385 \"../find.c\"\n  puts(_(\"%s: invalid option name: %s\\n\"));\n#line 527 \"../find.c\"\n  puts(_(\"%s: The '%s' option requires an argument.\\n\"));\n#line 156 \"../autoopts.c\"\n  puts(_(\"(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\\n\"\n       \"\\t'%s' and '%s'.\"));\n#line 94 \"../check.c\"\n  puts(_(\"%s error:  The %s option is required\\n\"));\n#line 632 \"../find.c\"\n  puts(_(\"%s: The '%s' option cannot have an argument.\\n\"));\n#line 151 \"../check.c\"\n  puts(_(\"%s: Command line arguments are not allowed.\\n\"));\n#line 535 \"../save.c\"\n  puts(_(\"error %d (%s) creating %s\\n\"));\n#line 234 \"../enum.c\"\n  puts(_(\"%s error:  '%s' does not match any %s keywords.\\n\"));\n#line 93 \"../reset.c\"\n  puts(_(\"%s error: The '%s' option requires an argument.\\n\"));\n#line 184 \"../save.c\"\n  puts(_(\"error %d (%s) stat-ing %s\\n\"));\n#line 238 \"../save.c\"\n  puts(_(\"error %d (%s) stat-ing %s\\n\"));\n#line 143 \"../restore.c\"\n  puts(_(\"%s error: no saved option state\\n\"));\n#line 231 \"../autoopts.c\"\n  puts(_(\"'%s' is not a command line option.\\n\"));\n#line 111 \"../time.c\"\n  puts(_(\"%s error:  '%s' is not a recognizable date/time.\\n\"));\n#line 132 \"../save.c\"\n  puts(_(\"'%s' not defined\\n\"));\n#line 50 \"../time.c\"\n  puts(_(\"%s error:  '%s' is not a recognizable time duration.\\n\"));\n#line 92 \"../check.c\"\n  puts(_(\"%s error:  The %s option must appear %d times.\\n\"));\n#line 164 \"../numeric.c\"\n  puts(_(\"%s error:  '%s' is not a recognizable number.\\n\"));\n#line 200 \"../enum.c\"\n  puts(_(\"%s error:  %s exceeds %s keyword count\\n\"));\n#line 330 \"../usage.c\"\n  puts(_(\"Try '%s %s' for more information.\\n\"));\n#line 45 \"../alias.c\"\n  puts(_(\"one %s%s option allowed\\n\"));\n#line 208 \"../makeshell.c\"\n  puts(_(\"standard output\"));\n#line 943 \"../makeshell.c\"\n  puts(_(\"standard output\"));\n#line 274 \"../usage.c\"\n  puts(_(\"standard output\"));\n#line 415 \"../usage.c\"\n  puts(_(\"standard output\"));\n#line 625 \"../usage.c\"\n  puts(_(\"standard output\"));\n#line 175 \"../version.c\"\n  puts(_(\"standard output\"));\n#line 274 \"../usage.c\"\n  puts(_(\"standard error\"));\n#line 415 \"../usage.c\"\n  puts(_(\"standard error\"));\n#line 625 \"../usage.c\"\n  puts(_(\"standard error\"));\n#line 175 \"../version.c\"\n  puts(_(\"standard error\"));\n#line 208 \"../makeshell.c\"\n  puts(_(\"write\"));\n#line 943 \"../makeshell.c\"\n  puts(_(\"write\"));\n#line 273 \"../usage.c\"\n  puts(_(\"write\"));\n#line 414 \"../usage.c\"\n  puts(_(\"write\"));\n#line 624 \"../usage.c\"\n  puts(_(\"write\"));\n#line 174 \"../version.c\"\n  puts(_(\"write\"));\n#line 60 \"../numeric.c\"\n  puts(_(\"%s error:  %s option value %ld is out of range.\\n\"));\n#line 44 \"../check.c\"\n  puts(_(\"%s error:  %s option requires the %s option\\n\"));\n#line 131 \"../save.c\"\n  puts(_(\"%s warning:  cannot save options - %s not regular file\\n\"));\n#line 183 \"../save.c\"\n  puts(_(\"%s warning:  cannot save options - %s not regular file\\n\"));\n#line 237 \"../save.c\"\n  puts(_(\"%s warning:  cannot save options - %s not regular file\\n\"));\n#line 256 \"../save.c\"\n  puts(_(\"%s warning:  cannot save options - %s not regular file\\n\"));\n#line 534 \"../save.c\"\n  puts(_(\"%s warning:  cannot save options - %s not regular file\\n\"));\n  /* END-LIBOPTS-MESSAGES */\n\n  /* USAGE-TEXT: */\n#line 873 \"../usage.c\"\n  puts(_(\"\\t\\t\\t\\t- an alternate for '%s'\\n\"));\n#line 1148 \"../usage.c\"\n  puts(_(\"Version, usage and configuration options:\"));\n#line 924 \"../usage.c\"\n  puts(_(\"\\t\\t\\t\\t- default option for unnamed options\\n\"));\n#line 837 \"../usage.c\"\n  puts(_(\"\\t\\t\\t\\t- disabled as '--%s'\\n\"));\n#line 1117 \"../usage.c\"\n  puts(_(\" --- %-14s %s\\n\"));\n#line 1115 \"../usage.c\"\n  puts(_(\"This option has been disabled\"));\n#line 864 \"../usage.c\"\n  puts(_(\"\\t\\t\\t\\t- enabled by default\\n\"));\n#line 40 \"../alias.c\"\n  puts(_(\"%s error:  only \"));\n#line 1194 \"../usage.c\"\n  puts(_(\" - examining environment variables named %s_*\\n\"));\n#line 168 \"../file.c\"\n  puts(_(\"\\t\\t\\t\\t- file must not pre-exist\\n\"));\n#line 172 \"../file.c\"\n  puts(_(\"\\t\\t\\t\\t- file must pre-exist\\n\"));\n#line 380 \"../usage.c\"\n  puts(_(\"Options are specified by doubled hyphens and their name or by a single\\n\"\n       \"hyphen and the flag character.\\n\"));\n#line 921 \"../makeshell.c\"\n  puts(_(\"\\n\"\n       \"= = = = = = = =\\n\\n\"\n       \"This incarnation of genshell will produce\\n\"\n       \"a shell script to parse the options for %s:\\n\\n\"));\n#line 166 \"../enum.c\"\n  puts(_(\"  or an integer mask with any of the lower %d bits set\\n\"));\n#line 897 \"../usage.c\"\n  puts(_(\"\\t\\t\\t\\t- is a set membership option\\n\"));\n#line 918 \"../usage.c\"\n  puts(_(\"\\t\\t\\t\\t- must appear between %d and %d times\\n\"));\n#line 382 \"../usage.c\"\n  puts(_(\"Options are specified by single or double hyphens and their name.\\n\"));\n#line 904 \"../usage.c\"\n  puts(_(\"\\t\\t\\t\\t- may appear multiple times\\n\"));\n#line 891 \"../usage.c\"\n  puts(_(\"\\t\\t\\t\\t- may not be preset\\n\"));\n#line 1309 \"../usage.c\"\n  puts(_(\"   Arg Option-Name    Description\\n\"));\n#line 1245 \"../usage.c\"\n  puts(_(\"  Flg Arg Option-Name    Description\\n\"));\n#line 1303 \"../usage.c\"\n  puts(_(\"  Flg Arg Option-Name    Description\\n\"));\n#line 1304 \"../usage.c\"\n  puts(_(\" %3s %s\"));\n#line 1310 \"../usage.c\"\n  puts(_(\" %3s %s\"));\n#line 387 \"../usage.c\"\n  puts(_(\"The '-#<number>' option may omit the hash char\\n\"));\n#line 383 \"../usage.c\"\n  puts(_(\"All arguments are named options.\\n\"));\n#line 971 \"../usage.c\"\n  puts(_(\" - reading file %s\"));\n#line 409 \"../usage.c\"\n  puts(_(\"\\n\"\n       \"Please send bug reports to:  <%s>\\n\"));\n#line 100 \"../version.c\"\n  puts(_(\"\\n\"\n       \"Please send bug reports to:  <%s>\\n\"));\n#line 129 \"../version.c\"\n  puts(_(\"\\n\"\n       \"Please send bug reports to:  <%s>\\n\"));\n#line 903 \"../usage.c\"\n  puts(_(\"\\t\\t\\t\\t- may NOT appear - preset only\\n\"));\n#line 944 \"../usage.c\"\n  puts(_(\"\\n\"\n       \"The following option preset mechanisms are supported:\\n\"));\n#line 1192 \"../usage.c\"\n  puts(_(\"\\n\"\n       \"The following option preset mechanisms are supported:\\n\"));\n#line 682 \"../usage.c\"\n  puts(_(\"prohibits these options:\\n\"));\n#line 677 \"../usage.c\"\n  puts(_(\"prohibits the option '%s'\\n\"));\n#line 81 \"../numeric.c\"\n  puts(_(\"%s%ld to %ld\"));\n#line 79 \"../numeric.c\"\n  puts(_(\"%sgreater than or equal to %ld\"));\n#line 75 \"../numeric.c\"\n  puts(_(\"%s%ld exactly\"));\n#line 68 \"../numeric.c\"\n  puts(_(\"%sit must lie in one of the ranges:\\n\"));\n#line 68 \"../numeric.c\"\n  puts(_(\"%sit must be in the range:\\n\"));\n#line 88 \"../numeric.c\"\n  puts(_(\", or\\n\"));\n#line 66 \"../numeric.c\"\n  puts(_(\"%sis scalable with a suffix: k/K/m/M/g/G/t/T\\n\"));\n#line 77 \"../numeric.c\"\n  puts(_(\"%sless than or equal to %ld\"));\n#line 390 \"../usage.c\"\n  puts(_(\"Operands and options may be intermixed.  They will be reordered.\\n\"));\n#line 652 \"../usage.c\"\n  puts(_(\"requires the option '%s'\\n\"));\n#line 655 \"../usage.c\"\n  puts(_(\"requires these options:\\n\"));\n#line 1321 \"../usage.c\"\n  puts(_(\"   Arg Option-Name   Req?  Description\\n\"));\n#line 1315 \"../usage.c\"\n  puts(_(\"  Flg Arg Option-Name   Req?  Description\\n\"));\n#line 167 \"../enum.c\"\n  puts(_(\"or you may use a numeric representation.  Preceding these with a '!'\\n\"\n       \"will clear the bits, specifying 'none' will clear all bits, and 'all'\\n\"\n       \"will set them all.  Multiple entries may be passed as an option\\n\"\n       \"argument list.\\n\"));\n#line 910 \"../usage.c\"\n  puts(_(\"\\t\\t\\t\\t- may appear up to %d times\\n\"));\n#line 77 \"../enum.c\"\n  puts(_(\"The valid \\\"%s\\\" option keywords are:\\n\"));\n#line 1152 \"../usage.c\"\n  puts(_(\"The next option supports vendor supported extra options:\"));\n#line 773 \"../usage.c\"\n  puts(_(\"These additional options are:\"));\n  /* END-USAGE-TEXT */\n}",
      "lines": 366,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/genshell.h": {
    "aoGetsText": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "static inline char* aoGetsText(char const* pz) {\n    if (pz == NULL) return NULL;\n    return (char*)gettext(pz);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "char",
        "* aoGetsText(char const* pz)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/gettext.h": {
    "pgettext_aux": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static const char *\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)\n{\n  const char *translation = dcgettext (domain, msg_ctxt_id, category);\n  if (translation == msg_ctxt_id)\n    return msgid;\n  else\n    return translation;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)",
        "*"
      ]
    },
    "npgettext_aux": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "static const char *\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)\n{\n  const char *translation =\n    dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n  if (translation == msg_ctxt_id || translation == msgid_plural)\n    return (n == 1 ? msgid : msgid_plural);\n  else\n    return translation;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)",
        "*"
      ]
    },
    "dcpgettext_expr": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "static const char *\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcgettext (domain, msg_ctxt_id, category);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (translation != msg_ctxt_id)\n        return translation;\n    }\n  return msgid;\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)",
        "*"
      ]
    },
    "dcnpgettext_expr": {
      "start_point": [
        253,
        0
      ],
      "end_point": [
        285,
        1
      ],
      "content": "static const char *\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (!(translation == msg_ctxt_id || translation == msgid_plural))\n        return translation;\n    }\n  return (n == 1 ? msgid : msgid_plural);\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/init.c": {
    "validate_struct": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "LOCAL tSuccess\nvalidate_struct(tOptions * opts, char const * pname)\n{\n    if (opts == NULL) {\n        fputs(zno_opt_arg, stderr);\n        return FAILURE;\n    }\n    print_exit = ((opts->fOptSet & OPTPROC_SHELL_OUTPUT) != 0);\n\n    /*\n     *  IF the client has enabled translation and the translation procedure\n     *  is available, then go do it.\n     */\n    if (  ((opts->fOptSet & OPTPROC_TRANSLATE) != 0)\n       && (opts->pTransProc != NULL)\n       && (option_xlateable_txt.field_ct != 0) ) {\n        /*\n         *  If option names are not to be translated at all, then do not do\n         *  it for configuration parsing either.  (That is the bit that really\n         *  gets tested anyway.)\n         */\n        if ((opts->fOptSet & OPTPROC_NO_XLAT_MASK) == OPTPROC_NXLAT_OPT)\n            opts->fOptSet |= OPTPROC_NXLAT_OPT_CFG;\n        opts->pTransProc();\n    }\n\n    /*\n     *  IF the struct version is not the current, and also\n     *     either too large (?!) or too small,\n     *  THEN emit error message and fail-exit\n     */\n    if (  ( opts->structVersion  != OPTIONS_STRUCT_VERSION  )\n       && (  (opts->structVersion > OPTIONS_STRUCT_VERSION  )\n          || (opts->structVersion < OPTIONS_MINIMUM_VERSION )\n       )  )  {\n        fprintf(stderr, zwrong_ver, pname, NUM_TO_VER(opts->structVersion));\n        if (opts->structVersion > OPTIONS_STRUCT_VERSION )\n            fputs(ztoo_new, stderr);\n        else\n            fputs(ztoo_old, stderr);\n\n        fwrite(ao_ver_string, sizeof(ao_ver_string) - 1, 1, stderr);\n        return FAILURE;\n    }\n\n    /*\n     *  If the program name hasn't been set, then set the name and the path\n     *  and the set of equivalent characters.\n     */\n    if (opts->pzProgName == NULL) {\n        char const *  pz = strrchr(pname, DIRCH);\n        char const ** pp =\n            (char const **)(void **)&(opts->pzProgName);\n\n        if (pz != NULL)\n            *pp = pz+1;\n        else\n            *pp = pname;\n\n        pz = pathfind(getenv(\"PATH\"), (char *)pname, \"rx\");\n        if (pz != NULL)\n            pname = VOIDP(pz);\n\n        pp  = (char const **)VOIDP(&(opts->pzProgPath));\n        *pp = pname;\n\n        /*\n         *  when comparing long names, these are equivalent\n         */\n        strequate(zSepChars);\n    }\n\n    return SUCCESS;\n}",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "LOCAL",
        "tSuccess",
        "tSuccess"
      ]
    },
    "immediate_opts": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "LOCAL tSuccess\nimmediate_opts(tOptions * opts)\n{\n    tSuccess  res;\n\n    opts->fOptSet  |= OPTPROC_IMMEDIATE;\n    opts->curOptIdx = 1;     /* start by skipping program name */\n    opts->pzCurOpt  = NULL;\n\n    /*\n     *  Examine all the options from the start.  We process any options that\n     *  are marked for immediate processing.\n     */\n    for (;;) {\n        tOptState opt_st = OPTSTATE_INITIALIZER(PRESET);\n\n        res = next_opt(opts, &opt_st);\n        switch (res) {\n        case FAILURE: goto   failed_option;\n        case PROBLEM: res = SUCCESS; goto leave;\n        case SUCCESS: break;\n        }\n\n        /*\n         *  IF this is an immediate-attribute option, then do it.\n         */\n        if (! DO_IMMEDIATELY(opt_st.flags))\n            continue;\n\n        if (! SUCCESSFUL(handle_opt(opts, &opt_st)))\n            break;\n    } failed_option:;\n\n    if ((opts->fOptSet & OPTPROC_ERRSTOP) != 0)\n        (*opts->pUsageProc)(opts, EXIT_FAILURE);\n\n leave:\n\n    opts->fOptSet &= ~OPTPROC_IMMEDIATE;\n    return res;\n}",
      "lines": 41,
      "depth": 13,
      "decorators": [
        "LOCAL",
        "tSuccess",
        "tSuccess"
      ]
    },
    "do_presets": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        240,
        1
      ],
      "content": "static tSuccess\ndo_presets(tOptions * opts)\n{\n    tOptDesc * od = NULL;\n\n    if (! SUCCESSFUL(immediate_opts(opts)))\n        return FAILURE;\n\n    /*\n     *  IF this option set has a --save-opts option, then it also\n     *  has a --load-opts option.  See if a command line option has disabled\n     *  option presetting.\n     */\n    if (  (opts->specOptIdx.save_opts != NO_EQUIVALENT)\n       && (opts->specOptIdx.save_opts != 0)) {\n        od = opts->pOptDesc + opts->specOptIdx.save_opts + 1;\n        if (DISABLED_OPT(od))\n            return SUCCESS;\n    }\n\n    /*\n     *  Until we return from this procedure, disable non-presettable opts\n     */\n    opts->fOptSet |= OPTPROC_PRESETTING;\n    /*\n     *  IF there are no config files,\n     *  THEN do any environment presets and leave.\n     */\n    if (opts->papzHomeList == NULL) {\n        env_presets(opts, ENV_ALL);\n    }\n    else {\n        env_presets(opts, ENV_IMM);\n\n        /*\n         *  Check to see if environment variables have disabled presetting.\n         */\n        if ((od != NULL) && ! DISABLED_OPT(od))\n            intern_file_load(opts);\n\n        /*\n         *  ${PROGRAM_LOAD_OPTS} value of \"no\" cannot disable other environment\n         *  variable options.  Only the loading of .rc files.\n         */\n        env_presets(opts, ENV_NON_IMM);\n    }\n    opts->fOptSet &= ~OPTPROC_PRESETTING;\n\n    return SUCCESS;\n}",
      "lines": 50,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "tSuccess"
      ]
    },
    "ao_initialize": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "LOCAL bool\nao_initialize(tOptions * opts, int a_ct, char ** a_v)\n{\n    if ((opts->fOptSet & OPTPROC_INITDONE) != 0)\n        return true;\n\n    opts->origArgCt   = (unsigned int)a_ct;\n    opts->origArgVect = a_v;\n    opts->fOptSet    |= OPTPROC_INITDONE;\n\n    if (HAS_pzPkgDataDir(opts))\n        program_pkgdatadir = opts->pzPkgDataDir;\n\n    if (! SUCCESSFUL(do_presets(opts)))\n        return false;\n\n    /*\n     *  IF option name conversion was suppressed but it is not suppressed\n     *  for the command line, then it's time to translate option names.\n     *  Usage text will not get retranslated.\n     */\n    if (  ((opts->fOptSet & OPTPROC_TRANSLATE) != 0)\n       && (opts->pTransProc != NULL)\n       && ((opts->fOptSet & OPTPROC_NO_XLAT_MASK) == OPTPROC_NXLAT_OPT_CFG)\n       )  {\n        opts->fOptSet &= ~OPTPROC_NXLAT_OPT_CFG;\n        (*opts->pTransProc)();\n    }\n\n    if ((opts->fOptSet & OPTPROC_REORDER) != 0)\n        optionSort(opts);\n\n    opts->curOptIdx   = 1;\n    opts->pzCurOpt    = NULL;\n    return true;\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "LOCAL",
        "bool",
        "bool"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/intprops.h": {},
  "sharutils/sharutils-4.15.2/libopts/libopts.c": {},
  "sharutils/sharutils-4.15.2/libopts/load.c": {
    "get_realpath": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "static bool\nget_realpath(char * buf, size_t b_sz)\n{\n#if defined(HAVE_CANONICALIZE_FILE_NAME)\n    {\n        size_t name_len;\n\n        char * pz = canonicalize_file_name(buf);\n        if (pz == NULL)\n            return false;\n\n        name_len = strlen(pz);\n        if (name_len >= (size_t)b_sz) {\n            free(pz);\n            return false;\n        }\n\n        memcpy(buf, pz, name_len + 1);\n        free(pz);\n    }\n\n#elif defined(HAVE_REALPATH)\n    {\n        size_t name_len;\n        char z[PATH_MAX+1];\n\n        if (realpath(buf, z) == NULL)\n            return false;\n\n        name_len = strlen(z);\n        if (name_len >= b_sz)\n            return false;\n\n        memcpy(buf, z, name_len + 1);\n    }\n#endif\n    return true;\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "optionMakePath": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "bool\noptionMakePath(char * p_buf, int b_sz, char const * fname, char const * prg_path)\n{\n    {\n        size_t len = strlen(fname);\n\n        if (((size_t)b_sz <= len) || (len == 0))\n            return false;\n    }\n\n    /*\n     *  IF not an environment variable, just copy the data\n     */\n    if (*fname != '$') {\n        char   const * src = fname;\n        char * dst = p_buf;\n        int    ct  = b_sz;\n\n        for (;;) {\n            if ( (*(dst++) = *(src++)) == NUL)\n                break;\n            if (--ct <= 0)\n                return false;\n        }\n    }\n\n    /*\n     *  IF the name starts with \"$$\", then it must be \"$$\" or\n     *  it must start with \"$$/\".  In either event, replace the \"$$\"\n     *  with the path to the executable and append a \"/\" character.\n     */\n    else switch (fname[1]) {\n    case NUL:\n        return false;\n\n    case '$':\n        if (! add_prog_path(p_buf, b_sz, fname, prg_path))\n            return false;\n        break;\n\n    case '@':\n        if (program_pkgdatadir[0] == NUL)\n            return false;\n\n        if (snprintf(p_buf, (size_t)b_sz, \"%s%s\",\n                     program_pkgdatadir, fname + 2) >= b_sz)\n            return false;\n        break;\n\n    default:\n        if (! add_env_val(p_buf, b_sz, fname))\n            return false;\n    }\n\n    return get_realpath(p_buf, b_sz);\n}",
      "lines": 56,
      "depth": 15,
      "decorators": [
        "bool"
      ]
    },
    "add_prog_path": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "static bool\nadd_prog_path(char * buf, int b_sz, char const * fname, char const * prg_path)\n{\n    char const *   path;\n    char const *   pz;\n    int     skip = 2;\n\n    switch (fname[2]) {\n    case DIRCH:\n        skip = 3;\n    case NUL:\n        break;\n    default:\n        return false;\n    }\n\n    /*\n     *  See if the path is included in the program name.\n     *  If it is, we're done.  Otherwise, we have to hunt\n     *  for the program using \"pathfind\".\n     */\n    if (strchr(prg_path, DIRCH) != NULL)\n        path = prg_path;\n    else {\n        path = pathfind(getenv(\"PATH\"), (char *)prg_path, \"rx\");\n\n        if (path == NULL)\n            return false;\n    }\n\n    pz = strrchr(path, DIRCH);\n\n    /*\n     *  IF we cannot find a directory name separator,\n     *  THEN we do not have a path name to our executable file.\n     */\n    if (pz == NULL)\n        return false;\n\n    fname += skip;\n\n    /*\n     *  Concatenate the file name to the end of the executable path.\n     *  The result may be either a file or a directory.\n     */\n    if ((unsigned)(pz - path) + 1 + strlen(fname) >= (unsigned)b_sz)\n        return false;\n\n    memcpy(buf, path, (size_t)((pz - path)+1));\n    strcpy(buf + (pz - path) + 1, fname);\n\n    /*\n     *  If the \"path\" path was gotten from \"pathfind()\", then it was\n     *  allocated and we need to deallocate it.\n     */\n    if (path != prg_path)\n        AGFREE(path);\n    return true;\n}",
      "lines": 59,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "add_env_val": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        296,
        1
      ],
      "content": "static bool\nadd_env_val(char * buf, int buf_sz, char const * name)\n{\n    char * dir_part = buf;\n\n    for (;;) {\n        int ch = (int)*++name;\n        if (! IS_VALUE_NAME_CHAR(ch))\n            break;\n        *(dir_part++) = (char)ch;\n    }\n\n    if (dir_part == buf)\n        return false;\n\n    *dir_part = NUL;\n\n    dir_part = getenv(buf);\n\n    /*\n     *  Environment value not found -- skip the home list entry\n     */\n    if (dir_part == NULL)\n        return false;\n\n    if (strlen(dir_part) + 1 + strlen(name) >= (unsigned)buf_sz)\n        return false;\n\n    sprintf(buf, \"%s%s\", dir_part, name);\n    return true;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "munge_str": {
      "start_point": [
        306,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "LOCAL void\nmunge_str(char * txt, tOptionLoadMode mode)\n{\n    char * pzE;\n\n    if (mode == OPTION_LOAD_KEEP)\n        return;\n\n    if (IS_WHITESPACE_CHAR(*txt)) {\n        char * src = SPN_WHITESPACE_CHARS(txt+1);\n        size_t l   = strlen(src) + 1;\n        memmove(txt, src, l);\n        pzE = txt + l - 1;\n\n    } else\n        pzE = txt + strlen(txt);\n\n    pzE  = SPN_WHITESPACE_BACK(txt, pzE);\n    *pzE = NUL;\n\n    if (mode == OPTION_LOAD_UNCOOKED)\n        return;\n\n    switch (*txt) {\n    default: return;\n    case '\"':\n    case '\\'': break;\n    }\n\n    switch (pzE[-1]) {\n    default: return;\n    case '\"':\n    case '\\'': break;\n    }\n\n    (void)ao_string_cook(txt, NULL);\n}",
      "lines": 37,
      "depth": 10,
      "decorators": [
        "LOCAL",
        "void",
        "void"
      ]
    },
    "assemble_arg_val": {
      "start_point": [
        344,
        0
      ],
      "end_point": [
        379,
        1
      ],
      "content": "static char *\nassemble_arg_val(char * txt, tOptionLoadMode mode)\n{\n    char * end = strpbrk(txt, ARG_BREAK_STR);\n    int    space_break;\n\n    /*\n     *  Not having an argument to a configurable name is okay.\n     */\n    if (end == NULL)\n        return txt + strlen(txt);\n\n    /*\n     *  If we are keeping all whitespace, then the  modevalue starts with the\n     *  character that follows the end of the configurable name, regardless\n     *  of which character caused it.\n     */\n    if (mode == OPTION_LOAD_KEEP) {\n        *(end++) = NUL;\n        return end;\n    }\n\n    /*\n     *  If the name ended on a white space character, remember that\n     *  because we'll have to skip over an immediately following ':' or '='\n     *  (and the white space following *that*).\n     */\n    space_break = IS_WHITESPACE_CHAR(*end);\n    *(end++) = NUL;\n\n    end = SPN_WHITESPACE_CHARS(end);\n    if (space_break && ((*end == ':') || (*end == '=')))\n        end = SPN_WHITESPACE_CHARS(end+1);\n\n    return end;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nassemble_arg_val(char * txt, tOptionLoadMode mode)",
        "*"
      ]
    },
    "trim_quotes": {
      "start_point": [
        381,
        0
      ],
      "end_point": [
        390,
        1
      ],
      "content": "static char *\ntrim_quotes(char * arg)\n{\n    switch (*arg) {\n    case '\"':\n    case '\\'':\n        ao_string_cook(arg, NULL);\n    }\n    return arg;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ntrim_quotes(char * arg)",
        "*"
      ]
    },
    "direction_ok": {
      "start_point": [
        396,
        0
      ],
      "end_point": [
        464,
        1
      ],
      "content": "static bool\ndirection_ok(opt_state_mask_t f, int dir)\n{\n    if (dir == 0)\n        return true;\n\n    switch (f & (OPTST_IMM|OPTST_DISABLE_IMM)) {\n    case 0:\n        /*\n         *  The selected option has no immediate action.\n         *  THEREFORE, if the direction is PRESETTING\n         *  THEN we skip this option.\n         */\n        if (PRESETTING(dir))\n            return false;\n        break;\n\n    case OPTST_IMM:\n        if (PRESETTING(dir)) {\n            /*\n             *  We are in the presetting direction with an option we handle\n             *  immediately for enablement, but normally for disablement.\n             *  Therefore, skip if disabled.\n             */\n            if ((f & OPTST_DISABLED) == 0)\n                return false;\n        } else {\n            /*\n             *  We are in the processing direction with an option we handle\n             *  immediately for enablement, but normally for disablement.\n             *  Therefore, skip if NOT disabled.\n             */\n            if ((f & OPTST_DISABLED) != 0)\n                return false;\n        }\n        break;\n\n    case OPTST_DISABLE_IMM:\n        if (PRESETTING(dir)) {\n            /*\n             *  We are in the presetting direction with an option we handle\n             *  immediately for disablement, but normally for disablement.\n             *  Therefore, skip if NOT disabled.\n             */\n            if ((f & OPTST_DISABLED) != 0)\n                return false;\n        } else {\n            /*\n             *  We are in the processing direction with an option we handle\n             *  immediately for disablement, but normally for disablement.\n             *  Therefore, skip if disabled.\n             */\n            if ((f & OPTST_DISABLED) == 0)\n                return false;\n        }\n        break;\n\n    case OPTST_IMM|OPTST_DISABLE_IMM:\n        /*\n         *  The selected option is always for immediate action.\n         *  THEREFORE, if the direction is PROCESSING\n         *  THEN we skip this option.\n         */\n        if (PROCESSING(dir))\n            return false;\n        break;\n    }\n    return true;\n}",
      "lines": 69,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "load_opt_line": {
      "start_point": [
        478,
        0
      ],
      "end_point": [
        540,
        1
      ],
      "content": "LOCAL void\nload_opt_line(tOptions * opts, tOptState * opt_state, char * line,\n              tDirection direction, tOptionLoadMode load_mode )\n{\n    /*\n     * When parsing a stored line, we only look at the characters after\n     * a hyphen.  Long names must always be at least two characters and\n     * short options are always exactly one character long.\n     */\n    line = SPN_LOAD_LINE_SKIP_CHARS(line);\n\n    {\n        char * arg = assemble_arg_val(line, load_mode);\n\n        if (IS_OPTION_NAME_CHAR(line[1])) {\n\n            if (! SUCCESSFUL(opt_find_long(opts, line, opt_state)))\n                return;\n\n        } else if (! SUCCESSFUL(opt_find_short(opts, *line, opt_state)))\n            return;\n\n        if ((! CALLED(direction)) && (opt_state->flags & OPTST_NO_INIT))\n            return;\n\n        opt_state->pzOptArg = trim_quotes(arg);\n    }\n\n    if (! direction_ok(opt_state->flags, direction))\n        return;\n\n    /*\n     *  Fix up the args.\n     */\n    if (OPTST_GET_ARGTYPE(opt_state->pOD->fOptState) == OPARG_TYPE_NONE) {\n        if (*opt_state->pzOptArg != NUL)\n            return;\n        opt_state->pzOptArg = NULL;\n\n    } else if (opt_state->pOD->fOptState & OPTST_ARG_OPTIONAL) {\n        if (*opt_state->pzOptArg == NUL)\n             opt_state->pzOptArg = NULL;\n        else {\n            AGDUPSTR(opt_state->pzOptArg, opt_state->pzOptArg, \"opt arg\");\n            opt_state->flags |= OPTST_ALLOC_ARG;\n        }\n\n    } else {\n        if (*opt_state->pzOptArg == NUL)\n             opt_state->pzOptArg = zNil;\n        else {\n            AGDUPSTR(opt_state->pzOptArg, opt_state->pzOptArg, \"opt arg\");\n            opt_state->flags |= OPTST_ALLOC_ARG;\n        }\n    }\n\n    {\n        tOptionLoadMode sv = option_load_mode;\n        option_load_mode = load_mode;\n        handle_opt(opts, opt_state);\n        option_load_mode = sv;\n    }\n}",
      "lines": 63,
      "depth": 13,
      "decorators": [
        "LOCAL",
        "void",
        "void"
      ]
    },
    "optionLoadLine": {
      "start_point": [
        568,
        0
      ],
      "end_point": [
        579,
        1
      ],
      "content": "void\noptionLoadLine(tOptions * opts, char const * line)\n{\n    tOptState st = OPTSTATE_INITIALIZER(SET);\n    char *    pz;\n    proc_state_mask_t sv_flags = opts->fOptSet;\n    opts->fOptSet &= ~OPTPROC_ERRSTOP;\n    AGDUPSTR(pz, line, \"opt line\");\n    load_opt_line(opts, &st, pz, DIRECTION_CALLED, OPTION_LOAD_COOKED);\n    AGFREE(pz);\n    opts->fOptSet = sv_flags;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/makeshell.c": {
    "to_uchar": {
      "start_point": [
        32,
        1
      ],
      "end_point": [
        32,
        62
      ],
      "content": "static inline unsigned char to_uchar (char ch) { return ch; }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "option_exits": {
      "start_point": [
        75,
        15
      ],
      "end_point": [
        81,
        1
      ],
      "content": "void\noption_exits(int exit_code)\n{\n    if (print_exit)\n        printf(\"\\nexit %d\\n\", exit_code);\n    exit(exit_code);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ao_bug": {
      "start_point": [
        83,
        15
      ],
      "end_point": [
        88,
        1
      ],
      "content": "void\nao_bug(char const * msg)\n{\n    fprintf(stderr, zao_bug_msg, msg);\n    option_exits(EX_SOFTWARE);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "fserr_warn": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "LOCAL void\nfserr_warn(char const * prog, char const * op, char const * fname)\n{\n    fprintf(stderr, zfserr_fmt, prog, errno, strerror(errno),\n            op, fname);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "LOCAL",
        "void",
        "void"
      ]
    },
    "fserr_exit": {
      "start_point": [
        97,
        15
      ],
      "end_point": [
        102,
        1
      ],
      "content": "void\nfserr_exit(char const * prog, char const * op, char const * fname)\n{\n    fserr_warn(prog, op, fname);\n    option_exits(EXIT_FAILURE);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "optionParseShell": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "void\noptionParseShell(tOptions * opts)\n{\n    /*\n     *  Check for our SHELL option now.\n     *  IF the output file contains the \"#!\" magic marker,\n     *  it will override anything we do here.\n     */\n    if (HAVE_GENSHELL_OPT(SHELL))\n        shell_prog = GENSHELL_OPT_ARG(SHELL);\n\n    else if (! ENABLED_GENSHELL_OPT(SHELL))\n        shell_prog = NULL;\n\n    else if ((shell_prog = getenv(\"SHELL\")),\n             shell_prog == NULL)\n\n        shell_prog = POSIX_SHELL;\n\n    /*\n     *  Check for a specified output file\n     */\n    if (HAVE_GENSHELL_OPT(SCRIPT))\n        open_out(GENSHELL_OPT_ARG(SCRIPT), opts->pzProgName);\n    \n    emit_usage(opts);\n    emit_setup(opts);\n\n    /*\n     *  There are four modes of option processing.\n     */\n    switch (opts->fOptSet & (OPTPROC_LONGOPT|OPTPROC_SHORTOPT)) {\n    case OPTPROC_LONGOPT:\n        fputs(LOOP_STR,         stdout);\n\n        fputs(LONG_OPT_MARK,    stdout);\n        fputs(INIT_LOPT_STR,    stdout);\n        emit_long(opts);\n        printf(LOPT_ARG_FMT,    opts->pzPROGNAME);\n        fputs(END_OPT_SEL_STR,  stdout);\n\n        fputs(NOT_FOUND_STR,    stdout);\n        break;\n\n    case 0:\n        fputs(ONLY_OPTS_LOOP,   stdout);\n        fputs(INIT_LOPT_STR,    stdout);\n        emit_long(opts);\n        printf(LOPT_ARG_FMT,    opts->pzPROGNAME);\n        break;\n\n    case OPTPROC_SHORTOPT:\n        fputs(LOOP_STR,         stdout);\n\n        fputs(FLAG_OPT_MARK,    stdout);\n        fputs(INIT_OPT_STR,     stdout);\n        emit_flag(opts);\n        printf(OPT_ARG_FMT,     opts->pzPROGNAME);\n        fputs(END_OPT_SEL_STR,  stdout);\n\n        fputs(NOT_FOUND_STR,    stdout);\n        break;\n\n    case OPTPROC_LONGOPT|OPTPROC_SHORTOPT:\n        fputs(LOOP_STR,         stdout);\n\n        fputs(LONG_OPT_MARK,    stdout);\n        fputs(INIT_LOPT_STR,    stdout);\n        emit_long(opts);\n        printf(LOPT_ARG_FMT,    opts->pzPROGNAME);\n        fputs(END_OPT_SEL_STR,  stdout);\n\n        fputs(FLAG_OPT_MARK,    stdout);\n        fputs(INIT_OPT_STR,     stdout);\n        emit_flag(opts);\n        printf(OPT_ARG_FMT,     opts->pzPROGNAME);\n        fputs(END_OPT_SEL_STR,  stdout);\n\n        fputs(NOT_FOUND_STR,    stdout);\n        break;\n    }\n\n    emit_wrapup(opts);\n    if ((script_trailer != NULL) && (*script_trailer != NUL))\n        fputs(script_trailer, stdout);\n    else if (ENABLED_GENSHELL_OPT(SHELL))\n        printf(SHOW_PROG_ENV, opts->pzPROGNAME);\n\n#ifdef HAVE_FCHMOD\n    fchmod(STDOUT_FILENO, 0755);\n#endif\n    fclose(stdout);\n\n    if (ferror(stdout))\n        fserr_exit(opts->pzProgName, zwriting, zstdout_name);\n\n    AGFREE(script_text);\n    script_leader    = NULL;\n    script_trailer   = NULL;\n    script_text      = NULL;\n}",
      "lines": 101,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "emit_var_text": {
      "start_point": [
        228,
        0
      ],
      "end_point": [
        272,
        1
      ],
      "content": "static void\nemit_var_text(char const * prog, char const * var, int fdin)\n{\n    FILE * fp   = fdopen(fdin, \"r\" FOPEN_BINARY_FLAG);\n    int    nlct = 0; /* defer newlines and skip trailing ones */\n\n    printf(SET_TEXT_FMT, prog, var);\n    if (fp == NULL)\n        goto skip_text;\n\n    for (;;) {\n        int  ch = fgetc(fp);\n        switch (ch) {\n\n        case NL:\n            nlct++;\n            break;\n\n        case '\\'':\n            while (nlct > 0) {\n                fputc(NL, stdout);\n                nlct--;\n            }\n            fputs(apostrophe, stdout);\n            break;\n\n        case EOF:\n            goto done;\n\n        default:\n            while (nlct > 0) {\n                fputc(NL, stdout);\n                nlct--;\n            }\n            fputc(ch, stdout);\n            break;\n        }\n    } done:;\n\n    fclose(fp);\n\n skip_text:\n\n    fputs(END_SET_TEXT, stdout);\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "text_to_var": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        351,
        1
      ],
      "content": "static void\ntext_to_var(tOptions * opts, teTextTo which, tOptDesc * od)\n{\n#   define _TT_(n) static char const z ## n [] = #n;\n    TEXTTO_TABLE\n#   undef _TT_\n#   define _TT_(n) z ## n ,\n      static char const * ttnames[] = { TEXTTO_TABLE };\n#   undef _TT_\n\n#if ! defined(HAVE_WORKING_FORK)\n    printf(SET_NO_TEXT_FMT, opts->pzPROGNAME, ttnames[which]);\n#else\n    int  fdpair[2];\n\n    fflush(stdout);\n    fflush(stderr);\n\n    if (pipe(fdpair) != 0)\n        fserr_exit(opts->pzProgName, \"pipe\", zinter_proc_pipe);\n\n    switch (fork()) {\n    case -1:\n        fserr_exit(opts->pzProgName, \"fork\", opts->pzProgName);\n        /* NOTREACHED */\n\n    case 0:\n        /*\n         * Send both stderr and stdout to the pipe.  No matter which\n         * descriptor is used, we capture the output on the read end.\n         */\n        dup2(fdpair[1], STDERR_FILENO);\n        dup2(fdpair[1], STDOUT_FILENO);\n        close(fdpair[0]);\n\n        switch (which) {\n        case TT_LONGUSAGE:\n            (*(opts->pUsageProc))(opts, EXIT_SUCCESS);\n            /* NOTREACHED */\n\n        case TT_USAGE:\n            (*(opts->pUsageProc))(opts, EXIT_FAILURE);\n            /* NOTREACHED */\n\n        case TT_VERSION:\n            if (od->fOptState & OPTST_ALLOC_ARG) {\n                AGFREE(od->optArg.argString);\n                od->fOptState &= ~OPTST_ALLOC_ARG;\n            }\n            od->optArg.argString = \"c\";\n            optionPrintVersion(opts, od);\n            /* NOTREACHED */\n\n        default:\n            option_exits(EXIT_FAILURE);\n            /* NOTREACHED */\n        }\n        /* NOTREACHED */\n\n    default:\n        close(fdpair[1]);\n    }\n\n    emit_var_text(opts->pzPROGNAME, ttnames[which], fdpair[0]);\n#endif\n}",
      "lines": 66,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "emit_usage": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        431,
        1
      ],
      "content": "static void\nemit_usage(tOptions * opts)\n{\n    char tm_nm_buf[AO_NAME_SIZE];\n\n    /*\n     *  First, switch stdout to the output file name.\n     *  Then, change the program name to the one defined\n     *  by the definitions (rather than the current\n     *  executable name).  Down case the upper cased name.\n     */\n    if (script_leader != NULL)\n        fputs(script_leader, stdout);\n\n    {\n        char const * out_nm;\n\n        {\n            time_t    c_tim = time(NULL);\n            struct tm * ptm = localtime(&c_tim);\n            strftime(tm_nm_buf, AO_NAME_SIZE, TIME_FMT, ptm );\n        }\n\n        if (HAVE_GENSHELL_OPT(SCRIPT))\n             out_nm = GENSHELL_OPT_ARG(SCRIPT);\n        else out_nm = STDOUT;\n\n        if ((script_leader == NULL) && (shell_prog != NULL))\n            printf(SHELL_MAGIC, shell_prog);\n\n        printf(PREAMBLE_FMT, START_MARK, out_nm, tm_nm_buf);\n    }\n\n    printf(END_PRE_FMT, opts->pzPROGNAME);\n\n    /*\n     *  Get a copy of the original program name in lower case and\n     *  fill in an approximation of the program name from it.\n     */\n    {\n        char *       pzPN = tm_nm_buf;\n        char const * pz   = opts->pzPROGNAME;\n        char **      pp;\n\n        /* Copy the program name into the time/name buffer */\n        for (;;) {\n            if ((*pzPN++ = (char)tolower(*pz++)) == NUL)\n                break;\n        }\n\n        pp  = VOIDP(&(opts->pzProgPath));\n        *pp = tm_nm_buf;\n        pp  = VOIDP(&(opts->pzProgName));\n        *pp = tm_nm_buf;\n    }\n\n    text_to_var(opts, TT_LONGUSAGE, NULL);\n    text_to_var(opts, TT_USAGE,     NULL);\n\n    {\n        tOptDesc * pOptDesc = opts->pOptDesc;\n        int        optionCt = opts->optCt;\n\n        for (;;) {\n            if (pOptDesc->pOptProc == optionPrintVersion) {\n                text_to_var(opts, TT_VERSION, pOptDesc);\n                break;\n            }\n\n            if (--optionCt <= 0)\n                break;\n            pOptDesc++;\n        }\n    }\n}",
      "lines": 75,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "emit_wrapup": {
      "start_point": [
        433,
        0
      ],
      "end_point": [
        465,
        1
      ],
      "content": "static void\nemit_wrapup(tOptions * opts)\n{\n    tOptDesc *   od     = opts->pOptDesc;\n    int          opt_ct = opts->presetOptCt;\n    char const * fmt;\n\n    printf(FINISH_LOOP, opts->pzPROGNAME);\n    for (;opt_ct > 0; od++, --opt_ct) {\n        /*\n         *  Options that are either usage documentation or are compiled out\n         *  are not to be processed.\n         */\n        if (SKIP_OPT(od) || (od->pz_NAME == NULL))\n            continue;\n\n        /*\n         *  do not presence check if there is no minimum/must-set\n         */\n        if ((od->optMinCt == 0) && ((od->fOptState & OPTST_MUST_SET) == 0))\n            continue;\n\n        if (od->optMaxCt > 1)\n             fmt = CHK_MIN_COUNT;\n        else fmt = CHK_ONE_REQUIRED;\n\n        {\n            int min = (od->optMinCt == 0) ? 1 : od->optMinCt;\n            printf(fmt, opts->pzPROGNAME, od->pz_NAME, min);\n        }\n    }\n    fputs(END_MARK, stdout);\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "emit_setup": {
      "start_point": [
        467,
        0
      ],
      "end_point": [
        530,
        1
      ],
      "content": "static void\nemit_setup(tOptions * opts)\n{\n    tOptDesc *   od     = opts->pOptDesc;\n    int          opt_ct = opts->presetOptCt;\n    char const * fmt;\n    char const * def_val;\n\n    for (;opt_ct > 0; od++, --opt_ct) {\n        char int_val_buf[32];\n\n        /*\n         *  Options that are either usage documentation or are compiled out\n         *  are not to be processed.\n         */\n        if (SKIP_OPT(od) || (od->pz_NAME == NULL))\n            continue;\n\n        if (od->optMaxCt > 1)\n             fmt = MULTI_DEF_FMT;\n        else fmt = SGL_DEF_FMT;\n\n        /*\n         *  IF this is an enumeration/bitmask option, then convert the value\n         *  to a string before printing the default value.\n         */\n        switch (OPTST_GET_ARGTYPE(od->fOptState)) {\n        case OPARG_TYPE_ENUMERATION:\n            (*(od->pOptProc))(OPTPROC_EMIT_SHELL, od );\n            def_val = od->optArg.argString;\n            break;\n\n        /*\n         *  Numeric and membership bit options are just printed as a number.\n         */\n        case OPARG_TYPE_NUMERIC:\n            snprintf(int_val_buf, sizeof(int_val_buf), \"%d\",\n                     (int)od->optArg.argInt);\n            def_val = int_val_buf;\n            break;\n\n        case OPARG_TYPE_MEMBERSHIP:\n            snprintf(int_val_buf, sizeof(int_val_buf), \"%lu\",\n                     (unsigned long)od->optArg.argIntptr);\n            def_val = int_val_buf;\n            break;\n\n        case OPARG_TYPE_BOOLEAN:\n            def_val = (od->optArg.argBool) ? TRUE_STR : FALSE_STR;\n            break;\n\n        default:\n            if (od->optArg.argString == NULL) {\n                if (fmt == SGL_DEF_FMT)\n                    fmt = SGL_NO_DEF_FMT;\n                def_val = NULL;\n            }\n            else\n                def_val = od->optArg.argString;\n        }\n\n        printf(fmt, opts->pzPROGNAME, od->pz_NAME, def_val);\n    }\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "emit_action": {
      "start_point": [
        532,
        0
      ],
      "end_point": [
        580,
        1
      ],
      "content": "static void\nemit_action(tOptions * opts, tOptDesc * od)\n{\n    if (od->pOptProc == optionPrintVersion)\n        printf(ECHO_N_EXIT, opts->pzPROGNAME, VER_STR);\n\n    else if (od->pOptProc == optionPagedUsage)\n        printf(PAGE_USAGE_TEXT, opts->pzPROGNAME);\n\n    else if (od->pOptProc == optionLoadOpt) {\n        printf(LVL3_CMD, NO_LOAD_WARN);\n        printf(LVL3_CMD, YES_NEED_OPT_ARG);\n\n    } else if (od->pz_NAME == NULL) {\n\n        if (od->pOptProc == NULL) {\n            printf(LVL3_CMD, NO_SAVE_OPTS);\n            printf(LVL3_CMD, OK_NEED_OPT_ARG);\n        } else\n            printf(ECHO_N_EXIT, opts->pzPROGNAME, LONG_USE_STR);\n\n    } else {\n        if (od->optMaxCt == 1)\n            printf(SGL_ARG_FMT, opts->pzPROGNAME, od->pz_NAME);\n        else {\n            if ((unsigned)od->optMaxCt < NOLIMIT)\n                printf(CHK_MAX_COUNT, opts->pzPROGNAME,\n                       od->pz_NAME, od->optMaxCt);\n\n            printf(MULTI_ARG_FMT, opts->pzPROGNAME, od->pz_NAME);\n        }\n\n        /*\n         *  Fix up the args.\n         */\n        if (OPTST_GET_ARGTYPE(od->fOptState) == OPARG_TYPE_NONE) {\n            printf(SET_MULTI_ARG, opts->pzPROGNAME, od->pz_NAME);\n            printf(LVL3_CMD, NO_ARG_NEEDED);\n\n        } else if (od->fOptState & OPTST_ARG_OPTIONAL) {\n            printf(SET_MULTI_ARG,  opts->pzPROGNAME, od->pz_NAME);\n            printf(LVL3_CMD, OK_NEED_OPT_ARG);\n\n        } else {\n            printf(LVL3_CMD, YES_NEED_OPT_ARG);\n        }\n    }\n    fputs(zOptionEndSelect, stdout);\n}",
      "lines": 49,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "emit_inaction": {
      "start_point": [
        582,
        0
      ],
      "end_point": [
        597,
        1
      ],
      "content": "static void\nemit_inaction(tOptions * opts, tOptDesc * od)\n{\n    if (od->pOptProc == optionLoadOpt) {\n        printf(LVL3_CMD, NO_SUPPRESS_LOAD);\n\n    } else if (od->optMaxCt == 1)\n        printf(NO_SGL_ARG_FMT, opts->pzPROGNAME,\n               od->pz_NAME, od->pz_DisablePfx);\n    else\n        printf(NO_MULTI_ARG_FMT, opts->pzPROGNAME,\n               od->pz_NAME, od->pz_DisablePfx);\n\n    printf(LVL3_CMD, NO_ARG_NEEDED);\n    fputs(zOptionEndSelect, stdout);\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "emit_flag": {
      "start_point": [
        605,
        0
      ],
      "end_point": [
        622,
        1
      ],
      "content": "static void\nemit_flag(tOptions * opts)\n{\n    tOptDesc * od = opts->pOptDesc;\n    int        opt_ct = opts->optCt;\n\n    fputs(zOptionCase, stdout);\n\n    for (;opt_ct > 0; od++, --opt_ct) {\n\n        if (SKIP_OPT(od) || ! IS_GRAPHIC_CHAR(od->optValue))\n            continue;\n\n        printf(zOptionFlag, od->optValue);\n        emit_action(opts, od);\n    }\n    printf(UNK_OPT_FMT, FLAG_STR, opts->pzPROGNAME);\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "emit_match_expr": {
      "start_point": [
        632,
        0
      ],
      "end_point": [
        704,
        1
      ],
      "content": "static void\nemit_match_expr(char const * name, tOptDesc * cod, tOptions * opts)\n{\n    char name_bf[32];\n    unsigned int    min_match_ct = 2;\n    unsigned int    max_match_ct = strlen(name) - 1;\n\n    if (max_match_ct >= sizeof(name_bf) - 1)\n        goto leave;\n    \n    {\n        tOptDesc *  od = opts->pOptDesc;\n        int         ct = opts->optCt;\n\n        for (; ct-- > 0; od++) {\n            unsigned int match_ct = 0;\n\n            /*\n             *  Omit the current option, Doc opts and compiled out opts.\n             */\n            if ((od == cod) || SKIP_OPT(od))\n                continue;\n\n            /*\n             *  Check each character of the name case insensitively.\n             *  They must not be the same.  They cannot be, because it would\n             *  not compile correctly if they were.\n             */\n            while (UPPER(od->pz_Name[match_ct]) == UPPER(name[match_ct]))\n                match_ct++;\n\n            if (match_ct > min_match_ct)\n                min_match_ct = match_ct;\n\n            /*\n             *  Check the disablement name, too.\n             */\n            if (od->pz_DisableName == NULL)\n                continue;\n\n            match_ct = 0;\n            while (  toupper(od->pz_DisableName[match_ct])\n                  == toupper(name[match_ct]))\n                match_ct++;\n            if (match_ct > min_match_ct)\n                min_match_ct = match_ct;\n        }\n    }\n\n    /*\n     *  Don't bother emitting partial matches if there is only one possible\n     *  partial match.\n     */\n    if (min_match_ct < max_match_ct) {\n        char *  pz    = name_bf + min_match_ct;\n        int     nm_ix = min_match_ct;\n\n        memcpy(name_bf, name, min_match_ct);\n\n        for (;;) {\n            *pz = NUL;\n            printf(zOptionPartName, name_bf);\n            *pz++ = name[nm_ix++];\n            if (name[nm_ix] == NUL) {\n                *pz = NUL;\n                break;\n            }\n        }\n    }\n\nleave:\n    printf(zOptionFullName, name);\n}",
      "lines": 73,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "emit_long": {
      "start_point": [
        711,
        0
      ],
      "end_point": [
        742,
        1
      ],
      "content": "static void\nemit_long(tOptions * opts)\n{\n    tOptDesc * od = opts->pOptDesc;\n    int        ct  = opts->optCt;\n\n    fputs(zOptionCase, stdout);\n\n    /*\n     *  do each option, ...\n     */\n    do  {\n        /*\n         *  Documentation & compiled-out options\n         */\n        if (SKIP_OPT(od))\n            continue;\n\n        emit_match_expr(od->pz_Name, od, opts);\n        emit_action(opts, od);\n\n        /*\n         *  Now, do the same thing for the disablement version of the option.\n         */\n        if (od->pz_DisableName != NULL) {\n            emit_match_expr(od->pz_DisableName, od, opts);\n            emit_inaction(opts, od);\n        }\n    } while (od++, --ct > 0);\n\n    printf(UNK_OPT_FMT, OPTION_STR, opts->pzPROGNAME);\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "load_old_output": {
      "start_point": [
        750,
        0
      ],
      "end_point": [
        795,
        1
      ],
      "content": "static char *\nload_old_output(char const * fname, char const * pname)\n{\n    /*\n     *  IF we cannot stat the file,\n     *  THEN assume we are creating a new file.\n     *       Skip the loading of the old data.\n     */\n    FILE * fp = fopen(fname, \"r\" FOPEN_BINARY_FLAG);\n    struct stat stbf;\n    char * text;\n    char * scan;\n\n    if (fp == NULL)\n        return NULL;\n\n    /*\n     * If we opened it, we should be able to stat it and it needs\n     * to be a regular file\n     */\n    if ((fstat(fileno(fp), &stbf) != 0) || (! S_ISREG(stbf.st_mode)))\n        fserr_exit(pname, \"fstat\", fname);\n\n    scan = text = AGALOC(stbf.st_size + 1, \"f data\");\n\n    /*\n     *  Read in all the data as fast as our OS will let us.\n     */\n    for (;;) {\n        size_t inct = fread(VOIDP(scan), 1, (size_t)stbf.st_size, fp);\n        if (inct == 0)\n            break;\n\n        stbf.st_size -= (ssize_t)inct;\n\n        if (stbf.st_size == 0)\n            break;\n\n        scan += inct;\n    }\n\n    *scan = NUL;\n    fclose(fp);\n\n    return text;\n}",
      "lines": 46,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nload_old_output(char const * fname, char const * pname)",
        "*"
      ]
    },
    "open_out": {
      "start_point": [
        808,
        0
      ],
      "end_point": [
        846,
        1
      ],
      "content": "static void\nopen_out(char const * fname, char const * pname)\n{\n\n    do  {\n        char * txt = script_text = load_old_output(fname, pname);\n        char * scn;\n\n        if (txt == NULL)\n            break;\n\n        scn = strstr(txt, START_MARK);\n        if (scn == NULL) {\n            script_trailer = txt;\n            break;\n        }\n\n        *(scn++) = NUL;\n        scn = strstr(scn, END_MARK);\n        if (scn == NULL) {\n            /*\n             * The file is corrupt.  Set the trailer to be everything\n             * after the start mark. The user will need to fix it up.\n             */\n            script_trailer = txt + strlen(txt) + START_MARK_LEN + 1;\n            break;\n        }\n\n        /*\n         *  Check to see if the data contains our marker.\n         *  If it does, then we will skip over it\n         */\n        script_trailer = scn + END_MARK_LEN;\n        script_leader  = txt;\n    } while (false);\n\n    if (freopen(fname, \"w\" FOPEN_BINARY_FLAG, stdout) != stdout)\n        fserr_exit(pname, \"freopen\", fname);\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "genshelloptUsage": {
      "start_point": [
        862,
        0
      ],
      "end_point": [
        946,
        1
      ],
      "content": "void\ngenshelloptUsage(tOptions * opts, int exit_cd)\n{\n#if ! defined(HAVE_WORKING_FORK)\n    optionUsage(opts, exit_cd);\n#else\n    /*\n     *  IF not EXIT_SUCCESS,\n     *  THEN emit the short form of usage.\n     */\n    if (exit_cd != EXIT_SUCCESS)\n        optionUsage(opts, exit_cd);\n    fflush(stderr);\n    fflush(stdout);\n    if (ferror(stdout) || ferror(stderr))\n        option_exits(EXIT_FAILURE);\n\n    option_usage_fp = stdout;\n\n    /*\n     *  First, print our usage\n     */\n    switch (fork()) {\n    case -1:\n        optionUsage(opts, EXIT_FAILURE);\n        /* NOTREACHED */\n\n    case 0:\n        pagerState = PAGER_STATE_CHILD;\n        optionUsage(opts, EXIT_SUCCESS);\n        /* NOTREACHED */\n        _exit(EXIT_FAILURE);\n\n    default:\n    {\n        int  sts;\n        wait(&sts);\n    }\n    }\n\n    /*\n     *  Generate the pzProgName, since optionProcess() normally\n     *  gets it from the command line\n     */\n    {\n        char *  pz;\n        char ** pp = VOIDP(&(optionParseShellOptions->pzProgName));\n        AGDUPSTR(pz, optionParseShellOptions->pzPROGNAME, \"prog name\");\n        *pp = pz;\n        while (*pz != NUL) {\n            *pz = (char)LOWER(*pz);\n            pz++;\n        }\n    }\n\n    /*\n     *  Separate the makeshell usage from the client usage\n     */\n    fprintf(option_usage_fp, zGenshell, optionParseShellOptions->pzProgName);\n    fflush(option_usage_fp);\n\n    /*\n     *  Now, print the client usage.\n     */\n    switch (fork()) {\n    case 0:\n        pagerState = PAGER_STATE_CHILD;\n        /*FALLTHROUGH*/\n    case -1:\n        optionUsage(optionParseShellOptions, EXIT_FAILURE);\n\n    default:\n    {\n        int  sts;\n        wait(&sts);\n    }\n    }\n\n    fflush(stdout);\n    if (ferror(stdout))\n        fserr_exit(opts->pzProgName, zwriting, zstdout_name);\n\n    option_exits(EXIT_SUCCESS);\n#endif\n}",
      "lines": 85,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/nested.c": {
    "remove_continuation": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "static void\nremove_continuation(char * src)\n{\n    char * pzD;\n\n    do  {\n        while (*src == NL)  src++;\n        pzD = strchr(src, NL);\n        if (pzD == NULL)\n            return;\n\n        /*\n         *  pzD has skipped at least one non-newline character and now\n         *  points to a newline character.  It now becomes the source and\n         *  pzD goes to the previous character.\n         */\n        src = pzD--;\n        if (*pzD != '\\\\')\n            pzD++;\n    } while (pzD == src);\n\n    /*\n     *  Start shifting text.\n     */\n    for (;;) {\n        char ch = ((*pzD++) = *(src++));\n        switch (ch) {\n        case NUL:  return;\n        case '\\\\':\n            if (*src == NL)\n                --pzD; /* rewrite on next iteration */\n        }\n    }\n}",
      "lines": 34,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "scan_q_str": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "static char const *\nscan_q_str(char const * pzTxt)\n{\n    char q = *(pzTxt++); /* remember the type of quote */\n\n    for (;;) {\n        char ch = *(pzTxt++);\n        if (ch == NUL)\n            return pzTxt-1;\n\n        if (ch == q)\n            return pzTxt;\n\n        if (ch == '\\\\') {\n            ch = *(pzTxt++);\n            /*\n             *  IF the next character is NUL, drop the backslash, too.\n             */\n            if (ch == NUL)\n                return pzTxt - 2;\n\n            /*\n             *  IF the quote character or the escape character were escaped,\n             *  then skip both, as long as the string does not end.\n             */\n            if ((ch == q) || (ch == '\\\\')) {\n                if (*(pzTxt++) == NUL)\n                    return pzTxt-1;\n            }\n        }\n    }\n}",
      "lines": 32,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\nscan_q_str(char const * pzTxt)",
        "*"
      ]
    },
    "add_string": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "static tOptionValue *\nadd_string(void ** pp, char const * name, size_t nm_len,\n           char const * val, size_t d_len)\n{\n    tOptionValue * pNV;\n    size_t sz = nm_len + d_len + sizeof(*pNV);\n\n    pNV = AGALOC(sz, \"option name/str value pair\");\n\n    if (val == NULL) {\n        pNV->valType = OPARG_TYPE_NONE;\n        pNV->pzName = pNV->v.strVal;\n\n    } else {\n        pNV->valType = OPARG_TYPE_STRING;\n        if (d_len > 0) {\n            char const * src = val;\n            char * pzDst = pNV->v.strVal;\n            int    ct    = (int)d_len;\n            do  {\n                int ch = *(src++) & 0xFF;\n                if (ch == NUL) goto data_copy_done;\n                if (ch == '&')\n                    ch = get_special_char(&src, &ct);\n                *(pzDst++) = (char)ch;\n            } while (--ct > 0);\n        data_copy_done:\n            *pzDst = NUL;\n\n        } else {\n            pNV->v.strVal[0] = NUL;\n        }\n\n        pNV->pzName = pNV->v.strVal + d_len + 1;\n    }\n\n    memcpy(pNV->pzName, name, nm_len);\n    pNV->pzName[ nm_len ] = NUL;\n    addArgListEntry(pp, pNV);\n    return pNV;\n}",
      "lines": 41,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "tOptionValue",
        "*\nadd_string(void ** pp, char const * name, size_t nm_len,\n           char const * val, size_t d_len)",
        "*"
      ]
    },
    "add_bool": {
      "start_point": [
        233,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "static tOptionValue *\nadd_bool(void ** pp, char const * name, size_t nm_len,\n         char const * val, size_t d_len)\n{\n    size_t sz = nm_len + sizeof(tOptionValue) + 1;\n    tOptionValue * new_val = AGALOC(sz, \"bool val\");\n\n    /*\n     * Scan over whitespace is constrained by \"d_len\"\n     */\n    while (IS_WHITESPACE_CHAR(*val) && (d_len > 0)) {\n        d_len--; val++;\n    }\n\n    if (d_len == 0)\n        new_val->v.boolVal = 0;\n\n    else if (IS_DEC_DIGIT_CHAR(*val))\n        new_val->v.boolVal = (unsigned)atoi(val);\n\n    else new_val->v.boolVal = ! IS_FALSE_TYPE_CHAR(*val);\n\n    new_val->valType = OPARG_TYPE_BOOLEAN;\n    new_val->pzName = (char *)(new_val + 1);\n    memcpy(new_val->pzName, name, nm_len);\n    new_val->pzName[ nm_len ] = NUL;\n    addArgListEntry(pp, new_val);\n    return new_val;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "tOptionValue",
        "*\nadd_bool(void ** pp, char const * name, size_t nm_len,\n         char const * val, size_t d_len)",
        "*"
      ]
    },
    "add_number": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        298,
        1
      ],
      "content": "static tOptionValue *\nadd_number(void ** pp, char const * name, size_t nm_len,\n           char const * val, size_t d_len)\n{\n    size_t sz = nm_len + sizeof(tOptionValue) + 1;\n    tOptionValue * new_val = AGALOC(sz, \"int val\");\n\n    /*\n     * Scan over whitespace is constrained by \"d_len\"\n     */\n    while (IS_WHITESPACE_CHAR(*val) && (d_len > 0)) {\n        d_len--; val++;\n    }\n    if (d_len == 0)\n        new_val->v.longVal = 0;\n    else\n        new_val->v.longVal = strtol(val, 0, 0);\n\n    new_val->valType = OPARG_TYPE_NUMERIC;\n    new_val->pzName  = (char *)(new_val + 1);\n    memcpy(new_val->pzName, name, nm_len);\n    new_val->pzName[ nm_len ] = NUL;\n    addArgListEntry(pp, new_val);\n    return new_val;\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "tOptionValue",
        "*\nadd_number(void ** pp, char const * name, size_t nm_len,\n           char const * val, size_t d_len)",
        "*"
      ]
    },
    "add_nested": {
      "start_point": [
        311,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "static tOptionValue *\nadd_nested(void ** pp, char const * name, size_t nm_len,\n           char * val, size_t d_len)\n{\n    tOptionValue * new_val;\n\n    if (d_len == 0) {\n        size_t sz = nm_len + sizeof(*new_val) + 1;\n        new_val = AGALOC(sz, \"empty nest\");\n        new_val->v.nestVal = NULL;\n        new_val->valType = OPARG_TYPE_HIERARCHY;\n        new_val->pzName = (char *)(new_val + 1);\n        memcpy(new_val->pzName, name, nm_len);\n        new_val->pzName[ nm_len ] = NUL;\n\n    } else {\n        new_val = optionLoadNested(val, name, nm_len);\n    }\n\n    if (new_val != NULL)\n        addArgListEntry(pp, new_val);\n\n    return new_val;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "tOptionValue",
        "*\nadd_nested(void ** pp, char const * name, size_t nm_len,\n           char * val, size_t d_len)",
        "*"
      ]
    },
    "scan_name": {
      "start_point": [
        340,
        0
      ],
      "end_point": [
        427,
        1
      ],
      "content": "static char const *\nscan_name(char const * name, tOptionValue * res)\n{\n    tOptionValue * new_val;\n    char const *   pzScan = name+1; /* we know first char is a name char */\n    char const *   pzVal;\n    size_t         nm_len = 1;\n    size_t         d_len = 0;\n\n    /*\n     *  Scan over characters that name a value.  These names may not end\n     *  with a colon, but they may contain colons.\n     */\n    pzScan = SPN_VALUE_NAME_CHARS(name + 1);\n    if (pzScan[-1] == ':')\n        pzScan--;\n    nm_len = (size_t)(pzScan - name);\n\n    pzScan = SPN_HORIZ_WHITE_CHARS(pzScan);\n\n re_switch:\n\n    switch (*pzScan) {\n    case '=':\n    case ':':\n        pzScan = SPN_HORIZ_WHITE_CHARS(pzScan + 1);\n        if ((*pzScan == '=') || (*pzScan == ':'))\n            goto default_char;\n        goto re_switch;\n\n    case NL:\n    case ',':\n        pzScan++;\n        /* FALLTHROUGH */\n\n    case NUL:\n        add_string(&(res->v.nestVal), name, nm_len, NULL, (size_t)0);\n        break;\n\n    case '\"':\n    case '\\'':\n        pzVal = pzScan;\n        pzScan = scan_q_str(pzScan);\n        d_len = (size_t)(pzScan - pzVal);\n        new_val = add_string(&(res->v.nestVal), name, nm_len, pzVal,\n                         d_len);\n        if ((new_val != NULL) && (option_load_mode == OPTION_LOAD_COOKED))\n            ao_string_cook(new_val->v.strVal, NULL);\n        break;\n\n    default:\n    default_char:\n        /*\n         *  We have found some strange text value.  It ends with a newline\n         *  or a comma.\n         */\n        pzVal = pzScan;\n        for (;;) {\n            char ch = *(pzScan++);\n            switch (ch) {\n            case NUL:\n                pzScan--;\n                d_len = (size_t)(pzScan - pzVal);\n                goto string_done;\n                /* FALLTHROUGH */\n\n            case NL:\n                if (   (pzScan > pzVal + 2)\n                    && (pzScan[-2] == '\\\\')\n                    && (pzScan[ 0] != NUL))\n                    continue;\n                /* FALLTHROUGH */\n\n            case ',':\n                d_len = (size_t)(pzScan - pzVal) - 1;\n            string_done:\n                new_val = add_string(&(res->v.nestVal), name, nm_len,\n                                     pzVal, d_len);\n                if (new_val != NULL)\n                    remove_continuation(new_val->v.strVal);\n                goto leave_scan_name;\n            }\n        }\n        break;\n    } leave_scan_name:;\n\n    return pzScan;\n}",
      "lines": 88,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\nscan_name(char const * name, tOptionValue * res)",
        "*"
      ]
    },
    "unnamed_xml": {
      "start_point": [
        438,
        0
      ],
      "end_point": [
        459,
        1
      ],
      "content": "static char const *\nunnamed_xml(char const * txt)\n{\n    switch (*txt) {\n    default:\n        txt = NULL;\n        break;\n\n    case '!':\n        txt = strstr(txt, \"-->\");\n        if (txt != NULL)\n            txt += 3;\n        break;\n\n    case '?':\n        txt = strchr(txt, '>');\n        if (txt != NULL)\n            txt++;\n        break;\n    }\n    return txt;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\nunnamed_xml(char const * txt)",
        "*"
      ]
    },
    "scan_xml_name": {
      "start_point": [
        471,
        0
      ],
      "end_point": [
        502,
        1
      ],
      "content": "static char const *\nscan_xml_name(char const * name, size_t * nm_len, tOptionValue * val)\n{\n    char const * scan = SPN_VALUE_NAME_CHARS(name + 1);\n    *nm_len = (size_t)(scan - name);\n    if (*nm_len > 64)\n        return NULL;\n    val->valType = OPARG_TYPE_STRING;\n\n    if (IS_WHITESPACE_CHAR(*scan)) {\n        /*\n         * There are attributes following the name.  Parse 'em.\n         */\n        scan = SPN_WHITESPACE_CHARS(scan);\n        scan = parse_attrs(NULL, scan, &option_load_mode, val);\n        if (scan == NULL)\n            return NULL; /* oops */\n    }\n\n    if (! IS_END_XML_TOKEN_CHAR(*scan))\n        return NULL; /* oops */\n\n    if (*scan == '/') {\n        /*\n         * Single element XML entries get inserted as an empty string.\n         */\n        if (*++scan != '>')\n            return NULL;\n        val->valType = OPARG_TYPE_NONE;\n    }\n    return scan+1;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\nscan_xml_name(char const * name, size_t * nm_len, tOptionValue * val)",
        "*"
      ]
    },
    "find_end_xml": {
      "start_point": [
        514,
        0
      ],
      "end_point": [
        538,
        1
      ],
      "content": "static char const *\nfind_end_xml(char const * src, size_t nm_len, char const * val, size_t * len)\n{\n    char z[72] = \"</\";\n    char * dst = z + 2;\n\n    do  {\n        *(dst++) = *(src++);\n    } while (--nm_len > 0); /* nm_len is known to be 64 or less */\n    *(dst++) = '>';\n    *dst = NUL;\n\n    {\n        char const * res = strstr(val, z);\n\n        if (res != NULL) {\n            char const * end = (option_load_mode != OPTION_LOAD_KEEP)\n                ? SPN_WHITESPACE_BACK(val, res)\n                : res;\n            *len = (size_t)(end - val); /* includes trailing white space */\n            res =  SPN_WHITESPACE_CHARS(res + (dst - z));\n        }\n        return res;\n    }\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\nfind_end_xml(char const * src, size_t nm_len, char const * val, size_t * len)",
        "*"
      ]
    },
    "scan_xml": {
      "start_point": [
        550,
        0
      ],
      "end_point": [
        631,
        1
      ],
      "content": "static char const *\nscan_xml(char const * xml_name, tOptionValue * res_val)\n{\n    size_t          nm_len, v_len;\n    char const *    scan;\n    char const *    val_str;\n    tOptionValue    valu;\n    tOptionLoadMode save_mode = option_load_mode;\n\n    if (! IS_VAR_FIRST_CHAR(*++xml_name))\n        return unnamed_xml(xml_name);\n\n    /*\n     * \"scan_xml_name()\" may change \"option_load_mode\".\n     */\n    val_str = scan_xml_name(xml_name, &nm_len, &valu);\n    if (val_str == NULL)\n        goto bail_scan_xml;\n\n    if (valu.valType == OPARG_TYPE_NONE)\n        scan = val_str;\n    else {\n        if (option_load_mode != OPTION_LOAD_KEEP)\n            val_str = SPN_WHITESPACE_CHARS(val_str);\n        scan = find_end_xml(xml_name, nm_len, val_str, &v_len);\n        if (scan == NULL)\n            goto bail_scan_xml;\n    }\n\n    /*\n     * \"scan\" now points to where the scan is to resume after returning.\n     * It either points after \"/>\" at the end of the XML element header,\n     * or it points after the \"</name>\" tail based on the name in the header.\n     */\n\n    switch (valu.valType) {\n    case OPARG_TYPE_NONE:\n        add_string(&(res_val->v.nestVal), xml_name, nm_len, NULL, 0);\n        break;\n\n    case OPARG_TYPE_STRING:\n    {\n        tOptionValue * new_val = add_string(\n            &(res_val->v.nestVal), xml_name, nm_len, val_str, v_len);\n\n        if (option_load_mode != OPTION_LOAD_KEEP)\n            munge_str(new_val->v.strVal, option_load_mode);\n\n        break;\n    }\n\n    case OPARG_TYPE_BOOLEAN:\n        add_bool(&(res_val->v.nestVal), xml_name, nm_len, val_str, v_len);\n        break;\n\n    case OPARG_TYPE_NUMERIC:\n        add_number(&(res_val->v.nestVal), xml_name, nm_len, val_str, v_len);\n        break;\n\n    case OPARG_TYPE_HIERARCHY:\n    {\n        char * pz = AGALOC(v_len+1, \"h scan\");\n        memcpy(pz, val_str, v_len);\n        pz[v_len] = NUL;\n        add_nested(&(res_val->v.nestVal), xml_name, nm_len, pz, v_len);\n        AGFREE(pz);\n        break;\n    }\n\n    case OPARG_TYPE_ENUMERATION:\n    case OPARG_TYPE_MEMBERSHIP:\n    default:\n        break;\n    }\n\n    option_load_mode = save_mode;\n    return scan;\n\nbail_scan_xml:\n    option_load_mode = save_mode;\n    return NULL;\n}",
      "lines": 82,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\nscan_xml(char const * xml_name, tOptionValue * res_val)",
        "*"
      ]
    },
    "unload_arg_list": {
      "start_point": [
        640,
        0
      ],
      "end_point": [
        654,
        1
      ],
      "content": "LOCAL void\nunload_arg_list(tArgList * arg_list)\n{\n    int ct = arg_list->useCt;\n    char const ** pnew_val = arg_list->apzArgs;\n\n    while (ct-- > 0) {\n        tOptionValue * new_val = (tOptionValue *)VOIDP(*(pnew_val++));\n        if (new_val->valType == OPARG_TYPE_HIERARCHY)\n            unload_arg_list(new_val->v.nestVal);\n        AGFREE(new_val);\n    }\n\n    AGFREE(arg_list);\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "LOCAL",
        "void",
        "void"
      ]
    },
    "optionUnloadNested": {
      "start_point": [
        666,
        0
      ],
      "end_point": [
        678,
        1
      ],
      "content": "void\noptionUnloadNested(tOptionValue const * opt_val)\n{\n    if (opt_val == NULL) return;\n    if (opt_val->valType != OPARG_TYPE_HIERARCHY) {\n        errno = EINVAL;\n        return;\n    }\n\n    unload_arg_list(opt_val->v.nestVal);\n\n    AGFREE(opt_val);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sort_list": {
      "start_point": [
        685,
        0
      ],
      "end_point": [
        717,
        1
      ],
      "content": "static void\nsort_list(tArgList * arg_list)\n{\n    int ix;\n    int lm = arg_list->useCt;\n\n    /*\n     *  This loop iterates \"useCt\" - 1 times.\n     */\n    for (ix = 0; ++ix < lm;) {\n        int iy = ix-1;\n        tOptionValue * new_v = C(tOptionValue *, arg_list->apzArgs[ix]);\n        tOptionValue * old_v = C(tOptionValue *, arg_list->apzArgs[iy]);\n\n        /*\n         *  For as long as the new entry precedes the \"old\" entry,\n         *  move the old pointer.  Stop before trying to extract the\n         *  \"-1\" entry.\n         */\n        while (strcmp(old_v->pzName, new_v->pzName) > 0) {\n            arg_list->apzArgs[iy+1] = VOIDP(old_v);\n            old_v = (tOptionValue *)VOIDP(arg_list->apzArgs[--iy]);\n            if (iy < 0)\n                break;\n        }\n\n        /*\n         *  Always store the pointer.  Sometimes it is redundant,\n         *  but the redundancy is cheaper than a test and branch sequence.\n         */\n        arg_list->apzArgs[iy+1] = VOIDP(new_v);\n    }\n}",
      "lines": 33,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "optionLoadNested": {
      "start_point": [
        745,
        0
      ],
      "end_point": [
        810,
        1
      ],
      "content": "LOCAL tOptionValue *\noptionLoadNested(char const * text, char const * name, size_t nm_len)\n{\n    tOptionValue * res_val;\n\n    /*\n     *  Make sure we have some data and we have space to put what we find.\n     */\n    if (text == NULL) {\n        errno = EINVAL;\n        return NULL;\n    }\n    text = SPN_WHITESPACE_CHARS(text);\n    if (*text == NUL) {\n        errno = ENOMSG;\n        return NULL;\n    }\n    res_val = AGALOC(sizeof(*res_val) + nm_len + 1, \"nest args\");\n    res_val->valType = OPARG_TYPE_HIERARCHY;\n    res_val->pzName  = (char *)(res_val + 1);\n    memcpy(res_val->pzName, name, nm_len);\n    res_val->pzName[nm_len] = NUL;\n\n    {\n        tArgList * arg_list = AGALOC(sizeof(*arg_list), \"nest arg l\");\n\n        res_val->v.nestVal = arg_list;\n        arg_list->useCt   = 0;\n        arg_list->allocCt = MIN_ARG_ALLOC_CT;\n    }\n\n    /*\n     *  Scan until we hit a NUL.\n     */\n    do  {\n        text = SPN_WHITESPACE_CHARS(text);\n        if (IS_VAR_FIRST_CHAR(*text))\n            text = scan_name(text, res_val);\n\n        else switch (*text) {\n        case NUL: goto scan_done;\n        case '<': text = scan_xml(text, res_val);\n                  if (text == NULL) goto woops;\n                  if (*text == ',') text++; break;\n        case '#': text = strchr(text, NL);  break;\n        default:  goto woops;\n        }\n    } while (text != NULL); scan_done:;\n\n    {\n        tArgList * al = res_val->v.nestVal;\n        if (al->useCt == 0) {\n            errno = ENOMSG;\n            goto woops;\n        }\n        if (al->useCt > 1)\n            sort_list(al);\n    }\n\n    return res_val;\n\n woops:\n    AGFREE(res_val->v.nestVal);\n    AGFREE(res_val);\n    return NULL;\n}",
      "lines": 66,
      "depth": 13,
      "decorators": [
        "LOCAL",
        "tOptionValue",
        "tOptionValue",
        "*\noptionLoadNested(char const * text, char const * name, size_t nm_len)",
        "*"
      ]
    },
    "optionNestedVal": {
      "start_point": [
        822,
        0
      ],
      "end_point": [
        852,
        1
      ],
      "content": "void\noptionNestedVal(tOptions * opts, tOptDesc * od)\n{\n    if (opts < OPTPROC_EMIT_LIMIT)\n        return;\n\n    if (od->fOptState & OPTST_RESET) {\n        tArgList *    arg_list = od->optCookie;\n        int           ct;\n        char const ** av;\n\n        if (arg_list == NULL)\n            return;\n        ct = arg_list->useCt;\n        av = arg_list->apzArgs;\n\n        while (--ct >= 0) {\n            void * p = VOIDP(*(av++));\n            optionUnloadNested((tOptionValue const *)p);\n        }\n\n        AGFREE(od->optCookie);\n\n    } else {\n        tOptionValue * opt_val = optionLoadNested(\n            od->optArg.argString, od->pz_Name, strlen(od->pz_Name));\n\n        if (opt_val != NULL)\n            addArgListEntry(&(od->optCookie), VOIDP(opt_val));\n    }\n}",
      "lines": 31,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "get_special_char": {
      "start_point": [
        857,
        0
      ],
      "end_point": [
        904,
        1
      ],
      "content": "LOCAL int\nget_special_char(char const ** ppz, int * ct)\n{\n    char const * pz = *ppz;\n\n    if (*ct < 3)\n        return '&';\n\n    if (*pz == '#') {\n        int base = 10;\n        int retch;\n\n        pz++;\n        if (*pz == 'x') {\n            base = 16;\n            pz++;\n        }\n        retch = (int)strtoul(pz, (char **)&pz, base);\n        if (*pz != ';')\n            return '&';\n        base = (int)(++pz - *ppz);\n        if (base > *ct)\n            return '&';\n\n        *ct -= base;\n        *ppz = pz;\n        return retch;\n    }\n\n    {\n        int ctr = sizeof(xml_xlate) / sizeof(xml_xlate[0]);\n        xml_xlate_t const * xlatp = xml_xlate;\n\n        for (;;) {\n            if (  (*ct >= xlatp->xml_len)\n               && (strncmp(pz, xlatp->xml_txt, (size_t)xlatp->xml_len) == 0)) {\n                *ppz += xlatp->xml_len;\n                *ct  -= xlatp->xml_len;\n                return xlatp->xml_ch;\n            }\n\n            if (--ctr <= 0)\n                break;\n            xlatp++;\n        }\n    }\n    return '&';\n}",
      "lines": 48,
      "depth": 15,
      "decorators": [
        "LOCAL",
        "int",
        "int"
      ]
    },
    "emit_special_char": {
      "start_point": [
        909,
        0
      ],
      "end_point": [
        926,
        1
      ],
      "content": "LOCAL void\nemit_special_char(FILE * fp, int ch)\n{\n    int ctr = sizeof(xml_xlate) / sizeof(xml_xlate[0]);\n    xml_xlate_t const * xlatp = xml_xlate;\n\n    putc('&', fp);\n    for (;;) {\n        if (ch == xlatp->xml_ch) {\n            fputs(xlatp->xml_txt, fp);\n            return;\n        }\n        if (--ctr <= 0)\n            break;\n        xlatp++;\n    }\n    fprintf(fp, XML_HEX_BYTE_FMT, (ch & 0xFF));\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "LOCAL",
        "void",
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/numeric.c": {
    "optionShowRange": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "void\noptionShowRange(tOptions * pOpts, tOptDesc * pOD, void * rng_table, int rng_ct)\n{\n    const struct {long const rmin, rmax;} * rng = rng_table;\n\n    char const * pz_indent = zTabHyp + tab_skip_ct;\n\n    /*\n     * The range is shown only for full usage requests and an error\n     * in this particular option.\n     */\n    if (pOpts != OPTPROC_EMIT_USAGE) {\n        if (pOpts <= OPTPROC_EMIT_LIMIT)\n            return;\n        pz_indent = ONE_TAB_STR;\n\n        fprintf(option_usage_fp, zRangeErr, pOpts->pzProgName,\n                pOD->pz_Name, pOD->optArg.argInt);\n        pz_indent = \"\";\n    }\n\n    if (pOD->fOptState & OPTST_SCALED_NUM)\n        fprintf(option_usage_fp, zRangeScaled, pz_indent);\n\n    fprintf(option_usage_fp, (rng_ct > 1) ? zRangeLie : zRangeOnly, pz_indent);\n    pz_indent = (pOpts != OPTPROC_EMIT_USAGE)\n        ? ONE_TAB_STR\n        : (zTabSpace + tab_skip_ct);\n\n    for (;;) {\n        if (rng->rmax == LONG_MIN)\n            fprintf(option_usage_fp, zRangeExact, pz_indent, rng->rmin);\n        else if (rng->rmin == LONG_MIN)\n            fprintf(option_usage_fp, zRangeUpto, pz_indent, rng->rmax);\n        else if (rng->rmax == LONG_MAX)\n            fprintf(option_usage_fp, zRangeAbove, pz_indent, rng->rmin);\n        else\n            fprintf(option_usage_fp, zRange, pz_indent, rng->rmin,\n                    rng->rmax);\n\n        if  (--rng_ct <= 0) {\n            fputc(NL, option_usage_fp);\n            break;\n        }\n        fputs(zRangeOr, option_usage_fp);\n        rng++;\n    }\n\n    if (pOpts > OPTPROC_EMIT_LIMIT)\n        pOpts->pUsageProc(pOpts, EXIT_FAILURE);\n}",
      "lines": 51,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "optionNumericVal": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "void\noptionNumericVal(tOptions * opts, tOptDesc * od)\n{\n    char * pz;\n    long   val;\n\n    /*\n     *  Guard against all the different ways this procedure might get invoked\n     *  when there is no string argument provided.\n     */\n    if (INQUERY_CALL(opts, od) || (od->optArg.argString == NULL))\n        return;\n\n    /*\n     *  Numeric options may have a range associated with it.\n     *  If it does, the usage procedure requests that it be\n     *  emitted by passing a NULL od pointer.  Also bail out\n     *  if there is no option argument or if we are being reset.\n     */\n    if (  (od == NULL)\n       || (od->optArg.argString == NULL)\n       || ((od->fOptState & OPTST_RESET) != 0))\n        return;\n\n    errno = 0;\n    val = strtol(od->optArg.argString, &pz, 0);\n    if ((pz == od->optArg.argString) || (errno != 0))\n        goto bad_number;\n\n    if ((od->fOptState & OPTST_SCALED_NUM) != 0)\n        switch (*(pz++)) {\n        case NUL:  pz--; break;\n        case 't':  val *= 1000;\n        case 'g':  val *= 1000;\n        case 'm':  val *= 1000;\n        case 'k':  val *= 1000; break;\n\n        case 'T':  val *= 1024;\n        case 'G':  val *= 1024;\n        case 'M':  val *= 1024;\n        case 'K':  val *= 1024; break;\n\n        default:   goto bad_number;\n        }\n\n    if (*pz != NUL)\n        goto bad_number;\n\n    if (od->fOptState & OPTST_ALLOC_ARG) {\n        AGFREE(od->optArg.argString);\n        od->fOptState &= ~OPTST_ALLOC_ARG;\n    }\n\n    od->optArg.argInt = val;\n    return;\n\n    bad_number:\n\n    fprintf( stderr, zNotNumber, opts->pzProgName, od->optArg.argString );\n    if ((opts->fOptSet & OPTPROC_ERRSTOP) != 0)\n        (*(opts->pUsageProc))(opts, EXIT_FAILURE);\n\n    errno = EINVAL;\n    od->optArg.argInt = ~0;\n}",
      "lines": 65,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/option-value-type.c": {
    "option_value_type_hash": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "static unsigned int\noption_value_type_hash (register const char *str, register unsigned int len)\n{\n  static const unsigned char asso_values[] =\n    {\n      18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n      18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n      18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n      18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n      18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n      18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n      18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n      18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n      18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n      18, 18, 18, 18, 18, 18, 18, 18,  0, 18,\n      18, 18, 18, 18,  0, 10, 18,  5, 18, 18,\n       5, 18, 18, 18, 18,  0, 18, 18, 18, 18,\n      18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n      18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n      18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n      18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n      18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n      18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n      18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n      18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n      18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n      18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n      18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n      18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n      18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n      18, 18, 18, 18, 18, 18\n    };\n  return len + asso_values[(unsigned char)str[0]];\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "find_option_value_type_name": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "static inline const option_value_type_map_t *\nfind_option_value_type_name (register const char *str, register unsigned int len)\n{\n  if (len <= 14 && len >= 3)\n    {\n      register int key = (int)option_value_type_hash (str, len);\n\n      if (key <= 17 && key >= 0)\n        {\n          register const char *s = option_value_type_table[key].vtp_name;\n\n          if (*str == *s && !strncmp (str + 1, s + 1, len - 1) && s[len] == '\\0')\n            return &option_value_type_table[key];\n        }\n    }\n  return 0;\n}",
      "lines": 17,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "const",
        "const",
        "option_value_type_map_t",
        "*\nfind_option_value_type_name (register const char *str, register unsigned int len)",
        "*"
      ]
    },
    "find_option_value_type_cmd": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "option_value_type_enum_t\nfind_option_value_type_cmd(char const * str, size_t len)\n{\n    option_value_type_map_t const * map;\n\n    map = find_option_value_type_name(str, (unsigned int)len);\n    return (map == NULL) ? VTP_INVALID_CMD : map->vtp_id;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "option_value_type_enum_t"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/option-value-type.h": {},
  "sharutils/sharutils-4.15.2/libopts/option-xat-attribute.c": {
    "option_xat_attribute_hash": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "static unsigned int\noption_xat_attribute_hash (register const char *str, register unsigned int len)\n{\n  static const unsigned char asso_values[] =\n    {\n     10,10,10,10,10,10,10,10,10,10,\n     10,10,10,10,10,10,10,10,10,10,\n     10,10,10,10,10,10,10,10,10,10,\n     10,10,10,10,10,10,10,10,10,10,\n     10,10,10,10,10,10,10,10,10,10,\n     10,10,10,10,10,10,10,10,10,10,\n     10,10,10,10,10,10,10,10,10,10,\n     10,10,10,10,10,10,10,10,10,10,\n     10,10,10,10,10,10,10,10,10,10,\n     10,10,10,10,10,10,10,10,10, 0,\n     10,10,10,10,10,10,10, 5,10, 0,\n     10,10,10,10,10,10, 0, 0,10, 0,\n     10,10,10,10,10,10,10,10,10,10,\n     10,10,10,10,10,10,10,10,10,10,\n     10,10,10,10,10,10,10,10,10,10,\n     10,10,10,10,10,10,10,10,10,10,\n     10,10,10,10,10,10,10,10,10,10,\n     10,10,10,10,10,10,10,10,10,10,\n     10,10,10,10,10,10,10,10,10,10,\n     10,10,10,10,10,10,10,10,10,10,\n     10,10,10,10,10,10,10,10,10,10,\n     10,10,10,10,10,10,10,10,10,10,\n     10,10,10,10,10,10,10,10,10,10,\n     10,10,10,10,10,10,10,10,10,10,\n     10,10,10,10,10,10,10,10,10,10,\n     10,10,10,10,10,10\n    };\n  return len + asso_values[(unsigned char)str[0]];\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "find_option_xat_attribute_name": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "static inline const option_xat_attribute_map_t *\nfind_option_xat_attribute_name (register const char *str, register unsigned int len)\n{\n  if (len <= 8 && len >= 4)\n    {\n      register int key = (int)option_xat_attribute_hash (str, len);\n\n      if (key <= 9 && key >= 0)\n        {\n          register const char *s = option_xat_attribute_table[key].xat_name;\n\n          if (*str == *s && !strncmp (str + 1, s + 1, len - 1) && s[len] == '\\0')\n            return &option_xat_attribute_table[key];\n        }\n    }\n  return 0;\n}",
      "lines": 17,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "const",
        "const",
        "option_xat_attribute_map_t",
        "*\nfind_option_xat_attribute_name (register const char *str, register unsigned int len)",
        "*"
      ]
    },
    "find_option_xat_attribute_cmd": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "option_xat_attribute_enum_t\nfind_option_xat_attribute_cmd(char const * str, size_t len)\n{\n    option_xat_attribute_map_t const * map;\n\n    map = find_option_xat_attribute_name(str, (unsigned int)len);\n    return (map == NULL) ? XAT_INVALID_CMD : map->xat_id;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "option_xat_attribute_enum_t"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/option-xat-attribute.h": {},
  "sharutils/sharutils-4.15.2/libopts/parse-duration.c": {
    "str_const_to_ul": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "static unsigned long\nstr_const_to_ul (cch_t * str, cch_t ** ppz, int base)\n{\n  return strtoul (str, (char **)ppz, base);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "str_const_to_l": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "static long\nstr_const_to_l (cch_t * str, cch_t ** ppz, int base)\n{\n  return strtol (str, (char **)ppz, base);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "long",
        "long"
      ]
    },
    "scale_n_add": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "static time_t\nscale_n_add (time_t base, time_t val, int scale)\n{\n  if (base == BAD_TIME)\n    {\n      if (errno == 0)\n        errno = EINVAL;\n      return BAD_TIME;\n    }\n\n  if (val > MAX_DURATION / scale)\n    {\n      errno = ERANGE;\n      return BAD_TIME;\n    }\n\n  val *= scale;\n  if (base > MAX_DURATION - val)\n    {\n      errno = ERANGE;\n      return BAD_TIME;\n    }\n\n  return base + val;\n}",
      "lines": 25,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "time_t"
      ]
    },
    "parse_hr_min_sec": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "static time_t\nparse_hr_min_sec (time_t start, cch_t * pz)\n{\n  int lpct = 0;\n\n  errno = 0;\n\n  /* For as long as our scanner pointer points to a colon *AND*\n     we've not looped before, then keep looping.  (two iterations max) */\n  while ((*pz == ':') && (lpct++ <= 1))\n    {\n      unsigned long v = str_const_to_ul (pz+1, &pz, 10);\n\n      if (errno != 0)\n        return BAD_TIME;\n\n      start = scale_n_add (v, start, 60);\n\n      if (errno != 0)\n        return BAD_TIME;\n    }\n\n  /* allow for trailing spaces */\n  while (isspace ((unsigned char)*pz))\n    pz++;\n  if (*pz != NUL)\n    {\n      errno = EINVAL;\n      return BAD_TIME;\n    }\n\n  return start;\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "time_t"
      ]
    },
    "parse_scaled_value": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "static time_t\nparse_scaled_value (time_t base, cch_t ** ppz, cch_t * endp, int scale)\n{\n  cch_t * pz = *ppz;\n  time_t val;\n\n  if (base == BAD_TIME)\n    return base;\n\n  errno = 0;\n  val = str_const_to_ul (pz, &pz, 10);\n  if (errno != 0)\n    return BAD_TIME;\n  while (isspace ((unsigned char)*pz))\n    pz++;\n  if (pz != endp)\n    {\n      errno = EINVAL;\n      return BAD_TIME;\n    }\n\n  *ppz = pz;\n  return scale_n_add (base, val, scale);\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "time_t"
      ]
    },
    "parse_year_month_day": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "static time_t\nparse_year_month_day (cch_t * pz, cch_t * ps)\n{\n  time_t res = 0;\n\n  res = parse_scaled_value (0, &pz, ps, SEC_PER_YEAR);\n\n  pz++; /* over the first '-' */\n  ps = strchr (pz, '-');\n  if (ps == NULL)\n    {\n      errno = EINVAL;\n      return BAD_TIME;\n    }\n  res = parse_scaled_value (res, &pz, ps, SEC_PER_MONTH);\n\n  pz++; /* over the second '-' */\n  ps = pz + strlen (pz);\n  return parse_scaled_value (res, &pz, ps, SEC_PER_DAY);\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "time_t"
      ]
    },
    "parse_yearmonthday": {
      "start_point": [
        188,
        0
      ],
      "end_point": [
        215,
        1
      ],
      "content": "static time_t\nparse_yearmonthday (cch_t * in_pz)\n{\n  time_t res = 0;\n  char   buf[8];\n  cch_t * pz;\n\n  if (strlen (in_pz) != 8)\n    {\n      errno = EINVAL;\n      return BAD_TIME;\n    }\n\n  memcpy (buf, in_pz, 4);\n  buf[4] = NUL;\n  pz = buf;\n  res = parse_scaled_value (0, &pz, buf + 4, SEC_PER_YEAR);\n\n  memcpy (buf, in_pz + 4, 2);\n  buf[2] = NUL;\n  pz =   buf;\n  res = parse_scaled_value (res, &pz, buf + 2, SEC_PER_MONTH);\n\n  memcpy (buf, in_pz + 6, 2);\n  buf[2] = NUL;\n  pz =   buf;\n  return parse_scaled_value (res, &pz, buf + 2, SEC_PER_DAY);\n}",
      "lines": 28,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "time_t"
      ]
    },
    "parse_YMWD": {
      "start_point": [
        218,
        0
      ],
      "end_point": [
        259,
        1
      ],
      "content": "static time_t\nparse_YMWD (cch_t * pz)\n{\n  time_t res = 0;\n  cch_t * ps = strchr (pz, 'Y');\n  if (ps != NULL)\n    {\n      res = parse_scaled_value (0, &pz, ps, SEC_PER_YEAR);\n      pz++;\n    }\n\n  ps = strchr (pz, 'M');\n  if (ps != NULL)\n    {\n      res = parse_scaled_value (res, &pz, ps, SEC_PER_MONTH);\n      pz++;\n    }\n\n  ps = strchr (pz, 'W');\n  if (ps != NULL)\n    {\n      res = parse_scaled_value (res, &pz, ps, SEC_PER_WEEK);\n      pz++;\n    }\n\n  ps = strchr (pz, 'D');\n  if (ps != NULL)\n    {\n      res = parse_scaled_value (res, &pz, ps, SEC_PER_DAY);\n      pz++;\n    }\n\n  while (isspace ((unsigned char)*pz))\n    pz++;\n  if (*pz != NUL)\n    {\n      errno = EINVAL;\n      return BAD_TIME;\n    }\n\n  return res;\n}",
      "lines": 42,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "time_t"
      ]
    },
    "parse_hour_minute_second": {
      "start_point": [
        263,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "static time_t\nparse_hour_minute_second (cch_t * pz, cch_t * ps)\n{\n  time_t res = 0;\n\n  res = parse_scaled_value (0, &pz, ps, SEC_PER_HR);\n\n  pz++;\n  ps = strchr (pz, ':');\n  if (ps == NULL)\n    {\n      errno = EINVAL;\n      return BAD_TIME;\n    }\n\n  res = parse_scaled_value (res, &pz, ps, SEC_PER_MIN);\n\n  pz++;\n  ps = pz + strlen (pz);\n  return parse_scaled_value (res, &pz, ps, 1);\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "time_t"
      ]
    },
    "parse_hourminutesecond": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "static time_t\nparse_hourminutesecond (cch_t * in_pz)\n{\n  time_t res = 0;\n  char   buf[4];\n  cch_t * pz;\n\n  if (strlen (in_pz) != 6)\n    {\n      errno = EINVAL;\n      return BAD_TIME;\n    }\n\n  memcpy (buf, in_pz, 2);\n  buf[2] = NUL;\n  pz = buf;\n  res = parse_scaled_value (0, &pz, buf + 2, SEC_PER_HR);\n\n  memcpy (buf, in_pz + 2, 2);\n  buf[2] = NUL;\n  pz =   buf;\n  res = parse_scaled_value (res, &pz, buf + 2, SEC_PER_MIN);\n\n  memcpy (buf, in_pz + 4, 2);\n  buf[2] = NUL;\n  pz =   buf;\n  return parse_scaled_value (res, &pz, buf + 2, 1);\n}",
      "lines": 28,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "time_t"
      ]
    },
    "parse_HMS": {
      "start_point": [
        316,
        0
      ],
      "end_point": [
        350,
        1
      ],
      "content": "static time_t\nparse_HMS (cch_t * pz)\n{\n  time_t res = 0;\n  cch_t * ps = strchr (pz, 'H');\n  if (ps != NULL)\n    {\n      res = parse_scaled_value (0, &pz, ps, SEC_PER_HR);\n      pz++;\n    }\n\n  ps = strchr (pz, 'M');\n  if (ps != NULL)\n    {\n      res = parse_scaled_value (res, &pz, ps, SEC_PER_MIN);\n      pz++;\n    }\n\n  ps = strchr (pz, 'S');\n  if (ps != NULL)\n    {\n      res = parse_scaled_value (res, &pz, ps, 1);\n      pz++;\n    }\n\n  while (isspace ((unsigned char)*pz))\n    pz++;\n  if (*pz != NUL)\n    {\n      errno = EINVAL;\n      return BAD_TIME;\n    }\n\n  return res;\n}",
      "lines": 35,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "time_t"
      ]
    },
    "parse_time": {
      "start_point": [
        353,
        0
      ],
      "end_point": [
        382,
        1
      ],
      "content": "static time_t\nparse_time (cch_t * pz)\n{\n  cch_t * ps;\n  time_t  res = 0;\n\n  /*\n   *  Scan for a hyphen\n   */\n  ps = strchr (pz, ':');\n  if (ps != NULL)\n    {\n      res = parse_hour_minute_second (pz, ps);\n    }\n\n  /*\n   *  Try for a 'H', 'M' or 'S' suffix\n   */\n  else if (ps = strpbrk (pz, \"HMS\"),\n           ps == NULL)\n    {\n      /* Its a YYYYMMDD format: */\n      res = parse_hourminutesecond (pz);\n    }\n\n  else\n    res = parse_HMS (pz);\n\n  return res;\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "time_t"
      ]
    },
    "trim": {
      "start_point": [
        386,
        0
      ],
      "end_point": [
        402,
        1
      ],
      "content": "static char *\ntrim (char * pz)\n{\n  /* trim leading white space */\n  while (isspace ((unsigned char)*pz))\n    pz++;\n\n  /* trim trailing white space */\n  {\n    char * pe = pz + strlen (pz);\n    while ((pe > pz) && isspace ((unsigned char)pe[-1]))\n      pe--;\n    *pe = NUL;\n  }\n\n  return pz;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ntrim (char * pz)",
        "*"
      ]
    },
    "parse_period": {
      "start_point": [
        407,
        0
      ],
      "end_point": [
        460,
        1
      ],
      "content": "static time_t\nparse_period (cch_t * in_pz)\n{\n  char * pT;\n  char * ps;\n  char * pz   = strdup (in_pz);\n  void * fptr = pz;\n  time_t res  = 0;\n\n  if (pz == NULL)\n    {\n      errno = ENOMEM;\n      return BAD_TIME;\n    }\n\n  pT = strchr (pz, 'T');\n  if (pT != NULL)\n    {\n      *(pT++) = NUL;\n      pz = trim (pz);\n      pT = trim (pT);\n    }\n\n  /*\n   *  Scan for a hyphen\n   */\n  ps = strchr (pz, '-');\n  if (ps != NULL)\n    {\n      res = parse_year_month_day (pz, ps);\n    }\n\n  /*\n   *  Try for a 'Y', 'M' or 'D' suffix\n   */\n  else if (ps = strpbrk (pz, \"YMWD\"),\n           ps == NULL)\n    {\n      /* Its a YYYYMMDD format: */\n      res = parse_yearmonthday (pz);\n    }\n\n  else\n    res = parse_YMWD (pz);\n\n  if ((errno == 0) && (pT != NULL))\n    {\n      time_t val = parse_time (pT);\n      res = scale_n_add (res, val, 1);\n    }\n\n  free (fptr);\n  return res;\n}",
      "lines": 54,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "time_t"
      ]
    },
    "parse_non_iso8601": {
      "start_point": [
        462,
        0
      ],
      "end_point": [
        572,
        1
      ],
      "content": "static time_t\nparse_non_iso8601 (cch_t * pz)\n{\n  whats_done_t whatd_we_do = NOTHING_IS_DONE;\n\n  time_t res = 0;\n\n  do  {\n    time_t val;\n\n    errno = 0;\n    val = str_const_to_l (pz, &pz, 10);\n    if (errno != 0)\n      goto bad_time;\n\n    /*  IF we find a colon, then we're going to have a seconds value.\n        We will not loop here any more.  We cannot already have parsed\n        a minute value and if we've parsed an hour value, then the result\n        value has to be less than an hour. */\n    if (*pz == ':')\n      {\n        if (whatd_we_do >= MINUTE_IS_DONE)\n          break;\n\n        val = parse_hr_min_sec (val, pz);\n\n        if ((whatd_we_do == HOUR_IS_DONE) && (val >= SEC_PER_HR))\n          break;\n\n        return scale_n_add (res, val, 1);\n      }\n\n    {\n      unsigned int mult;\n\n      /*  Skip over white space following the number we just parsed. */\n      while (isspace ((unsigned char)*pz))\n        pz++;\n\n      switch (*pz)\n        {\n        default:  goto bad_time;\n        case NUL:\n          return scale_n_add (res, val, 1);\n\n        case 'y': case 'Y':\n          if (whatd_we_do >= YEAR_IS_DONE)\n            goto bad_time;\n          mult = SEC_PER_YEAR;\n          whatd_we_do = YEAR_IS_DONE;\n          break;\n\n        case 'M':\n          if (whatd_we_do >= MONTH_IS_DONE)\n            goto bad_time;\n          mult = SEC_PER_MONTH;\n          whatd_we_do = MONTH_IS_DONE;\n          break;\n\n        case 'W':\n          if (whatd_we_do >= WEEK_IS_DONE)\n            goto bad_time;\n          mult = SEC_PER_WEEK;\n          whatd_we_do = WEEK_IS_DONE;\n          break;\n\n        case 'd': case 'D':\n          if (whatd_we_do >= DAY_IS_DONE)\n            goto bad_time;\n          mult = SEC_PER_DAY;\n          whatd_we_do = DAY_IS_DONE;\n          break;\n\n        case 'h':\n          if (whatd_we_do >= HOUR_IS_DONE)\n            goto bad_time;\n          mult = SEC_PER_HR;\n          whatd_we_do = HOUR_IS_DONE;\n          break;\n\n        case 'm':\n          if (whatd_we_do >= MINUTE_IS_DONE)\n            goto bad_time;\n          mult = SEC_PER_MIN;\n          whatd_we_do = MINUTE_IS_DONE;\n          break;\n\n        case 's':\n          mult = 1;\n          whatd_we_do = SECOND_IS_DONE;\n          break;\n        }\n\n      res = scale_n_add (res, val, mult);\n\n      pz++;\n      while (isspace ((unsigned char)*pz))\n        pz++;\n      if (*pz == NUL)\n        return res;\n\n      if (! isdigit ((unsigned char)*pz))\n        break;\n    }\n\n  } while (whatd_we_do < SECOND_IS_DONE);\n\n bad_time:\n  errno = EINVAL;\n  return BAD_TIME;\n}",
      "lines": 111,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "time_t"
      ]
    },
    "parse_duration": {
      "start_point": [
        574,
        0
      ],
      "end_point": [
        595,
        1
      ],
      "content": "time_t\nparse_duration (char const * pz)\n{\n  while (isspace ((unsigned char)*pz))\n    pz++;\n\n  switch (*pz)\n    {\n    case 'P':\n      return parse_period (pz + 1);\n\n    case 'T':\n      return parse_time (pz + 1);\n\n    default:\n      if (isdigit ((unsigned char)*pz))\n        return parse_non_iso8601 (pz);\n\n      errno = EINVAL;\n      return BAD_TIME;\n    }\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "time_t"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/parse-duration.h": {},
  "sharutils/sharutils-4.15.2/libopts/pgusage.c": {
    "open_tmp_usage": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "static inline FILE *\nopen_tmp_usage(char ** buf)\n{\n    char * bf;\n    size_t bfsz;\n\n    {\n        unsigned int my_pid = (unsigned int)getpid();\n        char const * tmpdir = getenv(TMPDIR);\n        if (tmpdir == NULL)\n            tmpdir = tmp_dir;\n        bfsz = TMP_FILE_FMT_LEN + strlen(tmpdir) + 10;\n        bf   = AGALOC(bfsz, \"tmp fil\");\n        snprintf(bf, bfsz, TMP_FILE_FMT, tmpdir, my_pid);\n    }\n\n    {\n        static mode_t const cmask = S_IRWXO | S_IRWXG;\n        mode_t svmsk = umask(cmask);\n        int fd = mkstemp(bf);\n        (void)umask(svmsk);\n\n        if (fd < 0) {\n            AGFREE(bf);\n            return NULL;\n        }\n        *buf = bf;\n        return fdopen(fd, \"w\");\n    }\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "FILE",
        "*\nopen_tmp_usage(char ** buf)",
        "*"
      ]
    },
    "mk_pager_cmd": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static inline char *\nmk_pager_cmd(char const * fname)\n{\n    /*\n     * Page the file and remove it when done.  For shell script processing,\n     * we must redirect the output to the current stderr, otherwise stdout.\n     */\n    fclose(option_usage_fp);\n    option_usage_fp = NULL;\n\n    {\n        char const * pager  = (char const *)getenv(PAGER_NAME);\n        size_t bfsz;\n        char * res;\n\n        /*\n         *  Use the \"more(1)\" program if \"PAGER\" has not been defined\n         */\n        if (pager == NULL)\n            pager = MORE_STR;\n\n        bfsz = 2 * strlen(fname) + strlen(pager) + PAGE_USAGE_FMT_LEN;\n        res  = AGALOC(bfsz, \"more cmd\");\n        snprintf(res, bfsz, PAGE_USAGE_FMT, pager, fname);\n        AGFREE(fname);\n        return res;\n    }\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "char",
        "*\nmk_pager_cmd(char const * fname)",
        "*"
      ]
    },
    "optionPagedUsage": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "void\noptionPagedUsage(tOptions * opts, tOptDesc * od)\n{\n#if ! defined(HAVE_WORKING_FORK)\n    if ((od->fOptState & OPTST_RESET) != 0)\n        return;\n\n    (*opts->pUsageProc)(opts, EXIT_SUCCESS);\n#else\n    static bool sv_print_exit = false;\n    static char * fil_name = NULL;\n\n    /*\n     *  IF we are being called after the usage proc is done\n     *     (and thus has called \"exit(2)\")\n     *  THEN invoke the pager to page through the usage file we created.\n     */\n    switch (pagerState) {\n    case PAGER_STATE_INITIAL:\n    {\n        if ((od->fOptState & OPTST_RESET) != 0)\n            return;\n        option_usage_fp = open_tmp_usage(&fil_name);\n        if (option_usage_fp == NULL)\n            (*opts->pUsageProc)(opts, EXIT_SUCCESS);\n\n        pagerState    = PAGER_STATE_READY;\n        sv_print_exit = print_exit;\n\n        /*\n         *  Set up so this routine gets called during the exit logic\n         */\n        atexit((void(*)(void))optionPagedUsage);\n\n        /*\n         *  The usage procedure will now put the usage information into\n         *  the temporary file we created above.  Keep any shell commands\n         *  out of the result.\n         */\n        print_exit = false;\n        (*opts->pUsageProc)(opts, EXIT_SUCCESS);\n\n        /* NOTREACHED */\n        _exit(EXIT_FAILURE);\n    }\n\n    case PAGER_STATE_READY:\n        fil_name = mk_pager_cmd(fil_name);\n\n        if (sv_print_exit) {\n            fputs(\"\\nexit 0\\n\", stdout);\n            fclose(stdout);\n            dup2(STDERR_FILENO, STDOUT_FILENO);\n\n        } else {\n            fclose(stderr);\n            dup2(STDOUT_FILENO, STDERR_FILENO);\n        }\n\n        ignore_val( system( fil_name));\n        AGFREE(fil_name);\n\n    case PAGER_STATE_CHILD:\n        /*\n         *  This is a child process used in creating shell script usage.\n         */\n        break;\n    }\n#endif\n}",
      "lines": 70,
      "depth": 17,
      "decorators": [
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/proto.h": {},
  "sharutils/sharutils-4.15.2/libopts/putshell.c": {
    "string_size": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "static size_t\nstring_size(char const * scan, size_t nl_len)\n{\n    /*\n     *  Start by counting the start and end quotes, plus the NUL.\n     */\n    size_t res_ln = 3;\n\n    for (;;) {\n        char ch = *(scan++);\n        if ((ch >= ' ') && (ch <= '~')) {\n\n            /*\n             * a backslash allowance for double quotes and baskslashes\n             */\n            res_ln += ((ch == '\"') || (ch == '\\\\')) ? 2 : 1;\n        }\n\n        /*\n         *  When not a normal character, then count the characters\n         *  required to represent whatever it is.\n         */\n        else switch (ch) {\n        case NUL:\n            return res_ln;\n\n        case NL:\n            res_ln += nl_len;\n            break;\n\n        case HT:\n        case BEL:\n        case BS:\n        case FF:\n        case CR:\n        case VT:\n            res_ln += 2;\n            break;\n\n        default:\n            res_ln += 4; /* text len for \\xNN */\n        }\n    }\n}",
      "lines": 44,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "optionQuoteString": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "char const *\noptionQuoteString(char const * text, char const * nl)\n{\n    size_t   nl_len = strlen(nl);\n    char *   out;\n    char *   res = out = AGALOC(string_size(text, nl_len), \"quot str\");\n    *(out++) = '\"';\n\n    for (;;) {\n        unsigned char ch = (unsigned char)*text;\n        if ((ch >= ' ') && (ch <= '~')) {\n            if ((ch == '\"') || (ch == '\\\\'))\n                /*\n                 *  We must escape these characters in the output string\n                 */\n                *(out++) = '\\\\';\n            *(out++) = (char)ch;\n\n        } else switch (ch) {\n#       define   add_esc_ch(_ch)  { *(out++) = '\\\\'; *(out++) = (_ch); }\n        case BEL: add_esc_ch('a'); break;\n        case BS:  add_esc_ch('b'); break;\n        case HT:  add_esc_ch('t'); break;\n        case VT:  add_esc_ch('v'); break;\n        case FF:  add_esc_ch('f'); break;\n        case CR:  add_esc_ch('r'); break;\n\n        case LF:\n            /*\n             *  Place contiguous new-lines on a single line.\n             *  The current character is a NL, check the next one.\n             */\n            while (*++text == NL)\n                add_esc_ch('n');\n\n            /*\n             *  Insert a splice before starting next line\n             */\n            if (*text != NUL) {\n                memcpy(out, nl, nl_len);\n                out += nl_len;\n\n                continue; /* text is already at the next character */\n            }\n\n            add_esc_ch('n');\n            /* FALLTHROUGH */\n\n        case NUL:\n            /*\n             *  End of string.  Terminate the quoted output.  If necessary,\n             *  deallocate the text string.  Return the scan resumption point.\n             */\n            *(out++) = '\"';\n            *out = NUL;\n            return res;\n\n        default:\n            /*\n             *  sprintf is safe here, because we already computed\n             *  the amount of space we will be using.\n             */\n            sprintf(out, MK_STR_OCT_FMT, ch);\n            out += 4;\n        }\n\n        text++;\n#       undef add_esc_ch\n    }\n}",
      "lines": 70,
      "depth": 14,
      "decorators": [
        "char",
        "const",
        "const",
        "*\noptionQuoteString(char const * text, char const * nl)",
        "*"
      ]
    },
    "print_quoted_apostrophes": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "static char const *\nprint_quoted_apostrophes(char const * str)\n{\n    while (*str == APOSTROPHE) {\n        fputs(QUOT_APOS, stdout);\n        str++;\n    }\n    return str;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\nprint_quoted_apostrophes(char const * str)",
        "*"
      ]
    },
    "print_quot_str": {
      "start_point": [
        219,
        0
      ],
      "end_point": [
        270,
        1
      ],
      "content": "static void\nprint_quot_str(char const * str)\n{\n    /*\n     *  Handle empty strings to make the rest of the logic simpler.\n     */\n    if ((str == NULL) || (*str == NUL)) {\n        fputs(EMPTY_ARG, stdout);\n        return;\n    }\n\n    /*\n     *  Emit any single quotes/apostrophes at the start of the string and\n     *  bail if that is all we need to do.\n     */\n    str = print_quoted_apostrophes(str);\n    if (*str == NUL)\n        return;\n\n    /*\n     *  Start the single quote string\n     */\n    fputc(APOSTROPHE, stdout);\n    for (;;) {\n        char const * pz = strchr(str, APOSTROPHE);\n        if (pz == NULL)\n            break;\n\n        /*\n         *  Emit the string up to the single quote (apostrophe) we just found.\n         */\n        (void)fwrite(str, (size_t)(pz - str), (size_t)1, stdout);\n\n        /*\n         * Close the current string, emit the apostrophes and re-open the\n         * string (IFF there is more text to print).\n         */\n        fputc(APOSTROPHE, stdout);\n        str = print_quoted_apostrophes(pz);\n        if (*str == NUL)\n            return;\n\n        fputc(APOSTROPHE, stdout);\n    }\n\n    /*\n     *  If we broke out of the loop, we must still emit the remaining text\n     *  and then close the single quote string.\n     */\n    fputs(str, stdout);\n    fputc(APOSTROPHE, stdout);\n}",
      "lines": 52,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_enumeration": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        288,
        1
      ],
      "content": "static void\nprint_enumeration(tOptions * pOpts, tOptDesc * pOD)\n{\n    uintptr_t e_val = pOD->optArg.argEnum;\n    printf(OPT_VAL_FMT, pOpts->pzPROGNAME, pOD->pz_NAME);\n\n    /*\n     *  Convert value to string, print that and restore numeric value.\n     */\n    (*(pOD->pOptProc))(OPTPROC_RETURN_VALNAME, pOD);\n    printf(QUOT_ARG_FMT, pOD->optArg.argString);\n    if (pOD->fOptState & OPTST_ALLOC_ARG)\n        AGFREE(pOD->optArg.argString);\n    pOD->optArg.argEnum = e_val;\n\n    printf(OPT_END_FMT, pOpts->pzPROGNAME, pOD->pz_NAME);\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_membership": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "static void\nprint_membership(tOptions * pOpts, tOptDesc * pOD)\n{\n    char const * svstr = pOD->optArg.argString;\n    char const * pz;\n    uintptr_t val = 1;\n    printf(zOptNumFmt, pOpts->pzPROGNAME, pOD->pz_NAME,\n           (int)(uintptr_t)(pOD->optCookie));\n    pOD->optCookie = VOIDP(~0UL);\n    (*(pOD->pOptProc))(OPTPROC_RETURN_VALNAME, pOD);\n\n    pz = pOD->optArg.argString;\n    while (*pz != NUL) {\n        printf(\"readonly %s_\", pOD->pz_NAME);\n        pz = SPN_PLUS_N_SPACE_CHARS(pz);\n\n        for (;;) {\n            int ch = *(pz++);\n            if (IS_LOWER_CASE_CHAR(ch))   fputc(toupper(ch), stdout);\n            else if (IS_UPPER_CASE_CHAR(ch))   fputc(ch, stdout);\n            else if (IS_PLUS_N_SPACE_CHAR(ch)) goto name_done;\n            else if (ch == NUL)        { pz--; goto name_done; }\n            else fputc('_', stdout);\n        } name_done:;\n        printf(SHOW_VAL_FMT, (unsigned long)val);\n        val <<= 1;\n    }\n\n    AGFREE(pOD->optArg.argString);\n    pOD->optArg.argString = svstr;\n}",
      "lines": 31,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_stacked_arg": {
      "start_point": [
        322,
        0
      ],
      "end_point": [
        338,
        1
      ],
      "content": "static void\nprint_stacked_arg(tOptions * pOpts, tOptDesc * pOD)\n{\n    tArgList *      pAL = (tArgList *)pOD->optCookie;\n    char const **   ppz = pAL->apzArgs;\n    int             ct  = pAL->useCt;\n\n    printf(zOptCookieCt, pOpts->pzPROGNAME, pOD->pz_NAME, ct);\n\n    while (--ct >= 0) {\n        printf(ARG_BY_NUM_FMT, pOpts->pzPROGNAME, pOD->pz_NAME,\n               pAL->useCt - ct);\n        print_quot_str(*(ppz++));\n        printf(EXPORT_ARG_FMT, pOpts->pzPROGNAME, pOD->pz_NAME,\n               pAL->useCt - ct);\n    }\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_reordering": {
      "start_point": [
        346,
        0
      ],
      "end_point": [
        360,
        1
      ],
      "content": "static void\nprint_reordering(tOptions * opts)\n{\n    unsigned int ix;\n\n    fputs(set_dash, stdout);\n\n    for (ix = opts->curOptIdx;\n         ix < opts->origArgCt;\n         ix++) {\n        fputc(' ', stdout);\n        print_quot_str(opts->origArgVect[ ix ]);\n    }\n    fputs(init_optct, stdout);\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "optionPutShell": {
      "start_point": [
        369,
        0
      ],
      "end_point": [
        501,
        1
      ],
      "content": "void\noptionPutShell(tOptions * pOpts)\n{\n    int  optIx = 0;\n\n    printf(zOptCtFmt, pOpts->curOptIdx-1);\n\n    do  {\n        tOptDesc * pOD = pOpts->pOptDesc + optIx;\n\n        if ((pOD->fOptState & OPTST_NO_OUTPUT_MASK) != 0)\n            continue;\n\n        /*\n         *  Equivalence classes are hard to deal with.  Where the\n         *  option data wind up kind of squishes around.  For the purposes\n         *  of emitting shell state, they are not recommended, but we'll\n         *  do something.  I guess we'll emit the equivalenced-to option\n         *  at the point in time when the base option is found.\n         */\n        if (pOD->optEquivIndex != NO_EQUIVALENT)\n            continue; /* equivalence to a different option */\n\n        /*\n         *  Equivalenced to a different option.  Process the current option\n         *  as the equivalenced-to option.  Keep the persistent state bits,\n         *  but copy over the set-state bits.\n         */\n        if (pOD->optActualIndex != optIx) {\n            tOptDesc * p  = pOpts->pOptDesc + pOD->optActualIndex;\n            p->optArg     = pOD->optArg;\n            p->fOptState &= OPTST_PERSISTENT_MASK;\n            p->fOptState |= pOD->fOptState & ~OPTST_PERSISTENT_MASK;\n            printf(zEquivMode, pOpts->pzPROGNAME, pOD->pz_NAME, p->pz_NAME);\n            pOD = p;\n        }\n\n        /*\n         *  If the argument type is a set membership bitmask, then we always\n         *  emit the thing.  We do this because it will always have some sort\n         *  of bitmask value and we need to emit the bit values.\n         */\n        if (OPTST_GET_ARGTYPE(pOD->fOptState) == OPARG_TYPE_MEMBERSHIP) {\n            print_membership(pOpts, pOD);\n            continue;\n        }\n\n        /*\n         *  IF the option was either specified or it wakes up enabled,\n         *  then we will emit information.  Otherwise, skip it.\n         *  The idea is that if someone defines an option to initialize\n         *  enabled, we should tell our shell script that it is enabled.\n         */\n        if (UNUSED_OPT(pOD) && DISABLED_OPT(pOD))\n            continue;\n\n        /*\n         *  Handle stacked arguments\n         */\n        if (  (pOD->fOptState & OPTST_STACKED)\n           && (pOD->optCookie != NULL) )  {\n            print_stacked_arg(pOpts, pOD);\n            continue;\n        }\n\n        /*\n         *  If the argument has been disabled,\n         *  Then set its value to the disablement string\n         */\n        if ((pOD->fOptState & OPTST_DISABLED) != 0) {\n            printf(zOptDisabl, pOpts->pzPROGNAME, pOD->pz_NAME,\n                   (pOD->pz_DisablePfx != NULL)\n                   ? pOD->pz_DisablePfx : \"false\");\n            continue;\n        }\n\n        /*\n         *  If the argument type is numeric, the last arg pointer\n         *  is really the VALUE of the string that was pointed to.\n         */\n        if (OPTST_GET_ARGTYPE(pOD->fOptState) == OPARG_TYPE_NUMERIC) {\n            printf(zOptNumFmt, pOpts->pzPROGNAME, pOD->pz_NAME,\n                   (int)pOD->optArg.argInt);\n            continue;\n        }\n\n        /*\n         *  If the argument type is an enumeration, then it is much\n         *  like a text value, except we call the callback function\n         *  to emit the value corresponding to the \"optArg\" number.\n         */\n        if (OPTST_GET_ARGTYPE(pOD->fOptState) == OPARG_TYPE_ENUMERATION) {\n            print_enumeration(pOpts, pOD);\n            continue;\n        }\n\n        /*\n         *  If the argument type is numeric, the last arg pointer\n         *  is really the VALUE of the string that was pointed to.\n         */\n        if (OPTST_GET_ARGTYPE(pOD->fOptState) == OPARG_TYPE_BOOLEAN) {\n            printf(zFullOptFmt, pOpts->pzPROGNAME, pOD->pz_NAME,\n                   (pOD->optArg.argBool == 0) ? \"false\" : \"true\");\n            continue;\n        }\n\n        /*\n         *  IF the option has an empty value,\n         *  THEN we set the argument to the occurrence count.\n         */\n        if (  (pOD->optArg.argString == NULL)\n           || (pOD->optArg.argString[0] == NUL) ) {\n\n            printf(zOptNumFmt, pOpts->pzPROGNAME, pOD->pz_NAME,\n                   pOD->optOccCt);\n            continue;\n        }\n\n        /*\n         *  This option has a text value\n         */\n        printf(OPT_VAL_FMT, pOpts->pzPROGNAME, pOD->pz_NAME);\n        print_quot_str(pOD->optArg.argString);\n        printf(OPT_END_FMT, pOpts->pzPROGNAME, pOD->pz_NAME);\n\n    } while (++optIx < pOpts->presetOptCt );\n\n    if (  ((pOpts->fOptSet & OPTPROC_REORDER) != 0)\n       && (pOpts->curOptIdx < pOpts->origArgCt))\n        print_reordering(pOpts);\n\n    fflush(stdout);\n}",
      "lines": 133,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/reset.c": {
    "optionReset": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "static void\noptionReset(tOptions * pOpts, tOptDesc * pOD)\n{\n    pOD->fOptState &= OPTST_PERSISTENT_MASK;\n    pOD->fOptState |= OPTST_RESET;\n    if (pOD->pOptProc != NULL)\n        pOD->pOptProc(pOpts, pOD);\n    pOD->optArg.argString =\n        pOpts->originalOptArgArray[ pOD->optIndex ].argString;\n    pOD->optCookie = pOpts->originalOptArgCookie[ pOD->optIndex ];\n    pOD->fOptState &= OPTST_PERSISTENT_MASK;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "optionResetEverything": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static void\noptionResetEverything(tOptions * pOpts)\n{\n    tOptDesc * pOD = pOpts->pOptDesc;\n    int        ct  = pOpts->presetOptCt;\n\n    for (;;) {\n        optionReset(pOpts, pOD);\n\n        if (--ct <= 0)\n            break;\n        pOD++;\n    }\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "optionResetOpt": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "void\noptionResetOpt(tOptions * pOpts, tOptDesc * pOD)\n{\n    static bool reset_active = false;\n\n    tOptState opt_state = OPTSTATE_INITIALIZER(DEFINED);\n    char const * pzArg = pOD->optArg.argString;\n    tSuccess     succ;\n\n    if (pOpts <= OPTPROC_EMIT_LIMIT)\n        return;\n\n    if (reset_active)\n        return;\n\n    if (  (! HAS_originalOptArgArray(pOpts))\n       || (pOpts->originalOptArgCookie == NULL))\n        ao_bug(zno_reset);\n\n    if ((pzArg == NULL) || (*pzArg == NUL)) {\n        fprintf(stderr, zreset_arg, pOpts->pzProgName, pOD->pz_Name);\n        pOpts->pUsageProc(pOpts, EXIT_FAILURE);\n        /* NOTREACHED */\n        assert(0 == 1);\n    }\n\n    reset_active = true;\n\n    if (pzArg[1] == NUL) {\n        if (*pzArg == '*') {\n            optionResetEverything(pOpts);\n            reset_active = false;\n            return;\n        }\n\n        succ = opt_find_short(pOpts, (uint8_t)*pzArg, &opt_state);\n        if (! SUCCESSFUL(succ)) {\n            fprintf(stderr, zIllOptChr, pOpts->pzProgPath, *pzArg);\n            pOpts->pUsageProc(pOpts, EXIT_FAILURE);\n            /* NOTREACHED */\n            assert(0 == 1);\n        }\n    } else {\n        succ = opt_find_long(pOpts, (char *)pzArg, &opt_state);\n        if (! SUCCESSFUL(succ)) {\n            fprintf(stderr, zIllOptStr, pOpts->pzProgPath, pzArg);\n            pOpts->pUsageProc(pOpts, EXIT_FAILURE);\n            /* NOTREACHED */\n            assert(0 == 1);\n        }\n    }\n\n    /*\n     *  We've found the indicated option.  Turn off all non-persistent\n     *  flags because we're forcing the option back to its initialized state.\n     *  Call any callout procedure to handle whatever it needs to.\n     *  Finally, clear the reset flag, too.\n     */\n    optionReset(pOpts, opt_state.pOD);\n    reset_active = false;\n}",
      "lines": 61,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/restore.c": {
    "fixupSavedOptionArgs": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "static void\nfixupSavedOptionArgs(tOptions * pOpts)\n{\n    tOptions * p   = pOpts->pSavedState;\n    tOptDesc * pOD = pOpts->pOptDesc;\n    int        ct  = pOpts->optCt;\n\n    /*\n     *  Make sure that allocated stuff is only referenced in the\n     *  archived copy of the data.\n     */\n    for (; ct-- > 0; pOD++)  {\n        switch (OPTST_GET_ARGTYPE(pOD->fOptState)) {\n        case OPARG_TYPE_STRING:\n            if (pOD->fOptState & OPTST_STACKED) {\n                tOptDesc * q = p->pOptDesc + (pOD - pOpts->pOptDesc);\n                q->optCookie = NULL;\n            }\n            if (pOD->fOptState & OPTST_ALLOC_ARG) {\n                tOptDesc * q = p->pOptDesc + (pOD - pOpts->pOptDesc);\n                AGDUPSTR(q->optArg.argString, pOD->optArg.argString, \"arg\");\n            }\n            break;\n\n        case OPARG_TYPE_HIERARCHY:\n        {\n            tOptDesc * q = p->pOptDesc + (pOD - pOpts->pOptDesc);\n            q->optCookie = NULL;\n        }\n        }\n    }\n}",
      "lines": 32,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "optionSaveState": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "void\noptionSaveState(tOptions * pOpts)\n{\n    tOptions * p = (tOptions *)pOpts->pSavedState;\n\n    if (p == NULL) {\n        size_t sz = sizeof(*pOpts)\n            + ((size_t)pOpts->optCt * sizeof(tOptDesc));\n        p = AGALOC(sz, \"saved option state\");\n\n        pOpts->pSavedState = p;\n    }\n\n    memcpy(p, pOpts, sizeof(*p));\n    memcpy(p + 1, pOpts->pOptDesc, (size_t)p->optCt * sizeof(tOptDesc));\n\n    fixupSavedOptionArgs(pOpts);\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "optionRestore": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "void\noptionRestore(tOptions * pOpts)\n{\n    tOptions * p = (tOptions *)pOpts->pSavedState;\n\n    if (p == NULL) {\n        char const * pzName = pOpts->pzProgName;\n        if (pzName == NULL) {\n            pzName = pOpts->pzPROGNAME;\n            if (pzName == NULL)\n                pzName = zNil;\n        }\n        fprintf(stderr, zNoState, pzName);\n        option_exits(EXIT_FAILURE);\n    }\n\n    pOpts->pSavedState = NULL;\n    optionFree(pOpts);\n\n    memcpy(pOpts, p, sizeof(*p));\n    memcpy(pOpts->pOptDesc, p+1, (size_t)p->optCt * sizeof(tOptDesc));\n    pOpts->pSavedState = p;\n\n    fixupSavedOptionArgs(pOpts);\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "optionFree": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "void\noptionFree(tOptions * pOpts)\n{\n free_saved_state:\n    {\n        tOptDesc * p = pOpts->pOptDesc;\n        int ct = pOpts->optCt;\n        do  {\n            if (p->fOptState & OPTST_ALLOC_ARG) {\n                AGFREE(p->optArg.argString);\n                p->optArg.argString = NULL;\n                p->fOptState &= ~OPTST_ALLOC_ARG;\n            }\n\n            switch (OPTST_GET_ARGTYPE(p->fOptState)) {\n            case OPARG_TYPE_STRING:\n#ifdef WITH_LIBREGEX\n                if (  (p->fOptState & OPTST_STACKED)\n                   && (p->optCookie != NULL)) {\n                    p->optArg.argString = \".*\";\n                    optionUnstackArg(pOpts, p);\n                }\n#else\n                /* leak memory */;\n#endif\n                break;\n\n            case OPARG_TYPE_HIERARCHY:\n                if (p->optCookie != NULL)\n                    unload_arg_list(p->optCookie);\n                break;\n            }\n\n            p->optCookie = NULL;\n        } while (p++, --ct > 0);\n    }\n    if (pOpts->pSavedState != NULL) {\n        tOptions * p = (tOptions *)pOpts->pSavedState;\n        memcpy(pOpts, p, sizeof(*p));\n        memcpy(pOpts->pOptDesc, p+1, (size_t)p->optCt * sizeof(tOptDesc));\n        AGFREE(pOpts->pSavedState);\n        pOpts->pSavedState = NULL;\n        goto free_saved_state;\n    }\n}",
      "lines": 45,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/save.c": {
    "find_dir_name": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "static char const *\nfind_dir_name(tOptions * opts, int * p_free)\n{\n    char const * pzDir;\n\n    if (  (opts->specOptIdx.save_opts == NO_EQUIVALENT)\n       || (opts->specOptIdx.save_opts == 0))\n        return NULL;\n\n    pzDir = opts->pOptDesc[ opts->specOptIdx.save_opts ].optArg.argString;\n    if ((pzDir != NULL) && (*pzDir != NUL))\n        return pzDir;\n\n    /*\n     *  This function only works if there is a directory where\n     *  we can stash the RC (INI) file.\n     */\n    {\n        char const * const * papz = opts->papzHomeList;\n        if (papz == NULL)\n            return NULL;\n\n        while (papz[1] != NULL) papz++;\n        pzDir = *papz;\n    }\n\n    /*\n     *  IF it does not require deciphering an env value, then just copy it\n     */\n    if (*pzDir != '$')\n        return pzDir;\n\n    {\n        char const * pzEndDir = strchr(++pzDir, DIRCH);\n        char * pzFileName;\n        char * pzEnv;\n\n        if (pzEndDir != NULL) {\n            char z[ AO_NAME_SIZE ];\n            if ((pzEndDir - pzDir) > AO_NAME_LIMIT )\n                return NULL;\n            memcpy(z, pzDir, (size_t)(pzEndDir - pzDir));\n            z[pzEndDir - pzDir] = NUL;\n            pzEnv = getenv(z);\n        } else {\n\n            /*\n             *  Make sure we can get the env value (after stripping off\n             *  any trailing directory or file names)\n             */\n            pzEnv = getenv(pzDir);\n        }\n\n        if (pzEnv == NULL) {\n            fprintf(stderr, zsave_warn, opts->pzProgName);\n            fprintf(stderr, zNotDef, pzDir);\n            return NULL;\n        }\n\n        if (pzEndDir == NULL)\n            return pzEnv;\n\n        {\n            size_t sz = strlen(pzEnv) + strlen(pzEndDir) + 2;\n            pzFileName = (char *)AGALOC(sz, \"dir name\");\n        }\n\n        if (pzFileName == NULL)\n            return NULL;\n\n        *p_free = 1;\n        /*\n         *  Glue together the full name into the allocated memory.\n         *  FIXME: We lose track of this memory.\n         */\n        sprintf(pzFileName, \"%s/%s\", pzEnv, pzEndDir);\n        return pzFileName;\n    }\n}",
      "lines": 79,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\nfind_dir_name(tOptions * opts, int * p_free)",
        "*"
      ]
    },
    "find_file_name": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        267,
        1
      ],
      "content": "static char const *\nfind_file_name(tOptions * opts, int * p_free_name)\n{\n    struct stat stBuf;\n    int    free_dir_name = 0;\n\n    char const * pzDir = find_dir_name(opts, &free_dir_name);\n    if (pzDir == NULL)\n        return NULL;\n\n    /*\n     *  See if we can find the specified directory.  We use a once-only loop\n     *  structure so we can bail out early.\n     */\n    if (stat(pzDir, &stBuf) != 0) do {\n        char z[AG_PATH_MAX];\n        char * dirchp;\n\n        /*\n         *  IF we could not, check to see if we got a full\n         *  path to a file name that has not been created yet.\n         */\n        if (errno != ENOENT) {\n        bogus_name:\n            fprintf(stderr, zsave_warn, opts->pzProgName);\n            fprintf(stderr, zNoStat, errno, strerror(errno), pzDir);\n            if (free_dir_name)\n                AGFREE(pzDir);\n            return NULL;\n        }\n\n        /*\n         *  Strip off the last component, stat the remaining string and\n         *  that string must name a directory\n         */\n        dirchp = strrchr(pzDir, DIRCH);\n        if (dirchp == NULL) {\n            stBuf.st_mode = S_IFREG;\n            break; /* found directory -- viz.,  \".\" */\n        }\n\n        if ((size_t)(dirchp - pzDir) >= sizeof(z))\n            goto bogus_name;\n\n        memcpy(z, pzDir, (size_t)(dirchp - pzDir));\n        z[dirchp - pzDir] = NUL;\n\n        if ((stat(z, &stBuf) != 0) || ! S_ISDIR(stBuf.st_mode))\n            goto bogus_name;\n        stBuf.st_mode = S_IFREG; /* file within this directory */\n    } while (false);\n\n    /*\n     *  IF what we found was a directory,\n     *  THEN tack on the config file name\n     */\n    if (S_ISDIR(stBuf.st_mode)) {\n        size_t sz = strlen(pzDir) + strlen(opts->pzRcName) + 2;\n\n        {\n            char * pzPath = (char *)AGALOC(sz, \"file name\");\n#ifdef HAVE_SNPRINTF\n            snprintf(pzPath, sz, \"%s/%s\", pzDir, opts->pzRcName);\n#else\n            sprintf(pzPath, \"%s/%s\", pzDir, opts->pzRcName);\n#endif\n            if (free_dir_name)\n                AGFREE(pzDir);\n            pzDir = pzPath;\n            free_dir_name = 1;\n        }\n\n        /*\n         *  IF we cannot stat the object for any reason other than\n         *     it does not exist, then we bail out\n         */\n        if (stat(pzDir, &stBuf) != 0) {\n            if (errno != ENOENT) {\n                fprintf(stderr, zsave_warn, opts->pzProgName);\n                fprintf(stderr, zNoStat, errno, strerror(errno),\n                        pzDir);\n                AGFREE(pzDir);\n                return NULL;\n            }\n\n            /*\n             *  It does not exist yet, but it will be a regular file\n             */\n            stBuf.st_mode = S_IFREG;\n        }\n    }\n\n    /*\n     *  Make sure that whatever we ultimately found, that it either is\n     *  or will soon be a file.\n     */\n    if (! S_ISREG(stBuf.st_mode)) {\n        fprintf(stderr, zsave_warn, opts->pzProgName, pzDir);\n        if (free_dir_name)\n            AGFREE(pzDir);\n        return NULL;\n    }\n\n    /*\n     *  Get rid of the old file\n     */\n    unlink(pzDir);\n    *p_free_name = free_dir_name;\n    return pzDir;\n}",
      "lines": 110,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\nfind_file_name(tOptions * opts, int * p_free_name)",
        "*"
      ]
    },
    "prt_entry": {
      "start_point": [
        276,
        0
      ],
      "end_point": [
        337,
        1
      ],
      "content": "static void\nprt_entry(FILE * fp, tOptDesc * od, char const * l_arg)\n{\n    int space_ct;\n\n    /*\n     *  There is an argument.  Pad the name so values line up.\n     *  Not disabled *OR* this got equivalenced to another opt,\n     *  then use current option name.\n     *  Otherwise, there must be a disablement name.\n     */\n    {\n        char const * pz =\n            (! DISABLED_OPT(od) || (od->optEquivIndex != NO_EQUIVALENT))\n            ? od->pz_Name\n            : od->pz_DisableName;\n        space_ct = 17 - strlen(pz);\n        fputs(pz, fp);\n    }\n\n    if (  (l_arg == NULL)\n       && (OPTST_GET_ARGTYPE(od->fOptState) != OPARG_TYPE_NUMERIC))\n        goto end_entry;\n\n    fputs(\" = \", fp);\n    while (space_ct-- > 0)  fputc(' ', fp);\n\n    /*\n     *  IF the option is numeric only,\n     *  THEN the char pointer is really the number\n     */\n    if (OPTST_GET_ARGTYPE(od->fOptState) == OPARG_TYPE_NUMERIC)\n        fprintf(fp, \"%d\", (int)(intptr_t)l_arg);\n\n    else {\n        for (;;) {\n            char const * eol = strchr(l_arg, NL);\n\n            /*\n             *  IF this is the last line\n             *  THEN bail and print it\n             */\n            if (eol == NULL)\n                break;\n\n            /*\n             *  Print the continuation and the text from the current line\n             */\n            (void)fwrite(l_arg, (size_t)(eol - l_arg), (size_t)1, fp);\n            l_arg = eol+1; /* advance the Last Arg pointer */\n            fputs(\"\\\\\\n\", fp);\n        }\n\n        /*\n         *  Terminate the entry\n         */\n        fputs(l_arg, fp);\n    }\n\nend_entry:\n    fputc(NL, fp);\n}",
      "lines": 62,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "prt_value": {
      "start_point": [
        341,
        0
      ],
      "end_point": [
        403,
        1
      ],
      "content": "static void\nprt_value(FILE * fp, int depth, tOptDesc * pOD, tOptionValue const * ovp)\n{\n    while (--depth >= 0)\n        putc(' ', fp), putc(' ', fp);\n\n    switch (ovp->valType) {\n    default:\n    case OPARG_TYPE_NONE:\n        fprintf(fp, NULL_ATR_FMT, ovp->pzName);\n        break;\n\n    case OPARG_TYPE_STRING:\n        prt_string(fp, ovp->pzName, ovp->v.strVal);\n        break;\n\n    case OPARG_TYPE_ENUMERATION:\n    case OPARG_TYPE_MEMBERSHIP:\n        if (pOD != NULL) {\n            uint32_t  opt_state = pOD->fOptState;\n            uintptr_t val = pOD->optArg.argEnum;\n            char const * typ = (ovp->valType == OPARG_TYPE_ENUMERATION)\n                ? \"keyword\" : \"set-membership\";\n\n            fprintf(fp, TYPE_ATR_FMT, ovp->pzName, typ);\n\n            /*\n             *  This is a magic incantation that will convert the\n             *  bit flag values back into a string suitable for printing.\n             */\n            (*(pOD->pOptProc))(OPTPROC_RETURN_VALNAME, pOD );\n            if (pOD->optArg.argString != NULL) {\n                fputs(pOD->optArg.argString, fp);\n\n                if (ovp->valType != OPARG_TYPE_ENUMERATION) {\n                    /*\n                     *  set membership strings get allocated\n                     */\n                    AGFREE(pOD->optArg.argString);\n                }\n            }\n\n            pOD->optArg.argEnum = val;\n            pOD->fOptState = opt_state;\n            fprintf(fp, END_XML_FMT, ovp->pzName);\n            break;\n        }\n        /* FALLTHROUGH */\n\n    case OPARG_TYPE_NUMERIC:\n        fprintf(fp, NUMB_ATR_FMT, ovp->pzName, ovp->v.longVal);\n        break;\n\n    case OPARG_TYPE_BOOLEAN:\n        fprintf(fp, BOOL_ATR_FMT, ovp->pzName,\n                ovp->v.boolVal ? \"true\" : \"false\");\n        break;\n\n    case OPARG_TYPE_HIERARCHY:\n        prt_val_list(fp, ovp->pzName, ovp->v.nestVal);\n        break;\n    }\n}",
      "lines": 63,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "prt_string": {
      "start_point": [
        407,
        0
      ],
      "end_point": [
        439,
        1
      ],
      "content": "static void\nprt_string(FILE * fp, char const * name, char const * pz)\n{\n    fprintf(fp, OPEN_XML_FMT, name);\n    for (;;) {\n        int ch = ((int)*(pz++)) & 0xFF;\n\n        switch (ch) {\n        case NUL: goto string_done;\n\n        case '&':\n        case '<':\n        case '>':\n#if __GNUC__ >= 4\n        case 1 ... (' ' - 1):\n        case ('~' + 1) ... 0xFF:\n#endif\n            emit_special_char(fp, ch);\n            break;\n\n        default:\n#if __GNUC__ < 4\n            if (  ((ch >= 1) && (ch <= (' ' - 1)))\n               || ((ch >= ('~' + 1)) && (ch <= 0xFF)) ) {\n                emit_special_char(fp, ch);\n                break;\n            }\n#endif\n            putc(ch, fp);\n        }\n    } string_done:;\n    fprintf(fp, END_XML_FMT, name);\n}",
      "lines": 33,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "prt_val_list": {
      "start_point": [
        443,
        0
      ],
      "end_point": [
        475,
        1
      ],
      "content": "static void\nprt_val_list(FILE * fp, char const * name, tArgList * al)\n{\n    static int depth = 1;\n\n    int sp_ct;\n    int opt_ct;\n    void ** opt_list;\n\n    if (al == NULL)\n        return;\n    opt_ct   = al->useCt;\n    opt_list = (void **)al->apzArgs;\n\n    if (opt_ct <= 0) {\n        fprintf(fp, OPEN_CLOSE_FMT, name);\n        return;\n    }\n\n    fprintf(fp, NESTED_OPT_FMT, name);\n\n    depth++;\n    while (--opt_ct >= 0) {\n        tOptionValue const * ovp = *(opt_list++);\n\n        prt_value(fp, depth, NULL, ovp);\n    }\n    depth--;\n\n    for (sp_ct = depth; --sp_ct >= 0;)\n        putc(' ', fp), putc(' ', fp);\n    fprintf(fp, \"</%s>\\n\", name);\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "prt_nested": {
      "start_point": [
        479,
        0
      ],
      "end_point": [
        512,
        1
      ],
      "content": "static void\nprt_nested(FILE * fp, tOptDesc * p)\n{\n    int opt_ct;\n    tArgList * al = p->optCookie;\n    void ** opt_list;\n\n    if (al == NULL)\n        return;\n\n    opt_ct   = al->useCt;\n    opt_list = (void **)al->apzArgs;\n\n    if (opt_ct <= 0)\n        return;\n\n    do  {\n        tOptionValue const * base = *(opt_list++);\n        tOptionValue const * ovp = optionGetValue(base, NULL);\n\n        if (ovp == NULL)\n            continue;\n\n        fprintf(fp, NESTED_OPT_FMT, p->pz_Name);\n\n        do  {\n            prt_value(fp, 1, p, ovp);\n\n        } while (ovp = optionNextValue(base, ovp),\n                 ovp != NULL);\n\n        fprintf(fp, \"</%s>\\n\", p->pz_Name);\n    } while (--opt_ct > 0);\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "open_sv_file": {
      "start_point": [
        520,
        0
      ],
      "end_point": [
        567,
        1
      ],
      "content": "static FILE *\nopen_sv_file(tOptions * opts)\n{\n    FILE * fp;\n\n    {\n        int   free_name = 0;\n        char const * pzFName = find_file_name(opts, &free_name);\n        if (pzFName == NULL)\n            return NULL;\n\n        fp = fopen(pzFName, \"w\" FOPEN_BINARY_FLAG);\n        if (fp == NULL) {\n            fprintf(stderr, zsave_warn, opts->pzProgName);\n            fprintf(stderr, zNoCreat, errno, strerror(errno), pzFName);\n            if (free_name)\n                AGFREE(pzFName);\n            return fp;\n        }\n\n        if (free_name)\n            AGFREE(pzFName);\n    }\n\n    fputs(\"#  \", fp);\n    {\n        char const * e = strchr(opts->pzUsageTitle, NL);\n        if (e++ != NULL)\n            fwrite(opts->pzUsageTitle, 1, e - opts->pzUsageTitle, fp);\n    }\n\n    {\n        time_t  cur_time = time(NULL);\n        char *  time_str = ctime(&cur_time);\n\n        fprintf(fp, zPresetFile, time_str);\n#ifdef HAVE_ALLOCATED_CTIME\n        /*\n         *  The return values for ctime(), localtime(), and gmtime()\n         *  normally point to static data that is overwritten by each call.\n         *  The test to detect allocated ctime, so we leak the memory.\n         */\n        AGFREE(time_str);\n#endif\n    }\n\n    return fp;\n}",
      "lines": 48,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "FILE",
        "*\nopen_sv_file(tOptions * opts)",
        "*"
      ]
    },
    "prt_no_arg_opt": {
      "start_point": [
        571,
        0
      ],
      "end_point": [
        590,
        1
      ],
      "content": "static void\nprt_no_arg_opt(FILE * fp, tOptDesc * p, tOptDesc * pOD)\n{\n    /*\n     * The aliased to argument indicates whether or not the option\n     * is \"disabled\".  However, the original option has the name\n     * string, so we get that there, not with \"p\".\n     */\n    char const * pznm =\n        (DISABLED_OPT(p)) ? pOD->pz_DisableName : pOD->pz_Name;\n    /*\n     *  If the option was disabled and the disablement name is NULL,\n     *  then the disablement was caused by aliasing.\n     *  Use the name as the string to emit.\n     */\n    if (pznm == NULL)\n        pznm = pOD->pz_Name;\n\n    fprintf(fp, \"%s\\n\", pznm);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "prt_str_arg": {
      "start_point": [
        594,
        0
      ],
      "end_point": [
        613,
        1
      ],
      "content": "static void\nprt_str_arg(FILE * fp, tOptDesc * pOD)\n{\n    if (pOD->fOptState & OPTST_STACKED) {\n        tArgList * pAL = (tArgList *)pOD->optCookie;\n        int        uct = pAL->useCt;\n        char const ** ppz = pAL->apzArgs;\n\n        /*\n         *  un-disable multiple copies of disabled options.\n         */\n        if (uct > 1)\n            pOD->fOptState &= ~OPTST_DISABLED;\n\n        while (uct-- > 0)\n            prt_entry(fp, pOD, *(ppz++));\n    } else {\n        prt_entry(fp, pOD, pOD->optArg.argString);\n    }\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "prt_enum_arg": {
      "start_point": [
        621,
        0
      ],
      "end_point": [
        634,
        1
      ],
      "content": "static void\nprt_enum_arg(FILE * fp, tOptDesc * od)\n{\n    uintptr_t val = od->optArg.argEnum;\n\n    /*\n     *  This is a magic incantation that will convert the\n     *  bit flag values back into a string suitable for printing.\n     */\n    (*(od->pOptProc))(OPTPROC_RETURN_VALNAME, od);\n    prt_entry(fp, od, VOIDP(od->optArg.argString));\n\n    od->optArg.argEnum = val;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "prt_set_arg": {
      "start_point": [
        645,
        0
      ],
      "end_point": [
        656,
        1
      ],
      "content": "static void\nprt_set_arg(FILE * fp, tOptDesc * od)\n{\n    char * list = optionMemberList(od);\n    size_t len  = strlen(list);\n    char * buf  = (char *)AGALOC(len + 3, \"dir name\");\n    *buf= '=';\n    memcpy(buf+1, list, len + 1);\n    prt_entry(fp, od, buf);\n    AGFREE(buf);\n    AGFREE(list);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "prt_file_arg": {
      "start_point": [
        666,
        0
      ],
      "end_point": [
        685,
        1
      ],
      "content": "static void\nprt_file_arg(FILE * fp, tOptDesc * od, tOptions * opts)\n{\n    /*\n     *  If the cookie is not NULL, then it has the file name, period.\n     *  Otherwise, if we have a non-NULL string argument, then....\n     */\n    if (od->optCookie != NULL)\n        prt_entry(fp, od, od->optCookie);\n\n    else if (HAS_originalOptArgArray(opts)) {\n        char const * orig =\n            opts->originalOptArgArray[od->optIndex].argString;\n\n        if (od->optArg.argString == orig)\n            return;\n\n        prt_entry(fp, od, od->optArg.argString);\n    }\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "optionSaveFile": {
      "start_point": [
        716,
        0
      ],
      "end_point": [
        800,
        1
      ],
      "content": "void\noptionSaveFile(tOptions * opts)\n{\n    tOptDesc *  od;\n    int         ct;\n    FILE *      fp = open_sv_file(opts);\n\n    if (fp == NULL)\n        return;\n\n    /*\n     *  FOR each of the defined options, ...\n     */\n    ct = opts->presetOptCt;\n    od = opts->pOptDesc;\n    do  {\n        tOptDesc * p;\n\n        /*\n         *  IF    the option has not been defined\n         *     OR it does not take an initialization value\n         *     OR it is equivalenced to another option\n         *  THEN continue (ignore it)\n         *\n         *  Equivalenced options get picked up when the equivalenced-to\n         *  option is processed.\n         */\n        if (UNUSED_OPT(od))\n            continue;\n\n        if ((od->fOptState & OPTST_DO_NOT_SAVE_MASK) != 0)\n            continue;\n\n        if (  (od->optEquivIndex != NO_EQUIVALENT)\n           && (od->optEquivIndex != od->optIndex))\n            continue;\n\n        /*\n         *  The option argument data are found at the equivalenced-to option,\n         *  but the actual option argument type comes from the original\n         *  option descriptor.  Be careful!\n         */\n        p = ((od->fOptState & OPTST_EQUIVALENCE) != 0)\n            ? (opts->pOptDesc + od->optActualIndex) : od;\n\n        switch (OPTST_GET_ARGTYPE(od->fOptState)) {\n        case OPARG_TYPE_NONE:\n            prt_no_arg_opt(fp, p, od);\n            break;\n\n        case OPARG_TYPE_NUMERIC:\n            prt_entry(fp, p, VOIDP(p->optArg.argInt));\n            break;\n\n        case OPARG_TYPE_STRING:\n            prt_str_arg(fp, p);\n            break;\n\n        case OPARG_TYPE_ENUMERATION:\n            prt_enum_arg(fp, p);\n            break;\n\n        case OPARG_TYPE_MEMBERSHIP:\n            prt_set_arg(fp, p);\n            break;\n\n        case OPARG_TYPE_BOOLEAN:\n            prt_entry(fp, p, p->optArg.argBool ? \"true\" : \"false\");\n            break;\n\n        case OPARG_TYPE_HIERARCHY:\n            prt_nested(fp, p);\n            break;\n\n        case OPARG_TYPE_FILE:\n            prt_file_arg(fp, p, opts);\n            break;\n\n        default:\n            break; /* cannot handle - skip it */\n        }\n    } while (od++, (--ct > 0));\n\n    fclose(fp);\n}",
      "lines": 85,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/sort.c": {
    "must_arg": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static tSuccess\nmust_arg(tOptions * opts, char * arg_txt, tOptState * pOS,\n         char ** opt_txt, uint32_t * opt_idx)\n{\n    /*\n     *  An option argument is required.  Long options can either have\n     *  a separate command line argument, or an argument attached by\n     *  the '=' character.  Figure out which.\n     */\n    switch (pOS->optType) {\n    case TOPT_SHORT:\n        /*\n         *  See if an arg string follows the flag character.  If not,\n         *  the next arg must be the option argument.\n         */\n        if (*arg_txt != NUL)\n            return SUCCESS;\n        break;\n\n    case TOPT_LONG:\n        /*\n         *  See if an arg string has already been assigned (glued on\n         *  with an `=' character).  If not, the next is the opt arg.\n         */\n        if (pOS->pzOptArg != NULL)\n            return SUCCESS;\n        break;\n\n    default:\n        return FAILURE;\n    }\n    if (opts->curOptIdx >= opts->origArgCt)\n        return FAILURE;\n\n    opt_txt[ (*opt_idx)++ ] = opts->origArgVect[ (opts->curOptIdx)++ ];\n    return SUCCESS;\n}",
      "lines": 37,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "tSuccess"
      ]
    },
    "maybe_arg": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "static tSuccess\nmaybe_arg(tOptions * opts, char * arg_txt, tOptState * pOS,\n          char ** opt_txt, uint32_t * opt_idx)\n{\n    /*\n     *  An option argument is optional.\n     */\n    switch (pOS->optType) {\n    case TOPT_SHORT:\n        /*\n         *  IF nothing is glued on after the current flag character,\n         *  THEN see if there is another argument.  If so and if it\n         *  does *NOT* start with a hyphen, then it is the option arg.\n         */\n        if (*arg_txt != NUL)\n            return SUCCESS;\n        break;\n\n    case TOPT_LONG:\n        /*\n         *  Look for an argument if we don't already have one (glued on\n         *  with a `=' character)\n         */\n        if (pOS->pzOptArg != NULL)\n            return SUCCESS;\n        break;\n\n    default:\n        return FAILURE;\n    }\n    if (opts->curOptIdx >= opts->origArgCt)\n        return PROBLEM;\n\n    arg_txt = opts->origArgVect[ opts->curOptIdx ];\n    if (*arg_txt != '-')\n        opt_txt[ (*opt_idx)++ ] = opts->origArgVect[ (opts->curOptIdx)++ ];\n    return SUCCESS;\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "tSuccess"
      ]
    },
    "short_opt_ck": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "static tSuccess\nshort_opt_ck(tOptions * opts, char * arg_txt, tOptState * pOS,\n             char ** opt_txt, uint32_t * opt_idx)\n{\n    while (*arg_txt != NUL) {\n        if (FAILED(opt_find_short(opts, (uint8_t)*arg_txt, pOS)))\n            return FAILURE;\n\n        /*\n         *  See if we can have an arg.\n         */\n        if (OPTST_GET_ARGTYPE(pOS->pOD->fOptState) == OPARG_TYPE_NONE) {\n            arg_txt++;\n\n        } else if (pOS->pOD->fOptState & OPTST_ARG_OPTIONAL) {\n            /*\n             *  Take an argument if it is not attached and it does not\n             *  start with a hyphen.\n             */\n            if (arg_txt[1] != NUL)\n                return SUCCESS;\n\n            arg_txt = opts->origArgVect[ opts->curOptIdx ];\n            if (*arg_txt != '-')\n                opt_txt[ (*opt_idx)++ ] =\n                    opts->origArgVect[ (opts->curOptIdx)++ ];\n            return SUCCESS;\n\n        } else {\n            /*\n             *  IF we need another argument, be sure it is there and\n             *  take it.\n             */\n            if (arg_txt[1] == NUL) {\n                if (opts->curOptIdx >= opts->origArgCt)\n                    return FAILURE;\n                opt_txt[ (*opt_idx)++ ] =\n                    opts->origArgVect[ (opts->curOptIdx)++ ];\n            }\n            return SUCCESS;\n        }\n    }\n    return SUCCESS;\n}",
      "lines": 44,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "tSuccess"
      ]
    },
    "optionSort": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        330,
        1
      ],
      "content": "LOCAL void\noptionSort(tOptions * opts)\n{\n    char **  opt_txt;\n    char **  ppzOpds;\n    uint32_t optsIdx = 0;\n    uint32_t opdsIdx = 0;\n\n    tOptState os = OPTSTATE_INITIALIZER(DEFINED);\n\n    /*\n     *  Disable for POSIX conformance, or if there are no operands.\n     */\n    if (  (getenv(\"POSIXLY_CORRECT\") != NULL)\n       || NAMED_OPTS(opts))\n        return;\n\n    /*\n     *  Make sure we can allocate two full-sized arg vectors.\n     */\n    opt_txt = malloc(opts->origArgCt * sizeof(char *));\n    if (opt_txt == NULL)\n        goto exit_no_mem;\n\n    ppzOpds = malloc(opts->origArgCt * sizeof(char *));\n    if (ppzOpds == NULL) {\n        free(opt_txt);\n        goto exit_no_mem;\n    }\n\n    opts->curOptIdx = 1;\n    opts->pzCurOpt  = NULL;\n\n    /*\n     *  Now, process all the options from our current position onward.\n     *  (This allows interspersed options and arguments for the few\n     *  non-standard programs that require it.)\n     */\n    for (;;) {\n        char * arg_txt;\n        tSuccess res;\n\n        /*\n         *  If we're out of arguments, we're done.  Join the option and\n         *  operand lists into the original argument vector.\n         */\n        if (opts->curOptIdx >= opts->origArgCt) {\n            errno = 0;\n            goto joinLists;\n        }\n\n        arg_txt = opts->origArgVect[ opts->curOptIdx ];\n        if (*arg_txt != '-') {\n            ppzOpds[ opdsIdx++ ] = opts->origArgVect[ (opts->curOptIdx)++ ];\n            continue;\n        }\n\n        switch (arg_txt[1]) {\n        case NUL:\n            /*\n             *  A single hyphen is an operand.\n             */\n            ppzOpds[ opdsIdx++ ] = opts->origArgVect[ (opts->curOptIdx)++ ];\n            continue;\n\n        case '-':\n            /*\n             *  Two consecutive hypens.  Put them on the options list and then\n             *  _always_ force the remainder of the arguments to be operands.\n             */\n            if (arg_txt[2] == NUL) {\n                opt_txt[ optsIdx++ ] =\n                    opts->origArgVect[ (opts->curOptIdx)++ ];\n                goto restOperands;\n            }\n            res = opt_find_long(opts, arg_txt+2, &os);\n            break;\n\n        default:\n            /*\n             *  If short options are not allowed, then do long\n             *  option processing.  Otherwise the character must be a\n             *  short (i.e. single character) option.\n             */\n            if ((opts->fOptSet & OPTPROC_SHORTOPT) == 0) {\n                res = opt_find_long(opts, arg_txt+1, &os);\n            } else {\n                res = opt_find_short(opts, (uint8_t)arg_txt[1], &os);\n            }\n            break;\n        }\n        if (FAILED(res)) {\n            errno = EINVAL;\n            goto freeTemps;\n        }\n\n        /*\n         *  We've found an option.  Add the argument to the option list.\n         *  Next, we have to see if we need to pull another argument to be\n         *  used as the option argument.\n         */\n        opt_txt[ optsIdx++ ] = opts->origArgVect[ (opts->curOptIdx)++ ];\n\n        if (OPTST_GET_ARGTYPE(os.pOD->fOptState) == OPARG_TYPE_NONE) {\n            /*\n             *  No option argument.  If we have a short option here,\n             *  then scan for short options until we get to the end\n             *  of the argument string.\n             */\n            if (  (os.optType == TOPT_SHORT)\n               && FAILED(short_opt_ck(opts, arg_txt+2, &os, opt_txt,\n                                      &optsIdx)) )  {\n                errno = EINVAL;\n                goto freeTemps;\n            }\n\n        } else if (os.pOD->fOptState & OPTST_ARG_OPTIONAL) {\n            switch (maybe_arg(opts, arg_txt+2, &os, opt_txt, &optsIdx)) {\n            case FAILURE: errno = EIO; goto freeTemps;\n            case PROBLEM: errno = 0;   goto joinLists;\n            }\n\n        } else {\n            switch (must_arg(opts, arg_txt+2, &os, opt_txt, &optsIdx)) {\n            case PROBLEM:\n            case FAILURE: errno = EIO; goto freeTemps;\n            }\n        }\n    } /* for (;;) */\n\n restOperands:\n    while (opts->curOptIdx < opts->origArgCt)\n        ppzOpds[ opdsIdx++ ] = opts->origArgVect[ (opts->curOptIdx)++ ];\n\n joinLists:\n    if (optsIdx > 0)\n        memcpy(opts->origArgVect + 1, opt_txt,\n               (size_t)optsIdx * sizeof(char *));\n    if (opdsIdx > 0)\n        memcpy(opts->origArgVect + 1 + optsIdx, ppzOpds,\n               (size_t)opdsIdx * sizeof(char *));\n\n freeTemps:\n    free(opt_txt);\n    free(ppzOpds);\n    return;\n\n exit_no_mem:\n    errno = ENOMEM;\n    return;\n}",
      "lines": 151,
      "depth": 16,
      "decorators": [
        "LOCAL",
        "void",
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/stack.c": {
    "optionUnstackArg": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "void\noptionUnstackArg(tOptions * opts, tOptDesc * od)\n{\n    tArgList * arg_list;\n\n    if (INQUERY_CALL(opts, od))\n        return;\n\n    arg_list = (tArgList *)od->optCookie;\n\n    /*\n     *  IF we don't have any stacked options,\n     *  THEN indicate that we don't have any of these options\n     */\n    if (arg_list == NULL) {\n        od->fOptState &= OPTST_PERSISTENT_MASK;\n        if ((od->fOptState & OPTST_INITENABLED) == 0)\n            od->fOptState |= OPTST_DISABLED;\n        return;\n    }\n\n#ifdef WITH_LIBREGEX\n    {\n        regex_t   re;\n        int       i, ct, dIdx;\n\n        if (regcomp(&re, od->optArg.argString, REG_NOSUB) != 0)\n            return;\n\n        /*\n         *  search the list for the entry(s) to remove.  Entries that\n         *  are removed are *not* copied into the result.  The source\n         *  index is incremented every time.  The destination only when\n         *  we are keeping a define.\n         */\n        for (i = 0, dIdx = 0, ct = arg_list->useCt; --ct >= 0; i++) {\n            char const * pzSrc = arg_list->apzArgs[ i ];\n            char *       pzEq  = strchr(pzSrc, '=');\n            int          res;\n\n\n            if (pzEq != NULL)\n                *pzEq = NUL;\n\n            res = regexec(&re, pzSrc, (size_t)0, NULL, 0);\n            switch (res) {\n            case 0:\n                /*\n                 *  Remove this entry by reducing the in-use count\n                 *  and *not* putting the string pointer back into\n                 *  the list.\n                 */\n                AGFREE(pzSrc);\n                arg_list->useCt--;\n                break;\n\n            default:\n            case REG_NOMATCH:\n                if (pzEq != NULL)\n                    *pzEq = '=';\n\n                /*\n                 *  IF we have dropped an entry\n                 *  THEN we have to move the current one.\n                 */\n                if (dIdx != i)\n                    arg_list->apzArgs[ dIdx ] = pzSrc;\n                dIdx++;\n            }\n        }\n\n        regfree(&re);\n    }\n#else  /* not WITH_LIBREGEX */\n    {\n        int i, ct, dIdx;\n\n        /*\n         *  search the list for the entry(s) to remove.  Entries that\n         *  are removed are *not* copied into the result.  The source\n         *  index is incremented every time.  The destination only when\n         *  we are keeping a define.\n         */\n        for (i = 0, dIdx = 0, ct = arg_list->useCt; --ct >= 0; i++) {\n            const char * pzSrc = arg_list->apzArgs[ i ];\n            char *       pzEq  = strchr(pzSrc, '=');\n\n            if (pzEq != NULL)\n                *pzEq = NUL;\n\n            if (strcmp(pzSrc, od->optArg.argString) == 0) {\n                /*\n                 *  Remove this entry by reducing the in-use count\n                 *  and *not* putting the string pointer back into\n                 *  the list.\n                 */\n                AGFREE(pzSrc);\n                arg_list->useCt--;\n            } else {\n                if (pzEq != NULL)\n                    *pzEq = '=';\n\n                /*\n                 *  IF we have dropped an entry\n                 *  THEN we have to move the current one.\n                 */\n                if (dIdx != i)\n                    arg_list->apzArgs[ dIdx ] = pzSrc;\n                dIdx++;\n            }\n        }\n    }\n#endif /* WITH_LIBREGEX */\n    /*\n     *  IF we have unstacked everything,\n     *  THEN indicate that we don't have any of these options\n     */\n    if (arg_list->useCt == 0) {\n        od->fOptState &= OPTST_PERSISTENT_MASK;\n        if ((od->fOptState & OPTST_INITENABLED) == 0)\n            od->fOptState |= OPTST_DISABLED;\n        AGFREE(arg_list);\n        od->optCookie = NULL;\n    }\n}",
      "lines": 125,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "addArgListEntry": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "LOCAL void\naddArgListEntry(void ** ppAL, void * entry)\n{\n    tArgList * pAL = *(void **)ppAL;\n\n    /*\n     *  IF we have never allocated one of these,\n     *  THEN allocate one now\n     */\n    if (pAL == NULL) {\n        pAL = (tArgList *)AGALOC(sizeof(*pAL), \"new option arg stack\");\n        if (pAL == NULL)\n            return;\n        pAL->useCt   = 0;\n        pAL->allocCt = MIN_ARG_ALLOC_CT;\n        *ppAL = VOIDP(pAL);\n    }\n\n    /*\n     *  ELSE if we are out of room\n     *  THEN make it bigger\n     */\n    else if (pAL->useCt >= pAL->allocCt) {\n        size_t sz = sizeof(*pAL);\n        pAL->allocCt += INCR_ARG_ALLOC_CT;\n\n        /*\n         *  The base structure contains space for MIN_ARG_ALLOC_CT\n         *  pointers.  We subtract it off to find our augment size.\n         */\n        sz += sizeof(char *) * ((size_t)pAL->allocCt - MIN_ARG_ALLOC_CT);\n        pAL = (tArgList *)AGREALOC(VOIDP(pAL), sz, \"expanded opt arg stack\");\n        if (pAL == NULL)\n            return;\n        *ppAL = VOIDP(pAL);\n    }\n\n    /*\n     *  Insert the new argument into the list\n     */\n    pAL->apzArgs[ (pAL->useCt)++ ] = entry;\n}",
      "lines": 42,
      "depth": 15,
      "decorators": [
        "LOCAL",
        "void",
        "void"
      ]
    },
    "optionStackArg": {
      "start_point": [
        232,
        0
      ],
      "end_point": [
        258,
        1
      ],
      "content": "void\noptionStackArg(tOptions * opts, tOptDesc * od)\n{\n    char * pz;\n\n    if (INQUERY_CALL(opts, od))\n        return;\n\n    if ((od->fOptState & OPTST_RESET) != 0) {\n        tArgList * arg_list = od->optCookie;\n        int ix;\n        if (arg_list == NULL)\n            return;\n\n        ix = arg_list->useCt;\n        while (--ix >= 0)\n            AGFREE(arg_list->apzArgs[ix]);\n        AGFREE(arg_list);\n\n    } else {\n        if (od->optArg.argString == NULL)\n            return;\n\n        AGDUPSTR(pz, od->optArg.argString, \"stack arg\");\n        addArgListEntry(&(od->optCookie), VOIDP(pz));\n    }\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/stdnoreturn.in.h": {},
  "sharutils/sharutils-4.15.2/libopts/streqvcmp.c": {
    "strneqvcmp": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "int\nstrneqvcmp(char const * s1, char const * s2, int ct)\n{\n    for (; ct > 0; --ct) {\n        unsigned char u1 = (unsigned char) *s1++;\n        unsigned char u2 = (unsigned char) *s2++;\n        int dif;\n        if (u1 == u2) {\n            if (u1 == NUL)\n                return 0;\n            continue;\n        }\n\n        dif = charmap[ u1 ] - charmap[ u2 ];\n\n        if (dif != 0)\n            return dif;\n\n        if (u1 == NUL)\n            return 0;\n    }\n\n    return 0;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "streqvcmp": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "int\nstreqvcmp(char const * s1, char const * s2)\n{\n    for (;;) {\n        unsigned char u1 = (unsigned char) *s1++;\n        unsigned char u2 = (unsigned char) *s2++;\n        int dif;\n        if (u1 == u2) {\n            if (u1 == NUL)\n                return 0;\n            continue;\n        }\n\n        dif = charmap[ u1 ] - charmap[ u2 ];\n\n        if (dif != 0)\n            return dif;\n\n        if (u1 == NUL)\n            return 0;\n    }\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "streqvmap": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "void\nstreqvmap(char from, char to, int ct)\n{\n    if (ct == 0) {\n        ct = sizeof(charmap) - 1;\n        do  {\n            charmap[ct] = (unsigned char)ct;\n        } while (--ct >= 0);\n    }\n\n    else {\n        unsigned int i_to   = (int)to   & 0xFF;\n        unsigned int i_from = (int)from & 0xFF;\n\n        do  {\n            charmap[i_from] = (unsigned char)i_to;\n            i_from++;\n            i_to++;\n            if ((i_from >= sizeof(charmap)) || (i_to >= sizeof(charmap)))\n                break;\n        } while (--ct > 0);\n    }\n}",
      "lines": 23,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "strequate": {
      "start_point": [
        239,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "void\nstrequate(char const * s)\n{\n    if ((s != NULL) && (*s != NUL)) {\n        unsigned char equiv = (unsigned char)*s;\n        while (*s != NUL)\n            charmap[(unsigned char)*(s++)] = equiv;\n    }\n}",
      "lines": 9,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "strtransform": {
      "start_point": [
        268,
        0
      ],
      "end_point": [
        274,
        1
      ],
      "content": "void\nstrtransform(char * d, char const * s)\n{\n    do  {\n        *(d++) = (char)charmap[(unsigned char)*s];\n    } while (*(s++) != NUL);\n}",
      "lines": 7,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/text_mmap.c": {
    "load_text_file": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "static void\nload_text_file(tmap_info_t * mapinfo, char const * pzFile)\n{\n#if ! defined(HAVE_MMAP)\n    mapinfo->txt_data = AGALOC(mapinfo->txt_size+1, \"file text\");\n    if (mapinfo->txt_data == NULL) {\n        mapinfo->txt_errno = ENOMEM;\n        return;\n    }\n\n    {\n        size_t sz = mapinfo->txt_size;\n        char * pz = mapinfo->txt_data;\n\n        while (sz > 0) {\n            ssize_t rdct = read(mapinfo->txt_fd, pz, sz);\n            if (rdct <= 0) {\n                mapinfo->txt_errno = errno;\n                fserr_warn(\"libopts\", \"read\", pzFile);\n                free(mapinfo->txt_data);\n                return;\n            }\n\n            pz += rdct;\n            sz -= rdct;\n        }\n\n        *pz = NUL;\n    }\n\n    mapinfo->txt_errno   = 0;\n\n#else /* HAVE mmap */\n    size_t const pgsz = (size_t)GETPAGESIZE();\n    void * map_addr   = NULL;\n\n    (void)pzFile;\n\n    mapinfo->txt_full_size = (mapinfo->txt_size + pgsz) & ~(pgsz - 1);\n    if (mapinfo->txt_full_size == (mapinfo->txt_size + pgsz)) {\n        /*\n         * The text is a multiple of a page boundary.  We must map an\n         * extra page so the text ends with a NUL.\n         */\n#if defined(MAP_ANONYMOUS)\n        map_addr = mmap(NULL, mapinfo->txt_full_size, PROT_READ|PROT_WRITE,\n                        MAP_ANONYMOUS|MAP_PRIVATE, AO_INVALID_FD, 0);\n#else\n        mapinfo->txt_zero_fd = open(\"/dev/zero\", O_RDONLY);\n\n        if (mapinfo->txt_zero_fd == AO_INVALID_FD) {\n            mapinfo->txt_errno = errno;\n            return;\n        }\n        map_addr = mmap(NULL, mapinfo->txt_full_size, PROT_READ|PROT_WRITE,\n                        MAP_PRIVATE, mapinfo->txt_zero_fd, 0);\n#endif\n        if (map_addr == MAP_FAILED_PTR) {\n            mapinfo->txt_errno = errno;\n            return;\n        }\n        mapinfo->txt_flags |= MAP_FIXED;\n    }\n\n    mapinfo->txt_data =\n        mmap(map_addr, mapinfo->txt_size, mapinfo->txt_prot,\n             mapinfo->txt_flags, mapinfo->txt_fd, 0);\n\n    if (mapinfo->txt_data == MAP_FAILED_PTR)\n        mapinfo->txt_errno = errno;\n#endif /* HAVE_MMAP */\n}",
      "lines": 72,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "validate_mmap": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "static void\nvalidate_mmap(char const * fname, int prot, int flags, tmap_info_t * mapinfo)\n{\n    memset(mapinfo, 0, sizeof(*mapinfo));\n#if defined(HAVE_MMAP) && ! defined(MAP_ANONYMOUS)\n    mapinfo->txt_zero_fd = AO_INVALID_FD;\n#endif\n    mapinfo->txt_fd      = AO_INVALID_FD;\n    mapinfo->txt_prot    = prot;\n    mapinfo->txt_flags   = flags;\n\n    /*\n     *  Map mmap flags and protections into open flags and do the open.\n     */\n    {\n        /*\n         *  See if we will be updating the file.  If we can alter the memory\n         *  and if we share the data and we are *not* copy-on-writing the data,\n         *  then our updates will show in the file, so we must open with\n         *  write access.\n         */\n        int o_flag = FILE_WRITABLE(prot, flags) ? O_RDWR : O_RDONLY;\n\n        /*\n         *  If you're not sharing the file and you are writing to it,\n         *  then don't let anyone else have access to the file.\n         */\n        if (((flags & MAP_SHARED) == 0) && (prot & PROT_WRITE))\n            o_flag |= O_EXCL;\n\n        mapinfo->txt_fd = open(fname, o_flag);\n        if (mapinfo->txt_fd < 0) {\n            mapinfo->txt_errno = errno;\n            mapinfo->txt_fd = AO_INVALID_FD;\n            return;\n        }\n    }\n\n    /*\n     *  Make sure we can stat the regular file.  Save the file size.\n     */\n    {\n        struct stat sb;\n        if (fstat(mapinfo->txt_fd, &sb) != 0) {\n            mapinfo->txt_errno = errno;\n            close(mapinfo->txt_fd);\n            return;\n        }\n\n        if (! S_ISREG(sb.st_mode)) {\n            mapinfo->txt_errno = errno = EINVAL;\n            close(mapinfo->txt_fd);\n            return;\n        }\n\n        mapinfo->txt_size = (size_t)sb.st_size;\n    }\n\n    if (mapinfo->txt_fd == AO_INVALID_FD)\n        mapinfo->txt_errno = errno;\n}",
      "lines": 61,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "close_mmap_files": {
      "start_point": [
        233,
        0
      ],
      "end_point": [
        249,
        1
      ],
      "content": "static void\nclose_mmap_files(tmap_info_t * mi)\n{\n    if (mi->txt_fd == AO_INVALID_FD)\n        return;\n\n    close(mi->txt_fd);\n    mi->txt_fd = AO_INVALID_FD;\n\n#if defined(HAVE_MMAP) && ! defined(MAP_ANONYMOUS)\n    if (mi->txt_zero_fd == AO_INVALID_FD)\n        return;\n\n    close(mi->txt_zero_fd);\n    mi->txt_zero_fd = AO_INVALID_FD;\n#endif\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "text_mmap": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        321,
        1
      ],
      "content": "void *\ntext_mmap(char const * pzFile, int prot, int flags, tmap_info_t * mi)\n{\n    validate_mmap(pzFile, prot, flags, mi);\n    if (mi->txt_errno != 0)\n        return MAP_FAILED_PTR;\n\n    load_text_file(mi, pzFile);\n\n    if (mi->txt_errno == 0)\n        return mi->txt_data;\n\n    close_mmap_files(mi);\n\n    errno = mi->txt_errno;\n    mi->txt_data = MAP_FAILED_PTR;\n    return mi->txt_data;\n}",
      "lines": 18,
      "depth": 7,
      "decorators": [
        "void",
        "*\ntext_mmap(char const * pzFile, int prot, int flags, tmap_info_t * mi)",
        "*"
      ]
    },
    "text_munmap": {
      "start_point": [
        343,
        0
      ],
      "end_point": [
        369,
        1
      ],
      "content": "int\ntext_munmap(tmap_info_t * mi)\n{\n    errno = 0;\n\n#ifdef HAVE_MMAP\n    (void)munmap(mi->txt_data, mi->txt_full_size);\n\n#else  /* don't HAVE_MMAP */\n    /*\n     *  IF the memory is writable *AND* it is not private (copy-on-write)\n     *     *AND* the memory is \"sharable\" (seen by other processes)\n     *  THEN rewrite the data.  Emulate mmap visibility.\n     */\n    if (   FILE_WRITABLE(mi->txt_prot, mi->txt_flags)\n        && (lseek(mi->txt_fd, 0, SEEK_SET) >= 0) ) {\n        write(mi->txt_fd, mi->txt_data, mi->txt_size);\n    }\n\n    free(mi->txt_data);\n#endif /* HAVE_MMAP */\n\n    mi->txt_errno = errno;\n    close_mmap_files(mi);\n\n    return mi->txt_errno;\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/time.c": {
    "optionTimeVal": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "void\noptionTimeVal(tOptions * opts, tOptDesc * od)\n{\n    time_t val;\n\n    if (INQUERY_CALL(opts, od))\n        return;\n\n    val = parse_duration(od->optArg.argString);\n    if (val == BAD_TIME) {\n        fprintf(stderr, zNotDuration, opts->pzProgName, od->optArg.argString);\n        if ((opts->fOptSet & OPTPROC_ERRSTOP) != 0)\n            (*(opts->pUsageProc))(opts, EXIT_FAILURE);\n    }\n\n    if (od->fOptState & OPTST_ALLOC_ARG) {\n        AGFREE(od->optArg.argString);\n        od->fOptState &= ~OPTST_ALLOC_ARG;\n    }\n\n    od->optArg.argInt = (long)val;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "optionTimeDate": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "void\noptionTimeDate(tOptions * opts, tOptDesc * od)\n{\n#if defined(HAVE_GETDATE_R) && defined(HAVE_PUTENV)\n    if (INQUERY_CALL(opts, od))\n        return;\n\n    if ((! HAS_pzPkgDataDir(opts)) || (opts->pzPkgDataDir == NULL))\n        goto default_action;\n\n    /*\n     *  Export the DATEMSK environment variable.  getdate_r() uses it to\n     *  find the file with the strptime formats.  If we cannot find the file\n     *  we need ($PKGDATADIR/datemsk), then fall back to just a time duration.\n     */\n    {\n        static char * envptr = NULL;\n\n        if (envptr == NULL) {\n            static char const fmt[] = \"DATEMSK=%s/datemsk\";\n            envptr = AGALOC(sizeof(fmt) + strlen(opts->pzPkgDataDir), fmt);\n            sprintf(envptr, fmt, opts->pzPkgDataDir);\n\n            putenv(envptr);\n        }\n\n        if (access(envptr+8, R_OK) != 0)\n            goto default_action;\n    }\n\n    /*\n     *  Convert the date to a time since the epoch and stash it in a long int.\n     */\n    {\n        struct tm stm;\n        time_t tm;\n\n        if (getdate_r(od->optArg.argString, &stm) != 0) {\n            fprintf(stderr, zNotDate, opts->pzProgName,\n                    od->optArg.argString);\n            if ((opts->fOptSet & OPTPROC_ERRSTOP) != 0)\n                (*(opts->pUsageProc))(opts, EXIT_FAILURE);\n            return;\n        }\n\n        tm = mktime(&stm);\n\n        if (od->fOptState & OPTST_ALLOC_ARG) {\n            AGFREE(od->optArg.argString);\n            od->fOptState &= ~OPTST_ALLOC_ARG;\n        }\n\n        od->optArg.argInt = tm;\n    }\n    return;\n\n default_action:\n\n#endif\n    optionTimeVal(opts, od);\n    if (od->optArg.argInt != BAD_TIME)\n        od->optArg.argInt += (long)time(NULL);\n}",
      "lines": 63,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/tokenize.c": {
    "copy_cooked": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static void\ncopy_cooked(ch_t ** ppDest, char const ** ppSrc)\n{\n    ch_t * pDest = (ch_t *)*ppDest;\n    const ch_t * pSrc  = (const ch_t *)(*ppSrc + 1);\n\n    for (;;) {\n        ch_t ch = *(pSrc++);\n        switch (ch) {\n        case NUL:   *ppSrc = NULL; return;\n        case '\"':   goto done;\n        case '\\\\':\n            pSrc += ao_string_cook_escape_char((char *)pSrc, (char *)&ch, 0x7F);\n            if (ch == 0x7F)\n                break;\n            /* FALLTHROUGH */\n\n        default:\n            *(pDest++) = ch;\n        }\n    }\n\n done:\n    *ppDest = (ch_t *)pDest; /* next spot for storing character */\n    *ppSrc  = (char const *)pSrc;  /* char following closing quote    */\n}",
      "lines": 26,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "copy_raw": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "static void\ncopy_raw(ch_t ** ppDest, char const ** ppSrc)\n{\n    ch_t * pDest = *ppDest;\n    cc_t * pSrc  = (cc_t *) (*ppSrc + 1);\n\n    for (;;) {\n        ch_t ch = *(pSrc++);\n        switch (ch) {\n        case NUL:   *ppSrc = NULL; return;\n        case '\\'':  goto done;\n        case '\\\\':\n            /*\n             *  *Four* escapes are handled:  newline removal, escape char\n             *  quoting and apostrophe quoting\n             */\n            switch (*pSrc) {\n            case NUL:   *ppSrc = NULL; return;\n            case '\\r':\n                if (*(++pSrc) == NL)\n                    ++pSrc;\n                continue;\n\n            case NL:\n                ++pSrc;\n                continue;\n\n            case '\\'':\n                ch = '\\'';\n                /* FALLTHROUGH */\n\n            case '\\\\':\n                ++pSrc;\n                break;\n            }\n            /* FALLTHROUGH */\n\n        default:\n            *(pDest++) = ch;\n        }\n    }\n\n done:\n    *ppDest = pDest; /* next spot for storing character */\n    *ppSrc  = (char const *) pSrc;  /* char following closing quote    */\n}",
      "lines": 46,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "alloc_token_list": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "static token_list_t *\nalloc_token_list(char const * str)\n{\n    token_list_t * res;\n\n    int max_token_ct = 2; /* allow for trailing NULL pointer & NUL on string */\n\n    if (str == NULL) goto enoent_res;\n\n    /*\n     *  Trim leading white space.  Use \"ENOENT\" and a NULL return to indicate\n     *  an empty string was passed.\n     */\n    str = SPN_WHITESPACE_CHARS(str);\n    if (*str == NUL)  goto enoent_res;\n\n    /*\n     *  Take an approximate count of tokens.  If no quoted strings are used,\n     *  it will be accurate.  If quoted strings are used, it will be a little\n     *  high and we'll squander the space for a few extra pointers.\n     */\n    {\n        char const * pz = str;\n\n        do {\n            max_token_ct++;\n            pz = BRK_WHITESPACE_CHARS(pz+1);\n            pz = SPN_WHITESPACE_CHARS(pz);\n        } while (*pz != NUL);\n\n        res = malloc(sizeof(*res) + (size_t)(pz - str)\n                     + ((size_t)max_token_ct * sizeof(ch_t *)));\n    }\n\n    if (res == NULL)\n        errno = ENOMEM;\n    else res->tkn_list[0] = (ch_t *)(res->tkn_list + (max_token_ct - 1));\n\n    return res;\n\n    enoent_res:\n\n    errno = ENOENT;\n    return NULL;\n}",
      "lines": 45,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "token_list_t",
        "*\nalloc_token_list(char const * str)",
        "*"
      ]
    },
    "ao_string_tokenize": {
      "start_point": [
        233,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "token_list_t *\nao_string_tokenize(char const * str)\n{\n    token_list_t * res = alloc_token_list(str);\n    ch_t * pzDest;\n\n    /*\n     *  Now copy each token into the output buffer.\n     */\n    if (res == NULL)\n        return res;\n\n    pzDest = (ch_t *)(res->tkn_list[0]);\n    res->tkn_ct  = 0;\n\n    do  {\n        res->tkn_list[ res->tkn_ct++ ] = pzDest;\n        for (;;) {\n            int ch = (ch_t)*str;\n            if (IS_WHITESPACE_CHAR(ch)) {\n            found_white_space:\n                str = SPN_WHITESPACE_CHARS(str+1);\n                break;\n            }\n\n            switch (ch) {\n            case '\"':\n                copy_cooked(&pzDest, &str);\n                if (str == NULL) {\n                    free(res);\n                    errno = EINVAL;\n                    return NULL;\n                }\n                if (IS_WHITESPACE_CHAR(*str))\n                    goto found_white_space;\n                break;\n\n            case '\\'':\n                copy_raw(&pzDest, &str);\n                if (str == NULL) {\n                    free(res);\n                    errno = EINVAL;\n                    return NULL;\n                }\n                if (IS_WHITESPACE_CHAR(*str))\n                    goto found_white_space;\n                break;\n\n            case NUL:\n                goto copy_done;\n\n            default:\n                str++;\n                *(pzDest++) = (unsigned char)ch;\n            }\n        } copy_done:;\n\n        /*\n         * NUL terminate the last token and see if we have any more tokens.\n         */\n        *(pzDest++) = NUL;\n    } while (*str != NUL);\n\n    res->tkn_list[ res->tkn_ct ] = NULL;\n\n    return res;\n}",
      "lines": 67,
      "depth": 15,
      "decorators": [
        "token_list_t",
        "*\nao_string_tokenize(char const * str)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        305,
        0
      ],
      "end_point": [
        328,
        1
      ],
      "content": "int\nmain(int argc, char ** argv)\n{\n    if (argc == 1) {\n        printf(\"USAGE:  %s arg [ ... ]\\n\", *argv);\n        return 1;\n    }\n    while (--argc > 0) {\n        char * arg = *(++argv);\n        token_list_t * p = ao_string_tokenize(arg);\n        if (p == NULL) {\n            printf(\"Parsing string ``%s'' failed:\\n\\terrno %d (%s)\\n\",\n                   arg, errno, strerror(errno));\n        } else {\n            int ix = 0;\n            printf(\"Parsed string ``%s''\\ninto %d tokens:\\n\", arg, p->tkn_ct);\n            do {\n                printf(\" %3d:  ``%s''\\n\", ix+1, p->tkn_list[ix]);\n            } while (++ix < p->tkn_ct);\n            free(p);\n        }\n    }\n    return 0;\n}",
      "lines": 24,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/usage.c": {
    "parse_usage_flags": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "static unsigned int\nparse_usage_flags(ao_flag_names_t const * fnt, char const * txt)\n{\n    unsigned int res = 0;\n\n    /*\n     * The text may be passed in.  If not, use the environment variable.\n     */\n    if (txt == NULL) {\n        txt = getenv(\"AUTOOPTS_USAGE\");\n        if (txt == NULL)\n            return 0;\n    }\n\n    txt = SPN_WHITESPACE_CHARS(txt);\n    if (*txt == NUL)\n        return 0;\n\n    /*\n     * search the string for table entries.  We must understand everything\n     * we see in the string, or we give up on it.\n     */\n    for (;;) {\n        int ix = 0;\n\n        for (;;) {\n            if (strneqvcmp(txt, fnt[ix].fnm_name, (int)fnt[ix].fnm_len) == 0)\n                break;\n            if (++ix >= AOUF_COUNT)\n                return 0;\n        }\n\n        /*\n         *  Make sure we have a full match.  Look for whitespace,\n         *  a comma, or a NUL byte.\n         */\n        if (! IS_END_LIST_ENTRY_CHAR(txt[fnt[ix].fnm_len]))\n            return 0;\n\n        res |= 1U << ix;\n        txt = SPN_WHITESPACE_CHARS(txt + fnt[ix].fnm_len);\n\n        switch (*txt) {\n        case NUL:\n            return res;\n\n        case ',':\n            txt = SPN_WHITESPACE_CHARS(txt + 1);\n            /* Something must follow the comma */\n\n        default:\n            continue;\n        }\n    }\n}",
      "lines": 55,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "set_usage_flags": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        216,
        1
      ],
      "content": "LOCAL void\nset_usage_flags(tOptions * opts, char const * flg_txt)\n{\n#   define _aof_(_n, _f)   { sizeof(#_n)-1, _f, #_n },\n    static ao_flag_names_t const fn_table[AOUF_COUNT] = {\n        AOFLAG_TABLE\n    };\n#   undef  _aof_\n\n    /*\n     * the flag word holds a bit for each selected table entry.\n     */\n    unsigned int flg = parse_usage_flags(fn_table, flg_txt);\n    if (flg == 0) return;\n\n    /*\n     * Ensure we do not have conflicting selections\n     */\n    {\n        static unsigned int const form_mask =\n            AOUF_gnu | AOUF_autoopts;\n        static unsigned int const misuse_mask =\n            AOUF_no_misuse_usage | AOUF_misuse_usage;\n        if (  ((flg & form_mask)   == form_mask)\n           || ((flg & misuse_mask) == misuse_mask) )\n            return;\n    }\n\n    /*\n     * Now fiddle the fOptSet bits, based on settings.\n     * The OPTPROC_LONGOPT bit is immutable, thus if it is set,\n     * then fnm points to a mask off mask.\n     */\n    {\n        ao_flag_names_t const * fnm = fn_table;\n        for (;;) {\n            if ((flg & 1) != 0) {\n                if ((fnm->fnm_mask & OPTPROC_LONGOPT) != 0)\n                     opts->fOptSet &= fnm->fnm_mask;\n                else opts->fOptSet |= fnm->fnm_mask;\n            }\n            flg >>= 1;\n            if (flg == 0)\n                break;\n            fnm++;\n        }\n    }\n}",
      "lines": 48,
      "depth": 14,
      "decorators": [
        "LOCAL",
        "void",
        "void"
      ]
    },
    "do_gnu_usage": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "static inline bool\ndo_gnu_usage(tOptions * pOpts)\n{\n    return (pOpts->fOptSet & OPTPROC_GNUUSAGE) ? true : false;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "bool"
      ]
    },
    "skip_misuse_usage": {
      "start_point": [
        232,
        0
      ],
      "end_point": [
        236,
        1
      ],
      "content": "static inline bool\nskip_misuse_usage(tOptions * pOpts)\n{\n    return (pOpts->fOptSet & OPTPROC_MISUSE) ? true : false;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "bool"
      ]
    },
    "optionOnlyUsage": {
      "start_point": [
        250,
        0
      ],
      "end_point": [
        274,
        1
      ],
      "content": "void\noptionOnlyUsage(tOptions * pOpts, int ex_code)\n{\n    char const * pOptTitle = NULL;\n\n    set_usage_flags(pOpts, NULL);\n    if ((ex_code != EXIT_SUCCESS) &&\n        skip_misuse_usage(pOpts))\n        return;\n\n    /*\n     *  Determine which header and which option formatting strings to use\n     */\n    if (do_gnu_usage(pOpts))\n        (void)setGnuOptFmts(pOpts, &pOptTitle);\n    else\n        (void)setStdOptFmts(pOpts, &pOptTitle);\n\n    prt_opt_usage(pOpts, ex_code, pOptTitle);\n\n    fflush(option_usage_fp);\n    if (ferror(option_usage_fp) != 0)\n        fserr_exit(pOpts->pzProgName, zwriting, (option_usage_fp == stderr)\n                   ? zstderr_name : zstdout_name);\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "print_offer_usage": {
      "start_point": [
        281,
        0
      ],
      "end_point": [
        330,
        1
      ],
      "content": "static void\nprint_offer_usage(tOptions * opts)\n{\n    char help[24];\n\n    if (HAS_opt_usage_t(opts)) {\n        int ix = opts->presetOptCt;\n        tOptDesc * od = opts->pOptDesc + ix;\n        while (od->optUsage != AOUSE_HELP) {\n            if (++ix >= opts->optCt)\n                ao_bug(zmissing_help_msg);\n            od++;\n        }\n        switch (opts->fOptSet & (OPTPROC_LONGOPT | OPTPROC_SHORTOPT)) {\n        case OPTPROC_SHORTOPT:\n            help[0] = '-';\n            help[1] = od->optValue;\n            help[2] = NUL;\n            break;\n\n        case OPTPROC_LONGOPT:\n        case (OPTPROC_LONGOPT | OPTPROC_SHORTOPT):\n            help[0] = help[1] = '-';\n            strncpy(help + 2, od->pz_Name, 20);\n            break;\n        \n        case 0:\n            strncpy(help, od->pz_Name, 20);\n            break;\n        }\n\n    } else {\n        switch (opts->fOptSet & (OPTPROC_LONGOPT | OPTPROC_SHORTOPT)) {\n        case OPTPROC_SHORTOPT:\n            strcpy(help, \"-h\");\n            break;\n\n        case OPTPROC_LONGOPT:\n        case (OPTPROC_LONGOPT | OPTPROC_SHORTOPT):\n            strcpy(help, \"--help\");\n            break;\n        \n        case 0:\n            strcpy(help, \"help\");\n            break;\n        }\n    }\n\n    fprintf(option_usage_fp, zoffer_usage_fmt, opts->pzProgName, help);\n}",
      "lines": 50,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_usage_details": {
      "start_point": [
        339,
        0
      ],
      "end_point": [
        415,
        1
      ],
      "content": "static void\nprint_usage_details(tOptions * opts, int exit_code)\n{\n    {\n        char const * pOptTitle = NULL;\n        int flen;\n\n        /*\n         *  Determine which header and which option formatting strings to use\n         */\n        if (do_gnu_usage(opts)) {\n            flen = setGnuOptFmts(opts, &pOptTitle);\n            sprintf(line_fmt_buf, zFmtFmt, flen);\n            fputc(NL, option_usage_fp);\n        }\n        else {\n            flen = setStdOptFmts(opts, &pOptTitle);\n            sprintf(line_fmt_buf, zFmtFmt, flen);\n\n            /*\n             *  When we exit with EXIT_SUCCESS and the first option is a doc\n             *  option, we do *NOT* want to emit the column headers.\n             *  Otherwise, we do.\n             */\n            if (  (exit_code != EXIT_SUCCESS)\n               || ((opts->pOptDesc->fOptState & OPTST_DOCUMENT) == 0) )\n\n                fputs(pOptTitle, option_usage_fp);\n        }\n\n        flen = 4 - ((flen + 15) / 8);\n        if (flen > 0)\n            tab_skip_ct = flen;\n        prt_opt_usage(opts, exit_code, pOptTitle);\n    }\n\n    /*\n     *  Describe the mechanics of denoting the options\n     */\n    switch (opts->fOptSet & OPTPROC_L_N_S) {\n    case OPTPROC_L_N_S:     fputs(zFlagOkay, option_usage_fp); break;\n    case OPTPROC_SHORTOPT:  break;\n    case OPTPROC_LONGOPT:   fputs(zNoFlags,  option_usage_fp); break;\n    case 0:                 fputs(zOptsOnly, option_usage_fp); break;\n    }\n\n    if ((opts->fOptSet & OPTPROC_NUM_OPT) != 0)\n        fputs(zNumberOpt, option_usage_fp);\n\n    if ((opts->fOptSet & OPTPROC_REORDER) != 0)\n        fputs(zReorder, option_usage_fp);\n\n    if (opts->pzExplain != NULL)\n        fputs(opts->pzExplain, option_usage_fp);\n\n    /*\n     *  IF the user is asking for help (thus exiting with SUCCESS),\n     *  THEN see what additional information we can provide.\n     */\n    if (exit_code == EXIT_SUCCESS)\n        prt_prog_detail(opts);\n\n    /*\n     * Give bug notification preference to the packager information\n     */\n    if (HAS_pzPkgDataDir(opts) && (opts->pzPackager != NULL))\n        fputs(opts->pzPackager, option_usage_fp);\n\n    else if (opts->pzBugAddr != NULL)\n        fprintf(option_usage_fp, zPlsSendBugs, opts->pzBugAddr);\n\n    fflush(option_usage_fp);\n\n    if (ferror(option_usage_fp) != 0)\n        fserr_exit(opts->pzProgName, zwriting, (option_usage_fp == stderr)\n                   ? zstderr_name : zstdout_name);\n}",
      "lines": 77,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_one_paragraph": {
      "start_point": [
        417,
        0
      ],
      "end_point": [
        439,
        1
      ],
      "content": "static void\nprint_one_paragraph(char const * text, bool plain, FILE * fp)\n{\n    if (plain) {\n#ifdef ENABLE_NLS\n#ifdef HAVE_LIBINTL_H\n#ifdef DEBUG_ENABLED\n#undef gettext\n#endif\n        char * buf = dgettext(\"libopts\", text);\n        if (buf == text)\n            text = gettext(text);\n#endif /* HAVE_LIBINTL_H */\n#endif /* ENABLE_NLS */\n        fputs(text, fp);\n    }\n\n    else {\n        char const * t = optionQuoteString(text, LINE_SPLICE);\n        fprintf(fp, PUTS_FMT, t);\n        AGFREE(t);\n    }\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "optionPrintParagraphs": {
      "start_point": [
        465,
        0
      ],
      "end_point": [
        549,
        1
      ],
      "content": "void\noptionPrintParagraphs(char const * text, bool plain, FILE * fp)\n{\n    size_t len = strlen(text);\n    char * buf;\n#ifndef ENABLE_NLS\n    if (plain || (len < 256))\n#else\n    if (len < 256)\n#endif\n    {\n        print_one_paragraph(text, plain, fp);\n        return;\n    }\n\n    AGDUPSTR(buf, text, \"ppara\");\n    text = buf;\n\n    for (;;) {\n        char * scan;\n\n        if (len < 256) {\n        done:\n            print_one_paragraph(buf, plain, fp);\n            break;\n        }\n        scan = buf;\n\n    try_longer:\n        scan = strchr(scan, NL);\n        if (scan == NULL)\n            goto done;\n\n        if ((scan - buf) < 40) {\n            scan++;\n            goto try_longer;\n        }\n\n        scan++;\n        if ((! isspace((int)*scan)) || (*scan == HT))\n            /*\n             * line starts with tab or non-whitespace --> continuation\n             */\n            goto try_longer;\n\n        if (*scan == NL) {\n            /*\n             * Double newline -> paragraph break\n             * Include all newlines in current paragraph.\n             */\n            while (*++scan == NL)  /*continue*/;\n\n        } else {\n            char * p = scan;\n            int   sp_ct = 0;\n\n            while (*p == ' ') {\n                if (++sp_ct >= 8) {\n                    /*\n                     * Too many spaces --> continuation line\n                     */\n                    scan = p;\n                    goto try_longer;\n                }\n                p++;\n            }\n        }\n\n        /*\n         * \"scan\" points to the first character of a paragraph or the\n         * terminating NUL byte.\n         */\n        {\n            char svch = *scan;\n            *scan = NUL;\n            print_one_paragraph(buf, plain, fp);\n            len -= scan - buf;\n            if (len <= 0)\n                break;\n            *scan = svch;\n            buf = scan;\n        }\n    }\n    AGFREE(text);\n}",
      "lines": 85,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "optionUsage": {
      "start_point": [
        567,
        0
      ],
      "end_point": [
        627,
        1
      ],
      "content": "void\noptionUsage(tOptions * opts, int usage_exit_code)\n{\n    int exit_code = (usage_exit_code == AO_EXIT_REQ_USAGE)\n        ? EXIT_SUCCESS : usage_exit_code;\n\n    displayEnum = false;\n    set_usage_flags(opts, NULL);\n\n    /*\n     *  Paged usage will preset option_usage_fp to an output file.\n     *  If it hasn't already been set, then set it to standard output\n     *  on successful exit (help was requested), otherwise error out.\n     *\n     *  Test the version before obtaining pzFullUsage or pzShortUsage.\n     *  These fields do not exist before revision 30.\n     */\n    {\n        char const * pz;\n\n        if (exit_code == EXIT_SUCCESS) {\n            pz = (opts->structVersion >= 30 * 4096)\n                ? opts->pzFullUsage : NULL;\n\n            if (option_usage_fp == NULL)\n                option_usage_fp = print_exit ? stderr : stdout;\n\n        } else {\n            pz = (opts->structVersion >= 30 * 4096)\n                ? opts->pzShortUsage : NULL;\n\n            if (option_usage_fp == NULL)\n                option_usage_fp = stderr;\n        }\n\n        if (((opts->fOptSet & OPTPROC_COMPUTE) == 0) && (pz != NULL)) {\n            if ((opts->fOptSet & OPTPROC_TRANSLATE) != 0)\n                optionPrintParagraphs(pz, true, option_usage_fp);\n            else\n                fputs(pz, option_usage_fp);\n            goto flush_and_exit;\n        }\n    }\n\n    fprintf(option_usage_fp, opts->pzUsageTitle, opts->pzProgName);\n\n    if ((exit_code == EXIT_SUCCESS) ||\n        (! skip_misuse_usage(opts)))\n\n        print_usage_details(opts, usage_exit_code);\n    else\n        print_offer_usage(opts);\n    \n flush_and_exit:\n    fflush(option_usage_fp);\n    if (ferror(option_usage_fp) != 0)\n        fserr_exit(opts->pzProgName, zwriting, (option_usage_fp == stdout)\n                   ? zstdout_name : zstderr_name);\n\n    option_exits(exit_code);\n}",
      "lines": 61,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "prt_conflicts": {
      "start_point": [
        638,
        0
      ],
      "end_point": [
        688,
        1
      ],
      "content": "static void\nprt_conflicts(tOptions * opts, tOptDesc * od)\n{\n    const int * opt_no;\n    fputs(zTabHyp + tab_skip_ct, option_usage_fp);\n\n    /*\n     *  REQUIRED:\n     */\n    if (od->pOptMust != NULL) {\n        opt_no = od->pOptMust;\n\n        if (opt_no[1] == NO_EQUIVALENT) {\n            fprintf(option_usage_fp, zReqOne,\n                    opts->pOptDesc[*opt_no].pz_Name);\n        } else {\n            fputs(zReqThese, option_usage_fp);\n            for (;;) {\n                fprintf(option_usage_fp, zTabout + tab_skip_ct,\n                        opts->pOptDesc[*opt_no].pz_Name);\n                if (*++opt_no == NO_EQUIVALENT)\n                    break;\n            }\n        }\n\n        if (od->pOptCant != NULL)\n            fputs(zTabHypAnd + tab_skip_ct, option_usage_fp);\n    }\n\n    /*\n     *  CONFLICTS:\n     */\n    if (od->pOptCant == NULL)\n        return;\n\n    opt_no = od->pOptCant;\n\n    if (opt_no[1] == NO_EQUIVALENT) {\n        fprintf(option_usage_fp, zProhibOne,\n                opts->pOptDesc[*opt_no].pz_Name);\n        return;\n    }\n\n    fputs(zProhib, option_usage_fp);\n    for (;;) {\n        fprintf(option_usage_fp, zTabout + tab_skip_ct,\n                opts->pOptDesc[*opt_no].pz_Name);\n        if (*++opt_no == NO_EQUIVALENT)\n            break;\n    }\n}",
      "lines": 51,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "prt_one_vendor": {
      "start_point": [
        698,
        0
      ],
      "end_point": [
        748,
        1
      ],
      "content": "static void\nprt_one_vendor(tOptions *    opts,  tOptDesc *   od,\n               arg_types_t * argtp, char const * usefmt)\n{\n    prt_preamble(opts, od, argtp);\n\n    {\n        char z[ 80 ];\n        char const *  pzArgType;\n\n        /*\n         *  Determine the argument type string first on its usage, then,\n         *  when the option argument is required, base the type string on the\n         *  argument type.\n         */\n        if (od->fOptState & OPTST_ARG_OPTIONAL) {\n            pzArgType = argtp->pzOpt;\n\n        } else switch (OPTST_GET_ARGTYPE(od->fOptState)) {\n        case OPARG_TYPE_NONE:        pzArgType = argtp->pzNo;   break;\n        case OPARG_TYPE_ENUMERATION: pzArgType = argtp->pzKey;  break;\n        case OPARG_TYPE_FILE:        pzArgType = argtp->pzFile; break;\n        case OPARG_TYPE_MEMBERSHIP:  pzArgType = argtp->pzKeyL; break;\n        case OPARG_TYPE_BOOLEAN:     pzArgType = argtp->pzBool; break;\n        case OPARG_TYPE_NUMERIC:     pzArgType = argtp->pzNum;  break;\n        case OPARG_TYPE_HIERARCHY:   pzArgType = argtp->pzNest; break;\n        case OPARG_TYPE_STRING:      pzArgType = argtp->pzStr;  break;\n        case OPARG_TYPE_TIME:        pzArgType = argtp->pzTime; break;\n        default:                     goto bogus_desc;\n        }\n\n        pzArgType = SPN_WHITESPACE_CHARS(pzArgType);\n        if (*pzArgType == NUL)\n            snprintf(z, sizeof(z), \"%s\", od->pz_Name);\n        else\n            snprintf(z, sizeof(z), \"%s=%s\", od->pz_Name, pzArgType);\n        fprintf(option_usage_fp, usefmt, z, od->pzText);\n\n        switch (OPTST_GET_ARGTYPE(od->fOptState)) {\n        case OPARG_TYPE_ENUMERATION:\n        case OPARG_TYPE_MEMBERSHIP:\n            displayEnum = (od->pOptProc != NULL) ? true : displayEnum;\n        }\n    }\n\n    return;\n\n bogus_desc:\n    fprintf(stderr, zbad_od, opts->pzProgName, od->pz_Name);\n    ao_bug(zbad_arg_type_msg);\n}",
      "lines": 51,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "prt_vendor_opts": {
      "start_point": [
        757,
        0
      ],
      "end_point": [
        806,
        1
      ],
      "content": "static void\nprt_vendor_opts(tOptions * opts, char const * title)\n{\n    static unsigned int const not_vended_mask =\n        OPTST_NO_USAGE_MASK | OPTST_DOCUMENT;\n\n    static char const vfmtfmt[] = \"%%-%us %%s\\n\";\n    char vfmt[sizeof(vfmtfmt)];\n\n    /*\n     *  Only handle client specified options.  The \"vendor option\" follows\n     *  \"presetOptCt\", so we won't loop/recurse indefinitely.\n     */\n    int          ct     = opts->presetOptCt;\n    tOptDesc *   od     = opts->pOptDesc;\n    fprintf(option_usage_fp, zTabout + tab_skip_ct, zVendOptsAre);\n\n    {\n        size_t   nmlen  = 0;\n        do  {\n            size_t l;\n            if (  ((od->fOptState & not_vended_mask) != 0)\n               || IS_GRAPHIC_CHAR(od->optValue))\n                continue;\n\n            l = strlen(od->pz_Name);\n            if (l > nmlen)  nmlen = l;\n        } while (od++, (--ct > 0));\n\n        snprintf(vfmt, sizeof(vfmt), vfmtfmt, (unsigned int)nmlen + 4);\n    }\n\n    if (tab_skip_ct > 0)\n        tab_skip_ct--;\n\n    ct    = opts->presetOptCt;\n    od    = opts->pOptDesc;\n\n    do  {\n        if (  ((od->fOptState & not_vended_mask) != 0)\n           || IS_GRAPHIC_CHAR(od->optValue))\n            continue;\n\n        prt_one_vendor(opts, od, &argTypes, vfmt);\n        prt_extd_usage(opts, od, title);\n\n    } while (od++, (--ct > 0));\n\n    /* no need to restore \"tab_skip_ct\" - options are done now */\n}",
      "lines": 50,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "prt_extd_usage": {
      "start_point": [
        815,
        0
      ],
      "end_point": [
        924,
        1
      ],
      "content": "static void\nprt_extd_usage(tOptions * opts, tOptDesc * od, char const * title)\n{\n    if (  ((opts->fOptSet & OPTPROC_VENDOR_OPT) != 0)\n       && (od->optActualValue == VENDOR_OPTION_VALUE)) {\n        prt_vendor_opts(opts, title);\n        return;\n    }\n\n    /*\n     *  IF there are option conflicts or dependencies,\n     *  THEN print them here.\n     */\n    if ((od->pOptMust != NULL) || (od->pOptCant != NULL))\n        prt_conflicts(opts, od);\n\n    /*\n     *  IF there is a disablement string\n     *  THEN print the disablement info\n     */\n    if (od->pz_DisableName != NULL )\n        fprintf(option_usage_fp, zDis + tab_skip_ct, od->pz_DisableName);\n\n    /*\n     *  Check for argument types that have callbacks with magical properties\n     */\n    switch (OPTST_GET_ARGTYPE(od->fOptState)) {\n    case OPARG_TYPE_NUMERIC:\n        /*\n         *  IF the numeric option has a special callback,\n         *  THEN call it, requesting the range or other special info\n         */\n        if (  (od->pOptProc != NULL)\n           && (od->pOptProc != optionNumericVal) ) {\n            (*(od->pOptProc))(OPTPROC_EMIT_USAGE, od);\n        }\n        break;\n\n    case OPARG_TYPE_FILE:\n        (*(od->pOptProc))(OPTPROC_EMIT_USAGE, od);\n        break;\n    }\n\n    /*\n     *  IF the option defaults to being enabled,\n     *  THEN print that out\n     */\n    if (od->fOptState & OPTST_INITENABLED)\n        fputs(zEnab + tab_skip_ct, option_usage_fp);\n\n    /*\n     *  IF  the option is in an equivalence class\n     *        AND not the designated lead\n     *  THEN print equivalence and leave it at that.\n     */\n    if (  (od->optEquivIndex != NO_EQUIVALENT)\n       && (od->optEquivIndex != od->optActualIndex )  )  {\n        fprintf(option_usage_fp, zalt_opt + tab_skip_ct,\n                 opts->pOptDesc[ od->optEquivIndex ].pz_Name);\n        return;\n    }\n\n    /*\n     *  IF this particular option can NOT be preset\n     *    AND some form of presetting IS allowed,\n     *    AND it is not an auto-managed option (e.g. --help, et al.)\n     *  THEN advise that this option may not be preset.\n     */\n    if (  ((od->fOptState & OPTST_NO_INIT) != 0)\n       && (  (opts->papzHomeList != NULL)\n          || (opts->pzPROGNAME != NULL)\n          )\n       && (od->optIndex < opts->presetOptCt)\n       )\n\n        fputs(zNoPreset + tab_skip_ct, option_usage_fp);\n\n    /*\n     *  Print the appearance requirements.\n     */\n    if (OPTST_GET_ARGTYPE(od->fOptState) == OPARG_TYPE_MEMBERSHIP)\n        fputs(zMembers + tab_skip_ct, option_usage_fp);\n\n    else switch (od->optMinCt) {\n    case 1:\n    case 0:\n        switch (od->optMaxCt) {\n        case 0:       fputs(zPreset + tab_skip_ct, option_usage_fp); break;\n        case NOLIMIT: fputs(zNoLim  + tab_skip_ct, option_usage_fp); break;\n        case 1:       break;\n            /*\n             * IF the max is more than one but limited, print \"UP TO\" message\n             */\n        default:\n            fprintf(option_usage_fp, zUpTo + tab_skip_ct, od->optMaxCt); break;\n        }\n        break;\n\n    default:\n        /*\n         *  More than one is required.  Print the range.\n         */\n        fprintf(option_usage_fp, zMust + tab_skip_ct,\n                od->optMinCt, od->optMaxCt);\n    }\n\n    if (  NAMED_OPTS(opts)\n       && (opts->specOptIdx.default_opt == od->optIndex))\n        fputs(zDefaultOpt + tab_skip_ct, option_usage_fp);\n}",
      "lines": 110,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "prt_ini_list": {
      "start_point": [
        937,
        0
      ],
      "end_point": [
        986,
        1
      ],
      "content": "static void\nprt_ini_list(char const * const * papz, char const * ini_file,\n             char const * path_nm)\n{\n    char pth_buf[AG_PATH_MAX+1];\n\n    fputs(zPresetIntro, option_usage_fp);\n\n    for (;;) {\n        char const * path   = *(papz++);\n        char const * nm_buf = pth_buf;\n\n        if (path == NULL)\n            break;\n\n        /*\n         * Ignore any invalid paths\n         */\n        if (! optionMakePath(pth_buf, (int)sizeof(pth_buf), path, path_nm))\n            nm_buf = path;\n\n        /*\n         * Expand paths that are relative to the executable or installation\n         * directories.  Leave alone paths that use environment variables.\n         */\n        else if ((*path == '$')\n                 && ((path[1] == '$') || (path[1] == '@')))\n            path = nm_buf;\n\n        /*\n         *  Print the name of the \"homerc\" file.  If the \"rcfile\" name is\n         *  not empty, we may or may not print that, too...\n         */\n        fprintf(option_usage_fp, zPathFmt, path);\n        if (*ini_file != NUL) {\n            struct stat sb;\n\n            /*\n             *  IF the \"homerc\" file is a directory,\n             *  then append the \"rcfile\" name.\n             */\n            if ((stat(nm_buf, &sb) == 0) && S_ISDIR(sb.st_mode)) {\n                fputc(DIRCH,    option_usage_fp);\n                fputs(ini_file, option_usage_fp);\n            }\n        }\n\n        fputc(NL, option_usage_fp);\n    }\n}",
      "lines": 50,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "prt_preamble": {
      "start_point": [
        995,
        0
      ],
      "end_point": [
        1019,
        1
      ],
      "content": "static void\nprt_preamble(tOptions * opts, tOptDesc * od, arg_types_t * at)\n{\n    /*\n     *  Flag prefix: IF no flags at all, then omit it.  If not printable\n     *  (not allowed for this option), then blank, else print it.\n     *  Follow it with a comma if we are doing GNU usage and long\n     *  opts are to be printed too.\n     */\n    if ((opts->fOptSet & OPTPROC_SHORTOPT) == 0)\n        fputs(at->pzSpc, option_usage_fp);\n\n    else if (! IS_GRAPHIC_CHAR(od->optValue)) {\n        if (  (opts->fOptSet & (OPTPROC_GNUUSAGE|OPTPROC_LONGOPT))\n           == (OPTPROC_GNUUSAGE|OPTPROC_LONGOPT))\n            fputc(' ', option_usage_fp);\n        fputs(at->pzNoF, option_usage_fp);\n\n    } else {\n        fprintf(option_usage_fp, \"   -%c\", od->optValue);\n        if (  (opts->fOptSet & (OPTPROC_GNUUSAGE|OPTPROC_LONGOPT))\n           == (OPTPROC_GNUUSAGE|OPTPROC_LONGOPT))\n            fputs(\", \", option_usage_fp);\n    }\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "prt_one_usage": {
      "start_point": [
        1028,
        0
      ],
      "end_point": [
        1082,
        1
      ],
      "content": "static void\nprt_one_usage(tOptions * opts, tOptDesc * od, arg_types_t * at)\n{\n    prt_preamble(opts, od, at);\n\n    {\n        char z[80];\n        char const * atyp;\n\n        /*\n         *  Determine the argument type string first on its usage, then,\n         *  when the option argument is required, base the type string on the\n         *  argument type.\n         */\n        if (od->fOptState & OPTST_ARG_OPTIONAL) {\n            atyp = at->pzOpt;\n\n        } else switch (OPTST_GET_ARGTYPE(od->fOptState)) {\n        case OPARG_TYPE_NONE:        atyp = at->pzNo;   break;\n        case OPARG_TYPE_ENUMERATION: atyp = at->pzKey;  break;\n        case OPARG_TYPE_FILE:        atyp = at->pzFile; break;\n        case OPARG_TYPE_MEMBERSHIP:  atyp = at->pzKeyL; break;\n        case OPARG_TYPE_BOOLEAN:     atyp = at->pzBool; break;\n        case OPARG_TYPE_NUMERIC:     atyp = at->pzNum;  break;\n        case OPARG_TYPE_HIERARCHY:   atyp = at->pzNest; break;\n        case OPARG_TYPE_STRING:      atyp = at->pzStr;  break;\n        case OPARG_TYPE_TIME:        atyp = at->pzTime; break;\n        default:                     goto bogus_desc;\n        }\n\n#ifdef _WIN32\n        if (at->pzOptFmt == zGnuOptFmt)\n            snprintf(z, sizeof(z), \"--%s%s\", od->pz_Name, atyp);\n        else if (at->pzOptFmt == zGnuOptFmt + 2)\n            snprintf(z, sizeof(z), \"%s%s\", od->pz_Name, atyp);\n        else\n#endif\n        snprintf(z, sizeof(z), at->pzOptFmt, atyp, od->pz_Name,\n                 (od->optMinCt != 0) ? at->pzReq : at->pzOpt);\n\n        fprintf(option_usage_fp, line_fmt_buf, z, od->pzText);\n\n        switch (OPTST_GET_ARGTYPE(od->fOptState)) {\n        case OPARG_TYPE_ENUMERATION:\n        case OPARG_TYPE_MEMBERSHIP:\n            displayEnum = (od->pOptProc != NULL) ? true : displayEnum;\n        }\n    }\n\n    return;\n\n bogus_desc:\n    fprintf(stderr, zbad_od, opts->pzProgName, od->pz_Name);\n    option_exits(EX_SOFTWARE);\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "prt_opt_usage": {
      "start_point": [
        1087,
        0
      ],
      "end_point": [
        1166,
        1
      ],
      "content": "static void\nprt_opt_usage(tOptions * opts, int ex_code, char const * title)\n{\n    int         ct     = opts->optCt;\n    int         optNo  = 0;\n    tOptDesc *  od     = opts->pOptDesc;\n    int         docCt  = 0;\n\n    do  {\n        /*\n         * no usage --> disallowed on command line (OPTST_NO_COMMAND), or\n         * deprecated -- strongly discouraged (OPTST_DEPRECATED), or\n         * compiled out of current object code (OPTST_OMITTED)\n         */\n        if ((od->fOptState & OPTST_NO_USAGE_MASK) != 0) {\n\n            /*\n             * IF      this is a compiled-out option\n             *   *AND* usage was requested with \"omitted-usage\"\n             *   *AND* this is NOT abbreviated usage\n             * THEN display this option.\n             */\n            if (  (od->fOptState == (OPTST_OMITTED | OPTST_NO_INIT))\n               && (od->pz_Name != NULL)\n               && (ex_code == EXIT_SUCCESS))  {\n\n                char const * why_pz =\n                    (od->pzText == NULL) ? zDisabledWhy : od->pzText;\n                prt_preamble(opts, od, &argTypes);\n                fprintf(option_usage_fp, zDisabledOpt, od->pz_Name, why_pz);\n            }\n\n            continue;\n        }\n\n        if ((od->fOptState & OPTST_DOCUMENT) != 0) {\n            if (ex_code == EXIT_SUCCESS) {\n                fprintf(option_usage_fp, argTypes.pzBrk, od->pzText,\n                        title);\n                docCt++;\n            }\n\n            continue;\n        }\n\n        /* Skip name only options when we have a vendor option */\n        if (  ((opts->fOptSet & OPTPROC_VENDOR_OPT) != 0)\n           && (! IS_GRAPHIC_CHAR(od->optValue)))\n            continue;\n\n        /*\n         *  IF       this is the first auto-opt maintained option\n         *    *AND*  we are doing a full help\n         *    *AND*  there are documentation options\n         *    *AND*  the last one was not a doc option,\n         *  THEN document that the remaining options are not user opts\n         */\n        if ((docCt > 0) && (ex_code == EXIT_SUCCESS)) {\n            if (opts->presetOptCt == optNo) {\n                if ((od[-1].fOptState & OPTST_DOCUMENT) == 0)\n                    fprintf(option_usage_fp, argTypes.pzBrk, zAuto, title);\n\n            } else if ((ct == 1) &&\n                       (opts->fOptSet & OPTPROC_VENDOR_OPT))\n                fprintf(option_usage_fp, argTypes.pzBrk, zVendIntro, title);\n        }\n\n        prt_one_usage(opts, od, &argTypes);\n\n        /*\n         *  IF we were invoked because of the --help option,\n         *  THEN print all the extra info\n         */\n        if (ex_code == EXIT_SUCCESS)\n            prt_extd_usage(opts, od, title);\n\n    } while (od++, optNo++, (--ct > 0));\n\n    fputc(NL, option_usage_fp);\n}",
      "lines": 80,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "prt_prog_detail": {
      "start_point": [
        1174,
        0
      ],
      "end_point": [
        1222,
        1
      ],
      "content": "static void\nprt_prog_detail(tOptions * opts)\n{\n    bool need_intro = (opts->papzHomeList == NULL);\n\n    /*\n     *  Display all the places we look for config files, if we have\n     *  a list of directories to search.\n     */\n    if (! need_intro)\n        prt_ini_list(opts->papzHomeList, opts->pzRcName, opts->pzProgPath);\n\n    /*\n     *  Let the user know about environment variable settings\n     */\n    if ((opts->fOptSet & OPTPROC_ENVIRON) != 0) {\n        if (need_intro)\n            fputs(zPresetIntro, option_usage_fp);\n\n        fprintf(option_usage_fp, zExamineFmt, opts->pzPROGNAME);\n    }\n\n    /*\n     *  IF we found an enumeration,\n     *  THEN hunt for it again.  Call the handler proc with a NULL\n     *       option struct pointer.  That tells it to display the keywords.\n     */\n    if (displayEnum) {\n        int        ct     = opts->optCt;\n        int        optNo  = 0;\n        tOptDesc * od     = opts->pOptDesc;\n\n        fputc(NL, option_usage_fp);\n        fflush(option_usage_fp);\n        do  {\n            switch (OPTST_GET_ARGTYPE(od->fOptState)) {\n            case OPARG_TYPE_ENUMERATION:\n            case OPARG_TYPE_MEMBERSHIP:\n                (*(od->pOptProc))(OPTPROC_EMIT_USAGE, od);\n            }\n        } while (od++, optNo++, (--ct > 0));\n    }\n\n    /*\n     *  If there is a detail string, now is the time for that.\n     */\n    if (opts->pzDetail != NULL)\n        fputs(opts->pzDetail, option_usage_fp);\n}",
      "lines": 49,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "setGnuOptFmts": {
      "start_point": [
        1239,
        0
      ],
      "end_point": [
        1274,
        1
      ],
      "content": "static int\nsetGnuOptFmts(tOptions * opts, char const ** ptxt)\n{\n    static char const zOneSpace[] = \" \";\n    int  flen = 22;\n    *ptxt = zNoRq_ShrtTtl;\n\n    argTypes.pzStr  = zGnuStrArg;\n    argTypes.pzReq  = zOneSpace;\n    argTypes.pzNum  = zGnuNumArg;\n    argTypes.pzKey  = zGnuKeyArg;\n    argTypes.pzKeyL = zGnuKeyLArg;\n    argTypes.pzTime = zGnuTimeArg;\n    argTypes.pzFile = zGnuFileArg;\n    argTypes.pzBool = zGnuBoolArg;\n    argTypes.pzNest = zGnuNestArg;\n    argTypes.pzOpt  = zGnuOptArg;\n    argTypes.pzNo   = zOneSpace;\n    argTypes.pzBrk  = zGnuBreak;\n    argTypes.pzNoF  = zSixSpaces;\n    argTypes.pzSpc  = zThreeSpaces;\n\n    switch (opts->fOptSet & OPTPROC_L_N_S) {\n    case OPTPROC_L_N_S:    argTypes.pzOptFmt = zGnuOptFmt;     break;\n    case OPTPROC_LONGOPT:  argTypes.pzOptFmt = zGnuOptFmt;     break;\n    case 0:                argTypes.pzOptFmt = zGnuOptFmt + 2; break;\n    case OPTPROC_SHORTOPT:\n        argTypes.pzOptFmt = zShrtGnuOptFmt;\n        zGnuStrArg[0] = zGnuNumArg[0] = zGnuKeyArg[0] = zGnuBoolArg[0] = ' ';\n        argTypes.pzOpt = \" [arg]\";\n        flen = 8;\n        break;\n    }\n\n    return flen;\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "setStdOptFmts": {
      "start_point": [
        1280,
        0
      ],
      "end_point": [
        1326,
        1
      ],
      "content": "static int\nsetStdOptFmts(tOptions * opts, char const ** ptxt)\n{\n    int  flen = 0;\n\n    argTypes.pzStr  = zStdStrArg;\n    argTypes.pzReq  = zStdReqArg;\n    argTypes.pzNum  = zStdNumArg;\n    argTypes.pzKey  = zStdKeyArg;\n    argTypes.pzKeyL = zStdKeyLArg;\n    argTypes.pzTime = zStdTimeArg;\n    argTypes.pzFile = zStdFileArg;\n    argTypes.pzBool = zStdBoolArg;\n    argTypes.pzNest = zStdNestArg;\n    argTypes.pzOpt  = zStdOptArg;\n    argTypes.pzNo   = zStdNoArg;\n    argTypes.pzBrk  = zStdBreak;\n    argTypes.pzNoF  = zFiveSpaces;\n    argTypes.pzSpc  = zTwoSpaces;\n\n    switch (opts->fOptSet & (OPTPROC_NO_REQ_OPT | OPTPROC_SHORTOPT)) {\n    case (OPTPROC_NO_REQ_OPT | OPTPROC_SHORTOPT):\n        *ptxt = zNoRq_ShrtTtl;\n        argTypes.pzOptFmt = zNrmOptFmt;\n        flen = 19;\n        break;\n\n    case OPTPROC_NO_REQ_OPT:\n        *ptxt = zNoRq_NoShrtTtl;\n        argTypes.pzOptFmt = zNrmOptFmt;\n        flen = 19;\n        break;\n\n    case OPTPROC_SHORTOPT:\n        *ptxt = zReq_ShrtTtl;\n        argTypes.pzOptFmt = zReqOptFmt;\n        flen = 24;\n        break;\n\n    case 0:\n        *ptxt = zReq_NoShrtTtl;\n        argTypes.pzOptFmt = zReqOptFmt;\n        flen = 24;\n    }\n\n    return flen;\n}",
      "lines": 47,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/version.c": {
    "optionVersion": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "char const *\noptionVersion(void)\n{\n    static char const ver[] = OPTIONS_DOTTED_VERSION;\n    return ver;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "char",
        "const",
        "const",
        "*\noptionVersion(void)",
        "*"
      ]
    },
    "emit_first_line": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static void\nemit_first_line(\n    FILE * fp, char const * alt1, char const * alt2, char const * alt3)\n{\n    char const * p = (alt1 != NULL) ? alt1 : ((alt2 != NULL) ? alt2 : alt3);\n    char const * e;\n    if (p == NULL)\n        return;\n    e = strchr(p, NL);\n    if (e == NULL)\n        fputs(p, fp);\n    else\n        fwrite(p, 1, (e - p), fp);\n    fputc(NL, fp);\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "emit_simple_ver": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "static void\nemit_simple_ver(tOptions * o, FILE * fp)\n{\n    emit_first_line(fp, o->pzFullVersion, o->pzCopyright, o->pzUsageTitle);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "emit_copy_full": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "static void\nemit_copy_full(tOptions * o, FILE * fp)\n{\n    if (o->pzCopyright != NULL)\n        fputs(o->pzCopyright, fp);\n\n    else if (o->pzFullVersion != NULL)\n        fputs(o->pzFullVersion, fp);\n\n    else\n        emit_first_line(fp, o->pzUsageTitle, NULL, NULL);\n    \n    if (HAS_pzPkgDataDir(o) && (o->pzPackager != NULL)) {\n        fputc(NL, fp);\n        fputs(o->pzPackager, fp);\n\n    } else if (o->pzBugAddr != NULL) {\n        fputc(NL, fp);\n        fprintf(fp, zPlsSendBugs, o->pzBugAddr);\n    }\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "emit_copy_note": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "static void\nemit_copy_note(tOptions * opts, FILE * fp)\n{\n    if (opts->pzCopyright != NULL)\n        fputs(opts->pzCopyright, fp);\n\n    if (opts->pzCopyNotice != NULL)\n        fputs(opts->pzCopyNotice, fp);\n\n    fputc(NL, fp);\n    fprintf(fp, zao_ver_fmt, optionVersion());\n    \n    if (HAS_pzPkgDataDir(opts) && (opts->pzPackager != NULL)) {\n        fputc(NL, fp);\n        fputs(opts->pzPackager, fp);\n\n    } else if (opts->pzBugAddr != NULL) {\n        fputc(NL, fp);\n        fprintf(fp, zPlsSendBugs, opts->pzBugAddr);\n    }\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_ver": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "static void\nprint_ver(tOptions * opts, tOptDesc * od, FILE * fp, bool call_exit)\n{\n    char ch;\n\n    if (opts <= OPTPROC_EMIT_LIMIT)\n        return;\n\n    /*\n     *  IF we have an argument for this option, use it\n     *  Otherwise, default to version only or copyright note,\n     *  depending on whether the layout is GNU standard form or not.\n     */\n    if (  (od->fOptState & OPTST_ARG_OPTIONAL)\n       && (od->optArg.argString != NULL)\n       && (od->optArg.argString[0] != NUL))\n\n        ch = od->optArg.argString[0];\n\n    else {\n        set_usage_flags(opts, NULL);\n        ch = (opts->fOptSet & OPTPROC_GNUUSAGE) ? 'c' : 'v';\n    }\n\n    switch (ch) {\n    case NUL: /* arg provided, but empty */\n    case 'v': case 'V': emit_simple_ver(opts, fp); break;\n    case 'c': case 'C': emit_copy_full( opts, fp); break;\n    case 'n': case 'N': emit_copy_note( opts, fp); break;\n\n    default:\n        fprintf(stderr, zBadVerArg, ch);\n        option_exits(EXIT_FAILURE);\n    }\n\n    fflush(fp);\n    if (ferror(fp))\n        fserr_exit(opts->pzProgName, zwriting,\n                   (fp == stdout) ? zstdout_name : zstderr_name);\n\n    if (call_exit)\n        option_exits(EXIT_SUCCESS);\n}",
      "lines": 43,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "optionPrintVersion": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "void\noptionPrintVersion(tOptions * opts, tOptDesc * od)\n{\n    print_ver(opts, od, print_exit ? stderr : stdout, true);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "optionPrintVersionAndReturn": {
      "start_point": [
        207,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "void\noptionPrintVersionAndReturn(tOptions * opts, tOptDesc * od)\n{\n    print_ver(opts, od, print_exit ? stderr : stdout, false);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "optionVersionStderr": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        227,
        1
      ],
      "content": "void\noptionVersionStderr(tOptions * opts, tOptDesc * od)\n{\n    print_ver(opts, od, stderr, true);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/autoopts/options.h": {},
  "sharutils/sharutils-4.15.2/libopts/autoopts/project.h": {},
  "sharutils/sharutils-4.15.2/libopts/autoopts/usage-txt.h": {},
  "sharutils/sharutils-4.15.2/libopts/compat/compat.h": {},
  "sharutils/sharutils-4.15.2/libopts/compat/pathfind.c": {
    "pathfind": [
      {
        "start_point": [
          16,
          0
        ],
        "end_point": [
          22,
          1
        ],
        "content": "static char *\npathfind( char const * path,\n          char const * fname,\n          char const * mode )\n{\n    return strdup(fname);\n}",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "char",
          "*\npathfind( char const * path,\n          char const * fname,\n          char const * mode )",
          "*"
        ]
      },
      {
        "start_point": [
          36,
          0
        ],
        "end_point": [
          102,
          1
        ],
        "content": "static char *\npathfind( char const * path,\n          char const * fname,\n          char const * mode )\n{\n    int    p_index   = 0;\n    int    mode_bits = 0;\n    char * res_path  = NULL;\n    char   zPath[ AG_PATH_MAX + 1 ];\n\n    if (strchr( mode, 'r' )) mode_bits |= R_OK;\n    if (strchr( mode, 'w' )) mode_bits |= W_OK;\n    if (strchr( mode, 'x' )) mode_bits |= X_OK;\n\n    /*\n     *  FOR each non-null entry in the colon-separated path, DO ...\n     */\n    for (;;) {\n        DIR  * dirP;\n        char * colon_unit = extract_colon_unit( zPath, path, &p_index );\n\n        if (colon_unit == NULL)\n            break;\n\n        dirP = opendir( colon_unit );\n\n        /*\n         *  IF the directory is inaccessable, THEN next directory\n         */\n        if (dirP == NULL)\n            continue;\n\n        for (;;) {\n            struct dirent *entP = readdir( dirP );\n\n            if (entP == (struct dirent *)NULL)\n                break;\n\n            /*\n             *  IF the file name matches the one we are looking for, ...\n             */\n            if (strcmp(entP->d_name, fname) == 0) {\n                char * abs_name = make_absolute(fname, colon_unit);\n\n                /*\n                 *  Make sure we can access it in the way we want\n                 */\n                if (access(abs_name, mode_bits) >= 0) {\n                    /*\n                     *  We can, so normalize the name and return it below\n                     */\n                    res_path = canonicalize_pathname(abs_name);\n                }\n\n                free(abs_name);\n                break;\n            }\n        }\n\n        closedir( dirP );\n\n        if (res_path != NULL)\n            break;\n    }\n\n    return res_path;\n}",
        "lines": 67,
        "depth": 15,
        "decorators": [
          "static",
          "static",
          "char",
          "*\npathfind( char const * path,\n          char const * fname,\n          char const * mode )",
          "*"
        ]
      }
    ],
    "make_absolute": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "static char *\nmake_absolute( char const * string, char const * dot_path )\n{\n    char * result;\n    int result_len;\n\n    if (!dot_path || *string == '/') {\n        result = strdup( string );\n    } else {\n        if (dot_path && dot_path[0]) {\n            result = malloc( 2 + strlen( dot_path ) + strlen( string ) );\n            strcpy( result, dot_path );\n            result_len = (int)strlen(result);\n            if (result[result_len - 1] != '/') {\n                result[result_len++] = '/';\n                result[result_len] = '\\0';\n            }\n        } else {\n            result = malloc( 3 + strlen( string ) );\n            result[0] = '.'; result[1] = '/'; result[2] = '\\0';\n            result_len = 2;\n        }\n\n        strcpy( result + result_len, string );\n    }\n\n    return result;\n}",
      "lines": 28,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nmake_absolute( char const * string, char const * dot_path )",
        "*"
      ]
    },
    "canonicalize_pathname": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "static char *\ncanonicalize_pathname( char *path )\n{\n    int i, start;\n    char stub_char, *result;\n\n    /* The result cannot be larger than the input PATH. */\n    result = strdup( path );\n\n    stub_char = (*path == '/') ? '/' : '.';\n\n    /* Walk along RESULT looking for things to compact. */\n    i = 0;\n    while (result[i]) {\n        while (result[i] != '\\0' && result[i] != '/')\n            i++;\n\n        start = i++;\n\n        /* If we didn't find any  slashes, then there is nothing left to\n         * do.\n         */\n        if (!result[start])\n            break;\n\n        /* Handle multiple `/'s in a row. */\n        while (result[i] == '/')\n            i++;\n\n#if !defined (apollo)\n        if ((start + 1) != i)\n#else\n        if ((start + 1) != i && (start != 0 || i != 2))\n#endif /* apollo */\n        {\n            strcpy( result + start + 1, result + i );\n            i = start + 1;\n        }\n\n        /* Handle backquoted `/'. */\n        if (start > 0 && result[start - 1] == '\\\\')\n            continue;\n\n        /* Check for trailing `/', and `.' by itself. */\n        if ((start && !result[i])\n            || (result[i] == '.' && !result[i+1])) {\n            result[--i] = '\\0';\n            break;\n        }\n\n        /* Check for `../', `./' or trailing `.' by itself. */\n        if (result[i] == '.') {\n            /* Handle `./'. */\n            if (result[i + 1] == '/') {\n                strcpy( result + i, result + i + 1 );\n                i = (start < 0) ? 0 : start;\n                continue;\n            }\n\n            /* Handle `../' or trailing `..' by itself. */\n            if (result[i + 1] == '.' &&\n                (result[i + 2] == '/' || !result[i + 2])) {\n                while (--start > -1 && result[start] != '/')\n                    ;\n                strcpy( result + start + 1, result + i + 2 );\n                i = (start < 0) ? 0 : start;\n                continue;\n            }\n        }\n    }\n\n    if (!*result) {\n        *result = stub_char;\n        result[1] = '\\0';\n    }\n\n    return result;\n}",
      "lines": 78,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ncanonicalize_pathname( char *path )",
        "*"
      ]
    },
    "extract_colon_unit": {
      "start_point": [
        233,
        0
      ],
      "end_point": [
        272,
        1
      ],
      "content": "static char *\nextract_colon_unit(char * pzDir, char const * string, int * p_index)\n{\n    char * pzDest = pzDir;\n    int    ix     = *p_index;\n\n    if (string == NULL)\n        return NULL;\n\n    if ((unsigned)ix >= strlen( string ))\n        return NULL;\n\n    {\n        char const * pzSrc = string + ix;\n\n        while (*pzSrc == ':')  pzSrc++;\n\n        for (;;) {\n            char ch = (*(pzDest++) = *(pzSrc++));\n            switch (ch) {\n            case ':':\n                pzDest[-1] = NUL;\n                /* FALLTHROUGH */\n            case NUL:\n                goto copy_done;\n            }\n\n            if ((unsigned long)(pzDest - pzDir) >= AG_PATH_MAX)\n                break;\n        } copy_done:;\n\n        ix = (int)(pzSrc - string);\n    }\n\n    if (*pzDir == NUL)\n        return NULL;\n\n    *p_index = ix;\n    return pzDir;\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nextract_colon_unit(char * pzDir, char const * string, int * p_index)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/compat/snprintf.c": {
    "snprintf": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static int\nsnprintf(char *str, size_t n, char const *fmt, ...)\n{\n    va_list ap;\n    int rval;\n\n#ifdef VSPRINTF_CHARSTAR\n    char *rp;\n    VA_START(ap, fmt);\n    rp = vsprintf(str, fmt, ap);\n    VA_END(ap);\n    rval = strlen(rp);\n\n#else\n    VA_START(ap, fmt);\n    rval = vsprintf(str, fmt, ap);\n    VA_END(ap);\n#endif\n\n    if (rval > n) {\n        fprintf(stderr, \"snprintf buffer overrun %d > %d\\n\", rval, (int)n);\n        abort();\n    }\n    return rval;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "vsnprintf": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static int\nvsnprintf( char *str, size_t n, char const *fmt, va_list ap )\n{\n#ifdef VSPRINTF_CHARSTAR\n    return (strlen(vsprintf(str, fmt, ap)));\n#else\n    return (vsprintf(str, fmt, ap));\n#endif\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/compat/strchr.c": {
    "strchr": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "static char *\nstrchr(char const *s, int c)\n{\n    do {\n        if ((unsigned char)*s == (unsigned char)c)\n            return s;\n\n    } while (*(++s) != NUL);\n\n    return NULL;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nstrchr(char const *s, int c)",
        "*"
      ]
    },
    "strrchr": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static char *\nstrrchr(char const *s, int c)\n{\n    char const *e = s + strlen(s);\n\n    for (;;) {\n        if (--e < s)\n            break;\n\n        if ((unsigned char)*e == (unsigned char)c)\n            return e;\n    }\n    return NULL;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nstrrchr(char const *s, int c)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/compat/strdup.c": {
    "strdup": {
      "start_point": [
        7,
        0
      ],
      "end_point": [
        21,
        1
      ],
      "content": "static char *\nstrdup( char const *s )\n{\n    char *cp;\n\n    if (s == NULL)\n        return NULL;\n\n    cp = (char *) AGALOC((unsigned) (strlen(s)+1), \"strdup\");\n\n    if (cp != NULL)\n        (void) strcpy(cp, s);\n\n    return cp;\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nstrdup( char const *s )",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/libopts/compat/windows-config.h": {},
  "sharutils/sharutils-4.15.2/libopts/compat/_Noreturn.h": {},
  "sharutils/sharutils-4.15.2/snippet/arg-nonnull.h": {},
  "sharutils/sharutils-4.15.2/snippet/c++defs.h": {},
  "sharutils/sharutils-4.15.2/snippet/unused-parameter.h": {},
  "sharutils/sharutils-4.15.2/snippet/warn-on-use.h": {},
  "sharutils/sharutils-4.15.2/snippet/_Noreturn.h": {},
  "sharutils/sharutils-4.15.2/src/encode.c": {},
  "sharutils/sharutils-4.15.2/src/local.h": {},
  "sharutils/sharutils-4.15.2/src/scribble.c": {
    "scribble_init": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "void\nscribble_init(void)\n{\n    bufs = NULL;\n    next_buf = &bufs;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "scribble_deinit": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "void\nscribble_deinit(void)\n{\n    scrib_buf_t * sb = bufs;\n    scribble_init();\n\n    while (sb != NULL) {\n        scrib_buf_t * nxt = sb->sb_next;\n        free(sb);\n        sb = nxt;\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "scribble_free": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "void\nscribble_free(void)\n{\n    scrib_buf_t * sb = bufs;\n\n    while (sb != NULL) {\n        sb->sb_off = 0;\n        sb = sb->sb_next;\n    }\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "new_scribble_block": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "static scrib_buf_t *\nnew_scribble_block(size_t min_size)\n{\n    scrib_buf_t * res = NULL;\n\n    min_size = ROUND_SCRIBBLE(min_size + hdr_sz, 0x2000U);\n\n    /*\n     * Allocate and link into list.  Advance pointer to next entry.\n     */\n    *next_buf    = res = malloc(min_size);\n    if (*next_buf == NULL)\n        return NULL;\n\n    next_buf     = &(res->sb_next);\n    res->sb_next = NULL;\n    res->sb_off  = 0;\n    /*\n     *  The \"sb_size\" field is read-only.  Override this during allocation.\n     */\n    {\n        size_t * psz = (void *)&(res->sb_size);\n        *psz = min_size - hdr_sz;\n    }\n\n    return res;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "scrib_buf_t",
        "*\nnew_scribble_block(size_t min_size)",
        "*"
      ]
    },
    "scribble_get": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "void *\nscribble_get(ssize_t size)\n{\n    scrib_buf_t * sb = bufs;\n    char * buf;\n\n     // allow for NUL byte & round to word boundary\n    size  = ROUND_SCRIBBLE(size+1, (ssize_t)sizeof(void *));\n\n    for (;;) {\n        if (sb == NULL) {\n            sb = new_scribble_block((size_t)size);\n            if (sb == NULL)\n                return NULL;\n            break;\n        }\n\n        if ((sb->sb_size - sb->sb_off) >= size)\n            break;\n\n        sb   = sb->sb_next;\n    }\n\n    buf = (char*)(sb->sb_buf + sb->sb_off);\n    sb->sb_off += size;\n    return buf;\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "void",
        "*\nscribble_get(ssize_t size)",
        "*"
      ]
    },
    "xscribble_get": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "void *\nxscribble_get(ssize_t sz)\n{\n    void * p = scribble_get(sz);\n    if (p == NULL) {\n        fprintf(stderr, _(\"could not allocate %u bytes of scribble space\"),\n                (unsigned int)sz);\n        exit(EXIT_FAILURE);\n    }\n    return p;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "void",
        "*\nxscribble_get(ssize_t sz)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/src/scribble.h": {},
  "sharutils/sharutils-4.15.2/src/shar-opts.c": {
    "doUsageOpt": {
      "start_point": [
        1580,
        0
      ],
      "end_point": [
        1590,
        1
      ],
      "content": "static void\ndoUsageOpt(tOptions * opts, tOptDesc * od)\n{\n    int ex_code;\n    ex_code = SHAR_EXIT_SUCCESS;\n    optionUsage(&sharOptions, ex_code);\n    /* NOTREACHED */\n    exit(1);\n    (void)opts;\n    (void)od;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "doOptLevel_Of_Compression": {
      "start_point": [
        1602,
        0
      ],
      "end_point": [
        1628,
        1
      ],
      "content": "static void\ndoOptLevel_Of_Compression(tOptions* pOptions, tOptDesc* pOptDesc)\n{\n    static struct {long rmin, rmax;} const rng[1] = {\n        { 1, 9 } };\n    int  ix;\n\n    if (pOptions <= OPTPROC_EMIT_LIMIT)\n        goto emit_ranges;\n    optionNumericVal(pOptions, pOptDesc);\n\n    for (ix = 0; ix < 1; ix++) {\n        if (pOptDesc->optArg.argInt < rng[ix].rmin)\n            continue;  /* ranges need not be ordered. */\n        if (pOptDesc->optArg.argInt == rng[ix].rmin)\n            return;\n        if (rng[ix].rmax == LONG_MIN)\n            continue;\n        if (pOptDesc->optArg.argInt <= rng[ix].rmax)\n            return;\n    }\n\n    option_usage_fp = stderr;\n\n emit_ranges:\noptionShowRange(pOptions, pOptDesc, VOIDP(rng), 1);\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "doOptBzip2": {
      "start_point": [
        1639,
        0
      ],
      "end_point": [
        1652,
        1
      ],
      "content": "static void\ndoOptBzip2(tOptions* pOptions, tOptDesc* pOptDesc)\n{\n    /*\n     * Be sure the flag-code[0] handles special values for the options pointer\n     * viz. (poptions <= OPTPROC_EMIT_LIMIT) *and also* the special flag bit\n     * ((poptdesc->fOptState & OPTST_RESET) != 0) telling the option to\n     * reset its state.\n     */\n    /* extracted from shar-opts.def, line 139 */\n    SET_OPT_COMPACTOR(\"bzip2\");\n    (void)pOptDesc;\n    (void)pOptions;\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "doOptGzip": {
      "start_point": [
        1663,
        0
      ],
      "end_point": [
        1676,
        1
      ],
      "content": "static void\ndoOptGzip(tOptions* pOptions, tOptDesc* pOptDesc)\n{\n    /*\n     * Be sure the flag-code[0] handles special values for the options pointer\n     * viz. (poptions <= OPTPROC_EMIT_LIMIT) *and also* the special flag bit\n     * ((poptdesc->fOptState & OPTST_RESET) != 0) telling the option to\n     * reset its state.\n     */\n    /* extracted from shar-opts.def, line 153 */\n    SET_OPT_COMPACTOR(\"gzip\");\n    (void)pOptDesc;\n    (void)pOptions;\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "doOptCompress": {
      "start_point": [
        1688,
        0
      ],
      "end_point": [
        1701,
        1
      ],
      "content": "static void\ndoOptCompress(tOptions* pOptions, tOptDesc* pOptDesc)\n{\n    /*\n     * Be sure the flag-code[0] handles special values for the options pointer\n     * viz. (poptions <= OPTPROC_EMIT_LIMIT) *and also* the special flag bit\n     * ((poptdesc->fOptState & OPTST_RESET) != 0) telling the option to\n     * reset its state.\n     */\n    /* extracted from shar-opts.def, line 168 */\n    SET_OPT_COMPACTOR(\"compress\");\n    (void)pOptDesc;\n    (void)pOptions;\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "doOptLevel_For_Gzip": {
      "start_point": [
        1711,
        0
      ],
      "end_point": [
        1718,
        1
      ],
      "content": "static void\ndoOptLevel_For_Gzip(tOptions* pOptions, tOptDesc* pOptDesc)\n{\n    int res = optionAlias(pOptions, pOptDesc, INDEX_OPT_LEVEL_OF_COMPRESSION);\n    if ((res != 0) && ((pOptions->fOptSet & OPTPROC_ERRSTOP) != 0))\n        USAGE(SHAR_EXIT_USAGE_ERROR);\n\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "doOptBits_Per_Code": {
      "start_point": [
        1728,
        0
      ],
      "end_point": [
        1740,
        1
      ],
      "content": "static void\ndoOptBits_Per_Code(tOptions* pOptions, tOptDesc* pOptDesc)\n{\n    /*\n     * Be sure the flag-code[0] handles special values for the options pointer\n     * viz. (poptions <= OPTPROC_EMIT_LIMIT) *and also* the special flag bit\n     * ((poptdesc->fOptState & OPTST_RESET) != 0) telling the option to\n     * reset its state.\n     */\n    /* extracted from shar-opts.def, line 190 */\n    check_intermixing(pOptions, pOptDesc);\n    SET_OPT_COMPACTOR(\"compress\");\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "doOptWhole_Size_Limit": {
      "start_point": [
        1757,
        0
      ],
      "end_point": [
        1783,
        1
      ],
      "content": "static void\ndoOptWhole_Size_Limit(tOptions* pOptions, tOptDesc* pOptDesc)\n{\n    static struct {long rmin, rmax;} const rng[2] = {\n        { 8, 1023 },       { 8192, 4194304 } };\n    int  ix;\n\n    if (pOptions <= OPTPROC_EMIT_LIMIT)\n        goto emit_ranges;\n    optionNumericVal(pOptions, pOptDesc);\n\n    for (ix = 0; ix < 2; ix++) {\n        if (pOptDesc->optArg.argInt < rng[ix].rmin)\n            continue;  /* ranges need not be ordered. */\n        if (pOptDesc->optArg.argInt == rng[ix].rmin)\n            return;\n        if (rng[ix].rmax == LONG_MIN)\n            continue;\n        if (pOptDesc->optArg.argInt <= rng[ix].rmax)\n            return;\n    }\n\n    option_usage_fp = stderr;\n\n emit_ranges:\noptionShowRange(pOptions, pOptDesc, VOIDP(rng), 2);\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "doOptSplit_Size_Limit": {
      "start_point": [
        1801,
        0
      ],
      "end_point": [
        1827,
        1
      ],
      "content": "static void\ndoOptSplit_Size_Limit(tOptions* pOptions, tOptDesc* pOptDesc)\n{\n    static struct {long rmin, rmax;} const rng[2] = {\n        { 8, 1023 },       { 8192, 4194304 } };\n    int  ix;\n\n    if (pOptions <= OPTPROC_EMIT_LIMIT)\n        goto emit_ranges;\n    optionNumericVal(pOptions, pOptDesc);\n\n    for (ix = 0; ix < 2; ix++) {\n        if (pOptDesc->optArg.argInt < rng[ix].rmin)\n            continue;  /* ranges need not be ordered. */\n        if (pOptDesc->optArg.argInt == rng[ix].rmin)\n            return;\n        if (rng[ix].rmax == LONG_MIN)\n            continue;\n        if (pOptDesc->optArg.argInt <= rng[ix].rmax)\n            return;\n    }\n\n    option_usage_fp = stderr;\n\n emit_ranges:\noptionShowRange(pOptions, pOptDesc, VOIDP(rng), 2);\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "doOptInput_File_List": {
      "start_point": [
        1854,
        0
      ],
      "end_point": [
        1871,
        1
      ],
      "content": "static void\ndoOptInput_File_List(tOptions* pOptions, tOptDesc* pOptDesc)\n{\n    /*\n     * Be sure the flag-code[0] handles special values for the options pointer\n     * viz. (poptions <= OPTPROC_EMIT_LIMIT) *and also* the special flag bit\n     * ((poptdesc->fOptState & OPTST_RESET) != 0) telling the option to\n     * reset its state.\n     */\n    /* extracted from shar-opts.def, line 358 */\n    char const * fnm = pOptDesc->optArg.argString;\n    validate_opt_context (pOptions, pOptDesc);\n    if (strcmp (fnm, \"-\") != 0) {\n        FILE * fp = freopen(fnm, \"r\", stdin);\n        if (fp != stdin)\n            usage_message(_(\"Cannot reopen %s as stdin\"), fnm);\n    }\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "doOptStdin_File_List": {
      "start_point": [
        1881,
        0
      ],
      "end_point": [
        1894,
        1
      ],
      "content": "static void\ndoOptStdin_File_List(tOptions* pOptions, tOptDesc* pOptDesc)\n{\n    /*\n     * Be sure the flag-code[0] handles special values for the options pointer\n     * viz. (poptions <= OPTPROC_EMIT_LIMIT) *and also* the special flag bit\n     * ((poptdesc->fOptState & OPTST_RESET) != 0) telling the option to\n     * reset its state.\n     */\n    /* extracted from shar-opts.def, line 394 */\n    SET_OPT_INPUT_FILE_LIST(\"-\");\n    (void)pOptDesc;\n    (void)pOptions;\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "doOptVanilla_Operation": {
      "start_point": [
        1911,
        0
      ],
      "end_point": [
        1929,
        1
      ],
      "content": "static void\ndoOptVanilla_Operation(tOptions* pOptions, tOptDesc* pOptDesc)\n{\n    /*\n     * Be sure the flag-code[0] handles special values for the options pointer\n     * viz. (poptions <= OPTPROC_EMIT_LIMIT) *and also* the special flag bit\n     * ((poptdesc->fOptState & OPTST_RESET) != 0) telling the option to\n     * reset its state.\n     */\n    /* extracted from shar-opts.def, line 590 */\n    validate_opt_context (pOptions, pOptDesc);\n\n    SET_OPT_NO_CHARACTER_COUNT;\n    SET_OPT_NO_TIMESTAMP;\n    SET_OPT_NO_MD5_DIGEST;\n    SET_OPT_NO_I18N;\n    SET_OPT_NO_PIPING;\n    SET_OPT_FORCE_PREFIX;\n}",
      "lines": 19,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "doOptPrint_Text_Domain_Dir": {
      "start_point": [
        1939,
        0
      ],
      "end_point": [
        1958,
        1
      ],
      "content": "static void\ndoOptPrint_Text_Domain_Dir(tOptions* pOptions, tOptDesc* pOptDesc)\n{\n    /*\n     * Be sure the flag-code[0] handles special values for the options pointer\n     * viz. (poptions <= OPTPROC_EMIT_LIMIT) *and also* the special flag bit\n     * ((poptdesc->fOptState & OPTST_RESET) != 0) telling the option to\n     * reset its state.\n     */\n    /* extracted from shar-opts.def, line 745 */\n    validate_opt_context (pOptions, pOptDesc);\n\n#if !defined ENABLE_NLS || defined HAVE_CATGETS \\\n    || (defined HAVE_GETTEXT && !defined __USE_GNU_GETTEXT)\n    exit (EXIT_FAILURE);\n#else\n    puts (LOCALEDIR);\n    exit (EXIT_SUCCESS);\n#endif\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "doOptSilent": {
      "start_point": [
        1967,
        0
      ],
      "end_point": [
        1974,
        1
      ],
      "content": "static void\ndoOptSilent(tOptions* pOptions, tOptDesc* pOptDesc)\n{\n    int res = optionAlias(pOptions, pOptDesc, INDEX_OPT_QUIET);\n    if ((res != 0) && ((pOptions->fOptSet & OPTPROC_ERRSTOP) != 0))\n        USAGE(SHAR_EXIT_USAGE_ERROR);\n\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "vusage_message": {
      "start_point": [
        1986,
        0
      ],
      "end_point": [
        1995,
        1
      ],
      "content": "void\nvusage_message(char const * fmt, va_list ap)\n{\n    char const * er_leader = _(\"shar usage error:\\n\");\n    fputs(er_leader, stderr);\n    vfprintf(stderr, fmt, ap);\n    optionUsage(&sharOptions, SHAR_EXIT_USAGE_ERROR);\n    /* NOTREACHED */\n    exit(1);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "usage_message": {
      "start_point": [
        2005,
        0
      ],
      "end_point": [
        2013,
        1
      ],
      "content": "void\nusage_message(char const * fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    vusage_message(fmt, ap);\n    /* NOTREACHED */\n    va_end(ap);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "vdie": {
      "start_point": [
        2023,
        0
      ],
      "end_point": [
        2032,
        1
      ],
      "content": "void\nvdie(int exit_code, char const * fmt, va_list ap)\n{\n    char const * die_leader = _(\"shar fatal error:\\n\");\n    fputs(die_leader, stderr);\n    vfprintf(stderr, fmt, ap);\n    fflush(stderr);\n    exit(exit_code);\n    /* NOTREACHED */\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "die": {
      "start_point": [
        2042,
        0
      ],
      "end_point": [
        2050,
        1
      ],
      "content": "void\ndie(int exit_code, char const * fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    vdie(exit_code, fmt, ap);\n    /* NOTREACHED */\n    va_end(ap);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "fserr": {
      "start_point": [
        2060,
        0
      ],
      "end_point": [
        2066,
        1
      ],
      "content": "void\nfserr(int exit_code, char const * op, char const * fname)\n{\n    char const * fserr_fmt = _(\"fserr %d (%s) performing '%s' on %s\\n\");\n    die(exit_code, fserr_fmt, errno, strerror(errno), op, fname);\n    /* NOTREACHED */\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "AO_gettext": {
      "start_point": [
        2163,
        0
      ],
      "end_point": [
        2192,
        1
      ],
      "content": "static char *\nAO_gettext(char const * pz)\n{\n    char * res;\n    if (pz == NULL)\n        return NULL;\n#ifdef HAVE_DCGETTEXT\n    /*\n     * While processing the option_xlateable_txt data, try to use the\n     * \"libopts\" domain.  Once we switch to the option descriptor data,\n     * do *not* use that domain.\n     */\n    if (option_xlateable_txt.field_ct != 0) {\n        res = dgettext(\"libopts\", pz);\n        if (res == pz)\n            res = (char *)VOIDP(_(pz));\n    } else\n        res = (char *)VOIDP(_(pz));\n#else\n    res = (char *)VOIDP(_(pz));\n#endif\n    if (res == pz)\n        return res;\n    res = strdup(res);\n    if (res == NULL) {\n        fputs(_(\"No memory for duping translated strings\\n\"), stderr);\n        exit(SHAR_EXIT_OPTION_ERROR);\n    }\n    return res;\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nAO_gettext(char const * pz)",
        "*"
      ]
    },
    "coerce_it": {
      "start_point": [
        2198,
        0
      ],
      "end_point": [
        2199,
        1
      ],
      "content": "static void coerce_it(void ** s) { *s = AO_gettext(*s);\n}",
      "lines": 2,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "translate_option_strings": {
      "start_point": [
        2205,
        0
      ],
      "end_point": [
        2233,
        1
      ],
      "content": "static void\ntranslate_option_strings(void)\n{\n    tOptions * const opts = &sharOptions;\n\n    /*\n     *  Guard against re-translation.  It won't work.  The strings will have\n     *  been changed by the first pass through this code.  One shot only.\n     */\n    if (option_xlateable_txt.field_ct != 0) {\n        /*\n         *  Do the translations.  The first pointer follows the field count\n         *  field.  The field count field is the size of a pointer.\n         */\n        char ** ppz = (char**)VOIDP(&(option_xlateable_txt));\n        int     ix  = option_xlateable_txt.field_ct;\n\n        do {\n            ppz++; /* skip over field_ct */\n            *ppz = AO_gettext(*ppz);\n        } while (--ix > 0);\n        /* prevent re-translation and disable \"libopts\" domain lookup */\n        option_xlateable_txt.field_ct = 0;\n\n        coerce_it(VOIDP(&(opts->pzCopyright)));\n        coerce_it(VOIDP(&(opts->pzCopyNotice)));\n        coerce_it(VOIDP(&(opts->pzFullVersion)));\n    }\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bogus_function": {
      "start_point": [
        2238,
        0
      ],
      "end_point": [
        2567,
        1
      ],
      "content": "static void bogus_function(void) {\n  /* TRANSLATORS:\n\n     The following dummy function was crated solely so that xgettext can\n     extract the correct strings.  These strings are actually referenced\n     by a field name in the sharOptions structure noted in the\n     comments below.  The literal text is defined in shar_opt_strs.\n   \n     NOTE: the strings below are segmented with respect to the source string\n     shar_opt_strs.  The strings above are handed off for translation\n     at run time a paragraph at a time.  Consequently, they are presented here\n     for translation a paragraph at a time.\n   \n     ALSO: often the description for an option will reference another option\n     by name.  These are set off with apostrophe quotes (I hope).  Do not\n     translate option names.\n   */\n  /* referenced via sharOptions.pzCopyright */\n  puts(_(\"shar (GNU sharutils) 4.15.2\\n\\\nCopyright (C) 1994-2015 Free Software Foundation, Inc., all rights reserved.\\n\\\nThis is free software. It is licensed for use, modification and\\n\\\nredistribution under the terms of the GNU General Public License,\\n\\\nversion 3 or later <http://gnu.org/licenses/gpl.html>\\n\"));\n\n  /* referenced via sharOptions.pzCopyNotice */\n  puts(_(\"shar is free software: you can redistribute it and/or modify it under the\\n\\\nterms of the GNU General Public License as published by the Free Software\\n\\\nFoundation, either version 3 of the License, or (at your option) any later\\n\\\nversion.\\n\\n\"));\n  puts(_(\"shar is distributed in the hope that it will be useful, but WITHOUT ANY\\n\\\nWARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\\n\\\nFOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\\n\\\ndetails.\\n\\n\"));\n  puts(_(\"You should have received a copy of the GNU General Public License along\\n\\\nwith this program.  If not, see <http://www.gnu.org/licenses/>.\\n\"));\n\n  /* referenced via sharOptions.pzUsageTitle */\n  puts(_(\"shar (GNU sharutils) - create a shell archive\\n\\\nUsage:  %s [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [<file>...]\\n\"));\n\n  /* referenced via sharOptions.pzExplain */\n  puts(_(\"If no 'file's are specified, the list of input files is read from standard\\n\\\ninput.  Standard input must not be a terminal.\\n\"));\n\n  /* referenced via sharOptions.pzDetail */\n  puts(_(\"'shar' creates \\\"shell archives\\\" (or shar files) which are in text format\\n\\\nand can be emailed.  These files may be unpacked later by executing them\\n\\\nwith '/bin/sh'.  The resulting archive is sent to standard out unless the\\n\\\n'-o' option is given.  A wide range of features provide extensive\\n\\\nflexibility in manufacturing shars and in specifying 'shar' \\\"smartness\\\".\\n\\\nArchives may be fairly simple ('--vanilla-operation') or essentially a\\n\\\nmailable 'tar' archive.\\n\\n\"));\n  puts(_(\"Options may be specified in any order until a 'file' argument is\\n\\\nrecognized.  If the '--intermix-type' option has been specified, more\\n\\\ncompression and encoding options will be recognized between the 'file'\\n\\\narguments.\\n\\n\"));\n  puts(_(\"Though this program supports 'uuencode'-d files, they are deprecated.  If\\n\\\nyou are emailing files, please consider mime-encoded files.  If you do\\n\\\n'uuencode', base64 is the preferred encoding method.\\n\"));\n\n  /* referenced via sharOptions.pzFullVersion */\n  puts(_(\"shar (GNU sharutils) 4.15.2\"));\n\n  /* referenced via sharOptions.pzFullUsage */\n  puts(_(\"shar (GNU sharutils) - create a shell archive\\n\\\nUsage:  shar [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [<file>...]\\n\\n\"));\n  puts(_(\"Specify compression:\\n\\\n   -p, --intermix-type        specify compression for input files\\n\\\n                                - prohibits the option 'vanilla-operation'\\n\"));\n  puts(_(\"   -C, --compactor=PROG       specify compaction (compression) program PROG\\n\\\n                                - prohibits the option 'vanilla-operation'\\n\\\n                                - may appear multiple times\\n\\\n                                - it must be known to shar: xz gzip bzip2\\n\"));\n  puts(_(\"   -g, --level-of-compression=LEVEL\\n\\\n                              pass LEVEL for compression\\n\\\n                                - it must be in the range: 1 to 9\\n\\n\"));\n  puts(_(\"Specify file encoding methodology:\\n\\\n   -M, --mixed-uuencode       decide uuencoding for each file\\n\"));\n  puts(_(\"   -B, --uuencode             treat all files as binary\\n\\\n                                - an alternate for mixed-uuencode\\n\"));\n  puts(_(\"   -T, --text-files           treat all files as text\\n\\\n                                - an alternate for mixed-uuencode\\n\\n\"));\n  puts(_(\"Specifying file selection and output modes:\\n\"));\n  puts(_(\"   -o, --output-prefix=str    print output to file PREFIX.nn\\n\"));\n  puts(_(\"   -l, --whole-size-limit=SIZE\\n\\\n                              split archive, not files, to SIZE\\n\\\n                                - requires the option 'output-prefix'\\n\\\n                                - is scalable with a suffix: k/K/m/M/g/G/t/T\\n\\\n                                - it must lie in one of the ranges:\\n\\\n                                  8 to 1023, or 8192 to 4194304\\n\"));\n  puts(_(\"   -L, --split-size-limit=SIZE\\n\\\n                              split archive or files to SIZE\\n\\\n                                - requires the option 'output-prefix'\\n\\\n                                - is scalable with a suffix: k/K/m/M/g/G/t/T\\n\\\n                                - it must lie in one of the ranges:\\n\\\n                                  8 to 1023, or 8192 to 4194304\\n\\\n                                - an alternate for 'whole-size-limit'\\n\"));\n  puts(_(\"   -I, --input-file-list=FILE read file list from FILE\\n\\n\"));\n  puts(_(\"Controlling the shar headers:\\n\\\n   -n, --archive-name=NAME    use NAME to document the archive\\n\"));\n  puts(_(\"   -s, --submitter=NAME       override the submitter name with NAME\\n\"));\n  puts(_(\"   -a, --net-headers          output Submitted-by: & Archive-name: headers\\n\\\n                                - requires the option 'archive-name'\\n\"));\n  puts(_(\"   -c, --cut-mark             start the shar with a cut line\\n\"));\n  puts(_(\"   -t, --translate            translate messages in the script\\n\\n\"));\n  puts(_(\"Protecting against transmission issues:\\n\\\n       --no-character-count   do not use `wc -c' to check size\\n\"));\n  puts(_(\"   -D, --no-md5-digest        do not use md5sum digest to verify\\n\"));\n  puts(_(\"   -F, --force-prefix         apply the prefix character on every line\\n\"));\n  puts(_(\"   -d, --here-delimiter=DELIM use DELIM to delimit the files\\n\\n\"));\n  puts(_(\"Producing different kinds of shars:\\n\\\n   -V, --vanilla-operation    produce very simple shars\\n\"));\n  puts(_(\"   -P, --no-piping            use temporary files between programs\\n\"));\n  puts(_(\"   -x, --no-check-existing    blindly overwrite existing files\\n\"));\n  puts(_(\"   -X, --query-user           ask user before overwriting files\\n\\\n                                - prohibits the option 'vanilla-operation'\\n\"));\n  puts(_(\"   -m, --no-timestamp         do not restore modification times\\n\"));\n  puts(_(\"   -Q, --quiet-unshar         avoid verbose messages at unshar time\\n\"));\n  puts(_(\"   -f, --basename             restore in one directory, despite hierarchy\\n\\n\"));\n  puts(_(\"Internationalization options:\\n\\\n       --no-i18n              do not internationalize\\n\"));\n  puts(_(\"       --print-text-domain-dir  print directory with shar messages\\n\\n\"));\n  puts(_(\"User feedback/entertainment:\\n\\\n   -q, --quiet                do not output verbose messages\\n\"));\n  puts(_(\"       --silent               an alias for the 'quiet' option\\n\\n\"));\n  puts(_(\"Version, usage and configuration options:\\n\"));\n  puts(_(\"   -v, --version[=MODE]       output version information and exit\\n\"));\n  puts(_(\"   -h, --help                 display extended usage information and exit\\n\"));\n  puts(_(\"   -!, --more-help            extended usage information passed thru pager\\n\"));\n  puts(_(\"   -R, --save-opts[=FILE]     save the option state to a config file FILE\\n\"));\n  puts(_(\"   -r, --load-opts=FILE       load options from the config file FILE\\n\\\n                                - disabled with '--no-load-opts'\\n\\\n                                - may appear multiple times\\n\\n\"));\n  puts(_(\"Options are specified by doubled hyphens and their name or by a single\\n\\\nhyphen and the flag character.\\n\\\nIf no 'file's are specified, the list of input files is read from a\\n\\\nstandard input.  Standard input must not be a terminal.\\n\\n\"));\n  puts(_(\"The following option preset mechanisms are supported:\\n\"));\n  puts(_(\" - reading file $HOME/.sharrc\\n\\n\\\n'shar' creates \\\"shell archives\\\" (or shar files) which are in text format\\n\\\nand can be emailed.  These files may be unpacked later by executing them\\n\\\nwith '/bin/sh'.  The resulting archive is sent to standard out unless the\\n\\\n'-o' option is given.  A wide range of features provide extensive\\n\\\nflexibility in manufacturing shars and in specifying 'shar' \\\"smartness\\\".\\n\\\nArchives may be fairly simple ('--vanilla-operation') or essentially a\\n\\\nmailable 'tar' archive.\\n\\n\"));\n  puts(_(\"Options may be specified in any order until a 'file' argument is\\n\\\nrecognized.  If the '--intermix-type' option has been specified, more\\n\\\ncompression and encoding options will be recognized between the 'file'\\n\\\narguments.\\n\\n\"));\n  puts(_(\"Though this program supports 'uuencode'-d files, they are deprecated.  If\\n\\\nyou are emailing files, please consider mime-encoded files.  If you do\\n\\\n'uuencode', base64 is the preferred encoding method.\\n\\n\\\nPlease send bug reports to:  <bug-gnu-utils@gnu.org>\\n\"));\n\n  /* referenced via sharOptions.pzShortUsage */\n  puts(_(\"shar (GNU sharutils) - create a shell archive\\n\\\nUsage:  shar [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [<file>...]\\n\\\nTry 'shar --help' for more information.\\n\"));\n  /* LIBOPTS-MESSAGES: */\n#line 67 \"../autoopts.c\"\n  puts(_(\"allocation of %d bytes failed\\n\"));\n#line 93 \"../autoopts.c\"\n  puts(_(\"allocation of %d bytes failed\\n\"));\n#line 53 \"../init.c\"\n  puts(_(\"AutoOpts function called without option descriptor\\n\"));\n#line 86 \"../init.c\"\n  puts(_(\"\\tThis exceeds the compiled library version:  \"));\n#line 84 \"../init.c\"\n  puts(_(\"Automated Options Processing Error!\\n\"\n       \"\\t%s called AutoOpts function with structure version %d:%d:%d.\\n\"));\n#line 80 \"../autoopts.c\"\n  puts(_(\"realloc of %d bytes at 0x%p failed\\n\"));\n#line 88 \"../init.c\"\n  puts(_(\"\\tThis is less than the minimum library version:  \"));\n#line 121 \"../version.c\"\n  puts(_(\"Automated Options version %s\\n\"\n       \"\\tCopyright (C) 1999-2014 by Bruce Korb - all rights reserved\\n\"));\n#line 87 \"../makeshell.c\"\n  puts(_(\"(AutoOpts bug):  %s.\\n\"));\n#line 90 \"../reset.c\"\n  puts(_(\"optionResetOpt() called, but reset-option not configured\"));\n#line 292 \"../usage.c\"\n  puts(_(\"could not locate the 'help' option\"));\n#line 336 \"../autoopts.c\"\n  puts(_(\"optionProcess() was called with invalid data\"));\n#line 748 \"../usage.c\"\n  puts(_(\"invalid argument type specified\"));\n#line 598 \"../find.c\"\n  puts(_(\"defaulted to option with optional arg\"));\n#line 76 \"../alias.c\"\n  puts(_(\"aliasing option is out of range.\"));\n#line 234 \"../enum.c\"\n  puts(_(\"%s error:  the keyword '%s' is ambiguous for %s\\n\"));\n#line 108 \"../find.c\"\n  puts(_(\"  The following options match:\\n\"));\n#line 293 \"../find.c\"\n  puts(_(\"%s: ambiguous option name: %s (matches %d options)\\n\"));\n#line 161 \"../check.c\"\n  puts(_(\"%s: Command line arguments required\\n\"));\n#line 43 \"../alias.c\"\n  puts(_(\"%d %s%s options allowed\\n\"));\n#line 94 \"../makeshell.c\"\n  puts(_(\"%s error %d (%s) calling %s for '%s'\\n\"));\n#line 306 \"../makeshell.c\"\n  puts(_(\"interprocess pipe\"));\n#line 168 \"../version.c\"\n  puts(_(\"error: version option argument '%c' invalid.  Use:\\n\"\n       \"\\t'v' - version only\\n\"\n       \"\\t'c' - version and copyright\\n\"\n       \"\\t'n' - version and full copyright notice\\n\"));\n#line 58 \"../check.c\"\n  puts(_(\"%s error:  the '%s' and '%s' options conflict\\n\"));\n#line 217 \"../find.c\"\n  puts(_(\"%s: The '%s' option has been disabled.\"));\n#line 430 \"../find.c\"\n  puts(_(\"%s: The '%s' option has been disabled.\"));\n#line 38 \"../alias.c\"\n  puts(_(\"-equivalence\"));\n#line 469 \"../find.c\"\n  puts(_(\"%s: illegal option -- %c\\n\"));\n#line 110 \"../reset.c\"\n  puts(_(\"%s: illegal option -- %c\\n\"));\n#line 271 \"../find.c\"\n  puts(_(\"%s: illegal option -- %s\\n\"));\n#line 755 \"../find.c\"\n  puts(_(\"%s: illegal option -- %s\\n\"));\n#line 118 \"../reset.c\"\n  puts(_(\"%s: illegal option -- %s\\n\"));\n#line 335 \"../find.c\"\n  puts(_(\"%s: unknown vendor extension option -- %s\\n\"));\n#line 159 \"../enum.c\"\n  puts(_(\"  or an integer from %d through %d\\n\"));\n#line 169 \"../enum.c\"\n  puts(_(\"  or an integer from %d through %d\\n\"));\n#line 747 \"../usage.c\"\n  puts(_(\"%s error:  invalid option descriptor for %s\\n\"));\n#line 1081 \"../usage.c\"\n  puts(_(\"%s error:  invalid option descriptor for %s\\n\"));\n#line 385 \"../find.c\"\n  puts(_(\"%s: invalid option name: %s\\n\"));\n#line 527 \"../find.c\"\n  puts(_(\"%s: The '%s' option requires an argument.\\n\"));\n#line 156 \"../autoopts.c\"\n  puts(_(\"(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\\n\"\n       \"\\t'%s' and '%s'.\"));\n#line 94 \"../check.c\"\n  puts(_(\"%s error:  The %s option is required\\n\"));\n#line 632 \"../find.c\"\n  puts(_(\"%s: The '%s' option cannot have an argument.\\n\"));\n#line 151 \"../check.c\"\n  puts(_(\"%s: Command line arguments are not allowed.\\n\"));\n#line 535 \"../save.c\"\n  puts(_(\"error %d (%s) creating %s\\n\"));\n#line 234 \"../enum.c\"\n  puts(_(\"%s error:  '%s' does not match any %s keywords.\\n\"));\n#line 93 \"../reset.c\"\n  puts(_(\"%s error: The '%s' option requires an argument.\\n\"));\n#line 184 \"../save.c\"\n  puts(_(\"error %d (%s) stat-ing %s\\n\"));\n#line 238 \"../save.c\"\n  puts(_(\"error %d (%s) stat-ing %s\\n\"));\n#line 143 \"../restore.c\"\n  puts(_(\"%s error: no saved option state\\n\"));\n#line 231 \"../autoopts.c\"\n  puts(_(\"'%s' is not a command line option.\\n\"));\n#line 111 \"../time.c\"\n  puts(_(\"%s error:  '%s' is not a recognizable date/time.\\n\"));\n#line 132 \"../save.c\"\n  puts(_(\"'%s' not defined\\n\"));\n#line 50 \"../time.c\"\n  puts(_(\"%s error:  '%s' is not a recognizable time duration.\\n\"));\n#line 92 \"../check.c\"\n  puts(_(\"%s error:  The %s option must appear %d times.\\n\"));\n#line 164 \"../numeric.c\"\n  puts(_(\"%s error:  '%s' is not a recognizable number.\\n\"));\n#line 200 \"../enum.c\"\n  puts(_(\"%s error:  %s exceeds %s keyword count\\n\"));\n#line 330 \"../usage.c\"\n  puts(_(\"Try '%s %s' for more information.\\n\"));\n#line 45 \"../alias.c\"\n  puts(_(\"one %s%s option allowed\\n\"));\n#line 208 \"../makeshell.c\"\n  puts(_(\"standard output\"));\n#line 943 \"../makeshell.c\"\n  puts(_(\"standard output\"));\n#line 274 \"../usage.c\"\n  puts(_(\"standard output\"));\n#line 415 \"../usage.c\"\n  puts(_(\"standard output\"));\n#line 625 \"../usage.c\"\n  puts(_(\"standard output\"));\n#line 175 \"../version.c\"\n  puts(_(\"standard output\"));\n#line 274 \"../usage.c\"\n  puts(_(\"standard error\"));\n#line 415 \"../usage.c\"\n  puts(_(\"standard error\"));\n#line 625 \"../usage.c\"\n  puts(_(\"standard error\"));\n#line 175 \"../version.c\"\n  puts(_(\"standard error\"));\n#line 208 \"../makeshell.c\"\n  puts(_(\"write\"));\n#line 943 \"../makeshell.c\"\n  puts(_(\"write\"));\n#line 273 \"../usage.c\"\n  puts(_(\"write\"));\n#line 414 \"../usage.c\"\n  puts(_(\"write\"));\n#line 624 \"../usage.c\"\n  puts(_(\"write\"));\n#line 174 \"../version.c\"\n  puts(_(\"write\"));\n#line 60 \"../numeric.c\"\n  puts(_(\"%s error:  %s option value %ld is out of range.\\n\"));\n#line 44 \"../check.c\"\n  puts(_(\"%s error:  %s option requires the %s option\\n\"));\n#line 131 \"../save.c\"\n  puts(_(\"%s warning:  cannot save options - %s not regular file\\n\"));\n#line 183 \"../save.c\"\n  puts(_(\"%s warning:  cannot save options - %s not regular file\\n\"));\n#line 237 \"../save.c\"\n  puts(_(\"%s warning:  cannot save options - %s not regular file\\n\"));\n#line 256 \"../save.c\"\n  puts(_(\"%s warning:  cannot save options - %s not regular file\\n\"));\n#line 534 \"../save.c\"\n  puts(_(\"%s warning:  cannot save options - %s not regular file\\n\"));\n  /* END-LIBOPTS-MESSAGES */\n}",
      "lines": 330,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/src/shar-opts.h": {
    "aoGetsText": {
      "start_point": [
        380,
        0
      ],
      "end_point": [
        383,
        1
      ],
      "content": "static inline char* aoGetsText(char const* pz) {\n    if (pz == NULL) return NULL;\n    return (char*)gettext(pz);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "char",
        "* aoGetsText(char const* pz)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/src/shar.c": {
    "to_uchar": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        90,
        61
      ],
      "content": "static inline unsigned char to_uchar (char ch) { return ch; }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "init_shar_msg": {
      "start_point": [
        303,
        0
      ],
      "end_point": [
        344,
        1
      ],
      "content": "static void\ninit_shar_msg(void)\n{\n  int ix;\n  struct quoting_options * alwaysq, * doubleq;\n\n  if (translate_script)\n    {\n      for (ix = 0; ix < SHAR_MSG_CT; ix++)\n        shar_msg_table[ix] = gettext (shar_msg_table[ix]);\n    }\n\n  alwaysq  = clone_quoting_options (NULL);\n  set_quoting_style (alwaysq, shell_always_quoting_style);\n\n  doubleq  = clone_quoting_options (NULL);\n  set_quoting_style (doubleq, c_quoting_style);\n  set_char_quoting (doubleq, '\"', 1); // \");\n\n  for (ix = 0; ix < SHAR_MSG_CT; ix++)\n    {\n      char const * pz = shar_msg_table[ix];\n\n      switch (shar_msg_xform[ix])\n        {\n        case XFORM_PLAIN: continue;\n\n        case XFORM_APOSTROPHE:\n          pz = quotearg_alloc (pz, shar_msg_size[ix], alwaysq);\n          break;\n\n        case XFORM_DBL_QUOTE:\n          pz = quotearg_alloc (pz, shar_msg_size[ix], doubleq);\n          break;\n        }\n\n      shar_msg_table[ix] = pz;\n    }\n\n  free (alwaysq);\n  free (doubleq);\n}",
      "lines": 42,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "format_report": {
      "start_point": [
        346,
        0
      ],
      "end_point": [
        364,
        1
      ],
      "content": "static char const *\nformat_report(char const * fmt, char const * what)\n{\n  if (fmt == NULL)\n    return NULL;\n\n  {\n    size_t sz = strlen (fmt) + strlen (what) + 2;\n    char * res = scribble_get(sz);\n    int len = snprintf (res, sz, fmt, what);\n    if ((unsigned)len < sz)\n      return res;\n    if (len < 0)\n      die (SHAR_EXIT_BUG, _(\"printf formatting error:  %s\\n\"), fmt);\n\n    res = scribble_get(len + 1);\n    return res;\n  }\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\nformat_report(char const * fmt, char const * what)",
        "*"
      ]
    },
    "echo_status": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        407,
        1
      ],
      "content": "static void\necho_status (const char*  test,\n\t     const char*  ok_fmt,\n\t     const char*  bad_fmt,\n\t     const char*  what,\n\t     int die_on_failure )\n{\n  char const * good_quot;\n  char const * bad_quot;\n  char const * die_str;\n\n  /*\n     NOTE TO DEVELOPERS:  The two format arguments \"ok_fmt\" and \"bad_fmt\" are\n     expected to be correctly quoted for use by the shell command, \"echo\".\n     That is to say, the status strings contain an unadorned:\n         echo %s\n     and the input has to work correctly.\n\n     These formatting strings will normally have a \"%s\" in them somewhere to\n     fill in the value from \"what\".  Those strings are then used in the real\n     output formatting with show_all_status_z or show_good_status_z or\n     show_bad_status_z.  Not all do, so \"what\" can sometimes be NULL.\n   */\n  good_quot = format_report (ok_fmt, what);\n  bad_quot  = format_report (bad_fmt, what);\n  die_str   = die_on_failure ? show_status_dies_z : \"\";\n\n  if (good_quot != NULL)\n    {\n      if (bad_quot != NULL)\n        fprintf (output, show_all_status_z, test, good_quot,\n                 bad_quot, die_str);\n      else\n        fprintf (output, show_good_status_z, test, good_quot);\n    }\n\n  else if (bad_quot != NULL)\n    fprintf (output, show_bad_status_z, test, bad_quot, die_str);\n\n  else\n    die (SHAR_EXIT_BUG, _(\"sharutils bug - no status\"));\n}",
      "lines": 42,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "echo_text": {
      "start_point": [
        409,
        0
      ],
      "end_point": [
        420,
        1
      ],
      "content": "static void\necho_text (const char* format_pz, const char* arg_pz, bool cascade)\n{\n  static char const continue_z[] = \" &&\\n\";\n  size_t sz = strlen (format_pz) + strlen (arg_pz) + sizeof (continue_z);\n  char * bf = scribble_get (sz);\n  unsigned int len = (unsigned)snprintf (bf, sz, format_pz, arg_pz);\n\n  if (cascade)\n    memcpy (bf + len, continue_z, sizeof (continue_z));\n  fprintf (output, echo_string_z, bf);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "walkdown": {
      "start_point": [
        431,
        0
      ],
      "end_point": [
        548,
        1
      ],
      "content": "static int\nwalkdown (\n     walker_t routine,\n     const char *local_name,\n     const char *restore_name)\n{\n  DIR *directory;\t\t/* directory being scanned */\n  int status;\t\t\t/* status to return */\n\n  char *local_name_copy;\t/* writeable copy of local_name */\n  size_t local_name_length;\t/* number of characters in local_name_copy */\n  size_t sizeof_local_name;\t/* allocated size of local_name_copy */\n\n  char *restore_name_copy;\t/* writeable copy of restore_name */\n  int    restore_offset;\t/* passdown copy of restore_name */\n  size_t restore_name_length;\t/* number of characters in restore_name_copy */\n  size_t sizeof_restore_name;\t/* allocated size of restore_name_copy */\n\n  if (stat (local_name, &struct_stat))\n    {\n      error (0, errno, \"%s\", local_name);\n      return SHAR_EXIT_FILE_NOT_FOUND;\n    }\n\n  if (!S_ISDIR (struct_stat.st_mode & S_IFMT))\n    return (*routine) (local_name, restore_name);\n\n  if (directory = opendir (local_name), !directory)\n    {\n      error (0, errno, \"%s\", local_name);\n      return SHAR_EXIT_CANNOT_OPENDIR;\n    }\n\n  status = 0;\n\n  /* include trailing '/' in length */\n\n  local_name_length = strlen (local_name) + 1;\n  sizeof_local_name = local_name_length + 32;\n  local_name_copy   = xmalloc (sizeof_local_name);\n  memcpy (local_name_copy, local_name, local_name_length-1);\n  local_name_copy[ local_name_length-1 ] = '/';\n  local_name_copy[ local_name_length   ] = NUL;\n\n  restore_name_length = strlen (restore_name) + 1;\n  sizeof_restore_name = restore_name_length + 32;\n  restore_name_copy   = xmalloc (sizeof_restore_name);\n  memcpy (restore_name_copy, restore_name, restore_name_length-1);\n  restore_name_copy[ restore_name_length-1 ] = '/';\n  restore_name_copy[ restore_name_length   ] = NUL;\n\n  if ((restore_name_copy[0] == '.') && (restore_name_copy[1] == '/'))\n    restore_offset = 2;\n  else\n    restore_offset = 0;\n\n  for (;;)\n    {\n      struct dirent *entry = readdir (directory);\n      const char* pzN;\n      int space_need;\n\n      if (entry == NULL)\n\tbreak;\n\n      /* append the new file name after the trailing '/' char.\n         If we need more space, add in a buffer so we needn't\n         allocate over and over.  */\n\n      pzN = entry->d_name;\n      if (*pzN == '.')\n\t{\n\t  if (pzN[1] == NUL)\n\t    continue;\n\t  if ((pzN[1] == '.') && (pzN[2] == NUL))\n\t    continue;\n\t}\n\n      space_need = 1 + NAMLEN (entry);\n      if (local_name_length + space_need > sizeof_local_name)\n\t{\n\t  sizeof_local_name = local_name_length + space_need + 16;\n\t  local_name_copy = (char *)\n\t    xrealloc (local_name_copy, sizeof_local_name);\n\t}\n      strcpy (local_name_copy + local_name_length, pzN);\n\n      if (restore_name_length + space_need > sizeof_restore_name)\n\t{\n\t  sizeof_restore_name = restore_name_length + space_need + 16;\n\t  restore_name_copy = (char *)\n\t    xrealloc (restore_name_copy, sizeof_restore_name);\n\t}\n      strcpy (restore_name_copy + restore_name_length, pzN);\n\n      status = walkdown (routine, local_name_copy,\n\t\t\t restore_name_copy + restore_offset);\n      if (status != 0)\n\tbreak;\n    }\n\n  /* Clean up.  */\n\n  free (local_name_copy);\n  free (restore_name_copy);\n\n#if CLOSEDIR_VOID\n  closedir (directory);\n#else\n  if (closedir (directory))\n    {\n      error (0, errno, \"%s\", local_name);\n      return SHAR_EXIT_CANNOT_OPENDIR;\n    }\n#endif\n\n  return status;\n}",
      "lines": 118,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "walktree": {
      "start_point": [
        557,
        0
      ],
      "end_point": [
        610,
        1
      ],
      "content": "static int\nwalktree (walker_t routine, const char *local_name)\n{\n  const char *restore_name;\n  char *local_name_copy;\n\n  /* Remove crumb at end.  */\n  {\n    int len = strlen (local_name);\n    char *cursor;\n\n    local_name_copy = (char *) alloca (len + 1);\n    memcpy (local_name_copy, local_name, len + 1);\n    cursor = local_name_copy + len - 1;\n\n    while (*cursor == '/' && cursor > local_name_copy)\n      *(cursor--) = NUL;\n  }\n\n  /* Remove crumb at beginning.  */\n\n  if (HAVE_OPT(BASENAME))\n    restore_name = base_name (local_name_copy);\n  else if (!strncmp (local_name_copy, \"./\", 2))\n    restore_name = local_name_copy + 2;\n  else\n    restore_name = local_name_copy;\n\n#if NO_WALKTREE\n\n  /* Just act on current entry.  */\n\n  {\n    int status = stat (local_name_copy, &struct_stat);\n\n    if (status != 0)\n      {\n        error (0, errno, \"%s\", local_name_copy);\n        status = SHAR_EXIT_FILE_NOT_FOUND;\n      }\n    else\n      status = (*routine) (local_name_copy, restore_name);\n\n    return status;\n  }\n\n#else\n\n  /* Walk recursively.  */\n\n  return walkdown (routine, local_name_copy, restore_name);\n\n#endif\n}",
      "lines": 54,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mode_string": {
      "start_point": [
        618,
        0
      ],
      "end_point": [
        642,
        1
      ],
      "content": "static char *\nmode_string (unsigned mode)\n{\n  static char const modes[] = \"-rwxrwxrwx\";\n  static char result[12];\n  int ix  = 1;\n  int msk = 0400;\n\n  strcpy (result, \"----------\");\n\n  do  {\n    if (mode & msk)\n      result[ix] = modes[ix];\n    ix++;\n    msk >>= 1;\n  } while (msk != 0);\n\n  if (mode & 04000)\n    result[3] = 's';\n\n  if (mode & 02000)\n    result[6] = 's';\n\n  return result;\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nmode_string (unsigned mode)",
        "*"
      ]
    },
    "generate_configure": {
      "start_point": [
        649,
        0
      ],
      "end_point": [
        717,
        1
      ],
      "content": "static void\ngenerate_configure (void)\n{\n  if (! HAVE_OPT(NO_MD5_DIGEST))\n    fprintf (output, md5check_z, SM_not_verifying_sums);\n\n  fputs (clobber_check_z, output);\n\n  if (! HAVE_OPT(NO_I18N))\n    {\n      fputs (i18n_z, output);\n      /* Above the name of the program of the package which supports the\n\t --print-text-domain-dir option has to be given.  */\n    }\n\n  if (! HAVE_OPT(QUIET_UNSHAR))\n    {\n      if (HAVE_OPT(VANILLA_OPERATION))\n\tfputs (dev_tty_nocheck_z, output);\n      else\n\t{\n\t  if (HAVE_OPT(QUERY_USER))\n\t    /* Check if /dev/tty exists.  If yes, define shar_tty to\n\t       '/dev/tty', else, leave it empty.  */\n\n\t    fputs (dev_tty_check_z, output);\n\n\t  /* Try to find a way to echo a message without newline.  Set\n\t     shar_n to '-n' or nothing for an echo option, and shar_c\n\t     to '\\c' or nothing for a string terminator.  */\n\n\t  fputs (echo_checks_z, output);\n\t}\n    }\n\n  if (! HAVE_OPT(NO_TIMESTAMP))\n    {\n      fprintf (output, timestamp_z, SM_time_not_set);\n    }\n\n  if ((! HAVE_OPT(WHOLE_SIZE_LIMIT)) || (part_number == 1))\n    {\n      echo_status (ck_lockdir_z, NULL, SM_lock_dir_exists, lock_dir_z, 1);\n\n      /* Create locking directory.  */\n      if (HAVE_OPT(VANILLA_OPERATION))\n\techo_status (make_lock_dir_z, NULL, SM_no_lock_dir, lock_dir_z, 1);\n      else\n\techo_status (make_lock_dir_z, SM_x_lock_dir_created,\n                     SM_x_no_lock_dir, lock_dir_z, 1);\n    }\n  else\n    {\n      fprintf (output, seq_check_z,\n               SM_unpack_part_1, part_number,\n               SM_unpack_next_part);\n    }\n\n  if (HAVE_OPT(QUERY_USER))\n    {\n      fprintf (output, query_answers_z,\n\t       SM_ans_yes,    SM_yes_means,\n\t       SM_ans_no,     SM_no_means,\n\t       SM_ans_all,    SM_all_means,\n\t       SM_ans_none,   SM_none_means,\n\t       SM_ans_help,   SM_help_means,\n\t       SM_ans_quit,   SM_quit_means);\n    }\n}",
      "lines": 69,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "generate_mkdir": {
      "start_point": [
        724,
        0
      ],
      "end_point": [
        781,
        1
      ],
      "content": "static void\ngenerate_mkdir (const char *path)\n{\n  const char *quoted_path;\n\n  /* If already generated code for this dir creation, don't do again.  */\n\n  {\n    int    ct = mkdir_already_ct;\n    char** pp = mkdir_already;\n\n    while (--ct > 0)\n      {\n        if (strcmp (*(pp++), path) == 0)\n          return;\n      }\n  }\n\n  /* Haven't done this one.  */\n\n  if (++mkdir_already_ct > mkdir_alloc_ct)\n    {\n      /*\n       *  We need more name space.  Get larger and larger chunks of space.\n       *  The bound is when integers go negative.  Too many directories.  :)\n       *\n       *  16, 40, 76, 130, 211, 332, 514, 787, 1196, 1810, 2731, 4112, ...\n       */\n      mkdir_alloc_ct += 16 + (mkdir_alloc_ct/2);\n      if (mkdir_alloc_ct < 0)\n        die (SHAR_EXIT_FAILED,\n             _(\"Too many directories for mkdir generation\"));\n\n      if (mkdir_already != NULL)\n        mkdir_already =\n          xrealloc (mkdir_already, mkdir_alloc_ct * sizeof (char*));\n      else\n        mkdir_already = xmalloc (mkdir_alloc_ct * sizeof (char*));\n    }\n\n  /* Add the directory into our \"we've done this already\" table */\n\n  mkdir_already[ mkdir_already_ct-1 ] = xstrdup (path);\n\n  /* Generate the text.  */\n\n  quoted_path = quotearg_n_style (\n    QUOT_ID_PATH, shell_always_quoting_style, path);\n  fprintf (output, dir_check_z, quoted_path);\n  if (! HAVE_OPT(QUIET_UNSHAR))\n    {\n      fprintf (output, dir_create_z, quoted_path);\n      echo_status (aok_check_z, SM_x_dir_created, SM_x_no_dir, path, 1);\n    }\n  else\n    fprintf (output, \"  mkdir %s || exit 1\\n\", quoted_path);\n  fputs (\"fi\\n\", output);\n}",
      "lines": 58,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "clear_mkdir_already": {
      "start_point": [
        783,
        0
      ],
      "end_point": [
        795,
        1
      ],
      "content": "static void\nclear_mkdir_already (void)\n{\n  char** pp = mkdir_already;\n  int    ct = mkdir_already_ct;\n\n  mkdir_already_ct = 0;\n  while (--ct >= 0)\n    {\n      free (*pp);\n      *(pp++) = NULL;\n    }\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "generate_mkdir_script": {
      "start_point": [
        801,
        0
      ],
      "end_point": [
        825,
        1
      ],
      "content": "static void\ngenerate_mkdir_script (const char * path)\n{\n  char *cursor;\n\n  for (cursor = strchr (path, '/'); cursor; cursor = strchr (cursor + 1, '/'))\n    {\n\n      /* Avoid empty string if leading or double '/'.  */\n\n      if (cursor == path || *(cursor - 1) == '/')\n\tcontinue;\n\n      /* Omit '.'.  */\n\n      if (cursor[-1] == '.' && (cursor == path + 1 || cursor[-2] == '/'))\n\tcontinue;\n\n      /* Temporarily terminate string.  FIXME!  */\n\n      *cursor = 0;\n      generate_mkdir (path);\n      *cursor = '/';\n    }\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_accessibility": {
      "start_point": [
        833,
        0
      ],
      "end_point": [
        843,
        1
      ],
      "content": "static int\ncheck_accessibility (const char *local_name, const char *restore_name)\n{\n  if (access (local_name, 4))\n    {\n      error (0, errno, _(\"Cannot access %s\"), local_name);\n      return SHAR_EXIT_FILE_NOT_FOUND;\n    }\n\n  return SHAR_EXIT_SUCCESS;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "generate_one_header_line": {
      "start_point": [
        849,
        0
      ],
      "end_point": [
        856,
        1
      ],
      "content": "static int\ngenerate_one_header_line (const char *local_name, const char *restore_name)\n{\n  char buf[INT_BUFSIZE_BOUND (off_t)];\n  fprintf (output, \"# %6s %s %s\\n\", offtostr (struct_stat.st_size, buf),\n\t   mode_string (struct_stat.st_mode), restore_name);\n  return 0;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "print_caution_notes": {
      "start_point": [
        858,
        0
      ],
      "end_point": [
        887,
        1
      ],
      "content": "static void\nprint_caution_notes (FILE * fp)\n{\n  {\n    char const * msg;\n\n    if (! HAVE_OPT(NO_CHECK_EXISTING))\n      msg = exist_keep_z;\n    else if (HAVE_OPT(QUERY_USER))\n      msg = exist_ask_z;\n    else\n      msg = exist_kill_z;\n\n    fprintf (fp, exist_note_z, msg);\n  }\n\n  if (HAVE_OPT(WHOLE_SIZE_LIMIT))\n    {\n      int len = snprintf (explain_text_fmt, sizeof (explain_text_fmt),\n                          explain_fmt_fmt_z, explain_1_len, explain_2_len);\n      if ((unsigned)len >= sizeof (explain_text_fmt))\n        strcpy (explain_text_fmt, \"#%-256s\\n#%-256s\\n\");\n\n      /* May be split, provide for white space for an explanation.  */\n\n      fputs (\"#\\n\", output);\n      archive_type_position = ftello (output);\n      fprintf (fp, explain_text_fmt, \"\", \"\");\n    }\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_header_stamp": {
      "start_point": [
        889,
        0
      ],
      "end_point": [
        935,
        1
      ],
      "content": "static void\nprint_header_stamp (FILE * fp)\n{\n  {\n    char const * pz = HAVE_OPT(ARCHIVE_NAME) ? OPT_ARG(ARCHIVE_NAME) : \"\";\n    char const * ch = HAVE_OPT(ARCHIVE_NAME) ? \", a shell\" : \"a shell\";\n\n    fprintf (fp, file_leader_z, pz, ch, PACKAGE, VERSION, sharpid);\n  }\n\n  {\n    static char ftime_fmt[] = \"%Y-%m-%d %H:%M %Z\";\n\n    /*\n     * All fields are two characters, except %Y is four and\n     * %Z may be up to 30 (?!?!).  Anyway, if that still fails,\n     * we'll drop back to \"%z\".  We'll give up if that fails.\n     */\n    char buffer[sizeof (ftime_fmt) + 64];\n    time_t now;\n    struct tm * local_time;\n    time (&now);\n    local_time = localtime (&now);\n    {\n      size_t l =\n        strftime (buffer, sizeof (buffer) - 1, ftime_fmt, local_time);\n      if (l == 0)\n        {\n          ftime_fmt[sizeof(ftime_fmt) - 2] = 'z';\n          l = strftime (buffer, sizeof (buffer) - 1, ftime_fmt, local_time);\n        }\n      if (l > 0)\n        fprintf (fp, made_on_comment_z, buffer, OPT_ARG(SUBMITTER));\n    }\n  }\n\n  {\n    char * c_dir = xgetcwd ();\n    if (c_dir != NULL)\n      {\n        fprintf (fp, source_dir_comment_z, c_dir);\n        free (c_dir);\n      }\n    else\n      error (0, errno, _(\"Cannot get current directory name\"));\n  }\n}",
      "lines": 47,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "generate_full_header": {
      "start_point": [
        941,
        0
      ],
      "end_point": [
        989,
        1
      ],
      "content": "static void\ngenerate_full_header (int argc, char * const * argv)\n{\n  int counter;\n\n  for (counter = 0; counter < argc; counter++)\n    {\n      struct stat sb;\n      /* If we cannot stat it, it is either a valid option or we have\n         already errored out.  */\n      if (stat (argv[counter], &sb) != 0)\n        continue;\n\n      if (walktree (check_accessibility, argv[counter]))\n\texit (SHAR_EXIT_FAILED);\n    }\n\n  if (HAVE_OPT(NET_HEADERS))\n    {\n      static char const by[] =\n        \"Submitted-by: %s\\nArchive-name: %s%s%02d\\n\\n\";\n      bool has_slash = (strchr (OPT_ARG(ARCHIVE_NAME), '/') != NULL);\n      int  part = (part_number > 0) ? part_number : 1;\n\n      fprintf (output, by, OPT_ARG(SUBMITTER), OPT_ARG(ARCHIVE_NAME),\n               has_slash ? \"\" : \"/part\", part);\n    }\n\n  if (HAVE_OPT(CUT_MARK))\n    fputs (cut_mark_line_z, output);\n\n  print_header_stamp (output);\n  print_caution_notes (output);\n  fputs (contents_z, output);\n\n  for (counter = 0; counter < argc; counter++)\n    {\n      struct stat sb;\n      /* If we cannot stat it, it is either a valid option or we have\n         already errored out.  */\n      if (stat (argv[counter], &sb) != 0)\n        continue;\n\n      (void) walktree (generate_one_header_line, argv[counter]);\n    }\n  fputs (\"#\\n\", output);\n\n  generate_configure ();\n}",
      "lines": 49,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "change_files": {
      "start_point": [
        991,
        0
      ],
      "end_point": [
        1048,
        1
      ],
      "content": "void\nchange_files (const char * restore_name, off_t * remaining_size)\n{\n  /* Change to another file.  */\n\n  DEBUG_PRINT (\"New file, remaining %s, \", *remaining_size);\n  DEBUG_PRINT (\"Limit still %s\\n\", OPT_VALUE_WHOLE_SIZE_LIMIT);\n\n  /* Close the \"&&\" and report an error if any of the above\n     failed.  */\n\n  fputs (\" :\\n\", output);\n  echo_status (\"test $? -ne 0\", SM_restore_failed, NULL, restore_name, 0);\n\n  {\n    size_t sz = strlen (SM_end_of_part) + 2 * LOG10_MAX_INT;\n    char * bf = scribble_get (sz);\n    snprintf (bf, sz, SM_end_of_part, part_number, part_number+1);\n    fprintf (output, echo_string_z, bf);\n  }\n\n  close_output (part_number + 1);\n\n  /* Clear mkdir_already in case the user unshars out of order.  */\n\n  clear_mkdir_already ();\n\n  /* Form the next filename.  */\n\n  open_output ();\n  if (! HAVE_OPT(QUIET))\n    fprintf (stderr, _(\"Starting file %s\\n\"), output_filename);\n\n  if (HAVE_OPT(NET_HEADERS))\n    {\n      fprintf (output, \"Submitted-by: %s\\n\", OPT_ARG(SUBMITTER));\n      fprintf (output, \"Archive-name: %s%s%02d\\n\\n\", OPT_ARG(ARCHIVE_NAME),\n\t       strchr (OPT_ARG(ARCHIVE_NAME), '/') ? \"\" : \"/part\",\n\t       part_number ? part_number : 1);\n    }\n\n  if (HAVE_OPT(CUT_MARK))\n    fputs (cut_mark_line_z, output);\n\n  {\n    static const char part_z[] = \"part %02d of %s \";\n    char const * nm = HAVE_OPT(ARCHIVE_NAME) ? OPT_ARG(ARCHIVE_NAME) :\n      \"a multipart\";\n    off_t len = sizeof(part_z) + strlen(nm) + LOG10_MAX_INT;\n    char * bf = scribble_get (len);\n    snprintf (bf, len, part_z, part_number, nm);\n    fprintf (output, file_leader_z, bf, \"\", PACKAGE, VERSION, sharpid);\n  }\n\n  generate_configure ();\n\n  first_file_position = ftello (output);\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "read_byte_size": {
      "start_point": [
        1050,
        0
      ],
      "end_point": [
        1085,
        1
      ],
      "content": "static void\nread_byte_size (char * wc, size_t wc_sz, FILE * pfp)\n{\n  char * pz = wc;\n\n  /* Read to the first digit or EOF */\n  for (;;)\n    {\n      int ch = getc (pfp);\n      if (ch == EOF)\n        goto bogus_number; /* no digits were found */\n\n      if (isdigit (ch))\n        {\n          *(pz++) = ch;\n          break;\n        }\n    }\n\n  for (;;)\n    {\n      int ch = getc (pfp);\n      if (! isdigit (ch))\n        break;\n      *(pz++) = ch;\n      if (pz >= wc + wc_sz)\n        goto bogus_number; /* number is waaay too large */\n    }\n\n  *pz = NUL;\n  return;\n\n bogus_number:\n  wc[0] = '0'; /* assume zero length */\n  wc[1] = NUL;\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "emit_char_ct_validation": {
      "start_point": [
        1089,
        0
      ],
      "end_point": [
        1133,
        1
      ],
      "content": "static void\nemit_char_ct_validation (\n     char const * local_name,\n     char const * quoted_name,\n     char const * restore_name,\n     int did_md5)\n{\n  /* Shell command able to count characters from its standard input.\n     We have to take care for the locale setting because wc in multi-byte\n     character environments gets different results.  */\n\n  char wc[1 + LOG10_MAX_INT * 2]; // enough for 64 bit size\n  char * command;\n\n#ifndef __MINGW32__\n  static char const cct_cmd[] = \"LC_ALL=C wc -c < %s\";\n#else\n  static char const cct_cmd[] = \"set LC_ALL=C & wc -c \\\"%s\\\"\";\n  quoted_name = local_name;\n#endif\n\n  command = alloca (sizeof(cct_cmd) + strlen (quoted_name));\n  sprintf (command, cct_cmd, quoted_name);\n\n  {\n    FILE * pfp = popen (command, \"r\");\n    if (pfp == NULL)\n      die (SHAR_EXIT_FAILED, _(\"Could not popen command\"), command);\n\n    /*  Read from stdin white space followed by digits.  That ought to be\n        followed by a newline or a NUL.  */\n    read_byte_size (wc, sizeof(wc), pfp);\n    pclose (pfp);\n  }\n\n  if (did_md5)\n    fputs (otherwise_z, output);\n\n  {\n    size_t sz = strlen (SM_bad_size) + strlen (restore_name) + LOG10_MAX_INT;\n    char * bf = scribble_get (sz);\n    snprintf (bf, sz, SM_bad_size, restore_name, wc);\n    fprintf (output, ck_chct_z, restore_name, wc, bf);\n  }\n}",
      "lines": 45,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "file_needs_encoding": {
      "start_point": [
        1147,
        0
      ],
      "end_point": [
        1244,
        1
      ],
      "content": "static do_uue_t\nfile_needs_encoding (char const * fname)\n{\n#ifdef __CHAR_UNSIGNED__\n#  define BYTE_IS_BINARY(_ch)  (byte_is_binary[_ch])\n#else\n#  define BYTE_IS_BINARY(_ch)  (byte_is_binary[(_ch) & 0xFF])\n#endif\n\n  FILE * infp;\n  int    line_length;\n\n  if (cmpr_state != NULL)\n    return true; // compression always implies encoding\n\n  switch (WHICH_OPT_MIXED_UUENCODE) {\n  case VALUE_OPT_TEXT_FILES: return false;\n  case VALUE_OPT_UUENCODE:   return true;\n  default: break;\n  }\n\n  /* Read the input file, seeking for one non-ASCII character.  Considering the\n     average file size, even reading the whole file (if it is text) would\n     usually be faster than invoking 'file'.  */\n\n  infp = fopen (fname, \"r\" FOPEN_BINARY);\n\n  if (infp == NULL)\n    {\n      error (0, errno, _(\"Cannot open file %s\"), fname);\n      return fail;\n    }\n\n  /* Assume initially that the input file is text.  Then try to prove\n     it is binary by looking for binary characters or long lines.  */\n\n  line_length = 0;\n\n  for (;;)\n    {\n      int ch = getc (infp);\n\n    retest_char:\n      switch (ch) {\n      case EOF:  goto loop_done;\n      case '\\n': line_length = 0; break;\n      case 'F':\n      case 'f':\n        if (line_length > 0)\n          {\n            line_length++;\n            break;\n          }\n\n        {\n          /*\n           * Mail handlers like to mutilate lines beginning with \"from \".\n           * Therefore, if a line starts with \"From \" or \"from \", deem\n           * the file to need encoding.\n           */\n          static char const from[] = \"rom \";\n          char const * p = from;\n          for (;;)\n            {\n              line_length++;\n              ch = getc (infp);\n              if (ch != *p)\n                goto retest_char;\n              if (*++p == NUL)\n                {\n                  line_length = MAXIMUM_NON_BINARY_LINE;\n                  goto loop_done;\n                }\n            }\n          /* NOTREACHED */\n        }\n\n      default:\n        if (BYTE_IS_BINARY(ch))\n          {\n            line_length = MAXIMUM_NON_BINARY_LINE;\n            goto loop_done;\n          }\n\n        line_length++;\n      } /* switch (ch) */\n\n      if (line_length >= MAXIMUM_NON_BINARY_LINE)\n        break;\n    } loop_done:;\n\n  fclose (infp);\n\n  /* Text files should terminate with an end of line.  */\n\n  return (line_length != 0) ? true : false;\n#undef BYTE_IS_BINARY\n}",
      "lines": 98,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "do_uue_t"
      ]
    },
    "encode_file_to_pipe": {
      "start_point": [
        1248,
        0
      ],
      "end_point": [
        1291,
        1
      ],
      "content": "static void\nencode_file_to_pipe (\n    int out_fd,\n    const char *  local_name,\n    const char *  q_local_name,\n    const char *  restore_name)\n{\n  /* Start writing the pipe with encodes.  */\n\n  FILE * in_fp;\n  FILE * out_fp;\n  char * cmdline  = alloca (strlen (q_local_name) + 64);\n  char const * open_txt = cmdline;\n  char const * open_fmt = \"popen\";\n\n  if (cmpr_state != NULL)\n    {\n      sprintf (cmdline, cmpr_state->cmpr_cmd_fmt,\n               cmpr_state->cmpr_level, q_local_name);\n      in_fp = popen (cmdline, \"r\" FOPEN_BINARY);\n    }\n  else\n    {\n      in_fp = fopen (local_name, \"r\" FOPEN_BINARY);\n      open_fmt = \"fopen\";\n      open_txt = local_name;\n    }\n\n  if (in_fp == NULL)\n    fserr (SHAR_EXIT_FAILED, open_fmt, open_txt);\n\n  out_fp = fdopen (out_fd, \"w\" FOPEN_BINARY);\n\n  fprintf (out_fp, mode_fmt_z, restore_name);\n\n  copy_file_encoded (in_fp, out_fp);\n  fprintf (out_fp, \"end\\n\");\n  if (cmpr_state != NULL)\n    pclose (in_fp);\n  else\n    fclose (in_fp);\n\n  exit (EXIT_SUCCESS);\n}",
      "lines": 44,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "open_encoded_file": [
      {
        "start_point": [
          1293,
          0
        ],
        "end_point": [
          1328,
          1
        ],
        "content": "static FILE *\nopen_encoded_file (char const * local_name, char const * q_local_name,\n               const char *  restore_name)\n{\n  int pipex[2];\n\n  /* Fork a uuencode process.  */\n\n  if (pipe (pipex) < 0)\n    fserr (SHAR_EXIT_FAILED, _(\"call\"), \"pipe(2)\");\n  fflush (output);\n\n  switch (fork ())\n    {\n    case 0:\n      close (pipex[0]);\n      encode_file_to_pipe (pipex[1], local_name, q_local_name, restore_name);\n      /* NOTREACHED */\n\n    case -1:\n      fserr (SHAR_EXIT_FAILED, _(\"call\"), \"fork\");\n      return NULL;\n\n    default:\n      /* Parent, create a file to read.  */\n      break;\n    }\n  close (pipex[1]);\n\n  {\n    FILE * fp = fdopen (pipex[0], \"r\" FOPEN_BINARY);\n    if (fp == NULL)\n      fserr (SHAR_EXIT_FAILED, \"fdopen\", _(\"pipe fd\"));\n    return fp;\n  }\n}",
        "lines": 36,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "FILE",
          "*\nopen_encoded_file (char const * local_name, char const * q_local_name,\n               const char *  restore_name)",
          "*"
        ]
      },
      {
        "start_point": [
          1359,
          0
        ],
        "end_point": [
          1416,
          1
        ],
        "content": "static FILE *\nopen_encoded_file (char const * local_name,\n               char const * q_local_name,\n               char const * restore_name)\n{\n  char * cmdline, * p;\n  static char uu_cmd_fmt[] = \"uuencode %s\";\n  size_t sz = sizeof (uu_cmd_fmt);\n  /* A command to use for encoding an uncompressed text file.  */\n#ifdef __MINGW32__\n  /* Windows needs a different style of quoting.  */\n  q_local_name = win_cmd_quote (local_name);\n  restore_name = win_cmd_quote (restore_name);\n#else\n  restore_name = quotearg_n_style (QUOT_ID_RNAME, shell_always_quoting_style,\n                                   restore_name);\n#endif\n\n  sz += strlen (q_local_name) + strlen (restore_name);\n\n  if (cmpr_state == NULL)\n    {\n      p = cmdline = alloca (sz);\n\n      /* Insert the uuencode command.  It will be reading from the\n         original file, so append the name of the remote file.  */\n      sprintf (p, uu_cmd_fmt, q_local_name);\n      strcat (strcat (p, \" \"), restore_name);\n    }\n  else\n    {\n      /* Before uuencoding the file, we compress it.  The compressed output\n         is piped into uuencode.  */\n      sz += strlen (cmpr_state->cmpr_cmd_fmt) + LOG10_MAX_INT;\n\n      p = cmdline = alloca (sz);\n      sprintf (p, cmpr_state->cmpr_cmd_fmt, cmpr_state->cmpr_level,\n               q_local_name);\n      p += strlen (p);\n      /* Append a pipe into uuencode.  */\n      strcat (p, \" | \");\n      p += strlen (p);\n      sprintf (p, uu_cmd_fmt, restore_name);\n    }\n\n  /* Don't use \"r\" FOPEN_BINARY mode because it might be \"rb\", while we need\n     text-mode read here, because we will be reading pure text from\n     uuencode, and we want to drop any CR characters from the CRLF\n     line endings, when we write the result into the shar.  */\n  {\n    FILE * in_fp = popen (cmdline, \"r\" FOPEN_TEXT);\n\n    if (in_fp == NULL)\n      fserr (SHAR_EXIT_FAILED, \"popen\", cmdline);\n\n    return in_fp;\n  }\n}",
        "lines": 58,
        "depth": 11,
        "decorators": [
          "static",
          "static",
          "FILE",
          "*\nopen_encoded_file (char const * local_name,\n               char const * q_local_name,\n               char const * restore_name)",
          "*"
        ]
      }
    ],
    "win_cmd_quote": {
      "start_point": [
        1333,
        0
      ],
      "end_point": [
        1350,
        1
      ],
      "content": "static char *\nwin_cmd_quote (char const * fname)\n{\n  static size_t blen = 0;\n  static char   *buf  = NULL;\n  size_t        nlen = strlen (fname);\n  if (nlen + 3 > blen)\n    {\n      blen = nlen + 3;\n      buf = buf ? malloc (blen) : realloc (buf, blen);\n      if (buf == NULL)\n        fserr (SHAR_EXIT_FAILED, \"malloc\", fname);\n    }\n  *buf = '\"';\n  memcpy (buf+1, fname, nlen);\n  buf[nlen + 1] = '\"';\n  buf[nlen + 2] = NUL;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nwin_cmd_quote (char const * fname)",
        "*"
      ]
    },
    "isatty": {
      "start_point": [
        1352,
        0
      ],
      "end_point": [
        1356,
        1
      ],
      "content": "static int\nisatty (int fd)\n{\n  return (_isatty (fd) && _lseek (fd, SEEK_CUR, 0L) == -1);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "open_shar_input": {
      "start_point": [
        1420,
        0
      ],
      "end_point": [
        1463,
        1
      ],
      "content": "static FILE *\nopen_shar_input (\n     const char *  local_name,\n     const char *  q_local_name,\n     const char *  restore_name,\n     const char *  q_restore_name,\n     const char ** file_type_p,\n     const char ** file_type_remote_p,\n     int *pipe_p)\n{\n  FILE * infp;\n\n  uuencode_file = file_needs_encoding (local_name);\n  if (uuencode_file == fail)\n    return NULL;\n\n  /* If mixed, determine the file type.  */\n\n  if (! uuencode_file)\n    {\n      *file_type_p = _(\"text\");\n      *file_type_remote_p = SM_type_text;\n\n      infp = fopen (local_name, \"r\" FOPEN_BINARY);\n      if (infp == NULL)\n        fserr (SHAR_EXIT_FAILED, \"fopen\", local_name);\n      *pipe_p = 0;\n    }\n  else\n    {\n      if (cmpr_state != NULL)\n        *file_type_p = *file_type_remote_p = cmpr_state->cmpr_title;\n      else\n        {\n          *file_type_p        = _(\"text\");\n          *file_type_remote_p = _(\"(text)\");\n        }\n\n      infp = open_encoded_file (local_name, q_local_name, restore_name);\n      *pipe_p = 1;\n    }\n\n  return infp;\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "FILE",
        "*\nopen_shar_input (\n     const char *  local_name,\n     const char *  q_local_name,\n     const char *  restore_name,\n     const char *  q_restore_name,\n     const char ** file_type_p,\n     const char ** file_type_remote_p,\n     int *pipe_p)",
        "*"
      ]
    },
    "split_shar_ed_file": {
      "start_point": [
        1468,
        0
      ],
      "end_point": [
        1568,
        1
      ],
      "content": "static void\nsplit_shar_ed_file (char const * restore, off_t * size_left, int * split_flag)\n{\n  DEBUG_PRINT (\"New file, remaining %s, \", (*size_left));\n  DEBUG_PRINT (\"Limit still %s\\n\", OPT_VALUE_WHOLE_SIZE_LIMIT);\n\n  fprintf (output, \"%s\\n\", OPT_ARG(HERE_DELIMITER));\n\n  /* Close the \"&&\" and report an error if any of the above\n     failed.  */\n\n  fputs (\" :\\n\", output);\n  echo_status (\"test $? -ne 0\", SM_restore_failed, NULL, restore, 0);\n\n  if (! HAVE_OPT(NO_CHECK_EXISTING))\n    fputs (\"fi\\n\", output);\n\n  if (HAVE_OPT(QUIET_UNSHAR))\n    {\n      size_t sz = strlen (SM_end_of_part) + 2 * LOG10_MAX_INT;\n      char * bf = scribble_get (sz);\n      snprintf (bf, sz, SM_end_of_part, part_number, part_number + 1);\n      fprintf (output, echo_string_z, bf);\n    }\n  else\n    {\n      char const * nm =\n        HAVE_OPT(ARCHIVE_NAME) ? OPT_ARG(ARCHIVE_NAME) : SM_word_archive;\n      size_t sz1 = strlen (SM_s_end_of_part) + strlen (nm) + LOG10_MAX_INT;\n      size_t sz2 = strlen (SM_contin_in_part) + strlen (restore)\n                 + LOG10_MAX_INT;\n      char * bf;\n      if (sz1 < sz2)\n        sz1 = sz2;\n      bf = scribble_get (sz1);\n      snprintf (bf, sz1, SM_s_end_of_part, nm, part_number);\n      fprintf (output, echo_string_z, bf);\n      snprintf (bf, sz1, SM_contin_in_part, restore, (long)part_number + 1);\n      fprintf (output, echo_string_z, bf);\n    }\n\n  fwrite (split_file_z, sizeof (split_file_z) - 1, 1, output);\n\n  if (part_number == 1)\n    {\n      /* Rewrite the info lines on the first header.  */\n\n      fseeko (output, archive_type_position, SEEK_SET);\n      fprintf (output, explain_text_fmt, explain_1_z, explain_2_z);\n      fseeko (output, 0, SEEK_END);\n    }\n  close_output (part_number + 1);\n\n  /* Next! */\n\n  open_output ();\n\n  if (HAVE_OPT(NET_HEADERS))\n    {\n      fprintf (output, \"Submitted-by: %s\\n\", OPT_ARG(SUBMITTER));\n      fprintf (output, \"Archive-name: %s%s%02d\\n\\n\",\n               OPT_ARG(ARCHIVE_NAME),\n               strchr (OPT_ARG(ARCHIVE_NAME), '/') ? \"\" : \"/part\",\n               part_number ? part_number : 1);\n    }\n\n  if (HAVE_OPT(CUT_MARK))\n    fputs (cut_mark_line_z, output);\n\n  fprintf (output, continue_archive_z,\n           base_name (output_filename), part_number,\n           HAVE_OPT(ARCHIVE_NAME)\n           ? OPT_ARG(ARCHIVE_NAME) : \"a multipart archive\",\n           restore, sharpid);\n\n  generate_configure ();\n\n  if (! HAVE_OPT(NO_CHECK_EXISTING))\n    {\n      if (HAVE_OPT(QUIET_UNSHAR))\n        fputs (split_continue_quietly_z, output);\n      else\n        {\n          fputs (split_continue_z, output);\n          fprintf (output, SM_still_skipping, restore);\n          fputs (otherwise_z, output);\n        }\n    }\n\n  if (! HAVE_OPT(QUIET))\n    fprintf (stderr, _(\"Continuing file %s\\n\"), output_filename);\n  if (! HAVE_OPT(QUIET_UNSHAR))\n    echo_text (SM_continuing, restore, false);\n\n  fprintf (output, split_resume_z,\n           line_prefix, OPT_ARG(HERE_DELIMITER),\n           uuencode_file ? \"${lock_dir}/uue\" : restore);\n\n  (*size_left) = OPT_VALUE_WHOLE_SIZE_LIMIT - ftello (output);\n  *split_flag  = 1;\n}",
      "lines": 101,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "process_shar_input": {
      "start_point": [
        1570,
        0
      ],
      "end_point": [
        1654,
        1
      ],
      "content": "static void\nprocess_shar_input (FILE * input, off_t * size_left, int * split_flag,\n                    char const * restore, char const * q_restore)\n{\n  char * inbf = scribble_get (BUFSIZ);\n\n  if (uuencode_file && (cmpr_state != NULL))\n    {\n      char * p = fgets (inbf, BUFSIZ, input);\n      char * e;\n      if ((p == NULL) || (strncmp (p, mode_fmt_z, 6) != 0))\n        return;\n      /*\n       * Find the start of the last token\n       */\n      e = p + strlen(p);\n      while (  isspace (to_uchar (e[-1])) && (e > p))  e--;\n      while (! isspace (to_uchar (e[-1])) && (e > p))  e--;\n      fwrite (p, e - p, 1, output);\n      fprintf (output, \"_sh%05d/%s\\n\", (int)sharpid, cmpr_state->cmpr_mode);\n    }\n\n  while (fgets (inbf, BUFSIZ, input))\n    {\n      /* Output a line and test the length.  */\n\n      if (!HAVE_OPT(FORCE_PREFIX)\n          && ISASCII (inbf[0])\n          && IS_GRAPH (inbf[0])\n\n          /* Protect lines already starting with the prefix.  */\n          && inbf[0] != line_prefix\n\n          /* Old mail programs interpret ~ directives.  */\n          && inbf[0] != '~'\n\n          /* Avoid mailing lines which are just '.'.  */\n          && inbf[0] != '.'\n\n#if STRNCMP_IS_FAST\n          && strncmp (inbf, OPT_ARG(HERE_DELIMITER), here_delimiter_length)\n\n          /* unshar -e: avoid 'exit 0'.  */\n          && strncmp (inbf, \"exit 0\", 6)\n\n          /* Don't let mail prepend a '>'.  */\n          && strncmp (inbf, \"From\", 4)\n#else\n          && (inbf[0] != OPT_ARG(HERE_DELIMITER)[0]\n              || strncmp (inbf, OPT_ARG(HERE_DELIMITER),\n                          here_delimiter_length))\n\n          /* unshar -e: avoid 'exit 0'.  */\n          && (inbf[0] != 'e' || strncmp (inbf, \"exit 0\", 6))\n\n          /* Don't let mail prepend a '>'.  */\n          && (inbf[0] != 'F' || strncmp (inbf, \"From\", 4))\n#endif\n          )\n        fputs (inbf, output);\n      else\n        {\n          fprintf (output, \"%c%s\", line_prefix, inbf);\n          (*size_left)--;\n        }\n\n      /* Try completing an incomplete line, but not if the incomplete\n         line contains no character.  This might occur with -T for\n         incomplete files, or sometimes when switching to a new file.  */\n\n      if (*inbf && inbf[strlen (inbf) - 1] != '\\n')\n        {\n          putc ('\\n', output);\n          (*size_left)--;\n        }\n\n      (*size_left) -= CRLF_STRLEN (inbf);\n      if (WHICH_OPT_WHOLE_SIZE_LIMIT != VALUE_OPT_SPLIT_SIZE_LIMIT)\n        continue;\n\n      if ((int)(*size_left) >= 0)\n        continue;\n      split_shar_ed_file (restore, size_left, split_flag);\n    }\n}",
      "lines": 85,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_query_user": {
      "start_point": [
        1656,
        0
      ],
      "end_point": [
        1676,
        1
      ],
      "content": "static void\nprint_query_user (char const * rname)\n{\n  size_t rname_len = strlen (rname);\n  size_t sz = strlen (SM_overwriting) + rname_len;\n  char * str_a, * str_b;\n\n  str_a = scribble_get (sz);\n  snprintf (str_a, sz, SM_overwriting, rname);\n\n  sz = strlen (SM_overwrite) + rname_len;\n  str_b = scribble_get (sz);\n  snprintf (str_b, sz, SM_overwrite, rname);\n\n  fprintf (output, query_user_z, str_a, str_b);\n\n  sz = strlen (SM_skipping) + rname_len;\n  str_b = scribble_get (sz);\n  snprintf (str_b, sz, SM_skipping, rname);\n  fprintf (output, query_check_z, SM_extract_aborted, str_b, str_b);\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "start_sharing_file": {
      "start_point": [
        1680,
        0
      ],
      "end_point": [
        1780,
        1
      ],
      "content": "static int\nstart_sharing_file (char const ** lnameq_p, char const ** rnameq_p,\n                    FILE ** fpp, off_t * size_left_p, int *pipe_p)\n{\n  char const * lname = *lnameq_p;\n  char const * rname = *rnameq_p;\n  char const * file_type;         /* text or binary */\n  char const * file_type_remote;  /* text or binary, avoiding locale */\n\n  /* Check to see that this is still a regular file and readable.  */\n\n  if (!S_ISREG (struct_stat.st_mode & S_IFMT))\n    {\n      error (0, 0, _(\"%s: Not a regular file\"), lname);\n      return 0;\n    }\n  if (access (lname, R_OK))\n    {\n      error (0, 0, _(\"Cannot access %s\"), lname);\n      return 0;\n    }\n\n  *lnameq_p =\n    quotearg_n_style (QUOT_ID_LNAME, shell_always_quoting_style, lname);\n  *rnameq_p =\n    quotearg_n_style (QUOT_ID_RNAME, shell_always_quoting_style, rname);\n\n  /*\n   * If file size is limited, either splitting files or not,\n   * get the current output length.  Switch files if we split on file\n   * boundaries and there may not be enough space.\n   */\n  if (HAVE_OPT(WHOLE_SIZE_LIMIT))\n    {\n      off_t current_size = ftello (output);\n      off_t encoded_size = 1024 + (uuencode_file\n               ? (struct_stat.st_size + struct_stat.st_size / 3)\n               : struct_stat.st_size);\n\n      *size_left_p = OPT_VALUE_WHOLE_SIZE_LIMIT - current_size;\n      DEBUG_PRINT (\"In shar: remaining size %s\\n\", *size_left_p);\n\n      if (  (WHICH_OPT_WHOLE_SIZE_LIMIT != VALUE_OPT_SPLIT_SIZE_LIMIT)\n         && (current_size > first_file_position)\n         && (encoded_size > *size_left_p))\n        {\n          change_files (*rnameq_p, size_left_p);\n          current_size = ftello (output);\n          *size_left_p = OPT_VALUE_WHOLE_SIZE_LIMIT - current_size;\n        }\n    }\n\n  else\n    *size_left_p = ~0;\t\t/* give some value to the variable */\n\n  fprintf (output, break_line_z, rname);\n\n  generate_mkdir_script (rname);\n\n  if (struct_stat.st_size == 0)\n    {\n      file_type = _(\"empty\");\n      file_type_remote = SM_is_empty;\n      *fpp = NULL;\t\t/* give some value to the variable */\n    }\n  else\n    {\n      *fpp = open_shar_input (lname, *lnameq_p, rname, *rnameq_p,\n                              &file_type, &file_type_remote, pipe_p);\n      if (*fpp == NULL)\n        return 0;\n    }\n\n  /* Protect existing files.  */\n\n  if (! HAVE_OPT(NO_CHECK_EXISTING))\n    {\n      fprintf (output, pre_exist_z, *rnameq_p);\n\n      if (HAVE_OPT(QUERY_USER))\n\tprint_query_user (rname);\n      else\n        echo_text (SM_skip_exist, rname, false);\n\n      fputs (otherwise_z, output);\n    }\n\n  if (! HAVE_OPT(QUIET))\n    error (0, 0, _(\"Saving %s (%s)\"), lname, file_type);\n\n  if (! HAVE_OPT(QUIET_UNSHAR))\n    {\n      size_t sz = strlen (SM_x_extracting)\n        + strlen (rname) + strlen (file_type_remote);\n      char * bf = scribble_get(sz);\n      snprintf (bf, sz, SM_x_extracting, rname, file_type_remote);\n      fprintf (output, echo_string_z, bf);\n    }\n\n  return 1;\n}",
      "lines": 101,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "finish_sharing_file": {
      "start_point": [
        1782,
        0
      ],
      "end_point": [
        1857,
        1
      ],
      "content": "static void\nfinish_sharing_file (const char * lname, const char * lname_q,\n                     const char * rname, const char * rname_q)\n{\n  if (! HAVE_OPT(NO_TIMESTAMP))\n    {\n      struct tm * restore_time;\n      /* Set the dates as they were.  */\n\n      restore_time = localtime (&struct_stat.st_mtime);\n      fprintf (output, shar_touch_z,\n\t       (restore_time->tm_year + 1900) / 100,\n\t       (restore_time->tm_year + 1900) % 100,\n\t       restore_time->tm_mon + 1, restore_time->tm_mday,\n\t       restore_time->tm_hour, restore_time->tm_min,\n\t       restore_time->tm_sec, rname_q);\n    }\n\n  if (HAVE_OPT(VANILLA_OPERATION))\n    {\n      /* Close the \"&&\" and report an error if any of the above\n\t failed.  */\n      fputs (\":\\n\", output);\n      echo_status (\"test $? -ne 0\", SM_restore_failed, NULL, rname, 0);\n    }\n\n  else\n    {\n      unsigned char md5buffer[16];\n      FILE *fp = NULL;\n      int did_md5 = 0;\n\n      /* Set the permissions as they were.  */\n\n      fprintf (output, SM_restore_mode,\n\t       (unsigned) (struct_stat.st_mode & 0777), rname_q);\n\n      /* Report an error if any of the above failed.  */\n\n      echo_status (\"test $? -ne 0\", SM_restore_failed, NULL, rname, 0);\n\n      if (   ! HAVE_OPT(NO_MD5_DIGEST)\n          && (fp = fopen (lname, \"r\" FOPEN_BINARY)) != NULL\n\t  && md5_stream (fp, md5buffer) == 0)\n\t{\n\t  /* Validate the transferred file using 'md5sum' command.  */\n\t  size_t cnt;\n\t  did_md5 = 1;\n\n\t  fprintf (output, md5test_z, rname_q,\n\t\t   SM_md5_check_failed, OPT_ARG(HERE_DELIMITER));\n\n\t  for (cnt = 0; cnt < 16; ++cnt)\n\t    fprintf (output, \"%02x\", md5buffer[cnt]);\n\n\t  fprintf (output, \" %c%s\\n%s\\n\",\n\t\t   ' ', rname, OPT_ARG(HERE_DELIMITER));\n\t  /* This  ^^^ space is not necessarily a parameter now.  But it\n\t     is a flag for binary/text mode and will perhaps be used later.  */\n\t}\n\n      if (fp != NULL)\n\tfclose (fp);\n\n      if (! HAVE_OPT(NO_CHARACTER_COUNT))\n        emit_char_ct_validation (lname, lname_q, rname_q, did_md5);\n\n      if (did_md5)\n\tfputs (\"  fi\\n\", output);\n    }\n\n  /* If the exists option is in place close the if.  */\n\n  if (! HAVE_OPT(NO_CHECK_EXISTING))\n    fputs (\"fi\\n\", output);\n}",
      "lines": 76,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "shar": {
      "start_point": [
        1863,
        0
      ],
      "end_point": [
        1952,
        1
      ],
      "content": "static int\nshar (const char * lname, const char * rname)\n{\n  FILE * input;\n  off_t  size_left;\n  int    split_flag = 0;          /* file split flag */\n  char const * lname_q = lname;\n  char const * rname_q = rname;\n  int pipe_p;\n\n  scribble_free ();\n\n  if (! start_sharing_file (&lname_q, &rname_q, &input, &size_left, &pipe_p))\n    return SHAR_EXIT_FAILED;\n\n  if (struct_stat.st_size == 0)\n    {\n      /* Just touch the file, or empty it if it exists.  */\n\n      fprintf (output, \" > %s &&\\n\", rname_q);\n    }\n\n  else\n    {\n      /* Run sed for non-empty files.  */\n\n      if (uuencode_file)\n\t{\n\n\t  /* Run sed through uudecode (via temp file if might get split).  */\n\n\t  fprintf (output, \"  sed 's/^%c//' << '%s' \",\n\t\t   line_prefix, OPT_ARG(HERE_DELIMITER));\n\t  if (HAVE_OPT(NO_PIPING))\n\t    fprintf (output, \"> ${lock_dir}/uue &&\\n\");\n\t  else\n\t    fputs (\"| uudecode &&\\n\", output);\n\t}\n\n      else\n\t{\n\t  /* Just run it into the file.  */\n\n\t  fprintf (output, \"  sed 's/^%c//' << '%s' > %s &&\\n\",\n\t\t   line_prefix, OPT_ARG(HERE_DELIMITER), rname_q);\n\t}\n\n      process_shar_input (input, &size_left, &split_flag, rname, rname_q);\n\n      if (!pipe_p)\n        fclose (input);\n      else\n        {\n#if HAVE_WORKING_FORK\n          fclose (input);\n          while (wait (NULL) >= 0)\n            ;\n#else\n          if (pclose (input))\n            fserr (SHAR_EXIT_FAILED, _(\"call\"), \"pclose\");\n#endif\n        }\n\n      fprintf (output, \"%s\\n\", OPT_ARG(HERE_DELIMITER));\n      if (split_flag && ! HAVE_OPT(QUIET_UNSHAR))\n        echo_text (SM_file_complete, rname, true);\n\n      /* If this file was uuencoded w/Split, decode it and drop the temp.  */\n\n      if (uuencode_file && HAVE_OPT(NO_PIPING))\n\t{\n\t  if (! HAVE_OPT(QUIET_UNSHAR))\n            echo_text (SM_uudec_file, rname, true);\n\n          fwrite (shar_decode_z, sizeof (shar_decode_z) - 1, 1, output);\n\t}\n\n      /* If this file was compressed, uncompress it and drop the temp.  */\n      if (cmpr_state != NULL)\n        {\n\t  if (! HAVE_OPT(QUIET_UNSHAR))\n            echo_text (cmpr_state->cmpr_unnote, rname, true);\n          fprintf (output, cmpr_state->cmpr_unpack, rname_q);\n        }\n    }\n\n  finish_sharing_file (lname, lname_q, rname, rname_q);\n\n  return EXIT_SUCCESS;\n}",
      "lines": 90,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "parse_output_base_name": {
      "start_point": [
        1966,
        0
      ],
      "end_point": [
        2028,
        1
      ],
      "content": "static void\nparse_output_base_name (char const * arg)\n{\n  char * bad_fmt = _(\"Invalid format for output file names (%s): %s\");\n  int c;\n  int hadarg = 0;\n  char const *p;\n  int base_name_len = 128;\n\n  for (p = arg ; (c = *p++) != 0; )\n    {\n      base_name_len++;\n      if (c != '%')\n\tcontinue;\n      c = *p++;\n      if (c == '%')\n\tcontinue;\n      if (hadarg)\n        usage_message(bad_fmt, _(\"more than one format element\"), arg);\n\n      while (c != 0 && strchr(\"#0+- 'I\", c) != 0)\n\tc = *p++;\n      if (c == 0)\n\tusage_message(bad_fmt, _(\"no conversion character\"), arg);\n\n      if (c >= '0' && c <= '9')\n\t{\n\t  long v;\n          char const * skp;\n\t  errno = 0;\n\t  v = strtol((void *)(p-1), (void *)&skp, 10);\n\t  if ((v == 0) || (v > 16) || (errno != 0))\n            usage_message(bad_fmt, _(\"format is too wide\"), arg);\n\t  p = skp;\n\t  c = *p++;\n\t  base_name_len += v;\n\t}\n      if (c == '.')\n\t{\n\t  c = *p++;\n\t  while (c != 0 && c >= '0' && c <= '9')\n\t    c = *p++;\n\t}\n      if (c == 0 || strchr(\"diouxX\", c) == 0)\n\tusage_message(bad_fmt, _(\"invalid conversion character\"), arg);\n      hadarg = 1;\n    }\n  output_filename = xmalloc(base_name_len);\n  if (! hadarg)\n    {\n      static char const sfx[] = \".%02d\";\n      size_t len = strlen (arg);\n      char * fmt = xmalloc(len + sizeof (sfx));\n      bool   svd = initialization_done;\n      memcpy (fmt, arg, len);\n      memcpy (fmt + len, sfx, sizeof (sfx));\n\n      /* this is allowed to happen after initialization. */\n      initialization_done = false;\n      SET_OPT_OUTPUT_PREFIX(fmt);\n      initialization_done = svd;\n    }\n}",
      "lines": 63,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "open_output": {
      "start_point": [
        2037,
        0
      ],
      "end_point": [
        2056,
        1
      ],
      "content": "static void\nopen_output (void)\n{\n  if (! HAVE_OPT(OUTPUT_PREFIX))\n    {\n      output = stdout;\n#ifdef __MINGW32__\n      _setmode (fileno (stdout) , _O_BINARY);\n#endif\n      return;\n    }\n\n  if (output_filename == NULL)\n    parse_output_base_name (OPT_ARG(OUTPUT_PREFIX));\n  sprintf (output_filename, OPT_ARG(OUTPUT_PREFIX), ++part_number);\n  output = fopen (output_filename, \"w\" FOPEN_BINARY);\n\n  if (output == NULL)\n    fserr (SHAR_EXIT_FAILED, _(\"Opening\"), output_filename);\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "close_output": {
      "start_point": [
        2061,
        0
      ],
      "end_point": [
        2071,
        1
      ],
      "content": "static void\nclose_output (int part)\n{\n  if (part > 0)\n    fprintf (output, \"echo %d > ${lock_dir}/seq\\n\", part);\n\n  fputs (\"exit 0\\n\", output);\n\n  if (fclose (output) != 0)\n    fserr (SHAR_EXIT_FAILED, _(\"Closing\"), output_filename);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "trim": {
      "start_point": [
        2081,
        0
      ],
      "end_point": [
        2097,
        1
      ],
      "content": "static char *\ntrim (char * pz)\n{\n  char * res;\n  while (isspace (to_uchar (*pz)))  pz++;\n  switch (*pz)\n    {\n    case NUL:\n    case '#':\n      return NULL;\n    }\n  res = pz;\n  pz += strlen (pz);\n  while (isspace (to_uchar (pz[-1])))  pz--;\n  *pz = NUL;\n  return res;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ntrim (char * pz)",
        "*"
      ]
    },
    "set_submitter": {
      "start_point": [
        2105,
        0
      ],
      "end_point": [
        2118,
        1
      ],
      "content": "static void\nset_submitter (void)\n{\n  char * buffer;\n  char * uname = getuser (getuid ());\n  size_t len   = strlen (uname);\n  if (uname == NULL)\n    fserr (SHAR_EXIT_FAILED, \"getpwuid\", \"getuid()\");\n  buffer = xmalloc (len + 2 + HOST_NAME_MAX);\n  memcpy (buffer, uname, len);\n  buffer[len++] = '@';\n  gethostname (buffer + len, HOST_NAME_MAX);\n  SET_OPT_SUBMITTER(buffer);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "configure_shar": {
      "start_point": [
        2127,
        0
      ],
      "end_point": [
        2233,
        1
      ],
      "content": "static void\nconfigure_shar (int * argc_p, char *** argv_p)\n{\n  line_prefix = (OPT_ARG(HERE_DELIMITER)[0] == DEFAULT_LINE_PREFIX_1\n\t\t ? DEFAULT_LINE_PREFIX_2\n\t\t : DEFAULT_LINE_PREFIX_1);\n\n  here_delimiter_length = strlen (OPT_ARG(HERE_DELIMITER));\n  gzip_compaction.cmpr_level =\n    xz_compaction.cmpr_level =\n    bzip2_compaction.cmpr_level = DESC(LEVEL_OF_COMPRESSION).optArg.argInt;\n#ifdef HAVE_COMPRESS\n  compress_compaction.cmpr_level = DESC(BITS_PER_CODE).optArg.argInt;\n#endif\n\n  /* Set defaults for unset options.  */\n  if (! HAVE_OPT(SUBMITTER))\n    set_submitter ();\n\n  open_output ();\n  if (isatty (fileno (output)) && isatty (STDERR_FILENO))\n    {\n      /*\n       * Output is going to a TTY device, and so is stderr.\n       * Redirect stderr to /dev/null in that case so that\n       * the results are not cluttered with chatter.\n       */\n      FILE * fp = freopen (\"/dev/null\", \"w\" FOPEN_BINARY, stderr);\n      if (fp != stderr)\n        error (SHAR_EXIT_FAILED, errno,\n               _(\"reopening stderr to /dev/null\"));\n    }\n\n  memset ((char *) byte_is_binary, 1, sizeof (byte_is_binary));\n  /* \\n ends an input line, and \\v and \\r disrupt the output  */\n  byte_is_binary['\\b'] = 0; /* BS back space   */\n  byte_is_binary['\\t'] = 0; /* HT horiz. tab   */\n  byte_is_binary['\\f'] = 0; /* FF form feed    */\n  /* bytes 0x20 through and including 0x7E --> 0x7E - 0x20 + 1 */\n  memset ((char *) byte_is_binary + 0x20, 0, 0x7F - 0x20);\n\n  /* Maybe read file list from standard input.  */\n\n  if (HAVE_OPT(INPUT_FILE_LIST))\n    {\n      char ** list;\n      int max_argc = 32;\n      char * get_buf = scribble_get (BUFSIZ);\n\n      *argc_p = 0;\n\n      list = (char **) xmalloc (max_argc * sizeof (char *));\n\n#ifdef __MINGW32__\n      _setmode (fileno (stdin), _O_BINARY);\n#endif\n\n      for (;;)\n        {\n          char * pz = fgets (get_buf, BUFSIZ, stdin);\n          if (pz == NULL)\n            break;\n\n          pz = trim (pz);\n          if (pz == NULL)\n            continue;\n\n\t  if (*argc_p == max_argc)\n            {\n              max_argc += max_argc / 2;\n              list = (char **) xrealloc (list, max_argc * sizeof (*list));\n            }\n\n\t  list[(*argc_p)++] = xstrdup (pz);\n\t}\n      *argv_p = list;\n      opt_idx = 0;\n    }\n\n  scribble_free ();\n  /* Diagnose various usage errors.  */\n\n  if (opt_idx >= *argc_p)\n    usage_message (_(\"No input files\"));\n\n  if (HAVE_OPT(WHOLE_SIZE_LIMIT))\n    {\n      if (OPT_VALUE_WHOLE_SIZE_LIMIT < 4096)\n        OPT_VALUE_WHOLE_SIZE_LIMIT *= 1024;\n      if (WHICH_OPT_WHOLE_SIZE_LIMIT == VALUE_OPT_SPLIT_SIZE_LIMIT)\n        SET_OPT_NO_PIPING;\n    }\n\n  /* Start making the archive file.  */\n\n  generate_full_header (*argc_p - opt_idx, &(*argv_p)[opt_idx]);\n\n  if (HAVE_OPT(QUERY_USER))\n    {\n      if (HAVE_OPT(NET_HEADERS))\n\terror (0, 0, _(\"PLEASE avoid -X shars on Usenet or public networks\"));\n\n      fputs (\"shar_wish=\\n\", output);\n    }\n\n  first_file_position = ftello (output);\n}",
      "lines": 107,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_intermixing": {
      "start_point": [
        2243,
        0
      ],
      "end_point": [
        2253,
        1
      ],
      "content": "void\ncheck_intermixing (tOptions * opts, tOptDesc * od)\n{\n  (void)opts;\n  (void)od;\n\n  if (initialization_done && ! HAVE_OPT(INTERMIX_TYPE))\n    usage_message (\n      _(\"The '%s' option may not be intermixed with file names\\n\\\nunless the --intermix-type option has been specified.\"), od->pz_Name);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "validate_opt_context": {
      "start_point": [
        2262,
        0
      ],
      "end_point": [
        2271,
        1
      ],
      "content": "void\nvalidate_opt_context (tOptions * opts, tOptDesc * od)\n{\n  (void)opts;\n  (void)od;\n\n  if (initialization_done)\n    usage_message(_(\"The '%s' option must appear before any file names\"),\n                  od->pz_Name);\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "set_compaction": {
      "start_point": [
        2282,
        0
      ],
      "end_point": [
        2313,
        1
      ],
      "content": "void\nset_compaction (tOptions * opts, tOptDesc * od)\n{\n  char const * c_type = od->optArg.argString;\n  int  ix = 0;\n\n  (void)opts;\n  (void)od;\n\n  check_intermixing (opts, od);\n\n  if (strcmp (c_type, \"none\") == 0)\n    {\n      cmpr_state = NULL;\n      return;\n    }\n\n  for (;;) {\n    if (strcmp (c_type, compaction[ix]->cmpr_name) == 0)\n      break;\n    if (++ix >= compact_ct)\n      {\n        fprintf (stderr,\n                 _(\"invalid compaction type:  %s\\nthe known types are:\\n\"),\n                 c_type);\n        for (ix = 0; ix < compact_ct; ix++)\n          fprintf (stderr, \"\\t%s\\n\", compaction[ix]->cmpr_name);\n        USAGE (SHAR_EXIT_OPTION_ERROR);\n      }\n  }\n  cmpr_state = compaction[ix];\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "initialize": {
      "start_point": [
        2323,
        0
      ],
      "end_point": [
        2350,
        1
      ],
      "content": "static void\ninitialize(int * argcp, char *** argvp)\n{\n  sharpid = (int) getpid ();\n  setlocale (LC_ALL, \"\");\n\n  /* Set the text message domain.  */\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n  scribble_init ();\n\n  opt_idx = optionProcess (&sharOptions, *argcp, *argvp);\n  if (opt_idx == *argcp)\n    {\n      if (! HAVE_OPT(INPUT_FILE_LIST))\n        SET_OPT_INPUT_FILE_LIST(\"-\");\n    }\n  else\n    {\n      if (HAVE_OPT(INPUT_FILE_LIST) && (opt_idx != *argcp))\n        usage_message(\n          _(\"files on command line and --input-file-list specified\"));\n    }\n\n  init_shar_msg ();\n  configure_shar (argcp, argvp);\n  initialization_done = true;\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        2356,
        0
      ],
      "end_point": [
        2402,
        1
      ],
      "content": "int\nmain (int argc, char ** argv)\n{\n  shar_exit_code_t status = SHAR_EXIT_SUCCESS;\n  initialize (&argc, &argv);\n\n  /* Process positional parameters and files.  */\n\n  while (opt_idx < argc)\n    {\n      char * arg = argv[opt_idx++];\n      struct stat sb;\n      if (stat (arg, &sb) != 0)\n        {\n          if (HAVE_OPT(INTERMIX_TYPE) && (*arg == '-'))\n            {\n              while (*++arg == '-')  ;\n              optionLoadLine (&sharOptions, arg);\n            }\n          else\n            error (0, errno, \"%s\", arg);\n          continue;\n        }\n\n      {\n        shar_exit_code_t s = walktree (shar, arg);\n        if (status == SHAR_EXIT_SUCCESS)\n          status = s;\n      }\n    }\n\n  /* Delete the sequence file, if any.  */\n\n  if (HAVE_OPT(WHOLE_SIZE_LIMIT) && part_number > 1)\n    {\n      fprintf (output, echo_string_z, SM_you_are_done);\n      if (HAVE_OPT(QUIET))\n\tfprintf (stderr, _(\"Created %d files\\n\"), part_number);\n    }\n\n  echo_status (\"rm -fr ${lock_dir}\", SM_x_rem_lock_dir, SM_x_no_rem_lock_dir,\n               \"${lock_dir}\", 1);\n\n  close_output (0);\n  scribble_deinit ();\n  exit (status);\n}",
      "lines": 47,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/src/unshar-opts.c": {
    "doUsageOpt": {
      "start_point": [
        480,
        0
      ],
      "end_point": [
        490,
        1
      ],
      "content": "static void\ndoUsageOpt(tOptions * opts, tOptDesc * od)\n{\n    int ex_code;\n    ex_code = UNSHAR_EXIT_SUCCESS;\n    optionUsage(&unsharOptions, ex_code);\n    /* NOTREACHED */\n    exit(1);\n    (void)opts;\n    (void)od;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "doOptForce": {
      "start_point": [
        499,
        0
      ],
      "end_point": [
        506,
        1
      ],
      "content": "static void\ndoOptForce(tOptions* pOptions, tOptDesc* pOptDesc)\n{\n    int res = optionAlias(pOptions, pOptDesc, INDEX_OPT_OVERWRITE);\n    if ((res != 0) && ((pOptions->fOptSet & OPTPROC_ERRSTOP) != 0))\n        USAGE(UNSHAR_EXIT_USAGE_ERROR);\n\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "doOptSplit_At": {
      "start_point": [
        524,
        0
      ],
      "end_point": [
        536,
        1
      ],
      "content": "static void\ndoOptSplit_At(tOptions* pOptions, tOptDesc* pOptDesc)\n{\n    /*\n     * Be sure the flag-code[0] handles special values for the options pointer\n     * viz. (poptions <= OPTPROC_EMIT_LIMIT) *and also* the special flag bit\n     * ((poptdesc->fOptState & OPTST_RESET) != 0) telling the option to\n     * reset its state.\n     */\n    /* extracted from unshar-opts.def, line 95 */\n    separator_str_len = strlen (pOptDesc->optArg.argString);\n    (void)pOptions;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "doOptExit_0": {
      "start_point": [
        547,
        0
      ],
      "end_point": [
        560,
        1
      ],
      "content": "static void\ndoOptExit_0(tOptions* pOptions, tOptDesc* pOptDesc)\n{\n    /*\n     * Be sure the flag-code[0] handles special values for the options pointer\n     * viz. (poptions <= OPTPROC_EMIT_LIMIT) *and also* the special flag bit\n     * ((poptdesc->fOptState & OPTST_RESET) != 0) telling the option to\n     * reset its state.\n     */\n    /* extracted from unshar-opts.def, line 118 */\n    SET_OPT_SPLIT_AT(\"exit 0\");\n    (void)pOptDesc;\n    (void)pOptions;\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "validate_fname": {
      "start_point": [
        576,
        0
      ],
      "end_point": [
        607,
        1
      ],
      "content": "static unshar_exit_code_t\nvalidate_fname(char const * fname)\n{\n    static char const * err_str = NULL;\n\n    if (err_str == NULL)\n        err_str = _(\"fs error %d (%s) %s-ing %s\\n\");\n    if ((fname[0] == '-') && (fname[1] == '\\0'))\n        return unshar_file(_(\"standard input\"), stdin);\n    {\n        struct stat sb;\n        if (stat(fname, &sb) < 0) {\n            fprintf(stderr, err_str, errno, strerror(errno), \"stat\",\n                    fname);\n            return UNSHAR_EXIT_NO_CONFIG_INPUT;\n        }\n    }\n/* extracted from optmain.tlib near line 295 */\n\n    {\n        int res;\n        FILE* fp = fopen(fname, \"r\");\n        if (fp == NULL) {\n            fprintf(stderr, err_str, errno, strerror(errno), \"fopen\",\n                    fname);\n            return UNSHAR_EXIT_NO_CONFIG_INPUT;\n        }\n        res = unshar_file(fname, fp);\n        fclose(fp);\n        return res;\n    }\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unshar_exit_code_t"
      ]
    },
    "main": {
      "start_point": [
        620,
        0
      ],
      "end_point": [
        648,
        1
      ],
      "content": "int\nmain(int argc, char ** argv)\n{\n    int res     = 0;\n    int proc_ct = 0;\n    int arg_ix  = optionProcess(&unsharOptions, argc, argv);\n    \n/* extracted from unshar-opts.def near line 34 */\n\n    init_unshar ();\n/* extracted from optmain.tlib near line 160 */\n\n    /*\n     *  IF the input list is from the command line...\n     */\n    if (arg_ix < argc) {\n        for (; arg_ix < argc; arg_ix++) {\n            char * arg = argv[arg_ix];\n            res |= validate_fname(arg);\n            proc_ct++;\n        }\n    }\n    else\n        /*\n         * process standard input as input file\n         */\n        res = unshar_file(_(\"standard input\"), stdin);\n    return res;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "vusage_message": {
      "start_point": [
        660,
        0
      ],
      "end_point": [
        669,
        1
      ],
      "content": "void\nvusage_message(char const * fmt, va_list ap)\n{\n    char const * er_leader = _(\"unshar usage error:\\n\");\n    fputs(er_leader, stderr);\n    vfprintf(stderr, fmt, ap);\n    optionUsage(&unsharOptions, UNSHAR_EXIT_USAGE_ERROR);\n    /* NOTREACHED */\n    exit(1);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "usage_message": {
      "start_point": [
        679,
        0
      ],
      "end_point": [
        687,
        1
      ],
      "content": "void\nusage_message(char const * fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    vusage_message(fmt, ap);\n    /* NOTREACHED */\n    va_end(ap);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "vdie": {
      "start_point": [
        697,
        0
      ],
      "end_point": [
        706,
        1
      ],
      "content": "void\nvdie(int exit_code, char const * fmt, va_list ap)\n{\n    char const * die_leader = _(\"unshar fatal error:\\n\");\n    fputs(die_leader, stderr);\n    vfprintf(stderr, fmt, ap);\n    fflush(stderr);\n    exit(exit_code);\n    /* NOTREACHED */\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "die": {
      "start_point": [
        716,
        0
      ],
      "end_point": [
        724,
        1
      ],
      "content": "void\ndie(int exit_code, char const * fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    vdie(exit_code, fmt, ap);\n    /* NOTREACHED */\n    va_end(ap);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "fserr": {
      "start_point": [
        734,
        0
      ],
      "end_point": [
        740,
        1
      ],
      "content": "void\nfserr(int exit_code, char const * op, char const * fname)\n{\n    char const * fserr_fmt = _(\"fserr %d (%s) performing '%s' on %s\\n\");\n    die(exit_code, fserr_fmt, errno, strerror(errno), op, fname);\n    /* NOTREACHED */\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "AO_gettext": {
      "start_point": [
        837,
        0
      ],
      "end_point": [
        866,
        1
      ],
      "content": "static char *\nAO_gettext(char const * pz)\n{\n    char * res;\n    if (pz == NULL)\n        return NULL;\n#ifdef HAVE_DCGETTEXT\n    /*\n     * While processing the option_xlateable_txt data, try to use the\n     * \"libopts\" domain.  Once we switch to the option descriptor data,\n     * do *not* use that domain.\n     */\n    if (option_xlateable_txt.field_ct != 0) {\n        res = dgettext(\"libopts\", pz);\n        if (res == pz)\n            res = (char *)VOIDP(_(pz));\n    } else\n        res = (char *)VOIDP(_(pz));\n#else\n    res = (char *)VOIDP(_(pz));\n#endif\n    if (res == pz)\n        return res;\n    res = strdup(res);\n    if (res == NULL) {\n        fputs(_(\"No memory for duping translated strings\\n\"), stderr);\n        exit(UNSHAR_EXIT_NOMEM);\n    }\n    return res;\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nAO_gettext(char const * pz)",
        "*"
      ]
    },
    "coerce_it": {
      "start_point": [
        872,
        0
      ],
      "end_point": [
        873,
        1
      ],
      "content": "static void coerce_it(void ** s) { *s = AO_gettext(*s);\n}",
      "lines": 2,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "translate_option_strings": {
      "start_point": [
        879,
        0
      ],
      "end_point": [
        907,
        1
      ],
      "content": "static void\ntranslate_option_strings(void)\n{\n    tOptions * const opts = &unsharOptions;\n\n    /*\n     *  Guard against re-translation.  It won't work.  The strings will have\n     *  been changed by the first pass through this code.  One shot only.\n     */\n    if (option_xlateable_txt.field_ct != 0) {\n        /*\n         *  Do the translations.  The first pointer follows the field count\n         *  field.  The field count field is the size of a pointer.\n         */\n        char ** ppz = (char**)VOIDP(&(option_xlateable_txt));\n        int     ix  = option_xlateable_txt.field_ct;\n\n        do {\n            ppz++; /* skip over field_ct */\n            *ppz = AO_gettext(*ppz);\n        } while (--ix > 0);\n        /* prevent re-translation and disable \"libopts\" domain lookup */\n        option_xlateable_txt.field_ct = 0;\n\n        coerce_it(VOIDP(&(opts->pzCopyright)));\n        coerce_it(VOIDP(&(opts->pzCopyNotice)));\n        coerce_it(VOIDP(&(opts->pzFullVersion)));\n    }\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bogus_function": {
      "start_point": [
        912,
        0
      ],
      "end_point": [
        1171,
        1
      ],
      "content": "static void bogus_function(void) {\n  /* TRANSLATORS:\n\n     The following dummy function was crated solely so that xgettext can\n     extract the correct strings.  These strings are actually referenced\n     by a field name in the unsharOptions structure noted in the\n     comments below.  The literal text is defined in unshar_opt_strs.\n   \n     NOTE: the strings below are segmented with respect to the source string\n     unshar_opt_strs.  The strings above are handed off for translation\n     at run time a paragraph at a time.  Consequently, they are presented here\n     for translation a paragraph at a time.\n   \n     ALSO: often the description for an option will reference another option\n     by name.  These are set off with apostrophe quotes (I hope).  Do not\n     translate option names.\n   */\n  /* referenced via unsharOptions.pzCopyright */\n  puts(_(\"unshar (GNU sharutils) 4.15.2\\n\\\nCopyright (C) 1994-2015 Free Software Foundation, Inc., all rights reserved.\\n\\\nThis is free software. It is licensed for use, modification and\\n\\\nredistribution under the terms of the GNU General Public License,\\n\\\nversion 3 or later <http://gnu.org/licenses/gpl.html>\\n\"));\n\n  /* referenced via unsharOptions.pzCopyNotice */\n  puts(_(\"unshar is free software: you can redistribute it and/or modify it under the\\n\\\nterms of the GNU General Public License as published by the Free Software\\n\\\nFoundation, either version 3 of the License, or (at your option) any later\\n\\\nversion.\\n\\n\"));\n  puts(_(\"unshar is distributed in the hope that it will be useful, but WITHOUT ANY\\n\\\nWARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\\n\\\nFOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\\n\\\ndetails.\\n\\n\"));\n  puts(_(\"You should have received a copy of the GNU General Public License along\\n\\\nwith this program.  If not, see <http://www.gnu.org/licenses/>.\\n\"));\n\n  /* referenced via unsharOptions.pzUsageTitle */\n  puts(_(\"unshar (GNU sharutils) - unpack a shar archive\\n\\\nUsage:  %s [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [<file>...]\\n\"));\n\n  /* referenced via unsharOptions.pzExplain */\n  puts(_(\"\\n\\\nIf no arguments are provided, input arguments are read from stdin,\\n\\\none per line; blank and '#'-prefixed lines are comments.\\n\\\n'stdin' may not be a terminal (tty).\\n\"));\n\n  /* referenced via unsharOptions.pzDetail */\n  puts(_(\"Unshar scans the input files (typically email messages) looking for the\\n\\\nstart of a shell archive.  If no files are given, then standard input is\\n\\\nprocessed instead.  It then passes each archive discovered through an\\n\\\ninvocation of the shell program to unpack it.\\n\"));\n\n  /* referenced via unsharOptions.pzFullVersion */\n  puts(_(\"unshar (GNU sharutils) 4.15.2\"));\n\n  /* referenced via unsharOptions.pzFullUsage */\n  puts(_(\"unshar (GNU sharutils) - unpack a shar archive\\n\\\nUsage:  unshar [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [<file>...]\\n\\n\"));\n  puts(_(\"   -d, --directory=DIR        unpack into the directory DIR\\n\"));\n  puts(_(\"   -c, --overwrite            overwrite any pre-existing files\\n\"));\n  puts(_(\"   -f, --force                an alias for the 'overwrite' option\\n\"));\n  puts(_(\"   -E, --split-at=SPLIT-PAT   split input on SPLIT-PAT lines\\n\"));\n  puts(_(\"   -e, --exit-0               split input on \\\"exit 0\\\" lines\\n\\\n                                - prohibits the option 'split-at'\\n\"));\n  puts(_(\"   -D, --debug                debug the shell code\\n\"));\n  puts(_(\"   -v, --version[=MODE]       output version information and exit\\n\"));\n  puts(_(\"   -h, --help                 display extended usage information and exit\\n\"));\n  puts(_(\"   -!, --more-help            extended usage information passed thru pager\\n\"));\n  puts(_(\"   -R, --save-opts[=FILE]     save the option state to the config file FILE\\n\"));\n  puts(_(\"   -r, --load-opts=FILE       load options from the config file FILE\\n\\\n                                - disabled as '--no-load-opts'\\n\\\n                                - may appear multiple times\\n\\n\"));\n  puts(_(\"Options are specified by doubled hyphens and their name or by a single\\n\\\nhyphen and the flag character.\\n\\n\"));\n  puts(_(\"If no arguments are provided, input arguments are read from stdin,\\n\\\none per line; blank and '#'-prefixed lines are comments.\\n\\\n'stdin' may not be a terminal (tty).\\n\\n\"));\n  puts(_(\"The following option preset mechanisms are supported:\\n\"));\n  puts(_(\" - reading file $HOME/.sharrc\\n\\n\\\n'unshar' scans the input files (typically email messages) looking for the\\n\\\nstart of a shell archive.  If no files are given, then standard input is\\n\\\nprocessed instead.  It then passes each archive discovered through an\\n\\\ninvocation of the shell program to unpack it.\\n\\n\"));\n  puts(_(\"Please send bug reports to:  <bug-gnu-utils@gnu.org>\\n\"));\n\n  /* referenced via unsharOptions.pzShortUsage */\n  puts(_(\"unshar (GNU sharutils) - unpack a shar archive\\n\\\nUsage:  unshar [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [<file>...]\\n\\\nTry 'unshar --help' for more information.\\n\"));\n  /* LIBOPTS-MESSAGES: */\n#line 67 \"../autoopts.c\"\n  puts(_(\"allocation of %d bytes failed\\n\"));\n#line 93 \"../autoopts.c\"\n  puts(_(\"allocation of %d bytes failed\\n\"));\n#line 53 \"../init.c\"\n  puts(_(\"AutoOpts function called without option descriptor\\n\"));\n#line 86 \"../init.c\"\n  puts(_(\"\\tThis exceeds the compiled library version:  \"));\n#line 84 \"../init.c\"\n  puts(_(\"Automated Options Processing Error!\\n\"\n       \"\\t%s called AutoOpts function with structure version %d:%d:%d.\\n\"));\n#line 80 \"../autoopts.c\"\n  puts(_(\"realloc of %d bytes at 0x%p failed\\n\"));\n#line 88 \"../init.c\"\n  puts(_(\"\\tThis is less than the minimum library version:  \"));\n#line 121 \"../version.c\"\n  puts(_(\"Automated Options version %s\\n\"\n       \"\\tCopyright (C) 1999-2014 by Bruce Korb - all rights reserved\\n\"));\n#line 87 \"../makeshell.c\"\n  puts(_(\"(AutoOpts bug):  %s.\\n\"));\n#line 90 \"../reset.c\"\n  puts(_(\"optionResetOpt() called, but reset-option not configured\"));\n#line 292 \"../usage.c\"\n  puts(_(\"could not locate the 'help' option\"));\n#line 336 \"../autoopts.c\"\n  puts(_(\"optionProcess() was called with invalid data\"));\n#line 748 \"../usage.c\"\n  puts(_(\"invalid argument type specified\"));\n#line 598 \"../find.c\"\n  puts(_(\"defaulted to option with optional arg\"));\n#line 76 \"../alias.c\"\n  puts(_(\"aliasing option is out of range.\"));\n#line 234 \"../enum.c\"\n  puts(_(\"%s error:  the keyword '%s' is ambiguous for %s\\n\"));\n#line 108 \"../find.c\"\n  puts(_(\"  The following options match:\\n\"));\n#line 293 \"../find.c\"\n  puts(_(\"%s: ambiguous option name: %s (matches %d options)\\n\"));\n#line 161 \"../check.c\"\n  puts(_(\"%s: Command line arguments required\\n\"));\n#line 43 \"../alias.c\"\n  puts(_(\"%d %s%s options allowed\\n\"));\n#line 94 \"../makeshell.c\"\n  puts(_(\"%s error %d (%s) calling %s for '%s'\\n\"));\n#line 306 \"../makeshell.c\"\n  puts(_(\"interprocess pipe\"));\n#line 168 \"../version.c\"\n  puts(_(\"error: version option argument '%c' invalid.  Use:\\n\"\n       \"\\t'v' - version only\\n\"\n       \"\\t'c' - version and copyright\\n\"\n       \"\\t'n' - version and full copyright notice\\n\"));\n#line 58 \"../check.c\"\n  puts(_(\"%s error:  the '%s' and '%s' options conflict\\n\"));\n#line 217 \"../find.c\"\n  puts(_(\"%s: The '%s' option has been disabled.\"));\n#line 430 \"../find.c\"\n  puts(_(\"%s: The '%s' option has been disabled.\"));\n#line 38 \"../alias.c\"\n  puts(_(\"-equivalence\"));\n#line 469 \"../find.c\"\n  puts(_(\"%s: illegal option -- %c\\n\"));\n#line 110 \"../reset.c\"\n  puts(_(\"%s: illegal option -- %c\\n\"));\n#line 271 \"../find.c\"\n  puts(_(\"%s: illegal option -- %s\\n\"));\n#line 755 \"../find.c\"\n  puts(_(\"%s: illegal option -- %s\\n\"));\n#line 118 \"../reset.c\"\n  puts(_(\"%s: illegal option -- %s\\n\"));\n#line 335 \"../find.c\"\n  puts(_(\"%s: unknown vendor extension option -- %s\\n\"));\n#line 159 \"../enum.c\"\n  puts(_(\"  or an integer from %d through %d\\n\"));\n#line 169 \"../enum.c\"\n  puts(_(\"  or an integer from %d through %d\\n\"));\n#line 747 \"../usage.c\"\n  puts(_(\"%s error:  invalid option descriptor for %s\\n\"));\n#line 1081 \"../usage.c\"\n  puts(_(\"%s error:  invalid option descriptor for %s\\n\"));\n#line 385 \"../find.c\"\n  puts(_(\"%s: invalid option name: %s\\n\"));\n#line 527 \"../find.c\"\n  puts(_(\"%s: The '%s' option requires an argument.\\n\"));\n#line 156 \"../autoopts.c\"\n  puts(_(\"(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\\n\"\n       \"\\t'%s' and '%s'.\"));\n#line 94 \"../check.c\"\n  puts(_(\"%s error:  The %s option is required\\n\"));\n#line 632 \"../find.c\"\n  puts(_(\"%s: The '%s' option cannot have an argument.\\n\"));\n#line 151 \"../check.c\"\n  puts(_(\"%s: Command line arguments are not allowed.\\n\"));\n#line 535 \"../save.c\"\n  puts(_(\"error %d (%s) creating %s\\n\"));\n#line 234 \"../enum.c\"\n  puts(_(\"%s error:  '%s' does not match any %s keywords.\\n\"));\n#line 93 \"../reset.c\"\n  puts(_(\"%s error: The '%s' option requires an argument.\\n\"));\n#line 184 \"../save.c\"\n  puts(_(\"error %d (%s) stat-ing %s\\n\"));\n#line 238 \"../save.c\"\n  puts(_(\"error %d (%s) stat-ing %s\\n\"));\n#line 143 \"../restore.c\"\n  puts(_(\"%s error: no saved option state\\n\"));\n#line 231 \"../autoopts.c\"\n  puts(_(\"'%s' is not a command line option.\\n\"));\n#line 111 \"../time.c\"\n  puts(_(\"%s error:  '%s' is not a recognizable date/time.\\n\"));\n#line 132 \"../save.c\"\n  puts(_(\"'%s' not defined\\n\"));\n#line 50 \"../time.c\"\n  puts(_(\"%s error:  '%s' is not a recognizable time duration.\\n\"));\n#line 92 \"../check.c\"\n  puts(_(\"%s error:  The %s option must appear %d times.\\n\"));\n#line 164 \"../numeric.c\"\n  puts(_(\"%s error:  '%s' is not a recognizable number.\\n\"));\n#line 200 \"../enum.c\"\n  puts(_(\"%s error:  %s exceeds %s keyword count\\n\"));\n#line 330 \"../usage.c\"\n  puts(_(\"Try '%s %s' for more information.\\n\"));\n#line 45 \"../alias.c\"\n  puts(_(\"one %s%s option allowed\\n\"));\n#line 208 \"../makeshell.c\"\n  puts(_(\"standard output\"));\n#line 943 \"../makeshell.c\"\n  puts(_(\"standard output\"));\n#line 274 \"../usage.c\"\n  puts(_(\"standard output\"));\n#line 415 \"../usage.c\"\n  puts(_(\"standard output\"));\n#line 625 \"../usage.c\"\n  puts(_(\"standard output\"));\n#line 175 \"../version.c\"\n  puts(_(\"standard output\"));\n#line 274 \"../usage.c\"\n  puts(_(\"standard error\"));\n#line 415 \"../usage.c\"\n  puts(_(\"standard error\"));\n#line 625 \"../usage.c\"\n  puts(_(\"standard error\"));\n#line 175 \"../version.c\"\n  puts(_(\"standard error\"));\n#line 208 \"../makeshell.c\"\n  puts(_(\"write\"));\n#line 943 \"../makeshell.c\"\n  puts(_(\"write\"));\n#line 273 \"../usage.c\"\n  puts(_(\"write\"));\n#line 414 \"../usage.c\"\n  puts(_(\"write\"));\n#line 624 \"../usage.c\"\n  puts(_(\"write\"));\n#line 174 \"../version.c\"\n  puts(_(\"write\"));\n#line 60 \"../numeric.c\"\n  puts(_(\"%s error:  %s option value %ld is out of range.\\n\"));\n#line 44 \"../check.c\"\n  puts(_(\"%s error:  %s option requires the %s option\\n\"));\n#line 131 \"../save.c\"\n  puts(_(\"%s warning:  cannot save options - %s not regular file\\n\"));\n#line 183 \"../save.c\"\n  puts(_(\"%s warning:  cannot save options - %s not regular file\\n\"));\n#line 237 \"../save.c\"\n  puts(_(\"%s warning:  cannot save options - %s not regular file\\n\"));\n#line 256 \"../save.c\"\n  puts(_(\"%s warning:  cannot save options - %s not regular file\\n\"));\n#line 534 \"../save.c\"\n  puts(_(\"%s warning:  cannot save options - %s not regular file\\n\"));\n  /* END-LIBOPTS-MESSAGES */\n}",
      "lines": 260,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/src/unshar-opts.h": {
    "aoGetsText": {
      "start_point": [
        217,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "static inline char* aoGetsText(char const* pz) {\n    if (pz == NULL) return NULL;\n    return (char*)gettext(pz);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "char",
        "* aoGetsText(char const* pz)",
        "*"
      ]
    },
    "nomem_err": {
      "start_point": [
        259,
        0
      ],
      "end_point": [
        264,
        1
      ],
      "content": "static inline void\nnomem_err(size_t sz, char const * what)\n{\n    char const * fmt = _(\"could not allocate %zu bytes for %s\\n\");\n    die(UNSHAR_EXIT_NOMEM, fmt, sz, what);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/src/unshar.c": {
    "to_uchar": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        52,
        61
      ],
      "content": "static inline unsigned char to_uchar (char ch) { return ch; }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "looks_like_c_code": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "static bool\nlooks_like_c_code (char const * buf)\n{\n  static char const * const directives[] = {\n    \"include\", \"define\", \"ifdef\", \"ifndef\", \"if\",\n    \"pragma\", \"undef\", \"elif\", \"error\", \"line\", NULL };\n\n  while (isspace (to_uchar (*buf)))  buf++;\n  switch (*(buf++))\n    {\n    case '#':\n      {\n        int ix = 0;\n        while (isspace ((int) *buf))  buf++;\n        for (;;) {\n          char const * dir = directives[ix++];\n          size_t ln;\n          if (dir == NULL)\n            return false;\n          ln = strlen (dir);\n          if ((strncmp (buf, dir, ln) == 0) && isspace ((int)buf[ln]))\n            return true;\n        }\n      }\n\n    case '/':\n      return ((*buf == '*') || (*buf == '/'));\n\n    default: return false;\n    }\n}",
      "lines": 31,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "looks_like_shell_code": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static bool\nlooks_like_shell_code (char const * buf)\n{\n  while (isspace ((int) *buf))  buf++;\n  switch (*buf)\n    {\n    case '#': case ':':\n      return true;\n    default:\n      if (islower ((int)*buf))\n        break;\n      return false;\n    }\n\n  {\n    static char const * const cmn_cmds[] = {\n      \"echo\", \"sed\", \"cat\", \"if\", NULL };\n\n    int ix = 0;\n    for (;;) {\n      char const * cmd = cmn_cmds[ix++];\n      size_t ln;\n      if (cmd == NULL)\n        return false;\n      ln = strlen (cmd);\n      if ((strncmp (buf, cmd, ln) == 0) && isspace ((int)buf[ln]))\n        return true;\n    }\n  }\n}",
      "lines": 30,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "this_is_cut_line": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "static bool\nthis_is_cut_line (char const * buf)\n{\n  static char const * const kwds[] = {\n    \"cut\", \"CUT\", \"tear\", \"TEAR\" };\n  static char const * const here_here[] = {\n    \"here\", \"HERE\" };\n  int ix = 0;\n\n  for (;;)\n    {\n      char const * kw  = kwds[ix];\n      char const * fnd = strstr (buf, kw);\n      if (fnd != NULL)\n        {\n          buf = fnd + strlen (kw);\n          break;\n        }\n\n      if (++ix >= 4)\n        return false;\n    }\n\n  {\n    char const * fnd = strstr (buf, kwds[ix]);\n    if (fnd != NULL)\n      return true;\n    fnd = strstr (buf, here_here[ix & 1]);\n    return (fnd != NULL);\n  }\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "next_line_is_valid": {
      "start_point": [
        188,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "static bool\nnext_line_is_valid (char const * name, FILE * file)\n{\n  off_t position;\n\n  /* Read next line after \"cut here\", skipping blank lines.  */\n\n  for (;;)\n    {\n      char * buf;\n      position = ftello (file);\n      buf = fgets (rw_buffer, rw_base_size, file);\n      if (buf == NULL)\n        {\n          error (0, 0, _(\"Found no shell commands after cut line in %s\"),\n                 name);\n          return false;\n        }\n\n      while (isspace ((int)*buf))  buf++;\n      if (*buf != '\\0')\n        break;\n    }\n\n  /* Win if line starts with a comment character of lower case letter.  */\n  if (islower ((int)*rw_buffer) || (*rw_buffer == '#') || (*rw_buffer == ':'))\n    {\n      fseeko (file, position, SEEK_SET);\n      return true;\n    }\n\n  /* Cut here message lied to us.  */\n\n  error (0, 0, _(\"%s is probably not a shell archive\"), name);\n  error (0, 0, _(\"The 'cut line' was followed by: %s\"), rw_buffer);\n  return false;\n}",
      "lines": 37,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "find_archive": {
      "start_point": [
        231,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "static bool\nfind_archive (char const * name, FILE * file, off_t start)\n{\n  fseeko (file, start, SEEK_SET);\n\n  while (1)\n    {\n      /* Record position of the start of this line.  */\n      off_t position = ftello (file);\n\n      /* Read next line, fail if no more and no previous process.  */\n      if (!fgets (rw_buffer, BUFSIZ, file))\n\t{\n\t  if (!start)\n\t    error (0, 0, _(\"Found no shell commands in %s\"), name);\n\t  return false;\n\t}\n\n      /*\n       * Bail out if we see C preprocessor commands or C comments.\n       */\n      if (looks_like_c_code (rw_buffer))\n\t{\n\t  error (0, 0, _(\"%s looks like raw C code, not a shell archive\"),\n\t\t name);\n\t  return false;\n\t}\n\n      /* Does this line start with a shell command or comment.  */\n\n      if (looks_like_shell_code (rw_buffer))\n\t{\n\t  fseeko (file, position, SEEK_SET);\n\t  return true;\n\t}\n\n      /*\n       * Does this line say \"Cut here\"?\n       */\n      if (this_is_cut_line (rw_buffer))\n        return next_line_is_valid (name, file);\n    }\n}",
      "lines": 43,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "get_env_tmpdir": [
      {
        "start_point": [
          277,
          0
        ],
        "end_point": [
          286,
          1
        ],
        "content": "static char const *\nget_env_tmpdir(void)\n{\n  char const * res = getenv (\"TMPDIR\");\n  if (res) return res;\n  res = getenv (\"TEMP\");\n  if (res) return res;\n  res = getenv (\"TMP\");\n  return res ? res : \".\";\n}",
        "lines": 10,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "char",
          "const",
          "const",
          "*\nget_env_tmpdir(void)",
          "*"
        ]
      },
      {
        "start_point": [
          290,
          0
        ],
        "end_point": [
          295,
          1
        ],
        "content": "static char const *\nget_env_tmpdir(void)\n{\n  char const * res = getenv (\"TMPDIR\");\n  return res ? res : \"/tmp\";\n}",
        "lines": 6,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "char",
          "const",
          "const",
          "*\nget_env_tmpdir(void)",
          "*"
        ]
      }
    ],
    "load_file": {
      "start_point": [
        310,
        0
      ],
      "end_point": [
        352,
        1
      ],
      "content": "static FILE *\nload_file (char const ** tmp_fname, FILE * infp)\n{\n  static char const z_tmpfile[] = \"unsh.XXXXXX\";\n  char * pz_fname;\n  FILE * outfp;\n\n  {\n    size_t name_size;\n    char const * pz_tmp = get_env_tmpdir();\n\n    name_size = strlen (pz_tmp) + sizeof (z_tmpfile) + 1;\n    *tmp_fname = pz_fname = malloc (name_size);\n\n    if (pz_fname == NULL)\n      fserr (UNSHAR_EXIT_NOMEM, \"malloc\", _(\"file name buffer\"));\n    \n    sprintf (pz_fname, \"%s/%s\", pz_tmp, z_tmpfile);\n  }\n\n  {\n    int fd = mkstemp (pz_fname);\n    if (fd < 0)\n      fserr (UNSHAR_EXIT_CANNOT_CREATE, \"mkstemp\", z_tmpfile);\n    \n    outfp = fdopen (fd, \"wb+\");\n  }\n\n  if (outfp == NULL)\n    fserr (UNSHAR_EXIT_CANNOT_CREATE, \"fdopen\", pz_fname);\n\n  for (;;)\n    {\n      size_t size_read = fread (rw_buffer, 1, rw_base_size, infp);\n      if (size_read == 0)\n        break;\n      fwrite (rw_buffer, size_read, 1, outfp);\n    }\n\n  rewind (outfp);\n\n  return outfp;\n}",
      "lines": 43,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "FILE",
        "*\nload_file (char const ** tmp_fname, FILE * infp)",
        "*"
      ]
    },
    "unshar_file": {
      "start_point": [
        359,
        0
      ],
      "end_point": [
        428,
        1
      ],
      "content": "int\nunshar_file (const char * name, FILE * file)\n{\n  char const * tmp_fname = NULL;\n  off_t curr_pos;\n\n#ifdef __MINGW32__\n  _setmode (fileno (file), _O_BINARY);\n#endif\n\n  curr_pos = ftello (file);\n  if (curr_pos < 0)\n    {\n      file = load_file (&tmp_fname, file);\n      curr_pos = ftello (file);\n      if (curr_pos < 0)\n        fserr (UNSHAR_EXIT_CANNOT_CREATE, \"ftell\", tmp_fname);\n    }\n      \n  while (find_archive (name, file, curr_pos))\n    {\n      char const * cmd = HAVE_OPT(OVERWRITE) ? \"sh -s - -c\" : \"sh\";\n      FILE * shell_fp = popen (cmd, \"w\");\n\n      if (shell_fp == NULL)\n\tfserr (UNSHAR_EXIT_POPEN_PROBLEM, \"popen\", cmd);\n      if (HAVE_OPT(DIRECTORY))\n        fprintf (shell_fp, \"cd %s >/dev/null || exit 1\\n\", OPT_ARG(DIRECTORY));\n      printf (\"%s:\\n\", name);\n      if (! HAVE_OPT(SPLIT_AT))\n\t{\n          for (;;)\n            {\n              size_t len = fread (rw_buffer, 1, rw_base_size, file);\n              if (len == 0)\n                break;\n              fwrite (rw_buffer, 1, len, shell_fp);\n            }\n\n\t  pclose (shell_fp);\n\t  break;\n\t}\n      else\n\t{\n          char * text_in;\n\n\t  while (text_in = fgets (rw_buffer, rw_base_size, file),\n\t\t text_in != NULL)\n\t    {\n\t      fputs (rw_buffer, shell_fp);\n\t      if (!strncmp (OPT_ARG(SPLIT_AT), rw_buffer, separator_str_len))\n\t\tbreak;\n\t    }\n\t  pclose (shell_fp);\n\n\t  if (text_in == NULL)\n\t    break;\n\n          curr_pos = ftello (file);\n\t}\n    }\n\n  if (tmp_fname != NULL)\n    {\n      unlink (tmp_fname);\n      free ((void *)tmp_fname);\n    }\n\n  return UNSHAR_EXIT_SUCCESS;\n}",
      "lines": 70,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "init_unshar": {
      "start_point": [
        437,
        0
      ],
      "end_point": [
        452,
        1
      ],
      "content": "void\ninit_unshar (void)\n{\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n#ifdef __MSDOS__\n  setbuf (stdout, NULL);\n  setbuf (stderr, NULL);\n#endif\n\n  rw_base_size = GET_PAGE_SIZE;\n  rw_buffer    = malloc (rw_base_size);\n  if (rw_buffer == NULL)\n    fserr (UNSHAR_EXIT_NOMEM, \"malloc\", _(\"read/write buffer\"));\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/src/uudecode-opts.c": {
    "doUsageOpt": {
      "start_point": [
        370,
        0
      ],
      "end_point": [
        380,
        1
      ],
      "content": "static void\ndoUsageOpt(tOptions * opts, tOptDesc * od)\n{\n    int ex_code;\n    ex_code = UUDECODE_EXIT_SUCCESS;\n    optionUsage(&uudecodeOptions, ex_code);\n    /* NOTREACHED */\n    exit(1);\n    (void)opts;\n    (void)od;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "doOptOutput_File": {
      "start_point": [
        392,
        0
      ],
      "end_point": [
        422,
        1
      ],
      "content": "static void\ndoOptOutput_File(tOptions* pOptions, tOptDesc* pOptDesc)\n{\n    /*\n     * Be sure the flag-code[0] handles special values for the options pointer\n     * viz. (poptions <= OPTPROC_EMIT_LIMIT) *and also* the special flag bit\n     * ((poptdesc->fOptState & OPTST_RESET) != 0) telling the option to\n     * reset its state.\n     */\n    /* extracted from uudecode-opts.def, line 61 */\n  FILE * fp;\n  switch (*pOptDesc->optArg.argString)\n    {\n    case '-':\n      if (pOptDesc->optArg.argString[1] == '\\0')\n        return;\n      break;\n\n    case '/':\n      if (strcmp (pOptDesc->optArg.argString + 1, \"dev/stdout\") == 0)\n        return;\n\n    default:\n      break;\n    }\n  fp = freopen (pOptDesc->optArg.argString, \"w\", stdout);\n  if (fp != stdout)\n    fserr (UUDECODE_EXIT_NO_OUTPUT, \"freopen-ing for stdout\",\n           pOptDesc->optArg.argString);\n    (void)pOptions;\n}",
      "lines": 31,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "vusage_message": {
      "start_point": [
        434,
        0
      ],
      "end_point": [
        443,
        1
      ],
      "content": "void\nvusage_message(char const * fmt, va_list ap)\n{\n    char const * er_leader = _(\"uudecode usage error:\\n\");\n    fputs(er_leader, stderr);\n    vfprintf(stderr, fmt, ap);\n    optionUsage(&uudecodeOptions, UUDECODE_EXIT_USAGE_ERROR);\n    /* NOTREACHED */\n    exit(1);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "usage_message": {
      "start_point": [
        453,
        0
      ],
      "end_point": [
        461,
        1
      ],
      "content": "void\nusage_message(char const * fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    vusage_message(fmt, ap);\n    /* NOTREACHED */\n    va_end(ap);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "vdie": {
      "start_point": [
        471,
        0
      ],
      "end_point": [
        480,
        1
      ],
      "content": "void\nvdie(int exit_code, char const * fmt, va_list ap)\n{\n    char const * die_leader = _(\"uudecode fatal error:\\n\");\n    fputs(die_leader, stderr);\n    vfprintf(stderr, fmt, ap);\n    fflush(stderr);\n    exit(exit_code);\n    /* NOTREACHED */\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "die": {
      "start_point": [
        490,
        0
      ],
      "end_point": [
        498,
        1
      ],
      "content": "void\ndie(int exit_code, char const * fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    vdie(exit_code, fmt, ap);\n    /* NOTREACHED */\n    va_end(ap);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "fserr": {
      "start_point": [
        508,
        0
      ],
      "end_point": [
        514,
        1
      ],
      "content": "void\nfserr(int exit_code, char const * op, char const * fname)\n{\n    char const * fserr_fmt = _(\"fserr %d (%s) performing '%s' on %s\\n\");\n    die(exit_code, fserr_fmt, errno, strerror(errno), op, fname);\n    /* NOTREACHED */\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "AO_gettext": {
      "start_point": [
        611,
        0
      ],
      "end_point": [
        640,
        1
      ],
      "content": "static char *\nAO_gettext(char const * pz)\n{\n    char * res;\n    if (pz == NULL)\n        return NULL;\n#ifdef HAVE_DCGETTEXT\n    /*\n     * While processing the option_xlateable_txt data, try to use the\n     * \"libopts\" domain.  Once we switch to the option descriptor data,\n     * do *not* use that domain.\n     */\n    if (option_xlateable_txt.field_ct != 0) {\n        res = dgettext(\"libopts\", pz);\n        if (res == pz)\n            res = (char *)VOIDP(_(pz));\n    } else\n        res = (char *)VOIDP(_(pz));\n#else\n    res = (char *)VOIDP(_(pz));\n#endif\n    if (res == pz)\n        return res;\n    res = strdup(res);\n    if (res == NULL) {\n        fputs(_(\"No memory for duping translated strings\\n\"), stderr);\n        exit(UUDECODE_EXIT_NO_MEM);\n    }\n    return res;\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nAO_gettext(char const * pz)",
        "*"
      ]
    },
    "coerce_it": {
      "start_point": [
        646,
        0
      ],
      "end_point": [
        647,
        1
      ],
      "content": "static void coerce_it(void ** s) { *s = AO_gettext(*s);\n}",
      "lines": 2,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "translate_option_strings": {
      "start_point": [
        653,
        0
      ],
      "end_point": [
        681,
        1
      ],
      "content": "static void\ntranslate_option_strings(void)\n{\n    tOptions * const opts = &uudecodeOptions;\n\n    /*\n     *  Guard against re-translation.  It won't work.  The strings will have\n     *  been changed by the first pass through this code.  One shot only.\n     */\n    if (option_xlateable_txt.field_ct != 0) {\n        /*\n         *  Do the translations.  The first pointer follows the field count\n         *  field.  The field count field is the size of a pointer.\n         */\n        char ** ppz = (char**)VOIDP(&(option_xlateable_txt));\n        int     ix  = option_xlateable_txt.field_ct;\n\n        do {\n            ppz++; /* skip over field_ct */\n            *ppz = AO_gettext(*ppz);\n        } while (--ix > 0);\n        /* prevent re-translation and disable \"libopts\" domain lookup */\n        option_xlateable_txt.field_ct = 0;\n\n        coerce_it(VOIDP(&(opts->pzCopyright)));\n        coerce_it(VOIDP(&(opts->pzCopyNotice)));\n        coerce_it(VOIDP(&(opts->pzFullVersion)));\n    }\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bogus_function": {
      "start_point": [
        686,
        0
      ],
      "end_point": [
        955,
        1
      ],
      "content": "static void bogus_function(void) {\n  /* TRANSLATORS:\n\n     The following dummy function was crated solely so that xgettext can\n     extract the correct strings.  These strings are actually referenced\n     by a field name in the uudecodeOptions structure noted in the\n     comments below.  The literal text is defined in uudecode_opt_strs.\n   \n     NOTE: the strings below are segmented with respect to the source string\n     uudecode_opt_strs.  The strings above are handed off for translation\n     at run time a paragraph at a time.  Consequently, they are presented here\n     for translation a paragraph at a time.\n   \n     ALSO: often the description for an option will reference another option\n     by name.  These are set off with apostrophe quotes (I hope).  Do not\n     translate option names.\n   */\n  /* referenced via uudecodeOptions.pzCopyright */\n  puts(_(\"uudecode (GNU sharutils) 4.15.2\\n\\\nCopyright (C) 1994-2015 Free Software Foundation, Inc., all rights reserved.\\n\\\nThis is free software. It is licensed for use, modification and\\n\\\nredistribution under the terms of the GNU General Public License,\\n\\\nversion 3 or later <http://gnu.org/licenses/gpl.html>\\n\"));\n\n  /* referenced via uudecodeOptions.pzCopyNotice */\n  puts(_(\"uudecode is free software: you can redistribute it and/or modify it under\\n\\\nthe terms of the GNU General Public License as published by the Free\\n\\\nSoftware Foundation, either version 3 of the License, or (at your option)\\n\\\nany later version.\\n\\n\"));\n  puts(_(\"uudecode is distributed in the hope that it will be useful, but WITHOUT ANY\\n\\\nWARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\\n\\\nFOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\\n\\\ndetails.\\n\\n\"));\n  puts(_(\"You should have received a copy of the GNU General Public License along\\n\\\nwith this program.  If not, see <http://www.gnu.org/licenses/>.\\n\"));\n\n  /* referenced via uudecodeOptions.pzUsageTitle */\n  puts(_(\"uudecode (GNU sharutils) - decode an encoded file\\n\\\nUsage:  %s [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [<file>...]\\n\"));\n\n  /* referenced via uudecodeOptions.pzExplain */\n  puts(_(\"If no 'file'(s) are provided, then standard input is decoded.\\n\"));\n\n  /* referenced via uudecodeOptions.pzDetail */\n  puts(_(\"'uudecode' transforms uuencoded files into their original form.\\n\\n\"));\n  puts(_(\"The encoded file(s) may be specified on the command line, or one may be\\n\\\nread from standard input.  The output file name is specified in the encoded\\n\\\nfile, but may be overridden with the '-o' option.  It will have the mode of\\n\\\nthe original file, except that setuid and execute bits are not retained.  If\\n\\\nthe output file is specified to be '/dev/stdout' or '-', the result will be\\n\\\nwritten to standard output.  If there are multiple input files and the\\n\\\nsecond or subsquent file specifies standard output, the decoded data will\\n\\\nbe written to the same file as the previous output.  Don't do that.\\n\\n\"));\n  puts(_(\"'uudecode' ignores any leading and trailing lines.  It looks for a line\\n\\\nthat starts with \\\"'begin'\\\" and proceeds until the end-of-encoding marker is\\n\\\nfound.  The program determines from the header line of the encoded file\\n\\\nwhich of the two supported encoding schemes was used and whether or not the\\n\\\noutput file name has been encoded with base64 encoding.  See 'uuencode(5)'.\\n\"));\n\n  /* referenced via uudecodeOptions.pzFullVersion */\n  puts(_(\"uudecode (GNU sharutils) 4.15.2\"));\n\n  /* referenced via uudecodeOptions.pzFullUsage */\n  puts(_(\"uudecode (GNU sharutils) - decode an encoded file\\n\\\nUsage:  uudecode [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [<file>...]\\n\\n\"));\n  puts(_(\"   -o, --output-file=str      direct output to file\\n\"));\n  puts(_(\"   -c, --ignore-chmod         ignore fchmod(3P) errors\\n\"));\n  puts(_(\"   -v, --version[=MODE]       output version information and exit\\n\"));\n  puts(_(\"   -h, --help                 display extended usage information and exit\\n\"));\n  puts(_(\"   -!, --more-help            extended usage information passed thru pager\\n\"));\n  puts(_(\"   -R, --save-opts[=FILE]     save the option state to a config file FILE\\n\"));\n  puts(_(\"   -r, --load-opts=FILE       load options from the config file FILE\\n\\\n                                - disabled with '--no-load-opts'\\n\\\n                                - may appear multiple times\\n\\n\"));\n  puts(_(\"Options are specified by doubled hyphens and their name or by a single\\n\\\nhyphen and the flag character.\\n\\\nIf no 'file'(s) are provided, then standard input is decoded.\\n\\n\"));\n  puts(_(\"The following option preset mechanisms are supported:\\n\"));\n  puts(_(\" - reading file $HOME/.sharrc\\n\\n\\\n'uudecode' transforms uuencoded files into their original form.\\n\\n\"));\n  puts(_(\"The encoded file(s) may be specified on the command line, or one may be\\n\\\nread from standard input.  The output file name is specified in the encoded\\n\\\nfile, but may be overridden with the '-o' option.  It will have the mode of\\n\\\nthe original file, except that setuid and execute bits are not retained.  If\\n\\\nthe output file is specified to be '/dev/stdout' or '-', the result will be\\n\\\nwritten to standard output.  If there are multiple input files and the\\n\\\nsecond or subsquent file specifies standard output, the decoded data will\\n\\\nbe written to the same file as the previous output.  Don't do that.\\n\\n\"));\n  puts(_(\"'uudecode' ignores any leading and trailing lines.  It looks for a line\\n\\\nthat starts with \\\"'begin'\\\" and proceeds until the end-of-encoding marker is\\n\\\nfound.  The program determines from the header line of the encoded file\\n\\\nwhich of the two supported encoding schemes was used and whether or not the\\n\\\noutput file name has been encoded with base64 encoding.  See 'uuencode(5)'.\\n\\n\"));\n  puts(_(\"Please send bug reports to:  <bug-gnu-utils@gnu.org>\\n\"));\n\n  /* referenced via uudecodeOptions.pzShortUsage */\n  puts(_(\"uudecode (GNU sharutils) - decode an encoded file\\n\\\nUsage:  uudecode [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [<file>...]\\n\\\nTry 'uudecode --help' for more information.\\n\"));\n  /* LIBOPTS-MESSAGES: */\n#line 67 \"../autoopts.c\"\n  puts(_(\"allocation of %d bytes failed\\n\"));\n#line 93 \"../autoopts.c\"\n  puts(_(\"allocation of %d bytes failed\\n\"));\n#line 53 \"../init.c\"\n  puts(_(\"AutoOpts function called without option descriptor\\n\"));\n#line 86 \"../init.c\"\n  puts(_(\"\\tThis exceeds the compiled library version:  \"));\n#line 84 \"../init.c\"\n  puts(_(\"Automated Options Processing Error!\\n\"\n       \"\\t%s called AutoOpts function with structure version %d:%d:%d.\\n\"));\n#line 80 \"../autoopts.c\"\n  puts(_(\"realloc of %d bytes at 0x%p failed\\n\"));\n#line 88 \"../init.c\"\n  puts(_(\"\\tThis is less than the minimum library version:  \"));\n#line 121 \"../version.c\"\n  puts(_(\"Automated Options version %s\\n\"\n       \"\\tCopyright (C) 1999-2014 by Bruce Korb - all rights reserved\\n\"));\n#line 87 \"../makeshell.c\"\n  puts(_(\"(AutoOpts bug):  %s.\\n\"));\n#line 90 \"../reset.c\"\n  puts(_(\"optionResetOpt() called, but reset-option not configured\"));\n#line 292 \"../usage.c\"\n  puts(_(\"could not locate the 'help' option\"));\n#line 336 \"../autoopts.c\"\n  puts(_(\"optionProcess() was called with invalid data\"));\n#line 748 \"../usage.c\"\n  puts(_(\"invalid argument type specified\"));\n#line 598 \"../find.c\"\n  puts(_(\"defaulted to option with optional arg\"));\n#line 76 \"../alias.c\"\n  puts(_(\"aliasing option is out of range.\"));\n#line 234 \"../enum.c\"\n  puts(_(\"%s error:  the keyword '%s' is ambiguous for %s\\n\"));\n#line 108 \"../find.c\"\n  puts(_(\"  The following options match:\\n\"));\n#line 293 \"../find.c\"\n  puts(_(\"%s: ambiguous option name: %s (matches %d options)\\n\"));\n#line 161 \"../check.c\"\n  puts(_(\"%s: Command line arguments required\\n\"));\n#line 43 \"../alias.c\"\n  puts(_(\"%d %s%s options allowed\\n\"));\n#line 94 \"../makeshell.c\"\n  puts(_(\"%s error %d (%s) calling %s for '%s'\\n\"));\n#line 306 \"../makeshell.c\"\n  puts(_(\"interprocess pipe\"));\n#line 168 \"../version.c\"\n  puts(_(\"error: version option argument '%c' invalid.  Use:\\n\"\n       \"\\t'v' - version only\\n\"\n       \"\\t'c' - version and copyright\\n\"\n       \"\\t'n' - version and full copyright notice\\n\"));\n#line 58 \"../check.c\"\n  puts(_(\"%s error:  the '%s' and '%s' options conflict\\n\"));\n#line 217 \"../find.c\"\n  puts(_(\"%s: The '%s' option has been disabled.\"));\n#line 430 \"../find.c\"\n  puts(_(\"%s: The '%s' option has been disabled.\"));\n#line 38 \"../alias.c\"\n  puts(_(\"-equivalence\"));\n#line 469 \"../find.c\"\n  puts(_(\"%s: illegal option -- %c\\n\"));\n#line 110 \"../reset.c\"\n  puts(_(\"%s: illegal option -- %c\\n\"));\n#line 271 \"../find.c\"\n  puts(_(\"%s: illegal option -- %s\\n\"));\n#line 755 \"../find.c\"\n  puts(_(\"%s: illegal option -- %s\\n\"));\n#line 118 \"../reset.c\"\n  puts(_(\"%s: illegal option -- %s\\n\"));\n#line 335 \"../find.c\"\n  puts(_(\"%s: unknown vendor extension option -- %s\\n\"));\n#line 159 \"../enum.c\"\n  puts(_(\"  or an integer from %d through %d\\n\"));\n#line 169 \"../enum.c\"\n  puts(_(\"  or an integer from %d through %d\\n\"));\n#line 747 \"../usage.c\"\n  puts(_(\"%s error:  invalid option descriptor for %s\\n\"));\n#line 1081 \"../usage.c\"\n  puts(_(\"%s error:  invalid option descriptor for %s\\n\"));\n#line 385 \"../find.c\"\n  puts(_(\"%s: invalid option name: %s\\n\"));\n#line 527 \"../find.c\"\n  puts(_(\"%s: The '%s' option requires an argument.\\n\"));\n#line 156 \"../autoopts.c\"\n  puts(_(\"(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\\n\"\n       \"\\t'%s' and '%s'.\"));\n#line 94 \"../check.c\"\n  puts(_(\"%s error:  The %s option is required\\n\"));\n#line 632 \"../find.c\"\n  puts(_(\"%s: The '%s' option cannot have an argument.\\n\"));\n#line 151 \"../check.c\"\n  puts(_(\"%s: Command line arguments are not allowed.\\n\"));\n#line 535 \"../save.c\"\n  puts(_(\"error %d (%s) creating %s\\n\"));\n#line 234 \"../enum.c\"\n  puts(_(\"%s error:  '%s' does not match any %s keywords.\\n\"));\n#line 93 \"../reset.c\"\n  puts(_(\"%s error: The '%s' option requires an argument.\\n\"));\n#line 184 \"../save.c\"\n  puts(_(\"error %d (%s) stat-ing %s\\n\"));\n#line 238 \"../save.c\"\n  puts(_(\"error %d (%s) stat-ing %s\\n\"));\n#line 143 \"../restore.c\"\n  puts(_(\"%s error: no saved option state\\n\"));\n#line 231 \"../autoopts.c\"\n  puts(_(\"'%s' is not a command line option.\\n\"));\n#line 111 \"../time.c\"\n  puts(_(\"%s error:  '%s' is not a recognizable date/time.\\n\"));\n#line 132 \"../save.c\"\n  puts(_(\"'%s' not defined\\n\"));\n#line 50 \"../time.c\"\n  puts(_(\"%s error:  '%s' is not a recognizable time duration.\\n\"));\n#line 92 \"../check.c\"\n  puts(_(\"%s error:  The %s option must appear %d times.\\n\"));\n#line 164 \"../numeric.c\"\n  puts(_(\"%s error:  '%s' is not a recognizable number.\\n\"));\n#line 200 \"../enum.c\"\n  puts(_(\"%s error:  %s exceeds %s keyword count\\n\"));\n#line 330 \"../usage.c\"\n  puts(_(\"Try '%s %s' for more information.\\n\"));\n#line 45 \"../alias.c\"\n  puts(_(\"one %s%s option allowed\\n\"));\n#line 208 \"../makeshell.c\"\n  puts(_(\"standard output\"));\n#line 943 \"../makeshell.c\"\n  puts(_(\"standard output\"));\n#line 274 \"../usage.c\"\n  puts(_(\"standard output\"));\n#line 415 \"../usage.c\"\n  puts(_(\"standard output\"));\n#line 625 \"../usage.c\"\n  puts(_(\"standard output\"));\n#line 175 \"../version.c\"\n  puts(_(\"standard output\"));\n#line 274 \"../usage.c\"\n  puts(_(\"standard error\"));\n#line 415 \"../usage.c\"\n  puts(_(\"standard error\"));\n#line 625 \"../usage.c\"\n  puts(_(\"standard error\"));\n#line 175 \"../version.c\"\n  puts(_(\"standard error\"));\n#line 208 \"../makeshell.c\"\n  puts(_(\"write\"));\n#line 943 \"../makeshell.c\"\n  puts(_(\"write\"));\n#line 273 \"../usage.c\"\n  puts(_(\"write\"));\n#line 414 \"../usage.c\"\n  puts(_(\"write\"));\n#line 624 \"../usage.c\"\n  puts(_(\"write\"));\n#line 174 \"../version.c\"\n  puts(_(\"write\"));\n#line 60 \"../numeric.c\"\n  puts(_(\"%s error:  %s option value %ld is out of range.\\n\"));\n#line 44 \"../check.c\"\n  puts(_(\"%s error:  %s option requires the %s option\\n\"));\n#line 131 \"../save.c\"\n  puts(_(\"%s warning:  cannot save options - %s not regular file\\n\"));\n#line 183 \"../save.c\"\n  puts(_(\"%s warning:  cannot save options - %s not regular file\\n\"));\n#line 237 \"../save.c\"\n  puts(_(\"%s warning:  cannot save options - %s not regular file\\n\"));\n#line 256 \"../save.c\"\n  puts(_(\"%s warning:  cannot save options - %s not regular file\\n\"));\n#line 534 \"../save.c\"\n  puts(_(\"%s warning:  cannot save options - %s not regular file\\n\"));\n  /* END-LIBOPTS-MESSAGES */\n}",
      "lines": 270,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/src/uudecode-opts.h": {
    "aoGetsText": {
      "start_point": [
        195,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "static inline char* aoGetsText(char const* pz) {\n    if (pz == NULL) return NULL;\n    return (char*)gettext(pz);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "char",
        "* aoGetsText(char const* pz)",
        "*"
      ]
    },
    "nomem_err": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        242,
        1
      ],
      "content": "static inline void\nnomem_err(size_t sz, char const * what)\n{\n    char const * fmt = _(\"could not allocate %zu bytes for %s\\n\");\n    die(UUDECODE_EXIT_NO_MEM, fmt, sz, what);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/src/uudecode.c": {
    "read_stduu": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "static uudecode_exit_code_t\nread_stduu (char const * inname, char const * outname)\n{\n  char buf[2 * BUFSIZ];\n\n  while (1)\n    {\n      int n;\n      char * p = buf;\n\n      if (fgets ((char *) buf, sizeof(buf), stdin) == NULL)\n        die (UUDECODE_EXIT_INVALID, _(\"%s: Short file\"), inname);\n\n      /* N is used to avoid writing out all the characters at the end of\n\t the file.  */\n\n      n = DEC (*p);\n      if (n <= 0)\n\tbreak;\n      for (++p; n >= 3; p += 4, n -= 3)\n\t{\n\t  TRY_PUTCHAR (DEC (p[0]) << 2 | DEC (p[1]) >> 4);\n\t  TRY_PUTCHAR (DEC (p[1]) << 4 | DEC (p[2]) >> 2);\n\t  TRY_PUTCHAR (DEC (p[2]) << 6 | DEC (p[3]));\n        }\n      switch (n)\n        {\n        case 0: break;\n        case 1:\n\t  TRY_PUTCHAR (DEC (p[0]) << 2 | DEC (p[1]) >> 4);\n          break;\n\n        case 2:\n\t  TRY_PUTCHAR (DEC (p[0]) << 2 | DEC (p[1]) >> 4);\n          TRY_PUTCHAR (DEC (p[1]) << 4 | DEC (p[2]) >> 2);\n          break;\n        }\n    }\n\n  /*\n   * We must now find an \"end\" line, with or without a '\\r' character.\n   */\n  do {\n    if (fgets (buf, sizeof(buf), stdin) == NULL)\n      break;\n\n    if (buf[0] != 'e') break;\n    if (buf[1] != 'n') break;\n    if (buf[2] != 'd') break;\n    if (buf[3] == NL)\n      return UUDECODE_EXIT_SUCCESS;\n\n    if (buf[3] != '\\r') break;\n    if (buf[4] == NL)\n      return UUDECODE_EXIT_SUCCESS;\n  } while (0);\n\n  die (UUDECODE_EXIT_INVALID, _(\"%s: No `end' line\"), inname);\n  /* NOTREACHED */\n  return UUDECODE_EXIT_INVALID;\n}",
      "lines": 61,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "uudecode_exit_code_t"
      ]
    },
    "read_base64": {
      "start_point": [
        175,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "static uudecode_exit_code_t\nread_base64 (char const * inname, char const * outname)\n{\n  char buf_in[2 * BUFSIZ];\n  char buf_out[2 * BUFSIZ];\n  struct base64_decode_context ctx;\n  base64_decode_ctx_init (&ctx);\n\n  for (;;)\n    {\n      size_t outlen = sizeof(buf_out);\n\n      if (fgets (buf_in, sizeof(buf_in), stdin) == NULL)\n\tfserr (UUDECODE_EXIT_INVALID, _(\"%s: Short file\"), inname);\n\n      if (memcmp (buf_in, \"====\", 4) == 0)\n\tbreak;\n\n      if (! base64_decode_ctx (&ctx, buf_in, strlen(buf_in), buf_out, &outlen))\n        die (UUDECODE_EXIT_INVALID, _(\"%s: invalid input\"), inname);\n\n      if (fwrite (buf_out, outlen, 1, stdout) != 1)\n        fserr (UUDECODE_EXIT_NO_OUTPUT, \"fwrite\", outname);\n    }\n\n  return UUDECODE_EXIT_SUCCESS;\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "uudecode_exit_code_t"
      ]
    },
    "get_env_homedir": [
      {
        "start_point": [
          204,
          0
        ],
        "end_point": [
          221,
          1
        ],
        "content": "static char const *\nget_env_homedir(void)\n{\n  char const * res = getenv(\"HOME\");\n  if (res) return res;\n  {\n    static char w32homedir[FILENAME_MAX];\n\n    char *homedrive = getenv (\"HOMEDRIVE\");\n    char *homepath  = getenv (\"HOMEPATH\");\n\n    if ((homedrive == NULL) || (homepath == NULL))\n      die (UUDECODE_EXIT_INVALID, _(\"cannot expand $HOME\"));\n\n    strcat (strcpy (w32homedir, homedrive), homepath);\n    return w32homedir;\n  }\n}",
        "lines": 18,
        "depth": 11,
        "decorators": [
          "static",
          "static",
          "char",
          "const",
          "const",
          "*\nget_env_homedir(void)",
          "*"
        ]
      },
      {
        "start_point": [
          225,
          0
        ],
        "end_point": [
          232,
          1
        ],
        "content": "static char const *\nget_env_homedir(void)\n{\n  char const * res = getenv(\"HOME\");\n  if (res == NULL)\n    die (UUDECODE_EXIT_INVALID, _(\"cannot expand $HOME\"));\n  return res;\n}",
        "lines": 8,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "char",
          "const",
          "const",
          "*\nget_env_homedir(void)",
          "*"
        ]
      }
    ],
    "expand_tilde": {
      "start_point": [
        243,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "static char *\nexpand_tilde (char * buf)\n{\n  char * outname;\n  char const * homedir;\n\n  if (buf[1] == '/')\n    {\n      homedir = get_env_homedir ();\n      buf += 2;\n    }\n  else\n    {\n      struct passwd *pw;\n      char * pz = buf + 1;\n      while (*pz != '/'\n#ifdef __MINGW32__\n             && *pz != '\\\\'\n#endif\n             )\n        ++pz;\n      if (*pz == NUL)\n        {\n          error (0, 0, _(\"%s: Illegal file name: %s\"), program_name, buf);\n          return NULL;\n        }\n      *pz++ = NUL;\n      pw = getpwnam (buf + 1);\n      if (pw == NULL)\n        {\n          error (0, 0, _(\"No user '%s'\"), buf + 1);\n          return NULL;\n        }\n      homedir = pw->pw_dir;\n      buf = pz;\n    }\n\n  {\n    size_t sz = strlen (homedir) + strlen (buf) + 2;\n    outname = (char *) malloc (sz);\n    if (outname == NULL)\n      fserr (UUDECODE_EXIT_NO_MEM, \"malloc\", _(\"output file name\"));\n  }\n\n  sprintf (outname, \"%s/%s\", homedir, buf);\n  return outname;\n}",
      "lines": 47,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nexpand_tilde (char * buf)",
        "*"
      ]
    },
    "reopen_output": {
      "start_point": [
        294,
        0
      ],
      "end_point": [
        331,
        1
      ],
      "content": "static uudecode_exit_code_t\nreopen_output (char const * outname, int mode)\n{\n  /* Check out file if it exists */\n  if (!access(outname, F_OK))\n    {\n      struct stat attr;\n      if (lstat(outname, &attr) == -1)\n        {\n          error (0, errno, _(\"cannot access %s\"), outname);\n          return UUDECODE_EXIT_NO_OUTPUT;\n        }\n    }\n\n  {\n    FILE * fp = freopen (outname, \"w\" FOPEN_BINARY, stdout);\n    if (fp != stdout)\n      fserr (UUDECODE_EXIT_NO_OUTPUT, \"freopen\", outname);\n  }\n\n  if (UU_CHMOD(outname, STDOUT_FILENO, mode) != 0)\n    {\n      error (0, errno, _(\"chmod of %s\"), outname);\n      /*\n       * http://austingroupbugs.net/view.php?id=635\n       * if the mode bits cannot be set, uudecode shall\n       * not treat this as an error.\n       */\n      if (! HAVE_OPT(IGNORE_CHMOD))\n        {\n          char const * p = getenv(\"POSIXLY_CORRECT\");\n          if (p == NULL)\n            return UUDECODE_EXIT_NO_OUTPUT;\n        }\n    }\n\n  return UUDECODE_EXIT_SUCCESS;\n}",
      "lines": 38,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "uudecode_exit_code_t"
      ]
    },
    "decode_fname": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        356,
        1
      ],
      "content": "static void\ndecode_fname (char * buf)\n{\n  size_t sz  = strlen (buf);\n  char * out = malloc (2*sz + 4);\n\n  if (sz == 0)\n    die (UUDECODE_EXIT_INVALID, _(\"output name is empty\"));\n\n  {\n    char * tmp = out + sz + 4;\n\n    if (out == NULL)\n      fserr(UUDECODE_EXIT_NO_MEM, \"malloc\", _(\"output file name\"));\n\n    memcpy(out, buf, sz);\n    out[sz] = '\\0';\n    if (! base64_decode (out, sz, tmp, &sz))\n      die (UUDECODE_EXIT_INVALID, _(\"invalid base64 encoded name: %s\"), buf);\n    memcpy (buf, tmp, sz);\n    buf[sz] = '\\0';\n  }\n  free (out);\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "decode": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        500,
        1
      ],
      "content": "static uudecode_exit_code_t\ndecode (char const * inname)\n{\n  char *pz;\n  int   mode;\n  char  buf[2 * BUFSIZ] = { NUL };\n  char *outname;\n  bool  allocated_outname = false;\n  bool  encoded_fname = false;\n  uudecode_exit_code_t rval;\n  bool  do_base64 = false;\n\n  /* Search for header line.  */\n\n  while (1)\n    {\n      if (fgets (buf, sizeof (buf), stdin) == NULL)\n\t{\n        bad_beginning:\n\t  die (UUDECODE_EXIT_INVALID,\n               _(\"%s: Invalid or missing 'begin' line\\n\"), inname);\n\t}\n\n      if (strchr (buf, NL) == NULL)\n        goto bad_beginning;\n\n      if (strncmp (buf, \"begin\", 5) == 0)\n\t{\n          char * scan = buf+5;\n\n        check_begin_option:\n\n          switch (*scan) {\n          default:\n            goto bad_beginning;\n          case ' ':\n            break;\n          case '-':\n            {\n              static char const base64[]  = \"ase64\";\n              static char const encoded[] = \"encoded\";\n\n              if (*++scan == 'b')\n                {\n                  if (strncmp (scan+1, base64, sizeof (base64) - 1) != 0)\n                    goto bad_beginning;\n                  if (do_base64)\n                    goto bad_beginning;\n                  do_base64 = true;\n                  scan += sizeof (base64); /* chars + 'b' */\n                }\n              else\n                {\n                  if (strncmp (scan, encoded, sizeof (encoded) - 1) != 0)\n                    goto bad_beginning;\n                  if (encoded_fname)\n                    goto bad_beginning;\n                  encoded_fname = true;\n                  scan += sizeof (encoded) - 1; /* 'e' is included */\n                }\n\n              goto check_begin_option;\n\t    }\n          }\n\n\t  if (sscanf (scan, \" %o %[^\\n]\", &mode, buf) == 2)\n\t    break;\n          goto bad_beginning;\n\t}\n    }\n\n  /* If the output file name is given on the command line this rules.  */\n  if (HAVE_OPT(OUTPUT_FILE))\n    outname = (char *) OPT_ARG(OUTPUT_FILE);\n  else\n    {\n      if (encoded_fname)\n        decode_fname (buf);\n\n      if (buf[0] != '~')\n\toutname = buf;\n      else\n        {\n          /* Handle ~user/file format.  */\n\n          outname = expand_tilde (buf);\n          if (outname == NULL)\n            return UUDECODE_EXIT_NO_OUTPUT;\n          allocated_outname = true;\n        }\n\n      /* Be certain there is no trailing white space */\n      pz = outname + strlen (outname);\n      while ((pz > outname) && isspace ((int)pz[-1]))\n        pz--;\n      *pz = NUL;\n    }\n\n  if (  (strcmp (outname, \"/dev/stdout\") != 0)\n     && (strcmp (outname, \"-\") != 0) )\n    {\n      rval = reopen_output (outname, mode);\n      if (rval != UUDECODE_EXIT_SUCCESS)\n        goto fail_return;\n    }\n#ifdef __MINGW32__\n  else if (_setmode (fileno (stdout), _O_BINARY) == -1)\n    {\n      rval = UUDECODE_EXIT_NO_OUTPUT;\n      goto fail_return;\n    }\n#endif\n\n  /* We use different functions for different encoding methods.\n     A common function would slow down the program.  */\n\n  /* For each input line:  */\n  if (do_base64)\n    rval = read_base64 (inname, outname);\n  else\n    rval = read_stduu (inname, outname);\n\n  if (  (rval == UUDECODE_EXIT_SUCCESS)\n     && (ferror(stdout) || fflush(stdout) != 0))\n    {\n      error (0, 0, _(\"%s: Write error\"), outname);\n      rval = UUDECODE_EXIT_NO_OUTPUT;\n    }\n\n fail_return:\n\n  if (allocated_outname)\n    free (outname);\n  return rval;\n}",
      "lines": 135,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "uudecode_exit_code_t"
      ]
    },
    "main": {
      "start_point": [
        505,
        0
      ],
      "end_point": [
        555,
        1
      ],
      "content": "int\nmain (int argc, char const * const * argv)\n{\n  uudecode_exit_code_t exit_status = UUDECODE_EXIT_SUCCESS;\n\n  setlocale (LC_ALL, \"\");\n\n  /* Set the text message domain.  */\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  {\n    int ct = optionProcess (&uudecodeOptions, argc, (char **)(void *)argv);\n    argc -= ct;\n    argv += ct;\n  }\n\n  switch (argc)\n    {\n    case 0:\n      exit_status = decode (_(\"standard input\"));\n      break;\n\n    default:\n      if (HAVE_OPT(OUTPUT_FILE))\n        {\n          usage_message(_(\"You cannot specify an output file when processing\\n\\\nmultiple input files.\\n\"));\n          /* NOTREACHED */\n        }\n      /* FALLTHROUGH */\n\n    case 1:\n      while (--argc >= 0)\n        {\n          char const * f = *(argv++);\n\n          if (freopen (f, \"r\", stdin) != NULL)\n            {\n              exit_status |= decode (f);\n            }\n          else\n            {\n              error (0, errno, \"%s\", f);\n              exit_status |= UUDECODE_EXIT_NO_INPUT;\n            }\n        }\n    }\n\n  exit (exit_status);\n}",
      "lines": 51,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/src/uuencode-opts.c": {
    "doUsageOpt": {
      "start_point": [
        363,
        0
      ],
      "end_point": [
        373,
        1
      ],
      "content": "static void\ndoUsageOpt(tOptions * opts, tOptDesc * od)\n{\n    int ex_code;\n    ex_code = UUENCODE_EXIT_SUCCESS;\n    optionUsage(&uuencodeOptions, ex_code);\n    /* NOTREACHED */\n    exit(1);\n    (void)opts;\n    (void)od;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "vusage_message": {
      "start_point": [
        385,
        0
      ],
      "end_point": [
        394,
        1
      ],
      "content": "void\nvusage_message(char const * fmt, va_list ap)\n{\n    char const * er_leader = _(\"uuencode usage error:\\n\");\n    fputs(er_leader, stderr);\n    vfprintf(stderr, fmt, ap);\n    optionUsage(&uuencodeOptions, UUENCODE_EXIT_USAGE_ERROR);\n    /* NOTREACHED */\n    exit(1);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "usage_message": {
      "start_point": [
        404,
        0
      ],
      "end_point": [
        412,
        1
      ],
      "content": "void\nusage_message(char const * fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    vusage_message(fmt, ap);\n    /* NOTREACHED */\n    va_end(ap);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "vdie": {
      "start_point": [
        422,
        0
      ],
      "end_point": [
        431,
        1
      ],
      "content": "void\nvdie(int exit_code, char const * fmt, va_list ap)\n{\n    char const * die_leader = _(\"uuencode fatal error:\\n\");\n    fputs(die_leader, stderr);\n    vfprintf(stderr, fmt, ap);\n    fflush(stderr);\n    exit(exit_code);\n    /* NOTREACHED */\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "die": {
      "start_point": [
        441,
        0
      ],
      "end_point": [
        449,
        1
      ],
      "content": "void\ndie(int exit_code, char const * fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    vdie(exit_code, fmt, ap);\n    /* NOTREACHED */\n    va_end(ap);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "fserr": {
      "start_point": [
        459,
        0
      ],
      "end_point": [
        465,
        1
      ],
      "content": "void\nfserr(int exit_code, char const * op, char const * fname)\n{\n    char const * fserr_fmt = _(\"fserr %d (%s) performing '%s' on %s\\n\");\n    die(exit_code, fserr_fmt, errno, strerror(errno), op, fname);\n    /* NOTREACHED */\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "AO_gettext": {
      "start_point": [
        562,
        0
      ],
      "end_point": [
        591,
        1
      ],
      "content": "static char *\nAO_gettext(char const * pz)\n{\n    char * res;\n    if (pz == NULL)\n        return NULL;\n#ifdef HAVE_DCGETTEXT\n    /*\n     * While processing the option_xlateable_txt data, try to use the\n     * \"libopts\" domain.  Once we switch to the option descriptor data,\n     * do *not* use that domain.\n     */\n    if (option_xlateable_txt.field_ct != 0) {\n        res = dgettext(\"libopts\", pz);\n        if (res == pz)\n            res = (char *)VOIDP(_(pz));\n    } else\n        res = (char *)VOIDP(_(pz));\n#else\n    res = (char *)VOIDP(_(pz));\n#endif\n    if (res == pz)\n        return res;\n    res = strdup(res);\n    if (res == NULL) {\n        fputs(_(\"No memory for duping translated strings\\n\"), stderr);\n        exit(UUENCODE_EXIT_FAILURE);\n    }\n    return res;\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nAO_gettext(char const * pz)",
        "*"
      ]
    },
    "coerce_it": {
      "start_point": [
        597,
        0
      ],
      "end_point": [
        598,
        1
      ],
      "content": "static void coerce_it(void ** s) { *s = AO_gettext(*s);\n}",
      "lines": 2,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "translate_option_strings": {
      "start_point": [
        604,
        0
      ],
      "end_point": [
        632,
        1
      ],
      "content": "static void\ntranslate_option_strings(void)\n{\n    tOptions * const opts = &uuencodeOptions;\n\n    /*\n     *  Guard against re-translation.  It won't work.  The strings will have\n     *  been changed by the first pass through this code.  One shot only.\n     */\n    if (option_xlateable_txt.field_ct != 0) {\n        /*\n         *  Do the translations.  The first pointer follows the field count\n         *  field.  The field count field is the size of a pointer.\n         */\n        char ** ppz = (char**)VOIDP(&(option_xlateable_txt));\n        int     ix  = option_xlateable_txt.field_ct;\n\n        do {\n            ppz++; /* skip over field_ct */\n            *ppz = AO_gettext(*ppz);\n        } while (--ix > 0);\n        /* prevent re-translation and disable \"libopts\" domain lookup */\n        option_xlateable_txt.field_ct = 0;\n\n        coerce_it(VOIDP(&(opts->pzCopyright)));\n        coerce_it(VOIDP(&(opts->pzCopyNotice)));\n        coerce_it(VOIDP(&(opts->pzFullVersion)));\n    }\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bogus_function": {
      "start_point": [
        637,
        0
      ],
      "end_point": [
        900,
        1
      ],
      "content": "static void bogus_function(void) {\n  /* TRANSLATORS:\n\n     The following dummy function was crated solely so that xgettext can\n     extract the correct strings.  These strings are actually referenced\n     by a field name in the uuencodeOptions structure noted in the\n     comments below.  The literal text is defined in uuencode_opt_strs.\n   \n     NOTE: the strings below are segmented with respect to the source string\n     uuencode_opt_strs.  The strings above are handed off for translation\n     at run time a paragraph at a time.  Consequently, they are presented here\n     for translation a paragraph at a time.\n   \n     ALSO: often the description for an option will reference another option\n     by name.  These are set off with apostrophe quotes (I hope).  Do not\n     translate option names.\n   */\n  /* referenced via uuencodeOptions.pzCopyright */\n  puts(_(\"uuencode (GNU sharutils) 4.15.2\\n\\\nCopyright (C) 1994-2015 Free Software Foundation, Inc., all rights reserved.\\n\\\nThis is free software. It is licensed for use, modification and\\n\\\nredistribution under the terms of the GNU General Public License,\\n\\\nversion 3 or later <http://gnu.org/licenses/gpl.html>\\n\"));\n\n  /* referenced via uuencodeOptions.pzCopyNotice */\n  puts(_(\"uuencode is free software: you can redistribute it and/or modify it under\\n\\\nthe terms of the GNU General Public License as published by the Free\\n\\\nSoftware Foundation, either version 3 of the License, or (at your option)\\n\\\nany later version.\\n\\n\"));\n  puts(_(\"uuencode is distributed in the hope that it will be useful, but WITHOUT ANY\\n\\\nWARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\\n\\\nFOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\\n\\\ndetails.\\n\\n\"));\n  puts(_(\"You should have received a copy of the GNU General Public License along\\n\\\nwith this program.  If not, see <http://www.gnu.org/licenses/>.\\n\"));\n\n  /* referenced via uuencodeOptions.pzUsageTitle */\n  puts(_(\"uuencode (GNU sharutils) - encode a file into email friendly text\\n\\\nUsage:  %s [ -<flag> | --<name> ]... [<in-file>] <output-name>\\n\"));\n\n  /* referenced via uuencodeOptions.pzDetail */\n  puts(_(\"'uuencode' is used to create an ASCII representation of a file that can be\\n\\\nsent over channels that may otherwise corrupt the data.  Specifically,\\n\\\nemail cannot handle binary data and will often even insert a character when\\n\\\nthe six character sequence \\\"\\\\nFrom \\\" is seen.\\n\\n\"));\n  puts(_(\"'uuencode' will read 'in-file' if provided and otherwise read data from\\n\\\nstandard in and write the encoded form to standard out.  The output will\\n\\\nbegin with a header line for use by 'uudecode' giving it the resulting\\n\\\nsuggested file 'output-name' and access mode.  If the 'output-name' is\\n\\\nspecifically '/dev/stdout', then 'uudecode' will emit the decoded file to\\n\\\nstandard out.\\n\\n\"));\n  puts(_(\"'Note': 'uuencode' uses buffered input and assumes that it is not hand\\n\\\ntyped from a tty.  The consequence is that at a tty, you may need to hit\\n\\\nCtl-D several times to terminate input.\\n\"));\n\n  /* referenced via uuencodeOptions.pzFullVersion */\n  puts(_(\"uuencode (GNU sharutils) 4.15.2\"));\n\n  /* referenced via uuencodeOptions.pzFullUsage */\n  puts(_(\"uuencode (GNU sharutils) - encode a file into email friendly text\\n\\\nUsage:  uuencode [ -<flag> | --<name> ]... [<in-file>] <output-name>\\n\\n\"));\n  puts(_(\"   -m, --base64               convert using base64\\n\"));\n  puts(_(\"   -e, --encode-file-name     encode the output file name\\n\"));\n  puts(_(\"   -v, --version[=MODE]       output version information and exit\\n\"));\n  puts(_(\"   -h, --help                 display extended usage information and exit\\n\"));\n  puts(_(\"   -!, --more-help            extended usage information passed thru pager\\n\"));\n  puts(_(\"   -R, --save-opts[=FILE]     save the option state to a config file FILE\\n\"));\n  puts(_(\"   -r, --load-opts=FILE       load options from the config file FILE\\n\\\n                                - disabled with '--no-load-opts'\\n\\\n                                - may appear multiple times\\n\\n\"));\n  puts(_(\"Options are specified by doubled hyphens and their name or by a single\\n\\\nhyphen and the flag character.\\n\\n\"));\n  puts(_(\"The following option preset mechanisms are supported:\\n\"));\n  puts(_(\" - reading file $HOME/.sharrc\\n\\n\\\n'uuencode' is used to create an ASCII representation of a file that can be\\n\\\nsent over channels that may otherwise corrupt the data.  Specifically,\\n\\\nemail cannot handle binary data and will often even insert a character when\\n\\\nthe six character sequence \\\"\\\\nFrom \\\" is seen.\\n\\n\"));\n  puts(_(\"'uuencode' will read 'in-file' if provided and otherwise read data from\\n\\\nstandard in and write the encoded form to standard out.  The output will\\n\\\nbegin with a header line for use by 'uudecode' giving it the resulting\\n\\\nsuggested file 'output-name' and access mode.  If the 'output-name' is\\n\\\nspecifically '/dev/stdout', then 'uudecode' will emit the decoded file to\\n\\\nstandard out.\\n\\n\"));\n  puts(_(\"'Note': 'uuencode' uses buffered input and assumes that it is not hand\\n\\\ntyped from a tty.  The consequence is that at a tty, you may need to hit\\n\\\nCtl-D several times to terminate input.\\n\\n\\\nPlease send bug reports to:  <bug-gnu-utils@gnu.org>\\n\"));\n\n  /* referenced via uuencodeOptions.pzShortUsage */\n  puts(_(\"uuencode (GNU sharutils) - encode a file into email friendly text\\n\\\nUsage:  uuencode [ -<flag> | --<name> ]... [<in-file>] <output-name>\\n\\\nTry 'uuencode --help' for more information.\\n\"));\n  /* LIBOPTS-MESSAGES: */\n#line 67 \"../autoopts.c\"\n  puts(_(\"allocation of %d bytes failed\\n\"));\n#line 93 \"../autoopts.c\"\n  puts(_(\"allocation of %d bytes failed\\n\"));\n#line 53 \"../init.c\"\n  puts(_(\"AutoOpts function called without option descriptor\\n\"));\n#line 86 \"../init.c\"\n  puts(_(\"\\tThis exceeds the compiled library version:  \"));\n#line 84 \"../init.c\"\n  puts(_(\"Automated Options Processing Error!\\n\"\n       \"\\t%s called AutoOpts function with structure version %d:%d:%d.\\n\"));\n#line 80 \"../autoopts.c\"\n  puts(_(\"realloc of %d bytes at 0x%p failed\\n\"));\n#line 88 \"../init.c\"\n  puts(_(\"\\tThis is less than the minimum library version:  \"));\n#line 121 \"../version.c\"\n  puts(_(\"Automated Options version %s\\n\"\n       \"\\tCopyright (C) 1999-2014 by Bruce Korb - all rights reserved\\n\"));\n#line 87 \"../makeshell.c\"\n  puts(_(\"(AutoOpts bug):  %s.\\n\"));\n#line 90 \"../reset.c\"\n  puts(_(\"optionResetOpt() called, but reset-option not configured\"));\n#line 292 \"../usage.c\"\n  puts(_(\"could not locate the 'help' option\"));\n#line 336 \"../autoopts.c\"\n  puts(_(\"optionProcess() was called with invalid data\"));\n#line 748 \"../usage.c\"\n  puts(_(\"invalid argument type specified\"));\n#line 598 \"../find.c\"\n  puts(_(\"defaulted to option with optional arg\"));\n#line 76 \"../alias.c\"\n  puts(_(\"aliasing option is out of range.\"));\n#line 234 \"../enum.c\"\n  puts(_(\"%s error:  the keyword '%s' is ambiguous for %s\\n\"));\n#line 108 \"../find.c\"\n  puts(_(\"  The following options match:\\n\"));\n#line 293 \"../find.c\"\n  puts(_(\"%s: ambiguous option name: %s (matches %d options)\\n\"));\n#line 161 \"../check.c\"\n  puts(_(\"%s: Command line arguments required\\n\"));\n#line 43 \"../alias.c\"\n  puts(_(\"%d %s%s options allowed\\n\"));\n#line 94 \"../makeshell.c\"\n  puts(_(\"%s error %d (%s) calling %s for '%s'\\n\"));\n#line 306 \"../makeshell.c\"\n  puts(_(\"interprocess pipe\"));\n#line 168 \"../version.c\"\n  puts(_(\"error: version option argument '%c' invalid.  Use:\\n\"\n       \"\\t'v' - version only\\n\"\n       \"\\t'c' - version and copyright\\n\"\n       \"\\t'n' - version and full copyright notice\\n\"));\n#line 58 \"../check.c\"\n  puts(_(\"%s error:  the '%s' and '%s' options conflict\\n\"));\n#line 217 \"../find.c\"\n  puts(_(\"%s: The '%s' option has been disabled.\"));\n#line 430 \"../find.c\"\n  puts(_(\"%s: The '%s' option has been disabled.\"));\n#line 38 \"../alias.c\"\n  puts(_(\"-equivalence\"));\n#line 469 \"../find.c\"\n  puts(_(\"%s: illegal option -- %c\\n\"));\n#line 110 \"../reset.c\"\n  puts(_(\"%s: illegal option -- %c\\n\"));\n#line 271 \"../find.c\"\n  puts(_(\"%s: illegal option -- %s\\n\"));\n#line 755 \"../find.c\"\n  puts(_(\"%s: illegal option -- %s\\n\"));\n#line 118 \"../reset.c\"\n  puts(_(\"%s: illegal option -- %s\\n\"));\n#line 335 \"../find.c\"\n  puts(_(\"%s: unknown vendor extension option -- %s\\n\"));\n#line 159 \"../enum.c\"\n  puts(_(\"  or an integer from %d through %d\\n\"));\n#line 169 \"../enum.c\"\n  puts(_(\"  or an integer from %d through %d\\n\"));\n#line 747 \"../usage.c\"\n  puts(_(\"%s error:  invalid option descriptor for %s\\n\"));\n#line 1081 \"../usage.c\"\n  puts(_(\"%s error:  invalid option descriptor for %s\\n\"));\n#line 385 \"../find.c\"\n  puts(_(\"%s: invalid option name: %s\\n\"));\n#line 527 \"../find.c\"\n  puts(_(\"%s: The '%s' option requires an argument.\\n\"));\n#line 156 \"../autoopts.c\"\n  puts(_(\"(AutoOpts bug):  Equivalenced option '%s' was equivalenced to both\\n\"\n       \"\\t'%s' and '%s'.\"));\n#line 94 \"../check.c\"\n  puts(_(\"%s error:  The %s option is required\\n\"));\n#line 632 \"../find.c\"\n  puts(_(\"%s: The '%s' option cannot have an argument.\\n\"));\n#line 151 \"../check.c\"\n  puts(_(\"%s: Command line arguments are not allowed.\\n\"));\n#line 535 \"../save.c\"\n  puts(_(\"error %d (%s) creating %s\\n\"));\n#line 234 \"../enum.c\"\n  puts(_(\"%s error:  '%s' does not match any %s keywords.\\n\"));\n#line 93 \"../reset.c\"\n  puts(_(\"%s error: The '%s' option requires an argument.\\n\"));\n#line 184 \"../save.c\"\n  puts(_(\"error %d (%s) stat-ing %s\\n\"));\n#line 238 \"../save.c\"\n  puts(_(\"error %d (%s) stat-ing %s\\n\"));\n#line 143 \"../restore.c\"\n  puts(_(\"%s error: no saved option state\\n\"));\n#line 231 \"../autoopts.c\"\n  puts(_(\"'%s' is not a command line option.\\n\"));\n#line 111 \"../time.c\"\n  puts(_(\"%s error:  '%s' is not a recognizable date/time.\\n\"));\n#line 132 \"../save.c\"\n  puts(_(\"'%s' not defined\\n\"));\n#line 50 \"../time.c\"\n  puts(_(\"%s error:  '%s' is not a recognizable time duration.\\n\"));\n#line 92 \"../check.c\"\n  puts(_(\"%s error:  The %s option must appear %d times.\\n\"));\n#line 164 \"../numeric.c\"\n  puts(_(\"%s error:  '%s' is not a recognizable number.\\n\"));\n#line 200 \"../enum.c\"\n  puts(_(\"%s error:  %s exceeds %s keyword count\\n\"));\n#line 330 \"../usage.c\"\n  puts(_(\"Try '%s %s' for more information.\\n\"));\n#line 45 \"../alias.c\"\n  puts(_(\"one %s%s option allowed\\n\"));\n#line 208 \"../makeshell.c\"\n  puts(_(\"standard output\"));\n#line 943 \"../makeshell.c\"\n  puts(_(\"standard output\"));\n#line 274 \"../usage.c\"\n  puts(_(\"standard output\"));\n#line 415 \"../usage.c\"\n  puts(_(\"standard output\"));\n#line 625 \"../usage.c\"\n  puts(_(\"standard output\"));\n#line 175 \"../version.c\"\n  puts(_(\"standard output\"));\n#line 274 \"../usage.c\"\n  puts(_(\"standard error\"));\n#line 415 \"../usage.c\"\n  puts(_(\"standard error\"));\n#line 625 \"../usage.c\"\n  puts(_(\"standard error\"));\n#line 175 \"../version.c\"\n  puts(_(\"standard error\"));\n#line 208 \"../makeshell.c\"\n  puts(_(\"write\"));\n#line 943 \"../makeshell.c\"\n  puts(_(\"write\"));\n#line 273 \"../usage.c\"\n  puts(_(\"write\"));\n#line 414 \"../usage.c\"\n  puts(_(\"write\"));\n#line 624 \"../usage.c\"\n  puts(_(\"write\"));\n#line 174 \"../version.c\"\n  puts(_(\"write\"));\n#line 60 \"../numeric.c\"\n  puts(_(\"%s error:  %s option value %ld is out of range.\\n\"));\n#line 44 \"../check.c\"\n  puts(_(\"%s error:  %s option requires the %s option\\n\"));\n#line 131 \"../save.c\"\n  puts(_(\"%s warning:  cannot save options - %s not regular file\\n\"));\n#line 183 \"../save.c\"\n  puts(_(\"%s warning:  cannot save options - %s not regular file\\n\"));\n#line 237 \"../save.c\"\n  puts(_(\"%s warning:  cannot save options - %s not regular file\\n\"));\n#line 256 \"../save.c\"\n  puts(_(\"%s warning:  cannot save options - %s not regular file\\n\"));\n#line 534 \"../save.c\"\n  puts(_(\"%s warning:  cannot save options - %s not regular file\\n\"));\n  /* END-LIBOPTS-MESSAGES */\n}",
      "lines": 264,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/src/uuencode-opts.h": {
    "aoGetsText": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "static inline char* aoGetsText(char const* pz) {\n    if (pz == NULL) return NULL;\n    return (char*)gettext(pz);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "char",
        "* aoGetsText(char const* pz)",
        "*"
      ]
    }
  },
  "sharutils/sharutils-4.15.2/src/uuencode.c": {
    "try_putchar": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static inline void\ntry_putchar (int c)\n{\n  if (putchar (c) == EOF)\n    fserr (UUENCODE_EXIT_FAILURE, \"putchar\", _(\"standard output\"));\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "encode_block": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "static size_t\nencode_block (char * out, unsigned char const * in, size_t in_len)\n{\n  char * start = out;\n\n  while (in_len >= 3)\n    {\n      *(out++) = ENC (in[0] >> 2);\n      *(out++) = ENC (((in[0] & 0x03) << 4) + ((in[1] >> 4) & 0x0F));\n      *(out++) = ENC (((in[1] & 0x0F) << 2) + ((in[2] >> 6) & 0x03));\n      *(out++) = ENC (in[2] & 0x3F);\n      in_len -= 3;\n      in += 3;\n    }\n\n  if (in_len > 0)\n    {\n      unsigned char lc = (in_len > 1) ? in[1] : '\\0';\n      *(out++) = ENC (in[0] >> 2);\n      *(out++) = ENC (((in[0] & 0x03) << 4) + ((lc >> 4) & 0x0F));\n      *(out++) = ENC ((lc & 0x0F) << 2);\n      *(out++) = ENC (0);\n    }\n\n  return out - start;\n}",
      "lines": 26,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "encode": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "static void\nencode (void)\n{\n  int finishing = 0;\n\n  do\n    {\n      unsigned char buf[45];\n      char   buf_out[64];\n      int    rdct = fread (buf, 1, sizeof(buf), stdin);\n      size_t wrct = sizeof (buf_out);\n\n      if (rdct <= 0)\n        {\n          if (ferror (stdin))\n            fserr (UUENCODE_EXIT_FAILURE, \"fread\", input_name);\n          break;\n        }\n\n      if (rdct < 45)\n        {\n          if (! feof (stdin))\n            fserr (UUENCODE_EXIT_FAILURE, \"fread\", input_name);\n          finishing = 1;\n        }\n\n      if (! HAVE_OPT(BASE64))\n        {\n          try_putchar (ENC ((unsigned int)rdct));\n          wrct = encode_block (buf_out, buf, rdct);\n        }\n      else\n        {\n          base64_encode ((char *)buf, (size_t)rdct, buf_out, wrct);\n          wrct = strlen(buf_out);\n        }\n\n      buf_out[wrct++] = '\\n';\n      if (fwrite (buf_out, 1, wrct, stdout) != wrct)\n        fserr (UUENCODE_EXIT_FAILURE, \"fwrite\", _(\"standard output\"));\n    } while (! finishing);\n\n  if (fclose (stdin) != 0)\n    fserr (UUENCODE_EXIT_FAILURE, \"fclose\", input_name);\n\n  if (! HAVE_OPT(BASE64))\n    {\n      try_putchar (ENC ('\\0'));\n      try_putchar ('\\n');\n    }\n}",
      "lines": 51,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "process_opts": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        260,
        1
      ],
      "content": "static void\nprocess_opts (int argc, char ** argv, int * mode)\n{\n  /* Set global variables.  */\n  setlocale (LC_ALL, \"\");\n\n  /* Set the text message domain.  */\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  input_name = _(\"standard input\");\n\n  {\n    int ct = optionProcess (&uuencodeOptions, argc, argv);\n    argc -= ct;\n    argv += ct;\n  }\n\n  switch (argc)\n    {\n    case 2:\n      /* Optional first argument is input file.  */\n      {\n        struct stat sb;\n#if S_IRWXU != 0700\n        choke me - Must translate mode argument\n#endif\n\n\tFILE * fp = freopen (*argv, \"r\" FOPEN_BINARY, stdin);\n        input_name = *argv;\n\tif (fp != stdin)\n          fserr (UUENCODE_EXIT_FAILURE, _(\"freopen of stdin\"), input_name);\n\tif (fstat (fileno (stdin), &sb) != 0)\n          fserr (UUENCODE_EXIT_FAILURE, \"fstat\", input_name);\n\t*mode = sb.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO);\n        output_name = argv[1];\n\tbreak;\n      }\n\n    case 1:\n#if __CYGWIN__ || __MINGW32__\n      if (! isatty (STDIN_FILENO))\n       setmode (STDIN_FILENO, O_BINARY);\n#endif\n\n      *mode = IRWALL_MODE & ~umask (IRWALL_MODE);\n      output_name = *argv;\n      break;\n\n    case 0:\n    default:\n      USAGE (UUENCODE_EXIT_USAGE_ERROR);\n    }\n\n  if (HAVE_OPT(ENCODE_FILE_NAME))\n    {\n      size_t nmlen = strlen (output_name);\n      size_t bfsz  = nmlen + (nmlen / 3) + 4;;\n      char * p = malloc (bfsz);\n      if (p == NULL)\n        fserr (UUENCODE_EXIT_FAILURE, \"malloc\", _(\"file name\"));\n      base64_encode ((char *)output_name, nmlen, p, bfsz);\n      output_name = p;\n    }\n}",
      "lines": 65,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        262,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "int\nmain (int argc, char ** argv)\n{\n  int mode;\n  process_opts (argc, argv, &mode);\n\n  if (printf (\"begin%s%s %o %s\\n\",\n              HAVE_OPT(BASE64) ? \"-base64\" : \"\",\n              HAVE_OPT(ENCODE_FILE_NAME) ? \"-encoded\" : \"\",\n\t      mode, output_name) < 0)\n    fserr (UUENCODE_EXIT_FAILURE, \"printf\", _(\"standard output\"));\n\n  encode ();\n\n  if (ferror (stdout))\n    fserr (UUENCODE_EXIT_FAILURE, \"ferror\", _(\"standard output\"));\n  if (puts (HAVE_OPT(BASE64) ? \"====\" : \"end\") == EOF)\n    fserr (UUENCODE_EXIT_FAILURE, \"puts\", _(\"standard output\"));\n  if (fclose (stdout) != 0)\n    fserr (UUENCODE_EXIT_FAILURE, \"fclose\", _(\"standard output\"));\n\n  exit (UUENCODE_EXIT_SUCCESS);\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  }
}