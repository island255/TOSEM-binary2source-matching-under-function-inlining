{
  "libunistring/libunistring-0.9.10/lib/alloca.in.h": {},
  "libunistring/libunistring-0.9.10/lib/amemxfrm.c": {
    "amemxfrm": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "char *\namemxfrm (char *s, size_t n, char *resultbuf, size_t *lengthp)\n{\n  /* Result accumulator.  */\n  char *result;\n  size_t length;\n  size_t allocated;\n\n  char orig_sentinel;\n\n  /* Initial memory allocation.  */\n  if (resultbuf != NULL && *lengthp > 0)\n    {\n      result = resultbuf;\n      allocated = *lengthp;\n    }\n  else\n    {\n      allocated = (n > 0 ? n : 1);\n      result = (char *) malloc (allocated);\n      if (result == NULL)\n        goto out_of_memory_2;\n    }\n  length = 0;\n\n  /* Add sentinel.byte.  */\n  orig_sentinel = s[n];\n  s[n] = '\\0';\n\n  /* Iterate through S, transforming each NUL terminated segment.\n     Accumulate the resulting transformed segments in result, separated by\n     NULs.  */\n  {\n    const char *p_end = s + n + 1;\n    const char *p;\n\n    p = s;\n    for (;;)\n      {\n        /* Search next NUL byte.  */\n        size_t l = strlen (p);\n\n        for (;;)\n          {\n            size_t k;\n\n            /* A call to strxfrm costs about 20 times more than a call to\n               strdup of the result.  Therefore it is worth to try to avoid\n               calling strxfrm more than once on a given string, by making\n               enough room before calling strxfrm.\n               The size of the strxfrm result, k, is likely to be between\n               l and 3 * l.  */\n            if (3 * l >= allocated - length)\n              {\n                /* Grow the result buffer.  */\n                size_t new_allocated;\n                char *new_result;\n\n                new_allocated = length + 3 * l + 1;\n                if (new_allocated < 2 * allocated)\n                  new_allocated = 2 * allocated;\n                if (new_allocated < 64)\n                  new_allocated = 64;\n                if (result == resultbuf)\n                  new_result = (char *) malloc (new_allocated);\n                else\n                  new_result = (char *) realloc (result, new_allocated);\n                if (new_result != NULL)\n                  {\n                    allocated = new_allocated;\n                    result = new_result;\n                  }\n              }\n\n            errno = 0;\n            k = strxfrm (result + length, p, allocated - length);\n            if (errno != 0)\n              goto fail;\n            if (k >= allocated - length)\n              {\n                /* Grow the result buffer.  */\n                size_t new_allocated;\n                char *new_result;\n\n                new_allocated = length + k + 1;\n                if (new_allocated < 2 * allocated)\n                  new_allocated = 2 * allocated;\n                if (new_allocated < 64)\n                  new_allocated = 64;\n                if (result == resultbuf)\n                  new_result = (char *) malloc (new_allocated);\n                else\n                  new_result = (char *) realloc (result, new_allocated);\n                if (new_result == NULL)\n                  goto out_of_memory_1;\n                allocated = new_allocated;\n                result = new_result;\n              }\n            else\n              {\n                length += k;\n                break;\n              }\n          }\n\n        p = p + l + 1;\n        if (p == p_end)\n          break;\n        result[length] = '\\0';\n        length++;\n      }\n  }\n\n  /* Shrink the allocated memory if possible.\n     It is not worth calling realloc when length + 1 == allocated; it would\n     save just one byte.  */\n  if (result != resultbuf && length + 1 < allocated)\n    {\n      if ((length > 0 ? length : 1) <= *lengthp)\n        {\n          memcpy (resultbuf, result, length);\n          free (result);\n          result = resultbuf;\n        }\n      else\n        {\n          char *memory = (char *) realloc (result, length > 0 ? length : 1);\n          if (memory != NULL)\n            result = memory;\n        }\n    }\n\n  s[n] = orig_sentinel;\n  *lengthp = length;\n  return result;\n\n fail:\n  {\n    int saved_errno = errno;\n    if (result != resultbuf)\n      free (result);\n    s[n] = orig_sentinel;\n    errno = saved_errno;\n    return NULL;\n  }\n\n out_of_memory_1:\n  if (result != resultbuf)\n    free (result);\n  s[n] = orig_sentinel;\n out_of_memory_2:\n  errno = ENOMEM;\n  return NULL;\n}",
      "lines": 154,
      "depth": 16,
      "decorators": [
        "char",
        "*\namemxfrm (char *s, size_t n, char *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/amemxfrm.h": {},
  "libunistring/libunistring-0.9.10/lib/arg-nonnull.h": {},
  "libunistring/libunistring-0.9.10/lib/array-mergesort.h": {
    "merge": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static void\nmerge (const ELEMENT *src1, size_t n1,\n       const ELEMENT *src2, size_t n2,\n       ELEMENT *dst)\n{\n  for (;;) /* while (n1 > 0 && n2 > 0) */\n    {\n      if (COMPARE (src1, src2) <= 0)\n        {\n          *dst++ = *src1++;\n          n1--;\n          if (n1 == 0)\n            break;\n        }\n      else\n        {\n          *dst++ = *src2++;\n          n2--;\n          if (n2 == 0)\n            break;\n        }\n    }\n  /* Here n1 == 0 || n2 == 0 but also n1 > 0 || n2 > 0.  */\n  if (n1 > 0)\n    {\n      if (dst != src1)\n        do\n          {\n            *dst++ = *src1++;\n            n1--;\n          }\n        while (n1 > 0);\n    }\n  else /* n2 > 0 */\n    {\n      if (dst != src2)\n        do\n          {\n            *dst++ = *src2++;\n            n2--;\n          }\n        while (n2 > 0);\n    }\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "merge_sort_fromto": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "STATIC void\nmerge_sort_fromto (const ELEMENT *src, ELEMENT *dst, size_t n, ELEMENT *tmp)\n{\n  switch (n)\n    {\n    case 0:\n      return;\n    case 1:\n      /* Nothing to do.  */\n      dst[0] = src[0];\n      return;\n    case 2:\n      /* Trivial case.  */\n      if (COMPARE (&src[0], &src[1]) <= 0)\n        {\n          /* src[0] <= src[1] */\n          dst[0] = src[0];\n          dst[1] = src[1];\n        }\n      else\n        {\n          dst[0] = src[1];\n          dst[1] = src[0];\n        }\n      break;\n    case 3:\n      /* Simple case.  */\n      if (COMPARE (&src[0], &src[1]) <= 0)\n        {\n          if (COMPARE (&src[1], &src[2]) <= 0)\n            {\n              /* src[0] <= src[1] <= src[2] */\n              dst[0] = src[0];\n              dst[1] = src[1];\n              dst[2] = src[2];\n            }\n          else if (COMPARE (&src[0], &src[2]) <= 0)\n            {\n              /* src[0] <= src[2] < src[1] */\n              dst[0] = src[0];\n              dst[1] = src[2];\n              dst[2] = src[1];\n            }\n          else\n            {\n              /* src[2] < src[0] <= src[1] */\n              dst[0] = src[2];\n              dst[1] = src[0];\n              dst[2] = src[1];\n            }\n        }\n      else\n        {\n          if (COMPARE (&src[0], &src[2]) <= 0)\n            {\n              /* src[1] < src[0] <= src[2] */\n              dst[0] = src[1];\n              dst[1] = src[0];\n              dst[2] = src[2];\n            }\n          else if (COMPARE (&src[1], &src[2]) <= 0)\n            {\n              /* src[1] <= src[2] < src[0] */\n              dst[0] = src[1];\n              dst[1] = src[2];\n              dst[2] = src[0];\n            }\n          else\n            {\n              /* src[2] < src[1] < src[0] */\n              dst[0] = src[2];\n              dst[1] = src[1];\n              dst[2] = src[0];\n            }\n        }\n      break;\n    default:\n      {\n        size_t n1 = n / 2;\n        size_t n2 = (n + 1) / 2;\n        /* Note: n1 + n2 = n, n1 <= n2.  */\n        /* Sort src[n1..n-1] into dst[n1..n-1], scratching tmp[0..n2/2-1].  */\n        merge_sort_fromto (src + n1, dst + n1, n2, tmp);\n        /* Sort src[0..n1-1] into tmp[0..n1-1], scratching dst[0..n1-1].  */\n        merge_sort_fromto (src, tmp, n1, dst);\n        /* Merge the two half results.  */\n        merge (tmp, n1, dst + n1, n2, dst);\n      }\n      break;\n    }\n}",
      "lines": 91,
      "depth": 16,
      "decorators": [
        "STATIC",
        "void",
        "void"
      ]
    },
    "merge_sort_inplace": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        278,
        1
      ],
      "content": "STATIC void\nmerge_sort_inplace (ELEMENT *src, size_t n, ELEMENT *tmp)\n{\n  switch (n)\n    {\n    case 0:\n    case 1:\n      /* Nothing to do.  */\n      return;\n    case 2:\n      /* Trivial case.  */\n      if (COMPARE (&src[0], &src[1]) <= 0)\n        {\n          /* src[0] <= src[1] */\n        }\n      else\n        {\n          ELEMENT t = src[0];\n          src[0] = src[1];\n          src[1] = t;\n        }\n      break;\n    case 3:\n      /* Simple case.  */\n      if (COMPARE (&src[0], &src[1]) <= 0)\n        {\n          if (COMPARE (&src[1], &src[2]) <= 0)\n            {\n              /* src[0] <= src[1] <= src[2] */\n            }\n          else if (COMPARE (&src[0], &src[2]) <= 0)\n            {\n              /* src[0] <= src[2] < src[1] */\n              ELEMENT t = src[1];\n              src[1] = src[2];\n              src[2] = t;\n            }\n          else\n            {\n              /* src[2] < src[0] <= src[1] */\n              ELEMENT t = src[0];\n              src[0] = src[2];\n              src[2] = src[1];\n              src[1] = t;\n            }\n        }\n      else\n        {\n          if (COMPARE (&src[0], &src[2]) <= 0)\n            {\n              /* src[1] < src[0] <= src[2] */\n              ELEMENT t = src[0];\n              src[0] = src[1];\n              src[1] = t;\n            }\n          else if (COMPARE (&src[1], &src[2]) <= 0)\n            {\n              /* src[1] <= src[2] < src[0] */\n              ELEMENT t = src[0];\n              src[0] = src[1];\n              src[1] = src[2];\n              src[2] = t;\n            }\n          else\n            {\n              /* src[2] < src[1] < src[0] */\n              ELEMENT t = src[0];\n              src[0] = src[2];\n              src[2] = t;\n            }\n        }\n      break;\n    default:\n      {\n        size_t n1 = n / 2;\n        size_t n2 = (n + 1) / 2;\n        /* Note: n1 + n2 = n, n1 <= n2.  */\n        /* Sort src[n1..n-1], scratching tmp[0..n2-1].  */\n        merge_sort_inplace (src + n1, n2, tmp);\n        /* Sort src[0..n1-1] into tmp[0..n1-1], scratching tmp[n1..2*n1-1].  */\n        merge_sort_fromto (src, tmp, n1, tmp + n1);\n        /* Merge the two half results.  */\n        merge (tmp, n1, src + n1, n2, src);\n      }\n      break;\n    }\n}",
      "lines": 87,
      "depth": 16,
      "decorators": [
        "STATIC",
        "void",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/c++defs.h": {},
  "libunistring/libunistring-0.9.10/lib/c-ctype.c": {},
  "libunistring/libunistring-0.9.10/lib/c-ctype.h": {
    "c_isalnum": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isalnum (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isalpha": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isalpha (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_LOWER:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isascii": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isascii (int c)\n{\n  switch (c)\n    {\n    case ' ':\n    _C_CTYPE_CNTRL:\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_PUNCT:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isblank": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isblank (int c)\n{\n  return c == ' ' || c == '\\t';\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_iscntrl": {
      "start_point": [
        228,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_iscntrl (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_CNTRL:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isdigit": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        250,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isdigit (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isgraph": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        265,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isgraph (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_PUNCT:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_islower": {
      "start_point": [
        267,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_islower (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_LOWER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isprint": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        293,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isprint (int c)\n{\n  switch (c)\n    {\n    case ' ':\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_PUNCT:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_ispunct": {
      "start_point": [
        295,
        0
      ],
      "end_point": [
        305,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_ispunct (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_PUNCT:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isspace": {
      "start_point": [
        307,
        0
      ],
      "end_point": [
        317,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isspace (int c)\n{\n  switch (c)\n    {\n    case ' ': case '\\t': case '\\n': case '\\v': case '\\f': case '\\r':\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isupper": {
      "start_point": [
        319,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isupper (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isxdigit": {
      "start_point": [
        331,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isxdigit (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_A_THRU_F:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_tolower": {
      "start_point": [
        344,
        0
      ],
      "end_point": [
        354,
        1
      ],
      "content": "C_CTYPE_INLINE int\nc_tolower (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_UPPER:\n      return c - 'A' + 'a';\n    default:\n      return c;\n    }\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "C_CTYPE_INLINE",
        "int",
        "int"
      ]
    },
    "c_toupper": {
      "start_point": [
        356,
        0
      ],
      "end_point": [
        366,
        1
      ],
      "content": "C_CTYPE_INLINE int\nc_toupper (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_LOWER:\n      return c - 'a' + 'A';\n    default:\n      return c;\n    }\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "C_CTYPE_INLINE",
        "int",
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/c-strcase.h": {},
  "libunistring/libunistring-0.9.10/lib/c-strcasecmp.c": {
    "c_strcasecmp": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\nc_strcasecmp (const char *s1, const char *s2)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2)\n    return 0;\n\n  do\n    {\n      c1 = c_tolower (*p1);\n      c2 = c_tolower (*p2);\n\n      if (c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/c-strcaseeq.h": {
    "strcaseeq9": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static inline int\nstrcaseeq9 (const char *s1, const char *s2)\n{\n  return c_strcasecmp (s1 + 9, s2 + 9) == 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq8": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static inline int\nstrcaseeq8 (const char *s1, const char *s2, char s28)\n{\n  if (CASEEQ (s1[8], s28))\n    {\n      if (s28 == 0)\n        return 1;\n      else\n        return strcaseeq9 (s1, s2);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq7": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static inline int\nstrcaseeq7 (const char *s1, const char *s2, char s27, char s28)\n{\n  if (CASEEQ (s1[7], s27))\n    {\n      if (s27 == 0)\n        return 1;\n      else\n        return strcaseeq8 (s1, s2, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq6": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "static inline int\nstrcaseeq6 (const char *s1, const char *s2, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[6], s26))\n    {\n      if (s26 == 0)\n        return 1;\n      else\n        return strcaseeq7 (s1, s2, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq5": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "static inline int\nstrcaseeq5 (const char *s1, const char *s2, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[5], s25))\n    {\n      if (s25 == 0)\n        return 1;\n      else\n        return strcaseeq6 (s1, s2, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq4": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "static inline int\nstrcaseeq4 (const char *s1, const char *s2, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[4], s24))\n    {\n      if (s24 == 0)\n        return 1;\n      else\n        return strcaseeq5 (s1, s2, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq3": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "static inline int\nstrcaseeq3 (const char *s1, const char *s2, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[3], s23))\n    {\n      if (s23 == 0)\n        return 1;\n      else\n        return strcaseeq4 (s1, s2, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq2": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "static inline int\nstrcaseeq2 (const char *s1, const char *s2, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[2], s22))\n    {\n      if (s22 == 0)\n        return 1;\n      else\n        return strcaseeq3 (s1, s2, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq1": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "static inline int\nstrcaseeq1 (const char *s1, const char *s2, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[1], s21))\n    {\n      if (s21 == 0)\n        return 1;\n      else\n        return strcaseeq2 (s1, s2, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq0": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "static inline int\nstrcaseeq0 (const char *s1, const char *s2, char s20, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[0], s20))\n    {\n      if (s20 == 0)\n        return 1;\n      else\n        return strcaseeq1 (s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/c-strncasecmp.c": {
    "c_strncasecmp": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\nc_strncasecmp (const char *s1, const char *s2, size_t n)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2 || n == 0)\n    return 0;\n\n  do\n    {\n      c1 = c_tolower (*p1);\n      c2 = c_tolower (*p2);\n\n      if (--n == 0 || c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/errno.in.h": {},
  "libunistring/libunistring-0.9.10/lib/flexmember.h": {},
  "libunistring/libunistring-0.9.10/lib/float+.h": {},
  "libunistring/libunistring-0.9.10/lib/float.c": {},
  "libunistring/libunistring-0.9.10/lib/float.in.h": {},
  "libunistring/libunistring-0.9.10/lib/fpucw.h": {},
  "libunistring/libunistring-0.9.10/lib/frexp.c": {
    "FUNC": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "DOUBLE\nFUNC (DOUBLE x, int *expptr)\n{\n  int sign;\n  int exponent;\n  DECL_ROUNDING\n\n  /* Test for NaN, infinity, and zero.  */\n  if (ISNAN (x) || x + x == x)\n    {\n      *expptr = 0;\n      return x;\n    }\n\n  sign = 0;\n  if (x < 0)\n    {\n      x = - x;\n      sign = -1;\n    }\n\n  BEGIN_ROUNDING ();\n\n  {\n    /* Since the exponent is an 'int', it fits in 64 bits.  Therefore the\n       loops are executed no more than 64 times.  */\n    DOUBLE pow2[64]; /* pow2[i] = 2^2^i */\n    DOUBLE powh[64]; /* powh[i] = 2^-2^i */\n    int i;\n\n    exponent = 0;\n    if (x >= L_(1.0))\n      {\n        /* A positive exponent.  */\n        DOUBLE pow2_i; /* = pow2[i] */\n        DOUBLE powh_i; /* = powh[i] */\n\n        /* Invariants: pow2_i = 2^2^i, powh_i = 2^-2^i,\n           x * 2^exponent = argument, x >= 1.0.  */\n        for (i = 0, pow2_i = L_(2.0), powh_i = L_(0.5);\n             ;\n             i++, pow2_i = pow2_i * pow2_i, powh_i = powh_i * powh_i)\n          {\n            if (x >= pow2_i)\n              {\n                exponent += (1 << i);\n                x *= powh_i;\n              }\n            else\n              break;\n\n            pow2[i] = pow2_i;\n            powh[i] = powh_i;\n          }\n        /* Avoid making x too small, as it could become a denormalized\n           number and thus lose precision.  */\n        while (i > 0 && x < pow2[i - 1])\n          {\n            i--;\n            powh_i = powh[i];\n          }\n        exponent += (1 << i);\n        x *= powh_i;\n        /* Here 2^-2^i <= x < 1.0.  */\n      }\n    else\n      {\n        /* A negative or zero exponent.  */\n        DOUBLE pow2_i; /* = pow2[i] */\n        DOUBLE powh_i; /* = powh[i] */\n\n        /* Invariants: pow2_i = 2^2^i, powh_i = 2^-2^i,\n           x * 2^exponent = argument, x < 1.0.  */\n        for (i = 0, pow2_i = L_(2.0), powh_i = L_(0.5);\n             ;\n             i++, pow2_i = pow2_i * pow2_i, powh_i = powh_i * powh_i)\n          {\n            if (x < powh_i)\n              {\n                exponent -= (1 << i);\n                x *= pow2_i;\n              }\n            else\n              break;\n\n            pow2[i] = pow2_i;\n            powh[i] = powh_i;\n          }\n        /* Here 2^-2^i <= x < 1.0.  */\n      }\n\n    /* Invariants: x * 2^exponent = argument, and 2^-2^i <= x < 1.0.  */\n    while (i > 0)\n      {\n        i--;\n        if (x < powh[i])\n          {\n            exponent -= (1 << i);\n            x *= pow2[i];\n          }\n      }\n    /* Here 0.5 <= x < 1.0.  */\n  }\n\n  if (sign < 0)\n    x = - x;\n\n  END_ROUNDING ();\n\n  *expptr = exponent;\n  return x;\n}",
      "lines": 112,
      "depth": 14,
      "decorators": [
        "DOUBLE"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/frexpl.c": {
    "frexpl": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "long double\nfrexpl (long double x, int *expptr)\n{\n  return frexp (x, expptr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "long double",
        "long",
        "double"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/fseterr.c": {
    "fseterr": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "void\nfseterr (FILE *fp)\n{\n  /* Most systems provide FILE as a struct and the necessary bitmask in\n     <stdio.h>, because they need it for implementing getc() and putc() as\n     fast macros.  */\n#if defined _IO_EOF_SEEN || defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1\n  /* GNU libc, BeOS, Haiku, Linux libc5 */\n  fp->_flags |= _IO_ERR_SEEN;\n#elif defined __sferror || defined __DragonFly__ || defined __ANDROID__\n  /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Minix 3, Android */\n  fp_->_flags |= __SERR;\n#elif defined __EMX__               /* emx+gcc */\n  fp->_flags |= _IOERR;\n#elif defined __minix               /* Minix */\n  fp->_flags |= _IOERR;\n#elif defined _IOERR                /* AIX, HP-UX, IRIX, OSF/1, Solaris, OpenServer, mingw, MSVC, NonStop Kernel, OpenVMS */\n  fp_->_flag |= _IOERR;\n#elif defined __UCLIBC__            /* uClibc */\n  fp->__modeflags |= __FLAG_ERROR;\n#elif defined __QNX__               /* QNX */\n  fp->_Mode |= 0x200 /* _MERR */;\n#elif defined __MINT__              /* Atari FreeMiNT */\n  fp->__error = 1;\n#elif defined EPLAN9                /* Plan9 */\n  if (fp->state != 0 /* CLOSED */)\n    fp->state = 5 /* ERR */;\n#elif 0                             /* unknown  */\n  /* Portable fallback, based on an idea by Rich Felker.\n     Wow! 6 system calls for something that is just a bit operation!\n     Not activated on any system, because there is no way to repair FP when\n     the sequence of system calls fails, and library code should not call\n     abort().  */\n  int saved_errno;\n  int fd;\n  int fd2;\n\n  saved_errno = errno;\n  fflush (fp);\n  fd = fileno (fp);\n  fd2 = dup (fd);\n  if (fd2 >= 0)\n    {\n      close (fd);\n      fputc ('\\0', fp); /* This should set the error indicator.  */\n      fflush (fp);      /* Or this.  */\n      if (dup2 (fd2, fd) < 0)\n        /* Whee... we botched the stream and now cannot restore it!  */\n        abort ();\n      close (fd2);\n    }\n  errno = saved_errno;\n#else\n #error \"Please port gnulib fseterr.c to your platform! Look at the definitions of ferror and clearerr on your system, then report this to bug-gnulib.\"\n#endif\n}",
      "lines": 56,
      "depth": 20,
      "decorators": [
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/fseterr.h": {},
  "libunistring/libunistring-0.9.10/lib/hard-locale.c": {
    "hard_locale": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "bool\nhard_locale (int category)\n{\n  bool hard = true;\n  char const *p = setlocale (category, NULL);\n\n  if (p)\n    {\n      if (2 <= GLIBC_VERSION)\n        {\n          if (strcmp (p, \"C\") == 0 || strcmp (p, \"POSIX\") == 0)\n            hard = false;\n        }\n      else\n        {\n          char *locale = strdup (p);\n          if (locale)\n            {\n              /* Temporarily set the locale to the \"C\" and \"POSIX\" locales\n                 to find their names, so that we can determine whether one\n                 or the other is the caller's locale.  */\n              if (((p = setlocale (category, \"C\"))\n                   && strcmp (p, locale) == 0)\n                  || ((p = setlocale (category, \"POSIX\"))\n                      && strcmp (p, locale) == 0))\n                hard = false;\n\n              /* Restore the caller's locale.  */\n              setlocale (category, locale);\n              free (locale);\n            }\n        }\n    }\n\n  return hard;\n}",
      "lines": 36,
      "depth": 19,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/hard-locale.h": {},
  "libunistring/libunistring-0.9.10/lib/iconv.c": {
    "utf16be_mbtowc": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "static int\nutf16be_mbtowc (ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  if (n >= 2)\n    {\n      ucs4_t wc = (s[0] << 8) + s[1];\n      if (wc >= 0xd800 && wc < 0xdc00)\n        {\n          if (n >= 4)\n            {\n              ucs4_t wc2 = (s[2] << 8) + s[3];\n              if (!(wc2 >= 0xdc00 && wc2 < 0xe000))\n                return RET_ILSEQ;\n              *pwc = 0x10000 + ((wc - 0xd800) << 10) + (wc2 - 0xdc00);\n              return 4;\n            }\n        }\n      else if (wc >= 0xdc00 && wc < 0xe000)\n        {\n          return RET_ILSEQ;\n        }\n      else\n        {\n          *pwc = wc;\n          return 2;\n        }\n    }\n  return RET_TOOFEW;\n}",
      "lines": 29,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf16be_wctomb": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "static int\nutf16be_wctomb (unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (!(wc >= 0xd800 && wc < 0xe000))\n    {\n      if (wc < 0x10000)\n        {\n          if (n >= 2)\n            {\n              r[0] = (unsigned char) (wc >> 8);\n              r[1] = (unsigned char) wc;\n              return 2;\n            }\n          else\n            return RET_TOOSMALL;\n        }\n      else if (wc < 0x110000)\n        {\n          if (n >= 4)\n            {\n              ucs4_t wc1 = 0xd800 + ((wc - 0x10000) >> 10);\n              ucs4_t wc2 = 0xdc00 + ((wc - 0x10000) & 0x3ff);\n              r[0] = (unsigned char) (wc1 >> 8);\n              r[1] = (unsigned char) wc1;\n              r[2] = (unsigned char) (wc2 >> 8);\n              r[3] = (unsigned char) wc2;\n              return 4;\n            }\n          else\n            return RET_TOOSMALL;\n        }\n    }\n  return RET_ILUNI;\n}",
      "lines": 34,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf16le_mbtowc": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "static int\nutf16le_mbtowc (ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  if (n >= 2)\n    {\n      ucs4_t wc = s[0] + (s[1] << 8);\n      if (wc >= 0xd800 && wc < 0xdc00)\n        {\n          if (n >= 4)\n            {\n              ucs4_t wc2 = s[2] + (s[3] << 8);\n              if (!(wc2 >= 0xdc00 && wc2 < 0xe000))\n                return RET_ILSEQ;\n              *pwc = 0x10000 + ((wc - 0xd800) << 10) + (wc2 - 0xdc00);\n              return 4;\n            }\n        }\n      else if (wc >= 0xdc00 && wc < 0xe000)\n        {\n          return RET_ILSEQ;\n        }\n      else\n        {\n          *pwc = wc;\n          return 2;\n        }\n    }\n  return RET_TOOFEW;\n}",
      "lines": 29,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf16le_wctomb": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "static int\nutf16le_wctomb (unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (!(wc >= 0xd800 && wc < 0xe000))\n    {\n      if (wc < 0x10000)\n        {\n          if (n >= 2)\n            {\n              r[0] = (unsigned char) wc;\n              r[1] = (unsigned char) (wc >> 8);\n              return 2;\n            }\n          else\n            return RET_TOOSMALL;\n        }\n      else if (wc < 0x110000)\n        {\n          if (n >= 4)\n            {\n              ucs4_t wc1 = 0xd800 + ((wc - 0x10000) >> 10);\n              ucs4_t wc2 = 0xdc00 + ((wc - 0x10000) & 0x3ff);\n              r[0] = (unsigned char) wc1;\n              r[1] = (unsigned char) (wc1 >> 8);\n              r[2] = (unsigned char) wc2;\n              r[3] = (unsigned char) (wc2 >> 8);\n              return 4;\n            }\n          else\n            return RET_TOOSMALL;\n        }\n    }\n  return RET_ILUNI;\n}",
      "lines": 34,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf32be_mbtowc": {
      "start_point": [
        204,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "static int\nutf32be_mbtowc (ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  if (n >= 4)\n    {\n      ucs4_t wc = (s[0] << 24) + (s[1] << 16) + (s[2] << 8) + s[3];\n      if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000))\n        {\n          *pwc = wc;\n          return 4;\n        }\n      else\n        return RET_ILSEQ;\n    }\n  return RET_TOOFEW;\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf32be_wctomb": {
      "start_point": [
        221,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "static int\nutf32be_wctomb (unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000))\n    {\n      if (n >= 4)\n        {\n          r[0] = 0;\n          r[1] = (unsigned char) (wc >> 16);\n          r[2] = (unsigned char) (wc >> 8);\n          r[3] = (unsigned char) wc;\n          return 4;\n        }\n      else\n        return RET_TOOSMALL;\n    }\n  return RET_ILUNI;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf32le_mbtowc": {
      "start_point": [
        246,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "static int\nutf32le_mbtowc (ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  if (n >= 4)\n    {\n      ucs4_t wc = s[0] + (s[1] << 8) + (s[2] << 16) + (s[3] << 24);\n      if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000))\n        {\n          *pwc = wc;\n          return 4;\n        }\n      else\n        return RET_ILSEQ;\n    }\n  return RET_TOOFEW;\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf32le_wctomb": {
      "start_point": [
        263,
        0
      ],
      "end_point": [
        280,
        1
      ],
      "content": "static int\nutf32le_wctomb (unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000))\n    {\n      if (n >= 4)\n        {\n          r[0] = (unsigned char) wc;\n          r[1] = (unsigned char) (wc >> 8);\n          r[2] = (unsigned char) (wc >> 16);\n          r[3] = 0;\n          return 4;\n        }\n      else\n        return RET_TOOSMALL;\n    }\n  return RET_ILUNI;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/iconv.in.h": {},
  "libunistring/libunistring-0.9.10/lib/iconveh.h": {},
  "libunistring/libunistring-0.9.10/lib/iconv_close.c": {},
  "libunistring/libunistring-0.9.10/lib/iconv_open-aix.h": {
    "mapping_hash": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static unsigned int\nmapping_hash (register const char *str, register size_t len)\n{\n  static const unsigned char asso_values[] =\n    {\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45,  0,  4, 25,\n       0, 11, 24,  9, 17,  3, 14, 21, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n       3, 45,  1, 45, 45, 45, 45,  0, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45\n    };\n  return len + asso_values[(unsigned char)str[3]+2] + asso_values[(unsigned char)str[len - 1]];\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "mapping_lookup": {
      "start_point": [
        229,
        0
      ],
      "end_point": [
        249,
        1
      ],
      "content": "const struct mapping *\nmapping_lookup (register const char *str, register size_t len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register unsigned int key = mapping_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE)\n        {\n          register int o = mappings[key].standard_name;\n          if (o >= 0)\n            {\n              register const char *s = o + stringpool;\n\n              if (*str == *s && !strcmp (str + 1, s + 1))\n                return &mappings[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "struct mapping",
        "struct",
        "mapping",
        "*\nmapping_lookup (register const char *str, register size_t len)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/iconv_open-hpux.h": {
    "mapping_hash": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static unsigned int\nmapping_hash (register const char *str, register size_t len)\n{\n  static const unsigned char asso_values[] =\n    {\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50,  1,  2,\n      24, 43,  5, 10,  0, 13, 32,  3, 19, 18,\n      50, 50, 50, 50, 50, 50, 50, 50, 50,  5,\n      50, 50, 50, 50, 14,  5,  0, 50, 50,  0,\n      27, 50, 12, 14, 50, 50,  0,  5,  2, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50\n    };\n  return len + asso_values[(unsigned char)str[3]+4] + asso_values[(unsigned char)str[len - 1]];\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "mapping_lookup": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        292,
        1
      ],
      "content": "const struct mapping *\nmapping_lookup (register const char *str, register size_t len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register unsigned int key = mapping_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE)\n        {\n          register int o = mappings[key].standard_name;\n          if (o >= 0)\n            {\n              register const char *s = o + stringpool;\n\n              if (*str == *s && !strcmp (str + 1, s + 1))\n                return &mappings[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "struct mapping",
        "struct",
        "mapping",
        "*\nmapping_lookup (register const char *str, register size_t len)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/iconv_open-irix.h": {
    "mapping_hash": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static unsigned int\nmapping_hash (register const char *str, register size_t len)\n{\n  static const unsigned char asso_values[] =\n    {\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24,  8,  2,\n       5, 12, 11,  0, 10,  9,  8,  7, 24, 24,\n      24, 24, 24, 24, 24, 24, 24,  0, 24,  0,\n      24,  5, 24,  0, 24,  7, 24, 24, 24, 24,\n       7, 24,  1,  0,  8, 24, 24,  0, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24\n    };\n  return len + asso_values[(unsigned char)str[len - 1]] + asso_values[(unsigned char)str[0]];\n}",
      "lines": 34,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "mapping_lookup": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "const struct mapping *\nmapping_lookup (register const char *str, register size_t len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register unsigned int key = mapping_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE)\n        {\n          register int o = mappings[key].standard_name;\n          if (o >= 0)\n            {\n              register const char *s = o + stringpool;\n\n              if (*str == *s && !strcmp (str + 1, s + 1))\n                return &mappings[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "struct mapping",
        "struct",
        "mapping",
        "*\nmapping_lookup (register const char *str, register size_t len)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/iconv_open-osf.h": {
    "mapping_hash": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static unsigned int\nmapping_hash (register const char *str, register size_t len)\n{\n  static const unsigned char asso_values[] =\n    {\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48,  2, 29,\n      24, 34, 31,  0, 15, 14, 10, 13,  2, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48,  7, 48, 48, 48, 48, 48, 48,\n      11, 48,  2,  7, 48, 48, 48,  1, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48\n    };\n  return len + asso_values[(unsigned char)str[3]+3] + asso_values[(unsigned char)str[len - 1]];\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "mapping_lookup": {
      "start_point": [
        251,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "const struct mapping *\nmapping_lookup (register const char *str, register size_t len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register unsigned int key = mapping_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE)\n        {\n          register int o = mappings[key].standard_name;\n          if (o >= 0)\n            {\n              register const char *s = o + stringpool;\n\n              if (*str == *s && !strcmp (str + 1, s + 1))\n                return &mappings[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "struct mapping",
        "struct",
        "mapping",
        "*\nmapping_lookup (register const char *str, register size_t len)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/iconv_open-solaris.h": {
    "mapping_hash": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "static unsigned int\nmapping_hash (register const char *str, register size_t len)\n{\n  static const unsigned char asso_values[] =\n    {\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20,  0,\n       9,  8,  7,  6,  5,  4,  3,  2, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20\n    };\n  register unsigned int hval = len;\n\n  switch (hval)\n    {\n      default:\n        hval += asso_values[(unsigned char)str[9]];\n      /*FALLTHROUGH*/\n      case 9:\n      case 8:\n      case 7:\n      case 6:\n      case 5:\n        break;\n    }\n  return hval;\n}",
      "lines": 48,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "mapping_lookup": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "const struct mapping *\nmapping_lookup (register const char *str, register size_t len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register unsigned int key = mapping_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE)\n        {\n          register int o = mappings[key].standard_name;\n          if (o >= 0)\n            {\n              register const char *s = o + stringpool;\n\n              if (*str == *s && !strcmp (str + 1, s + 1))\n                return &mappings[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "struct mapping",
        "struct",
        "mapping",
        "*\nmapping_lookup (register const char *str, register size_t len)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/iconv_open.c": {},
  "libunistring/libunistring-0.9.10/lib/isnan.c": {
    "FUNC": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "int\nFUNC (DOUBLE x)\n{\n#if defined KNOWN_EXPBIT0_LOCATION && IEEE_FLOATING_POINT\n# if defined USE_LONG_DOUBLE && ((defined __ia64 && LDBL_MANT_DIG == 64) || (defined __x86_64__ || defined __amd64__) || (defined __i386 || defined __i386__ || defined _I386 || defined _M_IX86 || defined _X86_)) && !HAVE_SAME_LONG_DOUBLE_AS_DOUBLE\n  /* Special CPU dependent code is needed to treat bit patterns outside the\n     IEEE 754 specification (such as Pseudo-NaNs, Pseudo-Infinities,\n     Pseudo-Zeroes, Unnormalized Numbers, and Pseudo-Denormals) as NaNs.\n     These bit patterns are:\n       - exponent = 0x0001..0x7FFF, mantissa bit 63 = 0,\n       - exponent = 0x0000, mantissa bit 63 = 1.\n     The NaN bit pattern is:\n       - exponent = 0x7FFF, mantissa >= 0x8000000000000001.  */\n  memory_double m;\n  unsigned int exponent;\n\n  m.value = x;\n  exponent = (m.word[EXPBIT0_WORD] >> EXPBIT0_BIT) & EXP_MASK;\n#  ifdef WORDS_BIGENDIAN\n  /* Big endian: EXPBIT0_WORD = 0, EXPBIT0_BIT = 16.  */\n  if (exponent == 0)\n    return 1 & (m.word[0] >> 15);\n  else if (exponent == EXP_MASK)\n    return (((m.word[0] ^ 0x8000U) << 16) | m.word[1] | (m.word[2] >> 16)) != 0;\n  else\n    return 1 & ~(m.word[0] >> 15);\n#  else\n  /* Little endian: EXPBIT0_WORD = 2, EXPBIT0_BIT = 0.  */\n  if (exponent == 0)\n    return (m.word[1] >> 31);\n  else if (exponent == EXP_MASK)\n    return ((m.word[1] ^ 0x80000000U) | m.word[0]) != 0;\n  else\n    return (m.word[1] >> 31) ^ 1;\n#  endif\n# else\n  /* Be careful to not do any floating-point operation on x, such as x == x,\n     because x may be a signaling NaN.  */\n#  if defined __SUNPRO_C || defined __ICC || defined _MSC_VER \\\n      || defined __DECC || defined __TINYC__ \\\n      || (defined __sgi && !defined __GNUC__)\n  /* The Sun C 5.0, Intel ICC 10.0, Microsoft Visual C/C++ 9.0, Compaq (ex-DEC)\n     6.4, and TinyCC compilers don't recognize the initializers as constant\n     expressions.  The Compaq compiler also fails when constant-folding\n     0.0 / 0.0 even when constant-folding is not required.  The Microsoft\n     Visual C/C++ compiler also fails when constant-folding 1.0 / 0.0 even\n     when constant-folding is not required. The SGI MIPSpro C compiler\n     complains about \"floating-point operation result is out of range\".  */\n  static DOUBLE zero = L_(0.0);\n  memory_double nan;\n  DOUBLE plus_inf = L_(1.0) / zero;\n  DOUBLE minus_inf = -L_(1.0) / zero;\n  nan.value = zero / zero;\n#  else\n  static memory_double nan = { L_(0.0) / L_(0.0) };\n  static DOUBLE plus_inf = L_(1.0) / L_(0.0);\n  static DOUBLE minus_inf = -L_(1.0) / L_(0.0);\n#  endif\n  {\n    memory_double m;\n\n    /* A NaN can be recognized through its exponent.  But exclude +Infinity and\n       -Infinity, which have the same exponent.  */\n    m.value = x;\n    if (((m.word[EXPBIT0_WORD] ^ nan.word[EXPBIT0_WORD])\n         & (EXP_MASK << EXPBIT0_BIT))\n        == 0)\n      return (memcmp (&m.value, &plus_inf, SIZE) != 0\n              && memcmp (&m.value, &minus_inf, SIZE) != 0);\n    else\n      return 0;\n  }\n# endif\n#else\n  /* The configuration did not find sufficient information, or does\n     not use IEEE floating point.  Give up about the signaling NaNs;\n     handle only the quiet NaNs.  */\n  if (x == x)\n    {\n# if defined USE_LONG_DOUBLE && ((defined __ia64 && LDBL_MANT_DIG == 64) || (defined __x86_64__ || defined __amd64__) || (defined __i386 || defined __i386__ || defined _I386 || defined _M_IX86 || defined _X86_)) && !HAVE_SAME_LONG_DOUBLE_AS_DOUBLE\n      /* Detect any special bit patterns that pass ==; see comment above.  */\n      memory_double m1;\n      memory_double m2;\n\n      memset (&m1.value, 0, SIZE);\n      memset (&m2.value, 0, SIZE);\n      m1.value = x;\n      m2.value = x + (x ? 0.0L : -0.0L);\n      if (memcmp (&m1.value, &m2.value, SIZE) != 0)\n        return 1;\n# endif\n      return 0;\n    }\n  else\n    return 1;\n#endif\n}",
      "lines": 97,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/isnand-nolibm.h": {},
  "libunistring/libunistring-0.9.10/lib/isnand.c": {},
  "libunistring/libunistring-0.9.10/lib/isnanf-nolibm.h": {},
  "libunistring/libunistring-0.9.10/lib/isnanf.c": {},
  "libunistring/libunistring-0.9.10/lib/isnanl-nolibm.h": {},
  "libunistring/libunistring-0.9.10/lib/isnanl.c": {},
  "libunistring/libunistring-0.9.10/lib/iswblank.c": {
    "iswblank": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "int\niswblank (wint_t wc)\n{\n  return wc == ' ' || wc == '\\t';\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/itold.c": {
    "_Qp_itoq": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "void\n_Qp_itoq (long double *result, int a)\n{\n  /* Convert from 'int' to 'double', then from 'double' to 'long double'.  */\n  *result = (double) a;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/langinfo.in.h": {},
  "libunistring/libunistring-0.9.10/lib/limits.in.h": {},
  "libunistring/libunistring-0.9.10/lib/localcharset.c": {
    "get_charset_aliases": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        395,
        1
      ],
      "content": "static const char *\nget_charset_aliases (void)\n{\n  const char *cp;\n\n  cp = charset_aliases;\n  if (cp == NULL)\n    {\n#if !(defined DARWIN7 || defined VMS || defined WINDOWS_NATIVE || defined __CYGWIN__ || defined OS2)\n      char *malloc_dir = NULL;\n      const char *dir;\n      const char *base = \"charset.alias\";\n      char *file_name;\n\n      /* Make it possible to override the charset.alias location.  This is\n         necessary for running the testsuite before \"make install\".  */\n      dir = getenv (\"CHARSETALIASDIR\");\n      if (dir == NULL || dir[0] == '\\0')\n        dir = relocate2 (LIBDIR, &malloc_dir);\n\n      /* Concatenate dir and base into freshly allocated file_name.  */\n      {\n        size_t dir_len = strlen (dir);\n        size_t base_len = strlen (base);\n        int add_slash = (dir_len > 0 && !ISSLASH (dir[dir_len - 1]));\n        file_name = (char *) malloc (dir_len + add_slash + base_len + 1);\n        if (file_name != NULL)\n          {\n            memcpy (file_name, dir, dir_len);\n            if (add_slash)\n              file_name[dir_len] = DIRECTORY_SEPARATOR;\n            memcpy (file_name + dir_len + add_slash, base, base_len + 1);\n          }\n      }\n\n      free (malloc_dir);\n\n      if (file_name == NULL)\n        /* Out of memory.  Treat the file as empty.  */\n        cp = \"\";\n      else\n        {\n          int fd;\n\n          /* Open the file.  Reject symbolic links on platforms that support\n             O_NOFOLLOW.  This is a security feature.  Without it, an attacker\n             could retrieve parts of the contents (namely, the tail of the\n             first line that starts with \"* \") of an arbitrary file by placing\n             a symbolic link to that file under the name \"charset.alias\" in\n             some writable directory and defining the environment variable\n             CHARSETALIASDIR to point to that directory.  */\n          fd = open (file_name,\n                     O_RDONLY | (HAVE_WORKING_O_NOFOLLOW ? O_NOFOLLOW : 0));\n          if (fd < 0)\n            /* File not found.  Treat it as empty.  */\n            cp = \"\";\n          else\n            {\n              FILE *fp;\n\n              fp = fdopen (fd, \"r\");\n              if (fp == NULL)\n                {\n                  /* Out of memory.  Treat the file as empty.  */\n                  close (fd);\n                  cp = \"\";\n                }\n              else\n                {\n                  /* Parse the file's contents.  */\n                  char *res_ptr = NULL;\n                  size_t res_size = 0;\n\n                  for (;;)\n                    {\n                      int c;\n                      char buf1[50+1];\n                      char buf2[50+1];\n                      size_t l1, l2;\n                      char *old_res_ptr;\n\n                      c = getc (fp);\n                      if (c == EOF)\n                        break;\n                      if (c == '\\n' || c == ' ' || c == '\\t')\n                        continue;\n                      if (c == '#')\n                        {\n                          /* Skip comment, to end of line.  */\n                          do\n                            c = getc (fp);\n                          while (!(c == EOF || c == '\\n'));\n                          if (c == EOF)\n                            break;\n                          continue;\n                        }\n                      ungetc (c, fp);\n                      if (fscanf (fp, \"%50s %50s\", buf1, buf2) < 2)\n                        break;\n                      l1 = strlen (buf1);\n                      l2 = strlen (buf2);\n                      old_res_ptr = res_ptr;\n                      if (res_size == 0)\n                        {\n                          res_size = l1 + 1 + l2 + 1;\n                          res_ptr = (char *) malloc (res_size + 1);\n                        }\n                      else\n                        {\n                          res_size += l1 + 1 + l2 + 1;\n                          res_ptr = (char *) realloc (res_ptr, res_size + 1);\n                        }\n                      if (res_ptr == NULL)\n                        {\n                          /* Out of memory. */\n                          res_size = 0;\n                          free (old_res_ptr);\n                          break;\n                        }\n                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);\n                      strcpy (res_ptr + res_size - (l2 + 1), buf2);\n                    }\n                  fclose (fp);\n                  if (res_size == 0)\n                    cp = \"\";\n                  else\n                    {\n                      *(res_ptr + res_size) = '\\0';\n                      cp = res_ptr;\n                    }\n                }\n            }\n\n          free (file_name);\n        }\n\n#else\n\n# if defined DARWIN7\n      /* To avoid the trouble of installing a file that is shared by many\n         GNU packages -- many packaging systems have problems with this --,\n         simply inline the aliases here.\n         For speed, map the most frequent case first.  */\n      cp = \"UTF-8\" \"\\0\" \"UTF-8\" \"\\0\"\n           \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-4\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"ISO8859-13\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"ISO8859-15\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"KOI8-R\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"KOI8-U\" \"\\0\" \"KOI8-U\" \"\\0\"\n           \"CP866\" \"\\0\" \"CP866\" \"\\0\"\n           \"CP949\" \"\\0\" \"CP949\" \"\\0\"\n           \"CP1131\" \"\\0\" \"CP1131\" \"\\0\"\n           \"CP1251\" \"\\0\" \"CP1251\" \"\\0\"\n           \"eucCN\" \"\\0\" \"GB2312\" \"\\0\"\n           \"GB2312\" \"\\0\" \"GB2312\" \"\\0\"\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"eucKR\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"Big5\" \"\\0\" \"BIG5\" \"\\0\"\n           \"Big5HKSCS\" \"\\0\" \"BIG5-HKSCS\" \"\\0\"\n           \"GBK\" \"\\0\" \"GBK\" \"\\0\"\n           \"GB18030\" \"\\0\" \"GB18030\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"ARMSCII-8\" \"\\0\" \"ARMSCII-8\" \"\\0\"\n           \"PT154\" \"\\0\" \"PT154\" \"\\0\"\n         /*\"ISCII-DEV\" \"\\0\" \"?\" \"\\0\"*/\n           \"*\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n\n# if defined VMS\n      /* To avoid the troubles of an extra file charset.alias_vms in the\n         sources of many GNU packages, simply inline the aliases here.  */\n      /* The list of encodings is taken from the OpenVMS 7.3-1 documentation\n         \"Compaq C Run-Time Library Reference Manual for OpenVMS systems\"\n         section 10.7 \"Handling Different Character Sets\".  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-8\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           /* Japanese */\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"DECKANJI\" \"\\0\" \"DEC-KANJI\" \"\\0\"\n           \"SDECKANJI\" \"\\0\" \"EUC-JP\" \"\\0\"\n           /* Chinese */\n           \"eucTW\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"DECHANYU\" \"\\0\" \"DEC-HANYU\" \"\\0\"\n           \"DECHANZI\" \"\\0\" \"GB2312\" \"\\0\"\n           /* Korean */\n           \"DECKOREAN\" \"\\0\" \"EUC-KR\" \"\\0\";\n# endif\n\n# if defined WINDOWS_NATIVE || defined __CYGWIN__\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      cp = \"CP936\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP1361\" \"\\0\" \"JOHAB\" \"\\0\"\n           \"CP20127\" \"\\0\" \"ASCII\" \"\\0\"\n           \"CP20866\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP20936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP21866\" \"\\0\" \"KOI8-RU\" \"\\0\"\n           \"CP28591\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP28592\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP28593\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP28594\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP28595\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP28596\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP28597\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP28598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP28599\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP28605\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP38598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP51932\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP51936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP51949\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP51950\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP54936\" \"\\0\" \"GB18030\" \"\\0\"\n           \"CP65001\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n# if defined OS2\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      /* The list of encodings is taken from \"List of OS/2 Codepages\"\n         by Alex Taylor:\n         <http://altsan.org/os2/toolkits/uls/index.html#codepages>.\n         See also \"IBM Globalization - Code page identifiers\":\n         <https://www-01.ibm.com/software/globalization/cp/cp_cpgid.html>.  */\n      cp = \"CP813\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP878\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP819\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP912\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP913\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP914\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP915\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP916\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP920\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP921\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"CP923\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP954\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP964\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP970\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP1089\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP1208\" \"\\0\" \"UTF-8\" \"\\0\"\n           \"CP1381\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP1386\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP3372\" \"\\0\" \"EUC-JP\" \"\\0\";\n# endif\n#endif\n\n      charset_aliases = cp;\n    }\n\n  return cp;\n}",
      "lines": 264,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nget_charset_aliases (void)",
        "*"
      ]
    },
    "locale_charset": {
      "start_point": [
        406,
        0
      ],
      "end_point": [
        627,
        1
      ],
      "content": "const char *\nlocale_charset (void)\n{\n  const char *codeset;\n  const char *aliases;\n\n#if !(defined WINDOWS_NATIVE || defined OS2)\n\n# if HAVE_LANGINFO_CODESET\n\n  /* Most systems support nl_langinfo (CODESET) nowadays.  */\n  codeset = nl_langinfo (CODESET);\n\n#  ifdef __CYGWIN__\n  /* Cygwin < 1.7 does not have locales.  nl_langinfo (CODESET) always\n     returns \"US-ASCII\".  Return the suffix of the locale name from the\n     environment variables (if present) or the codepage as a number.  */\n  if (codeset != NULL && strcmp (codeset, \"US-ASCII\") == 0)\n    {\n      const char *locale;\n      static char buf[2 + 10 + 1];\n\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n      if (locale != NULL && locale[0] != '\\0')\n        {\n          /* If the locale name contains an encoding after the dot, return\n             it.  */\n          const char *dot = strchr (locale, '.');\n\n          if (dot != NULL)\n            {\n              const char *modifier;\n\n              dot++;\n              /* Look for the possible @... trailer and remove it, if any.  */\n              modifier = strchr (dot, '@');\n              if (modifier == NULL)\n                return dot;\n              if (modifier - dot < sizeof (buf))\n                {\n                  memcpy (buf, dot, modifier - dot);\n                  buf [modifier - dot] = '\\0';\n                  return buf;\n                }\n            }\n        }\n\n      /* The Windows API has a function returning the locale's codepage as a\n         number: GetACP().  This encoding is used by Cygwin, unless the user\n         has set the environment variable CYGWIN=codepage:oem (which very few\n         people do).\n         Output directed to console windows needs to be converted (to\n         GetOEMCP() if the console is using a raster font, or to\n         GetConsoleOutputCP() if it is using a TrueType font).  Cygwin does\n         this conversion transparently (see winsup/cygwin/fhandler_console.cc),\n         converting to GetConsoleOutputCP().  This leads to correct results,\n         except when SetConsoleOutputCP has been called and a raster font is\n         in use.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n      codeset = buf;\n    }\n#  endif\n\n# else\n\n  /* On old systems which lack it, use setlocale or getenv.  */\n  const char *locale = NULL;\n\n  /* But most old systems don't have a complete set of locales.  Some\n     (like SunOS 4 or DJGPP) have only the C locale.  Therefore we don't\n     use setlocale here; it would return \"C\" when it doesn't support the\n     locale name the user has set.  */\n#  if 0\n  locale = setlocale (LC_CTYPE, NULL);\n#  endif\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n    }\n\n  /* On some old systems, one used to set locale = \"iso8859_1\". On others,\n     you set it to \"language_COUNTRY.charset\". In any case, we resolve it\n     through the charset.alias file.  */\n  codeset = locale;\n\n# endif\n\n#elif defined WINDOWS_NATIVE\n\n  static char buf[2 + 10 + 1];\n\n  /* The Windows API has a function returning the locale's codepage as\n     a number, but the value doesn't change according to what the\n     'setlocale' call specified.  So we use it as a last resort, in\n     case the string returned by 'setlocale' doesn't specify the\n     codepage.  */\n  char *current_locale = setlocale (LC_ALL, NULL);\n  char *pdot;\n\n  /* If they set different locales for different categories,\n     'setlocale' will return a semi-colon separated list of locale\n     values.  To make sure we use the correct one, we choose LC_CTYPE.  */\n  if (strchr (current_locale, ';'))\n    current_locale = setlocale (LC_CTYPE, NULL);\n\n  pdot = strrchr (current_locale, '.');\n  if (pdot && 2 + strlen (pdot + 1) + 1 <= sizeof (buf))\n    sprintf (buf, \"CP%s\", pdot + 1);\n  else\n    {\n      /* The Windows API has a function returning the locale's codepage as a\n        number: GetACP().\n        When the output goes to a console window, it needs to be provided in\n        GetOEMCP() encoding if the console is using a raster font, or in\n        GetConsoleOutputCP() encoding if it is using a TrueType font.\n        But in GUI programs and for output sent to files and pipes, GetACP()\n        encoding is the best bet.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n    }\n  codeset = buf;\n\n#elif defined OS2\n\n  const char *locale;\n  static char buf[2 + 10 + 1];\n  ULONG cp[3];\n  ULONG cplen;\n\n  codeset = NULL;\n\n  /* Allow user to override the codeset, as set in the operating system,\n     with standard language environment variables.  */\n  locale = getenv (\"LC_ALL\");\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_CTYPE\");\n      if (locale == NULL || locale[0] == '\\0')\n        locale = getenv (\"LANG\");\n    }\n  if (locale != NULL && locale[0] != '\\0')\n    {\n      /* If the locale name contains an encoding after the dot, return it.  */\n      const char *dot = strchr (locale, '.');\n\n      if (dot != NULL)\n        {\n          const char *modifier;\n\n          dot++;\n          /* Look for the possible @... trailer and remove it, if any.  */\n          modifier = strchr (dot, '@');\n          if (modifier == NULL)\n            return dot;\n          if (modifier - dot < sizeof (buf))\n            {\n              memcpy (buf, dot, modifier - dot);\n              buf [modifier - dot] = '\\0';\n              return buf;\n            }\n        }\n\n      /* For the POSIX locale, don't use the system's codepage.  */\n      if (strcmp (locale, \"C\") == 0 || strcmp (locale, \"POSIX\") == 0)\n        codeset = \"\";\n    }\n\n  if (codeset == NULL)\n    {\n      /* OS/2 has a function returning the locale's codepage as a number.  */\n      if (DosQueryCp (sizeof (cp), cp, &cplen))\n        codeset = \"\";\n      else\n        {\n          sprintf (buf, \"CP%u\", cp[0]);\n          codeset = buf;\n        }\n    }\n\n#endif\n\n  if (codeset == NULL)\n    /* The canonical name cannot be determined.  */\n    codeset = \"\";\n\n  /* Resolve alias. */\n  for (aliases = get_charset_aliases ();\n       *aliases != '\\0';\n       aliases += strlen (aliases) + 1, aliases += strlen (aliases) + 1)\n    if (strcmp (codeset, aliases) == 0\n        || (aliases[0] == '*' && aliases[1] == '\\0'))\n      {\n        codeset = aliases + strlen (aliases) + 1;\n        break;\n      }\n\n  /* Don't return an empty string.  GNU libc and GNU libiconv interpret\n     the empty string as denoting \"the locale's character encoding\",\n     thus GNU libiconv would call this function a second time.  */\n  if (codeset[0] == '\\0')\n    codeset = \"ASCII\";\n\n#ifdef DARWIN7\n  /* Mac OS X sets MB_CUR_MAX to 1 when LC_ALL=C, and \"UTF-8\"\n     (the default codeset) does not work when MB_CUR_MAX is 1.  */\n  if (strcmp (codeset, \"UTF-8\") == 0 && MB_CUR_MAX_L (uselocale (NULL)) <= 1)\n    codeset = \"ASCII\";\n#endif\n\n  return codeset;\n}",
      "lines": 222,
      "depth": 18,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nlocale_charset (void)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/localcharset.h": {},
  "libunistring/libunistring-0.9.10/lib/localename.c": {
    "gl_locale_name_canonicalize": [
      {
        "start_point": [
          1163,
          0
        ],
        "end_point": [
          1426,
          1
        ],
        "content": "void\ngl_locale_name_canonicalize (char *name)\n{\n  /* This conversion is based on a posting by\n     Deborah GoldSmith <goldsmit@apple.com> on 2005-03-08,\n     https://lists.apple.com/archives/carbon-dev/2005/Mar/msg00293.html */\n\n  /* Convert legacy (NeXTstep inherited) English names to Unix (ISO 639 and\n     ISO 3166) names.  Prior to Mac OS X 10.3, there is no API for doing this.\n     Therefore we do it ourselves, using a table based on the results of the\n     Mac OS X 10.3.8 function\n     CFLocaleCreateCanonicalLocaleIdentifierFromString().  */\n  typedef struct { const char legacy[21+1]; const char unixy[5+1]; }\n          legacy_entry;\n  static const legacy_entry legacy_table[] = {\n    { \"Afrikaans\",             \"af\" },\n    { \"Albanian\",              \"sq\" },\n    { \"Amharic\",               \"am\" },\n    { \"Arabic\",                \"ar\" },\n    { \"Armenian\",              \"hy\" },\n    { \"Assamese\",              \"as\" },\n    { \"Aymara\",                \"ay\" },\n    { \"Azerbaijani\",           \"az\" },\n    { \"Basque\",                \"eu\" },\n    { \"Belarusian\",            \"be\" },\n    { \"Belorussian\",           \"be\" },\n    { \"Bengali\",               \"bn\" },\n    { \"Brazilian Portugese\",   \"pt_BR\" },\n    { \"Brazilian Portuguese\",  \"pt_BR\" },\n    { \"Breton\",                \"br\" },\n    { \"Bulgarian\",             \"bg\" },\n    { \"Burmese\",               \"my\" },\n    { \"Byelorussian\",          \"be\" },\n    { \"Catalan\",               \"ca\" },\n    { \"Chewa\",                 \"ny\" },\n    { \"Chichewa\",              \"ny\" },\n    { \"Chinese\",               \"zh\" },\n    { \"Chinese, Simplified\",   \"zh_CN\" },\n    { \"Chinese, Traditional\",  \"zh_TW\" },\n    { \"Chinese, Tradtional\",   \"zh_TW\" },\n    { \"Croatian\",              \"hr\" },\n    { \"Czech\",                 \"cs\" },\n    { \"Danish\",                \"da\" },\n    { \"Dutch\",                 \"nl\" },\n    { \"Dzongkha\",              \"dz\" },\n    { \"English\",               \"en\" },\n    { \"Esperanto\",             \"eo\" },\n    { \"Estonian\",              \"et\" },\n    { \"Faroese\",               \"fo\" },\n    { \"Farsi\",                 \"fa\" },\n    { \"Finnish\",               \"fi\" },\n    { \"Flemish\",               \"nl_BE\" },\n    { \"French\",                \"fr\" },\n    { \"Galician\",              \"gl\" },\n    { \"Gallegan\",              \"gl\" },\n    { \"Georgian\",              \"ka\" },\n    { \"German\",                \"de\" },\n    { \"Greek\",                 \"el\" },\n    { \"Greenlandic\",           \"kl\" },\n    { \"Guarani\",               \"gn\" },\n    { \"Gujarati\",              \"gu\" },\n    { \"Hawaiian\",              \"haw\" }, /* Yes, \"haw\", not \"cpe\".  */\n    { \"Hebrew\",                \"he\" },\n    { \"Hindi\",                 \"hi\" },\n    { \"Hungarian\",             \"hu\" },\n    { \"Icelandic\",             \"is\" },\n    { \"Indonesian\",            \"id\" },\n    { \"Inuktitut\",             \"iu\" },\n    { \"Irish\",                 \"ga\" },\n    { \"Italian\",               \"it\" },\n    { \"Japanese\",              \"ja\" },\n    { \"Javanese\",              \"jv\" },\n    { \"Kalaallisut\",           \"kl\" },\n    { \"Kannada\",               \"kn\" },\n    { \"Kashmiri\",              \"ks\" },\n    { \"Kazakh\",                \"kk\" },\n    { \"Khmer\",                 \"km\" },\n    { \"Kinyarwanda\",           \"rw\" },\n    { \"Kirghiz\",               \"ky\" },\n    { \"Korean\",                \"ko\" },\n    { \"Kurdish\",               \"ku\" },\n    { \"Latin\",                 \"la\" },\n    { \"Latvian\",               \"lv\" },\n    { \"Lithuanian\",            \"lt\" },\n    { \"Macedonian\",            \"mk\" },\n    { \"Malagasy\",              \"mg\" },\n    { \"Malay\",                 \"ms\" },\n    { \"Malayalam\",             \"ml\" },\n    { \"Maltese\",               \"mt\" },\n    { \"Manx\",                  \"gv\" },\n    { \"Marathi\",               \"mr\" },\n    { \"Moldavian\",             \"mo\" },\n    { \"Mongolian\",             \"mn\" },\n    { \"Nepali\",                \"ne\" },\n    { \"Norwegian\",             \"nb\" }, /* Yes, \"nb\", not the obsolete \"no\".  */\n    { \"Nyanja\",                \"ny\" },\n    { \"Nynorsk\",               \"nn\" },\n    { \"Oriya\",                 \"or\" },\n    { \"Oromo\",                 \"om\" },\n    { \"Panjabi\",               \"pa\" },\n    { \"Pashto\",                \"ps\" },\n    { \"Persian\",               \"fa\" },\n    { \"Polish\",                \"pl\" },\n    { \"Portuguese\",            \"pt\" },\n    { \"Portuguese, Brazilian\", \"pt_BR\" },\n    { \"Punjabi\",               \"pa\" },\n    { \"Pushto\",                \"ps\" },\n    { \"Quechua\",               \"qu\" },\n    { \"Romanian\",              \"ro\" },\n    { \"Ruanda\",                \"rw\" },\n    { \"Rundi\",                 \"rn\" },\n    { \"Russian\",               \"ru\" },\n    { \"Sami\",                  \"se_NO\" }, /* Not just \"se\".  */\n    { \"Sanskrit\",              \"sa\" },\n    { \"Scottish\",              \"gd\" },\n    { \"Serbian\",               \"sr\" },\n    { \"Simplified Chinese\",    \"zh_CN\" },\n    { \"Sindhi\",                \"sd\" },\n    { \"Sinhalese\",             \"si\" },\n    { \"Slovak\",                \"sk\" },\n    { \"Slovenian\",             \"sl\" },\n    { \"Somali\",                \"so\" },\n    { \"Spanish\",               \"es\" },\n    { \"Sundanese\",             \"su\" },\n    { \"Swahili\",               \"sw\" },\n    { \"Swedish\",               \"sv\" },\n    { \"Tagalog\",               \"tl\" },\n    { \"Tajik\",                 \"tg\" },\n    { \"Tajiki\",                \"tg\" },\n    { \"Tamil\",                 \"ta\" },\n    { \"Tatar\",                 \"tt\" },\n    { \"Telugu\",                \"te\" },\n    { \"Thai\",                  \"th\" },\n    { \"Tibetan\",               \"bo\" },\n    { \"Tigrinya\",              \"ti\" },\n    { \"Tongan\",                \"to\" },\n    { \"Traditional Chinese\",   \"zh_TW\" },\n    { \"Turkish\",               \"tr\" },\n    { \"Turkmen\",               \"tk\" },\n    { \"Uighur\",                \"ug\" },\n    { \"Ukrainian\",             \"uk\" },\n    { \"Urdu\",                  \"ur\" },\n    { \"Uzbek\",                 \"uz\" },\n    { \"Vietnamese\",            \"vi\" },\n    { \"Welsh\",                 \"cy\" },\n    { \"Yiddish\",               \"yi\" }\n  };\n\n  /* Convert new-style locale names with language tags (ISO 639 and ISO 15924)\n     to Unix (ISO 639 and ISO 3166) names.  */\n  typedef struct { const char langtag[7+1]; const char unixy[12+1]; }\n          langtag_entry;\n  static const langtag_entry langtag_table[] = {\n    /* Mac OS X has \"az-Arab\", \"az-Cyrl\", \"az-Latn\".\n       The default script for az on Unix is Latin.  */\n    { \"az-Latn\", \"az\" },\n    /* Mac OS X has \"ga-dots\".  Does not yet exist on Unix.  */\n    { \"ga-dots\", \"ga\" },\n    /* Mac OS X has \"kk-Cyrl\".  Does not yet exist on Unix.  */\n    /* Mac OS X has \"mn-Cyrl\", \"mn-Mong\".\n       The default script for mn on Unix is Cyrillic.  */\n    { \"mn-Cyrl\", \"mn\" },\n    /* Mac OS X has \"ms-Arab\", \"ms-Latn\".\n       The default script for ms on Unix is Latin.  */\n    { \"ms-Latn\", \"ms\" },\n    /* Mac OS X has \"tg-Cyrl\".\n       The default script for tg on Unix is Cyrillic.  */\n    { \"tg-Cyrl\", \"tg\" },\n    /* Mac OS X has \"tk-Cyrl\".  Does not yet exist on Unix.  */\n    /* Mac OS X has \"tt-Cyrl\".\n       The default script for tt on Unix is Cyrillic.  */\n    { \"tt-Cyrl\", \"tt\" },\n    /* Mac OS X has \"zh-Hans\", \"zh-Hant\".\n       Country codes are used to distinguish these on Unix.  */\n    { \"zh-Hans\", \"zh_CN\" },\n    { \"zh-Hant\", \"zh_TW\" }\n  };\n\n  /* Convert script names (ISO 15924) to Unix conventions.\n     See https://www.unicode.org/iso15924/iso15924-codes.html  */\n  typedef struct { const char script[4+1]; const char unixy[9+1]; }\n          script_entry;\n  static const script_entry script_table[] = {\n    { \"Arab\", \"arabic\" },\n    { \"Cyrl\", \"cyrillic\" },\n    { \"Mong\", \"mongolian\" }\n  };\n\n  /* Step 1: Convert using legacy_table.  */\n  if (name[0] >= 'A' && name[0] <= 'Z')\n    {\n      unsigned int i1, i2;\n      i1 = 0;\n      i2 = sizeof (legacy_table) / sizeof (legacy_entry);\n      while (i2 - i1 > 1)\n        {\n          /* At this point we know that if name occurs in legacy_table,\n             its index must be >= i1 and < i2.  */\n          unsigned int i = (i1 + i2) >> 1;\n          const legacy_entry *p = &legacy_table[i];\n          if (strcmp (name, p->legacy) < 0)\n            i2 = i;\n          else\n            i1 = i;\n        }\n      if (strcmp (name, legacy_table[i1].legacy) == 0)\n        {\n          strcpy (name, legacy_table[i1].unixy);\n          return;\n        }\n    }\n\n  /* Step 2: Convert using langtag_table and script_table.  */\n  if (strlen (name) == 7 && name[2] == '-')\n    {\n      unsigned int i1, i2;\n      i1 = 0;\n      i2 = sizeof (langtag_table) / sizeof (langtag_entry);\n      while (i2 - i1 > 1)\n        {\n          /* At this point we know that if name occurs in langtag_table,\n             its index must be >= i1 and < i2.  */\n          unsigned int i = (i1 + i2) >> 1;\n          const langtag_entry *p = &langtag_table[i];\n          if (strcmp (name, p->langtag) < 0)\n            i2 = i;\n          else\n            i1 = i;\n        }\n      if (strcmp (name, langtag_table[i1].langtag) == 0)\n        {\n          strcpy (name, langtag_table[i1].unixy);\n          return;\n        }\n\n      i1 = 0;\n      i2 = sizeof (script_table) / sizeof (script_entry);\n      while (i2 - i1 > 1)\n        {\n          /* At this point we know that if (name + 3) occurs in script_table,\n             its index must be >= i1 and < i2.  */\n          unsigned int i = (i1 + i2) >> 1;\n          const script_entry *p = &script_table[i];\n          if (strcmp (name + 3, p->script) < 0)\n            i2 = i;\n          else\n            i1 = i;\n        }\n      if (strcmp (name + 3, script_table[i1].script) == 0)\n        {\n          name[2] = '@';\n          strcpy (name + 3, script_table[i1].unixy);\n          return;\n        }\n    }\n\n  /* Step 3: Convert new-style dash to Unix underscore. */\n  {\n    char *p;\n    for (p = name; *p != '\\0'; p++)\n      if (*p == '-')\n        *p = '_';\n  }\n}",
        "lines": 264,
        "depth": 13,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          1440,
          0
        ],
        "end_point": [
          1464,
          1
        ],
        "content": "void\ngl_locale_name_canonicalize (char *name)\n{\n  /* FIXME: This is probably incomplete: it does not handle \"zh-Hans\" and\n     \"zh-Hant\".  */\n  char *p;\n\n  for (p = name; *p != '\\0'; p++)\n    if (*p == '-')\n      {\n        *p = '_';\n        p++;\n        for (; *p != '\\0'; p++)\n          {\n            if (*p >= 'a' && *p <= 'z')\n              *p += 'A' - 'a';\n            if (*p == '-')\n              {\n                *p = '\\0';\n                return;\n              }\n          }\n        return;\n      }\n}",
        "lines": 25,
        "depth": 13,
        "decorators": [
          "void"
        ]
      }
    ],
    "gl_locale_name_from_win32_LANGID": {
      "start_point": [
        1469,
        0
      ],
      "end_point": [
        2512,
        1
      ],
      "content": "const char *\ngl_locale_name_from_win32_LANGID (LANGID langid)\n{\n  /* Activate the new code only when the GETTEXT_MUI environment variable is\n     set, for the time being, since the new code is not well tested.  */\n  if (getenv (\"GETTEXT_MUI\") != NULL)\n    {\n      static char namebuf[256];\n\n      /* Query the system's notion of locale name.\n         On Windows95/98/ME, GetLocaleInfoA returns some incorrect results.\n         But we don't need to support systems that are so old.  */\n      if (GetLocaleInfoA (MAKELCID (langid, SORT_DEFAULT), LOCALE_SNAME,\n                          namebuf, sizeof (namebuf) - 1))\n        {\n          /* Convert it to a Unix locale name.  */\n          gl_locale_name_canonicalize (namebuf);\n          return namebuf;\n        }\n    }\n  /* Internet Explorer has an LCID to RFC3066 name mapping stored in\n     HKEY_CLASSES_ROOT\\Mime\\Database\\Rfc1766.  But we better don't use that\n     since IE's i18n subsystem is known to be inconsistent with the native\n     Windows base (e.g. they have different character conversion facilities\n     that produce different results).  */\n  /* Use our own table.  */\n  {\n    int primary, sub;\n\n    /* Split into language and territory part.  */\n    primary = PRIMARYLANGID (langid);\n    sub = SUBLANGID (langid);\n\n    /* Dispatch on language.\n       See also https://www.unicode.org/unicode/onlinedat/languages.html .\n       For details about languages, see https://www.ethnologue.com/ .  */\n    switch (primary)\n      {\n      case LANG_AFRIKAANS:\n        switch (sub)\n          {\n          case SUBLANG_AFRIKAANS_SOUTH_AFRICA: return \"af_ZA\";\n          }\n        return \"af\";\n      case LANG_ALBANIAN:\n        switch (sub)\n          {\n          case SUBLANG_ALBANIAN_ALBANIA: return \"sq_AL\";\n          }\n        return \"sq\";\n      case LANG_ALSATIAN:\n        switch (sub)\n          {\n          case SUBLANG_ALSATIAN_FRANCE: return \"gsw_FR\";\n          }\n        return \"gsw\";\n      case LANG_AMHARIC:\n        switch (sub)\n          {\n          case SUBLANG_AMHARIC_ETHIOPIA: return \"am_ET\";\n          }\n        return \"am\";\n      case LANG_ARABIC:\n        switch (sub)\n          {\n          case SUBLANG_ARABIC_SAUDI_ARABIA: return \"ar_SA\";\n          case SUBLANG_ARABIC_IRAQ: return \"ar_IQ\";\n          case SUBLANG_ARABIC_EGYPT: return \"ar_EG\";\n          case SUBLANG_ARABIC_LIBYA: return \"ar_LY\";\n          case SUBLANG_ARABIC_ALGERIA: return \"ar_DZ\";\n          case SUBLANG_ARABIC_MOROCCO: return \"ar_MA\";\n          case SUBLANG_ARABIC_TUNISIA: return \"ar_TN\";\n          case SUBLANG_ARABIC_OMAN: return \"ar_OM\";\n          case SUBLANG_ARABIC_YEMEN: return \"ar_YE\";\n          case SUBLANG_ARABIC_SYRIA: return \"ar_SY\";\n          case SUBLANG_ARABIC_JORDAN: return \"ar_JO\";\n          case SUBLANG_ARABIC_LEBANON: return \"ar_LB\";\n          case SUBLANG_ARABIC_KUWAIT: return \"ar_KW\";\n          case SUBLANG_ARABIC_UAE: return \"ar_AE\";\n          case SUBLANG_ARABIC_BAHRAIN: return \"ar_BH\";\n          case SUBLANG_ARABIC_QATAR: return \"ar_QA\";\n          }\n        return \"ar\";\n      case LANG_ARMENIAN:\n        switch (sub)\n          {\n          case SUBLANG_ARMENIAN_ARMENIA: return \"hy_AM\";\n          }\n        return \"hy\";\n      case LANG_ASSAMESE:\n        switch (sub)\n          {\n          case SUBLANG_ASSAMESE_INDIA: return \"as_IN\";\n          }\n        return \"as\";\n      case LANG_AZERI:\n        switch (sub)\n          {\n          /* FIXME: Adjust this when Azerbaijani locales appear on Unix.  */\n          case 0x1e: return \"az@latin\";\n          case SUBLANG_AZERI_LATIN: return \"az_AZ@latin\";\n          case 0x1d: return \"az@cyrillic\";\n          case SUBLANG_AZERI_CYRILLIC: return \"az_AZ@cyrillic\";\n          }\n        return \"az\";\n      case LANG_BASHKIR:\n        switch (sub)\n          {\n          case SUBLANG_BASHKIR_RUSSIA: return \"ba_RU\";\n          }\n        return \"ba\";\n      case LANG_BASQUE:\n        switch (sub)\n          {\n          case SUBLANG_BASQUE_BASQUE: return \"eu_ES\";\n          }\n        return \"eu\"; /* Ambiguous: could be \"eu_ES\" or \"eu_FR\".  */\n      case LANG_BELARUSIAN:\n        switch (sub)\n          {\n          case SUBLANG_BELARUSIAN_BELARUS: return \"be_BY\";\n          }\n        return \"be\";\n      case LANG_BENGALI:\n        switch (sub)\n          {\n          case SUBLANG_BENGALI_INDIA: return \"bn_IN\";\n          case SUBLANG_BENGALI_BANGLADESH: return \"bn_BD\";\n          }\n        return \"bn\";\n      case LANG_BRETON:\n        switch (sub)\n          {\n          case SUBLANG_BRETON_FRANCE: return \"br_FR\";\n          }\n        return \"br\";\n      case LANG_BULGARIAN:\n        switch (sub)\n          {\n          case SUBLANG_BULGARIAN_BULGARIA: return \"bg_BG\";\n          }\n        return \"bg\";\n      case LANG_BURMESE:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"my_MM\";\n          }\n        return \"my\";\n      case LANG_CAMBODIAN:\n        switch (sub)\n          {\n          case SUBLANG_CAMBODIAN_CAMBODIA: return \"km_KH\";\n          }\n        return \"km\";\n      case LANG_CATALAN:\n        switch (sub)\n          {\n          case SUBLANG_CATALAN_SPAIN: return \"ca_ES\";\n          }\n        return \"ca\";\n      case LANG_CHEROKEE:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"chr_US\";\n          }\n        return \"chr\";\n      case LANG_CHINESE:\n        switch (sub)\n          {\n          case SUBLANG_CHINESE_TRADITIONAL: case 0x1f: return \"zh_TW\";\n          case SUBLANG_CHINESE_SIMPLIFIED: case 0x00: return \"zh_CN\";\n          case SUBLANG_CHINESE_HONGKONG: return \"zh_HK\"; /* traditional */\n          case SUBLANG_CHINESE_SINGAPORE: return \"zh_SG\"; /* simplified */\n          case SUBLANG_CHINESE_MACAU: return \"zh_MO\"; /* traditional */\n          }\n        return \"zh\";\n      case LANG_CORSICAN:\n        switch (sub)\n          {\n          case SUBLANG_CORSICAN_FRANCE: return \"co_FR\";\n          }\n        return \"co\";\n      case LANG_CROATIAN:      /* LANG_CROATIAN == LANG_SERBIAN == LANG_BOSNIAN\n                                * What used to be called Serbo-Croatian\n                                * should really now be two separate\n                                * languages because of political reasons.\n                                * (Says tml, who knows nothing about Serbian\n                                * or Croatian.)\n                                * (I can feel those flames coming already.)\n                                */\n        switch (sub)\n          {\n          /* Croatian */\n          case 0x00: return \"hr\";\n          case SUBLANG_CROATIAN_CROATIA: return \"hr_HR\";\n          case SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN: return \"hr_BA\";\n          /* Serbian */\n          case 0x1f: return \"sr\";\n          case 0x1c: return \"sr\"; /* latin */\n          case SUBLANG_SERBIAN_LATIN: return \"sr_CS\"; /* latin */\n          case 0x09: return \"sr_RS\"; /* latin */\n          case 0x0b: return \"sr_ME\"; /* latin */\n          case 0x06: return \"sr_BA\"; /* latin */\n          case 0x1b: return \"sr@cyrillic\";\n          case SUBLANG_SERBIAN_CYRILLIC: return \"sr_CS@cyrillic\";\n          case 0x0a: return \"sr_RS@cyrillic\";\n          case 0x0c: return \"sr_ME@cyrillic\";\n          case 0x07: return \"sr_BA@cyrillic\";\n          /* Bosnian */\n          case 0x1e: return \"bs\";\n          case 0x1a: return \"bs\"; /* latin */\n          case SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN: return \"bs_BA\"; /* latin */\n          case 0x19: return \"bs@cyrillic\";\n          case SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC: return \"bs_BA@cyrillic\";\n          }\n        return \"hr\";\n      case LANG_CZECH:\n        switch (sub)\n          {\n          case SUBLANG_CZECH_CZECH_REPUBLIC: return \"cs_CZ\";\n          }\n        return \"cs\";\n      case LANG_DANISH:\n        switch (sub)\n          {\n          case SUBLANG_DANISH_DENMARK: return \"da_DK\";\n          }\n        return \"da\";\n      case LANG_DARI:\n        /* FIXME: Adjust this when such locales appear on Unix.  */\n        switch (sub)\n          {\n          case SUBLANG_DARI_AFGHANISTAN: return \"prs_AF\";\n          }\n        return \"prs\";\n      case LANG_DIVEHI:\n        switch (sub)\n          {\n          case SUBLANG_DIVEHI_MALDIVES: return \"dv_MV\";\n          }\n        return \"dv\";\n      case LANG_DUTCH:\n        switch (sub)\n          {\n          case SUBLANG_DUTCH: return \"nl_NL\";\n          case SUBLANG_DUTCH_BELGIAN: /* FLEMISH, VLAAMS */ return \"nl_BE\";\n          case SUBLANG_DUTCH_SURINAM: return \"nl_SR\";\n          }\n        return \"nl\";\n      case LANG_EDO:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"bin_NG\";\n          }\n        return \"bin\";\n      case LANG_ENGLISH:\n        switch (sub)\n          {\n          /* SUBLANG_ENGLISH_US == SUBLANG_DEFAULT. Heh. I thought\n           * English was the language spoken in England.\n           * Oh well.\n           */\n          case SUBLANG_ENGLISH_US: return \"en_US\";\n          case SUBLANG_ENGLISH_UK: return \"en_GB\";\n          case SUBLANG_ENGLISH_AUS: return \"en_AU\";\n          case SUBLANG_ENGLISH_CAN: return \"en_CA\";\n          case SUBLANG_ENGLISH_NZ: return \"en_NZ\";\n          case SUBLANG_ENGLISH_EIRE: return \"en_IE\";\n          case SUBLANG_ENGLISH_SOUTH_AFRICA: return \"en_ZA\";\n          case SUBLANG_ENGLISH_JAMAICA: return \"en_JM\";\n          case SUBLANG_ENGLISH_CARIBBEAN: return \"en_GD\"; /* Grenada? */\n          case SUBLANG_ENGLISH_BELIZE: return \"en_BZ\";\n          case SUBLANG_ENGLISH_TRINIDAD: return \"en_TT\";\n          case SUBLANG_ENGLISH_ZIMBABWE: return \"en_ZW\";\n          case SUBLANG_ENGLISH_PHILIPPINES: return \"en_PH\";\n          case SUBLANG_ENGLISH_INDONESIA: return \"en_ID\";\n          case SUBLANG_ENGLISH_HONGKONG: return \"en_HK\";\n          case SUBLANG_ENGLISH_INDIA: return \"en_IN\";\n          case SUBLANG_ENGLISH_MALAYSIA: return \"en_MY\";\n          case SUBLANG_ENGLISH_SINGAPORE: return \"en_SG\";\n          }\n        return \"en\";\n      case LANG_ESTONIAN:\n        switch (sub)\n          {\n          case SUBLANG_ESTONIAN_ESTONIA: return \"et_EE\";\n          }\n        return \"et\";\n      case LANG_FAEROESE:\n        switch (sub)\n          {\n          case SUBLANG_FAEROESE_FAROE_ISLANDS: return \"fo_FO\";\n          }\n        return \"fo\";\n      case LANG_FARSI:\n        switch (sub)\n          {\n          case SUBLANG_FARSI_IRAN: return \"fa_IR\";\n          }\n        return \"fa\";\n      case LANG_FINNISH:\n        switch (sub)\n          {\n          case SUBLANG_FINNISH_FINLAND: return \"fi_FI\";\n          }\n        return \"fi\";\n      case LANG_FRENCH:\n        switch (sub)\n          {\n          case SUBLANG_FRENCH: return \"fr_FR\";\n          case SUBLANG_FRENCH_BELGIAN: /* WALLOON */ return \"fr_BE\";\n          case SUBLANG_FRENCH_CANADIAN: return \"fr_CA\";\n          case SUBLANG_FRENCH_SWISS: return \"fr_CH\";\n          case SUBLANG_FRENCH_LUXEMBOURG: return \"fr_LU\";\n          case SUBLANG_FRENCH_MONACO: return \"fr_MC\";\n          case SUBLANG_FRENCH_WESTINDIES: return \"fr\"; /* Caribbean? */\n          case SUBLANG_FRENCH_REUNION: return \"fr_RE\";\n          case SUBLANG_FRENCH_CONGO: return \"fr_CG\";\n          case SUBLANG_FRENCH_SENEGAL: return \"fr_SN\";\n          case SUBLANG_FRENCH_CAMEROON: return \"fr_CM\";\n          case SUBLANG_FRENCH_COTEDIVOIRE: return \"fr_CI\";\n          case SUBLANG_FRENCH_MALI: return \"fr_ML\";\n          case SUBLANG_FRENCH_MOROCCO: return \"fr_MA\";\n          case SUBLANG_FRENCH_HAITI: return \"fr_HT\";\n          }\n        return \"fr\";\n      case LANG_FRISIAN:\n        switch (sub)\n          {\n          case SUBLANG_FRISIAN_NETHERLANDS: return \"fy_NL\";\n          }\n        return \"fy\";\n      case LANG_FULFULDE:\n        /* Spoken in Nigeria, Guinea, Senegal, Mali, Niger, Cameroon, Benin.  */\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"ff_NG\";\n          }\n        return \"ff\";\n      case LANG_GAELIC:\n        switch (sub)\n          {\n          case 0x01: /* SCOTTISH */\n            /* old, superseded by LANG_SCOTTISH_GAELIC */\n            return \"gd_GB\";\n          case SUBLANG_IRISH_IRELAND: return \"ga_IE\";\n          }\n        return \"ga\";\n      case LANG_GALICIAN:\n        switch (sub)\n          {\n          case SUBLANG_GALICIAN_SPAIN: return \"gl_ES\";\n          }\n        return \"gl\";\n      case LANG_GEORGIAN:\n        switch (sub)\n          {\n          case SUBLANG_GEORGIAN_GEORGIA: return \"ka_GE\";\n          }\n        return \"ka\";\n      case LANG_GERMAN:\n        switch (sub)\n          {\n          case SUBLANG_GERMAN: return \"de_DE\";\n          case SUBLANG_GERMAN_SWISS: return \"de_CH\";\n          case SUBLANG_GERMAN_AUSTRIAN: return \"de_AT\";\n          case SUBLANG_GERMAN_LUXEMBOURG: return \"de_LU\";\n          case SUBLANG_GERMAN_LIECHTENSTEIN: return \"de_LI\";\n          }\n        return \"de\";\n      case LANG_GREEK:\n        switch (sub)\n          {\n          case SUBLANG_GREEK_GREECE: return \"el_GR\";\n          }\n        return \"el\";\n      case LANG_GREENLANDIC:\n        switch (sub)\n          {\n          case SUBLANG_GREENLANDIC_GREENLAND: return \"kl_GL\";\n          }\n        return \"kl\";\n      case LANG_GUARANI:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"gn_PY\";\n          }\n        return \"gn\";\n      case LANG_GUJARATI:\n        switch (sub)\n          {\n          case SUBLANG_GUJARATI_INDIA: return \"gu_IN\";\n          }\n        return \"gu\";\n      case LANG_HAUSA:\n        switch (sub)\n          {\n          case 0x1f: return \"ha\";\n          case SUBLANG_HAUSA_NIGERIA_LATIN: return \"ha_NG\";\n          }\n        return \"ha\";\n      case LANG_HAWAIIAN:\n        /* FIXME: Do they mean Hawaiian (\"haw_US\", 1000 speakers)\n           or Hawaii Creole English (\"cpe_US\", 600000 speakers)?  */\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"cpe_US\";\n          }\n        return \"cpe\";\n      case LANG_HEBREW:\n        switch (sub)\n          {\n          case SUBLANG_HEBREW_ISRAEL: return \"he_IL\";\n          }\n        return \"he\";\n      case LANG_HINDI:\n        switch (sub)\n          {\n          case SUBLANG_HINDI_INDIA: return \"hi_IN\";\n          }\n        return \"hi\";\n      case LANG_HUNGARIAN:\n        switch (sub)\n          {\n          case SUBLANG_HUNGARIAN_HUNGARY: return \"hu_HU\";\n          }\n        return \"hu\";\n      case LANG_IBIBIO:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"nic_NG\";\n          }\n        return \"nic\";\n      case LANG_ICELANDIC:\n        switch (sub)\n          {\n          case SUBLANG_ICELANDIC_ICELAND: return \"is_IS\";\n          }\n        return \"is\";\n      case LANG_IGBO:\n        switch (sub)\n          {\n          case SUBLANG_IGBO_NIGERIA: return \"ig_NG\";\n          }\n        return \"ig\";\n      case LANG_INDONESIAN:\n        switch (sub)\n          {\n          case SUBLANG_INDONESIAN_INDONESIA: return \"id_ID\";\n          }\n        return \"id\";\n      case LANG_INUKTITUT:\n        switch (sub)\n          {\n          case 0x1e: return \"iu\"; /* syllabic */\n          case SUBLANG_INUKTITUT_CANADA: return \"iu_CA\"; /* syllabic */\n          case 0x1f: return \"iu@latin\";\n          case SUBLANG_INUKTITUT_CANADA_LATIN: return \"iu_CA@latin\";\n          }\n        return \"iu\";\n      case LANG_ITALIAN:\n        switch (sub)\n          {\n          case SUBLANG_ITALIAN: return \"it_IT\";\n          case SUBLANG_ITALIAN_SWISS: return \"it_CH\";\n          }\n        return \"it\";\n      case LANG_JAPANESE:\n        switch (sub)\n          {\n          case SUBLANG_JAPANESE_JAPAN: return \"ja_JP\";\n          }\n        return \"ja\";\n      case LANG_KANNADA:\n        switch (sub)\n          {\n          case SUBLANG_KANNADA_INDIA: return \"kn_IN\";\n          }\n        return \"kn\";\n      case LANG_KANURI:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"kr_NG\";\n          }\n        return \"kr\";\n      case LANG_KASHMIRI:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"ks_PK\";\n          case SUBLANG_KASHMIRI_INDIA: return \"ks_IN\";\n          }\n        return \"ks\";\n      case LANG_KAZAK:\n        switch (sub)\n          {\n          case SUBLANG_KAZAK_KAZAKHSTAN: return \"kk_KZ\";\n          }\n        return \"kk\";\n      case LANG_KICHE:\n        /* FIXME: Adjust this when such locales appear on Unix.  */\n        switch (sub)\n          {\n          case SUBLANG_KICHE_GUATEMALA: return \"qut_GT\";\n          }\n        return \"qut\";\n      case LANG_KINYARWANDA:\n        switch (sub)\n          {\n          case SUBLANG_KINYARWANDA_RWANDA: return \"rw_RW\";\n          }\n        return \"rw\";\n      case LANG_KONKANI:\n        /* FIXME: Adjust this when such locales appear on Unix.  */\n        switch (sub)\n          {\n          case SUBLANG_KONKANI_INDIA: return \"kok_IN\";\n          }\n        return \"kok\";\n      case LANG_KOREAN:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"ko_KR\";\n          }\n        return \"ko\";\n      case LANG_KYRGYZ:\n        switch (sub)\n          {\n          case SUBLANG_KYRGYZ_KYRGYZSTAN: return \"ky_KG\";\n          }\n        return \"ky\";\n      case LANG_LAO:\n        switch (sub)\n          {\n          case SUBLANG_LAO_LAOS: return \"lo_LA\";\n          }\n        return \"lo\";\n      case LANG_LATIN:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"la_VA\";\n          }\n        return \"la\";\n      case LANG_LATVIAN:\n        switch (sub)\n          {\n          case SUBLANG_LATVIAN_LATVIA: return \"lv_LV\";\n          }\n        return \"lv\";\n      case LANG_LITHUANIAN:\n        switch (sub)\n          {\n          case SUBLANG_LITHUANIAN_LITHUANIA: return \"lt_LT\";\n          }\n        return \"lt\";\n      case LANG_LUXEMBOURGISH:\n        switch (sub)\n          {\n          case SUBLANG_LUXEMBOURGISH_LUXEMBOURG: return \"lb_LU\";\n          }\n        return \"lb\";\n      case LANG_MACEDONIAN:\n        switch (sub)\n          {\n          case SUBLANG_MACEDONIAN_MACEDONIA: return \"mk_MK\";\n          }\n        return \"mk\";\n      case LANG_MALAY:\n        switch (sub)\n          {\n          case SUBLANG_MALAY_MALAYSIA: return \"ms_MY\";\n          case SUBLANG_MALAY_BRUNEI_DARUSSALAM: return \"ms_BN\";\n          }\n        return \"ms\";\n      case LANG_MALAYALAM:\n        switch (sub)\n          {\n          case SUBLANG_MALAYALAM_INDIA: return \"ml_IN\";\n          }\n        return \"ml\";\n      case LANG_MALTESE:\n        switch (sub)\n          {\n          case SUBLANG_MALTESE_MALTA: return \"mt_MT\";\n          }\n        return \"mt\";\n      case LANG_MANIPURI:\n        /* FIXME: Adjust this when such locales appear on Unix.  */\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"mni_IN\";\n          }\n        return \"mni\";\n      case LANG_MAORI:\n        switch (sub)\n          {\n          case SUBLANG_MAORI_NEW_ZEALAND: return \"mi_NZ\";\n          }\n        return \"mi\";\n      case LANG_MAPUDUNGUN:\n        switch (sub)\n          {\n          case SUBLANG_MAPUDUNGUN_CHILE: return \"arn_CL\";\n          }\n        return \"arn\";\n      case LANG_MARATHI:\n        switch (sub)\n          {\n          case SUBLANG_MARATHI_INDIA: return \"mr_IN\";\n          }\n        return \"mr\";\n      case LANG_MOHAWK:\n        switch (sub)\n          {\n          case SUBLANG_MOHAWK_CANADA: return \"moh_CA\";\n          }\n        return \"moh\";\n      case LANG_MONGOLIAN:\n        switch (sub)\n          {\n          case SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA: case 0x1e: return \"mn_MN\";\n          case SUBLANG_MONGOLIAN_PRC: case 0x1f: return \"mn_CN\";\n          }\n        return \"mn\"; /* Ambiguous: could be \"mn_CN\" or \"mn_MN\".  */\n      case LANG_NEPALI:\n        switch (sub)\n          {\n          case SUBLANG_NEPALI_NEPAL: return \"ne_NP\";\n          case SUBLANG_NEPALI_INDIA: return \"ne_IN\";\n          }\n        return \"ne\";\n      case LANG_NORWEGIAN:\n        switch (sub)\n          {\n          case 0x1f: return \"nb\";\n          case SUBLANG_NORWEGIAN_BOKMAL: return \"nb_NO\";\n          case 0x1e: return \"nn\";\n          case SUBLANG_NORWEGIAN_NYNORSK: return \"nn_NO\";\n          }\n        return \"no\";\n      case LANG_OCCITAN:\n        switch (sub)\n          {\n          case SUBLANG_OCCITAN_FRANCE: return \"oc_FR\";\n          }\n        return \"oc\";\n      case LANG_ORIYA:\n        switch (sub)\n          {\n          case SUBLANG_ORIYA_INDIA: return \"or_IN\";\n          }\n        return \"or\";\n      case LANG_OROMO:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"om_ET\";\n          }\n        return \"om\";\n      case LANG_PAPIAMENTU:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"pap_AN\";\n          }\n        return \"pap\";\n      case LANG_PASHTO:\n        switch (sub)\n          {\n          case SUBLANG_PASHTO_AFGHANISTAN: return \"ps_AF\";\n          }\n        return \"ps\"; /* Ambiguous: could be \"ps_PK\" or \"ps_AF\".  */\n      case LANG_POLISH:\n        switch (sub)\n          {\n          case SUBLANG_POLISH_POLAND: return \"pl_PL\";\n          }\n        return \"pl\";\n      case LANG_PORTUGUESE:\n        switch (sub)\n          {\n          /* Hmm. SUBLANG_PORTUGUESE_BRAZILIAN == SUBLANG_DEFAULT.\n             Same phenomenon as SUBLANG_ENGLISH_US == SUBLANG_DEFAULT. */\n          case SUBLANG_PORTUGUESE_BRAZILIAN: return \"pt_BR\";\n          case SUBLANG_PORTUGUESE: return \"pt_PT\";\n          }\n        return \"pt\";\n      case LANG_PUNJABI:\n        switch (sub)\n          {\n          case SUBLANG_PUNJABI_INDIA: return \"pa_IN\"; /* Gurmukhi script */\n          case SUBLANG_PUNJABI_PAKISTAN: return \"pa_PK\"; /* Arabic script */\n          }\n        return \"pa\";\n      case LANG_QUECHUA:\n        /* Note: Microsoft uses the non-ISO language code \"quz\".  */\n        switch (sub)\n          {\n          case SUBLANG_QUECHUA_BOLIVIA: return \"qu_BO\";\n          case SUBLANG_QUECHUA_ECUADOR: return \"qu_EC\";\n          case SUBLANG_QUECHUA_PERU: return \"qu_PE\";\n          }\n        return \"qu\";\n      case LANG_ROMANIAN:\n        switch (sub)\n          {\n          case SUBLANG_ROMANIAN_ROMANIA: return \"ro_RO\";\n          case SUBLANG_ROMANIAN_MOLDOVA: return \"ro_MD\";\n          }\n        return \"ro\";\n      case LANG_ROMANSH:\n        switch (sub)\n          {\n          case SUBLANG_ROMANSH_SWITZERLAND: return \"rm_CH\";\n          }\n        return \"rm\";\n      case LANG_RUSSIAN:\n        switch (sub)\n          {\n          case SUBLANG_RUSSIAN_RUSSIA: return \"ru_RU\";\n          case SUBLANG_RUSSIAN_MOLDAVIA: return \"ru_MD\";\n          }\n        return \"ru\"; /* Ambiguous: could be \"ru_RU\" or \"ru_UA\" or \"ru_MD\".  */\n      case LANG_SAMI:\n        switch (sub)\n          {\n          /* Northern Sami */\n          case 0x00: return \"se\";\n          case SUBLANG_SAMI_NORTHERN_NORWAY: return \"se_NO\";\n          case SUBLANG_SAMI_NORTHERN_SWEDEN: return \"se_SE\";\n          case SUBLANG_SAMI_NORTHERN_FINLAND: return \"se_FI\";\n          /* Lule Sami */\n          case 0x1f: return \"smj\";\n          case SUBLANG_SAMI_LULE_NORWAY: return \"smj_NO\";\n          case SUBLANG_SAMI_LULE_SWEDEN: return \"smj_SE\";\n          /* Southern Sami */\n          case 0x1e: return \"sma\";\n          case SUBLANG_SAMI_SOUTHERN_NORWAY: return \"sma_NO\";\n          case SUBLANG_SAMI_SOUTHERN_SWEDEN: return \"sma_SE\";\n          /* Skolt Sami */\n          case 0x1d: return \"sms\";\n          case SUBLANG_SAMI_SKOLT_FINLAND: return \"sms_FI\";\n          /* Inari Sami */\n          case 0x1c: return \"smn\";\n          case SUBLANG_SAMI_INARI_FINLAND: return \"smn_FI\";\n          }\n        return \"se\"; /* or \"smi\"? */\n      case LANG_SANSKRIT:\n        switch (sub)\n          {\n          case SUBLANG_SANSKRIT_INDIA: return \"sa_IN\";\n          }\n        return \"sa\";\n      case LANG_SCOTTISH_GAELIC:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"gd_GB\";\n          }\n        return \"gd\";\n      case LANG_SINDHI:\n        switch (sub)\n          {\n          case SUBLANG_SINDHI_INDIA: return \"sd_IN\";\n          case SUBLANG_SINDHI_PAKISTAN: return \"sd_PK\";\n          /*case SUBLANG_SINDHI_AFGHANISTAN: return \"sd_AF\";*/\n          }\n        return \"sd\";\n      case LANG_SINHALESE:\n        switch (sub)\n          {\n          case SUBLANG_SINHALESE_SRI_LANKA: return \"si_LK\";\n          }\n        return \"si\";\n      case LANG_SLOVAK:\n        switch (sub)\n          {\n          case SUBLANG_SLOVAK_SLOVAKIA: return \"sk_SK\";\n          }\n        return \"sk\";\n      case LANG_SLOVENIAN:\n        switch (sub)\n          {\n          case SUBLANG_SLOVENIAN_SLOVENIA: return \"sl_SI\";\n          }\n        return \"sl\";\n      case LANG_SOMALI:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"so_SO\";\n          }\n        return \"so\";\n      case LANG_SORBIAN:\n        /* FIXME: Adjust this when such locales appear on Unix.  */\n        switch (sub)\n          {\n          /* Upper Sorbian */\n          case 0x00: return \"hsb\";\n          case SUBLANG_UPPER_SORBIAN_GERMANY: return \"hsb_DE\";\n          /* Lower Sorbian */\n          case 0x1f: return \"dsb\";\n          case SUBLANG_LOWER_SORBIAN_GERMANY: return \"dsb_DE\";\n          }\n        return \"wen\";\n      case LANG_SOTHO:\n        /* <https://msdn.microsoft.com/en-us/library/dd318693.aspx> calls\n           it \"Sesotho sa Leboa\"; according to\n           <https://www.ethnologue.com/show_language.asp?code=nso>\n           <https://www.ethnologue.com/show_language.asp?code=sot>\n           it's the same as Northern Sotho.  */\n        switch (sub)\n          {\n          case SUBLANG_SOTHO_SOUTH_AFRICA: return \"nso_ZA\";\n          }\n        return \"nso\";\n      case LANG_SPANISH:\n        switch (sub)\n          {\n          case SUBLANG_SPANISH: return \"es_ES\";\n          case SUBLANG_SPANISH_MEXICAN: return \"es_MX\";\n          case SUBLANG_SPANISH_MODERN:\n            return \"es_ES@modern\";      /* not seen on Unix */\n          case SUBLANG_SPANISH_GUATEMALA: return \"es_GT\";\n          case SUBLANG_SPANISH_COSTA_RICA: return \"es_CR\";\n          case SUBLANG_SPANISH_PANAMA: return \"es_PA\";\n          case SUBLANG_SPANISH_DOMINICAN_REPUBLIC: return \"es_DO\";\n          case SUBLANG_SPANISH_VENEZUELA: return \"es_VE\";\n          case SUBLANG_SPANISH_COLOMBIA: return \"es_CO\";\n          case SUBLANG_SPANISH_PERU: return \"es_PE\";\n          case SUBLANG_SPANISH_ARGENTINA: return \"es_AR\";\n          case SUBLANG_SPANISH_ECUADOR: return \"es_EC\";\n          case SUBLANG_SPANISH_CHILE: return \"es_CL\";\n          case SUBLANG_SPANISH_URUGUAY: return \"es_UY\";\n          case SUBLANG_SPANISH_PARAGUAY: return \"es_PY\";\n          case SUBLANG_SPANISH_BOLIVIA: return \"es_BO\";\n          case SUBLANG_SPANISH_EL_SALVADOR: return \"es_SV\";\n          case SUBLANG_SPANISH_HONDURAS: return \"es_HN\";\n          case SUBLANG_SPANISH_NICARAGUA: return \"es_NI\";\n          case SUBLANG_SPANISH_PUERTO_RICO: return \"es_PR\";\n          case SUBLANG_SPANISH_US: return \"es_US\";\n          }\n        return \"es\";\n      case LANG_SUTU:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"bnt_TZ\"; /* or \"st_LS\" or \"nso_ZA\"? */\n          }\n        return \"bnt\";\n      case LANG_SWAHILI:\n        switch (sub)\n          {\n          case SUBLANG_SWAHILI_KENYA: return \"sw_KE\";\n          }\n        return \"sw\";\n      case LANG_SWEDISH:\n        switch (sub)\n          {\n          case SUBLANG_SWEDISH_SWEDEN: return \"sv_SE\";\n          case SUBLANG_SWEDISH_FINLAND: return \"sv_FI\";\n          }\n        return \"sv\";\n      case LANG_SYRIAC:\n        switch (sub)\n          {\n          case SUBLANG_SYRIAC_SYRIA: return \"syr_SY\"; /* An extinct language.  */\n          }\n        return \"syr\";\n      case LANG_TAGALOG:\n        switch (sub)\n          {\n          case SUBLANG_TAGALOG_PHILIPPINES: return \"tl_PH\"; /* or \"fil_PH\"? */\n          }\n        return \"tl\"; /* or \"fil\"? */\n      case LANG_TAJIK:\n        switch (sub)\n          {\n          case 0x1f: return \"tg\";\n          case SUBLANG_TAJIK_TAJIKISTAN: return \"tg_TJ\";\n          }\n        return \"tg\";\n      case LANG_TAMAZIGHT:\n        /* Note: Microsoft uses the non-ISO language code \"tmz\".  */\n        switch (sub)\n          {\n          /* FIXME: Adjust this when Tamazight locales appear on Unix.  */\n          case SUBLANG_TAMAZIGHT_ARABIC: return \"ber_MA@arabic\";\n          case 0x1f: return \"ber@latin\";\n          case SUBLANG_TAMAZIGHT_ALGERIA_LATIN: return \"ber_DZ@latin\";\n          }\n        return \"ber\";\n      case LANG_TAMIL:\n        switch (sub)\n          {\n          case SUBLANG_TAMIL_INDIA: return \"ta_IN\";\n          }\n        return \"ta\"; /* Ambiguous: could be \"ta_IN\" or \"ta_LK\" or \"ta_SG\".  */\n      case LANG_TATAR:\n        switch (sub)\n          {\n          case SUBLANG_TATAR_RUSSIA: return \"tt_RU\";\n          }\n        return \"tt\";\n      case LANG_TELUGU:\n        switch (sub)\n          {\n          case SUBLANG_TELUGU_INDIA: return \"te_IN\";\n          }\n        return \"te\";\n      case LANG_THAI:\n        switch (sub)\n          {\n          case SUBLANG_THAI_THAILAND: return \"th_TH\";\n          }\n        return \"th\";\n      case LANG_TIBETAN:\n        switch (sub)\n          {\n          case SUBLANG_TIBETAN_PRC:\n            /* Most Tibetans would not like \"bo_CN\".  But Tibet does not yet\n               have a country code of its own.  */\n            return \"bo\";\n          case SUBLANG_TIBETAN_BHUTAN: return \"bo_BT\";\n          }\n        return \"bo\";\n      case LANG_TIGRINYA:\n        switch (sub)\n          {\n          case SUBLANG_TIGRINYA_ETHIOPIA: return \"ti_ET\";\n          case SUBLANG_TIGRINYA_ERITREA: return \"ti_ER\";\n          }\n        return \"ti\";\n      case LANG_TSONGA:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"ts_ZA\";\n          }\n        return \"ts\";\n      case LANG_TSWANA:\n        /* Spoken in South Africa, Botswana.  */\n        switch (sub)\n          {\n          case SUBLANG_TSWANA_SOUTH_AFRICA: return \"tn_ZA\";\n          }\n        return \"tn\";\n      case LANG_TURKISH:\n        switch (sub)\n          {\n          case SUBLANG_TURKISH_TURKEY: return \"tr_TR\";\n          }\n        return \"tr\";\n      case LANG_TURKMEN:\n        switch (sub)\n          {\n          case SUBLANG_TURKMEN_TURKMENISTAN: return \"tk_TM\";\n          }\n        return \"tk\";\n      case LANG_UIGHUR:\n        switch (sub)\n          {\n          case SUBLANG_UIGHUR_PRC: return \"ug_CN\";\n          }\n        return \"ug\";\n      case LANG_UKRAINIAN:\n        switch (sub)\n          {\n          case SUBLANG_UKRAINIAN_UKRAINE: return \"uk_UA\";\n          }\n        return \"uk\";\n      case LANG_URDU:\n        switch (sub)\n          {\n          case SUBLANG_URDU_PAKISTAN: return \"ur_PK\";\n          case SUBLANG_URDU_INDIA: return \"ur_IN\";\n          }\n        return \"ur\";\n      case LANG_UZBEK:\n        switch (sub)\n          {\n          case 0x1f: return \"uz\";\n          case SUBLANG_UZBEK_LATIN: return \"uz_UZ\";\n          case 0x1e: return \"uz@cyrillic\";\n          case SUBLANG_UZBEK_CYRILLIC: return \"uz_UZ@cyrillic\";\n          }\n        return \"uz\";\n      case LANG_VENDA:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"ve_ZA\";\n          }\n        return \"ve\";\n      case LANG_VIETNAMESE:\n        switch (sub)\n          {\n          case SUBLANG_VIETNAMESE_VIETNAM: return \"vi_VN\";\n          }\n        return \"vi\";\n      case LANG_WELSH:\n        switch (sub)\n          {\n          case SUBLANG_WELSH_UNITED_KINGDOM: return \"cy_GB\";\n          }\n        return \"cy\";\n      case LANG_WOLOF:\n        switch (sub)\n          {\n          case SUBLANG_WOLOF_SENEGAL: return \"wo_SN\";\n          }\n        return \"wo\";\n      case LANG_XHOSA:\n        switch (sub)\n          {\n          case SUBLANG_XHOSA_SOUTH_AFRICA: return \"xh_ZA\";\n          }\n        return \"xh\";\n      case LANG_YAKUT:\n        switch (sub)\n          {\n          case SUBLANG_YAKUT_RUSSIA: return \"sah_RU\";\n          }\n        return \"sah\";\n      case LANG_YI:\n        switch (sub)\n          {\n          case SUBLANG_YI_PRC: return \"ii_CN\";\n          }\n        return \"ii\";\n      case LANG_YIDDISH:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"yi_IL\";\n          }\n        return \"yi\";\n      case LANG_YORUBA:\n        switch (sub)\n          {\n          case SUBLANG_YORUBA_NIGERIA: return \"yo_NG\";\n          }\n        return \"yo\";\n      case LANG_ZULU:\n        switch (sub)\n          {\n          case SUBLANG_ZULU_SOUTH_AFRICA: return \"zu_ZA\";\n          }\n        return \"zu\";\n      default: return \"C\";\n      }\n  }\n}",
      "lines": 1044,
      "depth": 12,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_from_win32_LANGID (LANGID langid)",
        "*"
      ]
    },
    "gl_locale_name_from_win32_LCID": {
      "start_point": [
        2517,
        0
      ],
      "end_point": [
        2526,
        1
      ],
      "content": "const char *\ngl_locale_name_from_win32_LCID (LCID lcid)\n{\n  LANGID langid;\n\n  /* Strip off the sorting rules, keep only the language part.  */\n  langid = LANGIDFROMLCID (lcid);\n\n  return gl_locale_name_from_win32_LANGID (langid);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_from_win32_LCID (LCID lcid)",
        "*"
      ]
    },
    "enum_locales_fn": {
      "start_point": [
        2536,
        0
      ],
      "end_point": [
        2562,
        1
      ],
      "content": "static BOOL CALLBACK\nenum_locales_fn (LPTSTR locale_num_str)\n{\n  char *endp;\n  char locval[2 * LOCALE_NAME_MAX_LENGTH + 1 + 1];\n  LCID try_lcid = strtoul (locale_num_str, &endp, 16);\n\n  if (GetLocaleInfo (try_lcid, LOCALE_SENGLANGUAGE,\n                    locval, LOCALE_NAME_MAX_LENGTH))\n    {\n      strcat (locval, \"_\");\n      if (GetLocaleInfo (try_lcid, LOCALE_SENGCOUNTRY,\n                        locval + strlen (locval), LOCALE_NAME_MAX_LENGTH))\n       {\n         size_t locval_len = strlen (locval);\n\n         if (strncmp (locval, lname, locval_len) == 0\n             && (lname[locval_len] == '.'\n                 || lname[locval_len] == '\\0'))\n           {\n             found_lcid = try_lcid;\n             return FALSE;\n           }\n       }\n    }\n  return TRUE;\n}",
      "lines": 27,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "BOOL",
        "CALLBACK",
        "CALLBACK"
      ]
    },
    "get_lcid": {
      "start_point": [
        2571,
        0
      ],
      "end_point": [
        2597,
        1
      ],
      "content": "static LCID\nget_lcid (const char *locale_name)\n{\n  /* A simple cache.  */\n  static LCID last_lcid;\n  static char last_locale[1000];\n\n  /* Lock while looking for an LCID, to protect access to static\n     variables: last_lcid, last_locale, found_lcid, and lname.  */\n  gl_lock_lock (get_lcid_lock);\n  if (last_lcid > 0 && strcmp (locale_name, last_locale) == 0)\n    {\n      gl_lock_unlock (get_lcid_lock);\n      return last_lcid;\n    }\n  strncpy (lname, locale_name, sizeof (lname) - 1);\n  lname[sizeof (lname) - 1] = '\\0';\n  found_lcid = 0;\n  EnumSystemLocales (enum_locales_fn, LCID_SUPPORTED);\n  if (found_lcid > 0)\n    {\n      last_lcid = found_lcid;\n      strcpy (last_locale, locale_name);\n    }\n  gl_lock_unlock (get_lcid_lock);\n  return found_lcid;\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "LCID"
      ]
    },
    "string_hash": {
      "start_point": [
        2613,
        0
      ],
      "end_point": [
        2623,
        1
      ],
      "content": "static size_t _GL_ATTRIBUTE_PURE\nstring_hash (const void *x)\n{\n  const char *s = (const char *) x;\n  size_t h = 0;\n\n  for (; *s; s++)\n    h = *s + ((h << 9) | (h >> (SIZE_BITS - 9)));\n\n  return h;\n}",
      "lines": 11,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "size_t",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "struniq": {
      "start_point": [
        2645,
        0
      ],
      "end_point": [
        2683,
        1
      ],
      "content": "static const char *\nstruniq (const char *string)\n{\n  size_t hashcode = string_hash (string);\n  size_t slot = hashcode % HASH_TABLE_SIZE;\n  size_t size;\n  struct hash_node *new_node;\n  struct hash_node *p;\n  for (p = struniq_hash_table[slot]; p != NULL; p = p->next)\n    if (strcmp (p->contents, string) == 0)\n      return p->contents;\n  size = strlen (string) + 1;\n  new_node =\n    (struct hash_node *)\n    malloc (FLEXSIZEOF (struct hash_node, contents, size));\n  if (new_node == NULL)\n    /* Out of memory.  Return a statically allocated string.  */\n    return \"C\";\n  memcpy (new_node->contents, string, size);\n  /* Lock while inserting new_node.  */\n  gl_lock_lock (struniq_lock);\n  /* Check whether another thread already added the string while we were\n     waiting on the lock.  */\n  for (p = struniq_hash_table[slot]; p != NULL; p = p->next)\n    if (strcmp (p->contents, string) == 0)\n      {\n        free (new_node);\n        new_node = p;\n        goto done;\n      }\n  /* Really insert new_node into the hash table.  Fill new_node entirely first,\n     because other threads may be iterating over the linked list.  */\n  new_node->next = struniq_hash_table[slot];\n  struniq_hash_table[slot] = new_node;\n done:\n  /* Unlock after new_node is inserted.  */\n  gl_lock_unlock (struniq_lock);\n  return new_node->contents;\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nstruniq (const char *string)",
        "*"
      ]
    },
    "gl_locale_name_thread_unsafe": {
      "start_point": [
        2695,
        0
      ],
      "end_point": [
        2786,
        1
      ],
      "content": "const char *\ngl_locale_name_thread_unsafe (int category, const char *categoryname)\n{\n# if HAVE_USELOCALE\n  {\n    locale_t thread_locale = uselocale (NULL);\n    if (thread_locale != LC_GLOBAL_LOCALE)\n      {\n#  if __GLIBC__ >= 2 && !defined __UCLIBC__\n        /* Work around an incorrect definition of the _NL_LOCALE_NAME macro in\n           glibc < 2.12.\n           See <https://sourceware.org/bugzilla/show_bug.cgi?id=10968>.  */\n        const char *name =\n          nl_langinfo (_NL_ITEM ((category), _NL_ITEM_INDEX (-1)));\n        if (name[0] == '\\0')\n          /* Fallback code for glibc < 2.4, which did not implement\n             nl_langinfo (_NL_LOCALE_NAME (category)).  */\n          name = thread_locale->__names[category];\n        return name;\n#  elif defined __linux__ && HAVE_LANGINFO_H && defined NL_LOCALE_NAME\n        /* musl libc */\n        return nl_langinfo_l (NL_LOCALE_NAME (category), thread_locale);\n#  elif (defined __FreeBSD__ || defined __DragonFly__) || (defined __APPLE__ && defined __MACH__)\n        /* FreeBSD, Mac OS X */\n        int mask;\n\n        switch (category)\n          {\n          case LC_CTYPE:\n            mask = LC_CTYPE_MASK;\n            break;\n          case LC_NUMERIC:\n            mask = LC_NUMERIC_MASK;\n            break;\n          case LC_TIME:\n            mask = LC_TIME_MASK;\n            break;\n          case LC_COLLATE:\n            mask = LC_COLLATE_MASK;\n            break;\n          case LC_MONETARY:\n            mask = LC_MONETARY_MASK;\n            break;\n          case LC_MESSAGES:\n            mask = LC_MESSAGES_MASK;\n            break;\n          default: /* We shouldn't get here.  */\n            return \"\";\n          }\n        return querylocale (mask, thread_locale);\n#  elif defined __sun\n#   if HAVE_GETLOCALENAME_L\n        /* Solaris >= 12.  */\n        return getlocalename_l (category, thread_locale);\n#   else\n        /* Solaris 11 OpenIndiana.\n           For the internal structure of locale objects, see\n           https://github.com/OpenIndiana/illumos-gate/blob/master/usr/src/lib/libc/port/locale/localeimpl.h  */\n        switch (category)\n          {\n          case LC_CTYPE:\n          case LC_NUMERIC:\n          case LC_TIME:\n          case LC_COLLATE:\n          case LC_MONETARY:\n          case LC_MESSAGES:\n            return ((const char * const *) thread_locale)[category];\n          default: /* We shouldn't get here.  */\n            return \"\";\n          }\n#   endif\n#  elif defined __CYGWIN__\n        /* Cygwin < 2.6 lacks uselocale and thread-local locales altogether.\n           Cygwin <= 2.6.1 lacks NL_LOCALE_NAME, requiring peeking inside\n           an opaque struct.  */\n#   ifdef NL_LOCALE_NAME\n        return nl_langinfo_l (NL_LOCALE_NAME (category), thread_locale);\n#   else\n        /* FIXME: Remove when we can assume new-enough Cygwin.  */\n        struct __locale_t {\n          char categories[7][32];\n        };\n        return ((struct __locale_t *) thread_locale)->categories[category];\n#   endif\n#  elif defined __ANDROID__\n        return MB_CUR_MAX == 4 ? \"C.UTF-8\" : \"C\";\n#  endif\n      }\n  }\n# endif\n  return NULL;\n}",
      "lines": 92,
      "depth": 23,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_thread_unsafe (int category, const char *categoryname)",
        "*"
      ]
    },
    "gl_locale_name_thread": {
      "start_point": [
        2790,
        0
      ],
      "end_point": [
        2802,
        1
      ],
      "content": "const char *\ngl_locale_name_thread (int category, const char *categoryname)\n{\n#if HAVE_USELOCALE\n  const char *name = gl_locale_name_thread_unsafe (category, categoryname);\n  if (name != NULL)\n    return struniq (name);\n#endif\n  /* On WINDOWS_NATIVE, don't use GetThreadLocale() here, because when\n     SetThreadLocale has not been called - which is a very frequent case -\n     the value of GetThreadLocale() ignores past calls to 'setlocale'.  */\n  return NULL;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_thread (int category, const char *categoryname)",
        "*"
      ]
    },
    "gl_locale_name_posix": {
      "start_point": [
        2814,
        0
      ],
      "end_point": [
        2863,
        1
      ],
      "content": "const char *\ngl_locale_name_posix (int category, const char *categoryname)\n{\n#if defined WINDOWS_NATIVE\n  if (LC_MIN <= category && category <= LC_MAX)\n    {\n      char *locname = setlocale (category, NULL);\n      LCID lcid = 0;\n\n      /* If CATEGORY is LC_ALL, the result might be a semi-colon\n        separated list of locales.  We need only one, so we take the\n        one corresponding to LC_CTYPE, as the most important for\n        character translations.  */\n      if (category == LC_ALL && strchr (locname, ';'))\n        locname = setlocale (LC_CTYPE, NULL);\n\n      /* Convert locale name to LCID.  We don't want to use\n         LocaleNameToLCID because (a) it is only available since Vista,\n         and (b) it doesn't accept locale names returned by 'setlocale'.  */\n      lcid = get_lcid (locname);\n\n      if (lcid > 0)\n        return gl_locale_name_from_win32_LCID (lcid);\n    }\n#endif\n  /* Use the POSIX methods of looking to 'LC_ALL', 'LC_xxx', and 'LANG'.\n     On some systems this can be done by the 'setlocale' function itself.  */\n#if defined HAVE_SETLOCALE && defined HAVE_LC_MESSAGES && defined HAVE_LOCALE_NULL\n  return setlocale (category, NULL);\n#else\n  /* On other systems we ignore what setlocale reports and instead look at the\n     environment variables directly.  This is necessary\n       1. on systems which have a facility for customizing the default locale\n          (Mac OS X, native Windows, Cygwin) and where the system's setlocale()\n          function ignores this default locale (Mac OS X, Cygwin), in two cases:\n          a. when the user missed to use the setlocale() override from libintl\n             (for example by not including <libintl.h>),\n          b. when setlocale supports only the \"C\" locale, such as on Cygwin\n             1.5.x.  In this case even the override from libintl cannot help.\n       2. on all systems where setlocale supports only the \"C\" locale.  */\n  /* Strictly speaking, it is a POSIX violation to look at the environment\n     variables regardless whether setlocale has been called or not.  POSIX\n     says:\n         \"For C-language programs, the POSIX locale shall be the\n          default locale when the setlocale() function is not called.\"\n     But we assume that all programs that use internationalized APIs call\n     setlocale (LC_ALL, \"\").  */\n  return gl_locale_name_environ (category, categoryname);\n#endif\n}",
      "lines": 50,
      "depth": 12,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_posix (int category, const char *categoryname)",
        "*"
      ]
    },
    "gl_locale_name_environ": {
      "start_point": [
        2865,
        0
      ],
      "end_point": [
        2896,
        1
      ],
      "content": "const char *\ngl_locale_name_environ (int category, const char *categoryname)\n{\n  const char *retval;\n\n  /* Setting of LC_ALL overrides all other.  */\n  retval = getenv (\"LC_ALL\");\n  if (retval != NULL && retval[0] != '\\0')\n    return retval;\n  /* Next comes the name of the desired category.  */\n  retval = getenv (categoryname);\n  if (retval != NULL && retval[0] != '\\0')\n    return retval;\n  /* Last possibility is the LANG environment variable.  */\n  retval = getenv (\"LANG\");\n  if (retval != NULL && retval[0] != '\\0')\n    {\n#if HAVE_CFLOCALECOPYCURRENT || HAVE_CFPREFERENCESCOPYAPPVALUE\n      /* Mac OS X 10.2 or newer.\n         Ignore invalid LANG value set by the Terminal application.  */\n      if (strcmp (retval, \"UTF-8\") != 0)\n#endif\n#if defined __CYGWIN__\n      /* Cygwin.\n         Ignore dummy LANG value set by ~/.profile.  */\n      if (strcmp (retval, \"C.UTF-8\") != 0)\n#endif\n        return retval;\n    }\n\n  return NULL;\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_environ (int category, const char *categoryname)",
        "*"
      ]
    },
    "gl_locale_name_default": {
      "start_point": [
        2898,
        0
      ],
      "end_point": [
        2995,
        1
      ],
      "content": "const char *\ngl_locale_name_default (void)\n{\n  /* POSIX:2001 says:\n     \"All implementations shall define a locale as the default locale, to be\n      invoked when no environment variables are set, or set to the empty\n      string.  This default locale can be the POSIX locale or any other\n      implementation-defined locale.  Some implementations may provide\n      facilities for local installation administrators to set the default\n      locale, customizing it for each location.  POSIX:2001 does not require\n      such a facility.\n\n     The systems with such a facility are Mac OS X and Windows: They provide a\n     GUI that allows the user to choose a locale.\n       - On Mac OS X, by default, none of LC_* or LANG are set.  Starting with\n         Mac OS X 10.4 or 10.5, LANG is set for processes launched by the\n         'Terminal' application (but sometimes to an incorrect value \"UTF-8\").\n         When no environment variable is set, setlocale (LC_ALL, \"\") uses the\n         \"C\" locale.\n       - On native Windows, by default, none of LC_* or LANG are set.\n         When no environment variable is set, setlocale (LC_ALL, \"\") uses the\n         locale chosen by the user.\n       - On Cygwin 1.5.x, by default, none of LC_* or LANG are set.\n         When no environment variable is set, setlocale (LC_ALL, \"\") uses the\n         \"C\" locale.\n       - On Cygwin 1.7, by default, LANG is set to \"C.UTF-8\" when the default\n         ~/.profile is executed.\n         When no environment variable is set, setlocale (LC_ALL, \"\") uses the\n         \"C.UTF-8\" locale, which operates in the same way as the \"C\" locale.\n  */\n\n#if !(HAVE_CFLOCALECOPYCURRENT || HAVE_CFPREFERENCESCOPYAPPVALUE || defined WINDOWS_NATIVE || defined __CYGWIN__)\n\n  /* The system does not have a way of setting the locale, other than the\n     POSIX specified environment variables.  We use C as default locale.  */\n  return \"C\";\n\n#else\n\n  /* Return an XPG style locale name language[_territory][@modifier].\n     Don't even bother determining the codeset; it's not useful in this\n     context, because message catalogs are not specific to a single\n     codeset.  */\n\n# if HAVE_CFLOCALECOPYCURRENT || HAVE_CFPREFERENCESCOPYAPPVALUE\n  /* Mac OS X 10.2 or newer */\n  {\n    /* Cache the locale name, since CoreFoundation calls are expensive.  */\n    static const char *cached_localename;\n\n    if (cached_localename == NULL)\n      {\n        char namebuf[256];\n#  if HAVE_CFLOCALECOPYCURRENT /* Mac OS X 10.3 or newer */\n        CFLocaleRef locale = CFLocaleCopyCurrent ();\n        CFStringRef name = CFLocaleGetIdentifier (locale);\n\n        if (CFStringGetCString (name, namebuf, sizeof (namebuf),\n                                kCFStringEncodingASCII))\n          {\n            gl_locale_name_canonicalize (namebuf);\n            cached_localename = strdup (namebuf);\n          }\n        CFRelease (locale);\n#  elif HAVE_CFPREFERENCESCOPYAPPVALUE /* Mac OS X 10.2 or newer */\n        CFTypeRef value =\n          CFPreferencesCopyAppValue (CFSTR (\"AppleLocale\"),\n                                     kCFPreferencesCurrentApplication);\n        if (value != NULL\n            && CFGetTypeID (value) == CFStringGetTypeID ()\n            && CFStringGetCString ((CFStringRef)value,\n                                   namebuf, sizeof (namebuf),\n                                   kCFStringEncodingASCII))\n          {\n            gl_locale_name_canonicalize (namebuf);\n            cached_localename = strdup (namebuf);\n          }\n#  endif\n        if (cached_localename == NULL)\n          cached_localename = \"C\";\n      }\n    return cached_localename;\n  }\n\n# endif\n\n# if defined WINDOWS_NATIVE || defined __CYGWIN__ /* Native Windows or Cygwin */\n  {\n    LCID lcid;\n\n    /* Use native Windows API locale ID.  */\n    lcid = GetThreadLocale ();\n\n    return gl_locale_name_from_win32_LCID (lcid);\n  }\n# endif\n#endif\n}",
      "lines": 98,
      "depth": 18,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_default (void)",
        "*"
      ]
    },
    "gl_locale_name": {
      "start_point": [
        3003,
        0
      ],
      "end_point": [
        3017,
        1
      ],
      "content": "const char *\ngl_locale_name (int category, const char *categoryname)\n{\n  const char *retval;\n\n  retval = gl_locale_name_thread (category, categoryname);\n  if (retval != NULL)\n    return retval;\n\n  retval = gl_locale_name_posix (category, categoryname);\n  if (retval != NULL)\n    return retval;\n\n  return gl_locale_name_default ();\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name (int category, const char *categoryname)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/localename.h": {},
  "libunistring/libunistring-0.9.10/lib/malloc.c": {
    "rpl_malloc": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void *\nrpl_malloc (size_t n)\n{\n  void *result;\n\n#if NEED_MALLOC_GNU\n  if (n == 0)\n    n = 1;\n#endif\n\n  result = malloc (n);\n\n#if !HAVE_MALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "void",
        "*\nrpl_malloc (size_t n)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/malloca.c": {
    "mmalloca": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "void *\nmmalloca (size_t n)\n{\n#if HAVE_ALLOCA\n  /* Allocate one more word, used to determine the address to pass to freea(),\n     and room for the alignment \u00e2\u0089\u00a1 sa_alignment_max mod 2*sa_alignment_max.  */\n  size_t nplus = n + sizeof (small_t) + 2 * sa_alignment_max - 1;\n\n  if (nplus >= n)\n    {\n      char *mem = (char *) malloc (nplus);\n\n      if (mem != NULL)\n        {\n          char *p =\n            (char *)((((uintptr_t)mem + sizeof (small_t) + sa_alignment_max - 1)\n                      & ~(uintptr_t)(2 * sa_alignment_max - 1))\n                     + sa_alignment_max);\n          /* Here p >= mem + sizeof (small_t),\n             and p <= mem + sizeof (small_t) + 2 * sa_alignment_max - 1\n             hence p + n <= mem + nplus.\n             So, the memory range [p, p+n) lies in the allocated memory range\n             [mem, mem + nplus).  */\n          ((small_t *) p)[-1] = p - mem;\n          /* p \u00e2\u0089\u00a1 sa_alignment_max mod 2*sa_alignment_max.  */\n          return p;\n        }\n    }\n  /* Out of memory.  */\n  return NULL;\n#else\n# if !MALLOC_0_IS_NONNULL\n  if (n == 0)\n    n = 1;\n# endif\n  return malloc (n);\n#endif\n}",
      "lines": 38,
      "depth": 21,
      "decorators": [
        "void",
        "*\nmmalloca (size_t n)",
        "*"
      ]
    },
    "freea": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "void\nfreea (void *p)\n{\n  /* Check argument.  */\n  if ((uintptr_t) p & (sa_alignment_max - 1))\n    {\n      /* p was not the result of a malloca() call.  Invalid argument.  */\n      abort ();\n    }\n  /* Determine whether p was a non-NULL pointer returned by mmalloca().  */\n  if ((uintptr_t) p & sa_alignment_max)\n    {\n      void *mem = (char *) p - ((small_t *) p)[-1];\n      free (mem);\n    }\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/malloca.h": {},
  "libunistring/libunistring-0.9.10/lib/math.c": {},
  "libunistring/libunistring-0.9.10/lib/math.in.h": {
    "float": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "_GL_MATH_INLINE float\n_NaN ()\n{\n  static float zero = 0.0f;\n  return zero / zero;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "_GL_MATH_INLINE"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/mbchar.c": {},
  "libunistring/libunistring-0.9.10/lib/mbchar.h": {
    "mb_width_aux": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "MBCHAR_INLINE int\nmb_width_aux (wint_t wc)\n{\n  int w = wcwidth (wc);\n  /* For unprintable characters, arbitrarily return 0 for control characters\n     and MB_UNPRINTABLE_WIDTH otherwise.  */\n  return (w >= 0 ? w : iswcntrl (wc) ? 0 : MB_UNPRINTABLE_WIDTH);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "MBCHAR_INLINE",
        "int",
        "int"
      ]
    },
    "mb_copy": {
      "start_point": [
        275,
        0
      ],
      "end_point": [
        288,
        1
      ],
      "content": "MBCHAR_INLINE void\nmb_copy (mbchar_t *new_mbc, const mbchar_t *old_mbc)\n{\n  if (old_mbc->ptr == &old_mbc->buf[0])\n    {\n      memcpy (&new_mbc->buf[0], &old_mbc->buf[0], old_mbc->bytes);\n      new_mbc->ptr = &new_mbc->buf[0];\n    }\n  else\n    new_mbc->ptr = old_mbc->ptr;\n  new_mbc->bytes = old_mbc->bytes;\n  if ((new_mbc->wc_valid = old_mbc->wc_valid))\n    new_mbc->wc = old_mbc->wc;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "MBCHAR_INLINE",
        "void",
        "void"
      ]
    },
    "is_basic": [
      {
        "start_point": [
          323,
          0
        ],
        "end_point": [
          328,
          1
        ],
        "content": "MBCHAR_INLINE bool\nis_basic (char c)\n{\n  return (is_basic_table [(unsigned char) c >> 5] >> ((unsigned char) c & 31))\n         & 1;\n}",
        "lines": 6,
        "depth": 12,
        "decorators": [
          "MBCHAR_INLINE",
          "bool",
          "bool"
        ]
      },
      {
        "start_point": [
          332,
          0
        ],
        "end_point": [
          362,
          1
        ],
        "content": "MBCHAR_INLINE bool\nis_basic (char c)\n{\n  switch (c)\n    {\n    case '\\t': case '\\v': case '\\f':\n    case ' ': case '!': case '\"': case '#': case '%':\n    case '&': case '\\'': case '(': case ')': case '*':\n    case '+': case ',': case '-': case '.': case '/':\n    case '0': case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9':\n    case ':': case ';': case '<': case '=': case '>':\n    case '?':\n    case 'A': case 'B': case 'C': case 'D': case 'E':\n    case 'F': case 'G': case 'H': case 'I': case 'J':\n    case 'K': case 'L': case 'M': case 'N': case 'O':\n    case 'P': case 'Q': case 'R': case 'S': case 'T':\n    case 'U': case 'V': case 'W': case 'X': case 'Y':\n    case 'Z':\n    case '[': case '\\\\': case ']': case '^': case '_':\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'i': case 'j':\n    case 'k': case 'l': case 'm': case 'n': case 'o':\n    case 'p': case 'q': case 'r': case 's': case 't':\n    case 'u': case 'v': case 'w': case 'x': case 'y':\n    case 'z': case '{': case '|': case '}': case '~':\n      return 1;\n    default:\n      return 0;\n    }\n}",
        "lines": 31,
        "depth": 7,
        "decorators": [
          "MBCHAR_INLINE",
          "bool",
          "bool"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/mbiter.c": {},
  "libunistring/libunistring-0.9.10/lib/mbiter.h": {
    "mbiter_multi_next": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "MBITER_INLINE void\nmbiter_multi_next (struct mbiter_multi *iter)\n{\n  if (iter->next_done)\n    return;\n  if (iter->in_shift)\n    goto with_shift;\n  /* Handle most ASCII characters quickly, without calling mbrtowc().  */\n  if (is_basic (*iter->cur.ptr))\n    {\n      /* These characters are part of the basic character set.  ISO C 99\n         guarantees that their wide character code is identical to their\n         char code.  */\n      iter->cur.bytes = 1;\n      iter->cur.wc = *iter->cur.ptr;\n      iter->cur.wc_valid = true;\n    }\n  else\n    {\n      assert (mbsinit (&iter->state));\n      iter->in_shift = true;\n    with_shift:\n      iter->cur.bytes = mbrtowc (&iter->cur.wc, iter->cur.ptr,\n                                 iter->limit - iter->cur.ptr, &iter->state);\n      if (iter->cur.bytes == (size_t) -1)\n        {\n          /* An invalid multibyte sequence was encountered.  */\n          iter->cur.bytes = 1;\n          iter->cur.wc_valid = false;\n          /* Whether to set iter->in_shift = false and reset iter->state\n             or not is not very important; the string is bogus anyway.  */\n        }\n      else if (iter->cur.bytes == (size_t) -2)\n        {\n          /* An incomplete multibyte character at the end.  */\n          iter->cur.bytes = iter->limit - iter->cur.ptr;\n          iter->cur.wc_valid = false;\n          /* Whether to set iter->in_shift = false and reset iter->state\n             or not is not important; the string end is reached anyway.  */\n        }\n      else\n        {\n          if (iter->cur.bytes == 0)\n            {\n              /* A null wide character was encountered.  */\n              iter->cur.bytes = 1;\n              assert (*iter->cur.ptr == '\\0');\n              assert (iter->cur.wc == 0);\n            }\n          iter->cur.wc_valid = true;\n\n          /* When in the initial state, we can go back treating ASCII\n             characters more quickly.  */\n          if (mbsinit (&iter->state))\n            iter->in_shift = false;\n        }\n    }\n  iter->next_done = true;\n}",
      "lines": 59,
      "depth": 17,
      "decorators": [
        "MBITER_INLINE",
        "void",
        "void"
      ]
    },
    "mbiter_multi_reloc": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "MBITER_INLINE void\nmbiter_multi_reloc (struct mbiter_multi *iter, ptrdiff_t ptrdiff)\n{\n  iter->cur.ptr += ptrdiff;\n  iter->limit += ptrdiff;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "MBITER_INLINE",
        "void",
        "void"
      ]
    },
    "mbiter_multi_copy": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        208,
        1
      ],
      "content": "MBITER_INLINE void\nmbiter_multi_copy (struct mbiter_multi *new_iter, const struct mbiter_multi *old_iter)\n{\n  new_iter->limit = old_iter->limit;\n  if ((new_iter->in_shift = old_iter->in_shift))\n    memcpy (&new_iter->state, &old_iter->state, sizeof (mbstate_t));\n  else\n    memset (&new_iter->state, 0, sizeof (mbstate_t));\n  new_iter->next_done = old_iter->next_done;\n  mb_copy (&new_iter->cur, &old_iter->cur);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "MBITER_INLINE",
        "void",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/mbrtowc.c": {
    "mbrtowc": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        341,
        1
      ],
      "content": "size_t\nmbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n  char *pstate = (char *)ps;\n\n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n\n  if (n == 0)\n    return (size_t)(-2);\n\n  /* Here n > 0.  */\n\n  if (pstate == NULL)\n    pstate = internal_state;\n\n  {\n    size_t nstate = pstate[0];\n    char buf[4];\n    const char *p;\n    size_t m;\n\n    switch (nstate)\n      {\n      case 0:\n        p = s;\n        m = n;\n        break;\n      case 3:\n        buf[2] = pstate[3];\n        FALLTHROUGH;\n      case 2:\n        buf[1] = pstate[2];\n        FALLTHROUGH;\n      case 1:\n        buf[0] = pstate[1];\n        p = buf;\n        m = nstate;\n        buf[m++] = s[0];\n        if (n >= 2 && m < 4)\n          {\n            buf[m++] = s[1];\n            if (n >= 3 && m < 4)\n              buf[m++] = s[2];\n          }\n        break;\n      default:\n        errno = EINVAL;\n        return (size_t)(-1);\n      }\n\n    /* Here m > 0.  */\n\n# if __GLIBC__ || defined __UCLIBC__\n    /* Work around bug <https://sourceware.org/bugzilla/show_bug.cgi?id=9674> */\n    mbtowc (NULL, NULL, 0);\n# endif\n    {\n      int res = mbtowc (pwc, p, m);\n\n      if (res >= 0)\n        {\n          if (pwc != NULL && ((*pwc == 0) != (res == 0)))\n            abort ();\n          if (nstate >= (res > 0 ? res : 1))\n            abort ();\n          res -= nstate;\n          pstate[0] = 0;\n          return res;\n        }\n\n      /* mbtowc does not distinguish between invalid and incomplete multibyte\n         sequences.  But mbrtowc needs to make this distinction.\n         There are two possible approaches:\n           - Use iconv() and its return value.\n           - Use built-in knowledge about the possible encodings.\n         Given the low quality of implementation of iconv() on the systems that\n         lack mbrtowc(), we use the second approach.\n         The possible encodings are:\n           - 8-bit encodings,\n           - EUC-JP, EUC-KR, GB2312, EUC-TW, BIG5, GB18030, SJIS,\n           - UTF-8.\n         Use specialized code for each.  */\n      if (m >= 4 || m >= MB_CUR_MAX)\n        goto invalid;\n      /* Here MB_CUR_MAX > 1 and 0 < m < 4.  */\n      {\n        const char *encoding = locale_charset ();\n\n        if (STREQ_OPT (encoding, \"UTF-8\", 'U', 'T', 'F', '-', '8', 0, 0, 0, 0))\n          {\n            /* Cf. unistr/u8-mblen.c.  */\n            unsigned char c = (unsigned char) p[0];\n\n            if (c >= 0xc2)\n              {\n                if (c < 0xe0)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                  }\n                else if (c < 0xf0)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                    if (m == 2)\n                      {\n                        unsigned char c2 = (unsigned char) p[1];\n\n                        if ((c2 ^ 0x80) < 0x40\n                            && (c >= 0xe1 || c2 >= 0xa0)\n                            && (c != 0xed || c2 < 0xa0))\n                          goto incomplete;\n                      }\n                  }\n                else if (c <= 0xf4)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                    else /* m == 2 || m == 3 */\n                      {\n                        unsigned char c2 = (unsigned char) p[1];\n\n                        if ((c2 ^ 0x80) < 0x40\n                            && (c >= 0xf1 || c2 >= 0x90)\n                            && (c < 0xf4 || (c == 0xf4 && c2 < 0x90)))\n                          {\n                            if (m == 2)\n                              goto incomplete;\n                            else /* m == 3 */\n                              {\n                                unsigned char c3 = (unsigned char) p[2];\n\n                                if ((c3 ^ 0x80) < 0x40)\n                                  goto incomplete;\n                              }\n                          }\n                      }\n                  }\n              }\n            goto invalid;\n          }\n\n        /* As a reference for this code, you can use the GNU libiconv\n           implementation.  Look for uses of the RET_TOOFEW macro.  */\n\n        if (STREQ_OPT (encoding,\n                       \"EUC-JP\", 'E', 'U', 'C', '-', 'J', 'P', 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0xa1 && c < 0xff) || c == 0x8e || c == 0x8f)\n                  goto incomplete;\n              }\n            if (m == 2)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c == 0x8f)\n                  {\n                    unsigned char c2 = (unsigned char) p[1];\n\n                    if (c2 >= 0xa1 && c2 < 0xff)\n                      goto incomplete;\n                  }\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"EUC-KR\", 'E', 'U', 'C', '-', 'K', 'R', 0, 0, 0)\n            || STREQ_OPT (encoding,\n                          \"GB2312\", 'G', 'B', '2', '3', '1', '2', 0, 0, 0)\n            || STREQ_OPT (encoding,\n                          \"BIG5\", 'B', 'I', 'G', '5', 0, 0, 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c >= 0xa1 && c < 0xff)\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"EUC-TW\", 'E', 'U', 'C', '-', 'T', 'W', 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0xa1 && c < 0xff) || c == 0x8e)\n                  goto incomplete;\n              }\n            else /* m == 2 || m == 3 */\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c == 0x8e)\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"GB18030\", 'G', 'B', '1', '8', '0', '3', '0', 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0x90 && c <= 0xe3) || (c >= 0xf8 && c <= 0xfe))\n                  goto incomplete;\n              }\n            else /* m == 2 || m == 3 */\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c >= 0x90 && c <= 0xe3)\n                  {\n                    unsigned char c2 = (unsigned char) p[1];\n\n                    if (c2 >= 0x30 && c2 <= 0x39)\n                      {\n                        if (m == 2)\n                          goto incomplete;\n                        else /* m == 3 */\n                          {\n                            unsigned char c3 = (unsigned char) p[2];\n\n                            if (c3 >= 0x81 && c3 <= 0xfe)\n                              goto incomplete;\n                          }\n                      }\n                  }\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding, \"SJIS\", 'S', 'J', 'I', 'S', 0, 0, 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0x81 && c <= 0x9f) || (c >= 0xe0 && c <= 0xea)\n                    || (c >= 0xf0 && c <= 0xf9))\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n\n        /* An unknown multibyte encoding.  */\n        goto incomplete;\n      }\n\n     incomplete:\n      {\n        size_t k = nstate;\n        /* Here 0 <= k < m < 4.  */\n        pstate[++k] = s[0];\n        if (k < m)\n          {\n            pstate[++k] = s[1];\n            if (k < m)\n              pstate[++k] = s[2];\n          }\n        if (k != m)\n          abort ();\n      }\n      pstate[0] = m;\n      return (size_t)(-2);\n\n     invalid:\n      errno = EILSEQ;\n      /* The conversion state is undefined, says POSIX.  */\n      return (size_t)(-1);\n    }\n  }\n}",
      "lines": 284,
      "depth": 25,
      "decorators": [
        "size_t"
      ]
    },
    "rpl_mbrtowc": {
      "start_point": [
        348,
        0
      ],
      "end_point": [
        420,
        1
      ],
      "content": "size_t\nrpl_mbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n  size_t ret;\n  wchar_t wc;\n\n# if MBRTOWC_NULL_ARG2_BUG || MBRTOWC_RETVAL_BUG || MBRTOWC_EMPTY_INPUT_BUG\n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n# endif\n\n# if MBRTOWC_EMPTY_INPUT_BUG\n  if (n == 0)\n    return (size_t) -2;\n# endif\n\n  if (! pwc)\n    pwc = &wc;\n\n# if MBRTOWC_RETVAL_BUG\n  {\n    static mbstate_t internal_state;\n\n    /* Override mbrtowc's internal state.  We cannot call mbsinit() on the\n       hidden internal state, but we can call it on our variable.  */\n    if (ps == NULL)\n      ps = &internal_state;\n\n    if (!mbsinit (ps))\n      {\n        /* Parse the rest of the multibyte character byte for byte.  */\n        size_t count = 0;\n        for (; n > 0; s++, n--)\n          {\n            ret = mbrtowc (&wc, s, 1, ps);\n\n            if (ret == (size_t)(-1))\n              return (size_t)(-1);\n            count++;\n            if (ret != (size_t)(-2))\n              {\n                /* The multibyte character has been completed.  */\n                *pwc = wc;\n                return (wc == 0 ? 0 : count);\n              }\n          }\n        return (size_t)(-2);\n      }\n  }\n# endif\n\n  ret = mbrtowc (pwc, s, n, ps);\n\n# if MBRTOWC_NUL_RETVAL_BUG\n  if (ret < (size_t) -2 && !*pwc)\n    return 0;\n# endif\n\n# if C_LOCALE_MAYBE_EILSEQ\n  if ((size_t) -2 <= ret && n != 0 && ! hard_locale (LC_CTYPE))\n    {\n      unsigned char uc = *s;\n      *pwc = uc;\n      return 1;\n    }\n# endif\n\n  return ret;\n}",
      "lines": 73,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/mbsinit.c": {
    "mbsinit": [
      {
        "start_point": [
          52,
          0
        ],
        "end_point": [
          58,
          1
        ],
        "content": "int\nmbsinit (const mbstate_t *ps)\n{\n  const char *pstate = (const char *)ps;\n\n  return pstate == NULL || pstate[0] == 0;\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          62,
          0
        ],
        "end_point": [
          79,
          1
        ],
        "content": "int\nmbsinit (const mbstate_t *ps)\n{\n# if defined _WIN32 && !defined __CYGWIN__\n  /* Native Windows.  */\n#  ifdef __MINGW32__\n  /* On mingw, 'mbstate_t' is defined as 'int'.  */\n  return ps == NULL || *ps == 0;\n#  else\n  /* MSVC defines 'mbstate_t' as an 8-byte struct; the first 4-bytes matter.  */\n  return ps == NULL || *(const unsigned int *)ps == 0;\n#  endif\n# else\n  /* Minix, HP-UX 11.00, Solaris 2.6, Interix, ...  */\n  /* Maybe this definition works, maybe not...  */\n  return ps == NULL || *(const char *)ps == 0;\n# endif\n}",
        "lines": 18,
        "depth": 13,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/mbsnlen.c": {
    "mbsnlen": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "size_t\nmbsnlen (const char *string, size_t len)\n{\n  if (MB_CUR_MAX > 1)\n    {\n      size_t count;\n      mbi_iterator_t iter;\n\n      count = 0;\n      for (mbi_init (iter, string, len); mbi_avail (iter); mbi_advance (iter))\n        count++;\n\n      return count;\n    }\n  else\n    return len;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/memchr.c": {
    "__memchr": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "void *\n__memchr (void const *s, int c_in, size_t n)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned reg_char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;\n       --n, ++char_ptr)\n    if (*char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will test a\n     longword at a time.  The tricky part is testing if *any of the four*\n     bytes in the longword in question are equal to c.  We first use an xor\n     with repeated_c.  This reduces the task to testing whether *any of the\n     four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     So, the test whether any byte in longword1 is zero is equivalent to\n     testing whether tmp is nonzero.  */\n\n  while (n >= sizeof (longword))\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n      n -= sizeof (longword);\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that either n < sizeof (longword), or one of the\n     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian\n     machines, we could determine the first such byte without any further\n     memory accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.  Choose code\n     that works in both cases.  */\n\n  for (; n > 0; --n, ++char_ptr)\n    {\n      if (*char_ptr == c)\n        return (void *) char_ptr;\n    }\n\n  return NULL;\n}",
      "lines": 112,
      "depth": 14,
      "decorators": [
        "void",
        "*\n__memchr (void const *s, int c_in, size_t n)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/memcmp2.c": {
    "memcmp2": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "int\nmemcmp2 (const char *s1, size_t n1, const char *s2, size_t n2)\n{\n  int cmp = memcmp (s1, s2, n1 <= n2 ? n1 : n2);\n  if (cmp == 0)\n    {\n      if (n1 < n2)\n        cmp = -1;\n      else if (n1 > n2)\n        cmp = 1;\n    }\n  return cmp;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/memcmp2.h": {},
  "libunistring/libunistring-0.9.10/lib/minmax.h": {},
  "libunistring/libunistring-0.9.10/lib/printf-args.c": {
    "PRINTF_FETCHARGS": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "int\nPRINTF_FETCHARGS (va_list args, arguments *a)\n{\n  size_t i;\n  argument *ap;\n\n  for (i = 0, ap = &a->arg[0]; i < a->count; i++, ap++)\n    switch (ap->type)\n      {\n      case TYPE_SCHAR:\n        ap->a.a_schar = va_arg (args, /*signed char*/ int);\n        break;\n      case TYPE_UCHAR:\n        ap->a.a_uchar = va_arg (args, /*unsigned char*/ int);\n        break;\n      case TYPE_SHORT:\n        ap->a.a_short = va_arg (args, /*short*/ int);\n        break;\n      case TYPE_USHORT:\n        ap->a.a_ushort = va_arg (args, /*unsigned short*/ int);\n        break;\n      case TYPE_INT:\n        ap->a.a_int = va_arg (args, int);\n        break;\n      case TYPE_UINT:\n        ap->a.a_uint = va_arg (args, unsigned int);\n        break;\n      case TYPE_LONGINT:\n        ap->a.a_longint = va_arg (args, long int);\n        break;\n      case TYPE_ULONGINT:\n        ap->a.a_ulongint = va_arg (args, unsigned long int);\n        break;\n#if HAVE_LONG_LONG_INT\n      case TYPE_LONGLONGINT:\n        ap->a.a_longlongint = va_arg (args, long long int);\n        break;\n      case TYPE_ULONGLONGINT:\n        ap->a.a_ulonglongint = va_arg (args, unsigned long long int);\n        break;\n#endif\n      case TYPE_DOUBLE:\n        ap->a.a_double = va_arg (args, double);\n        break;\n      case TYPE_LONGDOUBLE:\n        ap->a.a_longdouble = va_arg (args, long double);\n        break;\n      case TYPE_CHAR:\n        ap->a.a_char = va_arg (args, int);\n        break;\n#if HAVE_WINT_T\n      case TYPE_WIDE_CHAR:\n        /* Although ISO C 99 7.24.1.(2) says that wint_t is \"unchanged by\n           default argument promotions\", this is not the case in mingw32,\n           where wint_t is 'unsigned short'.  */\n        ap->a.a_wide_char =\n          (sizeof (wint_t) < sizeof (int)\n           ? (wint_t) va_arg (args, int)\n           : va_arg (args, wint_t));\n        break;\n#endif\n      case TYPE_STRING:\n        ap->a.a_string = va_arg (args, const char *);\n        /* A null pointer is an invalid argument for \"%s\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_string == NULL)\n          ap->a.a_string = \"(NULL)\";\n        break;\n#if HAVE_WCHAR_T\n      case TYPE_WIDE_STRING:\n        ap->a.a_wide_string = va_arg (args, const wchar_t *);\n        /* A null pointer is an invalid argument for \"%ls\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_wide_string == NULL)\n          {\n            static const wchar_t wide_null_string[] =\n              {\n                (wchar_t)'(',\n                (wchar_t)'N', (wchar_t)'U', (wchar_t)'L', (wchar_t)'L',\n                (wchar_t)')',\n                (wchar_t)0\n              };\n            ap->a.a_wide_string = wide_null_string;\n          }\n        break;\n#endif\n      case TYPE_POINTER:\n        ap->a.a_pointer = va_arg (args, void *);\n        break;\n      case TYPE_COUNT_SCHAR_POINTER:\n        ap->a.a_count_schar_pointer = va_arg (args, signed char *);\n        break;\n      case TYPE_COUNT_SHORT_POINTER:\n        ap->a.a_count_short_pointer = va_arg (args, short *);\n        break;\n      case TYPE_COUNT_INT_POINTER:\n        ap->a.a_count_int_pointer = va_arg (args, int *);\n        break;\n      case TYPE_COUNT_LONGINT_POINTER:\n        ap->a.a_count_longint_pointer = va_arg (args, long int *);\n        break;\n#if HAVE_LONG_LONG_INT\n      case TYPE_COUNT_LONGLONGINT_POINTER:\n        ap->a.a_count_longlongint_pointer = va_arg (args, long long int *);\n        break;\n#endif\n#if ENABLE_UNISTDIO\n      /* The unistdio extensions.  */\n      case TYPE_U8_STRING:\n        ap->a.a_u8_string = va_arg (args, const uint8_t *);\n        /* A null pointer is an invalid argument for \"%U\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u8_string == NULL)\n          {\n            static const uint8_t u8_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u8_string = u8_null_string;\n          }\n        break;\n      case TYPE_U16_STRING:\n        ap->a.a_u16_string = va_arg (args, const uint16_t *);\n        /* A null pointer is an invalid argument for \"%lU\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u16_string == NULL)\n          {\n            static const uint16_t u16_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u16_string = u16_null_string;\n          }\n        break;\n      case TYPE_U32_STRING:\n        ap->a.a_u32_string = va_arg (args, const uint32_t *);\n        /* A null pointer is an invalid argument for \"%llU\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u32_string == NULL)\n          {\n            static const uint32_t u32_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u32_string = u32_null_string;\n          }\n        break;\n#endif\n      default:\n        /* Unknown type.  */\n        return -1;\n      }\n  return 0;\n}",
      "lines": 153,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/printf-args.h": {},
  "libunistring/libunistring-0.9.10/lib/printf-frexp.c": {
    "FUNC": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "DOUBLE\nFUNC (DOUBLE x, int *expptr)\n{\n  int exponent;\n  DECL_ROUNDING\n\n  BEGIN_ROUNDING ();\n\n#ifdef USE_FREXP_LDEXP\n  /* frexp and ldexp are usually faster than the loop below.  */\n  x = FREXP (x, &exponent);\n\n  x = x + x;\n  exponent -= 1;\n\n  if (exponent < MIN_EXP - 1)\n    {\n      x = LDEXP (x, exponent - (MIN_EXP - 1));\n      exponent = MIN_EXP - 1;\n    }\n#else\n  {\n    /* Since the exponent is an 'int', it fits in 64 bits.  Therefore the\n       loops are executed no more than 64 times.  */\n    DOUBLE pow2[64]; /* pow2[i] = 2^2^i */\n    DOUBLE powh[64]; /* powh[i] = 2^-2^i */\n    int i;\n\n    exponent = 0;\n    if (x >= L_(1.0))\n      {\n        /* A nonnegative exponent.  */\n        {\n          DOUBLE pow2_i; /* = pow2[i] */\n          DOUBLE powh_i; /* = powh[i] */\n\n          /* Invariants: pow2_i = 2^2^i, powh_i = 2^-2^i,\n             x * 2^exponent = argument, x >= 1.0.  */\n          for (i = 0, pow2_i = L_(2.0), powh_i = L_(0.5);\n               ;\n               i++, pow2_i = pow2_i * pow2_i, powh_i = powh_i * powh_i)\n            {\n              if (x >= pow2_i)\n                {\n                  exponent += (1 << i);\n                  x *= powh_i;\n                }\n              else\n                break;\n\n              pow2[i] = pow2_i;\n              powh[i] = powh_i;\n            }\n        }\n        /* Here 1.0 <= x < 2^2^i.  */\n      }\n    else\n      {\n        /* A negative exponent.  */\n        {\n          DOUBLE pow2_i; /* = pow2[i] */\n          DOUBLE powh_i; /* = powh[i] */\n\n          /* Invariants: pow2_i = 2^2^i, powh_i = 2^-2^i,\n             x * 2^exponent = argument, x < 1.0, exponent >= MIN_EXP - 1.  */\n          for (i = 0, pow2_i = L_(2.0), powh_i = L_(0.5);\n               ;\n               i++, pow2_i = pow2_i * pow2_i, powh_i = powh_i * powh_i)\n            {\n              if (exponent - (1 << i) < MIN_EXP - 1)\n                break;\n\n              exponent -= (1 << i);\n              x *= pow2_i;\n              if (x >= L_(1.0))\n                break;\n\n              pow2[i] = pow2_i;\n              powh[i] = powh_i;\n            }\n        }\n        /* Here either x < 1.0 and exponent - 2^i < MIN_EXP - 1 <= exponent,\n           or 1.0 <= x < 2^2^i and exponent >= MIN_EXP - 1.  */\n\n        if (x < L_(1.0))\n          /* Invariants: x * 2^exponent = argument, x < 1.0 and\n             exponent - 2^i < MIN_EXP - 1 <= exponent.  */\n          while (i > 0)\n            {\n              i--;\n              if (exponent - (1 << i) >= MIN_EXP - 1)\n                {\n                  exponent -= (1 << i);\n                  x *= pow2[i];\n                  if (x >= L_(1.0))\n                    break;\n                }\n            }\n\n        /* Here either x < 1.0 and exponent = MIN_EXP - 1,\n           or 1.0 <= x < 2^2^i and exponent >= MIN_EXP - 1.  */\n      }\n\n    /* Invariants: x * 2^exponent = argument, and\n       either x < 1.0 and exponent = MIN_EXP - 1,\n       or 1.0 <= x < 2^2^i and exponent >= MIN_EXP - 1.  */\n    while (i > 0)\n      {\n        i--;\n        if (x >= pow2[i])\n          {\n            exponent += (1 << i);\n            x *= powh[i];\n          }\n      }\n    /* Here either x < 1.0 and exponent = MIN_EXP - 1,\n       or 1.0 <= x < 2.0 and exponent >= MIN_EXP - 1.  */\n  }\n#endif\n\n  END_ROUNDING ();\n\n  *expptr = exponent;\n  return x;\n}",
      "lines": 125,
      "depth": 18,
      "decorators": [
        "DOUBLE"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/printf-frexp.h": {},
  "libunistring/libunistring-0.9.10/lib/printf-frexpl.c": {
    "printf_frexpl": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "long double\nprintf_frexpl (long double x, int *expptr)\n{\n  return printf_frexp (x, expptr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "long double",
        "long",
        "double"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/printf-frexpl.h": {},
  "libunistring/libunistring-0.9.10/lib/printf-parse.c": {
    "PRINTF_PARSE": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        640,
        1
      ],
      "content": "int\nPRINTF_PARSE (const CHAR_T *format, DIRECTIVES *d, arguments *a)\n{\n  const CHAR_T *cp = format;    /* pointer into format */\n  size_t arg_posn = 0;          /* number of regular arguments consumed */\n  size_t d_allocated;           /* allocated elements of d->dir */\n  size_t a_allocated;           /* allocated elements of a->arg */\n  size_t max_width_length = 0;\n  size_t max_precision_length = 0;\n\n  d->count = 0;\n  d_allocated = N_DIRECT_ALLOC_DIRECTIVES;\n  d->dir = d->direct_alloc_dir;\n\n  a->count = 0;\n  a_allocated = N_DIRECT_ALLOC_ARGUMENTS;\n  a->arg = a->direct_alloc_arg;\n\n#define REGISTER_ARG(_index_,_type_) \\\n  {                                                                     \\\n    size_t n = (_index_);                                               \\\n    if (n >= a_allocated)                                               \\\n      {                                                                 \\\n        size_t memory_size;                                             \\\n        argument *memory;                                               \\\n                                                                        \\\n        a_allocated = xtimes (a_allocated, 2);                          \\\n        if (a_allocated <= n)                                           \\\n          a_allocated = xsum (n, 1);                                    \\\n        memory_size = xtimes (a_allocated, sizeof (argument));          \\\n        if (size_overflow_p (memory_size))                              \\\n          /* Overflow, would lead to out of memory.  */                 \\\n          goto out_of_memory;                                           \\\n        memory = (argument *) (a->arg != a->direct_alloc_arg            \\\n                               ? realloc (a->arg, memory_size)          \\\n                               : malloc (memory_size));                 \\\n        if (memory == NULL)                                             \\\n          /* Out of memory.  */                                         \\\n          goto out_of_memory;                                           \\\n        if (a->arg == a->direct_alloc_arg)                              \\\n          memcpy (memory, a->arg, a->count * sizeof (argument));        \\\n        a->arg = memory;                                                \\\n      }                                                                 \\\n    while (a->count <= n)                                               \\\n      a->arg[a->count++].type = TYPE_NONE;                              \\\n    if (a->arg[n].type == TYPE_NONE)                                    \\\n      a->arg[n].type = (_type_);                                        \\\n    else if (a->arg[n].type != (_type_))                                \\\n      /* Ambiguous type for positional argument.  */                    \\\n      goto error;                                                       \\\n  }\n\n  while (*cp != '\\0')\n    {\n      CHAR_T c = *cp++;\n      if (c == '%')\n        {\n          size_t arg_index = ARG_NONE;\n          DIRECTIVE *dp = &d->dir[d->count]; /* pointer to next directive */\n\n          /* Initialize the next directive.  */\n          dp->dir_start = cp - 1;\n          dp->flags = 0;\n          dp->width_start = NULL;\n          dp->width_end = NULL;\n          dp->width_arg_index = ARG_NONE;\n          dp->precision_start = NULL;\n          dp->precision_end = NULL;\n          dp->precision_arg_index = ARG_NONE;\n          dp->arg_index = ARG_NONE;\n\n          /* Test for positional argument.  */\n          if (*cp >= '0' && *cp <= '9')\n            {\n              const CHAR_T *np;\n\n              for (np = cp; *np >= '0' && *np <= '9'; np++)\n                ;\n              if (*np == '$')\n                {\n                  size_t n = 0;\n\n                  for (np = cp; *np >= '0' && *np <= '9'; np++)\n                    n = xsum (xtimes (n, 10), *np - '0');\n                  if (n == 0)\n                    /* Positional argument 0.  */\n                    goto error;\n                  if (size_overflow_p (n))\n                    /* n too large, would lead to out of memory later.  */\n                    goto error;\n                  arg_index = n - 1;\n                  cp = np + 1;\n                }\n            }\n\n          /* Read the flags.  */\n          for (;;)\n            {\n              if (*cp == '\\'')\n                {\n                  dp->flags |= FLAG_GROUP;\n                  cp++;\n                }\n              else if (*cp == '-')\n                {\n                  dp->flags |= FLAG_LEFT;\n                  cp++;\n                }\n              else if (*cp == '+')\n                {\n                  dp->flags |= FLAG_SHOWSIGN;\n                  cp++;\n                }\n              else if (*cp == ' ')\n                {\n                  dp->flags |= FLAG_SPACE;\n                  cp++;\n                }\n              else if (*cp == '#')\n                {\n                  dp->flags |= FLAG_ALT;\n                  cp++;\n                }\n              else if (*cp == '0')\n                {\n                  dp->flags |= FLAG_ZERO;\n                  cp++;\n                }\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n              else if (*cp == 'I')\n                {\n                  dp->flags |= FLAG_LOCALIZED;\n                  cp++;\n                }\n#endif\n              else\n                break;\n            }\n\n          /* Parse the field width.  */\n          if (*cp == '*')\n            {\n              dp->width_start = cp;\n              cp++;\n              dp->width_end = cp;\n              if (max_width_length < 1)\n                max_width_length = 1;\n\n              /* Test for positional argument.  */\n              if (*cp >= '0' && *cp <= '9')\n                {\n                  const CHAR_T *np;\n\n                  for (np = cp; *np >= '0' && *np <= '9'; np++)\n                    ;\n                  if (*np == '$')\n                    {\n                      size_t n = 0;\n\n                      for (np = cp; *np >= '0' && *np <= '9'; np++)\n                        n = xsum (xtimes (n, 10), *np - '0');\n                      if (n == 0)\n                        /* Positional argument 0.  */\n                        goto error;\n                      if (size_overflow_p (n))\n                        /* n too large, would lead to out of memory later.  */\n                        goto error;\n                      dp->width_arg_index = n - 1;\n                      cp = np + 1;\n                    }\n                }\n              if (dp->width_arg_index == ARG_NONE)\n                {\n                  dp->width_arg_index = arg_posn++;\n                  if (dp->width_arg_index == ARG_NONE)\n                    /* arg_posn wrapped around.  */\n                    goto error;\n                }\n              REGISTER_ARG (dp->width_arg_index, TYPE_INT);\n            }\n          else if (*cp >= '0' && *cp <= '9')\n            {\n              size_t width_length;\n\n              dp->width_start = cp;\n              for (; *cp >= '0' && *cp <= '9'; cp++)\n                ;\n              dp->width_end = cp;\n              width_length = dp->width_end - dp->width_start;\n              if (max_width_length < width_length)\n                max_width_length = width_length;\n            }\n\n          /* Parse the precision.  */\n          if (*cp == '.')\n            {\n              cp++;\n              if (*cp == '*')\n                {\n                  dp->precision_start = cp - 1;\n                  cp++;\n                  dp->precision_end = cp;\n                  if (max_precision_length < 2)\n                    max_precision_length = 2;\n\n                  /* Test for positional argument.  */\n                  if (*cp >= '0' && *cp <= '9')\n                    {\n                      const CHAR_T *np;\n\n                      for (np = cp; *np >= '0' && *np <= '9'; np++)\n                        ;\n                      if (*np == '$')\n                        {\n                          size_t n = 0;\n\n                          for (np = cp; *np >= '0' && *np <= '9'; np++)\n                            n = xsum (xtimes (n, 10), *np - '0');\n                          if (n == 0)\n                            /* Positional argument 0.  */\n                            goto error;\n                          if (size_overflow_p (n))\n                            /* n too large, would lead to out of memory\n                               later.  */\n                            goto error;\n                          dp->precision_arg_index = n - 1;\n                          cp = np + 1;\n                        }\n                    }\n                  if (dp->precision_arg_index == ARG_NONE)\n                    {\n                      dp->precision_arg_index = arg_posn++;\n                      if (dp->precision_arg_index == ARG_NONE)\n                        /* arg_posn wrapped around.  */\n                        goto error;\n                    }\n                  REGISTER_ARG (dp->precision_arg_index, TYPE_INT);\n                }\n              else\n                {\n                  size_t precision_length;\n\n                  dp->precision_start = cp - 1;\n                  for (; *cp >= '0' && *cp <= '9'; cp++)\n                    ;\n                  dp->precision_end = cp;\n                  precision_length = dp->precision_end - dp->precision_start;\n                  if (max_precision_length < precision_length)\n                    max_precision_length = precision_length;\n                }\n            }\n\n          {\n            arg_type type;\n\n            /* Parse argument type/size specifiers.  */\n            {\n              int flags = 0;\n\n              for (;;)\n                {\n                  if (*cp == 'h')\n                    {\n                      flags |= (1 << (flags & 1));\n                      cp++;\n                    }\n                  else if (*cp == 'L')\n                    {\n                      flags |= 4;\n                      cp++;\n                    }\n                  else if (*cp == 'l')\n                    {\n                      flags += 8;\n                      cp++;\n                    }\n                  else if (*cp == 'j')\n                    {\n                      if (sizeof (intmax_t) > sizeof (long))\n                        {\n                          /* intmax_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (intmax_t) > sizeof (int))\n                        {\n                          /* intmax_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n                  else if (*cp == 'z' || *cp == 'Z')\n                    {\n                      /* 'z' is standardized in ISO C 99, but glibc uses 'Z'\n                         because the warning facility in gcc-2.95.2 understands\n                         only 'Z' (see gcc-2.95.2/gcc/c-common.c:1784).  */\n                      if (sizeof (size_t) > sizeof (long))\n                        {\n                          /* size_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (size_t) > sizeof (int))\n                        {\n                          /* size_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n                  else if (*cp == 't')\n                    {\n                      if (sizeof (ptrdiff_t) > sizeof (long))\n                        {\n                          /* ptrdiff_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (ptrdiff_t) > sizeof (int))\n                        {\n                          /* ptrdiff_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n#if defined __APPLE__ && defined __MACH__\n                  /* On Mac OS X 10.3, PRIdMAX is defined as \"qd\".\n                     We cannot change it to \"lld\" because PRIdMAX must also\n                     be understood by the system's printf routines.  */\n                  else if (*cp == 'q')\n                    {\n                      if (64 / 8 > sizeof (long))\n                        {\n                          /* int64_t = long long */\n                          flags += 16;\n                        }\n                      else\n                        {\n                          /* int64_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n#endif\n#if defined _WIN32 && ! defined __CYGWIN__\n                  /* On native Windows, PRIdMAX is defined as \"I64d\".\n                     We cannot change it to \"lld\" because PRIdMAX must also\n                     be understood by the system's printf routines.  */\n                  else if (*cp == 'I' && cp[1] == '6' && cp[2] == '4')\n                    {\n                      if (64 / 8 > sizeof (long))\n                        {\n                          /* __int64 = long long */\n                          flags += 16;\n                        }\n                      else\n                        {\n                          /* __int64 = long */\n                          flags += 8;\n                        }\n                      cp += 3;\n                    }\n#endif\n                  else\n                    break;\n                }\n\n              /* Read the conversion character.  */\n              c = *cp++;\n              switch (c)\n                {\n                case 'd': case 'i':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_LONGLONGINT;\n                  else\n#endif\n                  /* If 'long long' exists and is the same as 'long', we parse\n                     \"lld\" into TYPE_LONGINT.  */\n                  if (flags >= 8)\n                    type = TYPE_LONGINT;\n                  else if (flags & 2)\n                    type = TYPE_SCHAR;\n                  else if (flags & 1)\n                    type = TYPE_SHORT;\n                  else\n                    type = TYPE_INT;\n                  break;\n                case 'o': case 'u': case 'x': case 'X':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_ULONGLONGINT;\n                  else\n#endif\n                  /* If 'unsigned long long' exists and is the same as\n                     'unsigned long', we parse \"llu\" into TYPE_ULONGINT.  */\n                  if (flags >= 8)\n                    type = TYPE_ULONGINT;\n                  else if (flags & 2)\n                    type = TYPE_UCHAR;\n                  else if (flags & 1)\n                    type = TYPE_USHORT;\n                  else\n                    type = TYPE_UINT;\n                  break;\n                case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                case 'a': case 'A':\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_LONGDOUBLE;\n                  else\n                    type = TYPE_DOUBLE;\n                  break;\n                case 'c':\n                  if (flags >= 8)\n#if HAVE_WINT_T\n                    type = TYPE_WIDE_CHAR;\n#else\n                    goto error;\n#endif\n                  else\n                    type = TYPE_CHAR;\n                  break;\n#if HAVE_WINT_T\n                case 'C':\n                  type = TYPE_WIDE_CHAR;\n                  c = 'c';\n                  break;\n#endif\n                case 's':\n                  if (flags >= 8)\n#if HAVE_WCHAR_T\n                    type = TYPE_WIDE_STRING;\n#else\n                    goto error;\n#endif\n                  else\n                    type = TYPE_STRING;\n                  break;\n#if HAVE_WCHAR_T\n                case 'S':\n                  type = TYPE_WIDE_STRING;\n                  c = 's';\n                  break;\n#endif\n                case 'p':\n                  type = TYPE_POINTER;\n                  break;\n                case 'n':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_COUNT_LONGLONGINT_POINTER;\n                  else\n#endif\n                  /* If 'long long' exists and is the same as 'long', we parse\n                     \"lln\" into TYPE_COUNT_LONGINT_POINTER.  */\n                  if (flags >= 8)\n                    type = TYPE_COUNT_LONGINT_POINTER;\n                  else if (flags & 2)\n                    type = TYPE_COUNT_SCHAR_POINTER;\n                  else if (flags & 1)\n                    type = TYPE_COUNT_SHORT_POINTER;\n                  else\n                    type = TYPE_COUNT_INT_POINTER;\n                  break;\n#if ENABLE_UNISTDIO\n                /* The unistdio extensions.  */\n                case 'U':\n                  if (flags >= 16)\n                    type = TYPE_U32_STRING;\n                  else if (flags >= 8)\n                    type = TYPE_U16_STRING;\n                  else\n                    type = TYPE_U8_STRING;\n                  break;\n#endif\n                case '%':\n                  type = TYPE_NONE;\n                  break;\n                default:\n                  /* Unknown conversion character.  */\n                  goto error;\n                }\n            }\n\n            if (type != TYPE_NONE)\n              {\n                dp->arg_index = arg_index;\n                if (dp->arg_index == ARG_NONE)\n                  {\n                    dp->arg_index = arg_posn++;\n                    if (dp->arg_index == ARG_NONE)\n                      /* arg_posn wrapped around.  */\n                      goto error;\n                  }\n                REGISTER_ARG (dp->arg_index, type);\n              }\n            dp->conversion = c;\n            dp->dir_end = cp;\n          }\n\n          d->count++;\n          if (d->count >= d_allocated)\n            {\n              size_t memory_size;\n              DIRECTIVE *memory;\n\n              d_allocated = xtimes (d_allocated, 2);\n              memory_size = xtimes (d_allocated, sizeof (DIRECTIVE));\n              if (size_overflow_p (memory_size))\n                /* Overflow, would lead to out of memory.  */\n                goto out_of_memory;\n              memory = (DIRECTIVE *) (d->dir != d->direct_alloc_dir\n                                      ? realloc (d->dir, memory_size)\n                                      : malloc (memory_size));\n              if (memory == NULL)\n                /* Out of memory.  */\n                goto out_of_memory;\n              if (d->dir == d->direct_alloc_dir)\n                memcpy (memory, d->dir, d->count * sizeof (DIRECTIVE));\n              d->dir = memory;\n            }\n        }\n#if CHAR_T_ONLY_ASCII\n      else if (!c_isascii (c))\n        {\n          /* Non-ASCII character.  Not supported.  */\n          goto error;\n        }\n#endif\n    }\n  d->dir[d->count].dir_start = cp;\n\n  d->max_width_length = max_width_length;\n  d->max_precision_length = max_precision_length;\n  return 0;\n\nerror:\n  if (a->arg != a->direct_alloc_arg)\n    free (a->arg);\n  if (d->dir != d->direct_alloc_dir)\n    free (d->dir);\n  errno = EINVAL;\n  return -1;\n\nout_of_memory:\n  if (a->arg != a->direct_alloc_arg)\n    free (a->arg);\n  if (d->dir != d->direct_alloc_dir)\n    free (d->dir);\n  errno = ENOMEM;\n  return -1;\n}",
      "lines": 551,
      "depth": 24,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/printf-parse.h": {},
  "libunistring/libunistring-0.9.10/lib/relocatable.c": {
    "set_this_relocation_prefix": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "static void\nset_this_relocation_prefix (const char *orig_prefix_arg,\n                            const char *curr_prefix_arg)\n{\n  if (orig_prefix_arg != NULL && curr_prefix_arg != NULL\n      /* Optimization: if orig_prefix and curr_prefix are equal, the\n         relocation is a nop.  */\n      && strcmp (orig_prefix_arg, curr_prefix_arg) != 0)\n    {\n      /* Duplicate the argument strings.  */\n      char *memory;\n\n      orig_prefix_len = strlen (orig_prefix_arg);\n      curr_prefix_len = strlen (curr_prefix_arg);\n      memory = (char *) xmalloc (orig_prefix_len + 1 + curr_prefix_len + 1);\n#ifdef NO_XMALLOC\n      if (memory != NULL)\n#endif\n        {\n          memcpy (memory, orig_prefix_arg, orig_prefix_len + 1);\n          orig_prefix = memory;\n          memory += orig_prefix_len + 1;\n          memcpy (memory, curr_prefix_arg, curr_prefix_len + 1);\n          curr_prefix = memory;\n          return;\n        }\n    }\n  orig_prefix = NULL;\n  curr_prefix = NULL;\n  /* Don't worry about wasted memory here - this function is usually only\n     called once.  */\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_relocation_prefix": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "void\nset_relocation_prefix (const char *orig_prefix_arg, const char *curr_prefix_arg)\n{\n  set_this_relocation_prefix (orig_prefix_arg, curr_prefix_arg);\n\n  /* Now notify all dependent libraries.  */\n#if DEPENDS_ON_LIBCHARSET\n  libcharset_set_relocation_prefix (orig_prefix_arg, curr_prefix_arg);\n#endif\n#if DEPENDS_ON_LIBICONV && HAVE_ICONV && _LIBICONV_VERSION >= 0x0109\n  libiconv_set_relocation_prefix (orig_prefix_arg, curr_prefix_arg);\n#endif\n#if DEPENDS_ON_LIBINTL && ENABLE_NLS && defined libintl_set_relocation_prefix\n  libintl_set_relocation_prefix (orig_prefix_arg, curr_prefix_arg);\n#endif\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "compute_curr_prefix": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        312,
        1
      ],
      "content": "char *\ncompute_curr_prefix (const char *orig_installprefix,\n                     const char *orig_installdir,\n                     const char *curr_pathname)\n{\n  char *curr_installdir;\n  const char *rel_installdir;\n\n  if (curr_pathname == NULL)\n    return NULL;\n\n  /* Determine the relative installation directory, relative to the prefix.\n     This is simply the difference between orig_installprefix and\n     orig_installdir.  */\n  if (strncmp (orig_installprefix, orig_installdir, strlen (orig_installprefix))\n      != 0)\n    /* Shouldn't happen - nothing should be installed outside $(prefix).  */\n    return NULL;\n  rel_installdir = orig_installdir + strlen (orig_installprefix);\n\n  /* Determine the current installation directory.  */\n  {\n    const char *p_base = curr_pathname + FILE_SYSTEM_PREFIX_LEN (curr_pathname);\n    const char *p = curr_pathname + strlen (curr_pathname);\n    char *q;\n\n    while (p > p_base)\n      {\n        p--;\n        if (ISSLASH (*p))\n          break;\n      }\n\n    q = (char *) xmalloc (p - curr_pathname + 1);\n#ifdef NO_XMALLOC\n    if (q == NULL)\n      return NULL;\n#endif\n    memcpy (q, curr_pathname, p - curr_pathname);\n    q[p - curr_pathname] = '\\0';\n    curr_installdir = q;\n  }\n\n  /* Compute the current installation prefix by removing the trailing\n     rel_installdir from it.  */\n  {\n    const char *rp = rel_installdir + strlen (rel_installdir);\n    const char *cp = curr_installdir + strlen (curr_installdir);\n    const char *cp_base =\n      curr_installdir + FILE_SYSTEM_PREFIX_LEN (curr_installdir);\n\n    while (rp > rel_installdir && cp > cp_base)\n      {\n        bool same = false;\n        const char *rpi = rp;\n        const char *cpi = cp;\n\n        while (rpi > rel_installdir && cpi > cp_base)\n          {\n            rpi--;\n            cpi--;\n            if (ISSLASH (*rpi) || ISSLASH (*cpi))\n              {\n                if (ISSLASH (*rpi) && ISSLASH (*cpi))\n                  same = true;\n                break;\n              }\n            /* Do case-insensitive comparison if the file system is always or\n               often case-insensitive.  It's better to accept the comparison\n               if the difference is only in case, rather than to fail.  */\n#if defined _WIN32 || defined __CYGWIN__ || defined __EMX__ || defined __DJGPP__\n            /* Native Windows, Cygwin, OS/2, DOS - case insignificant file system */\n            if ((*rpi >= 'a' && *rpi <= 'z' ? *rpi - 'a' + 'A' : *rpi)\n                != (*cpi >= 'a' && *cpi <= 'z' ? *cpi - 'a' + 'A' : *cpi))\n              break;\n#else\n            if (*rpi != *cpi)\n              break;\n#endif\n          }\n        if (!same)\n          break;\n        /* The last pathname component was the same.  opi and cpi now point\n           to the slash before it.  */\n        rp = rpi;\n        cp = cpi;\n      }\n\n    if (rp > rel_installdir)\n      {\n        /* Unexpected: The curr_installdir does not end with rel_installdir.  */\n        free (curr_installdir);\n        return NULL;\n      }\n\n    {\n      size_t curr_prefix_len = cp - curr_installdir;\n      char *curr_prefix;\n\n      curr_prefix = (char *) xmalloc (curr_prefix_len + 1);\n#ifdef NO_XMALLOC\n      if (curr_prefix == NULL)\n        {\n          free (curr_installdir);\n          return NULL;\n        }\n#endif\n      memcpy (curr_prefix, curr_installdir, curr_prefix_len);\n      curr_prefix[curr_prefix_len] = '\\0';\n\n      free (curr_installdir);\n\n      return curr_prefix;\n    }\n  }\n}",
      "lines": 116,
      "depth": 17,
      "decorators": [
        "char",
        "*\ncompute_curr_prefix (const char *orig_installprefix,\n                     const char *orig_installdir,\n                     const char *curr_pathname)",
        "*"
      ]
    },
    "DllMain": {
      "start_point": [
        330,
        0
      ],
      "end_point": [
        352,
        1
      ],
      "content": "BOOL WINAPI\nDllMain (HINSTANCE module_handle, DWORD event, LPVOID reserved)\n{\n  (void) reserved;\n\n  if (event == DLL_PROCESS_ATTACH)\n    {\n      /* The DLL is being loaded into an application's address range.  */\n      static char location[MAX_PATH];\n\n      if (!GetModuleFileName (module_handle, location, sizeof (location)))\n        /* Shouldn't happen.  */\n        return FALSE;\n\n      if (!IS_PATH_WITH_DIR (location))\n        /* Shouldn't happen.  */\n        return FALSE;\n\n      shared_library_fullname = strdup (location);\n    }\n\n  return TRUE;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "BOOL",
        "WINAPI",
        "WINAPI"
      ]
    },
    "_DLL_InitTerm": {
      "start_point": [
        361,
        0
      ],
      "end_point": [
        391,
        1
      ],
      "content": "unsigned long _System\n_DLL_InitTerm (unsigned long hModule, unsigned long ulFlag)\n{\n  static char location[CCHMAXPATH];\n\n  switch (ulFlag)\n    {\n      case 0:\n        if (_CRT_init () == -1)\n          return 0;\n\n        __ctordtorInit();\n\n        /* See http://cyberkinetica.homeunix.net/os2tk45/cp1/1247_L2H_DosQueryModuleNameSy.html\n           for specification of DosQueryModuleName(). */\n        if (DosQueryModuleName (hModule, sizeof (location), location))\n          return 0;\n\n        _fnslashify (location);\n        shared_library_fullname = strdup (location);\n        break;\n\n      case 1:\n        __ctordtorTerm();\n\n        _CRT_term ();\n        break;\n    }\n\n  return 1;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "unsigned long _System",
        "unsigned",
        "long",
        "_System"
      ]
    },
    "find_shared_library_fullname": {
      "start_point": [
        395,
        0
      ],
      "end_point": [
        446,
        1
      ],
      "content": "static void\nfind_shared_library_fullname ()\n{\n#if (defined __linux__ && (__GLIBC__ >= 2 || defined __UCLIBC__)) || defined __CYGWIN__\n  /* Linux has /proc/self/maps. glibc 2 and uClibc have the getline()\n     function.\n     Cygwin >= 1.5 has /proc/self/maps and the getline() function too.\n     But it is costly: ca. 0.3 ms on Linux, 3 ms on Cygwin 1.5, and 5 ms on\n     Cygwin 1.7.  */\n  FILE *fp;\n\n  /* Open the current process' maps file.  It describes one VMA per line.  */\n  fp = fopen (\"/proc/self/maps\", \"r\");\n  if (fp)\n    {\n      unsigned long address = (unsigned long) &find_shared_library_fullname;\n      for (;;)\n        {\n          unsigned long start, end;\n          int c;\n\n          if (fscanf (fp, \"%lx-%lx\", &start, &end) != 2)\n            break;\n          if (address >= start && address <= end - 1)\n            {\n              /* Found it.  Now see if this line contains a filename.  */\n              while (c = getc (fp), c != EOF && c != '\\n' && c != '/')\n                continue;\n              if (c == '/')\n                {\n                  size_t size;\n                  int len;\n\n                  ungetc (c, fp);\n                  shared_library_fullname = NULL; size = 0;\n                  len = getline (&shared_library_fullname, &size, fp);\n                  if (len >= 0)\n                    {\n                      /* Success: filled shared_library_fullname.  */\n                      if (len > 0 && shared_library_fullname[len - 1] == '\\n')\n                        shared_library_fullname[len - 1] = '\\0';\n                    }\n                }\n              break;\n            }\n          while (c = getc (fp), c != EOF && c != '\\n')\n            continue;\n        }\n      fclose (fp);\n    }\n#endif\n}",
      "lines": 52,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_shared_library_fullname": {
      "start_point": [
        453,
        0
      ],
      "end_point": [
        465,
        1
      ],
      "content": "static char *\nget_shared_library_fullname ()\n{\n#if !(defined _WIN32 && !defined __CYGWIN__) && !defined __EMX__\n  static bool tried_find_shared_library_fullname;\n  if (!tried_find_shared_library_fullname)\n    {\n      find_shared_library_fullname ();\n      tried_find_shared_library_fullname = true;\n    }\n#endif\n  return shared_library_fullname;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_shared_library_fullname ()",
        "*"
      ]
    },
    "relocate": {
      "start_point": [
        473,
        0
      ],
      "end_point": [
        581,
        1
      ],
      "content": "const char *\nrelocate (const char *pathname)\n{\n#if defined PIC && defined INSTALLDIR && ENABLE_COSTLY_RELOCATABLE\n  static int initialized;\n\n  /* Initialization code for a shared library.  */\n  if (!initialized)\n    {\n      /* At this point, orig_prefix and curr_prefix likely have already been\n         set through the main program's set_program_name_and_installdir\n         function.  This is sufficient in the case that the library has\n         initially been installed in the same orig_prefix.  But we can do\n         better, to also cover the cases that 1. it has been installed\n         in a different prefix before being moved to orig_prefix and (later)\n         to curr_prefix, 2. unlike the program, it has not moved away from\n         orig_prefix.  */\n      const char *orig_installprefix = INSTALLPREFIX;\n      const char *orig_installdir = INSTALLDIR;\n      char *curr_prefix_better;\n\n      curr_prefix_better =\n        compute_curr_prefix (orig_installprefix, orig_installdir,\n                             get_shared_library_fullname ());\n\n      set_relocation_prefix (orig_installprefix,\n                             curr_prefix_better != NULL\n                             ? curr_prefix_better\n                             : curr_prefix);\n\n      if (curr_prefix_better != NULL)\n        free (curr_prefix_better);\n\n      initialized = 1;\n    }\n#endif\n\n  /* Note: It is not necessary to perform case insensitive comparison here,\n     even for DOS-like file systems, because the pathname argument was\n     typically created from the same Makefile variable as orig_prefix came\n     from.  */\n  if (orig_prefix != NULL && curr_prefix != NULL\n      && strncmp (pathname, orig_prefix, orig_prefix_len) == 0)\n    {\n      if (pathname[orig_prefix_len] == '\\0')\n        {\n          /* pathname equals orig_prefix.  */\n          char *result = (char *) xmalloc (strlen (curr_prefix) + 1);\n\n#ifdef NO_XMALLOC\n          if (result != NULL)\n#endif\n            {\n              strcpy (result, curr_prefix);\n              return result;\n            }\n        }\n      else if (ISSLASH (pathname[orig_prefix_len]))\n        {\n          /* pathname starts with orig_prefix.  */\n          const char *pathname_tail = &pathname[orig_prefix_len];\n          char *result =\n            (char *) xmalloc (curr_prefix_len + strlen (pathname_tail) + 1);\n\n#ifdef NO_XMALLOC\n          if (result != NULL)\n#endif\n            {\n              memcpy (result, curr_prefix, curr_prefix_len);\n              strcpy (result + curr_prefix_len, pathname_tail);\n              return result;\n            }\n        }\n    }\n\n#ifdef __EMX__\n# ifdef __KLIBC__\n#  undef strncmp\n\n  if (strncmp (pathname, \"/@unixroot\", 10) == 0\n      && (pathname[10] == '\\0' || ISSLASH (pathname[10])))\n    {\n      /* kLIBC itself processes /@unixroot prefix */\n      return pathname;\n    }\n  else\n# endif\n  if (ISSLASH (pathname[0]))\n    {\n      const char *unixroot = getenv (\"UNIXROOT\");\n\n      if (unixroot && HAS_DEVICE (unixroot) && unixroot[2] == '\\0')\n        {\n          char *result = (char *) xmalloc (2 + strlen (pathname) + 1);\n#ifdef NO_XMALLOC\n          if (result != NULL)\n#endif\n            {\n              memcpy (result, unixroot, 2);\n              strcpy (result + 2, pathname);\n              return result;\n            }\n        }\n    }\n#endif\n\n  /* Nothing to relocate.  */\n  return pathname;\n}",
      "lines": 109,
      "depth": 17,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nrelocate (const char *pathname)",
        "*"
      ]
    },
    "relocate2": {
      "start_point": [
        588,
        0
      ],
      "end_point": [
        594,
        1
      ],
      "content": "const char *\nrelocate2 (const char *pathname, char **allocatedp)\n{\n  const char *result = relocate (pathname);\n  *allocatedp = (result != pathname ? (char *) result : NULL);\n  return result;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nrelocate2 (const char *pathname, char **allocatedp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/relocatable.h": {},
  "libunistring/libunistring-0.9.10/lib/signbitd.c": {
    "gl_signbitd": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "int\ngl_signbitd (double arg)\n{\n#if defined DBL_SIGNBIT_WORD && defined DBL_SIGNBIT_BIT\n  /* The use of a union to extract the bits of the representation of a\n     'long double' is safe in practice, despite of the \"aliasing rules\" of\n     C99, because the GCC docs say\n       \"Even with '-fstrict-aliasing', type-punning is allowed, provided the\n        memory is accessed through the union type.\"\n     and similarly for other compilers.  */\n# define NWORDS \\\n    ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n  union { double value; unsigned int word[NWORDS]; } m;\n  m.value = arg;\n  return (m.word[DBL_SIGNBIT_WORD] >> DBL_SIGNBIT_BIT) & 1;\n#elif HAVE_COPYSIGN_IN_LIBC\n  return copysign (1.0, arg) < 0;\n#else\n  /* This does not do the right thing for NaN, but this is irrelevant for\n     most use cases.  */\n  if (isnand (arg))\n    return 0;\n  if (arg < 0.0)\n    return 1;\n  else if (arg == 0.0)\n    {\n      /* Distinguish 0.0 and -0.0.  */\n      static double plus_zero = 0.0;\n      double arg_mem = arg;\n      return (memcmp (&plus_zero, &arg_mem, SIZEOF_DBL) != 0);\n    }\n  else\n    return 0;\n#endif\n}",
      "lines": 35,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/signbitf.c": {
    "gl_signbitf": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "int\ngl_signbitf (float arg)\n{\n#if defined FLT_SIGNBIT_WORD && defined FLT_SIGNBIT_BIT\n  /* The use of a union to extract the bits of the representation of a\n     'long double' is safe in practice, despite of the \"aliasing rules\" of\n     C99, because the GCC docs say\n       \"Even with '-fstrict-aliasing', type-punning is allowed, provided the\n        memory is accessed through the union type.\"\n     and similarly for other compilers.  */\n# define NWORDS \\\n    ((sizeof (float) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n  union { float value; unsigned int word[NWORDS]; } m;\n  m.value = arg;\n  return (m.word[FLT_SIGNBIT_WORD] >> FLT_SIGNBIT_BIT) & 1;\n#elif HAVE_COPYSIGNF_IN_LIBC\n  return copysignf (1.0f, arg) < 0;\n#else\n  /* This does not do the right thing for NaN, but this is irrelevant for\n     most use cases.  */\n  if (isnanf (arg))\n    return 0;\n  if (arg < 0.0f)\n    return 1;\n  else if (arg == 0.0f)\n    {\n      /* Distinguish 0.0f and -0.0f.  */\n      static float plus_zero = 0.0f;\n      float arg_mem = arg;\n      return (memcmp (&plus_zero, &arg_mem, SIZEOF_FLT) != 0);\n    }\n  else\n    return 0;\n#endif\n}",
      "lines": 35,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/signbitl.c": {
    "gl_signbitl": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "int\ngl_signbitl (long double arg)\n{\n#if defined LDBL_SIGNBIT_WORD && defined LDBL_SIGNBIT_BIT\n  /* The use of a union to extract the bits of the representation of a\n     'long double' is safe in practice, despite of the \"aliasing rules\" of\n     C99, because the GCC docs say\n       \"Even with '-fstrict-aliasing', type-punning is allowed, provided the\n        memory is accessed through the union type.\"\n     and similarly for other compilers.  */\n# define NWORDS \\\n    ((sizeof (long double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n  union { long double value; unsigned int word[NWORDS]; } m;\n  m.value = arg;\n  return (m.word[LDBL_SIGNBIT_WORD] >> LDBL_SIGNBIT_BIT) & 1;\n#elif HAVE_COPYSIGNL_IN_LIBC\n  return copysignl (1.0L, arg) < 0;\n#else\n  /* This does not do the right thing for NaN, but this is irrelevant for\n     most use cases.  */\n  if (isnanl (arg))\n    return 0;\n  if (arg < 0.0L)\n    return 1;\n  else if (arg == 0.0L)\n    {\n      /* Distinguish 0.0L and -0.0L.  */\n      static long double plus_zero = 0.0L;\n      long double arg_mem = arg;\n      return (memcmp (&plus_zero, &arg_mem, SIZEOF_LDBL) != 0);\n    }\n  else\n    return 0;\n#endif\n}",
      "lines": 35,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/size_max.h": {},
  "libunistring/libunistring-0.9.10/lib/stdbool.in.h": {},
  "libunistring/libunistring-0.9.10/lib/stdbool.mini.h": {},
  "libunistring/libunistring-0.9.10/lib/stddef.in.h": {},
  "libunistring/libunistring-0.9.10/lib/stdint.in.h": {},
  "libunistring/libunistring-0.9.10/lib/stdint.mini.h": {},
  "libunistring/libunistring-0.9.10/lib/stdio-impl.h": {},
  "libunistring/libunistring-0.9.10/lib/stdlib.in.h": {},
  "libunistring/libunistring-0.9.10/lib/str-kmp.h": {
    "knuth_morris_pratt": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "static bool\nknuth_morris_pratt (const UNIT *haystack,\n                    const UNIT *needle, size_t needle_len,\n                    const UNIT **resultp)\n{\n  size_t m = needle_len;\n\n  /* Allocate the table.  */\n  size_t *table = (size_t *) nmalloca (m, sizeof (size_t));\n  if (table == NULL)\n    return false;\n  /* Fill the table.\n     For 0 < i < m:\n       0 < table[i] <= i is defined such that\n       forall 0 < x < table[i]: needle[x..i-1] != needle[0..i-1-x],\n       and table[i] is as large as possible with this property.\n     This implies:\n     1) For 0 < i < m:\n          If table[i] < i,\n          needle[table[i]..i-1] = needle[0..i-1-table[i]].\n     2) For 0 < i < m:\n          rhaystack[0..i-1] == needle[0..i-1]\n          and exists h, i <= h < m: rhaystack[h] != needle[h]\n          implies\n          forall 0 <= x < table[i]: rhaystack[x..x+m-1] != needle[0..m-1].\n     table[0] remains uninitialized.  */\n  {\n    size_t i, j;\n\n    /* i = 1: Nothing to verify for x = 0.  */\n    table[1] = 1;\n    j = 0;\n\n    for (i = 2; i < m; i++)\n      {\n        /* Here: j = i-1 - table[i-1].\n           The inequality needle[x..i-1] != needle[0..i-1-x] is known to hold\n           for x < table[i-1], by induction.\n           Furthermore, if j>0: needle[i-1-j..i-2] = needle[0..j-1].  */\n        UNIT b = CANON_ELEMENT (needle[i - 1]);\n\n        for (;;)\n          {\n            /* Invariants: The inequality needle[x..i-1] != needle[0..i-1-x]\n               is known to hold for x < i-1-j.\n               Furthermore, if j>0: needle[i-1-j..i-2] = needle[0..j-1].  */\n            if (b == CANON_ELEMENT (needle[j]))\n              {\n                /* Set table[i] := i-1-j.  */\n                table[i] = i - ++j;\n                break;\n              }\n            /* The inequality needle[x..i-1] != needle[0..i-1-x] also holds\n               for x = i-1-j, because\n                 needle[i-1] != needle[j] = needle[i-1-x].  */\n            if (j == 0)\n              {\n                /* The inequality holds for all possible x.  */\n                table[i] = i;\n                break;\n              }\n            /* The inequality needle[x..i-1] != needle[0..i-1-x] also holds\n               for i-1-j < x < i-1-j+table[j], because for these x:\n                 needle[x..i-2]\n                 = needle[x-(i-1-j)..j-1]\n                 != needle[0..j-1-(x-(i-1-j))]  (by definition of table[j])\n                    = needle[0..i-2-x],\n               hence needle[x..i-1] != needle[0..i-1-x].\n               Furthermore\n                 needle[i-1-j+table[j]..i-2]\n                 = needle[table[j]..j-1]\n                 = needle[0..j-1-table[j]]  (by definition of table[j]).  */\n            j = j - table[j];\n          }\n        /* Here: j = i - table[i].  */\n      }\n  }\n\n  /* Search, using the table to accelerate the processing.  */\n  {\n    size_t j;\n    const UNIT *rhaystack;\n    const UNIT *phaystack;\n\n    *resultp = NULL;\n    j = 0;\n    rhaystack = haystack;\n    phaystack = haystack;\n    /* Invariant: phaystack = rhaystack + j.  */\n    while (*phaystack != 0)\n      if (CANON_ELEMENT (needle[j]) == CANON_ELEMENT (*phaystack))\n        {\n          j++;\n          phaystack++;\n          if (j == m)\n            {\n              /* The entire needle has been found.  */\n              *resultp = rhaystack;\n              break;\n            }\n        }\n      else if (j > 0)\n        {\n          /* Found a match of needle[0..j-1], mismatch at needle[j].  */\n          rhaystack += table[j];\n          j -= table[j];\n        }\n      else\n        {\n          /* Found a mismatch at needle[0] already.  */\n          rhaystack++;\n          phaystack++;\n        }\n  }\n\n  freea (table);\n  return true;\n}",
      "lines": 118,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/str-two-way.h": {
    "critical_factorization": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        230,
        1
      ],
      "content": "static size_t\ncritical_factorization (const unsigned char *needle, size_t needle_len,\n                        size_t *period)\n{\n  /* Index of last byte of left half, or SIZE_MAX.  */\n  size_t max_suffix, max_suffix_rev;\n  size_t j; /* Index into NEEDLE for current candidate suffix.  */\n  size_t k; /* Offset into current period.  */\n  size_t p; /* Intermediate period.  */\n  unsigned char a, b; /* Current comparison bytes.  */\n\n  /* Special case NEEDLE_LEN of 1 or 2 (all callers already filtered\n     out 0-length needles.  */\n  if (needle_len < 3)\n    {\n      *period = 1;\n      return needle_len - 1;\n    }\n\n  /* Invariants:\n     0 <= j < NEEDLE_LEN - 1\n     -1 <= max_suffix{,_rev} < j (treating SIZE_MAX as if it were signed)\n     min(max_suffix, max_suffix_rev) < global period of NEEDLE\n     1 <= p <= global period of NEEDLE\n     p == global period of the substring NEEDLE[max_suffix{,_rev}+1...j]\n     1 <= k <= p\n  */\n\n  /* Perform lexicographic search.  */\n  max_suffix = SIZE_MAX;\n  j = 0;\n  k = p = 1;\n  while (j + k < needle_len)\n    {\n      a = CANON_ELEMENT (needle[j + k]);\n      b = CANON_ELEMENT (needle[max_suffix + k]);\n      if (a < b)\n        {\n          /* Suffix is smaller, period is entire prefix so far.  */\n          j += k;\n          k = 1;\n          p = j - max_suffix;\n        }\n      else if (a == b)\n        {\n          /* Advance through repetition of the current period.  */\n          if (k != p)\n            ++k;\n          else\n            {\n              j += p;\n              k = 1;\n            }\n        }\n      else /* b < a */\n        {\n          /* Suffix is larger, start over from current location.  */\n          max_suffix = j++;\n          k = p = 1;\n        }\n    }\n  *period = p;\n\n  /* Perform reverse lexicographic search.  */\n  max_suffix_rev = SIZE_MAX;\n  j = 0;\n  k = p = 1;\n  while (j + k < needle_len)\n    {\n      a = CANON_ELEMENT (needle[j + k]);\n      b = CANON_ELEMENT (needle[max_suffix_rev + k]);\n      if (b < a)\n        {\n          /* Suffix is smaller, period is entire prefix so far.  */\n          j += k;\n          k = 1;\n          p = j - max_suffix_rev;\n        }\n      else if (a == b)\n        {\n          /* Advance through repetition of the current period.  */\n          if (k != p)\n            ++k;\n          else\n            {\n              j += p;\n              k = 1;\n            }\n        }\n      else /* a < b */\n        {\n          /* Suffix is larger, start over from current location.  */\n          max_suffix_rev = j++;\n          k = p = 1;\n        }\n    }\n\n  /* Choose the shorter suffix.  Return the index of the first byte of\n     the right half, rather than the last byte of the left half.\n\n     For some examples, 'banana' has two critical factorizations, both\n     exposed by the two lexicographic extreme suffixes of 'anana' and\n     'nana', where both suffixes have a period of 2.  On the other\n     hand, with 'aab' and 'bba', both strings have a single critical\n     factorization of the last byte, with the suffix having a period\n     of 1.  While the maximal lexicographic suffix of 'aab' is 'b',\n     the maximal lexicographic suffix of 'bba' is 'ba', which is not a\n     critical factorization.  Conversely, the maximal reverse\n     lexicographic suffix of 'a' works for 'bba', but not 'ab' for\n     'aab'.  The shorter suffix of the two will always be a critical\n     factorization.  */\n  if (max_suffix_rev + 1 < max_suffix + 1)\n    return max_suffix + 1;\n  *period = p;\n  return max_suffix_rev + 1;\n}",
      "lines": 116,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "two_way_short_needle": {
      "start_point": [
        242,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "static RETURN_TYPE\ntwo_way_short_needle (const unsigned char *haystack, size_t haystack_len,\n                      const unsigned char *needle, size_t needle_len)\n{\n  size_t i; /* Index into current byte of NEEDLE.  */\n  size_t j; /* Index into current window of HAYSTACK.  */\n  size_t period; /* The period of the right half of needle.  */\n  size_t suffix; /* The index of the right half of needle.  */\n\n  /* Factor the needle into two halves, such that the left half is\n     smaller than the global period, and the right half is\n     periodic (with a period as large as NEEDLE_LEN - suffix).  */\n  suffix = critical_factorization (needle, needle_len, &period);\n\n  /* Perform the search.  Each iteration compares the right half\n     first.  */\n  if (CMP_FUNC (needle, needle + period, suffix) == 0)\n    {\n      /* Entire needle is periodic; a mismatch in the left half can\n         only advance by the period, so use memory to avoid rescanning\n         known occurrences of the period in the right half.  */\n      size_t memory = 0;\n      j = 0;\n      while (AVAILABLE (haystack, haystack_len, j, needle_len))\n        {\n          /* Scan for matches in right half.  */\n          i = MAX (suffix, memory);\n          while (i < needle_len && (CANON_ELEMENT (needle[i])\n                                    == CANON_ELEMENT (haystack[i + j])))\n            ++i;\n          if (needle_len <= i)\n            {\n              /* Scan for matches in left half.  */\n              i = suffix - 1;\n              while (memory < i + 1 && (CANON_ELEMENT (needle[i])\n                                        == CANON_ELEMENT (haystack[i + j])))\n                --i;\n              if (i + 1 < memory + 1)\n                return (RETURN_TYPE) (haystack + j);\n              /* No match, so remember how many repetitions of period\n                 on the right half were scanned.  */\n              j += period;\n              memory = needle_len - period;\n            }\n          else\n            {\n              j += i - suffix + 1;\n              memory = 0;\n            }\n        }\n    }\n  else\n    {\n      /* The two halves of needle are distinct; no extra memory is\n         required, and any mismatch results in a maximal shift.  */\n      period = MAX (suffix, needle_len - suffix) + 1;\n      j = 0;\n      while (AVAILABLE (haystack, haystack_len, j, needle_len))\n        {\n          /* Scan for matches in right half.  */\n          i = suffix;\n          while (i < needle_len && (CANON_ELEMENT (needle[i])\n                                    == CANON_ELEMENT (haystack[i + j])))\n            ++i;\n          if (needle_len <= i)\n            {\n              /* Scan for matches in left half.  */\n              i = suffix - 1;\n              while (i != SIZE_MAX && (CANON_ELEMENT (needle[i])\n                                       == CANON_ELEMENT (haystack[i + j])))\n                --i;\n              if (i == SIZE_MAX)\n                return (RETURN_TYPE) (haystack + j);\n              j += period;\n            }\n          else\n            j += i - suffix + 1;\n        }\n    }\n  return NULL;\n}",
      "lines": 81,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "RETURN_TYPE"
      ]
    },
    "two_way_long_needle": {
      "start_point": [
        336,
        0
      ],
      "end_point": [
        454,
        1
      ],
      "content": "static RETURN_TYPE\ntwo_way_long_needle (const unsigned char *haystack, size_t haystack_len,\n                     const unsigned char *needle, size_t needle_len)\n{\n  size_t i; /* Index into current byte of NEEDLE.  */\n  size_t j; /* Index into current window of HAYSTACK.  */\n  size_t period; /* The period of the right half of needle.  */\n  size_t suffix; /* The index of the right half of needle.  */\n  size_t shift_table[1U << CHAR_BIT]; /* See below.  */\n\n  /* Factor the needle into two halves, such that the left half is\n     smaller than the global period, and the right half is\n     periodic (with a period as large as NEEDLE_LEN - suffix).  */\n  suffix = critical_factorization (needle, needle_len, &period);\n\n  /* Populate shift_table.  For each possible byte value c,\n     shift_table[c] is the distance from the last occurrence of c to\n     the end of NEEDLE, or NEEDLE_LEN if c is absent from the NEEDLE.\n     shift_table[NEEDLE[NEEDLE_LEN - 1]] contains the only 0.  */\n  for (i = 0; i < 1U << CHAR_BIT; i++)\n    shift_table[i] = needle_len;\n  for (i = 0; i < needle_len; i++)\n    shift_table[CANON_ELEMENT (needle[i])] = needle_len - i - 1;\n\n  /* Perform the search.  Each iteration compares the right half\n     first.  */\n  if (CMP_FUNC (needle, needle + period, suffix) == 0)\n    {\n      /* Entire needle is periodic; a mismatch in the left half can\n         only advance by the period, so use memory to avoid rescanning\n         known occurrences of the period in the right half.  */\n      size_t memory = 0;\n      size_t shift;\n      j = 0;\n      while (AVAILABLE (haystack, haystack_len, j, needle_len))\n        {\n          /* Check the last byte first; if it does not match, then\n             shift to the next possible match location.  */\n          shift = shift_table[CANON_ELEMENT (haystack[j + needle_len - 1])];\n          if (0 < shift)\n            {\n              if (memory && shift < period)\n                {\n                  /* Since needle is periodic, but the last period has\n                     a byte out of place, there can be no match until\n                     after the mismatch.  */\n                  shift = needle_len - period;\n                }\n              memory = 0;\n              j += shift;\n              continue;\n            }\n          /* Scan for matches in right half.  The last byte has\n             already been matched, by virtue of the shift table.  */\n          i = MAX (suffix, memory);\n          while (i < needle_len - 1 && (CANON_ELEMENT (needle[i])\n                                        == CANON_ELEMENT (haystack[i + j])))\n            ++i;\n          if (needle_len - 1 <= i)\n            {\n              /* Scan for matches in left half.  */\n              i = suffix - 1;\n              while (memory < i + 1 && (CANON_ELEMENT (needle[i])\n                                        == CANON_ELEMENT (haystack[i + j])))\n                --i;\n              if (i + 1 < memory + 1)\n                return (RETURN_TYPE) (haystack + j);\n              /* No match, so remember how many repetitions of period\n                 on the right half were scanned.  */\n              j += period;\n              memory = needle_len - period;\n            }\n          else\n            {\n              j += i - suffix + 1;\n              memory = 0;\n            }\n        }\n    }\n  else\n    {\n      /* The two halves of needle are distinct; no extra memory is\n         required, and any mismatch results in a maximal shift.  */\n      size_t shift;\n      period = MAX (suffix, needle_len - suffix) + 1;\n      j = 0;\n      while (AVAILABLE (haystack, haystack_len, j, needle_len))\n        {\n          /* Check the last byte first; if it does not match, then\n             shift to the next possible match location.  */\n          shift = shift_table[CANON_ELEMENT (haystack[j + needle_len - 1])];\n          if (0 < shift)\n            {\n              j += shift;\n              continue;\n            }\n          /* Scan for matches in right half.  The last byte has\n             already been matched, by virtue of the shift table.  */\n          i = suffix;\n          while (i < needle_len - 1 && (CANON_ELEMENT (needle[i])\n                                        == CANON_ELEMENT (haystack[i + j])))\n            ++i;\n          if (needle_len - 1 <= i)\n            {\n              /* Scan for matches in left half.  */\n              i = suffix - 1;\n              while (i != SIZE_MAX && (CANON_ELEMENT (needle[i])\n                                       == CANON_ELEMENT (haystack[i + j])))\n                --i;\n              if (i == SIZE_MAX)\n                return (RETURN_TYPE) (haystack + j);\n              j += period;\n            }\n          else\n            j += i - suffix + 1;\n        }\n    }\n  return NULL;\n}",
      "lines": 119,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "RETURN_TYPE"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/streq.h": {
    "streq9": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "static inline int\nstreq9 (const char *s1, const char *s2)\n{\n  return strcmp (s1 + 9, s2 + 9) == 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq8": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "static inline int\nstreq8 (const char *s1, const char *s2, char s28)\n{\n  if (s1[8] == s28)\n    {\n      if (s28 == 0)\n        return 1;\n      else\n        return streq9 (s1, s2);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq7": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static inline int\nstreq7 (const char *s1, const char *s2, char s27, char s28)\n{\n  if (s1[7] == s27)\n    {\n      if (s27 == 0)\n        return 1;\n      else\n        return streq8 (s1, s2, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq6": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "static inline int\nstreq6 (const char *s1, const char *s2, char s26, char s27, char s28)\n{\n  if (s1[6] == s26)\n    {\n      if (s26 == 0)\n        return 1;\n      else\n        return streq7 (s1, s2, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq5": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "static inline int\nstreq5 (const char *s1, const char *s2, char s25, char s26, char s27, char s28)\n{\n  if (s1[5] == s25)\n    {\n      if (s25 == 0)\n        return 1;\n      else\n        return streq6 (s1, s2, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq4": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "static inline int\nstreq4 (const char *s1, const char *s2, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[4] == s24)\n    {\n      if (s24 == 0)\n        return 1;\n      else\n        return streq5 (s1, s2, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq3": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "static inline int\nstreq3 (const char *s1, const char *s2, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[3] == s23)\n    {\n      if (s23 == 0)\n        return 1;\n      else\n        return streq4 (s1, s2, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq2": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "static inline int\nstreq2 (const char *s1, const char *s2, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[2] == s22)\n    {\n      if (s22 == 0)\n        return 1;\n      else\n        return streq3 (s1, s2, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq1": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "static inline int\nstreq1 (const char *s1, const char *s2, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[1] == s21)\n    {\n      if (s21 == 0)\n        return 1;\n      else\n        return streq2 (s1, s2, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq0": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "static inline int\nstreq0 (const char *s1, const char *s2, char s20, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[0] == s20)\n    {\n      if (s20 == 0)\n        return 1;\n      else\n        return streq1 (s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/striconveh.c": {
    "iconveh_open": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "int\niconveh_open (const char *to_codeset, const char *from_codeset, iconveh_t *cdp)\n{\n  iconv_t cd;\n  iconv_t cd1;\n  iconv_t cd2;\n\n  /* Avoid glibc-2.1 bug with EUC-KR.  */\n# if ((__GLIBC__ == 2 && __GLIBC_MINOR__ <= 1) && !defined __UCLIBC__) \\\n     && !defined _LIBICONV_VERSION\n  if (c_strcasecmp (from_codeset, \"EUC-KR\") == 0\n      || c_strcasecmp (to_codeset, \"EUC-KR\") == 0)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n# endif\n\n  cd = iconv_open (to_codeset, from_codeset);\n\n  if (STRCASEEQ (from_codeset, \"UTF-8\", 'U','T','F','-','8',0,0,0,0))\n    cd1 = (iconv_t)(-1);\n  else\n    {\n      cd1 = iconv_open (\"UTF-8\", from_codeset);\n      if (cd1 == (iconv_t)(-1))\n        {\n          int saved_errno = errno;\n          if (cd != (iconv_t)(-1))\n            iconv_close (cdp->cd);\n          errno = saved_errno;\n          return -1;\n        }\n    }\n\n  if (STRCASEEQ (to_codeset, \"UTF-8\", 'U','T','F','-','8',0,0,0,0)\n# if (((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 2) || __GLIBC__ > 2) \\\n      && !defined __UCLIBC__) \\\n     || _LIBICONV_VERSION >= 0x0105\n      || c_strcasecmp (to_codeset, \"UTF-8//TRANSLIT\") == 0\n# endif\n     )\n    cd2 = (iconv_t)(-1);\n  else\n    {\n      cd2 = iconv_open (to_codeset, \"UTF-8\");\n      if (cd2 == (iconv_t)(-1))\n        {\n          int saved_errno = errno;\n          if (cd1 != (iconv_t)(-1))\n            iconv_close (cd1);\n          if (cd != (iconv_t)(-1))\n            iconv_close (cd);\n          errno = saved_errno;\n          return -1;\n        }\n    }\n\n  cdp->cd = cd;\n  cdp->cd1 = cd1;\n  cdp->cd2 = cd2;\n  return 0;\n}",
      "lines": 63,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "iconveh_close": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "int\niconveh_close (const iconveh_t *cd)\n{\n  if (cd->cd2 != (iconv_t)(-1) && iconv_close (cd->cd2) < 0)\n    {\n      /* Return -1, but preserve the errno from iconv_close.  */\n      int saved_errno = errno;\n      if (cd->cd1 != (iconv_t)(-1))\n        iconv_close (cd->cd1);\n      if (cd->cd != (iconv_t)(-1))\n        iconv_close (cd->cd);\n      errno = saved_errno;\n      return -1;\n    }\n  if (cd->cd1 != (iconv_t)(-1) && iconv_close (cd->cd1) < 0)\n    {\n      /* Return -1, but preserve the errno from iconv_close.  */\n      int saved_errno = errno;\n      if (cd->cd != (iconv_t)(-1))\n        iconv_close (cd->cd);\n      errno = saved_errno;\n      return -1;\n    }\n  if (cd->cd != (iconv_t)(-1) && iconv_close (cd->cd) < 0)\n    return -1;\n  return 0;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "iconv_carefully": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        216,
        1
      ],
      "content": "static size_t\niconv_carefully (iconv_t cd,\n                 const char **inbuf, size_t *inbytesleft,\n                 char **outbuf, size_t *outbytesleft,\n                 bool *incremented)\n{\n  const char *inptr = *inbuf;\n  const char *inptr_end = inptr + *inbytesleft;\n  char *outptr = *outbuf;\n  size_t outsize = *outbytesleft;\n  const char *inptr_before;\n  size_t res;\n\n  do\n    {\n      size_t insize;\n\n      inptr_before = inptr;\n      res = (size_t)(-1);\n\n      for (insize = 1; inptr + insize <= inptr_end; insize++)\n        {\n          res = iconv (cd,\n                       (ICONV_CONST char **) &inptr, &insize,\n                       &outptr, &outsize);\n          if (!(res == (size_t)(-1) && errno == EINVAL))\n            break;\n          /* iconv can eat up a shift sequence but give EINVAL while attempting\n             to convert the first character.  E.g. libiconv does this.  */\n          if (inptr > inptr_before)\n            {\n              res = 0;\n              break;\n            }\n        }\n\n      if (res == 0)\n        {\n          *outbuf = outptr;\n          *outbytesleft = outsize;\n        }\n    }\n  while (res == 0 && inptr < inptr_end);\n\n  *inbuf = inptr;\n  *inbytesleft = inptr_end - inptr;\n  if (res != (size_t)(-1) && res > 0)\n    {\n      /* iconv() has already incremented INPTR.  We cannot go back to a\n         previous INPTR, otherwise the state inside CD would become invalid,\n         if FROM_CODESET is a stateful encoding.  So, tell the caller that\n         *INBUF has already been incremented.  */\n      *incremented = (inptr > inptr_before);\n      errno = EILSEQ;\n      return (size_t)(-1);\n    }\n  else\n    {\n      *incremented = false;\n      return res;\n    }\n}",
      "lines": 62,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "iconv_carefully_1": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "static size_t\niconv_carefully_1 (iconv_t cd,\n                   const char **inbuf, size_t *inbytesleft,\n                   char **outbuf, size_t *outbytesleft,\n                   bool *incremented)\n{\n  const char *inptr_before = *inbuf;\n  const char *inptr = inptr_before;\n  const char *inptr_end = inptr_before + *inbytesleft;\n  char *outptr = *outbuf;\n  size_t outsize = *outbytesleft;\n  size_t res = (size_t)(-1);\n  size_t insize;\n\n  for (insize = 1; inptr_before + insize <= inptr_end; insize++)\n    {\n      inptr = inptr_before;\n      res = iconv (cd,\n                   (ICONV_CONST char **) &inptr, &insize,\n                   &outptr, &outsize);\n      if (!(res == (size_t)(-1) && errno == EINVAL))\n        break;\n      /* iconv can eat up a shift sequence but give EINVAL while attempting\n         to convert the first character.  E.g. libiconv does this.  */\n      if (inptr > inptr_before)\n        {\n          res = 0;\n          break;\n        }\n    }\n\n  *inbuf = inptr;\n  *inbytesleft = inptr_end - inptr;\n# if !defined _LIBICONV_VERSION && !(defined __GLIBC__ && !defined __UCLIBC__)\n  /* Irix iconv() inserts a NUL byte if it cannot convert.\n     NetBSD iconv() inserts a question mark if it cannot convert.\n     Only GNU libiconv and GNU libc are known to prefer to fail rather\n     than doing a lossy conversion.  */\n  if (res != (size_t)(-1) && res > 0)\n    {\n      /* iconv() has already incremented INPTR.  We cannot go back to a\n         previous INPTR, otherwise the state inside CD would become invalid,\n         if FROM_CODESET is a stateful encoding.  So, tell the caller that\n         *INBUF has already been incremented.  */\n      *incremented = (inptr > inptr_before);\n      errno = EILSEQ;\n      return (size_t)(-1);\n    }\n# endif\n\n  if (res != (size_t)(-1))\n    {\n      *outbuf = outptr;\n      *outbytesleft = outsize;\n    }\n  *incremented = false;\n  return res;\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "utf8conv_carefully": {
      "start_point": [
        291,
        0
      ],
      "end_point": [
        355,
        1
      ],
      "content": "static size_t\nutf8conv_carefully (bool one_character_only,\n                    const char **inbuf, size_t *inbytesleft,\n                    char **outbuf, size_t *outbytesleft,\n                    bool *incremented)\n{\n  const char *inptr = *inbuf;\n  size_t insize = *inbytesleft;\n  char *outptr = *outbuf;\n  size_t outsize = *outbytesleft;\n  size_t res;\n\n  res = 0;\n  do\n    {\n      ucs4_t uc;\n      int n;\n      int m;\n\n      n = u8_mbtoucr (&uc, (const uint8_t *) inptr, insize);\n      if (n < 0)\n        {\n          errno = (n == -2 ? EINVAL : EILSEQ);\n          n = u8_mbtouc (&uc, (const uint8_t *) inptr, insize);\n          inptr += n;\n          insize -= n;\n          res = (size_t)(-1);\n          *incremented = true;\n          break;\n        }\n      if (outsize == 0)\n        {\n          errno = E2BIG;\n          res = (size_t)(-1);\n          *incremented = false;\n          break;\n        }\n      m = u8_uctomb ((uint8_t *) outptr, uc, outsize);\n      if (m == -2)\n        {\n          errno = E2BIG;\n          res = (size_t)(-1);\n          *incremented = false;\n          break;\n        }\n      inptr += n;\n      insize -= n;\n      if (m == -1)\n        {\n          errno = EILSEQ;\n          res = (size_t)(-1);\n          *incremented = true;\n          break;\n        }\n      outptr += m;\n      outsize -= m;\n    }\n  while (!one_character_only && insize > 0);\n\n  *inbuf = inptr;\n  *inbytesleft = insize;\n  *outbuf = outptr;\n  *outbytesleft = outsize;\n  return res;\n}",
      "lines": 65,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "mem_cd_iconveh_internal": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        1022,
        1
      ],
      "content": "static int\nmem_cd_iconveh_internal (const char *src, size_t srclen,\n                         iconv_t cd, iconv_t cd1, iconv_t cd2,\n                         enum iconv_ilseq_handler handler,\n                         size_t extra_alloc,\n                         size_t *offsets,\n                         char **resultp, size_t *lengthp)\n{\n  /* When a conversion error occurs, we cannot start using CD1 and CD2 at\n     this point: FROM_CODESET may be a stateful encoding like ISO-2022-KR.\n     Instead, we have to start afresh from the beginning of SRC.  */\n  /* Use a temporary buffer, so that for small strings, a single malloc()\n     call will be sufficient.  */\n# define tmpbufsize 4096\n  /* The alignment is needed when converting e.g. to glibc's WCHAR_T or\n     libiconv's UCS-4-INTERNAL encoding.  */\n  union { unsigned int align; char buf[tmpbufsize]; } tmp;\n# define tmpbuf tmp.buf\n\n  char *initial_result;\n  char *result;\n  size_t allocated;\n  size_t length;\n  size_t last_length = (size_t)(-1); /* only needed if offsets != NULL */\n\n  if (*resultp != NULL && *lengthp >= sizeof (tmpbuf))\n    {\n      initial_result = *resultp;\n      allocated = *lengthp;\n    }\n  else\n    {\n      initial_result = tmpbuf;\n      allocated = sizeof (tmpbuf);\n    }\n  result = initial_result;\n\n  /* Test whether a direct conversion is possible at all.  */\n  if (cd == (iconv_t)(-1))\n    goto indirectly;\n\n  if (offsets != NULL)\n    {\n      size_t i;\n\n      for (i = 0; i < srclen; i++)\n        offsets[i] = (size_t)(-1);\n\n      last_length = (size_t)(-1);\n    }\n  length = 0;\n\n  /* First, try a direct conversion, and see whether a conversion error\n     occurs at all.  */\n  {\n    const char *inptr = src;\n    size_t insize = srclen;\n\n    /* Avoid glibc-2.1 bug and Solaris 2.7-2.9 bug.  */\n# if defined _LIBICONV_VERSION \\\n     || !(((__GLIBC__ == 2 && __GLIBC_MINOR__ <= 1) && !defined __UCLIBC__) \\\n          || defined __sun)\n    /* Set to the initial state.  */\n    iconv (cd, NULL, NULL, NULL, NULL);\n# endif\n\n    while (insize > 0)\n      {\n        char *outptr = result + length;\n        size_t outsize = allocated - extra_alloc - length;\n        bool incremented;\n        size_t res;\n        bool grow;\n\n        if (offsets != NULL)\n          {\n            if (length != last_length) /* ensure that offset[] be increasing */\n              {\n                offsets[inptr - src] = length;\n                last_length = length;\n              }\n            res = iconv_carefully_1 (cd,\n                                     &inptr, &insize,\n                                     &outptr, &outsize,\n                                     &incremented);\n          }\n        else\n          /* Use iconv_carefully instead of iconv here, because:\n             - If TO_CODESET is UTF-8, we can do the error handling in this\n               loop, no need for a second loop,\n             - With iconv() implementations other than GNU libiconv and GNU\n               libc, if we use iconv() in a big swoop, checking for an E2BIG\n               return, we lose the number of irreversible conversions.  */\n          res = iconv_carefully (cd,\n                                 &inptr, &insize,\n                                 &outptr, &outsize,\n                                 &incremented);\n\n        length = outptr - result;\n        grow = (length + extra_alloc > allocated / 2);\n        if (res == (size_t)(-1))\n          {\n            if (errno == E2BIG)\n              grow = true;\n            else if (errno == EINVAL)\n              break;\n            else if (errno == EILSEQ && handler != iconveh_error)\n              {\n                if (cd2 == (iconv_t)(-1))\n                  {\n                    /* TO_CODESET is UTF-8.  */\n                    /* Error handling can produce up to 1 byte of output.  */\n                    if (length + 1 + extra_alloc > allocated)\n                      {\n                        char *memory;\n\n                        allocated = 2 * allocated;\n                        if (length + 1 + extra_alloc > allocated)\n                          abort ();\n                        if (result == initial_result)\n                          memory = (char *) malloc (allocated);\n                        else\n                          memory = (char *) realloc (result, allocated);\n                        if (memory == NULL)\n                          {\n                            if (result != initial_result)\n                              free (result);\n                            errno = ENOMEM;\n                            return -1;\n                          }\n                        if (result == initial_result)\n                          memcpy (memory, initial_result, length);\n                        result = memory;\n                        grow = false;\n                      }\n                    /* The input is invalid in FROM_CODESET.  Eat up one byte\n                       and emit a question mark.  */\n                    if (!incremented)\n                      {\n                        if (insize == 0)\n                          abort ();\n                        inptr++;\n                        insize--;\n                      }\n                    result[length] = '?';\n                    length++;\n                  }\n                else\n                  goto indirectly;\n              }\n            else\n              {\n                if (result != initial_result)\n                  {\n                    int saved_errno = errno;\n                    free (result);\n                    errno = saved_errno;\n                  }\n                return -1;\n              }\n          }\n        if (insize == 0)\n          break;\n        if (grow)\n          {\n            char *memory;\n\n            allocated = 2 * allocated;\n            if (result == initial_result)\n              memory = (char *) malloc (allocated);\n            else\n              memory = (char *) realloc (result, allocated);\n            if (memory == NULL)\n              {\n                if (result != initial_result)\n                  free (result);\n                errno = ENOMEM;\n                return -1;\n              }\n            if (result == initial_result)\n              memcpy (memory, initial_result, length);\n            result = memory;\n          }\n      }\n  }\n\n  /* Now get the conversion state back to the initial state.\n     But avoid glibc-2.1 bug and Solaris 2.7 bug.  */\n#if defined _LIBICONV_VERSION \\\n    || !(((__GLIBC__ == 2 && __GLIBC_MINOR__ <= 1) && !defined __UCLIBC__) \\\n         || defined __sun)\n  for (;;)\n    {\n      char *outptr = result + length;\n      size_t outsize = allocated - extra_alloc - length;\n      size_t res;\n\n      res = iconv (cd, NULL, NULL, &outptr, &outsize);\n      length = outptr - result;\n      if (res == (size_t)(-1))\n        {\n          if (errno == E2BIG)\n            {\n              char *memory;\n\n              allocated = 2 * allocated;\n              if (result == initial_result)\n                memory = (char *) malloc (allocated);\n              else\n                memory = (char *) realloc (result, allocated);\n              if (memory == NULL)\n                {\n                  if (result != initial_result)\n                    free (result);\n                  errno = ENOMEM;\n                  return -1;\n                }\n              if (result == initial_result)\n                memcpy (memory, initial_result, length);\n              result = memory;\n            }\n          else\n            {\n              if (result != initial_result)\n                {\n                  int saved_errno = errno;\n                  free (result);\n                  errno = saved_errno;\n                }\n              return -1;\n            }\n        }\n      else\n        break;\n    }\n#endif\n\n  /* The direct conversion succeeded.  */\n  goto done;\n\n indirectly:\n  /* The direct conversion failed.\n     Use a conversion through UTF-8.  */\n  if (offsets != NULL)\n    {\n      size_t i;\n\n      for (i = 0; i < srclen; i++)\n        offsets[i] = (size_t)(-1);\n\n      last_length = (size_t)(-1);\n    }\n  length = 0;\n  {\n    const bool slowly = (offsets != NULL || handler == iconveh_error);\n# define utf8bufsize 4096 /* may also be smaller or larger than tmpbufsize */\n    char utf8buf[utf8bufsize + 1];\n    size_t utf8len = 0;\n    const char *in1ptr = src;\n    size_t in1size = srclen;\n    bool do_final_flush1 = true;\n    bool do_final_flush2 = true;\n\n    /* Avoid glibc-2.1 bug and Solaris 2.7-2.9 bug.  */\n# if defined _LIBICONV_VERSION \\\n     || !(((__GLIBC__ == 2 && __GLIBC_MINOR__ <= 1) && !defined __UCLIBC__) \\\n          || defined __sun)\n    /* Set to the initial state.  */\n    if (cd1 != (iconv_t)(-1))\n      iconv (cd1, NULL, NULL, NULL, NULL);\n    if (cd2 != (iconv_t)(-1))\n      iconv (cd2, NULL, NULL, NULL, NULL);\n# endif\n\n    while (in1size > 0 || do_final_flush1 || utf8len > 0 || do_final_flush2)\n      {\n        char *out1ptr = utf8buf + utf8len;\n        size_t out1size = utf8bufsize - utf8len;\n        bool incremented1;\n        size_t res1;\n        int errno1;\n\n        /* Conversion step 1: from FROM_CODESET to UTF-8.  */\n        if (in1size > 0)\n          {\n            if (offsets != NULL\n                && length != last_length) /* ensure that offset[] be increasing */\n              {\n                offsets[in1ptr - src] = length;\n                last_length = length;\n              }\n            if (cd1 != (iconv_t)(-1))\n              {\n                if (slowly)\n                  res1 = iconv_carefully_1 (cd1,\n                                            &in1ptr, &in1size,\n                                            &out1ptr, &out1size,\n                                            &incremented1);\n                else\n                  res1 = iconv_carefully (cd1,\n                                          &in1ptr, &in1size,\n                                          &out1ptr, &out1size,\n                                          &incremented1);\n              }\n            else\n              {\n                /* FROM_CODESET is UTF-8.  */\n                res1 = utf8conv_carefully (slowly,\n                                           &in1ptr, &in1size,\n                                           &out1ptr, &out1size,\n                                           &incremented1);\n              }\n          }\n        else if (do_final_flush1)\n          {\n            /* Now get the conversion state of CD1 back to the initial state.\n               But avoid glibc-2.1 bug and Solaris 2.7 bug.  */\n# if defined _LIBICONV_VERSION \\\n     || !(((__GLIBC__ == 2 && __GLIBC_MINOR__ <= 1) && !defined __UCLIBC__) \\\n          || defined __sun)\n            if (cd1 != (iconv_t)(-1))\n              res1 = iconv (cd1, NULL, NULL, &out1ptr, &out1size);\n            else\n# endif\n              res1 = 0;\n            do_final_flush1 = false;\n            incremented1 = true;\n          }\n        else\n          {\n            res1 = 0;\n            incremented1 = true;\n          }\n        if (res1 == (size_t)(-1)\n            && !(errno == E2BIG || errno == EINVAL || errno == EILSEQ))\n          {\n            if (result != initial_result)\n              {\n                int saved_errno = errno;\n                free (result);\n                errno = saved_errno;\n              }\n            return -1;\n          }\n        if (res1 == (size_t)(-1)\n            && errno == EILSEQ && handler != iconveh_error)\n          {\n            /* The input is invalid in FROM_CODESET.  Eat up one byte and\n               emit a question mark.  Room for the question mark was allocated\n               at the end of utf8buf.  */\n            if (!incremented1)\n              {\n                if (in1size == 0)\n                  abort ();\n                in1ptr++;\n                in1size--;\n              }\n            *out1ptr++ = '?';\n            res1 = 0;\n          }\n        errno1 = errno;\n        utf8len = out1ptr - utf8buf;\n\n        if (offsets != NULL\n            || in1size == 0\n            || utf8len > utf8bufsize / 2\n            || (res1 == (size_t)(-1) && errno1 == E2BIG))\n          {\n            /* Conversion step 2: from UTF-8 to TO_CODESET.  */\n            const char *in2ptr = utf8buf;\n            size_t in2size = utf8len;\n\n            while (in2size > 0\n                   || (in1size == 0 && !do_final_flush1 && do_final_flush2))\n              {\n                char *out2ptr = result + length;\n                size_t out2size = allocated - extra_alloc - length;\n                bool incremented2;\n                size_t res2;\n                bool grow;\n\n                if (in2size > 0)\n                  {\n                    if (cd2 != (iconv_t)(-1))\n                      res2 = iconv_carefully (cd2,\n                                              &in2ptr, &in2size,\n                                              &out2ptr, &out2size,\n                                              &incremented2);\n                    else\n                      /* TO_CODESET is UTF-8.  */\n                      res2 = utf8conv_carefully (false,\n                                                 &in2ptr, &in2size,\n                                                 &out2ptr, &out2size,\n                                                 &incremented2);\n                  }\n                else /* in1size == 0 && !do_final_flush1\n                        && in2size == 0 && do_final_flush2 */\n                  {\n                    /* Now get the conversion state of CD1 back to the initial\n                       state.  But avoid glibc-2.1 bug and Solaris 2.7 bug.  */\n# if defined _LIBICONV_VERSION \\\n     || !(((__GLIBC__ == 2 && __GLIBC_MINOR__ <= 1) && !defined __UCLIBC__) \\\n          || defined __sun)\n                    if (cd2 != (iconv_t)(-1))\n                      res2 = iconv (cd2, NULL, NULL, &out2ptr, &out2size);\n                    else\n# endif\n                      res2 = 0;\n                    do_final_flush2 = false;\n                    incremented2 = true;\n                  }\n\n                length = out2ptr - result;\n                grow = (length + extra_alloc > allocated / 2);\n                if (res2 == (size_t)(-1))\n                  {\n                    if (errno == E2BIG)\n                      grow = true;\n                    else if (errno == EINVAL)\n                      break;\n                    else if (errno == EILSEQ && handler != iconveh_error)\n                      {\n                        /* Error handling can produce up to 10 bytes of ASCII\n                           output.  But TO_CODESET may be UCS-2, UTF-16 or\n                           UCS-4, so use CD2 here as well.  */\n                        char scratchbuf[10];\n                        size_t scratchlen;\n                        ucs4_t uc;\n                        const char *inptr;\n                        size_t insize;\n                        size_t res;\n\n                        if (incremented2)\n                          {\n                            if (u8_prev (&uc, (const uint8_t *) in2ptr,\n                                         (const uint8_t *) utf8buf)\n                                == NULL)\n                              abort ();\n                          }\n                        else\n                          {\n                            int n;\n                            if (in2size == 0)\n                              abort ();\n                            n = u8_mbtouc_unsafe (&uc, (const uint8_t *) in2ptr,\n                                                  in2size);\n                            in2ptr += n;\n                            in2size -= n;\n                          }\n\n                        if (handler == iconveh_escape_sequence)\n                          {\n                            static char hex[16] = \"0123456789ABCDEF\";\n                            scratchlen = 0;\n                            scratchbuf[scratchlen++] = '\\\\';\n                            if (uc < 0x10000)\n                              scratchbuf[scratchlen++] = 'u';\n                            else\n                              {\n                                scratchbuf[scratchlen++] = 'U';\n                                scratchbuf[scratchlen++] = hex[(uc>>28) & 15];\n                                scratchbuf[scratchlen++] = hex[(uc>>24) & 15];\n                                scratchbuf[scratchlen++] = hex[(uc>>20) & 15];\n                                scratchbuf[scratchlen++] = hex[(uc>>16) & 15];\n                              }\n                            scratchbuf[scratchlen++] = hex[(uc>>12) & 15];\n                            scratchbuf[scratchlen++] = hex[(uc>>8) & 15];\n                            scratchbuf[scratchlen++] = hex[(uc>>4) & 15];\n                            scratchbuf[scratchlen++] = hex[uc & 15];\n                          }\n                        else\n                          {\n                            scratchbuf[0] = '?';\n                            scratchlen = 1;\n                          }\n\n                        inptr = scratchbuf;\n                        insize = scratchlen;\n                        if (cd2 != (iconv_t)(-1))\n                          res = iconv (cd2,\n                                       (ICONV_CONST char **) &inptr, &insize,\n                                       &out2ptr, &out2size);\n                        else\n                          {\n                            /* TO_CODESET is UTF-8.  */\n                            if (out2size >= insize)\n                              {\n                                memcpy (out2ptr, inptr, insize);\n                                out2ptr += insize;\n                                out2size -= insize;\n                                inptr += insize;\n                                insize = 0;\n                                res = 0;\n                              }\n                            else\n                              {\n                                errno = E2BIG;\n                                res = (size_t)(-1);\n                              }\n                          }\n                        length = out2ptr - result;\n                        if (res == (size_t)(-1) && errno == E2BIG)\n                          {\n                            char *memory;\n\n                            allocated = 2 * allocated;\n                            if (length + 1 + extra_alloc > allocated)\n                              abort ();\n                            if (result == initial_result)\n                              memory = (char *) malloc (allocated);\n                            else\n                              memory = (char *) realloc (result, allocated);\n                            if (memory == NULL)\n                              {\n                                if (result != initial_result)\n                                  free (result);\n                                errno = ENOMEM;\n                                return -1;\n                              }\n                            if (result == initial_result)\n                              memcpy (memory, initial_result, length);\n                            result = memory;\n                            grow = false;\n\n                            out2ptr = result + length;\n                            out2size = allocated - extra_alloc - length;\n                            if (cd2 != (iconv_t)(-1))\n                              res = iconv (cd2,\n                                           (ICONV_CONST char **) &inptr,\n                                           &insize,\n                                           &out2ptr, &out2size);\n                            else\n                              {\n                                /* TO_CODESET is UTF-8.  */\n                                if (!(out2size >= insize))\n                                  abort ();\n                                memcpy (out2ptr, inptr, insize);\n                                out2ptr += insize;\n                                out2size -= insize;\n                                inptr += insize;\n                                insize = 0;\n                                res = 0;\n                              }\n                            length = out2ptr - result;\n                          }\n# if !defined _LIBICONV_VERSION && !(defined __GLIBC__ && !defined __UCLIBC__)\n                        /* Irix iconv() inserts a NUL byte if it cannot convert.\n                           NetBSD iconv() inserts a question mark if it cannot\n                           convert.\n                           Only GNU libiconv and GNU libc are known to prefer\n                           to fail rather than doing a lossy conversion.  */\n                        if (res != (size_t)(-1) && res > 0)\n                          {\n                            errno = EILSEQ;\n                            res = (size_t)(-1);\n                          }\n# endif\n                        if (res == (size_t)(-1))\n                          {\n                            /* Failure converting the ASCII replacement.  */\n                            if (result != initial_result)\n                              {\n                                int saved_errno = errno;\n                                free (result);\n                                errno = saved_errno;\n                              }\n                            return -1;\n                          }\n                      }\n                    else\n                      {\n                        if (result != initial_result)\n                          {\n                            int saved_errno = errno;\n                            free (result);\n                            errno = saved_errno;\n                          }\n                        return -1;\n                      }\n                  }\n                if (!(in2size > 0\n                      || (in1size == 0 && !do_final_flush1 && do_final_flush2)))\n                  break;\n                if (grow)\n                  {\n                    char *memory;\n\n                    allocated = 2 * allocated;\n                    if (result == initial_result)\n                      memory = (char *) malloc (allocated);\n                    else\n                      memory = (char *) realloc (result, allocated);\n                    if (memory == NULL)\n                      {\n                        if (result != initial_result)\n                          free (result);\n                        errno = ENOMEM;\n                        return -1;\n                      }\n                    if (result == initial_result)\n                      memcpy (memory, initial_result, length);\n                    result = memory;\n                  }\n              }\n\n            /* Move the remaining bytes to the beginning of utf8buf.  */\n            if (in2size > 0)\n              memmove (utf8buf, in2ptr, in2size);\n            utf8len = in2size;\n          }\n\n        if (res1 == (size_t)(-1))\n          {\n            if (errno1 == EINVAL)\n              in1size = 0;\n            else if (errno1 == EILSEQ)\n              {\n                if (result != initial_result)\n                  free (result);\n                errno = errno1;\n                return -1;\n              }\n          }\n      }\n# undef utf8bufsize\n  }\n\n done:\n  /* Now the final memory allocation.  */\n  if (result == tmpbuf)\n    {\n      size_t memsize = length + extra_alloc;\n\n      if (*resultp != NULL && *lengthp >= memsize)\n        result = *resultp;\n      else\n        {\n          char *memory;\n\n          memory = (char *) malloc (memsize > 0 ? memsize : 1);\n          if (memory != NULL)\n            result = memory;\n          else\n            {\n              errno = ENOMEM;\n              return -1;\n            }\n        }\n      memcpy (result, tmpbuf, length);\n    }\n  else if (result != *resultp && length + extra_alloc < allocated)\n    {\n      /* Shrink the allocated memory if possible.  */\n      size_t memsize = length + extra_alloc;\n      char *memory;\n\n      memory = (char *) realloc (result, memsize > 0 ? memsize : 1);\n      if (memory != NULL)\n        result = memory;\n    }\n  *resultp = result;\n  *lengthp = length;\n  return 0;\n# undef tmpbuf\n# undef tmpbufsize\n}",
      "lines": 666,
      "depth": 27,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mem_cd_iconveh": {
      "start_point": [
        1024,
        0
      ],
      "end_point": [
        1033,
        1
      ],
      "content": "int\nmem_cd_iconveh (const char *src, size_t srclen,\n                const iconveh_t *cd,\n                enum iconv_ilseq_handler handler,\n                size_t *offsets,\n                char **resultp, size_t *lengthp)\n{\n  return mem_cd_iconveh_internal (src, srclen, cd->cd, cd->cd1, cd->cd2,\n                                  handler, 0, offsets, resultp, lengthp);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "str_cd_iconveh": {
      "start_point": [
        1035,
        0
      ],
      "end_point": [
        1065,
        1
      ],
      "content": "char *\nstr_cd_iconveh (const char *src,\n                const iconveh_t *cd,\n                enum iconv_ilseq_handler handler)\n{\n  /* For most encodings, a trailing NUL byte in the input will be converted\n     to a trailing NUL byte in the output.  But not for UTF-7.  So that this\n     function is usable for UTF-7, we have to exclude the NUL byte from the\n     conversion and add it by hand afterwards.  */\n  char *result = NULL;\n  size_t length = 0;\n  int retval = mem_cd_iconveh_internal (src, strlen (src),\n                                        cd->cd, cd->cd1, cd->cd2, handler, 1,\n                                        NULL, &result, &length);\n\n  if (retval < 0)\n    {\n      if (result != NULL)\n        {\n          int saved_errno = errno;\n          free (result);\n          errno = saved_errno;\n        }\n      return NULL;\n    }\n\n  /* Add the terminating NUL byte.  */\n  result[length] = '\\0';\n\n  return result;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "char",
        "*\nstr_cd_iconveh (const char *src,\n                const iconveh_t *cd,\n                enum iconv_ilseq_handler handler)",
        "*"
      ]
    },
    "mem_iconveh": {
      "start_point": [
        1069,
        0
      ],
      "end_point": [
        1151,
        1
      ],
      "content": "int\nmem_iconveh (const char *src, size_t srclen,\n             const char *from_codeset, const char *to_codeset,\n             enum iconv_ilseq_handler handler,\n             size_t *offsets,\n             char **resultp, size_t *lengthp)\n{\n  if (srclen == 0)\n    {\n      /* Nothing to convert.  */\n      *lengthp = 0;\n      return 0;\n    }\n  else if (offsets == NULL && c_strcasecmp (from_codeset, to_codeset) == 0)\n    {\n      char *result;\n\n      if (*resultp != NULL && *lengthp >= srclen)\n        result = *resultp;\n      else\n        {\n          result = (char *) malloc (srclen);\n          if (result == NULL)\n            {\n              errno = ENOMEM;\n              return -1;\n            }\n        }\n      memcpy (result, src, srclen);\n      *resultp = result;\n      *lengthp = srclen;\n      return 0;\n    }\n  else\n    {\n#if HAVE_ICONV\n      iconveh_t cd;\n      char *result;\n      size_t length;\n      int retval;\n\n      if (iconveh_open (to_codeset, from_codeset, &cd) < 0)\n        return -1;\n\n      result = *resultp;\n      length = *lengthp;\n      retval = mem_cd_iconveh (src, srclen, &cd, handler, offsets,\n                               &result, &length);\n\n      if (retval < 0)\n        {\n          /* Close cd, but preserve the errno from str_cd_iconv.  */\n          int saved_errno = errno;\n          iconveh_close (&cd);\n          errno = saved_errno;\n        }\n      else\n        {\n          if (iconveh_close (&cd) < 0)\n            {\n              /* Return -1, but free the allocated memory, and while doing\n                 that, preserve the errno from iconveh_close.  */\n              int saved_errno = errno;\n              if (result != *resultp && result != NULL)\n                free (result);\n              errno = saved_errno;\n              return -1;\n            }\n          *resultp = result;\n          *lengthp = length;\n        }\n      return retval;\n#else\n      /* This is a different error code than if iconv_open existed but didn't\n         support from_codeset and to_codeset, so that the caller can emit\n         an error message such as\n           \"iconv() is not supported. Installing GNU libiconv and\n            then reinstalling this package would fix this.\"  */\n      errno = ENOSYS;\n      return -1;\n#endif\n    }\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "str_iconveh": {
      "start_point": [
        1153,
        0
      ],
      "end_point": [
        1207,
        1
      ],
      "content": "char *\nstr_iconveh (const char *src,\n             const char *from_codeset, const char *to_codeset,\n             enum iconv_ilseq_handler handler)\n{\n  if (*src == '\\0' || c_strcasecmp (from_codeset, to_codeset) == 0)\n    {\n      char *result = strdup (src);\n\n      if (result == NULL)\n        errno = ENOMEM;\n      return result;\n    }\n  else\n    {\n#if HAVE_ICONV\n      iconveh_t cd;\n      char *result;\n\n      if (iconveh_open (to_codeset, from_codeset, &cd) < 0)\n        return NULL;\n\n      result = str_cd_iconveh (src, &cd, handler);\n\n      if (result == NULL)\n        {\n          /* Close cd, but preserve the errno from str_cd_iconv.  */\n          int saved_errno = errno;\n          iconveh_close (&cd);\n          errno = saved_errno;\n        }\n      else\n        {\n          if (iconveh_close (&cd) < 0)\n            {\n              /* Return NULL, but free the allocated memory, and while doing\n                 that, preserve the errno from iconveh_close.  */\n              int saved_errno = errno;\n              free (result);\n              errno = saved_errno;\n              return NULL;\n            }\n        }\n      return result;\n#else\n      /* This is a different error code than if iconv_open existed but didn't\n         support from_codeset and to_codeset, so that the caller can emit\n         an error message such as\n           \"iconv() is not supported. Installing GNU libiconv and\n            then reinstalling this package would fix this.\"  */\n      errno = ENOSYS;\n      return NULL;\n#endif\n    }\n}",
      "lines": 55,
      "depth": 14,
      "decorators": [
        "char",
        "*\nstr_iconveh (const char *src,\n             const char *from_codeset, const char *to_codeset,\n             enum iconv_ilseq_handler handler)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/striconveh.h": {},
  "libunistring/libunistring-0.9.10/lib/striconveha.c": {
    "uniconv_register_autodetect": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "int\nuniconv_register_autodetect (const char *name,\n                             const char * const *try_in_order)\n{\n  size_t namelen;\n  size_t listlen;\n  size_t memneed;\n  size_t i;\n  char *memory;\n  struct autodetect_alias *new_alias;\n  char *new_name;\n  const char **new_try_in_order;\n\n  /* The TRY_IN_ORDER list must not be empty.  */\n  if (try_in_order[0] == NULL)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  /* We must deep-copy NAME and TRY_IN_ORDER, because they may be allocated\n     with dynamic extent.  */\n  namelen = strlen (name) + 1;\n  memneed = sizeof (struct autodetect_alias) + namelen + sizeof (char *);\n  for (i = 0; try_in_order[i] != NULL; i++)\n    memneed += sizeof (char *) + strlen (try_in_order[i]) + 1;\n  listlen = i;\n\n  memory = (char *) malloc (memneed);\n  if (memory != NULL)\n    {\n      new_alias = (struct autodetect_alias *) memory;\n      memory += sizeof (struct autodetect_alias);\n\n      new_try_in_order = (const char **) memory;\n      memory += (listlen + 1) * sizeof (char *);\n\n      new_name = (char *) memory;\n      memcpy (new_name, name, namelen);\n      memory += namelen;\n\n      for (i = 0; i < listlen; i++)\n        {\n          size_t len = strlen (try_in_order[i]) + 1;\n          memcpy (memory, try_in_order[i], len);\n          new_try_in_order[i] = (const char *) memory;\n          memory += len;\n        }\n      new_try_in_order[i] = NULL;\n\n      /* Now insert the new alias.  */\n      new_alias->name = new_name;\n      new_alias->encodings_to_try = new_try_in_order;\n      new_alias->next = NULL;\n      /* FIXME: Not multithread-safe.  */\n      *autodetect_list_end = new_alias;\n      autodetect_list_end = &new_alias->next;\n      return 0;\n    }\n  else\n    {\n      errno = ENOMEM;\n      return -1;\n    }\n}",
      "lines": 65,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "mem_iconveha_notranslit": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "static int\nmem_iconveha_notranslit (const char *src, size_t srclen,\n                         const char *from_codeset, const char *to_codeset,\n                         enum iconv_ilseq_handler handler,\n                         size_t *offsets,\n                         char **resultp, size_t *lengthp)\n{\n  int retval = mem_iconveh (src, srclen, from_codeset, to_codeset, handler,\n                            offsets, resultp, lengthp);\n  if (retval >= 0 || errno != EINVAL)\n    return retval;\n  else\n    {\n      struct autodetect_alias *alias;\n\n      /* Unsupported from_codeset or to_codeset. Check whether the caller\n         requested autodetection.  */\n      for (alias = autodetect_list; alias != NULL; alias = alias->next)\n        if (strcmp (from_codeset, alias->name) == 0)\n          {\n            const char * const *encodings;\n\n            if (handler != iconveh_error)\n              {\n                /* First try all encodings without any forgiving.  */\n                encodings = alias->encodings_to_try;\n                do\n                  {\n                    retval = mem_iconveha_notranslit (src, srclen,\n                                                      *encodings, to_codeset,\n                                                      iconveh_error, offsets,\n                                                      resultp, lengthp);\n                    if (!(retval < 0 && errno == EILSEQ))\n                      return retval;\n                    encodings++;\n                  }\n                while (*encodings != NULL);\n              }\n\n            encodings = alias->encodings_to_try;\n            do\n              {\n                retval = mem_iconveha_notranslit (src, srclen,\n                                                  *encodings, to_codeset,\n                                                  handler, offsets,\n                                                  resultp, lengthp);\n                if (!(retval < 0 && errno == EILSEQ))\n                  return retval;\n                encodings++;\n              }\n            while (*encodings != NULL);\n\n            /* Return the last call's result.  */\n            return -1;\n          }\n\n      /* It wasn't an autodetection name.  */\n      errno = EINVAL;\n      return -1;\n    }\n}",
      "lines": 61,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mem_iconveha": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "int\nmem_iconveha (const char *src, size_t srclen,\n              const char *from_codeset, const char *to_codeset,\n              bool transliterate,\n              enum iconv_ilseq_handler handler,\n              size_t *offsets,\n              char **resultp, size_t *lengthp)\n{\n  if (srclen == 0)\n    {\n      /* Nothing to convert.  */\n      *lengthp = 0;\n      return 0;\n    }\n\n  /* When using GNU libc >= 2.2 or GNU libiconv >= 1.5,\n     we want to use transliteration.  */\n#if (((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 2) || __GLIBC__ > 2) \\\n     && !defined __UCLIBC__) \\\n    || _LIBICONV_VERSION >= 0x0105\n  if (transliterate)\n    {\n      int retval;\n      size_t len = strlen (to_codeset);\n      char *to_codeset_suffixed = (char *) malloca (len + 10 + 1);\n      memcpy (to_codeset_suffixed, to_codeset, len);\n      memcpy (to_codeset_suffixed + len, \"//TRANSLIT\", 10 + 1);\n\n      retval = mem_iconveha_notranslit (src, srclen,\n                                        from_codeset, to_codeset_suffixed,\n                                        handler, offsets, resultp, lengthp);\n\n      freea (to_codeset_suffixed);\n\n      return retval;\n    }\n  else\n#endif\n    return mem_iconveha_notranslit (src, srclen,\n                                    from_codeset, to_codeset,\n                                    handler, offsets, resultp, lengthp);\n}",
      "lines": 42,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "str_iconveha_notranslit": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "static char *\nstr_iconveha_notranslit (const char *src,\n                         const char *from_codeset, const char *to_codeset,\n                         enum iconv_ilseq_handler handler)\n{\n  char *result = str_iconveh (src, from_codeset, to_codeset, handler);\n\n  if (result != NULL || errno != EINVAL)\n    return result;\n  else\n    {\n      struct autodetect_alias *alias;\n\n      /* Unsupported from_codeset or to_codeset. Check whether the caller\n         requested autodetection.  */\n      for (alias = autodetect_list; alias != NULL; alias = alias->next)\n        if (strcmp (from_codeset, alias->name) == 0)\n          {\n            const char * const *encodings;\n\n            if (handler != iconveh_error)\n              {\n                /* First try all encodings without any forgiving.  */\n                encodings = alias->encodings_to_try;\n                do\n                  {\n                    result = str_iconveha_notranslit (src,\n                                                      *encodings, to_codeset,\n                                                      iconveh_error);\n                    if (!(result == NULL && errno == EILSEQ))\n                      return result;\n                    encodings++;\n                  }\n                while (*encodings != NULL);\n              }\n\n            encodings = alias->encodings_to_try;\n            do\n              {\n                result = str_iconveha_notranslit (src,\n                                                  *encodings, to_codeset,\n                                                  handler);\n                if (!(result == NULL && errno == EILSEQ))\n                  return result;\n                encodings++;\n              }\n            while (*encodings != NULL);\n\n            /* Return the last call's result.  */\n            return NULL;\n          }\n\n      /* It wasn't an autodetection name.  */\n      errno = EINVAL;\n      return NULL;\n    }\n}",
      "lines": 57,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nstr_iconveha_notranslit (const char *src,\n                         const char *from_codeset, const char *to_codeset,\n                         enum iconv_ilseq_handler handler)",
        "*"
      ]
    },
    "str_iconveha": {
      "start_point": [
        322,
        0
      ],
      "end_point": [
        360,
        1
      ],
      "content": "char *\nstr_iconveha (const char *src,\n              const char *from_codeset, const char *to_codeset,\n              bool transliterate,\n              enum iconv_ilseq_handler handler)\n{\n  if (*src == '\\0' || c_strcasecmp (from_codeset, to_codeset) == 0)\n    {\n      char *result = strdup (src);\n\n      if (result == NULL)\n        errno = ENOMEM;\n      return result;\n    }\n\n  /* When using GNU libc >= 2.2 or GNU libiconv >= 1.5,\n     we want to use transliteration.  */\n#if (((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 2) || __GLIBC__ > 2) \\\n     && !defined __UCLIBC__) \\\n    || _LIBICONV_VERSION >= 0x0105\n  if (transliterate)\n    {\n      char *result;\n      size_t len = strlen (to_codeset);\n      char *to_codeset_suffixed = (char *) malloca (len + 10 + 1);\n      memcpy (to_codeset_suffixed, to_codeset, len);\n      memcpy (to_codeset_suffixed + len, \"//TRANSLIT\", 10 + 1);\n\n      result = str_iconveha_notranslit (src, from_codeset, to_codeset_suffixed,\n                                        handler);\n\n      freea (to_codeset_suffixed);\n\n      return result;\n    }\n  else\n#endif\n    return str_iconveha_notranslit (src, from_codeset, to_codeset, handler);\n}",
      "lines": 39,
      "depth": 13,
      "decorators": [
        "char",
        "*\nstr_iconveha (const char *src,\n              const char *from_codeset, const char *to_codeset,\n              bool transliterate,\n              enum iconv_ilseq_handler handler)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/striconveha.h": {},
  "libunistring/libunistring-0.9.10/lib/string.in.h": {},
  "libunistring/libunistring-0.9.10/lib/strncat.c": {
    "strncat": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "char *\nstrncat (char *dest, const char *src, size_t n)\n{\n  char *destptr = dest + strlen (dest);\n\n  for (; n > 0 && (*destptr = *src) != '\\0'; src++, destptr++, n--)\n    ;\n  if (n == 0)\n    *destptr = '\\0';\n  return dest;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "char",
        "*\nstrncat (char *dest, const char *src, size_t n)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/strstr.c": {
    "strstr": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "char *\nstrstr (const char *haystack_start, const char *needle_start)\n{\n  const char *haystack = haystack_start;\n  const char *needle = needle_start;\n  size_t needle_len; /* Length of NEEDLE.  */\n  size_t haystack_len; /* Known minimum length of HAYSTACK.  */\n  bool ok = true; /* True if NEEDLE is prefix of HAYSTACK.  */\n\n  /* Determine length of NEEDLE, and in the process, make sure\n     HAYSTACK is at least as long (no point processing all of a long\n     NEEDLE if HAYSTACK is too short).  */\n  while (*haystack && *needle)\n    ok &= *haystack++ == *needle++;\n  if (*needle)\n    return NULL;\n  if (ok)\n    return (char *) haystack_start;\n\n  /* Reduce the size of haystack using strchr, since it has a smaller\n     linear coefficient than the Two-Way algorithm.  */\n  needle_len = needle - needle_start;\n  haystack = strchr (haystack_start + 1, *needle_start);\n  if (!haystack || __builtin_expect (needle_len == 1, 0))\n    return (char *) haystack;\n  needle -= needle_len;\n  haystack_len = (haystack > haystack_start + needle_len ? 1\n                  : needle_len + haystack_start - haystack);\n\n  /* Perform the search.  Abstract memory is considered to be an array\n     of 'unsigned char' values, not an array of 'char' values.  See\n     ISO C 99 section 6.2.6.1.  */\n  if (needle_len < LONG_NEEDLE_THRESHOLD)\n    return two_way_short_needle ((const unsigned char *) haystack,\n                                 haystack_len,\n                                 (const unsigned char *) needle, needle_len);\n  return two_way_long_needle ((const unsigned char *) haystack, haystack_len,\n                              (const unsigned char *) needle, needle_len);\n}",
      "lines": 39,
      "depth": 10,
      "decorators": [
        "char",
        "*\nstrstr (const char *haystack_start, const char *needle_start)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/sys_types.in.h": {},
  "libunistring/libunistring-0.9.10/lib/unicase.h": {},
  "libunistring/libunistring-0.9.10/lib/unicase.in.h": {},
  "libunistring/libunistring-0.9.10/lib/uniconv.h": {},
  "libunistring/libunistring-0.9.10/lib/uniconv.in.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype.in.h": {},
  "libunistring/libunistring-0.9.10/lib/unigbrk.h": {},
  "libunistring/libunistring-0.9.10/lib/unigbrk.in.h": {},
  "libunistring/libunistring-0.9.10/lib/unilbrk.h": {},
  "libunistring/libunistring-0.9.10/lib/unilbrk.in.h": {},
  "libunistring/libunistring-0.9.10/lib/uniname.h": {},
  "libunistring/libunistring-0.9.10/lib/uniname.in.h": {},
  "libunistring/libunistring-0.9.10/lib/uninorm.h": {},
  "libunistring/libunistring-0.9.10/lib/uninorm.in.h": {},
  "libunistring/libunistring-0.9.10/lib/unistd.c": {},
  "libunistring/libunistring-0.9.10/lib/unistd.in.h": {
    "rpl_environ": {
      "start_point": [
        442,
        0
      ],
      "end_point": [
        446,
        1
      ],
      "content": "_GL_UNISTD_INLINE char ***\nrpl_environ (void)\n{\n  return &environ;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "char",
        "char",
        "***\nrpl_environ (void)",
        "*",
        "**\nrpl_environ (void)",
        "*",
        "*\nrpl_environ (void)",
        "*"
      ]
    },
    "getpagesize": {
      "start_point": [
        921,
        0
      ],
      "end_point": [
        925,
        1
      ],
      "content": "_GL_UNISTD_INLINE int\ngetpagesize ()\n{\n  return _gl_getpagesize ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "int",
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistdio.h": {},
  "libunistring/libunistring-0.9.10/lib/unistdio.in.h": {},
  "libunistring/libunistring-0.9.10/lib/unistr.h": {
    "u8_mbtouc_unsafe": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "static inline int\nu8_mbtouc_unsafe (ucs4_t *puc, const uint8_t *s, size_t n)\n{\n  uint8_t c = *s;\n\n  if (c < 0x80)\n    {\n      *puc = c;\n      return 1;\n    }\n  else\n    return u8_mbtouc_unsafe_aux (puc, s, n);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u16_mbtouc_unsafe": {
      "start_point": [
        185,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "static inline int\nu16_mbtouc_unsafe (ucs4_t *puc, const uint16_t *s, size_t n)\n{\n  uint16_t c = *s;\n\n  if (c < 0xd800 || c >= 0xe000)\n    {\n      *puc = c;\n      return 1;\n    }\n  else\n    return u16_mbtouc_unsafe_aux (puc, s, n);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u32_mbtouc_unsafe": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "static inline int\nu32_mbtouc_unsafe (ucs4_t *puc,\n                   const uint32_t *s, size_t n _GL_UNUSED_PARAMETER)\n{\n  uint32_t c = *s;\n\n  if (c < 0xd800 || (c >= 0xe000 && c < 0x110000))\n    *puc = c;\n  else\n    /* invalid multibyte character */\n    *puc = 0xfffd;\n  return 1;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u8_mbtouc": {
      "start_point": [
        229,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "static inline int\nu8_mbtouc (ucs4_t *puc, const uint8_t *s, size_t n)\n{\n  uint8_t c = *s;\n\n  if (c < 0x80)\n    {\n      *puc = c;\n      return 1;\n    }\n  else\n    return u8_mbtouc_aux (puc, s, n);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u16_mbtouc": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        264,
        1
      ],
      "content": "static inline int\nu16_mbtouc (ucs4_t *puc, const uint16_t *s, size_t n)\n{\n  uint16_t c = *s;\n\n  if (c < 0xd800 || c >= 0xe000)\n    {\n      *puc = c;\n      return 1;\n    }\n  else\n    return u16_mbtouc_aux (puc, s, n);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u32_mbtouc": {
      "start_point": [
        273,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "static inline int\nu32_mbtouc (ucs4_t *puc, const uint32_t *s, size_t n _GL_UNUSED_PARAMETER)\n{\n  uint32_t c = *s;\n\n  if (c < 0xd800 || (c >= 0xe000 && c < 0x110000))\n    *puc = c;\n  else\n    /* invalid multibyte character */\n    *puc = 0xfffd;\n  return 1;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u8_uctomb": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        335,
        1
      ],
      "content": "static inline int\nu8_uctomb (uint8_t *s, ucs4_t uc, int n)\n{\n  if (uc < 0x80 && n > 0)\n    {\n      s[0] = uc;\n      return 1;\n    }\n  else\n    return u8_uctomb_aux (s, uc, n);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u16_uctomb": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        357,
        1
      ],
      "content": "static inline int\nu16_uctomb (uint16_t *s, ucs4_t uc, int n)\n{\n  if (uc < 0xd800 && n > 0)\n    {\n      s[0] = uc;\n      return 1;\n    }\n  else\n    return u16_uctomb_aux (s, uc, n);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u32_uctomb": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        381,
        1
      ],
      "content": "static inline int\nu32_uctomb (uint32_t *s, ucs4_t uc, int n)\n{\n  if (uc < 0xd800 || (uc >= 0xe000 && uc < 0x110000))\n    {\n      if (n > 0)\n        {\n          *s = uc;\n          return 1;\n        }\n      else\n        return -2;\n    }\n  else\n    return -1;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr.in.h": {
    "u8_mbtouc_unsafe": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "static inline int\nu8_mbtouc_unsafe (ucs4_t *puc, const uint8_t *s, size_t n)\n{\n  uint8_t c = *s;\n\n  if (c < 0x80)\n    {\n      *puc = c;\n      return 1;\n    }\n  else\n    return u8_mbtouc_unsafe_aux (puc, s, n);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u16_mbtouc_unsafe": {
      "start_point": [
        184,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "static inline int\nu16_mbtouc_unsafe (ucs4_t *puc, const uint16_t *s, size_t n)\n{\n  uint16_t c = *s;\n\n  if (c < 0xd800 || c >= 0xe000)\n    {\n      *puc = c;\n      return 1;\n    }\n  else\n    return u16_mbtouc_unsafe_aux (puc, s, n);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u32_mbtouc_unsafe": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "static inline int\nu32_mbtouc_unsafe (ucs4_t *puc,\n                   const uint32_t *s, size_t n _GL_UNUSED_PARAMETER)\n{\n  uint32_t c = *s;\n\n  if (c < 0xd800 || (c >= 0xe000 && c < 0x110000))\n    *puc = c;\n  else\n    /* invalid multibyte character */\n    *puc = 0xfffd;\n  return 1;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u8_mbtouc": {
      "start_point": [
        228,
        0
      ],
      "end_point": [
        240,
        1
      ],
      "content": "static inline int\nu8_mbtouc (ucs4_t *puc, const uint8_t *s, size_t n)\n{\n  uint8_t c = *s;\n\n  if (c < 0x80)\n    {\n      *puc = c;\n      return 1;\n    }\n  else\n    return u8_mbtouc_aux (puc, s, n);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u16_mbtouc": {
      "start_point": [
        251,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "static inline int\nu16_mbtouc (ucs4_t *puc, const uint16_t *s, size_t n)\n{\n  uint16_t c = *s;\n\n  if (c < 0xd800 || c >= 0xe000)\n    {\n      *puc = c;\n      return 1;\n    }\n  else\n    return u16_mbtouc_aux (puc, s, n);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u32_mbtouc": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "static inline int\nu32_mbtouc (ucs4_t *puc, const uint32_t *s, size_t n _GL_UNUSED_PARAMETER)\n{\n  uint32_t c = *s;\n\n  if (c < 0xd800 || (c >= 0xe000 && c < 0x110000))\n    *puc = c;\n  else\n    /* invalid multibyte character */\n    *puc = 0xfffd;\n  return 1;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u8_uctomb": {
      "start_point": [
        324,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "static inline int\nu8_uctomb (uint8_t *s, ucs4_t uc, int n)\n{\n  if (uc < 0x80 && n > 0)\n    {\n      s[0] = uc;\n      return 1;\n    }\n  else\n    return u8_uctomb_aux (s, uc, n);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u16_uctomb": {
      "start_point": [
        346,
        0
      ],
      "end_point": [
        356,
        1
      ],
      "content": "static inline int\nu16_uctomb (uint16_t *s, ucs4_t uc, int n)\n{\n  if (uc < 0xd800 && n > 0)\n    {\n      s[0] = uc;\n      return 1;\n    }\n  else\n    return u16_uctomb_aux (s, uc, n);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u32_uctomb": {
      "start_point": [
        365,
        0
      ],
      "end_point": [
        380,
        1
      ],
      "content": "static inline int\nu32_uctomb (uint32_t *s, ucs4_t uc, int n)\n{\n  if (uc < 0xd800 || (uc >= 0xe000 && uc < 0x110000))\n    {\n      if (n > 0)\n        {\n          *s = uc;\n          return 1;\n        }\n      else\n        return -2;\n    }\n  else\n    return -1;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistring-notinline.h": {},
  "libunistring/libunistring-0.9.10/lib/unitypes.h": {},
  "libunistring/libunistring-0.9.10/lib/unitypes.in.h": {},
  "libunistring/libunistring-0.9.10/lib/uniwbrk.h": {},
  "libunistring/libunistring-0.9.10/lib/uniwbrk.in.h": {},
  "libunistring/libunistring-0.9.10/lib/uniwidth.h": {},
  "libunistring/libunistring-0.9.10/lib/uniwidth.in.h": {},
  "libunistring/libunistring-0.9.10/lib/unused-parameter.h": {},
  "libunistring/libunistring-0.9.10/lib/vasnprintf.c": {
    "local_strnlen": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "static size_t\nlocal_strnlen (const char *string, size_t maxlen)\n{\n  const char *end = memchr (string, '\\0', maxlen);\n  return end ? (size_t) (end - string) : maxlen;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "local_wcslen": {
      "start_point": [
        256,
        0
      ],
      "end_point": [
        264,
        1
      ],
      "content": "static size_t\nlocal_wcslen (const wchar_t *s)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; *ptr != (wchar_t) 0; ptr++)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "local_wcsnlen": {
      "start_point": [
        275,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "static size_t\nlocal_wcsnlen (const wchar_t *s, size_t maxlen)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; maxlen > 0 && *ptr != (wchar_t) 0; ptr++, maxlen--)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "decimal_point_char": {
      "start_point": [
        292,
        0
      ],
      "end_point": [
        311,
        1
      ],
      "content": "static char\ndecimal_point_char (void)\n{\n  const char *point;\n  /* Determine it in a multithread-safe way.  We know nl_langinfo is\n     multithread-safe on glibc systems and Mac OS X systems, but is not required\n     to be multithread-safe by POSIX.  sprintf(), however, is multithread-safe.\n     localeconv() is rarely multithread-safe.  */\n#  if HAVE_NL_LANGINFO && (__GLIBC__ || defined __UCLIBC__ || (defined __APPLE__ && defined __MACH__))\n  point = nl_langinfo (RADIXCHAR);\n#  elif 1\n  char pointbuf[5];\n  sprintf (pointbuf, \"%#.0f\", 1.0);\n  point = &pointbuf[1];\n#  else\n  point = localeconv () -> decimal_point;\n#  endif\n  /* The decimal point is always a single byte: either '.' or ','.  */\n  return (point[0] != '\\0' ? point[0] : '.');\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "is_infinite_or_zero": {
      "start_point": [
        318,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "static int\nis_infinite_or_zero (double x)\n{\n  return isnand (x) || x + x == x;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_infinite_or_zerol": {
      "start_point": [
        329,
        0
      ],
      "end_point": [
        333,
        1
      ],
      "content": "static int\nis_infinite_or_zerol (long double x)\n{\n  return isnanl (x) || x + x == x;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "multiply": {
      "start_point": [
        361,
        0
      ],
      "end_point": [
        424,
        1
      ],
      "content": "static void *\nmultiply (mpn_t src1, mpn_t src2, mpn_t *dest)\n{\n  const mp_limb_t *p1;\n  const mp_limb_t *p2;\n  size_t len1;\n  size_t len2;\n\n  if (src1.nlimbs <= src2.nlimbs)\n    {\n      len1 = src1.nlimbs;\n      p1 = src1.limbs;\n      len2 = src2.nlimbs;\n      p2 = src2.limbs;\n    }\n  else\n    {\n      len1 = src2.nlimbs;\n      p1 = src2.limbs;\n      len2 = src1.nlimbs;\n      p2 = src1.limbs;\n    }\n  /* Now 0 <= len1 <= len2.  */\n  if (len1 == 0)\n    {\n      /* src1 or src2 is zero.  */\n      dest->nlimbs = 0;\n      dest->limbs = (mp_limb_t *) malloc (1);\n    }\n  else\n    {\n      /* Here 1 <= len1 <= len2.  */\n      size_t dlen;\n      mp_limb_t *dp;\n      size_t k, i, j;\n\n      dlen = len1 + len2;\n      dp = (mp_limb_t *) malloc (dlen * sizeof (mp_limb_t));\n      if (dp == NULL)\n        return NULL;\n      for (k = len2; k > 0; )\n        dp[--k] = 0;\n      for (i = 0; i < len1; i++)\n        {\n          mp_limb_t digit1 = p1[i];\n          mp_twolimb_t carry = 0;\n          for (j = 0; j < len2; j++)\n            {\n              mp_limb_t digit2 = p2[j];\n              carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n              carry += dp[i + j];\n              dp[i + j] = (mp_limb_t) carry;\n              carry = carry >> GMP_LIMB_BITS;\n            }\n          dp[i + len2] = (mp_limb_t) carry;\n        }\n      /* Normalise.  */\n      while (dlen > 0 && dp[dlen - 1] == 0)\n        dlen--;\n      dest->nlimbs = dlen;\n      dest->limbs = dp;\n    }\n  return dest->limbs;\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nmultiply (mpn_t src1, mpn_t src2, mpn_t *dest)",
        "*"
      ]
    },
    "divide": {
      "start_point": [
        433,
        0
      ],
      "end_point": [
        856,
        1
      ],
      "content": "static void *\ndivide (mpn_t a, mpn_t b, mpn_t *q)\n{\n  /* Algorithm:\n     First normalise a and b: a=[a[m-1],...,a[0]], b=[b[n-1],...,b[0]]\n     with m>=0 and n>0 (in base beta = 2^GMP_LIMB_BITS).\n     If m<n, then q:=0 and r:=a.\n     If m>=n=1, perform a single-precision division:\n       r:=0, j:=m,\n       while j>0 do\n         {Here (q[m-1]*beta^(m-1)+...+q[j]*beta^j) * b[0] + r*beta^j =\n               = a[m-1]*beta^(m-1)+...+a[j]*beta^j und 0<=r<b[0]<beta}\n         j:=j-1, r:=r*beta+a[j], q[j]:=floor(r/b[0]), r:=r-b[0]*q[j].\n       Normalise [q[m-1],...,q[0]], yields q.\n     If m>=n>1, perform a multiple-precision division:\n       We have a/b < beta^(m-n+1).\n       s:=intDsize-1-(highest bit in b[n-1]), 0<=s<intDsize.\n       Shift a and b left by s bits, copying them. r:=a.\n       r=[r[m],...,r[0]], b=[b[n-1],...,b[0]] with b[n-1]>=beta/2.\n       For j=m-n,...,0: {Here 0 <= r < b*beta^(j+1).}\n         Compute q* :\n           q* := floor((r[j+n]*beta+r[j+n-1])/b[n-1]).\n           In case of overflow (q* >= beta) set q* := beta-1.\n           Compute c2 := ((r[j+n]*beta+r[j+n-1]) - q* * b[n-1])*beta + r[j+n-2]\n           and c3 := b[n-2] * q*.\n           {We have 0 <= c2 < 2*beta^2, even 0 <= c2 < beta^2 if no overflow\n            occurred.  Furthermore 0 <= c3 < beta^2.\n            If there was overflow and\n            r[j+n]*beta+r[j+n-1] - q* * b[n-1] >= beta, i.e. c2 >= beta^2,\n            the next test can be skipped.}\n           While c3 > c2, {Here 0 <= c2 < c3 < beta^2}\n             Put q* := q* - 1, c2 := c2 + b[n-1]*beta, c3 := c3 - b[n-2].\n           If q* > 0:\n             Put r := r - b * q* * beta^j. In detail:\n               [r[n+j],...,r[j]] := [r[n+j],...,r[j]] - q* * [b[n-1],...,b[0]].\n               hence: u:=0, for i:=0 to n-1 do\n                              u := u + q* * b[i],\n                              r[j+i]:=r[j+i]-(u mod beta) (+ beta, if carry),\n                              u:=u div beta (+ 1, if carry in subtraction)\n                      r[n+j]:=r[n+j]-u.\n               {Since always u = (q* * [b[i-1],...,b[0]] div beta^i) + 1\n                               < q* + 1 <= beta,\n                the carry u does not overflow.}\n             If a negative carry occurs, put q* := q* - 1\n               and [r[n+j],...,r[j]] := [r[n+j],...,r[j]] + [0,b[n-1],...,b[0]].\n         Set q[j] := q*.\n       Normalise [q[m-n],..,q[0]]; this yields the quotient q.\n       Shift [r[n-1],...,r[0]] right by s bits and normalise; this yields the\n       rest r.\n       The room for q[j] can be allocated at the memory location of r[n+j].\n     Finally, round-to-even:\n       Shift r left by 1 bit.\n       If r > b or if r = b and q[0] is odd, q := q+1.\n   */\n  const mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  const mp_limb_t *b_ptr = b.limbs;\n  size_t b_len = b.nlimbs;\n  mp_limb_t *roomptr;\n  mp_limb_t *tmp_roomptr = NULL;\n  mp_limb_t *q_ptr;\n  size_t q_len;\n  mp_limb_t *r_ptr;\n  size_t r_len;\n\n  /* Allocate room for a_len+2 digits.\n     (Need a_len+1 digits for the real division and 1 more digit for the\n     final rounding of q.)  */\n  roomptr = (mp_limb_t *) malloc ((a_len + 2) * sizeof (mp_limb_t));\n  if (roomptr == NULL)\n    return NULL;\n\n  /* Normalise a.  */\n  while (a_len > 0 && a_ptr[a_len - 1] == 0)\n    a_len--;\n\n  /* Normalise b.  */\n  for (;;)\n    {\n      if (b_len == 0)\n        /* Division by zero.  */\n        abort ();\n      if (b_ptr[b_len - 1] == 0)\n        b_len--;\n      else\n        break;\n    }\n\n  /* Here m = a_len >= 0 and n = b_len > 0.  */\n\n  if (a_len < b_len)\n    {\n      /* m<n: trivial case.  q=0, r := copy of a.  */\n      r_ptr = roomptr;\n      r_len = a_len;\n      memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n      q_ptr = roomptr + a_len;\n      q_len = 0;\n    }\n  else if (b_len == 1)\n    {\n      /* n=1: single precision division.\n         beta^(m-1) <= a < beta^m  ==>  beta^(m-2) <= a/b < beta^m  */\n      r_ptr = roomptr;\n      q_ptr = roomptr + 1;\n      {\n        mp_limb_t den = b_ptr[0];\n        mp_limb_t remainder = 0;\n        const mp_limb_t *sourceptr = a_ptr + a_len;\n        mp_limb_t *destptr = q_ptr + a_len;\n        size_t count;\n        for (count = a_len; count > 0; count--)\n          {\n            mp_twolimb_t num =\n              ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--sourceptr;\n            *--destptr = num / den;\n            remainder = num % den;\n          }\n        /* Normalise and store r.  */\n        if (remainder > 0)\n          {\n            r_ptr[0] = remainder;\n            r_len = 1;\n          }\n        else\n          r_len = 0;\n        /* Normalise q.  */\n        q_len = a_len;\n        if (q_ptr[q_len - 1] == 0)\n          q_len--;\n      }\n    }\n  else\n    {\n      /* n>1: multiple precision division.\n         beta^(m-1) <= a < beta^m, beta^(n-1) <= b < beta^n  ==>\n         beta^(m-n-1) <= a/b < beta^(m-n+1).  */\n      /* Determine s.  */\n      size_t s;\n      {\n        mp_limb_t msd = b_ptr[b_len - 1]; /* = b[n-1], > 0 */\n        /* Determine s = GMP_LIMB_BITS - integer_length (msd).\n           Code copied from gnulib's integer_length.c.  */\n# if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)\n        s = __builtin_clz (msd);\n# else\n#  if defined DBL_EXPBIT0_WORD && defined DBL_EXPBIT0_BIT\n        if (GMP_LIMB_BITS <= DBL_MANT_BIT)\n          {\n            /* Use 'double' operations.\n               Assumes an IEEE 754 'double' implementation.  */\n#   define DBL_EXP_MASK ((DBL_MAX_EXP - DBL_MIN_EXP) | 7)\n#   define DBL_EXP_BIAS (DBL_EXP_MASK / 2 - 1)\n#   define NWORDS \\\n     ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n            union { double value; unsigned int word[NWORDS]; } m;\n\n            /* Use a single integer to floating-point conversion.  */\n            m.value = msd;\n\n            s = GMP_LIMB_BITS\n                - (((m.word[DBL_EXPBIT0_WORD] >> DBL_EXPBIT0_BIT) & DBL_EXP_MASK)\n                   - DBL_EXP_BIAS);\n          }\n        else\n#   undef NWORDS\n#  endif\n          {\n            s = 31;\n            if (msd >= 0x10000)\n              {\n                msd = msd >> 16;\n                s -= 16;\n              }\n            if (msd >= 0x100)\n              {\n                msd = msd >> 8;\n                s -= 8;\n              }\n            if (msd >= 0x10)\n              {\n                msd = msd >> 4;\n                s -= 4;\n              }\n            if (msd >= 0x4)\n              {\n                msd = msd >> 2;\n                s -= 2;\n              }\n            if (msd >= 0x2)\n              {\n                msd = msd >> 1;\n                s -= 1;\n              }\n          }\n# endif\n      }\n      /* 0 <= s < GMP_LIMB_BITS.\n         Copy b, shifting it left by s bits.  */\n      if (s > 0)\n        {\n          tmp_roomptr = (mp_limb_t *) malloc (b_len * sizeof (mp_limb_t));\n          if (tmp_roomptr == NULL)\n            {\n              free (roomptr);\n              return NULL;\n            }\n          {\n            const mp_limb_t *sourceptr = b_ptr;\n            mp_limb_t *destptr = tmp_roomptr;\n            mp_twolimb_t accu = 0;\n            size_t count;\n            for (count = b_len; count > 0; count--)\n              {\n                accu += (mp_twolimb_t) *sourceptr++ << s;\n                *destptr++ = (mp_limb_t) accu;\n                accu = accu >> GMP_LIMB_BITS;\n              }\n            /* accu must be zero, since that was how s was determined.  */\n            if (accu != 0)\n              abort ();\n          }\n          b_ptr = tmp_roomptr;\n        }\n      /* Copy a, shifting it left by s bits, yields r.\n         Memory layout:\n         At the beginning: r = roomptr[0..a_len],\n         at the end: r = roomptr[0..b_len-1], q = roomptr[b_len..a_len]  */\n      r_ptr = roomptr;\n      if (s == 0)\n        {\n          memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n          r_ptr[a_len] = 0;\n        }\n      else\n        {\n          const mp_limb_t *sourceptr = a_ptr;\n          mp_limb_t *destptr = r_ptr;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              accu += (mp_twolimb_t) *sourceptr++ << s;\n              *destptr++ = (mp_limb_t) accu;\n              accu = accu >> GMP_LIMB_BITS;\n            }\n          *destptr++ = (mp_limb_t) accu;\n        }\n      q_ptr = roomptr + b_len;\n      q_len = a_len - b_len + 1; /* q will have m-n+1 limbs */\n      {\n        size_t j = a_len - b_len; /* m-n */\n        mp_limb_t b_msd = b_ptr[b_len - 1]; /* b[n-1] */\n        mp_limb_t b_2msd = b_ptr[b_len - 2]; /* b[n-2] */\n        mp_twolimb_t b_msdd = /* b[n-1]*beta+b[n-2] */\n          ((mp_twolimb_t) b_msd << GMP_LIMB_BITS) | b_2msd;\n        /* Division loop, traversed m-n+1 times.\n           j counts down, b is unchanged, beta/2 <= b[n-1] < beta.  */\n        for (;;)\n          {\n            mp_limb_t q_star;\n            mp_limb_t c1;\n            if (r_ptr[j + b_len] < b_msd) /* r[j+n] < b[n-1] ? */\n              {\n                /* Divide r[j+n]*beta+r[j+n-1] by b[n-1], no overflow.  */\n                mp_twolimb_t num =\n                  ((mp_twolimb_t) r_ptr[j + b_len] << GMP_LIMB_BITS)\n                  | r_ptr[j + b_len - 1];\n                q_star = num / b_msd;\n                c1 = num % b_msd;\n              }\n            else\n              {\n                /* Overflow, hence r[j+n]*beta+r[j+n-1] >= beta*b[n-1].  */\n                q_star = (mp_limb_t)~(mp_limb_t)0; /* q* = beta-1 */\n                /* Test whether r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] >= beta\n                   <==> r[j+n]*beta+r[j+n-1] + b[n-1] >= beta*b[n-1]+beta\n                   <==> b[n-1] < floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta)\n                        {<= beta !}.\n                   If yes, jump directly to the subtraction loop.\n                   (Otherwise, r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] < beta\n                    <==> floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta) = b[n-1] ) */\n                if (r_ptr[j + b_len] > b_msd\n                    || (c1 = r_ptr[j + b_len - 1] + b_msd) < b_msd)\n                  /* r[j+n] >= b[n-1]+1 or\n                     r[j+n] = b[n-1] and the addition r[j+n-1]+b[n-1] gives a\n                     carry.  */\n                  goto subtract;\n              }\n            /* q_star = q*,\n               c1 = (r[j+n]*beta+r[j+n-1]) - q* * b[n-1] (>=0, <beta).  */\n            {\n              mp_twolimb_t c2 = /* c1*beta+r[j+n-2] */\n                ((mp_twolimb_t) c1 << GMP_LIMB_BITS) | r_ptr[j + b_len - 2];\n              mp_twolimb_t c3 = /* b[n-2] * q* */\n                (mp_twolimb_t) b_2msd * (mp_twolimb_t) q_star;\n              /* While c2 < c3, increase c2 and decrease c3.\n                 Consider c3-c2.  While it is > 0, decrease it by\n                 b[n-1]*beta+b[n-2].  Because of b[n-1]*beta+b[n-2] >= beta^2/2\n                 this can happen only twice.  */\n              if (c3 > c2)\n                {\n                  q_star = q_star - 1; /* q* := q* - 1 */\n                  if (c3 - c2 > b_msdd)\n                    q_star = q_star - 1; /* q* := q* - 1 */\n                }\n            }\n            if (q_star > 0)\n              subtract:\n              {\n                /* Subtract r := r - b * q* * beta^j.  */\n                mp_limb_t cr;\n                {\n                  const mp_limb_t *sourceptr = b_ptr;\n                  mp_limb_t *destptr = r_ptr + j;\n                  mp_twolimb_t carry = 0;\n                  size_t count;\n                  for (count = b_len; count > 0; count--)\n                    {\n                      /* Here 0 <= carry <= q*.  */\n                      carry =\n                        carry\n                        + (mp_twolimb_t) q_star * (mp_twolimb_t) *sourceptr++\n                        + (mp_limb_t) ~(*destptr);\n                      /* Here 0 <= carry <= beta*q* + beta-1.  */\n                      *destptr++ = ~(mp_limb_t) carry;\n                      carry = carry >> GMP_LIMB_BITS; /* <= q* */\n                    }\n                  cr = (mp_limb_t) carry;\n                }\n                /* Subtract cr from r_ptr[j + b_len], then forget about\n                   r_ptr[j + b_len].  */\n                if (cr > r_ptr[j + b_len])\n                  {\n                    /* Subtraction gave a carry.  */\n                    q_star = q_star - 1; /* q* := q* - 1 */\n                    /* Add b back.  */\n                    {\n                      const mp_limb_t *sourceptr = b_ptr;\n                      mp_limb_t *destptr = r_ptr + j;\n                      mp_limb_t carry = 0;\n                      size_t count;\n                      for (count = b_len; count > 0; count--)\n                        {\n                          mp_limb_t source1 = *sourceptr++;\n                          mp_limb_t source2 = *destptr;\n                          *destptr++ = source1 + source2 + carry;\n                          carry =\n                            (carry\n                             ? source1 >= (mp_limb_t) ~source2\n                             : source1 > (mp_limb_t) ~source2);\n                        }\n                    }\n                    /* Forget about the carry and about r[j+n].  */\n                  }\n              }\n            /* q* is determined.  Store it as q[j].  */\n            q_ptr[j] = q_star;\n            if (j == 0)\n              break;\n            j--;\n          }\n      }\n      r_len = b_len;\n      /* Normalise q.  */\n      if (q_ptr[q_len - 1] == 0)\n        q_len--;\n# if 0 /* Not needed here, since we need r only to compare it with b/2, and\n          b is shifted left by s bits.  */\n      /* Shift r right by s bits.  */\n      if (s > 0)\n        {\n          mp_limb_t ptr = r_ptr + r_len;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = r_len; count > 0; count--)\n            {\n              accu = (mp_twolimb_t) (mp_limb_t) accu << GMP_LIMB_BITS;\n              accu += (mp_twolimb_t) *--ptr << (GMP_LIMB_BITS - s);\n              *ptr = (mp_limb_t) (accu >> GMP_LIMB_BITS);\n            }\n        }\n# endif\n      /* Normalise r.  */\n      while (r_len > 0 && r_ptr[r_len - 1] == 0)\n        r_len--;\n    }\n  /* Compare r << 1 with b.  */\n  if (r_len > b_len)\n    goto increment_q;\n  {\n    size_t i;\n    for (i = b_len;;)\n      {\n        mp_limb_t r_i =\n          (i <= r_len && i > 0 ? r_ptr[i - 1] >> (GMP_LIMB_BITS - 1) : 0)\n          | (i < r_len ? r_ptr[i] << 1 : 0);\n        mp_limb_t b_i = (i < b_len ? b_ptr[i] : 0);\n        if (r_i > b_i)\n          goto increment_q;\n        if (r_i < b_i)\n          goto keep_q;\n        if (i == 0)\n          break;\n        i--;\n      }\n  }\n  if (q_len > 0 && ((q_ptr[0] & 1) != 0))\n    /* q is odd.  */\n    increment_q:\n    {\n      size_t i;\n      for (i = 0; i < q_len; i++)\n        if (++(q_ptr[i]) != 0)\n          goto keep_q;\n      q_ptr[q_len++] = 1;\n    }\n  keep_q:\n  if (tmp_roomptr != NULL)\n    free (tmp_roomptr);\n  q->limbs = q_ptr;\n  q->nlimbs = q_len;\n  return roomptr;\n}",
      "lines": 424,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndivide (mpn_t a, mpn_t b, mpn_t *q)",
        "*"
      ]
    },
    "convert_to_decimal": {
      "start_point": [
        864,
        0
      ],
      "end_point": [
        910,
        1
      ],
      "content": "static char *\nconvert_to_decimal (mpn_t a, size_t extra_zeroes)\n{\n  mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  /* 0.03345 is slightly larger than log(2)/(9*log(10)).  */\n  size_t c_len = 9 * ((size_t)(a_len * (GMP_LIMB_BITS * 0.03345f)) + 1);\n  char *c_ptr = (char *) malloc (xsum (c_len, extra_zeroes));\n  if (c_ptr != NULL)\n    {\n      char *d_ptr = c_ptr;\n      for (; extra_zeroes > 0; extra_zeroes--)\n        *d_ptr++ = '0';\n      while (a_len > 0)\n        {\n          /* Divide a by 10^9, in-place.  */\n          mp_limb_t remainder = 0;\n          mp_limb_t *ptr = a_ptr + a_len;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              mp_twolimb_t num =\n                ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--ptr;\n              *ptr = num / 1000000000;\n              remainder = num % 1000000000;\n            }\n          /* Store the remainder as 9 decimal digits.  */\n          for (count = 9; count > 0; count--)\n            {\n              *d_ptr++ = '0' + (remainder % 10);\n              remainder = remainder / 10;\n            }\n          /* Normalize a.  */\n          if (a_ptr[a_len - 1] == 0)\n            a_len--;\n        }\n      /* Remove leading zeroes.  */\n      while (d_ptr > c_ptr && d_ptr[-1] == '0')\n        d_ptr--;\n      /* But keep at least one zero.  */\n      if (d_ptr == c_ptr)\n        *d_ptr++ = '0';\n      /* Terminate the string.  */\n      *d_ptr = '\\0';\n    }\n  return c_ptr;\n}",
      "lines": 47,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nconvert_to_decimal (mpn_t a, size_t extra_zeroes)",
        "*"
      ]
    },
    "decode_long_double": {
      "start_point": [
        918,
        0
      ],
      "end_point": [
        996,
        1
      ],
      "content": "static void *\ndecode_long_double (long double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  long double y;\n  size_t i;\n\n  /* Allocate memory for result.  */\n  m.nlimbs = (LDBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n  /* Split into exponential part and mantissa.  */\n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n  /* x = 2^exp * y = 2^(exp - LDBL_MANT_BIT) * (y * 2^LDBL_MANT_BIT), and the\n     latter is an integer.  */\n  /* Convert the mantissa (y * 2^LDBL_MANT_BIT) to a sequence of limbs.\n     I'm not sure whether it's safe to cast a 'long double' value between\n     2^31 and 2^32 to 'unsigned int', therefore play safe and cast only\n     'long double' values between 0 and 2^16 (to 'unsigned int' or 'int',\n     doesn't matter).  */\n#  if (LDBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (LDBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = LDBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#  if 0 /* On FreeBSD 6.1/x86, 'long double' numbers sometimes have excess\n           precision.  */\n  if (!(y == 0.0L))\n    abort ();\n#  endif\n  /* Normalise.  */\n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - LDBL_MANT_BIT;\n  return m.limbs;\n}",
      "lines": 79,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndecode_long_double (long double x, int *ep, mpn_t *mp)",
        "*"
      ]
    },
    "decode_double": {
      "start_point": [
        1006,
        0
      ],
      "end_point": [
        1081,
        1
      ],
      "content": "static void *\ndecode_double (double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  double y;\n  size_t i;\n\n  /* Allocate memory for result.  */\n  m.nlimbs = (DBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n  /* Split into exponential part and mantissa.  */\n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n  /* x = 2^exp * y = 2^(exp - DBL_MANT_BIT) * (y * 2^DBL_MANT_BIT), and the\n     latter is an integer.  */\n  /* Convert the mantissa (y * 2^DBL_MANT_BIT) to a sequence of limbs.\n     I'm not sure whether it's safe to cast a 'double' value between\n     2^31 and 2^32 to 'unsigned int', therefore play safe and cast only\n     'double' values between 0 and 2^16 (to 'unsigned int' or 'int',\n     doesn't matter).  */\n#  if (DBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (DBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = DBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n  if (!(y == 0.0))\n    abort ();\n  /* Normalise.  */\n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - DBL_MANT_BIT;\n  return m.limbs;\n}",
      "lines": 76,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndecode_double (double x, int *ep, mpn_t *mp)",
        "*"
      ]
    },
    "scale10_round_decimal_decoded": {
      "start_point": [
        1090,
        0
      ],
      "end_point": [
        1303,
        1
      ],
      "content": "static char *\nscale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)\n{\n  int s;\n  size_t extra_zeroes;\n  unsigned int abs_n;\n  unsigned int abs_s;\n  mp_limb_t *pow5_ptr;\n  size_t pow5_len;\n  unsigned int s_limbs;\n  unsigned int s_bits;\n  mpn_t pow5;\n  mpn_t z;\n  void *z_memory;\n  char *digits;\n\n  if (memory == NULL)\n    return NULL;\n  /* x = 2^e * m, hence\n     y = round (2^e * 10^n * m) = round (2^(e+n) * 5^n * m)\n       = round (2^s * 5^n * m).  */\n  s = e + n;\n  extra_zeroes = 0;\n  /* Factor out a common power of 10 if possible.  */\n  if (s > 0 && n > 0)\n    {\n      extra_zeroes = (s < n ? s : n);\n      s -= extra_zeroes;\n      n -= extra_zeroes;\n    }\n  /* Here y = round (2^s * 5^n * m) * 10^extra_zeroes.\n     Before converting to decimal, we need to compute\n     z = round (2^s * 5^n * m).  */\n  /* Compute 5^|n|, possibly shifted by |s| bits if n and s have the same\n     sign.  2.322 is slightly larger than log(5)/log(2).  */\n  abs_n = (n >= 0 ? n : -n);\n  abs_s = (s >= 0 ? s : -s);\n  pow5_ptr = (mp_limb_t *) malloc (((int)(abs_n * (2.322f / GMP_LIMB_BITS)) + 1\n                                    + abs_s / GMP_LIMB_BITS + 1)\n                                   * sizeof (mp_limb_t));\n  if (pow5_ptr == NULL)\n    {\n      free (memory);\n      return NULL;\n    }\n  /* Initialize with 1.  */\n  pow5_ptr[0] = 1;\n  pow5_len = 1;\n  /* Multiply with 5^|n|.  */\n  if (abs_n > 0)\n    {\n      static mp_limb_t const small_pow5[13 + 1] =\n        {\n          1, 5, 25, 125, 625, 3125, 15625, 78125, 390625, 1953125, 9765625,\n          48828125, 244140625, 1220703125\n        };\n      unsigned int n13;\n      for (n13 = 0; n13 <= abs_n; n13 += 13)\n        {\n          mp_limb_t digit1 = small_pow5[n13 + 13 <= abs_n ? 13 : abs_n - n13];\n          size_t j;\n          mp_twolimb_t carry = 0;\n          for (j = 0; j < pow5_len; j++)\n            {\n              mp_limb_t digit2 = pow5_ptr[j];\n              carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n              pow5_ptr[j] = (mp_limb_t) carry;\n              carry = carry >> GMP_LIMB_BITS;\n            }\n          if (carry > 0)\n            pow5_ptr[pow5_len++] = (mp_limb_t) carry;\n        }\n    }\n  s_limbs = abs_s / GMP_LIMB_BITS;\n  s_bits = abs_s % GMP_LIMB_BITS;\n  if (n >= 0 ? s >= 0 : s <= 0)\n    {\n      /* Multiply with 2^|s|.  */\n      if (s_bits > 0)\n        {\n          mp_limb_t *ptr = pow5_ptr;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = pow5_len; count > 0; count--)\n            {\n              accu += (mp_twolimb_t) *ptr << s_bits;\n              *ptr++ = (mp_limb_t) accu;\n              accu = accu >> GMP_LIMB_BITS;\n            }\n          if (accu > 0)\n            {\n              *ptr = (mp_limb_t) accu;\n              pow5_len++;\n            }\n        }\n      if (s_limbs > 0)\n        {\n          size_t count;\n          for (count = pow5_len; count > 0;)\n            {\n              count--;\n              pow5_ptr[s_limbs + count] = pow5_ptr[count];\n            }\n          for (count = s_limbs; count > 0;)\n            {\n              count--;\n              pow5_ptr[count] = 0;\n            }\n          pow5_len += s_limbs;\n        }\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n        {\n          /* Multiply m with pow5.  No division needed.  */\n          z_memory = multiply (m, pow5, &z);\n        }\n      else\n        {\n          /* Divide m by pow5 and round.  */\n          z_memory = divide (m, pow5, &z);\n        }\n    }\n  else\n    {\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n        {\n          /* n >= 0, s < 0.\n             Multiply m with pow5, then divide by 2^|s|.  */\n          mpn_t numerator;\n          mpn_t denominator;\n          void *tmp_memory;\n          tmp_memory = multiply (m, pow5, &numerator);\n          if (tmp_memory == NULL)\n            {\n              free (pow5_ptr);\n              free (memory);\n              return NULL;\n            }\n          /* Construct 2^|s|.  */\n          {\n            mp_limb_t *ptr = pow5_ptr + pow5_len;\n            size_t i;\n            for (i = 0; i < s_limbs; i++)\n              ptr[i] = 0;\n            ptr[s_limbs] = (mp_limb_t) 1 << s_bits;\n            denominator.limbs = ptr;\n            denominator.nlimbs = s_limbs + 1;\n          }\n          z_memory = divide (numerator, denominator, &z);\n          free (tmp_memory);\n        }\n      else\n        {\n          /* n < 0, s > 0.\n             Multiply m with 2^s, then divide by pow5.  */\n          mpn_t numerator;\n          mp_limb_t *num_ptr;\n          num_ptr = (mp_limb_t *) malloc ((m.nlimbs + s_limbs + 1)\n                                          * sizeof (mp_limb_t));\n          if (num_ptr == NULL)\n            {\n              free (pow5_ptr);\n              free (memory);\n              return NULL;\n            }\n          {\n            mp_limb_t *destptr = num_ptr;\n            {\n              size_t i;\n              for (i = 0; i < s_limbs; i++)\n                *destptr++ = 0;\n            }\n            if (s_bits > 0)\n              {\n                const mp_limb_t *sourceptr = m.limbs;\n                mp_twolimb_t accu = 0;\n                size_t count;\n                for (count = m.nlimbs; count > 0; count--)\n                  {\n                    accu += (mp_twolimb_t) *sourceptr++ << s_bits;\n                    *destptr++ = (mp_limb_t) accu;\n                    accu = accu >> GMP_LIMB_BITS;\n                  }\n                if (accu > 0)\n                  *destptr++ = (mp_limb_t) accu;\n              }\n            else\n              {\n                const mp_limb_t *sourceptr = m.limbs;\n                size_t count;\n                for (count = m.nlimbs; count > 0; count--)\n                  *destptr++ = *sourceptr++;\n              }\n            numerator.limbs = num_ptr;\n            numerator.nlimbs = destptr - num_ptr;\n          }\n          z_memory = divide (numerator, pow5, &z);\n          free (num_ptr);\n        }\n    }\n  free (pow5_ptr);\n  free (memory);\n\n  /* Here y = round (x * 10^n) = z * 10^extra_zeroes.  */\n\n  if (z_memory == NULL)\n    return NULL;\n  digits = convert_to_decimal (z, extra_zeroes);\n  free (z_memory);\n  return digits;\n}",
      "lines": 214,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)",
        "*"
      ]
    },
    "scale10_round_decimal_long_double": {
      "start_point": [
        1312,
        0
      ],
      "end_point": [
        1319,
        1
      ],
      "content": "static char *\nscale10_round_decimal_long_double (long double x, int n)\n{\n  int e IF_LINT(= 0);\n  mpn_t m;\n  void *memory = decode_long_double (x, &e, &m);\n  return scale10_round_decimal_decoded (e, m, memory, n);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_long_double (long double x, int n)",
        "*"
      ]
    },
    "scale10_round_decimal_double": {
      "start_point": [
        1330,
        0
      ],
      "end_point": [
        1337,
        1
      ],
      "content": "static char *\nscale10_round_decimal_double (double x, int n)\n{\n  int e IF_LINT(= 0);\n  mpn_t m;\n  void *memory = decode_double (x, &e, &m);\n  return scale10_round_decimal_decoded (e, m, memory, n);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_double (double x, int n)",
        "*"
      ]
    },
    "floorlog10l": {
      "start_point": [
        1346,
        0
      ],
      "end_point": [
        1428,
        1
      ],
      "content": "static int\nfloorlog10l (long double x)\n{\n  int exp;\n  long double y;\n  double z;\n  double l;\n\n  /* Split into exponential part and mantissa.  */\n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n  if (y == 0.0L)\n    return INT_MIN;\n  if (y < 0.5L)\n    {\n      while (y < (1.0L / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n        {\n          y *= 1.0L * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n          exp -= GMP_LIMB_BITS;\n        }\n      if (y < (1.0L / (1 << 16)))\n        {\n          y *= 1.0L * (1 << 16);\n          exp -= 16;\n        }\n      if (y < (1.0L / (1 << 8)))\n        {\n          y *= 1.0L * (1 << 8);\n          exp -= 8;\n        }\n      if (y < (1.0L / (1 << 4)))\n        {\n          y *= 1.0L * (1 << 4);\n          exp -= 4;\n        }\n      if (y < (1.0L / (1 << 2)))\n        {\n          y *= 1.0L * (1 << 2);\n          exp -= 2;\n        }\n      if (y < (1.0L / (1 << 1)))\n        {\n          y *= 1.0L * (1 << 1);\n          exp -= 1;\n        }\n    }\n  if (!(y >= 0.5L && y < 1.0L))\n    abort ();\n  /* Compute an approximation for l = log2(x) = exp + log2(y).  */\n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n  /* Now 0.95 <= z <= 1.01.  */\n  z = 1 - z;\n  /* log2(1-z) = 1/log(2) * (- z - z^2/2 - z^3/3 - z^4/4 - ...)\n     Four terms are enough to get an approximation with error < 10^-7.  */\n  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n  /* Finally multiply with log(2)/log(10), yields an approximation for\n     log10(x).  */\n  l *= 0.30102999566398119523;\n  /* Round down to the next integer.  */\n  return (int) l + (l < 0 ? -1 : 0);\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "floorlog10": {
      "start_point": [
        1437,
        0
      ],
      "end_point": [
        1519,
        1
      ],
      "content": "static int\nfloorlog10 (double x)\n{\n  int exp;\n  double y;\n  double z;\n  double l;\n\n  /* Split into exponential part and mantissa.  */\n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n  if (y == 0.0)\n    return INT_MIN;\n  if (y < 0.5)\n    {\n      while (y < (1.0 / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n        {\n          y *= 1.0 * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n          exp -= GMP_LIMB_BITS;\n        }\n      if (y < (1.0 / (1 << 16)))\n        {\n          y *= 1.0 * (1 << 16);\n          exp -= 16;\n        }\n      if (y < (1.0 / (1 << 8)))\n        {\n          y *= 1.0 * (1 << 8);\n          exp -= 8;\n        }\n      if (y < (1.0 / (1 << 4)))\n        {\n          y *= 1.0 * (1 << 4);\n          exp -= 4;\n        }\n      if (y < (1.0 / (1 << 2)))\n        {\n          y *= 1.0 * (1 << 2);\n          exp -= 2;\n        }\n      if (y < (1.0 / (1 << 1)))\n        {\n          y *= 1.0 * (1 << 1);\n          exp -= 1;\n        }\n    }\n  if (!(y >= 0.5 && y < 1.0))\n    abort ();\n  /* Compute an approximation for l = log2(x) = exp + log2(y).  */\n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n  /* Now 0.95 <= z <= 1.01.  */\n  z = 1 - z;\n  /* log2(1-z) = 1/log(2) * (- z - z^2/2 - z^3/3 - z^4/4 - ...)\n     Four terms are enough to get an approximation with error < 10^-7.  */\n  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n  /* Finally multiply with log(2)/log(10), yields an approximation for\n     log10(x).  */\n  l *= 0.30102999566398119523;\n  /* Round down to the next integer.  */\n  return (int) l + (l < 0 ? -1 : 0);\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_borderline": {
      "start_point": [
        1525,
        0
      ],
      "end_point": [
        1535,
        1
      ],
      "content": "static int\nis_borderline (const char *digits, size_t precision)\n{\n  for (; precision > 0; precision--, digits++)\n    if (*digits != '0')\n      return 0;\n  if (*digits != '1')\n    return 0;\n  digits++;\n  return *digits == '\\0';\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MAX_ROOM_NEEDED": {
      "start_point": [
        1552,
        0
      ],
      "end_point": [
        1787,
        1
      ],
      "content": "static size_t\nMAX_ROOM_NEEDED (const arguments *ap, size_t arg_index, FCHAR_T conversion,\n                 arg_type type, int flags, size_t width, int has_precision,\n                 size_t precision, int pad_ourselves)\n{\n  size_t tmp_length;\n\n  switch (conversion)\n    {\n    case 'd': case 'i': case 'u':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Multiply by 2, as an estimate for FLAG_GROUP.  */\n      tmp_length = xsum (tmp_length, tmp_length);\n      /* Add 1, to account for a leading sign.  */\n      tmp_length = xsum (tmp_length, 1);\n      break;\n\n    case 'o':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Add 1, to account for a leading sign.  */\n      tmp_length = xsum (tmp_length, 1);\n      break;\n\n    case 'x': case 'X':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Add 2, to account for a leading sign or alternate form.  */\n      tmp_length = xsum (tmp_length, 2);\n      break;\n\n    case 'f': case 'F':\n      if (type == TYPE_LONGDOUBLE)\n        tmp_length =\n          (unsigned int) (LDBL_MAX_EXP\n                          * 0.30103 /* binary -> decimal */\n                          * 2 /* estimate for FLAG_GROUP */\n                         )\n          + 1 /* turn floor into ceil */\n          + 10; /* sign, decimal point etc. */\n      else\n        tmp_length =\n          (unsigned int) (DBL_MAX_EXP\n                          * 0.30103 /* binary -> decimal */\n                          * 2 /* estimate for FLAG_GROUP */\n                         )\n          + 1 /* turn floor into ceil */\n          + 10; /* sign, decimal point etc. */\n      tmp_length = xsum (tmp_length, precision);\n      break;\n\n    case 'e': case 'E': case 'g': case 'G':\n      tmp_length =\n        12; /* sign, decimal point, exponent etc. */\n      tmp_length = xsum (tmp_length, precision);\n      break;\n\n    case 'a': case 'A':\n      if (type == TYPE_LONGDOUBLE)\n        tmp_length =\n          (unsigned int) (LDBL_DIG\n                          * 0.831 /* decimal -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (DBL_DIG\n                          * 0.831 /* decimal -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Account for sign, decimal point etc. */\n      tmp_length = xsum (tmp_length, 12);\n      break;\n\n    case 'c':\n# if HAVE_WINT_T && !WIDE_CHAR_VERSION\n      if (type == TYPE_WIDE_CHAR)\n        tmp_length = MB_CUR_MAX;\n      else\n# endif\n        tmp_length = 1;\n      break;\n\n    case 's':\n# if HAVE_WCHAR_T\n      if (type == TYPE_WIDE_STRING)\n        {\n#  if WIDE_CHAR_VERSION\n          /* ISO C says about %ls in fwprintf:\n               \"If the precision is not specified or is greater than the size\n                of the array, the array shall contain a null wide character.\"\n             So if there is a precision, we must not use wcslen.  */\n          const wchar_t *arg = ap->arg[arg_index].a.a_wide_string;\n\n          if (has_precision)\n            tmp_length = local_wcsnlen (arg, precision);\n          else\n            tmp_length = local_wcslen (arg);\n#  else\n          /* ISO C says about %ls in fprintf:\n               \"If a precision is specified, no more than that many bytes are\n                written (including shift sequences, if any), and the array\n                shall contain a null wide character if, to equal the multibyte\n                character sequence length given by the precision, the function\n                would need to access a wide character one past the end of the\n                array.\"\n             So if there is a precision, we must not use wcslen.  */\n          /* This case has already been handled separately in VASNPRINTF.  */\n          abort ();\n#  endif\n        }\n      else\n# endif\n        {\n# if WIDE_CHAR_VERSION\n          /* ISO C says about %s in fwprintf:\n               \"If the precision is not specified or is greater than the size\n                of the converted array, the converted array shall contain a\n                null wide character.\"\n             So if there is a precision, we must not use strlen.  */\n          /* This case has already been handled separately in VASNPRINTF.  */\n          abort ();\n# else\n          /* ISO C says about %s in fprintf:\n               \"If the precision is not specified or greater than the size of\n                the array, the array shall contain a null character.\"\n             So if there is a precision, we must not use strlen.  */\n          const char *arg = ap->arg[arg_index].a.a_string;\n\n          if (has_precision)\n            tmp_length = local_strnlen (arg, precision);\n          else\n            tmp_length = strlen (arg);\n# endif\n        }\n      break;\n\n    case 'p':\n      tmp_length =\n        (unsigned int) (sizeof (void *) * CHAR_BIT\n                        * 0.25 /* binary -> hexadecimal */\n                       )\n          + 1 /* turn floor into ceil */\n          + 2; /* account for leading 0x */\n      break;\n\n    default:\n      abort ();\n    }\n\n  if (!pad_ourselves)\n    {\n# if ENABLE_UNISTDIO\n      /* Padding considers the number of characters, therefore the number of\n         elements after padding may be\n           > max (tmp_length, width)\n         but is certainly\n           <= tmp_length + width.  */\n      tmp_length = xsum (tmp_length, width);\n# else\n      /* Padding considers the number of elements, says POSIX.  */\n      if (tmp_length < width)\n        tmp_length = width;\n# endif\n    }\n\n  tmp_length = xsum (tmp_length, 1); /* account for trailing NUL */\n\n  return tmp_length;\n}",
      "lines": 236,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "xsum": {
      "start_point": [
        4634,
        16
      ],
      "end_point": [
        5563,
        15
      ],
      "content": "int prefixes[2] IF_LINT (= { 0 });\n                int orig_errno;\n#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif\n\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n#endif\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif\n\n                /* Decide whether to handle the precision ourselves.  */\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif\n\n                /* Decide whether to perform the padding ourselves.  */\n#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif\n\n#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif\n\n                /* Construct the format string for calling snprintf or\n                   sprintf.  */\n                fbp = buf;\n                *fbp++ = '%';\n#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif\n                if (flags & FLAG_LEFT)\n                  *fbp++ = '-';\n                if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';\n                if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';\n                if (flags & FLAG_ALT)\n                  *fbp++ = '#';\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif\n                if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n                if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n\n                switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if defined _WIN32 && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif\n#endif\n                    FALLTHROUGH;\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }\n#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif\n                  *fbp = dp->conversion;\n#if USE_SNPRINTF\n# if ! (((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || (defined _WIN32 && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <https://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <https://msdn.microsoft.com/en-us/library/ms175782.aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif\n\n                /* Construct the arguments for calling snprintf or sprintf.  */\n                prefix_count = 0;\n                if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }\n                if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }\n\n#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif\n\n                orig_errno = errno;\n\n                for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }\n                errno = orig_errno;\n#undef pad_ourselves\n#undef prec_ourselves\n              }",
      "lines": 930,
      "depth": 24,
      "decorators": [
        "int",
        "prefixes[2]",
        "prefixes",
        "[",
        "2",
        "]",
        "IF_LINT (=",
        "IF_LINT",
        "(",
        "=",
        "{ 0 });\n                int orig_errno;\n#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif\n\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n#endif\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif\n\n                /* Decide whether to handle the precision ourselves.  */\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif\n\n                /* Decide whether to perform the padding ourselves.  */\n#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif\n\n#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif\n\n                /* Construct the format string for calling snprintf or\n                   sprintf.  */\n                fbp = buf;\n                *fbp++ = '%';\n#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif\n                if (flags & FLAG_LEFT)\n                  *fbp++ = '-';\n                if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';\n                if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';\n                if (flags & FLAG_ALT)\n                  *fbp++ = '#';\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif\n                if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n                if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n\n                switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if defined _WIN32 && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif\n#endif\n                    FALLTHROUGH;\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }\n#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif\n                  *fbp = dp->conversion;\n#if USE_SNPRINTF\n# if ! (((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || (defined _WIN32 && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <https://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <https://msdn.microsoft.com/en-us/library/ms175782.aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif\n\n                /* Construct the arguments for calling snprintf or sprintf.  */\n                prefix_count = 0;\n                if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }\n                if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }\n\n#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif\n\n                orig_errno = errno;\n\n                for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }\n                errno = orig_errno;\n#undef pad_ourselves\n#undef prec_ourselves\n              }",
        "{",
        "0 });",
        "0",
        "})",
        "}",
        ")",
        ";",
        "int orig_errno;",
        "int",
        "orig_errno",
        ";",
        "#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "size_t tmp_length;",
        "size_t",
        "tmp_length",
        ";",
        "TCHAR_T tmpbuf[700];",
        "TCHAR_T",
        "tmpbuf[700]",
        "tmpbuf",
        "[",
        "700",
        "]",
        ";",
        "TCHAR_T *tmp;",
        "TCHAR_T",
        "*tmp",
        "*",
        "tmp",
        ";",
        "#endif",
        "#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_width = 0;",
        "has_width = 0",
        "has_width",
        "=",
        "0",
        ";",
        "#endif",
        "#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "||",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "USE_MSVC__SNPRINTF",
        "||",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "width = 0;",
        "width = 0",
        "width",
        "=",
        "0",
        ";",
        "if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }",
        "if",
        "(dp->width_start != dp->width_end)",
        "(",
        "dp->width_start != dp->width_end",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        "{\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }",
        "{",
        "if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }",
        "if",
        "(dp->width_arg_index != ARG_NONE)",
        "(",
        "dp->width_arg_index != ARG_NONE",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }",
        "{",
        "int arg;",
        "int",
        "arg",
        ";",
        "if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();",
        "if",
        "(!(a.arg[dp->width_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->width_arg_index].type == TYPE_INT",
        "a.arg[dp->width_arg_index].type",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "arg = a.arg[dp->width_arg_index].a.a_int;",
        "arg = a.arg[dp->width_arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->width_arg_index].a.a_int",
        "a.arg[dp->width_arg_index].a",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "width = arg;",
        "width = arg",
        "width",
        "=",
        "arg",
        ";",
        "if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }",
        "if",
        "(arg < 0)",
        "(",
        "arg < 0",
        "arg",
        "<",
        "0",
        ")",
        "{\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }",
        "{",
        "/* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */",
        "flags |= FLAG_LEFT;",
        "flags |= FLAG_LEFT",
        "flags",
        "|=",
        "FLAG_LEFT",
        ";",
        "width = -width;",
        "width = -width",
        "width",
        "=",
        "-width",
        "-",
        "width",
        ";",
        "}",
        "}",
        "else",
        "{\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }",
        "{",
        "const FCHAR_T *digitp = dp->width_start;",
        "const",
        "const",
        "FCHAR_T",
        "*digitp = dp->width_start",
        "*digitp",
        "*",
        "digitp",
        "=",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);",
        "do",
        "width = xsum (xtimes (width, 10), *digitp++ - '0');",
        "width = xsum (xtimes (width, 10), *digitp++ - '0')",
        "width",
        "=",
        "xsum (xtimes (width, 10), *digitp++ - '0')",
        "xsum",
        "(xtimes (width, 10), *digitp++ - '0')",
        "(",
        "xtimes (width, 10)",
        "xtimes",
        "(width, 10)",
        "(",
        "width",
        ",",
        "10",
        ")",
        ",",
        "*digitp++ - '0'",
        "*digitp++",
        "*",
        "digitp++",
        "digitp",
        "++",
        "-",
        "'0'",
        "'",
        "'",
        ")",
        ";",
        "while",
        "(digitp != dp->width_end)",
        "(",
        "digitp != dp->width_end",
        "digitp",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        ";",
        "}",
        "#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_width = 1;",
        "has_width = 1",
        "has_width",
        "=",
        "1",
        ";",
        "#endif",
        "}",
        "#endif",
        "#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "||",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "USE_MSVC__SNPRINTF",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_precision = 0;",
        "has_precision = 0",
        "has_precision",
        "=",
        "0",
        ";",
        "precision = 6;",
        "precision = 6",
        "precision",
        "=",
        "6",
        ";",
        "if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }",
        "if",
        "(dp->precision_start != dp->precision_end)",
        "(",
        "dp->precision_start != dp->precision_end",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "{\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }",
        "{",
        "if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }",
        "if",
        "(dp->precision_arg_index != ARG_NONE)",
        "(",
        "dp->precision_arg_index != ARG_NONE",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }",
        "{",
        "int arg;",
        "int",
        "arg",
        ";",
        "if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();",
        "if",
        "(!(a.arg[dp->precision_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->precision_arg_index].type == TYPE_INT",
        "a.arg[dp->precision_arg_index].type",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "arg = a.arg[dp->precision_arg_index].a.a_int;",
        "arg = a.arg[dp->precision_arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->precision_arg_index].a.a_int",
        "a.arg[dp->precision_arg_index].a",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "/* \"A negative precision is taken as if the precision\n                            were omitted.\"  */",
        "if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }",
        "if",
        "(arg >= 0)",
        "(",
        "arg >= 0",
        "arg",
        ">=",
        "0",
        ")",
        "{\n                            precision = arg;\n                            has_precision = 1;\n                          }",
        "{",
        "precision = arg;",
        "precision = arg",
        "precision",
        "=",
        "arg",
        ";",
        "has_precision = 1;",
        "has_precision = 1",
        "has_precision",
        "=",
        "1",
        ";",
        "}",
        "}",
        "else",
        "{\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }",
        "{",
        "const FCHAR_T *digitp = dp->precision_start + 1;",
        "const",
        "const",
        "FCHAR_T",
        "*digitp = dp->precision_start + 1",
        "*digitp",
        "*",
        "digitp",
        "=",
        "dp->precision_start + 1",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "+",
        "1",
        ";",
        "precision = 0;",
        "precision = 0",
        "precision",
        "=",
        "0",
        ";",
        "while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');",
        "while",
        "(digitp != dp->precision_end)",
        "(",
        "digitp != dp->precision_end",
        "digitp",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "precision = xsum (xtimes (precision, 10), *digitp++ - '0');",
        "precision = xsum (xtimes (precision, 10), *digitp++ - '0')",
        "precision",
        "=",
        "xsum (xtimes (precision, 10), *digitp++ - '0')",
        "xsum",
        "(xtimes (precision, 10), *digitp++ - '0')",
        "(",
        "xtimes (precision, 10)",
        "xtimes",
        "(precision, 10)",
        "(",
        "precision",
        ",",
        "10",
        ")",
        ",",
        "*digitp++ - '0'",
        "*digitp++",
        "*",
        "digitp++",
        "digitp",
        "++",
        "-",
        "'0'",
        "'",
        "'",
        ")",
        ";",
        "has_precision = 1;",
        "has_precision = 1",
        "has_precision",
        "=",
        "1",
        ";",
        "}",
        "}",
        "#endif",
        "/* Decide whether to handle the precision ourselves.  */",
        "#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif",
        "#if",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }",
        "switch",
        "(dp->conversion)",
        "(",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ")",
        "{\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }",
        "{",
        "case 'd':",
        "case",
        "'d'",
        "'",
        "'",
        ":",
        "case 'i':",
        "case",
        "'i'",
        "'",
        "'",
        ":",
        "case 'u':",
        "case",
        "'u'",
        "'",
        "'",
        ":",
        "case 'o':",
        "case",
        "'o'",
        "'",
        "'",
        ":",
        "case 'x':",
        "case",
        "'x'",
        "'",
        "'",
        ":",
        "case 'X':",
        "case",
        "'X'",
        "'",
        "'",
        ":",
        "case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;",
        "case",
        "'p'",
        "'",
        "'",
        ":",
        "prec_ourselves = has_precision && (precision > 0);",
        "prec_ourselves = has_precision && (precision > 0)",
        "prec_ourselves",
        "=",
        "has_precision && (precision > 0)",
        "has_precision",
        "&&",
        "(precision > 0)",
        "(",
        "precision > 0",
        "precision",
        ">",
        "0",
        ")",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    prec_ourselves = 0;\n                    break;",
        "default",
        ":",
        "prec_ourselves = 0;",
        "prec_ourselves = 0",
        "prec_ourselves",
        "=",
        "0",
        ";",
        "break;",
        "break",
        ";",
        "}",
        "#endif",
        "/* Decide whether to perform the padding ourselves.  */",
        "#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif",
        "#if",
        "!NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)",
        "!NEED_PRINTF_FLAG_LEFTADJUST",
        "!",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "&&",
        "(!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)",
        "(",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        ")",
        "\n",
        "switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }",
        "switch",
        "(dp->conversion)",
        "(",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ")",
        "{\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }",
        "{",
        "# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif",
        "# if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "\n",
        "/* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */",
        "case 'c':",
        "case",
        "'c'",
        "'",
        "'",
        ":",
        "case 's':",
        "case",
        "'s'",
        "'",
        "'",
        ":",
        "# endif",
        "# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif",
        "# if",
        "NEED_PRINTF_FLAG_ZERO",
        "\n",
        "case 'f':",
        "case",
        "'f'",
        "'",
        "'",
        ":",
        "case 'F':",
        "case",
        "'F'",
        "'",
        "'",
        ":",
        "case 'e':",
        "case",
        "'e'",
        "'",
        "'",
        ":",
        "case 'E':",
        "case",
        "'E'",
        "'",
        "'",
        ":",
        "case 'g':",
        "case",
        "'g'",
        "'",
        "'",
        ":",
        "case 'G':",
        "case",
        "'G'",
        "'",
        "'",
        ":",
        "case 'a':",
        "case",
        "'a'",
        "'",
        "'",
        ":",
        "case 'A':",
        "case",
        "'A'",
        "'",
        "'",
        ":",
        "# endif",
        "pad_ourselves = 1;",
        "pad_ourselves = 1",
        "pad_ourselves",
        "=",
        "1",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    pad_ourselves = prec_ourselves;\n                    break;",
        "default",
        ":",
        "pad_ourselves = prec_ourselves;",
        "pad_ourselves = prec_ourselves",
        "pad_ourselves",
        "=",
        "prec_ourselves",
        ";",
        "break;",
        "break",
        ";",
        "}",
        "#endif",
        "#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "/* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */",
        "tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);",
        "tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "tmp_length",
        "=",
        "MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "MAX_ROOM_NEEDED",
        "(&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "(",
        "&a",
        "&",
        "a",
        ",",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        ",",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ",",
        "type",
        ",",
        "flags",
        ",",
        "width",
        ",",
        "has_precision",
        ",",
        "precision",
        ",",
        "pad_ourselves",
        ")",
        ";",
        "if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }",
        "if",
        "(tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))",
        "(",
        "tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T)",
        "tmp_length",
        "<=",
        "sizeof (tmpbuf) / sizeof (TCHAR_T)",
        "sizeof (tmpbuf)",
        "sizeof",
        "(",
        "tmpbuf",
        "tmpbuf",
        ")",
        "/",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "tmp = tmpbuf;",
        "tmp = tmpbuf",
        "tmp",
        "=",
        "tmpbuf",
        ";",
        "else",
        "{\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }",
        "{",
        "size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));",
        "size_t",
        "tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T))",
        "tmp_memsize",
        "=",
        "xtimes (tmp_length, sizeof (TCHAR_T))",
        "xtimes",
        "(tmp_length, sizeof (TCHAR_T))",
        "(",
        "tmp_length",
        ",",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;",
        "if",
        "(size_overflow_p (tmp_memsize))",
        "(",
        "size_overflow_p (tmp_memsize)",
        "size_overflow_p",
        "(tmp_memsize)",
        "(",
        "tmp_memsize",
        ")",
        ")",
        "/* Overflow, would lead to out of memory.  */",
        "goto out_of_memory;",
        "goto",
        "out_of_memory",
        ";",
        "tmp = (TCHAR_T *) malloc (tmp_memsize);",
        "tmp = (TCHAR_T *) malloc (tmp_memsize)",
        "tmp",
        "=",
        "(TCHAR_T *) malloc (tmp_memsize)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "malloc (tmp_memsize)",
        "malloc",
        "(tmp_memsize)",
        "(",
        "tmp_memsize",
        ")",
        ";",
        "if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;",
        "if",
        "(tmp == NULL)",
        "(",
        "tmp == NULL",
        "tmp",
        "==",
        "NULL",
        ")",
        "/* Out of memory.  */",
        "goto out_of_memory;",
        "goto",
        "out_of_memory",
        ";",
        "}",
        "#endif",
        "/* Construct the format string for calling snprintf or\n                   sprintf.  */",
        "fbp = buf;",
        "fbp = buf",
        "fbp",
        "=",
        "buf",
        ";",
        "*fbp++ = '%';",
        "*fbp++ = '%'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'%'",
        "'",
        "'",
        ";",
        "#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif",
        "#if",
        "NEED_PRINTF_FLAG_GROUPING",
        "\n",
        "/* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */",
        "#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';",
        "#else",
        "if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';",
        "if",
        "(flags & FLAG_GROUP)",
        "(",
        "flags & FLAG_GROUP",
        "flags",
        "&",
        "FLAG_GROUP",
        ")",
        "*fbp++ = '\\'';",
        "*fbp++ = '\\''",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'\\''",
        "'",
        "\\'",
        "'",
        ";",
        "#endif",
        "if (flags & FLAG_LEFT)\n                  *fbp++ = '-';",
        "if",
        "(flags & FLAG_LEFT)",
        "(",
        "flags & FLAG_LEFT",
        "flags",
        "&",
        "FLAG_LEFT",
        ")",
        "*fbp++ = '-';",
        "*fbp++ = '-'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'-'",
        "'",
        "'",
        ";",
        "if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';",
        "if",
        "(flags & FLAG_SHOWSIGN)",
        "(",
        "flags & FLAG_SHOWSIGN",
        "flags",
        "&",
        "FLAG_SHOWSIGN",
        ")",
        "*fbp++ = '+';",
        "*fbp++ = '+'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'+'",
        "'",
        "'",
        ";",
        "if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';",
        "if",
        "(flags & FLAG_SPACE)",
        "(",
        "flags & FLAG_SPACE",
        "flags",
        "&",
        "FLAG_SPACE",
        ")",
        "*fbp++ = ' ';",
        "*fbp++ = ' '",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "' '",
        "'",
        "'",
        ";",
        "if (flags & FLAG_ALT)\n                  *fbp++ = '#';",
        "if",
        "(flags & FLAG_ALT)",
        "(",
        "flags & FLAG_ALT",
        "flags",
        "&",
        "FLAG_ALT",
        ")",
        "*fbp++ = '#';",
        "*fbp++ = '#'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'#'",
        "'",
        "'",
        ";",
        "#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif",
        "#if",
        "__GLIBC__ >= 2 && !defined __UCLIBC__",
        "__GLIBC__ >= 2",
        "__GLIBC__",
        ">=",
        "2",
        "&&",
        "!defined __UCLIBC__",
        "!",
        "defined __UCLIBC__",
        "defined",
        "__UCLIBC__",
        "\n",
        "if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';",
        "if",
        "(flags & FLAG_LOCALIZED)",
        "(",
        "flags & FLAG_LOCALIZED",
        "flags",
        "&",
        "FLAG_LOCALIZED",
        ")",
        "*fbp++ = 'I';",
        "*fbp++ = 'I'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'I'",
        "'",
        "'",
        ";",
        "#endif",
        "if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "if",
        "(!pad_ourselves)",
        "(",
        "!pad_ourselves",
        "!",
        "pad_ourselves",
        ")",
        "{\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "{",
        "if (flags & FLAG_ZERO)\n                      *fbp++ = '0';",
        "if",
        "(flags & FLAG_ZERO)",
        "(",
        "flags & FLAG_ZERO",
        "flags",
        "&",
        "FLAG_ZERO",
        ")",
        "*fbp++ = '0';",
        "*fbp++ = '0'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'0'",
        "'",
        "'",
        ";",
        "if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "if",
        "(dp->width_start != dp->width_end)",
        "(",
        "dp->width_start != dp->width_end",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        "{\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "{",
        "size_t n = dp->width_end - dp->width_start;",
        "size_t",
        "n = dp->width_end - dp->width_start",
        "n",
        "=",
        "dp->width_end - dp->width_start",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        "-",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "/* The width specification is known to consist only\n                           of standard ASCII characters.  */",
        "if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "if",
        "(sizeof (FCHAR_T) == sizeof (TCHAR_T))",
        "(",
        "sizeof (FCHAR_T) == sizeof (TCHAR_T)",
        "sizeof (FCHAR_T)",
        "sizeof",
        "(FCHAR_T)",
        "(",
        "FCHAR_T",
        ")",
        "==",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "{\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }",
        "{",
        "memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));",
        "memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T))",
        "memcpy",
        "(fbp, dp->width_start, n * sizeof (TCHAR_T))",
        "(",
        "fbp",
        ",",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ",",
        "n * sizeof (TCHAR_T)",
        "n",
        "*",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "fbp += n;",
        "fbp += n",
        "fbp",
        "+=",
        "n",
        ";",
        "}",
        "else",
        "{\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "{",
        "const FCHAR_T *mp = dp->width_start;",
        "const",
        "const",
        "FCHAR_T",
        "*mp = dp->width_start",
        "*mp",
        "*",
        "mp",
        "=",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "do\n                              *fbp++ = *mp++;\n                            while (--n > 0);",
        "do",
        "*fbp++ = *mp++;",
        "*fbp++ = *mp++",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "*mp++",
        "*",
        "mp++",
        "mp",
        "++",
        ";",
        "while",
        "(--n > 0)",
        "(",
        "--n > 0",
        "--n",
        "--",
        "n",
        ">",
        "0",
        ")",
        ";",
        "}",
        "}",
        "}",
        "if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "if",
        "(!prec_ourselves)",
        "(",
        "!prec_ourselves",
        "!",
        "prec_ourselves",
        ")",
        "{\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "{",
        "if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "if",
        "(dp->precision_start != dp->precision_end)",
        "(",
        "dp->precision_start != dp->precision_end",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "{\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "{",
        "size_t n = dp->precision_end - dp->precision_start;",
        "size_t",
        "n = dp->precision_end - dp->precision_start",
        "n",
        "=",
        "dp->precision_end - dp->precision_start",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        "-",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ";",
        "/* The precision specification is known to consist only\n                           of standard ASCII characters.  */",
        "if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "if",
        "(sizeof (FCHAR_T) == sizeof (TCHAR_T))",
        "(",
        "sizeof (FCHAR_T) == sizeof (TCHAR_T)",
        "sizeof (FCHAR_T)",
        "sizeof",
        "(FCHAR_T)",
        "(",
        "FCHAR_T",
        ")",
        "==",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "{\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }",
        "{",
        "memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));",
        "memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T))",
        "memcpy",
        "(fbp, dp->precision_start, n * sizeof (TCHAR_T))",
        "(",
        "fbp",
        ",",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ",",
        "n * sizeof (TCHAR_T)",
        "n",
        "*",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "fbp += n;",
        "fbp += n",
        "fbp",
        "+=",
        "n",
        ";",
        "}",
        "else",
        "{\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "{",
        "const FCHAR_T *mp = dp->precision_start;",
        "const",
        "const",
        "FCHAR_T",
        "*mp = dp->precision_start",
        "*mp",
        "*",
        "mp",
        "=",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ";",
        "do\n                              *fbp++ = *mp++;\n                            while (--n > 0);",
        "do",
        "*fbp++ = *mp++;",
        "*fbp++ = *mp++",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "*mp++",
        "*",
        "mp++",
        "mp",
        "++",
        ";",
        "while",
        "(--n > 0)",
        "(",
        "--n > 0",
        "--n",
        "--",
        "n",
        ">",
        "0",
        ")",
        ";",
        "}",
        "}",
        "}",
        "switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if defined _WIN32 && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif\n#endif\n                    FALLTHROUGH;\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }",
        "switch",
        "(type)",
        "(",
        "type",
        ")",
        "{\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if defined _WIN32 && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif\n#endif\n                    FALLTHROUGH;\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }",
        "{",
        "#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if defined _WIN32 && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif\n#endif",
        "#if",
        "HAVE_LONG_LONG_INT",
        "\n",
        "case TYPE_LONGLONGINT:",
        "case",
        "TYPE_LONGLONGINT",
        ":",
        "case TYPE_ULONGLONGINT:",
        "case",
        "TYPE_ULONGLONGINT",
        ":",
        "# if defined _WIN32 && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif",
        "# if",
        "defined _WIN32 && ! defined __CYGWIN__",
        "defined _WIN32",
        "defined",
        "_WIN32",
        "&&",
        "! defined __CYGWIN__",
        "!",
        "defined __CYGWIN__",
        "defined",
        "__CYGWIN__",
        "\n",
        "*fbp++ = 'I';",
        "*fbp++ = 'I'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'I'",
        "'",
        "'",
        ";",
        "*fbp++ = '6';",
        "*fbp++ = '6'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'6'",
        "'",
        "'",
        ";",
        "*fbp++ = '4';",
        "*fbp++ = '4'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'4'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "# else\n                    *fbp++ = 'l';",
        "# else",
        "*fbp++ = 'l';",
        "*fbp++ = 'l'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'l'",
        "'",
        "'",
        ";",
        "# endif",
        "#endif",
        "FALLTHROUGH;",
        "FALLTHROUGH",
        ";",
        "case TYPE_LONGINT:",
        "case",
        "TYPE_LONGINT",
        ":",
        "case TYPE_ULONGINT:",
        "case",
        "TYPE_ULONGINT",
        ":",
        "#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif",
        "#if",
        "HAVE_WINT_T",
        "\n",
        "case TYPE_WIDE_CHAR:",
        "case",
        "TYPE_WIDE_CHAR",
        ":",
        "#endif",
        "#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif",
        "#if",
        "HAVE_WCHAR_T",
        "\n",
        "case TYPE_WIDE_STRING:",
        "case",
        "TYPE_WIDE_STRING",
        ":",
        "#endif",
        "*fbp++ = 'l';",
        "*fbp++ = 'l'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'l'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;",
        "case",
        "TYPE_LONGDOUBLE",
        ":",
        "*fbp++ = 'L';",
        "*fbp++ = 'L'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'L'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    break;",
        "default",
        ":",
        "break;",
        "break",
        ";",
        "}",
        "#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif",
        "#if",
        "NEED_PRINTF_DIRECTIVE_F",
        "\n",
        "if (dp->conversion == 'F')\n                  *fbp = 'f';",
        "if",
        "(dp->conversion == 'F')",
        "(",
        "dp->conversion == 'F'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'F'",
        "'",
        "'",
        ")",
        "*fbp = 'f';",
        "*fbp = 'f'",
        "*fbp",
        "*",
        "fbp",
        "=",
        "'f'",
        "'",
        "'",
        ";",
        "else",
        "else",
        "#endif",
        "*fbp = dp->conversion;",
        "*fbp = dp->conversion",
        "*fbp",
        "*",
        "fbp",
        "=",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ";",
        "#if USE_SNPRINTF\n# if ! (((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || (defined _WIN32 && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <https://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <https://msdn.microsoft.com/en-us/library/ms175782.aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "# if ! (((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || (defined _WIN32 && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <https://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <https://msdn.microsoft.com/en-us/library/ms175782.aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif",
        "# if",
        "! (((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || (defined _WIN32 && ! defined __CYGWIN__))",
        "!",
        "(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || (defined _WIN32 && ! defined __CYGWIN__))",
        "(",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || (defined _WIN32 && ! defined __CYGWIN__)",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)",
        "(",
        "(__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__",
        "(__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))",
        "(",
        "__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)",
        "__GLIBC__ > 2",
        "__GLIBC__",
        ">",
        "2",
        "||",
        "(__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)",
        "(",
        "__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3",
        "__GLIBC__ == 2",
        "__GLIBC__",
        "==",
        "2",
        "&&",
        "__GLIBC_MINOR__ >= 3",
        "__GLIBC_MINOR__",
        ">=",
        "3",
        ")",
        ")",
        "&&",
        "!defined __UCLIBC__",
        "!",
        "defined __UCLIBC__",
        "defined",
        "__UCLIBC__",
        ")",
        "||",
        "(defined __APPLE__ && defined __MACH__)",
        "(",
        "defined __APPLE__ && defined __MACH__",
        "defined __APPLE__",
        "defined",
        "__APPLE__",
        "&&",
        "defined __MACH__",
        "defined",
        "__MACH__",
        ")",
        "||",
        "(defined _WIN32 && ! defined __CYGWIN__)",
        "(",
        "defined _WIN32 && ! defined __CYGWIN__",
        "defined _WIN32",
        "defined",
        "_WIN32",
        "&&",
        "! defined __CYGWIN__",
        "!",
        "defined __CYGWIN__",
        "defined",
        "__CYGWIN__",
        ")",
        ")",
        "\n",
        "fbp[1] = '%';",
        "fbp[1] = '%'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'%'",
        "'",
        "'",
        ";",
        "fbp[2] = 'n';",
        "fbp[2] = 'n'",
        "fbp[2]",
        "fbp",
        "[",
        "2",
        "]",
        "=",
        "'n'",
        "'",
        "'",
        ";",
        "fbp[3] = '\\0';",
        "fbp[3] = '\\0'",
        "fbp[3]",
        "fbp",
        "[",
        "3",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <https://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <https://msdn.microsoft.com/en-us/library/ms175782.aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';",
        "# else",
        "/* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */",
        "/* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */",
        "/* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <https://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <https://msdn.microsoft.com/en-us/library/ms175782.aspx>\n                   So we should avoid %n in this situation.  */",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "# endif",
        "#else\n                fbp[1] = '\\0';",
        "#else",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "#endif",
        "/* Construct the arguments for calling snprintf or sprintf.  */",
        "prefix_count = 0;",
        "prefix_count = 0",
        "prefix_count",
        "=",
        "0",
        ";",
        "if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }",
        "if",
        "(!pad_ourselves && dp->width_arg_index != ARG_NONE)",
        "(",
        "!pad_ourselves && dp->width_arg_index != ARG_NONE",
        "!pad_ourselves",
        "!",
        "pad_ourselves",
        "&&",
        "dp->width_arg_index != ARG_NONE",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }",
        "{",
        "if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();",
        "if",
        "(!(a.arg[dp->width_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->width_arg_index].type == TYPE_INT",
        "a.arg[dp->width_arg_index].type",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;",
        "prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int",
        "prefixes[prefix_count++]",
        "prefixes",
        "[",
        "prefix_count++",
        "prefix_count",
        "++",
        "]",
        "=",
        "a.arg[dp->width_arg_index].a.a_int",
        "a.arg[dp->width_arg_index].a",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "}",
        "if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }",
        "if",
        "(!prec_ourselves && dp->precision_arg_index != ARG_NONE)",
        "(",
        "!prec_ourselves && dp->precision_arg_index != ARG_NONE",
        "!prec_ourselves",
        "!",
        "prec_ourselves",
        "&&",
        "dp->precision_arg_index != ARG_NONE",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }",
        "{",
        "if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();",
        "if",
        "(!(a.arg[dp->precision_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->precision_arg_index].type == TYPE_INT",
        "a.arg[dp->precision_arg_index].type",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;",
        "prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int",
        "prefixes[prefix_count++]",
        "prefixes",
        "[",
        "prefix_count++",
        "prefix_count",
        "++",
        "]",
        "=",
        "a.arg[dp->precision_arg_index].a.a_int",
        "a.arg[dp->precision_arg_index].a",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "}",
        "#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */",
        "# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n",
        "# define",
        "TCHARS_PER_DCHAR",
        " (sizeof (DCHAR_T) / sizeof (TCHAR_T))",
        "\n",
        "/* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */",
        "ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));",
        "ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR))",
        "ENSURE_ALLOCATION",
        "(xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR))",
        "(",
        "xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "(2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR",
        "(2 + TCHARS_PER_DCHAR - 1)",
        "(",
        "2 + TCHARS_PER_DCHAR - 1",
        "2 + TCHARS_PER_DCHAR",
        "2",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ")",
        ";",
        "/* Prepare checking whether snprintf returns the count\n                   via %n.  */",
        "*(TCHAR_T *) (result + length) = '\\0';",
        "*(TCHAR_T *) (result + length) = '\\0'",
        "*(TCHAR_T *) (result + length)",
        "*",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "#endif",
        "orig_errno = errno;",
        "orig_errno = errno",
        "orig_errno",
        "=",
        "errno",
        ";",
        "for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }",
        "for",
        "(",
        ";",
        ";",
        ")",
        "{\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }",
        "{",
        "int count = -1;",
        "int",
        "count = -1",
        "count",
        "=",
        "-1",
        ";",
        "#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "int retcount = 0;",
        "int",
        "retcount = 0",
        "retcount",
        "=",
        "0",
        ";",
        "size_t maxlen = allocated - length;",
        "size_t",
        "maxlen = allocated - length",
        "maxlen",
        "=",
        "allocated - length",
        "allocated",
        "-",
        "length",
        ";",
        "/* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */",
        "if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;",
        "if",
        "(maxlen > INT_MAX / TCHARS_PER_DCHAR)",
        "(",
        "maxlen > INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        ">",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        "maxlen = INT_MAX / TCHARS_PER_DCHAR;",
        "maxlen = INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        "=",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "maxlen = maxlen * TCHARS_PER_DCHAR;",
        "maxlen = maxlen * TCHARS_PER_DCHAR",
        "maxlen",
        "=",
        "maxlen * TCHARS_PER_DCHAR",
        "maxlen",
        "*",
        "TCHARS_PER_DCHAR",
        ";",
        "# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "# define",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        " \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }",
        "\n",
        "#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "#else",
        "# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "# define",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        " \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }",
        "\n",
        "#endif",
        "errno = 0;",
        "errno = 0",
        "errno",
        "=",
        "0",
        ";",
        "switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }",
        "switch",
        "(type)",
        "(",
        "type",
        ")",
        "{\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }",
        "{",
        "case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_SCHAR",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_schar;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_schar",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_schar",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_schar",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_UCHAR",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_uchar;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_uchar",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_uchar",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_uchar",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_SHORT",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_short;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_short",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_short",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_short",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_USHORT",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_ushort;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ushort",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ushort",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ushort",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_INT",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_int;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_int",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_UINT",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_uint;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_uint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_uint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_uint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGINT",
        ":",
        "{\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long int arg = a.arg[dp->arg_index].a.a_longint;",
        "long int",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_longint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_ULONGINT",
        ":",
        "{\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;",
        "unsigned long int",
        "unsigned",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ulongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ulongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ulongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_LONG_LONG_INT",
        "\n",
        "case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGLONGINT",
        ":",
        "{\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long long int arg = a.arg[dp->arg_index].a.a_longlongint;",
        "long long int",
        "long",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_longlongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longlongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longlongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_ULONGLONGINT",
        ":",
        "{\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;",
        "unsigned long long int",
        "unsigned",
        "long",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ulonglongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ulonglongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ulonglongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_DOUBLE",
        ":",
        "{\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "double arg = a.arg[dp->arg_index].a.a_double;",
        "double",
        "arg = a.arg[dp->arg_index].a.a_double",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_double",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_double",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGDOUBLE",
        ":",
        "{\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long double arg = a.arg[dp->arg_index].a.a_longdouble;",
        "long double",
        "long",
        "double",
        "arg = a.arg[dp->arg_index].a.a_longdouble",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longdouble",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longdouble",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_CHAR",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_char;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_char",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_char",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_char",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_WINT_T",
        "\n",
        "case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_WIDE_CHAR",
        ":",
        "{\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "wint_t arg = a.arg[dp->arg_index].a.a_wide_char;",
        "wint_t",
        "arg = a.arg[dp->arg_index].a.a_wide_char",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_wide_char",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_wide_char",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_STRING",
        ":",
        "{\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "const char *arg = a.arg[dp->arg_index].a.a_string;",
        "const",
        "const",
        "char",
        "*arg = a.arg[dp->arg_index].a.a_string",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_string",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_string",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_WCHAR_T",
        "\n",
        "case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_WIDE_STRING",
        ":",
        "{\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;",
        "const",
        "const",
        "wchar_t",
        "*arg = a.arg[dp->arg_index].a.a_wide_string",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_wide_string",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_wide_string",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_POINTER",
        ":",
        "{\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "void *arg = a.arg[dp->arg_index].a.a_pointer;",
        "void",
        "*arg = a.arg[dp->arg_index].a.a_pointer",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_pointer",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_pointer",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "default:\n                        abort ();",
        "default",
        ":",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "}",
        "#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */",
        "if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }",
        "if",
        "(count >= 0)",
        "(",
        "count >= 0",
        "count",
        ">=",
        "0",
        ")",
        "{\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }",
        "{",
        "/* Verify that snprintf() has NUL-terminated its\n                           result.  */",
        "if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();",
        "if",
        "(count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')",
        "(",
        "count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0'",
        "count < maxlen",
        "count",
        "<",
        "maxlen",
        "&&",
        "((TCHAR_T *) (result + length)) [count] != '\\0'",
        "((TCHAR_T *) (result + length)) [count]",
        "((TCHAR_T *) (result + length))",
        "(",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ")",
        "[",
        "count",
        "]",
        "!=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "/* Portability hack.  */",
        "if (retcount > count)\n                          count = retcount;",
        "if",
        "(retcount > count)",
        "(",
        "retcount > count",
        "retcount",
        ">",
        "count",
        ")",
        "count = retcount;",
        "count = retcount",
        "count",
        "=",
        "retcount",
        ";",
        "}",
        "else",
        "{\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }",
        "{",
        "/* snprintf() doesn't understand the '%n'\n                           directive.  */",
        "if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }",
        "if",
        "(fbp[1] != '\\0')",
        "(",
        "fbp[1] != '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "!=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ")",
        "{\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }",
        "{",
        "/* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "else",
        "{\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }",
        "{",
        "/* Look at the snprintf() return value.  */",
        "if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;",
        "if",
        "(retcount < 0)",
        "(",
        "retcount < 0",
        "retcount",
        "<",
        "0",
        ")",
        "{\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }",
        "{",
        "# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif",
        "# if",
        "!HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "USE_MSVC__SNPRINTF",
        "\n",
        "/* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */",
        "size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);",
        "size_t",
        "tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "tmp_length",
        "=",
        "MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "MAX_ROOM_NEEDED",
        "(&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "(",
        "&a",
        "&",
        "a",
        ",",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        ",",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ",",
        "type",
        ",",
        "flags",
        ",",
        "width",
        ",",
        "has_precision",
        ",",
        "precision",
        ",",
        "pad_ourselves",
        ")",
        ";",
        "if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }",
        "if",
        "(maxlen < tmp_length)",
        "(",
        "maxlen < tmp_length",
        "maxlen",
        "<",
        "tmp_length",
        ")",
        "{\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }",
        "{",
        "/* Make more room.  But try to do through\n                                       this reallocation only once.  */",
        "size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);",
        "size_t",
        "bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "bigger_need",
        "=",
        "xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR",
        "xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)",
        "xsum",
        "(tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)",
        "(",
        "tmp_length",
        ",",
        "TCHARS_PER_DCHAR - 1",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ";",
        "/* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */",
        "size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);",
        "size_t",
        "bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12)",
        "bigger_need2",
        "=",
        "xsum (xtimes (allocated, 2), 12)",
        "xsum",
        "(xtimes (allocated, 2), 12)",
        "(",
        "xtimes (allocated, 2)",
        "xtimes",
        "(allocated, 2)",
        "(",
        "allocated",
        ",",
        "2",
        ")",
        ",",
        "12",
        ")",
        ";",
        "if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;",
        "if",
        "(bigger_need < bigger_need2)",
        "(",
        "bigger_need < bigger_need2",
        "bigger_need",
        "<",
        "bigger_need2",
        ")",
        "bigger_need = bigger_need2;",
        "bigger_need = bigger_need2",
        "bigger_need",
        "=",
        "bigger_need2",
        ";",
        "ENSURE_ALLOCATION (bigger_need);",
        "ENSURE_ALLOCATION (bigger_need)",
        "ENSURE_ALLOCATION",
        "(bigger_need)",
        "(",
        "bigger_need",
        ")",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "# endif",
        "}",
        "else",
        "count = retcount;",
        "count = retcount",
        "count",
        "=",
        "retcount",
        ";",
        "}",
        "}",
        "#endif",
        "/* Attempt to handle failure.  */",
        "if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }",
        "if",
        "(count < 0)",
        "(",
        "count < 0",
        "count",
        "<",
        "0",
        ")",
        "{\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }",
        "{",
        "/* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */",
        "int saved_errno = errno;",
        "int",
        "saved_errno = errno",
        "saved_errno",
        "=",
        "errno",
        ";",
        "if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }",
        "if",
        "(saved_errno == 0)",
        "(",
        "saved_errno == 0",
        "saved_errno",
        "==",
        "0",
        ")",
        "{\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }",
        "{",
        "if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;",
        "if",
        "(dp->conversion == 'c' || dp->conversion == 's')",
        "(",
        "dp->conversion == 'c' || dp->conversion == 's'",
        "dp->conversion == 'c'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'c'",
        "'",
        "'",
        "||",
        "dp->conversion == 's'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'s'",
        "'",
        "'",
        ")",
        "saved_errno = EILSEQ;",
        "saved_errno = EILSEQ",
        "saved_errno",
        "=",
        "EILSEQ",
        ";",
        "else",
        "saved_errno = EINVAL;",
        "saved_errno = EINVAL",
        "saved_errno",
        "=",
        "EINVAL",
        ";",
        "}",
        "if (!(result == resultbuf || result == NULL))\n                          free (result);",
        "if",
        "(!(result == resultbuf || result == NULL))",
        "(",
        "!(result == resultbuf || result == NULL)",
        "!",
        "(result == resultbuf || result == NULL)",
        "(",
        "result == resultbuf || result == NULL",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        "||",
        "result == NULL",
        "result",
        "==",
        "NULL",
        ")",
        ")",
        "free (result);",
        "free (result)",
        "free",
        "(result)",
        "(",
        "result",
        ")",
        ";",
        "if (buf_malloced != NULL)\n                          free (buf_malloced);",
        "if",
        "(buf_malloced != NULL)",
        "(",
        "buf_malloced != NULL",
        "buf_malloced",
        "!=",
        "NULL",
        ")",
        "free (buf_malloced);",
        "free (buf_malloced)",
        "free",
        "(buf_malloced)",
        "(",
        "buf_malloced",
        ")",
        ";",
        "CLEANUP ();",
        "CLEANUP ()",
        "CLEANUP",
        "()",
        "(",
        ")",
        ";",
        "errno = saved_errno;",
        "errno = saved_errno",
        "errno",
        "=",
        "saved_errno",
        ";",
        "return NULL;",
        "return",
        "NULL",
        ";",
        "}",
        "#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */",
        "if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }",
        "if",
        "((unsigned int) count + 1 >= maxlen)",
        "(",
        "(unsigned int) count + 1 >= maxlen",
        "(unsigned int) count + 1",
        "(unsigned int) count",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "count",
        "+",
        "1",
        ">=",
        "maxlen",
        ")",
        "{\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }",
        "{",
        "/* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */",
        "if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }",
        "if",
        "(maxlen == INT_MAX / TCHARS_PER_DCHAR)",
        "(",
        "maxlen == INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        "==",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        "goto overflow;",
        "goto",
        "overflow",
        ";",
        "else",
        "{\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }",
        "{",
        "/* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */",
        "size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));",
        "size_t",
        "n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "n",
        "=",
        "xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "xmax",
        "(xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "(",
        "xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR",
        "((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)",
        "(",
        "(unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1",
        "(unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR",
        "(unsigned int) count + 2",
        "(unsigned int) count",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "count",
        "+",
        "2",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ",",
        "xtimes (allocated, 2)",
        "xtimes",
        "(allocated, 2)",
        "(",
        "allocated",
        ",",
        "2",
        ")",
        ")",
        ";",
        "ENSURE_ALLOCATION (n);",
        "ENSURE_ALLOCATION (n)",
        "ENSURE_ALLOCATION",
        "(n)",
        "(",
        "n",
        ")",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "}",
        "#endif",
        "#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif",
        "#if",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }",
        "if",
        "(prec_ourselves)",
        "(",
        "prec_ourselves",
        ")",
        "{\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }",
        "{",
        "/* Handle the precision.  */",
        "TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);",
        "TCHAR_T",
        "*prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length)",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "=",
        "# if",
        "# if",
        "USE_SNPRINTF\n                          (TCHAR_T *) (result + length)",
        "USE_SNPRINTF\n                          (TCHAR_T *)",
        "USE_SNPRINTF",
        "(TCHAR_T *)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# else\n                          tmp;\n",
        "# else",
        "\n                          tmp;",
        "\n",
        "# endif\n                        size_t prefix_count;\n",
        "# endif",
        "\n                        size_t prefix_count;",
        "\n",
        "size_t move;",
        "size_t",
        "move",
        ";",
        "prefix_count = 0;",
        "prefix_count = 0",
        "prefix_count",
        "=",
        "0",
        ";",
        "/* Put the additional zeroes after the sign.  */",
        "if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;",
        "if",
        "(count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))",
        "(",
        "count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' ')",
        "count >= 1",
        "count",
        ">=",
        "1",
        "&&",
        "(*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' ')",
        "(",
        "*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '",
        "*prec_ptr == '-' || *prec_ptr == '+'",
        "*prec_ptr == '-'",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "'-'",
        "'",
        "'",
        "||",
        "*prec_ptr == '+'",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "'+'",
        "'",
        "'",
        "||",
        "*prec_ptr == ' '",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "' '",
        "'",
        "'",
        ")",
        ")",
        "prefix_count = 1;",
        "prefix_count = 1",
        "prefix_count",
        "=",
        "1",
        ";",
        "/* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */",
        "else",
        "if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;",
        "if",
        "(count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))",
        "(",
        "count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X')",
        "count >= 2\n                                 && prec_ptr[0] == '0'",
        "count >= 2",
        "count",
        ">=",
        "2",
        "&&",
        "prec_ptr[0] == '0'",
        "prec_ptr[0]",
        "prec_ptr",
        "[",
        "0",
        "]",
        "==",
        "'0'",
        "'",
        "'",
        "&&",
        "(prec_ptr[1] == 'x' || prec_ptr[1] == 'X')",
        "(",
        "prec_ptr[1] == 'x' || prec_ptr[1] == 'X'",
        "prec_ptr[1] == 'x'",
        "prec_ptr[1]",
        "prec_ptr",
        "[",
        "1",
        "]",
        "==",
        "'x'",
        "'",
        "'",
        "||",
        "prec_ptr[1] == 'X'",
        "prec_ptr[1]",
        "prec_ptr",
        "[",
        "1",
        "]",
        "==",
        "'X'",
        "'",
        "'",
        ")",
        ")",
        "prefix_count = 2;",
        "prefix_count = 2",
        "prefix_count",
        "=",
        "2",
        ";",
        "move = count - prefix_count;",
        "move = count - prefix_count",
        "move",
        "=",
        "count - prefix_count",
        "count",
        "-",
        "prefix_count",
        ";",
        "if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }",
        "if",
        "(precision > move)",
        "(",
        "precision > move",
        "precision",
        ">",
        "move",
        ")",
        "{\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }",
        "{",
        "/* Insert zeroes.  */",
        "size_t insert = precision - move;",
        "size_t",
        "insert = precision - move",
        "insert",
        "=",
        "precision - move",
        "precision",
        "-",
        "move",
        ";",
        "TCHAR_T *prec_end;",
        "TCHAR_T",
        "*prec_end",
        "*",
        "prec_end",
        ";",
        "# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);",
        "size_t",
        "n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "n",
        "=",
        "xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "(count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR",
        "(count + insert + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + insert + TCHARS_PER_DCHAR - 1",
        "count + insert + TCHARS_PER_DCHAR",
        "count + insert",
        "count",
        "+",
        "insert",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ";",
        "length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;",
        "length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "length",
        "+=",
        "(count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "(count + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + TCHARS_PER_DCHAR - 1",
        "count + TCHARS_PER_DCHAR",
        "count",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "ENSURE_ALLOCATION (n);",
        "ENSURE_ALLOCATION (n)",
        "ENSURE_ALLOCATION",
        "(n)",
        "(",
        "n",
        ")",
        ";",
        "length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;",
        "length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "length",
        "-=",
        "(count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "(count + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + TCHARS_PER_DCHAR - 1",
        "count + TCHARS_PER_DCHAR",
        "count",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "prec_ptr = (TCHAR_T *) (result + length);",
        "prec_ptr = (TCHAR_T *) (result + length)",
        "prec_ptr",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# endif",
        "prec_end = prec_ptr + count;",
        "prec_end = prec_ptr + count",
        "prec_end",
        "=",
        "prec_ptr + count",
        "prec_ptr",
        "+",
        "count",
        ";",
        "prec_ptr += prefix_count;",
        "prec_ptr += prefix_count",
        "prec_ptr",
        "+=",
        "prefix_count",
        ";",
        "while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }",
        "while",
        "(prec_end > prec_ptr)",
        "(",
        "prec_end > prec_ptr",
        "prec_end",
        ">",
        "prec_ptr",
        ")",
        "{\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }",
        "{",
        "prec_end--;",
        "prec_end--",
        "prec_end",
        "--",
        ";",
        "prec_end[insert] = prec_end[0];",
        "prec_end[insert] = prec_end[0]",
        "prec_end[insert]",
        "prec_end",
        "[",
        "insert",
        "]",
        "=",
        "prec_end[0]",
        "prec_end",
        "[",
        "0",
        "]",
        ";",
        "}",
        "prec_end += insert;",
        "prec_end += insert",
        "prec_end",
        "+=",
        "insert",
        ";",
        "do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);",
        "do",
        "*--prec_end = '0';",
        "*--prec_end = '0'",
        "*--prec_end",
        "*",
        "--prec_end",
        "--",
        "prec_end",
        "=",
        "'0'",
        "'",
        "'",
        ";",
        "while",
        "(prec_end > prec_ptr)",
        "(",
        "prec_end > prec_ptr",
        "prec_end",
        ">",
        "prec_ptr",
        ")",
        ";",
        "count += insert;",
        "count += insert",
        "count",
        "+=",
        "insert",
        ";",
        "}",
        "}",
        "#endif",
        "#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();",
        "if",
        "(count >= tmp_length)",
        "(",
        "count >= tmp_length",
        "count",
        ">=",
        "tmp_length",
        ")",
        "/* tmp_length was incorrectly calculated - fix the\n                         code above!  */",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "#endif",
        "#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "\n",
        "/* Convert from TCHAR_T[] to DCHAR_T[].  */",
        "if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }",
        "if",
        "(dp->conversion == 'c' || dp->conversion == 's')",
        "(",
        "dp->conversion == 'c' || dp->conversion == 's'",
        "dp->conversion == 'c'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'c'",
        "'",
        "'",
        "||",
        "dp->conversion == 's'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'s'",
        "'",
        "'",
        ")",
        "{\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }",
        "{",
        "/* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */",
        "const TCHAR_T *tmpsrc;",
        "const",
        "const",
        "TCHAR_T",
        "*tmpsrc",
        "*",
        "tmpsrc",
        ";",
        "DCHAR_T *tmpdst;",
        "DCHAR_T",
        "*tmpdst",
        "*",
        "tmpdst",
        ";",
        "size_t tmpdst_len;",
        "size_t",
        "tmpdst_len",
        ";",
        "/* This code assumes that TCHAR_T is 'char'.  */",
        "verify (sizeof (TCHAR_T) == 1);",
        "verify (sizeof (TCHAR_T) == 1)",
        "verify",
        "(sizeof (TCHAR_T) == 1)",
        "(",
        "sizeof (TCHAR_T) == 1",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        "==",
        "1",
        ")",
        ";",
        "# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "tmpsrc = (TCHAR_T *) (result + length);",
        "tmpsrc = (TCHAR_T *) (result + length)",
        "tmpsrc",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# else\n                        tmpsrc = tmp;",
        "# else",
        "tmpsrc = tmp;",
        "tmpsrc = tmp",
        "tmpsrc",
        "=",
        "tmp",
        ";",
        "# endif",
        "tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);",
        "tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "tmpdst",
        "=",
        "DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "DCHAR_CONV_FROM_ENCODING",
        "(locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "(",
        "locale_charset ()",
        "locale_charset",
        "()",
        "(",
        ")",
        ",",
        "iconveh_question_mark",
        ",",
        "tmpsrc",
        ",",
        "count",
        ",",
        "NULL",
        ",",
        "NULL",
        ",",
        "&tmpdst_len",
        "&",
        "tmpdst_len",
        ")",
        ";",
        "if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }",
        "if",
        "(tmpdst == NULL)",
        "(",
        "tmpdst == NULL",
        "tmpdst",
        "==",
        "NULL",
        ")",
        "{\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }",
        "{",
        "int saved_errno = errno;",
        "int",
        "saved_errno = errno",
        "saved_errno",
        "=",
        "errno",
        ";",
        "if (!(result == resultbuf || result == NULL))\n                              free (result);",
        "if",
        "(!(result == resultbuf || result == NULL))",
        "(",
        "!(result == resultbuf || result == NULL)",
        "!",
        "(result == resultbuf || result == NULL)",
        "(",
        "result == resultbuf || result == NULL",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        "||",
        "result == NULL",
        "result",
        "==",
        "NULL",
        ")",
        ")",
        "free (result);",
        "free (result)",
        "free",
        "(result)",
        "(",
        "result",
        ")",
        ";",
        "if (buf_malloced != NULL)\n                              free (buf_malloced);",
        "if",
        "(buf_malloced != NULL)",
        "(",
        "buf_malloced != NULL",
        "buf_malloced",
        "!=",
        "NULL",
        ")",
        "free (buf_malloced);",
        "free (buf_malloced)",
        "free",
        "(buf_malloced)",
        "(",
        "buf_malloced",
        ")",
        ";",
        "CLEANUP ();",
        "CLEANUP ()",
        "CLEANUP",
        "()",
        "(",
        ")",
        ";",
        "errno = saved_errno;",
        "errno = saved_errno",
        "errno",
        "=",
        "saved_errno",
        ";",
        "return NULL;",
        "return",
        "NULL",
        ";",
        "}",
        "ENSURE_ALLOCATION (xsum (length, tmpdst_len));",
        "ENSURE_ALLOCATION (xsum (length, tmpdst_len))",
        "ENSURE_ALLOCATION",
        "(xsum (length, tmpdst_len))",
        "(",
        "xsum (length, tmpdst_len)",
        "xsum",
        "(length, tmpdst_len)",
        "(",
        "length",
        ",",
        "tmpdst_len",
        ")",
        ")",
        ";",
        "DCHAR_CPY (result + length, tmpdst, tmpdst_len);",
        "DCHAR_CPY (result + length, tmpdst, tmpdst_len)",
        "DCHAR_CPY",
        "(result + length, tmpdst, tmpdst_len)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ",",
        "tmpdst",
        ",",
        "tmpdst_len",
        ")",
        ";",
        "free (tmpdst);",
        "free (tmpdst)",
        "free",
        "(tmpdst)",
        "(",
        "tmpdst",
        ")",
        ";",
        "count = tmpdst_len;",
        "count = tmpdst_len",
        "count",
        "=",
        "tmpdst_len",
        ";",
        "}",
        "else",
        "{\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }",
        "{",
        "/* The result string is ASCII.\n                           Simple 1:1 conversion.  */",
        "# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "/* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */",
        "if (sizeof (DCHAR_T) != sizeof (TCHAR_T))",
        "if",
        "(sizeof (DCHAR_T) != sizeof (TCHAR_T))",
        "(",
        "sizeof (DCHAR_T) != sizeof (TCHAR_T)",
        "sizeof (DCHAR_T)",
        "sizeof",
        "(DCHAR_T)",
        "(",
        "DCHAR_T",
        ")",
        "!=",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "",
        "",
        "# endif",
        "{\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }",
        "{",
        "const TCHAR_T *tmpsrc;",
        "const",
        "const",
        "TCHAR_T",
        "*tmpsrc",
        "*",
        "tmpsrc",
        ";",
        "DCHAR_T *tmpdst;",
        "DCHAR_T",
        "*tmpdst",
        "*",
        "tmpdst",
        ";",
        "size_t n;",
        "size_t",
        "n",
        ";",
        "# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }",
        "if",
        "(result == resultbuf)",
        "(",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        ")",
        "{\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }",
        "{",
        "tmpsrc = (TCHAR_T *) (result + length);",
        "tmpsrc = (TCHAR_T *) (result + length)",
        "tmpsrc",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "/* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */",
        "ENSURE_ALLOCATION (xsum (length, count));",
        "ENSURE_ALLOCATION",
        "(xsum (length, count))",
        "("
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/verify.h": {},
  "libunistring/libunistring-0.9.10/lib/version.c": {},
  "libunistring/libunistring-0.9.10/lib/warn-on-use.h": {},
  "libunistring/libunistring-0.9.10/lib/wchar.in.h": {},
  "libunistring/libunistring-0.9.10/lib/wctype-h.c": {},
  "libunistring/libunistring-0.9.10/lib/wctype.in.h": {
    "rpl_towlower": {
      "start_point": [
        380,
        0
      ],
      "end_point": [
        384,
        1
      ],
      "content": "_GL_WCTYPE_INLINE wint_t\nrpl_towlower (wint_t wc)\n{\n  return (wint_t) (wchar_t) towlower (wc);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_WCTYPE_INLINE",
        "wint_t",
        "wint_t"
      ]
    },
    "rpl_towupper": {
      "start_point": [
        389,
        0
      ],
      "end_point": [
        393,
        1
      ],
      "content": "_GL_WCTYPE_INLINE wint_t\nrpl_towupper (wint_t wc)\n{\n  return (wint_t) (wchar_t) towupper (wc);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_WCTYPE_INLINE",
        "wint_t",
        "wint_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/wcwidth.c": {},
  "libunistring/libunistring-0.9.10/lib/xalloc-oversized.h": {},
  "libunistring/libunistring-0.9.10/lib/xsize.c": {},
  "libunistring/libunistring-0.9.10/lib/xsize.h": {
    "size_t": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "__attribute__ ((__pure__))\n#endif\nxsum (size_t size1, size_t size2)\n{\n  size_t sum = size1 + size2;\n  return (sum >= size1 ? sum : SIZE_MAX);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": null
    },
    "__pure__": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "__attribute__ ((__pure__))\n#endif\nxmax (size_t size1, size_t size2)\n{\n  /* No explicit check is needed here, because for any n:\n     max (SIZE_MAX, n) == SIZE_MAX and max (n, SIZE_MAX) == SIZE_MAX.  */\n  return (size1 >= size2 ? size1 : size2);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": null
    }
  },
  "libunistring/libunistring-0.9.10/lib/_Noreturn.h": {},
  "libunistring/libunistring-0.9.10/lib/glthread/lock.c": {
    "glthread_rwlock_init_for_glibc": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "int\nglthread_rwlock_init_for_glibc (pthread_rwlock_t *lock)\n{\n  pthread_rwlockattr_t attributes;\n  int err;\n\n  err = pthread_rwlockattr_init (&attributes);\n  if (err != 0)\n    return err;\n  /* Note: PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP is the only value that\n     causes the writer to be preferred. PTHREAD_RWLOCK_PREFER_WRITER_NP does not\n     do this; see\n     http://man7.org/linux/man-pages/man3/pthread_rwlockattr_setkind_np.3.html */\n  err = pthread_rwlockattr_setkind_np (&attributes,\n                                       PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);\n  if (err == 0)\n    err = pthread_rwlock_init(lock, &attributes);\n  /* pthread_rwlockattr_destroy always returns 0.  It cannot influence the\n     return value.  */\n  pthread_rwlockattr_destroy (&attributes);\n  return err;\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_init_multithreaded": [
      {
        "start_point": [
          74,
          0
        ],
        "end_point": [
          84,
          1
        ],
        "content": "int\nglthread_rwlock_init_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_rwlock_init (&lock->rwlock, NULL);\n  if (err != 0)\n    return err;\n  lock->initialized = 1;\n  return 0;\n}",
        "lines": 11,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          164,
          0
        ],
        "end_point": [
          181,
          1
        ],
        "content": "int\nglthread_rwlock_init_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_init (&lock->lock, NULL);\n  if (err != 0)\n    return err;\n  err = pthread_cond_init (&lock->waiting_readers, NULL);\n  if (err != 0)\n    return err;\n  err = pthread_cond_init (&lock->waiting_writers, NULL);\n  if (err != 0)\n    return err;\n  lock->waiting_writers_count = 0;\n  lock->runcount = 0;\n  return 0;\n}",
        "lines": 18,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          521,
          0
        ],
        "end_point": [
          534,
          1
        ],
        "content": "int\nglthread_rwlock_init_multithreaded (gl_rwlock_t *lock)\n{\n  if (!pth_mutex_init (&lock->lock))\n    return errno;\n  if (!pth_cond_init (&lock->waiting_readers))\n    return errno;\n  if (!pth_cond_init (&lock->waiting_writers))\n    return errno;\n  lock->waiting_writers_count = 0;\n  lock->runcount = 0;\n  lock->initialized = 1;\n  return 0;\n}",
        "lines": 14,
        "depth": 10,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_rdlock_multithreaded": [
      {
        "start_point": [
          86,
          0
        ],
        "end_point": [
          110,
          1
        ],
        "content": "int\nglthread_rwlock_rdlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_rwlock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_rwlock_rdlock (&lock->rwlock);\n}",
        "lines": 25,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          183,
          0
        ],
        "end_point": [
          208,
          1
        ],
        "content": "int\nglthread_rwlock_rdlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n  /* Test whether only readers are currently running, and whether the runcount\n     field will not overflow, and whether no writer is waiting.  The latter\n     condition is because POSIX recommends that \"write locks shall take\n     precedence over read locks\", to avoid \"writer starvation\".  */\n  while (!(lock->runcount + 1 > 0 && lock->waiting_writers_count == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_readers.  */\n      err = pthread_cond_wait (&lock->waiting_readers, &lock->lock);\n      if (err != 0)\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return err;\n        }\n    }\n  lock->runcount++;\n  return pthread_mutex_unlock (&lock->lock);\n}",
        "lines": 26,
        "depth": 12,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          536,
          0
        ],
        "end_point": [
          560,
          1
        ],
        "content": "int\nglthread_rwlock_rdlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    glthread_rwlock_init_multithreaded (lock);\n  if (!pth_mutex_acquire (&lock->lock, 0, NULL))\n    return errno;\n  /* Test whether only readers are currently running, and whether the runcount\n     field will not overflow, and whether no writer is waiting.  The latter\n     condition is because POSIX recommends that \"write locks shall take\n     precedence over read locks\", to avoid \"writer starvation\".  */\n  while (!(lock->runcount + 1 > 0 && lock->waiting_writers_count == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_readers.  */\n      if (!pth_cond_await (&lock->waiting_readers, &lock->lock, NULL))\n        {\n          int err = errno;\n          pth_mutex_release (&lock->lock);\n          return err;\n        }\n    }\n  lock->runcount++;\n  return (!pth_mutex_release (&lock->lock) ? errno : 0);\n}",
        "lines": 25,
        "depth": 12,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_wrlock_multithreaded": [
      {
        "start_point": [
          112,
          0
        ],
        "end_point": [
          136,
          1
        ],
        "content": "int\nglthread_rwlock_wrlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_rwlock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_rwlock_wrlock (&lock->rwlock);\n}",
        "lines": 25,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          210,
          0
        ],
        "end_point": [
          235,
          1
        ],
        "content": "int\nglthread_rwlock_wrlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n  /* Test whether no readers or writers are currently running.  */\n  while (!(lock->runcount == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_writers.  */\n      lock->waiting_writers_count++;\n      err = pthread_cond_wait (&lock->waiting_writers, &lock->lock);\n      if (err != 0)\n        {\n          lock->waiting_writers_count--;\n          pthread_mutex_unlock (&lock->lock);\n          return err;\n        }\n      lock->waiting_writers_count--;\n    }\n  lock->runcount--; /* runcount becomes -1 */\n  return pthread_mutex_unlock (&lock->lock);\n}",
        "lines": 26,
        "depth": 12,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          562,
          0
        ],
        "end_point": [
          586,
          1
        ],
        "content": "int\nglthread_rwlock_wrlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    glthread_rwlock_init_multithreaded (lock);\n  if (!pth_mutex_acquire (&lock->lock, 0, NULL))\n    return errno;\n  /* Test whether no readers or writers are currently running.  */\n  while (!(lock->runcount == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_writers.  */\n      lock->waiting_writers_count++;\n      if (!pth_cond_await (&lock->waiting_writers, &lock->lock, NULL))\n        {\n          int err = errno;\n          lock->waiting_writers_count--;\n          pth_mutex_release (&lock->lock);\n          return err;\n        }\n      lock->waiting_writers_count--;\n    }\n  lock->runcount--; /* runcount becomes -1 */\n  return (!pth_mutex_release (&lock->lock) ? errno : 0);\n}",
        "lines": 25,
        "depth": 12,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_unlock_multithreaded": [
      {
        "start_point": [
          138,
          0
        ],
        "end_point": [
          144,
          1
        ],
        "content": "int\nglthread_rwlock_unlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    return EINVAL;\n  return pthread_rwlock_unlock (&lock->rwlock);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          237,
          0
        ],
        "end_point": [
          291,
          1
        ],
        "content": "int\nglthread_rwlock_unlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n  if (lock->runcount < 0)\n    {\n      /* Drop a writer lock.  */\n      if (!(lock->runcount == -1))\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount = 0;\n    }\n  else\n    {\n      /* Drop a reader lock.  */\n      if (!(lock->runcount > 0))\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount--;\n    }\n  if (lock->runcount == 0)\n    {\n      /* POSIX recommends that \"write locks shall take precedence over read\n         locks\", to avoid \"writer starvation\".  */\n      if (lock->waiting_writers_count > 0)\n        {\n          /* Wake up one of the waiting writers.  */\n          err = pthread_cond_signal (&lock->waiting_writers);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->lock);\n              return err;\n            }\n        }\n      else\n        {\n          /* Wake up all waiting readers.  */\n          err = pthread_cond_broadcast (&lock->waiting_readers);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->lock);\n              return err;\n            }\n        }\n    }\n  return pthread_mutex_unlock (&lock->lock);\n}",
        "lines": 55,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          588,
          0
        ],
        "end_point": [
          643,
          1
        ],
        "content": "int\nglthread_rwlock_unlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  if (!lock->initialized)\n    return EINVAL;\n  if (!pth_mutex_acquire (&lock->lock, 0, NULL))\n    return errno;\n  if (lock->runcount < 0)\n    {\n      /* Drop a writer lock.  */\n      if (!(lock->runcount == -1))\n        {\n          pth_mutex_release (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount = 0;\n    }\n  else\n    {\n      /* Drop a reader lock.  */\n      if (!(lock->runcount > 0))\n        {\n          pth_mutex_release (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount--;\n    }\n  if (lock->runcount == 0)\n    {\n      /* POSIX recommends that \"write locks shall take precedence over read\n         locks\", to avoid \"writer starvation\".  */\n      if (lock->waiting_writers_count > 0)\n        {\n          /* Wake up one of the waiting writers.  */\n          if (!pth_cond_notify (&lock->waiting_writers, FALSE))\n            {\n              int err = errno;\n              pth_mutex_release (&lock->lock);\n              return err;\n            }\n        }\n      else\n        {\n          /* Wake up all waiting readers.  */\n          if (!pth_cond_notify (&lock->waiting_readers, TRUE))\n            {\n              int err = errno;\n              pth_mutex_release (&lock->lock);\n              return err;\n            }\n        }\n    }\n  return (!pth_mutex_release (&lock->lock) ? errno : 0);\n}",
        "lines": 56,
        "depth": 14,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_destroy_multithreaded": [
      {
        "start_point": [
          146,
          0
        ],
        "end_point": [
          158,
          1
        ],
        "content": "int\nglthread_rwlock_destroy_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  if (!lock->initialized)\n    return EINVAL;\n  err = pthread_rwlock_destroy (&lock->rwlock);\n  if (err != 0)\n    return err;\n  lock->initialized = 0;\n  return 0;\n}",
        "lines": 13,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          293,
          0
        ],
        "end_point": [
          308,
          1
        ],
        "content": "int\nglthread_rwlock_destroy_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_destroy (&lock->lock);\n  if (err != 0)\n    return err;\n  err = pthread_cond_destroy (&lock->waiting_readers);\n  if (err != 0)\n    return err;\n  err = pthread_cond_destroy (&lock->waiting_writers);\n  if (err != 0)\n    return err;\n  return 0;\n}",
        "lines": 16,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          645,
          0
        ],
        "end_point": [
          650,
          1
        ],
        "content": "int\nglthread_rwlock_destroy_multithreaded (gl_rwlock_t *lock)\n{\n  lock->initialized = 0;\n  return 0;\n}",
        "lines": 6,
        "depth": 6,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_init_multithreaded": [
      {
        "start_point": [
          318,
          0
        ],
        "end_point": [
          343,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_mutexattr_t attributes;\n  int err;\n\n  err = pthread_mutexattr_init (&attributes);\n  if (err != 0)\n    return err;\n  err = pthread_mutexattr_settype (&attributes, PTHREAD_MUTEX_RECURSIVE);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutex_init (lock, &attributes);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutexattr_destroy (&attributes);\n  if (err != 0)\n    return err;\n  return 0;\n}",
        "lines": 26,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          347,
          0
        ],
        "end_point": [
          373,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_mutexattr_t attributes;\n  int err;\n\n  err = pthread_mutexattr_init (&attributes);\n  if (err != 0)\n    return err;\n  err = pthread_mutexattr_settype (&attributes, PTHREAD_MUTEX_RECURSIVE);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutex_init (&lock->recmutex, &attributes);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutexattr_destroy (&attributes);\n  if (err != 0)\n    return err;\n  lock->initialized = 1;\n  return 0;\n}",
        "lines": 27,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          427,
          0
        ],
        "end_point": [
          438,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_init (&lock->mutex, NULL);\n  if (err != 0)\n    return err;\n  lock->owner = (pthread_t) 0;\n  lock->depth = 0;\n  return 0;\n}",
        "lines": 12,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          701,
          0
        ],
        "end_point": [
          712,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  int err;\n\n  err = mutex_init (&lock->mutex, USYNC_THREAD, NULL);\n  if (err != 0)\n    return err;\n  lock->owner = (thread_t) 0;\n  lock->depth = 0;\n  return 0;\n}",
        "lines": 12,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_lock_multithreaded": [
      {
        "start_point": [
          375,
          0
        ],
        "end_point": [
          399,
          1
        ],
        "content": "int\nglthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_recursive_lock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_mutex_lock (&lock->recmutex);\n}",
        "lines": 25,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          440,
          0
        ],
        "end_point": [
          459,
          1
        ],
        "content": "int\nglthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_t self = pthread_self ();\n  if (lock->owner != self)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->mutex);\n      if (err != 0)\n        return err;\n      lock->owner = self;\n    }\n  if (++(lock->depth) == 0) /* wraparound? */\n    {\n      lock->depth--;\n      return EAGAIN;\n    }\n  return 0;\n}",
        "lines": 20,
        "depth": 11,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          714,
          0
        ],
        "end_point": [
          733,
          1
        ],
        "content": "int\nglthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock)\n{\n  thread_t self = thr_self ();\n  if (lock->owner != self)\n    {\n      int err;\n\n      err = mutex_lock (&lock->mutex);\n      if (err != 0)\n        return err;\n      lock->owner = self;\n    }\n  if (++(lock->depth) == 0) /* wraparound? */\n    {\n      lock->depth--;\n      return EAGAIN;\n    }\n  return 0;\n}",
        "lines": 20,
        "depth": 11,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_unlock_multithreaded": [
      {
        "start_point": [
          401,
          0
        ],
        "end_point": [
          407,
          1
        ],
        "content": "int\nglthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (!lock->initialized)\n    return EINVAL;\n  return pthread_mutex_unlock (&lock->recmutex);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          461,
          0
        ],
        "end_point": [
          475,
          1
        ],
        "content": "int\nglthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != pthread_self ())\n    return EPERM;\n  if (lock->depth == 0)\n    return EINVAL;\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = (pthread_t) 0;\n      return pthread_mutex_unlock (&lock->mutex);\n    }\n  else\n    return 0;\n}",
        "lines": 15,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          735,
          0
        ],
        "end_point": [
          749,
          1
        ],
        "content": "int\nglthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != thr_self ())\n    return EPERM;\n  if (lock->depth == 0)\n    return EINVAL;\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = (thread_t) 0;\n      return mutex_unlock (&lock->mutex);\n    }\n  else\n    return 0;\n}",
        "lines": 15,
        "depth": 10,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_destroy_multithreaded": [
      {
        "start_point": [
          409,
          0
        ],
        "end_point": [
          421,
          1
        ],
        "content": "int\nglthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock)\n{\n  int err;\n\n  if (!lock->initialized)\n    return EINVAL;\n  err = pthread_mutex_destroy (&lock->recmutex);\n  if (err != 0)\n    return err;\n  lock->initialized = 0;\n  return 0;\n}",
        "lines": 13,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          477,
          0
        ],
        "end_point": [
          483,
          1
        ],
        "content": "int\nglthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != (pthread_t) 0)\n    return EBUSY;\n  return pthread_mutex_destroy (&lock->mutex);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          751,
          0
        ],
        "end_point": [
          757,
          1
        ],
        "content": "int\nglthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != (thread_t) 0)\n    return EBUSY;\n  return mutex_destroy (&lock->mutex);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_once_singlethreaded": [
      {
        "start_point": [
          491,
          0
        ],
        "end_point": [
          505,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (pthread_once_t *once_control)\n{\n  /* We don't know whether pthread_once_t is an integer type, a floating-point\n     type, a pointer type, or a structure type.  */\n  char *firstbyte = (char *)once_control;\n  if (*firstbyte == *(const char *)&fresh_once)\n    {\n      /* First time use of once_control.  Invert the first byte.  */\n      *firstbyte = ~ *(const char *)&fresh_once;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 15,
        "depth": 12,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          673,
          0
        ],
        "end_point": [
          685,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (pth_once_t *once_control)\n{\n  /* We know that pth_once_t is an integer type.  */\n  if (*once_control == PTH_ONCE_INIT)\n    {\n      /* First time use of once_control.  Invert the marker.  */\n      *once_control = ~ PTH_ONCE_INIT;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 13,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          784,
          0
        ],
        "end_point": [
          796,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (gl_once_t *once_control)\n{\n  /* We know that gl_once_t contains an integer type.  */\n  if (!once_control->inited)\n    {\n      /* First time use of once_control.  Invert the marker.  */\n      once_control->inited = ~ 0;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 13,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_once_call": {
      "start_point": [
        658,
        0
      ],
      "end_point": [
        664,
        1
      ],
      "content": "static void\nglthread_once_call (void *arg)\n{\n  void (**gl_once_temp_addr) (void) = (void (**) (void)) arg;\n  void (*initfunction) (void) = *gl_once_temp_addr;\n  initfunction ();\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glthread_once_multithreaded": [
      {
        "start_point": [
          666,
          0
        ],
        "end_point": [
          671,
          1
        ],
        "content": "int\nglthread_once_multithreaded (pth_once_t *once_control, void (*initfunction) (void))\n{\n  void (*temp) (void) = initfunction;\n  return (!pth_once (once_control, glthread_once_call, &temp) ? errno : 0);\n}",
        "lines": 6,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          761,
          0
        ],
        "end_point": [
          782,
          1
        ],
        "content": "int\nglthread_once_multithreaded (gl_once_t *once_control, void (*initfunction) (void))\n{\n  if (!once_control->inited)\n    {\n      int err;\n\n      /* Use the mutex to guarantee that if another thread is already calling\n         the initfunction, this thread waits until it's finished.  */\n      err = mutex_lock (&once_control->mutex);\n      if (err != 0)\n        return err;\n      if (!once_control->inited)\n        {\n          once_control->inited = 1;\n          initfunction ();\n        }\n      return mutex_unlock (&once_control->mutex);\n    }\n  else\n    return 0;\n}",
        "lines": 22,
        "depth": 11,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_lock_init_func": {
      "start_point": [
        806,
        0
      ],
      "end_point": [
        811,
        1
      ],
      "content": "void\nglthread_lock_init_func (gl_lock_t *lock)\n{\n  InitializeCriticalSection (&lock->lock);\n  lock->guard.done = 1;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glthread_lock_lock_func": {
      "start_point": [
        813,
        0
      ],
      "end_point": [
        829,
        1
      ],
      "content": "int\nglthread_lock_lock_func (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_lock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glthread_lock_unlock_func": {
      "start_point": [
        831,
        0
      ],
      "end_point": [
        838,
        1
      ],
      "content": "int\nglthread_lock_unlock_func (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "glthread_lock_destroy_func": {
      "start_point": [
        840,
        0
      ],
      "end_point": [
        848,
        1
      ],
      "content": "int\nglthread_lock_destroy_func (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  DeleteCriticalSection (&lock->lock);\n  lock->guard.done = 0;\n  return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "gl_waitqueue_init": {
      "start_point": [
        855,
        0
      ],
      "end_point": [
        862,
        1
      ],
      "content": "static void\ngl_waitqueue_init (gl_waitqueue_t *wq)\n{\n  wq->array = NULL;\n  wq->count = 0;\n  wq->alloc = 0;\n  wq->offset = 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gl_waitqueue_add": {
      "start_point": [
        866,
        0
      ],
      "end_point": [
        913,
        1
      ],
      "content": "static HANDLE\ngl_waitqueue_add (gl_waitqueue_t *wq)\n{\n  HANDLE event;\n  unsigned int index;\n\n  if (wq->count == wq->alloc)\n    {\n      unsigned int new_alloc = 2 * wq->alloc + 1;\n      HANDLE *new_array =\n        (HANDLE *) realloc (wq->array, new_alloc * sizeof (HANDLE));\n      if (new_array == NULL)\n        /* No more memory.  */\n        return INVALID_HANDLE_VALUE;\n      /* Now is a good opportunity to rotate the array so that its contents\n         starts at offset 0.  */\n      if (wq->offset > 0)\n        {\n          unsigned int old_count = wq->count;\n          unsigned int old_alloc = wq->alloc;\n          unsigned int old_offset = wq->offset;\n          unsigned int i;\n          if (old_offset + old_count > old_alloc)\n            {\n              unsigned int limit = old_offset + old_count - old_alloc;\n              for (i = 0; i < limit; i++)\n                new_array[old_alloc + i] = new_array[i];\n            }\n          for (i = 0; i < old_count; i++)\n            new_array[i] = new_array[old_offset + i];\n          wq->offset = 0;\n        }\n      wq->array = new_array;\n      wq->alloc = new_alloc;\n    }\n  /* Whether the created event is a manual-reset one or an auto-reset one,\n     does not matter, since we will wait on it only once.  */\n  event = CreateEvent (NULL, TRUE, FALSE, NULL);\n  if (event == INVALID_HANDLE_VALUE)\n    /* No way to allocate an event.  */\n    return INVALID_HANDLE_VALUE;\n  index = wq->offset + wq->count;\n  if (index >= wq->alloc)\n    index -= wq->alloc;\n  wq->array[index] = event;\n  wq->count++;\n  return event;\n}",
      "lines": 48,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "HANDLE"
      ]
    },
    "gl_waitqueue_notify_first": {
      "start_point": [
        916,
        0
      ],
      "end_point": [
        924,
        1
      ],
      "content": "static void\ngl_waitqueue_notify_first (gl_waitqueue_t *wq)\n{\n  SetEvent (wq->array[wq->offset + 0]);\n  wq->offset++;\n  wq->count--;\n  if (wq->count == 0 || wq->offset == wq->alloc)\n    wq->offset = 0;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gl_waitqueue_notify_all": {
      "start_point": [
        927,
        0
      ],
      "end_point": [
        941,
        1
      ],
      "content": "static void\ngl_waitqueue_notify_all (gl_waitqueue_t *wq)\n{\n  unsigned int i;\n\n  for (i = 0; i < wq->count; i++)\n    {\n      unsigned int index = wq->offset + i;\n      if (index >= wq->alloc)\n        index -= wq->alloc;\n      SetEvent (wq->array[index]);\n    }\n  wq->count = 0;\n  wq->offset = 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glthread_rwlock_init_func": {
      "start_point": [
        943,
        0
      ],
      "end_point": [
        951,
        1
      ],
      "content": "void\nglthread_rwlock_init_func (gl_rwlock_t *lock)\n{\n  InitializeCriticalSection (&lock->lock);\n  gl_waitqueue_init (&lock->waiting_readers);\n  gl_waitqueue_init (&lock->waiting_writers);\n  lock->runcount = 0;\n  lock->guard.done = 1;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glthread_rwlock_rdlock_func": {
      "start_point": [
        953,
        0
      ],
      "end_point": [
        1007,
        1
      ],
      "content": "int\nglthread_rwlock_rdlock_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_rwlock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n  /* Test whether only readers are currently running, and whether the runcount\n     field will not overflow, and whether no writer is waiting.  The latter\n     condition is because POSIX recommends that \"write locks shall take\n     precedence over read locks\", to avoid \"writer starvation\".  */\n  if (!(lock->runcount + 1 > 0 && lock->waiting_writers.count == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_readers.  */\n      HANDLE event = gl_waitqueue_add (&lock->waiting_readers);\n      if (event != INVALID_HANDLE_VALUE)\n        {\n          DWORD result;\n          LeaveCriticalSection (&lock->lock);\n          /* Wait until another thread signals this event.  */\n          result = WaitForSingleObject (event, INFINITE);\n          if (result == WAIT_FAILED || result == WAIT_TIMEOUT)\n            abort ();\n          CloseHandle (event);\n          /* The thread which signalled the event already did the bookkeeping:\n             removed us from the waiting_readers, incremented lock->runcount.  */\n          if (!(lock->runcount > 0))\n            abort ();\n          return 0;\n        }\n      else\n        {\n          /* Allocation failure.  Weird.  */\n          do\n            {\n              LeaveCriticalSection (&lock->lock);\n              Sleep (1);\n              EnterCriticalSection (&lock->lock);\n            }\n          while (!(lock->runcount + 1 > 0));\n        }\n    }\n  lock->runcount++;\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 55,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_wrlock_func": {
      "start_point": [
        1009,
        0
      ],
      "end_point": [
        1060,
        1
      ],
      "content": "int\nglthread_rwlock_wrlock_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_rwlock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n  /* Test whether no readers or writers are currently running.  */\n  if (!(lock->runcount == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_writers.  */\n      HANDLE event = gl_waitqueue_add (&lock->waiting_writers);\n      if (event != INVALID_HANDLE_VALUE)\n        {\n          DWORD result;\n          LeaveCriticalSection (&lock->lock);\n          /* Wait until another thread signals this event.  */\n          result = WaitForSingleObject (event, INFINITE);\n          if (result == WAIT_FAILED || result == WAIT_TIMEOUT)\n            abort ();\n          CloseHandle (event);\n          /* The thread which signalled the event already did the bookkeeping:\n             removed us from the waiting_writers, set lock->runcount = -1.  */\n          if (!(lock->runcount == -1))\n            abort ();\n          return 0;\n        }\n      else\n        {\n          /* Allocation failure.  Weird.  */\n          do\n            {\n              LeaveCriticalSection (&lock->lock);\n              Sleep (1);\n              EnterCriticalSection (&lock->lock);\n            }\n          while (!(lock->runcount == 0));\n        }\n    }\n  lock->runcount--; /* runcount becomes -1 */\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 52,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_unlock_func": {
      "start_point": [
        1062,
        0
      ],
      "end_point": [
        1104,
        1
      ],
      "content": "int\nglthread_rwlock_unlock_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  EnterCriticalSection (&lock->lock);\n  if (lock->runcount < 0)\n    {\n      /* Drop a writer lock.  */\n      if (!(lock->runcount == -1))\n        abort ();\n      lock->runcount = 0;\n    }\n  else\n    {\n      /* Drop a reader lock.  */\n      if (!(lock->runcount > 0))\n        {\n          LeaveCriticalSection (&lock->lock);\n          return EPERM;\n        }\n      lock->runcount--;\n    }\n  if (lock->runcount == 0)\n    {\n      /* POSIX recommends that \"write locks shall take precedence over read\n         locks\", to avoid \"writer starvation\".  */\n      if (lock->waiting_writers.count > 0)\n        {\n          /* Wake up one of the waiting writers.  */\n          lock->runcount--;\n          gl_waitqueue_notify_first (&lock->waiting_writers);\n        }\n      else\n        {\n          /* Wake up all waiting readers.  */\n          lock->runcount += lock->waiting_readers.count;\n          gl_waitqueue_notify_all (&lock->waiting_readers);\n        }\n    }\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_destroy_func": {
      "start_point": [
        1106,
        0
      ],
      "end_point": [
        1120,
        1
      ],
      "content": "int\nglthread_rwlock_destroy_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  if (lock->runcount != 0)\n    return EBUSY;\n  DeleteCriticalSection (&lock->lock);\n  if (lock->waiting_readers.array != NULL)\n    free (lock->waiting_readers.array);\n  if (lock->waiting_writers.array != NULL)\n    free (lock->waiting_writers.array);\n  lock->guard.done = 0;\n  return 0;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "glthread_recursive_lock_init_func": {
      "start_point": [
        1124,
        0
      ],
      "end_point": [
        1131,
        1
      ],
      "content": "void\nglthread_recursive_lock_init_func (gl_recursive_lock_t *lock)\n{\n  lock->owner = 0;\n  lock->depth = 0;\n  InitializeCriticalSection (&lock->lock);\n  lock->guard.done = 1;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glthread_recursive_lock_lock_func": {
      "start_point": [
        1133,
        0
      ],
      "end_point": [
        1161,
        1
      ],
      "content": "int\nglthread_recursive_lock_lock_func (gl_recursive_lock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_recursive_lock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  {\n    DWORD self = GetCurrentThreadId ();\n    if (lock->owner != self)\n      {\n        EnterCriticalSection (&lock->lock);\n        lock->owner = self;\n      }\n    if (++(lock->depth) == 0) /* wraparound? */\n      {\n        lock->depth--;\n        return EAGAIN;\n      }\n  }\n  return 0;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glthread_recursive_lock_unlock_func": {
      "start_point": [
        1163,
        0
      ],
      "end_point": [
        1176,
        1
      ],
      "content": "int\nglthread_recursive_lock_unlock_func (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != GetCurrentThreadId ())\n    return EPERM;\n  if (lock->depth == 0)\n    return EINVAL;\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = 0;\n      LeaveCriticalSection (&lock->lock);\n    }\n  return 0;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "glthread_recursive_lock_destroy_func": {
      "start_point": [
        1178,
        0
      ],
      "end_point": [
        1186,
        1
      ],
      "content": "int\nglthread_recursive_lock_destroy_func (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != 0)\n    return EBUSY;\n  DeleteCriticalSection (&lock->lock);\n  lock->guard.done = 0;\n  return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "glthread_once_func": {
      "start_point": [
        1190,
        0
      ],
      "end_point": [
        1225,
        1
      ],
      "content": "void\nglthread_once_func (gl_once_t *once_control, void (*initfunction) (void))\n{\n  if (once_control->inited <= 0)\n    {\n      if (InterlockedIncrement (&once_control->started) == 0)\n        {\n          /* This thread is the first one to come to this once_control.  */\n          InitializeCriticalSection (&once_control->lock);\n          EnterCriticalSection (&once_control->lock);\n          once_control->inited = 0;\n          initfunction ();\n          once_control->inited = 1;\n          LeaveCriticalSection (&once_control->lock);\n        }\n      else\n        {\n          /* Undo last operation.  */\n          InterlockedDecrement (&once_control->started);\n          /* Some other thread has already started the initialization.\n             Yield the CPU while waiting for the other thread to finish\n             initializing and taking the lock.  */\n          while (once_control->inited < 0)\n            Sleep (0);\n          if (once_control->inited <= 0)\n            {\n              /* Take the lock.  This blocks until the other thread has\n                 finished calling the initfunction.  */\n              EnterCriticalSection (&once_control->lock);\n              LeaveCriticalSection (&once_control->lock);\n              if (!(once_control->inited > 0))\n                abort ();\n            }\n        }\n    }\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/glthread/lock.h": {},
  "libunistring/libunistring-0.9.10/lib/glthread/threadlib.c": {
    "dummy_thread_func": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "static void *\ndummy_thread_func (void *arg)\n{\n  return arg;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndummy_thread_func (void *arg)",
        "*"
      ]
    },
    "glthread_in_use": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nglthread_in_use (void)\n{\n  static int tested;\n  static int result; /* 1: linked with -lpthread, 0: only with libc */\n\n  if (!tested)\n    {\n      pthread_t thread;\n\n      if (pthread_create (&thread, NULL, dummy_thread_func, NULL) != 0)\n        /* Thread creation failed.  */\n        result = 0;\n      else\n        {\n          /* Thread creation works.  */\n          void *retval;\n          if (pthread_join (thread, &retval) != 0)\n            abort ();\n          result = 1;\n        }\n      tested = 1;\n    }\n  return result;\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/cased.c": {
    "uc_is_cased": [
      {
        "start_point": [
          40,
          0
        ],
        "end_point": [
          46,
          1
        ],
        "content": "bool\nuc_is_cased (ucs4_t uc)\n{\n  return (uc_is_property_lowercase (uc)\n          || uc_is_property_uppercase (uc)\n          || uc_is_general_category (uc, UC_TITLECASE_LETTER));\n}",
        "lines": 7,
        "depth": 9,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          55,
          0
        ],
        "end_point": [
          59,
          1
        ],
        "content": "bool\nuc_is_cased (ucs4_t uc)\n{\n  return bitmap_lookup (&u_casing_property_cased, uc);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/unicase/cased.h": {},
  "libunistring/libunistring-0.9.10/lib/unicase/casefold.h": {},
  "libunistring/libunistring-0.9.10/lib/unicase/caseprop.h": {},
  "libunistring/libunistring-0.9.10/lib/unicase/context.h": {},
  "libunistring/libunistring-0.9.10/lib/unicase/empty-prefix-context.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/empty-suffix-context.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/ignorable.c": {
    "uc_is_case_ignorable": [
      {
        "start_point": [
          52,
          0
        ],
        "end_point": [
          64,
          1
        ],
        "content": "bool\nuc_is_case_ignorable (ucs4_t uc)\n{\n  int wbp = uc_wordbreak_property (uc);\n\n  return (wbp == WBP_MIDLETTER || wbp == WBP_MIDNUMLET\n          || uc_is_general_category_withtable (uc, UC_CATEGORY_MASK_Mn\n                                                   | UC_CATEGORY_MASK_Me\n                                                   | UC_CATEGORY_MASK_Cf\n                                                   | UC_CATEGORY_MASK_Lm\n                                                   | UC_CATEGORY_MASK_Sk))\n         && !uc_is_cased (uc);\n}",
        "lines": 13,
        "depth": 13,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          73,
          0
        ],
        "end_point": [
          77,
          1
        ],
        "content": "bool\nuc_is_case_ignorable (ucs4_t uc)\n{\n  return bitmap_lookup (&u_casing_property_case_ignorable, uc);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/unicase/ignorable.h": {},
  "libunistring/libunistring-0.9.10/lib/unicase/invariant.h": {},
  "libunistring/libunistring-0.9.10/lib/unicase/locale-language.c": {
    "uc_locale_language": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "const char *\nuc_locale_language (void)\n{\n  const char *locale_name = gl_locale_name (LC_CTYPE, \"LC_CTYPE\");\n  const char *p;\n\n  /* Find the end of the language portion.  */\n  p = locale_name;\n  while (*p != '\\0' && *p != '_' && *p != '.' && *p != '@')\n    p++;\n\n  /* Return a statically allocated pointer to the language portion, so that the\n     caller of this function does not need to free() the result.\n     We could use a dynamically built unification table.  But given that the\n     set of possible languages is small, it is easier (and excludes ENOMEM\n     error conditions) to allocate the unification table statically.  */\n  if (p != locale_name)\n    {\n      const char *language =\n        uc_locale_languages_lookup (locale_name, p - locale_name);\n      if (language != NULL)\n        return language;\n    }\n\n  return \"\";\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nuc_locale_language (void)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/locale-languages.h": {
    "uc_locale_language_hash": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "static unsigned int\nuc_locale_language_hash (register const char *str, register size_t len)\n{\n  static const unsigned short asso_values[] =\n    {\n      462, 462, 462, 462, 462, 462, 462, 462, 462, 462,\n      462, 462, 462, 462, 462, 462, 462, 462, 462, 462,\n      462, 462, 462, 462, 462, 462, 462, 462, 462, 462,\n      462, 462, 462, 462, 462, 462, 462, 462, 462, 462,\n      462, 462, 462, 462, 462, 462, 462, 462, 462, 462,\n      462, 462, 462, 462, 462, 462, 462, 462, 462, 462,\n      462, 462, 462, 462, 462, 462, 462, 462, 462, 462,\n      462, 462, 462, 462, 462, 462, 462, 462, 462, 462,\n      462, 462, 462, 462, 462, 462, 462, 462, 462, 462,\n      462, 462, 462, 462, 462, 462, 462, 462, 462,   4,\n       48,  12,  35, 124, 222, 107, 187, 191, 145, 241,\n       11,  73,   0, 114,   4,  66, 213,  88,   2,  25,\n       31, 209,  10, 160, 157, 154, 247, 175,  96, 462,\n        0,  34,  49, 227,  52, 187, 245, 462, 207, 231,\n      462, 462, 462, 462, 462, 462, 462, 462, 462, 462,\n      462, 462, 462, 462, 462, 462, 462, 462, 462, 462,\n      462, 462, 462, 462, 462, 462, 462, 462, 462, 462,\n      462, 462, 462, 462, 462, 462, 462, 462, 462, 462,\n      462, 462, 462, 462, 462, 462, 462, 462, 462, 462,\n      462, 462, 462, 462, 462, 462, 462, 462, 462, 462,\n      462, 462, 462, 462, 462, 462, 462, 462, 462, 462,\n      462, 462, 462, 462, 462, 462, 462, 462, 462, 462,\n      462, 462, 462, 462, 462, 462, 462, 462, 462, 462,\n      462, 462, 462, 462, 462, 462, 462, 462, 462, 462,\n      462, 462, 462, 462, 462, 462, 462, 462, 462, 462,\n      462, 462, 462, 462, 462, 462, 462, 462, 462, 462,\n      462, 462, 462, 462, 462, 462, 462, 462, 462, 462,\n      462, 462, 462\n    };\n  register unsigned int hval = len;\n\n  switch (hval)\n    {\n      default:\n        hval += asso_values[(unsigned char)str[2]+2];\n      /*FALLTHROUGH*/\n      case 2:\n        hval += asso_values[(unsigned char)str[1]+17];\n      /*FALLTHROUGH*/\n      case 1:\n        hval += asso_values[(unsigned char)str[0]+3];\n        break;\n    }\n  return hval;\n}",
      "lines": 50,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "uc_locale_languages_lookup": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        1027,
        1
      ],
      "content": "const char *\nuc_locale_languages_lookup (register const char *str, register size_t len)\n{\n  struct stringpool_t\n    {\n      char stringpool_str4[sizeof(\"sq\")];\n      char stringpool_str5[sizeof(\"men\")];\n      char stringpool_str6[sizeof(\"se\")];\n      char stringpool_str7[sizeof(\"man\")];\n      char stringpool_str8[sizeof(\"sa\")];\n      char stringpool_str11[sizeof(\"sat\")];\n      char stringpool_str12[sizeof(\"mi\")];\n      char stringpool_str13[sizeof(\"min\")];\n      char stringpool_str14[sizeof(\"si\")];\n      char stringpool_str15[sizeof(\"wen\")];\n      char stringpool_str16[sizeof(\"be\")];\n      char stringpool_str17[sizeof(\"ka\")];\n      char stringpool_str18[sizeof(\"ba\")];\n      char stringpool_str19[sizeof(\"ban\")];\n      char stringpool_str23[sizeof(\"ki\")];\n      char stringpool_str24[sizeof(\"bi\")];\n      char stringpool_str25[sizeof(\"bin\")];\n      char stringpool_str28[sizeof(\"wal\")];\n      char stringpool_str29[sizeof(\"te\")];\n      char stringpool_str30[sizeof(\"bal\")];\n      char stringpool_str31[sizeof(\"ta\")];\n      char stringpool_str32[sizeof(\"tet\")];\n      char stringpool_str33[sizeof(\"mg\")];\n      char stringpool_str35[sizeof(\"sg\")];\n      char stringpool_str36[sizeof(\"mr\")];\n      char stringpool_str37[sizeof(\"ti\")];\n      char stringpool_str38[sizeof(\"sr\")];\n      char stringpool_str39[sizeof(\"ce\")];\n      char stringpool_str40[sizeof(\"or\")];\n      char stringpool_str41[sizeof(\"ca\")];\n      char stringpool_str42[sizeof(\"mad\")];\n      char stringpool_str44[sizeof(\"kg\")];\n      char stringpool_str45[sizeof(\"bg\")];\n      char stringpool_str47[sizeof(\"kr\")];\n      char stringpool_str48[sizeof(\"br\")];\n      char stringpool_str50[sizeof(\"sid\")];\n      char stringpool_str51[sizeof(\"ms\")];\n      char stringpool_str52[sizeof(\"ae\")];\n      char stringpool_str53[sizeof(\"ss\")];\n      char stringpool_str54[sizeof(\"aa\")];\n      char stringpool_str55[sizeof(\"os\")];\n      char stringpool_str56[sizeof(\"su\")];\n      char stringpool_str58[sizeof(\"tg\")];\n      char stringpool_str61[sizeof(\"tr\")];\n      char stringpool_str62[sizeof(\"ks\")];\n      char stringpool_str63[sizeof(\"bs\")];\n      char stringpool_str64[sizeof(\"ug\")];\n      char stringpool_str65[sizeof(\"ku\")];\n      char stringpool_str66[sizeof(\"kab\")];\n      char stringpool_str67[sizeof(\"ur\")];\n      char stringpool_str69[sizeof(\"tiv\")];\n      char stringpool_str71[sizeof(\"cr\")];\n      char stringpool_str72[sizeof(\"pa\")];\n      char stringpool_str73[sizeof(\"kru\")];\n      char stringpool_str75[sizeof(\"af\")];\n      char stringpool_str76[sizeof(\"ts\")];\n      char stringpool_str77[sizeof(\"pap\")];\n      char stringpool_str78[sizeof(\"pi\")];\n      char stringpool_str79[sizeof(\"la\")];\n      char stringpool_str84[sizeof(\"ar\")];\n      char stringpool_str85[sizeof(\"li\")];\n      char stringpool_str86[sizeof(\"cs\")];\n      char stringpool_str88[sizeof(\"ceb\")];\n      char stringpool_str89[sizeof(\"cu\")];\n      char stringpool_str90[sizeof(\"bem\")];\n      char stringpool_str91[sizeof(\"kam\")];\n      char stringpool_str92[sizeof(\"sd\")];\n      char stringpool_str97[sizeof(\"sas\")];\n      char stringpool_str98[sizeof(\"mo\")];\n      char stringpool_str99[sizeof(\"as\")];\n      char stringpool_str100[sizeof(\"so\")];\n      char stringpool_str102[sizeof(\"ast\")];\n      char stringpool_str103[sizeof(\"tem\")];\n      char stringpool_str106[sizeof(\"lg\")];\n      char stringpool_str108[sizeof(\"wo\")];\n      char stringpool_str109[sizeof(\"ko\")];\n      char stringpool_str110[sizeof(\"bo\")];\n      char stringpool_str113[sizeof(\"fa\")];\n      char stringpool_str114[sizeof(\"mag\")];\n      char stringpool_str115[sizeof(\"kbd\")];\n      char stringpool_str116[sizeof(\"ab\")];\n      char stringpool_str117[sizeof(\"ps\")];\n      char stringpool_str118[sizeof(\"ne\")];\n      char stringpool_str119[sizeof(\"fi\")];\n      char stringpool_str120[sizeof(\"na\")];\n      char stringpool_str123[sizeof(\"to\")];\n      char stringpool_str125[sizeof(\"nap\")];\n      char stringpool_str127[sizeof(\"lu\")];\n      char stringpool_str128[sizeof(\"de\")];\n      char stringpool_str130[sizeof(\"da\")];\n      char stringpool_str131[sizeof(\"fil\")];\n      char stringpool_str132[sizeof(\"lua\")];\n      char stringpool_str133[sizeof(\"co\")];\n      char stringpool_str134[sizeof(\"ff\")];\n      char stringpool_str135[sizeof(\"csb\")];\n      char stringpool_str137[sizeof(\"din\")];\n      char stringpool_str141[sizeof(\"lb\")];\n      char stringpool_str142[sizeof(\"ru\")];\n      char stringpool_str143[sizeof(\"fr\")];\n      char stringpool_str145[sizeof(\"sus\")];\n      char stringpool_str146[sizeof(\"pam\")];\n      char stringpool_str147[sizeof(\"ng\")];\n      char stringpool_str149[sizeof(\"ie\")];\n      char stringpool_str150[sizeof(\"nr\")];\n      char stringpool_str151[sizeof(\"ia\")];\n      char stringpool_str153[sizeof(\"tum\")];\n      char stringpool_str156[sizeof(\"ml\")];\n      char stringpool_str157[sizeof(\"ii\")];\n      char stringpool_str158[sizeof(\"sl\")];\n      char stringpool_str159[sizeof(\"mk\")];\n      char stringpool_str160[sizeof(\"za\")];\n      char stringpool_str161[sizeof(\"sk\")];\n      char stringpool_str162[sizeof(\"bej\")];\n      char stringpool_str163[sizeof(\"kaj\")];\n      char stringpool_str165[sizeof(\"zap\")];\n      char stringpool_str166[sizeof(\"oj\")];\n      char stringpool_str167[sizeof(\"kl\")];\n      char stringpool_str169[sizeof(\"yi\")];\n      char stringpool_str170[sizeof(\"kk\")];\n      char stringpool_str171[sizeof(\"lo\")];\n      char stringpool_str173[sizeof(\"kj\")];\n      char stringpool_str174[sizeof(\"bug\")];\n      char stringpool_str175[sizeof(\"kdm\")];\n      char stringpool_str177[sizeof(\"mn\")];\n      char stringpool_str178[sizeof(\"ig\")];\n      char stringpool_str179[sizeof(\"sn\")];\n      char stringpool_str180[sizeof(\"pag\")];\n      char stringpool_str181[sizeof(\"tl\")];\n      char stringpool_str182[sizeof(\"nb\")];\n      char stringpool_str183[sizeof(\"pbb\")];\n      char stringpool_str184[sizeof(\"tk\")];\n      char stringpool_str186[sizeof(\"ro\")];\n      char stringpool_str187[sizeof(\"mos\")];\n      char stringpool_str188[sizeof(\"kn\")];\n      char stringpool_str189[sizeof(\"bn\")];\n      char stringpool_str190[sizeof(\"uk\")];\n      char stringpool_str191[sizeof(\"sv\")];\n      char stringpool_str193[sizeof(\"ga\")];\n      char stringpool_str195[sizeof(\"he\")];\n      char stringpool_str196[sizeof(\"is\")];\n      char stringpool_str197[sizeof(\"ha\")];\n      char stringpool_str198[sizeof(\"mai\")];\n      char stringpool_str199[sizeof(\"iu\")];\n      char stringpool_str200[sizeof(\"kv\")];\n      char stringpool_str202[sizeof(\"tn\")];\n      char stringpool_str203[sizeof(\"hi\")];\n      char stringpool_str204[sizeof(\"nd\")];\n      char stringpool_str205[sizeof(\"fo\")];\n      char stringpool_str206[sizeof(\"fon\")];\n      char stringpool_str207[sizeof(\"ak\")];\n      char stringpool_str208[sizeof(\"zu\")];\n      char stringpool_str209[sizeof(\"my\")];\n      char stringpool_str210[sizeof(\"myn\")];\n      char stringpool_str211[sizeof(\"mh\")];\n      char stringpool_str212[sizeof(\"no\")];\n      char stringpool_str213[sizeof(\"ve\")];\n      char stringpool_str214[sizeof(\"shn\")];\n      char stringpool_str215[sizeof(\"hil\")];\n      char stringpool_str217[sizeof(\"sc\")];\n      char stringpool_str218[sizeof(\"scn\")];\n      char stringpool_str219[sizeof(\"oc\")];\n      char stringpool_str220[sizeof(\"ky\")];\n      char stringpool_str221[sizeof(\"vi\")];\n      char stringpool_str222[sizeof(\"pl\")];\n      char stringpool_str223[sizeof(\"bh\")];\n      char stringpool_str224[sizeof(\"cv\")];\n      char stringpool_str225[sizeof(\"an\")];\n      char stringpool_str226[sizeof(\"ee\")];\n      char stringpool_str227[sizeof(\"hr\")];\n      char stringpool_str229[sizeof(\"mt\")];\n      char stringpool_str230[sizeof(\"war\")];\n      char stringpool_str231[sizeof(\"st\")];\n      char stringpool_str234[sizeof(\"ty\")];\n      char stringpool_str235[sizeof(\"id\")];\n      char stringpool_str236[sizeof(\"th\")];\n      char stringpool_str237[sizeof(\"av\")];\n      char stringpool_str240[sizeof(\"raj\")];\n      char stringpool_str241[sizeof(\"gu\")];\n      char stringpool_str242[sizeof(\"luo\")];\n      char stringpool_str244[sizeof(\"cy\")];\n      char stringpool_str245[sizeof(\"hu\")];\n      char stringpool_str246[sizeof(\"ch\")];\n      char stringpool_str247[sizeof(\"ja\")];\n      char stringpool_str248[sizeof(\"mak\")];\n      char stringpool_str249[sizeof(\"sw\")];\n      char stringpool_str250[sizeof(\"ln\")];\n      char stringpool_str251[sizeof(\"sm\")];\n      char stringpool_str252[sizeof(\"srr\")];\n      char stringpool_str253[sizeof(\"om\")];\n      char stringpool_str254[sizeof(\"tt\")];\n      char stringpool_str255[sizeof(\"yo\")];\n      char stringpool_str257[sizeof(\"ay\")];\n      char stringpool_str258[sizeof(\"kw\")];\n      char stringpool_str259[sizeof(\"crh\")];\n      char stringpool_str260[sizeof(\"km\")];\n      char stringpool_str261[sizeof(\"bm\")];\n      char stringpool_str262[sizeof(\"lv\")];\n      char stringpool_str264[sizeof(\"uz\")];\n      char stringpool_str265[sizeof(\"rn\")];\n      char stringpool_str266[sizeof(\"bik\")];\n      char stringpool_str267[sizeof(\"qu\")];\n      char stringpool_str269[sizeof(\"fj\")];\n      char stringpool_str270[sizeof(\"nl\")];\n      char stringpool_str272[sizeof(\"tw\")];\n      char stringpool_str273[sizeof(\"es\")];\n      char stringpool_str276[sizeof(\"eu\")];\n      char stringpool_str277[sizeof(\"gd\")];\n      char stringpool_str278[sizeof(\"yao\")];\n      char stringpool_str280[sizeof(\"nso\")];\n      char stringpool_str281[sizeof(\"az\")];\n      char stringpool_str286[sizeof(\"gon\")];\n      char stringpool_str289[sizeof(\"ho\")];\n      char stringpool_str291[sizeof(\"nn\")];\n      char stringpool_str293[sizeof(\"nds\")];\n      char stringpool_str295[sizeof(\"pt\")];\n      char stringpool_str296[sizeof(\"jab\")];\n      char stringpool_str297[sizeof(\"am\")];\n      char stringpool_str298[sizeof(\"suk\")];\n      char stringpool_str300[sizeof(\"awa\")];\n      char stringpool_str302[sizeof(\"lt\")];\n      char stringpool_str303[sizeof(\"nv\")];\n      char stringpool_str304[sizeof(\"ik\")];\n      char stringpool_str307[sizeof(\"vo\")];\n      char stringpool_str308[sizeof(\"nah\")];\n      char stringpool_str309[sizeof(\"kmb\")];\n      char stringpool_str313[sizeof(\"dv\")];\n      char stringpool_str316[sizeof(\"fy\")];\n      char stringpool_str320[sizeof(\"eo\")];\n      char stringpool_str323[sizeof(\"ny\")];\n      char stringpool_str324[sizeof(\"nyn\")];\n      char stringpool_str329[sizeof(\"umb\")];\n      char stringpool_str333[sizeof(\"ang\")];\n      char stringpool_str334[sizeof(\"kcg\")];\n      char stringpool_str335[sizeof(\"rw\")];\n      char stringpool_str337[sizeof(\"rm\")];\n      char stringpool_str338[sizeof(\"bho\")];\n      char stringpool_str343[sizeof(\"gl\")];\n      char stringpool_str351[sizeof(\"kok\")];\n      char stringpool_str357[sizeof(\"dz\")];\n      char stringpool_str364[sizeof(\"gn\")];\n      char stringpool_str365[sizeof(\"zh\")];\n      char stringpool_str369[sizeof(\"mni\")];\n      char stringpool_str371[sizeof(\"xh\")];\n      char stringpool_str374[sizeof(\"it\")];\n      char stringpool_str375[sizeof(\"fur\")];\n      char stringpool_str376[sizeof(\"gv\")];\n      char stringpool_str378[sizeof(\"el\")];\n      char stringpool_str388[sizeof(\"ace\")];\n      char stringpool_str397[sizeof(\"nym\")];\n      char stringpool_str399[sizeof(\"en\")];\n      char stringpool_str400[sizeof(\"hy\")];\n      char stringpool_str414[sizeof(\"doi\")];\n      char stringpool_str416[sizeof(\"ilo\")];\n      char stringpool_str420[sizeof(\"ht\")];\n      char stringpool_str424[sizeof(\"hz\")];\n      char stringpool_str430[sizeof(\"jv\")];\n      char stringpool_str441[sizeof(\"hmn\")];\n      char stringpool_str448[sizeof(\"gsw\")];\n      char stringpool_str451[sizeof(\"et\")];\n      char stringpool_str461[sizeof(\"mwr\")];\n    };\n  static const struct stringpool_t stringpool_contents =\n    {\n      \"sq\",\n      \"men\",\n      \"se\",\n      \"man\",\n      \"sa\",\n      \"sat\",\n      \"mi\",\n      \"min\",\n      \"si\",\n      \"wen\",\n      \"be\",\n      \"ka\",\n      \"ba\",\n      \"ban\",\n      \"ki\",\n      \"bi\",\n      \"bin\",\n      \"wal\",\n      \"te\",\n      \"bal\",\n      \"ta\",\n      \"tet\",\n      \"mg\",\n      \"sg\",\n      \"mr\",\n      \"ti\",\n      \"sr\",\n      \"ce\",\n      \"or\",\n      \"ca\",\n      \"mad\",\n      \"kg\",\n      \"bg\",\n      \"kr\",\n      \"br\",\n      \"sid\",\n      \"ms\",\n      \"ae\",\n      \"ss\",\n      \"aa\",\n      \"os\",\n      \"su\",\n      \"tg\",\n      \"tr\",\n      \"ks\",\n      \"bs\",\n      \"ug\",\n      \"ku\",\n      \"kab\",\n      \"ur\",\n      \"tiv\",\n      \"cr\",\n      \"pa\",\n      \"kru\",\n      \"af\",\n      \"ts\",\n      \"pap\",\n      \"pi\",\n      \"la\",\n      \"ar\",\n      \"li\",\n      \"cs\",\n      \"ceb\",\n      \"cu\",\n      \"bem\",\n      \"kam\",\n      \"sd\",\n      \"sas\",\n      \"mo\",\n      \"as\",\n      \"so\",\n      \"ast\",\n      \"tem\",\n      \"lg\",\n      \"wo\",\n      \"ko\",\n      \"bo\",\n      \"fa\",\n      \"mag\",\n      \"kbd\",\n      \"ab\",\n      \"ps\",\n      \"ne\",\n      \"fi\",\n      \"na\",\n      \"to\",\n      \"nap\",\n      \"lu\",\n      \"de\",\n      \"da\",\n      \"fil\",\n      \"lua\",\n      \"co\",\n      \"ff\",\n      \"csb\",\n      \"din\",\n      \"lb\",\n      \"ru\",\n      \"fr\",\n      \"sus\",\n      \"pam\",\n      \"ng\",\n      \"ie\",\n      \"nr\",\n      \"ia\",\n      \"tum\",\n      \"ml\",\n      \"ii\",\n      \"sl\",\n      \"mk\",\n      \"za\",\n      \"sk\",\n      \"bej\",\n      \"kaj\",\n      \"zap\",\n      \"oj\",\n      \"kl\",\n      \"yi\",\n      \"kk\",\n      \"lo\",\n      \"kj\",\n      \"bug\",\n      \"kdm\",\n      \"mn\",\n      \"ig\",\n      \"sn\",\n      \"pag\",\n      \"tl\",\n      \"nb\",\n      \"pbb\",\n      \"tk\",\n      \"ro\",\n      \"mos\",\n      \"kn\",\n      \"bn\",\n      \"uk\",\n      \"sv\",\n      \"ga\",\n      \"he\",\n      \"is\",\n      \"ha\",\n      \"mai\",\n      \"iu\",\n      \"kv\",\n      \"tn\",\n      \"hi\",\n      \"nd\",\n      \"fo\",\n      \"fon\",\n      \"ak\",\n      \"zu\",\n      \"my\",\n      \"myn\",\n      \"mh\",\n      \"no\",\n      \"ve\",\n      \"shn\",\n      \"hil\",\n      \"sc\",\n      \"scn\",\n      \"oc\",\n      \"ky\",\n      \"vi\",\n      \"pl\",\n      \"bh\",\n      \"cv\",\n      \"an\",\n      \"ee\",\n      \"hr\",\n      \"mt\",\n      \"war\",\n      \"st\",\n      \"ty\",\n      \"id\",\n      \"th\",\n      \"av\",\n      \"raj\",\n      \"gu\",\n      \"luo\",\n      \"cy\",\n      \"hu\",\n      \"ch\",\n      \"ja\",\n      \"mak\",\n      \"sw\",\n      \"ln\",\n      \"sm\",\n      \"srr\",\n      \"om\",\n      \"tt\",\n      \"yo\",\n      \"ay\",\n      \"kw\",\n      \"crh\",\n      \"km\",\n      \"bm\",\n      \"lv\",\n      \"uz\",\n      \"rn\",\n      \"bik\",\n      \"qu\",\n      \"fj\",\n      \"nl\",\n      \"tw\",\n      \"es\",\n      \"eu\",\n      \"gd\",\n      \"yao\",\n      \"nso\",\n      \"az\",\n      \"gon\",\n      \"ho\",\n      \"nn\",\n      \"nds\",\n      \"pt\",\n      \"jab\",\n      \"am\",\n      \"suk\",\n      \"awa\",\n      \"lt\",\n      \"nv\",\n      \"ik\",\n      \"vo\",\n      \"nah\",\n      \"kmb\",\n      \"dv\",\n      \"fy\",\n      \"eo\",\n      \"ny\",\n      \"nyn\",\n      \"umb\",\n      \"ang\",\n      \"kcg\",\n      \"rw\",\n      \"rm\",\n      \"bho\",\n      \"gl\",\n      \"kok\",\n      \"dz\",\n      \"gn\",\n      \"zh\",\n      \"mni\",\n      \"xh\",\n      \"it\",\n      \"fur\",\n      \"gv\",\n      \"el\",\n      \"ace\",\n      \"nym\",\n      \"en\",\n      \"hy\",\n      \"doi\",\n      \"ilo\",\n      \"ht\",\n      \"hz\",\n      \"jv\",\n      \"hmn\",\n      \"gsw\",\n      \"et\",\n      \"mwr\"\n    };\n  #define stringpool ((const char *) &stringpool_contents)\n  static const unsigned char lengthtable[] =\n    {\n       0,  0,  0,  0,  2,  3,  2,  3,  2,  0,  0,  3,  2,  3,\n       2,  3,  2,  2,  2,  3,  0,  0,  0,  2,  2,  3,  0,  0,\n       3,  2,  3,  2,  3,  2,  0,  2,  2,  2,  2,  2,  2,  2,\n       3,  0,  2,  2,  0,  2,  2,  0,  3,  2,  2,  2,  2,  2,\n       2,  0,  2,  0,  0,  2,  2,  2,  2,  2,  3,  2,  0,  3,\n       0,  2,  2,  3,  0,  2,  2,  3,  2,  2,  0,  0,  0,  0,\n       2,  2,  2,  0,  3,  2,  3,  3,  2,  0,  0,  0,  0,  3,\n       2,  2,  2,  0,  3,  3,  0,  0,  2,  0,  2,  2,  2,  0,\n       0,  2,  3,  3,  2,  2,  2,  2,  2,  0,  0,  2,  0,  3,\n       0,  2,  2,  0,  2,  3,  3,  2,  2,  3,  0,  3,  0,  0,\n       0,  2,  2,  2,  0,  3,  3,  2,  0,  2,  2,  2,  0,  3,\n       0,  0,  2,  2,  2,  2,  2,  2,  3,  3,  0,  3,  2,  2,\n       0,  2,  2,  2,  0,  2,  3,  3,  0,  2,  2,  2,  3,  2,\n       2,  3,  2,  0,  2,  3,  2,  2,  2,  2,  0,  2,  0,  2,\n       2,  2,  3,  2,  2,  0,  2,  2,  2,  2,  3,  2,  2,  2,\n       3,  2,  2,  2,  3,  3,  0,  2,  3,  2,  2,  2,  2,  2,\n       2,  2,  2,  2,  0,  2,  3,  2,  0,  0,  2,  2,  2,  2,\n       0,  0,  3,  2,  3,  0,  2,  2,  2,  2,  3,  2,  2,  2,\n       3,  2,  2,  2,  0,  2,  2,  3,  2,  2,  2,  0,  2,  2,\n       3,  2,  0,  2,  2,  0,  2,  2,  0,  0,  2,  2,  3,  0,\n       3,  2,  0,  0,  0,  0,  3,  0,  0,  2,  0,  2,  0,  3,\n       0,  2,  3,  2,  3,  0,  3,  0,  2,  2,  2,  0,  0,  2,\n       3,  3,  0,  0,  0,  2,  0,  0,  2,  0,  0,  0,  2,  0,\n       0,  2,  3,  0,  0,  0,  0,  3,  0,  0,  0,  3,  3,  2,\n       0,  2,  3,  0,  0,  0,  0,  2,  0,  0,  0,  0,  0,  0,\n       0,  3,  0,  0,  0,  0,  0,  2,  0,  0,  0,  0,  0,  0,\n       2,  2,  0,  0,  0,  3,  0,  2,  0,  0,  2,  3,  2,  0,\n       2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  3,  0,  0,  0,\n       0,  0,  0,  0,  0,  3,  0,  2,  2,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  3,  0,  3,  0,  0,  0,\n       2,  0,  0,  0,  2,  0,  0,  0,  0,  0,  2,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  3,  0,  0,  0,  0,  0,  0,\n       3,  0,  0,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  3\n    };\n  static const int wordlist[] =\n    {\n      -1, -1, -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str4,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str5,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str6,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str7,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str8,\n      -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str11,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str12,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str13,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str14,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str15,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str16,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str17,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str18,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str19,\n      -1, -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str23,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str24,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str25,\n      -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str28,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str29,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str30,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str31,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str32,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str33,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str35,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str36,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str37,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str38,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str39,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str40,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str41,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str42,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str44,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str45,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str47,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str48,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str50,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str51,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str52,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str53,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str54,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str55,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str56,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str58,\n      -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str61,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str62,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str63,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str64,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str65,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str66,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str67,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str69,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str71,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str72,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str73,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str75,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str76,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str77,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str78,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str79,\n      -1, -1, -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str84,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str85,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str86,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str88,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str89,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str90,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str91,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str92,\n      -1, -1, -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str97,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str98,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str99,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str100,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str102,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str103,\n      -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str106,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str108,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str109,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str110,\n      -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str113,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str114,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str115,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str116,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str117,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str118,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str119,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str120,\n      -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str123,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str125,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str127,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str128,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str130,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str131,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str132,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str133,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str134,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str135,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str137,\n      -1, -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str141,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str142,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str143,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str145,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str146,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str147,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str149,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str150,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str151,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str153,\n      -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str156,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str157,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str158,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str159,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str160,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str161,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str162,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str163,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str165,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str166,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str167,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str169,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str170,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str171,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str173,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str174,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str175,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str177,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str178,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str179,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str180,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str181,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str182,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str183,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str184,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str186,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str187,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str188,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str189,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str190,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str191,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str193,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str195,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str196,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str197,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str198,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str199,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str200,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str202,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str203,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str204,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str205,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str206,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str207,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str208,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str209,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str210,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str211,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str212,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str213,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str214,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str215,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str217,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str218,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str219,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str220,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str221,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str222,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str223,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str224,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str225,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str226,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str227,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str229,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str230,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str231,\n      -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str234,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str235,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str236,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str237,\n      -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str240,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str241,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str242,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str244,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str245,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str246,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str247,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str248,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str249,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str250,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str251,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str252,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str253,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str254,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str255,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str257,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str258,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str259,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str260,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str261,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str262,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str264,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str265,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str266,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str267,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str269,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str270,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str272,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str273,\n      -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str276,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str277,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str278,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str280,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str281,\n      -1, -1, -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str286,\n      -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str289,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str291,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str293,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str295,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str296,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str297,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str298,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str300,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str302,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str303,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str304,\n      -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str307,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str308,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str309,\n      -1, -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str313,\n      -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str316,\n      -1, -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str320,\n      -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str323,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str324,\n      -1, -1, -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str329,\n      -1, -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str333,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str334,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str335,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str337,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str338,\n      -1, -1, -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str343,\n      -1, -1, -1, -1, -1, -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str351,\n      -1, -1, -1, -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str357,\n      -1, -1, -1, -1, -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str364,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str365,\n      -1, -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str369,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str371,\n      -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str374,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str375,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str376,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str378,\n      -1, -1, -1, -1, -1, -1, -1, -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str388,\n      -1, -1, -1, -1, -1, -1, -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str397,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str399,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str400,\n      -1, -1, -1, -1, -1, -1, -1, -1, -1,\n      -1, -1, -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str414,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str416,\n      -1, -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str420,\n      -1, -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str424,\n      -1, -1, -1, -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str430,\n      -1, -1, -1, -1, -1, -1, -1, -1, -1,\n      -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str441,\n      -1, -1, -1, -1, -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str448,\n      -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str451,\n      -1, -1, -1, -1, -1, -1, -1, -1, -1,\n      (int)(size_t)&((struct stringpool_t *)0)->stringpool_str461\n    };\n\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register unsigned int key = uc_locale_language_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE)\n        if (len == lengthtable[key])\n          {\n            register const char *s = wordlist[key] + stringpool;\n\n            if (*str == *s && !memcmp (str + 1, s + 1, len - 1))\n              return s;\n          }\n    }\n  return 0;\n}",
      "lines": 931,
      "depth": 15,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nuc_locale_languages_lookup (register const char *str, register size_t len)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/simple-mapping.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "ucs4_t\nFUNC (ucs4_t uc)\n{\n  unsigned int index1 = uc >> mapping_header_0;\n  if (index1 < mapping_header_1)\n    {\n      int lookup1 = u_mapping.level1[index1];\n      if (lookup1 >= 0)\n        {\n          unsigned int index2 = (uc >> mapping_header_2) & mapping_header_3;\n          int lookup2 = u_mapping.level2[lookup1 + index2];\n          if (lookup2 >= 0)\n            {\n              unsigned int index3 = (uc & mapping_header_4);\n              int lookup3 = u_mapping.level3[lookup2 + index3];\n\n              return uc + lookup3;\n            }\n        }\n    }\n  return uc;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "ucs4_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/special-casing-table.h": {
    "gl_unicase_special_hash": {
      "start_point": [
        20,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static unsigned int\ngl_unicase_special_hash (register const char *str, register size_t len)\n{\n  static const unsigned char asso_values[] =\n    {\n        2,   0,   4,   5,  37,  12, 121,   4, 122, 122,\n      122, 122, 122, 122, 122, 122, 122, 122, 122, 120,\n      119, 118, 117, 116, 122, 122, 122, 122, 122, 122,\n        5,   3, 122, 122, 122, 122, 122, 122, 122, 122,\n      115, 122, 122, 122, 122, 122, 114, 122,   6, 122,\n      122, 122, 122, 122, 122, 122, 122, 122, 122, 122,\n      122, 122, 122, 122, 122, 122, 122, 122, 122, 122,\n      122, 122, 122,   1, 111, 122, 122, 122, 122, 122,\n      109, 122, 108, 122, 107, 122, 106, 122, 122, 122,\n      122, 122, 122, 122, 122, 122, 122, 122, 122, 122,\n      122, 122, 122, 122, 122,  33, 122, 122, 122, 122,\n      122, 122, 122, 122, 122, 122, 122, 122, 122, 122,\n      122, 122, 122, 122, 122, 122, 122, 122, 105, 104,\n      103, 102, 101, 100,  99,  31,  98,  97,  96,  95,\n       94,  93,  92,  91,  28,  90,  89,  88,  87,  86,\n       27,  24,  23,  20,  19,  85,  84,  83,  16,  82,\n       81,  80,  79,  15,  78,  77,  76,  75,  74,  73,\n       72,  71,  70,  69,  68,  67,  64, 122,  65,  64,\n       63, 122,  62,  61, 122, 122, 122, 122,  60, 122,\n      122, 122, 122, 122,  59,  58,  57, 122,  56,  55,\n      122, 122, 122, 122,  14,  55, 122, 122, 122, 122,\n       53,  52, 122, 122,  51,  50, 122, 122, 122, 122,\n      122, 122, 122,  50, 122, 122,  48,  47,  46, 122,\n       45,  44, 122, 122, 122, 122, 122, 122, 122, 122,\n       46, 122,  42,  41,  39, 122,  38,  35, 122, 122,\n      122,   0,  33, 122, 122, 122, 122\n    };\n  return asso_values[(unsigned char)str[2]+1] + asso_values[(unsigned char)str[1]] + asso_values[(unsigned char)str[0]];\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "gl_unicase_special_lookup": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        332,
        1
      ],
      "content": "const struct special_casing_rule *\ngl_unicase_special_lookup (register const char *str, register size_t len)\n{\n  static const unsigned char lengthtable[] =\n    {\n       3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n       3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n       3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n       3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n       3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n       3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n       3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n       3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n       3,  3,  3,  3,  3,  3,  3,  3,  3,  3\n    };\n  static const struct special_casing_rule wordlist[] =\n    {\n#line 126 \"./unicase/special-casing-table.gperf\"\n      {\"\\373\\001\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0046, 0x0049,      0 }, { 0xFB01,      0,      0 }, { 0x0046, 0x0069,      0 }, { 0x0066, 0x0069,      0 }},\n#line 31 \"./unicase/special-casing-table.gperf\"\n      {\"\\001I\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x02BC, 0x004E,      0 }, { 0x0149,      0,      0 }, { 0x02BC, 0x004E,      0 }, { 0x02BC, 0x006E,      0 }},\n#line 125 \"./unicase/special-casing-table.gperf\"\n      {\"\\373\\000\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0046, 0x0046,      0 }, { 0xFB00,      0,      0 }, { 0x0046, 0x0066,      0 }, { 0x0066, 0x0066,      0 }},\n#line 15 \"./unicase/special-casing-table.gperf\"\n      {\"\\000I\\000\", 1,  SCC_MORE_ABOVE       , {  'l',  't' }, { 0x0049,      0,      0 }, { 0x0069, 0x0307,      0 }, { 0x0049,      0,      0 }, { 0x0069,      0,      0 }},\n#line 127 \"./unicase/special-casing-table.gperf\"\n      {\"\\373\\002\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0046, 0x004C,      0 }, { 0xFB02,      0,      0 }, { 0x0046, 0x006C,      0 }, { 0x0066, 0x006C,      0 }},\n#line 128 \"./unicase/special-casing-table.gperf\"\n      {\"\\373\\003\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0046, 0x0046, 0x0049 }, { 0xFB03,      0,      0 }, { 0x0046, 0x0066, 0x0069 }, { 0x0066, 0x0066, 0x0069 }},\n#line 28 \"./unicase/special-casing-table.gperf\"\n      {\"\\0010\\000\", 1,  SCC_ALWAYS           , {  't',  'r' }, { 0x0130,      0,      0 }, { 0x0069,      0,      0 }, { 0x0130,      0,      0 }, { 0x0069,      0,      0 }},\n#line 16 \"./unicase/special-casing-table.gperf\"\n      {\"\\000I\\001\", 1, -SCC_BEFORE_DOT       , {  't',  'r' }, { 0x0049,      0,      0 }, { 0x0131,      0,      0 }, { 0x0049,      0,      0 }, { 0x0131,      0,      0 }},\n#line 17 \"./unicase/special-casing-table.gperf\"\n      {\"\\000I\\002\", 1, -SCC_BEFORE_DOT       , {  'a',  'z' }, { 0x0049,      0,      0 }, { 0x0131,      0,      0 }, { 0x0049,      0,      0 }, { 0x0131,      0,      0 }},\n#line 33 \"./unicase/special-casing-table.gperf\"\n      {\"\\003\\007\\000\", 1,  SCC_AFTER_SOFT_DOTTED, {  'l',  't' }, {      0,      0,      0 }, { 0x0307,      0,      0 }, {      0,      0,      0 }, { 0x0307,      0,      0 }},\n#line 29 \"./unicase/special-casing-table.gperf\"\n      {\"\\0010\\001\", 1,  SCC_ALWAYS           , {  'a',  'z' }, { 0x0130,      0,      0 }, { 0x0069,      0,      0 }, { 0x0130,      0,      0 }, { 0x0069,      0,      0 }},\n#line 30 \"./unicase/special-casing-table.gperf\"\n      {\"\\0010\\002\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0130,      0,      0 }, { 0x0069, 0x0307,      0 }, { 0x0130,      0,      0 }, { 0x0069, 0x0307,      0 }},\n#line 130 \"./unicase/special-casing-table.gperf\"\n      {\"\\373\\005\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0053, 0x0054,      0 }, { 0xFB05,      0,      0 }, { 0x0053, 0x0074,      0 }, { 0x0073, 0x0074,      0 }},\n#line 34 \"./unicase/special-casing-table.gperf\"\n      {\"\\003\\007\\001\", 1,  SCC_AFTER_I          , {  't',  'r' }, { 0x0307,      0,      0 }, {      0,      0,      0 }, { 0x0307,      0,      0 }, { 0x0307,      0,      0 }},\n#line 35 \"./unicase/special-casing-table.gperf\"\n      {\"\\003\\007\\002\", 0,  SCC_AFTER_I          , {  'a',  'z' }, { 0x0307,      0,      0 }, {      0,      0,      0 }, { 0x0307,      0,      0 }, { 0x0307,      0,      0 }},\n#line 19 \"./unicase/special-casing-table.gperf\"\n      {\"\\000I\\004\", 0,  SCC_ALWAYS           , {  'a',  'z' }, { 0x0049,      0,      0 }, { 0x0069,      0,      0 }, { 0x0049,      0,      0 }, { 0x0131,      0,      0 }},\n#line 23 \"./unicase/special-casing-table.gperf\"\n      {\"\\000\\314\\000\", 0,  SCC_ALWAYS           , {  'l',  't' }, { 0x00CC,      0,      0 }, { 0x0069, 0x0307, 0x0300 }, { 0x00CC,      0,      0 }, { 0x00EC,      0,      0 }},\n#line 109 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\314\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0397, 0x0399,      0 }, { 0x1FC3,      0,      0 }, { 0x1FCC,      0,      0 }, { 0x03B7, 0x03B9,      0 }},\n#line 85 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\243\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F6B, 0x0399,      0 }, { 0x1FA3,      0,      0 }, { 0x1FAB,      0,      0 }, { 0x1F63, 0x03B9,      0 }},\n#line 80 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\236\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F2E, 0x0399,      0 }, { 0x1F96,      0,      0 }, { 0x1F9E,      0,      0 }, { 0x1F26, 0x03B9,      0 }},\n#line 37 \"./unicase/special-casing-table.gperf\"\n      {\"\\003\\243\\000\", 0,  SCC_FINAL_SIGMA      , { '\\0', '\\0' }, { 0x03A3,      0,      0 }, { 0x03C2,      0,      0 }, { 0x03A3,      0,      0 }, { 0x03C3,      0,      0 }},\n#line 45 \"./unicase/special-casing-table.gperf\"\n      {\"\\036\\236\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1E9E,      0,      0 }, { 0x00DF,      0,      0 }, { 0x1E9E,      0,      0 }, { 0x0073, 0x0073,      0 }},\n#line 76 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\232\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F2A, 0x0399,      0 }, { 0x1F92,      0,      0 }, { 0x1F9A,      0,      0 }, { 0x1F22, 0x03B9,      0 }},\n#line 75 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\231\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F29, 0x0399,      0 }, { 0x1F91,      0,      0 }, { 0x1F99,      0,      0 }, { 0x1F21, 0x03B9,      0 }},\n#line 44 \"./unicase/special-casing-table.gperf\"\n      {\"\\036\\232\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0041, 0x02BE,      0 }, { 0x1E9A,      0,      0 }, { 0x0041, 0x02BE,      0 }, { 0x0061, 0x02BE,      0 }},\n#line 43 \"./unicase/special-casing-table.gperf\"\n      {\"\\036\\231\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0059, 0x030A,      0 }, { 0x1E99,      0,      0 }, { 0x0059, 0x030A,      0 }, { 0x0079, 0x030A,      0 }},\n#line 74 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\230\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F28, 0x0399,      0 }, { 0x1F90,      0,      0 }, { 0x1F98,      0,      0 }, { 0x1F20, 0x03B9,      0 }},\n#line 73 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\227\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F2F, 0x0399,      0 }, { 0x1F97,      0,      0 }, { 0x1F9F,      0,      0 }, { 0x1F27, 0x03B9,      0 }},\n#line 42 \"./unicase/special-casing-table.gperf\"\n      {\"\\036\\230\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0057, 0x030A,      0 }, { 0x1E98,      0,      0 }, { 0x0057, 0x030A,      0 }, { 0x0077, 0x030A,      0 }},\n#line 41 \"./unicase/special-casing-table.gperf\"\n      {\"\\036\\227\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0054, 0x0308,      0 }, { 0x1E97,      0,      0 }, { 0x0054, 0x0308,      0 }, { 0x0074, 0x0308,      0 }},\n#line 72 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\226\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F2E, 0x0399,      0 }, { 0x1F96,      0,      0 }, { 0x1F9E,      0,      0 }, { 0x1F26, 0x03B9,      0 }},\n#line 66 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\220\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F28, 0x0399,      0 }, { 0x1F90,      0,      0 }, { 0x1F98,      0,      0 }, { 0x1F20, 0x03B9,      0 }},\n#line 40 \"./unicase/special-casing-table.gperf\"\n      {\"\\036\\226\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0048, 0x0331,      0 }, { 0x1E96,      0,      0 }, { 0x0048, 0x0331,      0 }, { 0x0068, 0x0331,      0 }},\n#line 36 \"./unicase/special-casing-table.gperf\"\n      {\"\\003\\220\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0399, 0x0308, 0x0301 }, { 0x0390,      0,      0 }, { 0x0399, 0x0308, 0x0301 }, { 0x03B9, 0x0308, 0x0301 }},\n#line 57 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\207\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F0F, 0x0399,      0 }, { 0x1F87,      0,      0 }, { 0x1F8F,      0,      0 }, { 0x1F07, 0x03B9,      0 }},\n#line 21 \"./unicase/special-casing-table.gperf\"\n      {\"\\000i\\000\", 1,  SCC_ALWAYS           , {  't',  'r' }, { 0x0130,      0,      0 }, { 0x0069,      0,      0 }, { 0x0130,      0,      0 }, { 0x0069,      0,      0 }},\n#line 124 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\374\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x03A9, 0x0399,      0 }, { 0x1FF3,      0,      0 }, { 0x1FFC,      0,      0 }, { 0x03C9, 0x03B9,      0 }},\n#line 129 \"./unicase/special-casing-table.gperf\"\n      {\"\\373\\004\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0046, 0x0046, 0x004C }, { 0xFB04,      0,      0 }, { 0x0046, 0x0066, 0x006C }, { 0x0066, 0x0066, 0x006C }},\n#line 123 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\367\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x03A9, 0x0342, 0x0399 }, { 0x1FF7,      0,      0 }, { 0x03A9, 0x0342, 0x0345 }, { 0x03C9, 0x0342, 0x03B9 }},\n#line 22 \"./unicase/special-casing-table.gperf\"\n      {\"\\000i\\001\", 0,  SCC_ALWAYS           , {  'a',  'z' }, { 0x0130,      0,      0 }, { 0x0069,      0,      0 }, { 0x0130,      0,      0 }, { 0x0069,      0,      0 }},\n#line 18 \"./unicase/special-casing-table.gperf\"\n      {\"\\000I\\003\", 1,  SCC_ALWAYS           , {  't',  'r' }, { 0x0049,      0,      0 }, { 0x0069,      0,      0 }, { 0x0049,      0,      0 }, { 0x0131,      0,      0 }},\n#line 122 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\366\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x03A9, 0x0342,      0 }, { 0x1FF6,      0,      0 }, { 0x03A9, 0x0342,      0 }, { 0x03C9, 0x0342,      0 }},\n#line 121 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\364\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x038F, 0x0399,      0 }, { 0x1FF4,      0,      0 }, { 0x038F, 0x0345,      0 }, { 0x03CE, 0x03B9,      0 }},\n#line 39 \"./unicase/special-casing-table.gperf\"\n      {\"\\005\\207\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0535, 0x0552,      0 }, { 0x0587,      0,      0 }, { 0x0535, 0x0582,      0 }, { 0x0565, 0x0582,      0 }},\n#line 120 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\363\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x03A9, 0x0399,      0 }, { 0x1FF3,      0,      0 }, { 0x1FFC,      0,      0 }, { 0x03C9, 0x03B9,      0 }},\n#line 119 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\362\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1FFA, 0x0399,      0 }, { 0x1FF2,      0,      0 }, { 0x1FFA, 0x0345,      0 }, { 0x1F7C, 0x03B9,      0 }},\n#line 32 \"./unicase/special-casing-table.gperf\"\n      {\"\\001\\360\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x004A, 0x030C,      0 }, { 0x01F0,      0,      0 }, { 0x004A, 0x030C,      0 }, { 0x006A, 0x030C,      0 }},\n#line 118 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\347\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x03A5, 0x0308, 0x0342 }, { 0x1FE7,      0,      0 }, { 0x03A5, 0x0308, 0x0342 }, { 0x03C5, 0x0308, 0x0342 }},\n#line 117 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\346\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x03A5, 0x0342,      0 }, { 0x1FE6,      0,      0 }, { 0x03A5, 0x0342,      0 }, { 0x03C5, 0x0342,      0 }},\n#line 116 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\344\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x03A1, 0x0313,      0 }, { 0x1FE4,      0,      0 }, { 0x03A1, 0x0313,      0 }, { 0x03C1, 0x0313,      0 }},\n#line 115 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\343\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x03A5, 0x0308, 0x0301 }, { 0x1FE3,      0,      0 }, { 0x03A5, 0x0308, 0x0301 }, { 0x03C5, 0x0308, 0x0301 }},\n#line 114 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\342\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x03A5, 0x0308, 0x0300 }, { 0x1FE2,      0,      0 }, { 0x03A5, 0x0308, 0x0300 }, { 0x03C5, 0x0308, 0x0300 }},\n#line 25 \"./unicase/special-casing-table.gperf\"\n      {\"\\000\\337\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0053, 0x0053,      0 }, { 0x00DF,      0,      0 }, { 0x0053, 0x0073,      0 }, { 0x0073, 0x0073,      0 }},\n#line 113 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\327\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0399, 0x0308, 0x0342 }, { 0x1FD7,      0,      0 }, { 0x0399, 0x0308, 0x0342 }, { 0x03B9, 0x0308, 0x0342 }},\n#line 112 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\326\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0399, 0x0342,      0 }, { 0x1FD6,      0,      0 }, { 0x0399, 0x0342,      0 }, { 0x03B9, 0x0342,      0 }},\n#line 111 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\323\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0399, 0x0308, 0x0301 }, { 0x1FD3,      0,      0 }, { 0x0399, 0x0308, 0x0301 }, { 0x03B9, 0x0308, 0x0301 }},\n#line 110 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\322\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0399, 0x0308, 0x0300 }, { 0x1FD2,      0,      0 }, { 0x0399, 0x0308, 0x0300 }, { 0x03B9, 0x0308, 0x0300 }},\n#line 24 \"./unicase/special-casing-table.gperf\"\n      {\"\\000\\315\\000\", 0,  SCC_ALWAYS           , {  'l',  't' }, { 0x00CD,      0,      0 }, { 0x0069, 0x0307, 0x0301 }, { 0x00CD,      0,      0 }, { 0x00ED,      0,      0 }},\n#line 108 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\307\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0397, 0x0342, 0x0399 }, { 0x1FC7,      0,      0 }, { 0x0397, 0x0342, 0x0345 }, { 0x03B7, 0x0342, 0x03B9 }},\n#line 107 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\306\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0397, 0x0342,      0 }, { 0x1FC6,      0,      0 }, { 0x0397, 0x0342,      0 }, { 0x03B7, 0x0342,      0 }},\n#line 106 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\304\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0389, 0x0399,      0 }, { 0x1FC4,      0,      0 }, { 0x0389, 0x0345,      0 }, { 0x03AE, 0x03B9,      0 }},\n#line 105 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\303\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0397, 0x0399,      0 }, { 0x1FC3,      0,      0 }, { 0x1FCC,      0,      0 }, { 0x03B7, 0x03B9,      0 }},\n#line 104 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\302\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1FCA, 0x0399,      0 }, { 0x1FC2,      0,      0 }, { 0x1FCA, 0x0345,      0 }, { 0x1F74, 0x03B9,      0 }},\n#line 103 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\274\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0391, 0x0399,      0 }, { 0x1FB3,      0,      0 }, { 0x1FBC,      0,      0 }, { 0x03B1, 0x03B9,      0 }},\n#line 102 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\267\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0391, 0x0342, 0x0399 }, { 0x1FB7,      0,      0 }, { 0x0391, 0x0342, 0x0345 }, { 0x03B1, 0x0342, 0x03B9 }},\n#line 101 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\266\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0391, 0x0342,      0 }, { 0x1FB6,      0,      0 }, { 0x0391, 0x0342,      0 }, { 0x03B1, 0x0342,      0 }},\n#line 100 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\264\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0386, 0x0399,      0 }, { 0x1FB4,      0,      0 }, { 0x0386, 0x0345,      0 }, { 0x03AC, 0x03B9,      0 }},\n#line 99 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\263\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0391, 0x0399,      0 }, { 0x1FB3,      0,      0 }, { 0x1FBC,      0,      0 }, { 0x03B1, 0x03B9,      0 }},\n#line 98 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\262\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1FBA, 0x0399,      0 }, { 0x1FB2,      0,      0 }, { 0x1FBA, 0x0345,      0 }, { 0x1F70, 0x03B9,      0 }},\n#line 38 \"./unicase/special-casing-table.gperf\"\n      {\"\\003\\260\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x03A5, 0x0308, 0x0301 }, { 0x03B0,      0,      0 }, { 0x03A5, 0x0308, 0x0301 }, { 0x03C5, 0x0308, 0x0301 }},\n#line 97 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\257\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F6F, 0x0399,      0 }, { 0x1FA7,      0,      0 }, { 0x1FAF,      0,      0 }, { 0x1F67, 0x03B9,      0 }},\n#line 96 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\256\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F6E, 0x0399,      0 }, { 0x1FA6,      0,      0 }, { 0x1FAE,      0,      0 }, { 0x1F66, 0x03B9,      0 }},\n#line 95 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\255\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F6D, 0x0399,      0 }, { 0x1FA5,      0,      0 }, { 0x1FAD,      0,      0 }, { 0x1F65, 0x03B9,      0 }},\n#line 94 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\254\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F6C, 0x0399,      0 }, { 0x1FA4,      0,      0 }, { 0x1FAC,      0,      0 }, { 0x1F64, 0x03B9,      0 }},\n#line 93 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\253\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F6B, 0x0399,      0 }, { 0x1FA3,      0,      0 }, { 0x1FAB,      0,      0 }, { 0x1F63, 0x03B9,      0 }},\n#line 92 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\252\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F6A, 0x0399,      0 }, { 0x1FA2,      0,      0 }, { 0x1FAA,      0,      0 }, { 0x1F62, 0x03B9,      0 }},\n#line 91 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\251\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F69, 0x0399,      0 }, { 0x1FA1,      0,      0 }, { 0x1FA9,      0,      0 }, { 0x1F61, 0x03B9,      0 }},\n#line 90 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\250\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F68, 0x0399,      0 }, { 0x1FA0,      0,      0 }, { 0x1FA8,      0,      0 }, { 0x1F60, 0x03B9,      0 }},\n#line 89 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\247\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F6F, 0x0399,      0 }, { 0x1FA7,      0,      0 }, { 0x1FAF,      0,      0 }, { 0x1F67, 0x03B9,      0 }},\n#line 88 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\246\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F6E, 0x0399,      0 }, { 0x1FA6,      0,      0 }, { 0x1FAE,      0,      0 }, { 0x1F66, 0x03B9,      0 }},\n#line 87 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\245\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F6D, 0x0399,      0 }, { 0x1FA5,      0,      0 }, { 0x1FAD,      0,      0 }, { 0x1F65, 0x03B9,      0 }},\n#line 86 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\244\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F6C, 0x0399,      0 }, { 0x1FA4,      0,      0 }, { 0x1FAC,      0,      0 }, { 0x1F64, 0x03B9,      0 }},\n#line 84 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\242\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F6A, 0x0399,      0 }, { 0x1FA2,      0,      0 }, { 0x1FAA,      0,      0 }, { 0x1F62, 0x03B9,      0 }},\n#line 83 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\241\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F69, 0x0399,      0 }, { 0x1FA1,      0,      0 }, { 0x1FA9,      0,      0 }, { 0x1F61, 0x03B9,      0 }},\n#line 82 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\240\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F68, 0x0399,      0 }, { 0x1FA0,      0,      0 }, { 0x1FA8,      0,      0 }, { 0x1F60, 0x03B9,      0 }},\n#line 81 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\237\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F2F, 0x0399,      0 }, { 0x1F97,      0,      0 }, { 0x1F9F,      0,      0 }, { 0x1F27, 0x03B9,      0 }},\n#line 79 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\235\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F2D, 0x0399,      0 }, { 0x1F95,      0,      0 }, { 0x1F9D,      0,      0 }, { 0x1F25, 0x03B9,      0 }},\n#line 78 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\234\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F2C, 0x0399,      0 }, { 0x1F94,      0,      0 }, { 0x1F9C,      0,      0 }, { 0x1F24, 0x03B9,      0 }},\n#line 77 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\233\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F2B, 0x0399,      0 }, { 0x1F93,      0,      0 }, { 0x1F9B,      0,      0 }, { 0x1F23, 0x03B9,      0 }},\n#line 71 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\225\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F2D, 0x0399,      0 }, { 0x1F95,      0,      0 }, { 0x1F9D,      0,      0 }, { 0x1F25, 0x03B9,      0 }},\n#line 70 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\224\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F2C, 0x0399,      0 }, { 0x1F94,      0,      0 }, { 0x1F9C,      0,      0 }, { 0x1F24, 0x03B9,      0 }},\n#line 69 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\223\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F2B, 0x0399,      0 }, { 0x1F93,      0,      0 }, { 0x1F9B,      0,      0 }, { 0x1F23, 0x03B9,      0 }},\n#line 68 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\222\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F2A, 0x0399,      0 }, { 0x1F92,      0,      0 }, { 0x1F9A,      0,      0 }, { 0x1F22, 0x03B9,      0 }},\n#line 67 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\221\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F29, 0x0399,      0 }, { 0x1F91,      0,      0 }, { 0x1F99,      0,      0 }, { 0x1F21, 0x03B9,      0 }},\n#line 65 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\217\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F0F, 0x0399,      0 }, { 0x1F87,      0,      0 }, { 0x1F8F,      0,      0 }, { 0x1F07, 0x03B9,      0 }},\n#line 64 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\216\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F0E, 0x0399,      0 }, { 0x1F86,      0,      0 }, { 0x1F8E,      0,      0 }, { 0x1F06, 0x03B9,      0 }},\n#line 63 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\215\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F0D, 0x0399,      0 }, { 0x1F85,      0,      0 }, { 0x1F8D,      0,      0 }, { 0x1F05, 0x03B9,      0 }},\n#line 62 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\214\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F0C, 0x0399,      0 }, { 0x1F84,      0,      0 }, { 0x1F8C,      0,      0 }, { 0x1F04, 0x03B9,      0 }},\n#line 61 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\213\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F0B, 0x0399,      0 }, { 0x1F83,      0,      0 }, { 0x1F8B,      0,      0 }, { 0x1F03, 0x03B9,      0 }},\n#line 60 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\212\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F0A, 0x0399,      0 }, { 0x1F82,      0,      0 }, { 0x1F8A,      0,      0 }, { 0x1F02, 0x03B9,      0 }},\n#line 59 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\211\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F09, 0x0399,      0 }, { 0x1F81,      0,      0 }, { 0x1F89,      0,      0 }, { 0x1F01, 0x03B9,      0 }},\n#line 58 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\210\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F08, 0x0399,      0 }, { 0x1F80,      0,      0 }, { 0x1F88,      0,      0 }, { 0x1F00, 0x03B9,      0 }},\n#line 56 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\206\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F0E, 0x0399,      0 }, { 0x1F86,      0,      0 }, { 0x1F8E,      0,      0 }, { 0x1F06, 0x03B9,      0 }},\n#line 55 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\205\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F0D, 0x0399,      0 }, { 0x1F85,      0,      0 }, { 0x1F8D,      0,      0 }, { 0x1F05, 0x03B9,      0 }},\n#line 54 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\204\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F0C, 0x0399,      0 }, { 0x1F84,      0,      0 }, { 0x1F8C,      0,      0 }, { 0x1F04, 0x03B9,      0 }},\n#line 53 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\203\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F0B, 0x0399,      0 }, { 0x1F83,      0,      0 }, { 0x1F8B,      0,      0 }, { 0x1F03, 0x03B9,      0 }},\n#line 52 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\202\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F0A, 0x0399,      0 }, { 0x1F82,      0,      0 }, { 0x1F8A,      0,      0 }, { 0x1F02, 0x03B9,      0 }},\n#line 51 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\201\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F09, 0x0399,      0 }, { 0x1F81,      0,      0 }, { 0x1F89,      0,      0 }, { 0x1F01, 0x03B9,      0 }},\n#line 50 \"./unicase/special-casing-table.gperf\"\n      {\"\\037\\200\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x1F08, 0x0399,      0 }, { 0x1F80,      0,      0 }, { 0x1F88,      0,      0 }, { 0x1F00, 0x03B9,      0 }},\n#line 49 \"./unicase/special-casing-table.gperf\"\n      {\"\\037V\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x03A5, 0x0313, 0x0342 }, { 0x1F56,      0,      0 }, { 0x03A5, 0x0313, 0x0342 }, { 0x03C5, 0x0313, 0x0342 }},\n#line 48 \"./unicase/special-casing-table.gperf\"\n      {\"\\037T\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x03A5, 0x0313, 0x0301 }, { 0x1F54,      0,      0 }, { 0x03A5, 0x0313, 0x0301 }, { 0x03C5, 0x0313, 0x0301 }},\n#line 47 \"./unicase/special-casing-table.gperf\"\n      {\"\\037R\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x03A5, 0x0313, 0x0300 }, { 0x1F52,      0,      0 }, { 0x03A5, 0x0313, 0x0300 }, { 0x03C5, 0x0313, 0x0300 }},\n#line 46 \"./unicase/special-casing-table.gperf\"\n      {\"\\037P\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x03A5, 0x0313,      0 }, { 0x1F50,      0,      0 }, { 0x03A5, 0x0313,      0 }, { 0x03C5, 0x0313,      0 }},\n#line 20 \"./unicase/special-casing-table.gperf\"\n      {\"\\000J\\000\", 0,  SCC_MORE_ABOVE       , {  'l',  't' }, { 0x004A,      0,      0 }, { 0x006A, 0x0307,      0 }, { 0x004A,      0,      0 }, { 0x006A,      0,      0 }},\n#line 27 \"./unicase/special-casing-table.gperf\"\n      {\"\\001.\\000\", 0,  SCC_MORE_ABOVE       , {  'l',  't' }, { 0x012E,      0,      0 }, { 0x012F, 0x0307,      0 }, { 0x012E,      0,      0 }, { 0x012F,      0,      0 }},\n#line 26 \"./unicase/special-casing-table.gperf\"\n      {\"\\001(\\000\", 0,  SCC_ALWAYS           , {  'l',  't' }, { 0x0128,      0,      0 }, { 0x0069, 0x0307, 0x0303 }, { 0x0128,      0,      0 }, { 0x0129,      0,      0 }},\n#line 136 \"./unicase/special-casing-table.gperf\"\n      {\"\\373\\027\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0544, 0x053D,      0 }, { 0xFB17,      0,      0 }, { 0x0544, 0x056D,      0 }, { 0x0574, 0x056D,      0 }},\n#line 135 \"./unicase/special-casing-table.gperf\"\n      {\"\\373\\026\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x054E, 0x0546,      0 }, { 0xFB16,      0,      0 }, { 0x054E, 0x0576,      0 }, { 0x057E, 0x0576,      0 }},\n#line 134 \"./unicase/special-casing-table.gperf\"\n      {\"\\373\\025\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0544, 0x053B,      0 }, { 0xFB15,      0,      0 }, { 0x0544, 0x056B,      0 }, { 0x0574, 0x056B,      0 }},\n#line 133 \"./unicase/special-casing-table.gperf\"\n      {\"\\373\\024\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0544, 0x0535,      0 }, { 0xFB14,      0,      0 }, { 0x0544, 0x0565,      0 }, { 0x0574, 0x0565,      0 }},\n#line 132 \"./unicase/special-casing-table.gperf\"\n      {\"\\373\\023\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0544, 0x0546,      0 }, { 0xFB13,      0,      0 }, { 0x0544, 0x0576,      0 }, { 0x0574, 0x0576,      0 }},\n#line 131 \"./unicase/special-casing-table.gperf\"\n      {\"\\373\\006\\000\", 0,  SCC_ALWAYS           , { '\\0', '\\0' }, { 0x0053, 0x0054,      0 }, { 0xFB06,      0,      0 }, { 0x0053, 0x0074,      0 }, { 0x0073, 0x0074,      0 }}\n    };\n\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register unsigned int key = gl_unicase_special_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE)\n        if (len == lengthtable[key])\n          {\n            register const char *s = wordlist[key].code;\n\n            if (*str == *s && !memcmp (str + 1, s + 1, len - 1))\n              return &wordlist[key];\n          }\n    }\n  return 0;\n}",
      "lines": 278,
      "depth": 15,
      "decorators": [
        "const",
        "const",
        "struct special_casing_rule",
        "struct",
        "special_casing_rule",
        "*\ngl_unicase_special_lookup (register const char *str, register size_t len)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/special-casing.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/special-casing.in.h": {},
  "libunistring/libunistring-0.9.10/lib/unicase/tocasefold.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/tocasefold.h": {},
  "libunistring/libunistring-0.9.10/lib/unicase/tolower.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/tolower.h": {},
  "libunistring/libunistring-0.9.10/lib/unicase/totitle.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/totitle.h": {},
  "libunistring/libunistring-0.9.10/lib/unicase/toupper.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/toupper.h": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u-casecmp.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nFUNC (const SRC_UNIT *s1, size_t n1, const SRC_UNIT *s2, size_t n2,\n      const char *iso639_language, uninorm_t nf, int *resultp)\n{\n  UNIT buf1[2048 / sizeof (UNIT)];\n  UNIT buf2[2048 / sizeof (UNIT)];\n  UNIT *norms1;\n  size_t norms1_length;\n  UNIT *norms2;\n  size_t norms2_length;\n  int cmp;\n\n  /* Optimization: There is no need to do canonical composition of each string.\n     Decomposition is enough.  */\n  if (nf != NULL)\n    nf = uninorm_decomposing_form (nf);\n\n  /* Case-fold and normalize S1.  */\n  norms1_length = sizeof (buf1) / sizeof (UNIT);\n  norms1 = U_CASEFOLD (s1, n1, iso639_language, nf, buf1, &norms1_length);\n  if (norms1 == NULL)\n    /* errno is set here.  */\n    return -1;\n\n  /* Case-fold and normalize S2.  */\n  norms2_length = sizeof (buf2) / sizeof (UNIT);\n  norms2 = U_CASEFOLD (s2, n2, iso639_language, nf, buf2, &norms2_length);\n  if (norms2 == NULL)\n    {\n      if (norms1 != buf1)\n        {\n          int saved_errno = errno;\n          free (norms1);\n          errno = saved_errno;\n        }\n      return -1;\n    }\n\n  /* Compare the normalized strings.  */\n  cmp = U_CMP2 (norms1, norms1_length, norms2, norms2_length);\n  if (cmp > 0)\n    cmp = 1;\n  else if (cmp < 0)\n    cmp = -1;\n\n  if (norms2 != buf2)\n    free (norms2);\n  if (norms1 != buf1)\n    free (norms1);\n  *resultp = cmp;\n  return 0;\n}",
      "lines": 52,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u-casecoll.h": {
    "FUNC": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "int\nFUNC (const UNIT *s1, size_t n1, const UNIT *s2, size_t n2,\n      const char *iso639_language, uninorm_t nf, int *resultp)\n{\n  char buf1[2048];\n  char buf2[2048];\n  char *transformed1;\n  size_t transformed1_length;\n  char *transformed2;\n  size_t transformed2_length;\n  int cmp;\n\n  /* Normalize and transform S1.  */\n  transformed1_length = sizeof (buf1);\n  transformed1 =\n    U_CASEXFRM (s1, n1, iso639_language, nf, buf1, &transformed1_length);\n  if (transformed1 == NULL)\n    /* errno is set here.  */\n    return -1;\n\n  /* Normalize and transform S2.  */\n  transformed2_length = sizeof (buf2);\n  transformed2 =\n    U_CASEXFRM (s2, n2, iso639_language, nf, buf2, &transformed2_length);\n  if (transformed2 == NULL)\n    {\n      if (transformed1 != buf1)\n        {\n          int saved_errno = errno;\n          free (transformed1);\n          errno = saved_errno;\n        }\n      return -1;\n    }\n\n  /* Compare the transformed strings.  */\n  cmp = memcmp2 (transformed1, transformed1_length,\n                 transformed2, transformed2_length);\n  if (cmp < 0)\n    cmp = -1;\n  else if (cmp > 0)\n    cmp = 1;\n\n  if (transformed2 != buf2)\n    free (transformed2);\n  if (transformed1 != buf1)\n    free (transformed1);\n  *resultp = cmp;\n  return 0;\n}",
      "lines": 50,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u-casefold.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "UNIT *\nFUNC (const UNIT *s, size_t n, const char *iso639_language,\n      uninorm_t nf,\n      UNIT *resultbuf, size_t *lengthp)\n{\n  return U_CT_CASEFOLD (s, n,\n                        unicase_empty_prefix_context, unicase_empty_suffix_context,\n                        iso639_language,\n                        nf,\n                        resultbuf, lengthp);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "UNIT",
        "*\nFUNC (const UNIT *s, size_t n, const char *iso639_language,\n      uninorm_t nf,\n      UNIT *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u-casemap.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        424,
        1
      ],
      "content": "UNIT *\nFUNC (const UNIT *s, size_t n,\n      casing_prefix_context_t prefix_context,\n      casing_suffix_context_t suffix_context,\n      const char *iso639_language,\n      ucs4_t (*single_character_map) (ucs4_t),\n      size_t offset_in_rule, /* offset in 'struct special_casing_rule' */\n      uninorm_t nf,\n      UNIT *resultbuf, size_t *lengthp)\n{\n  /* The result being accumulated.  */\n  UNIT *result;\n  size_t length;\n  size_t allocated;\n\n  /* Initialize the accumulator.  */\n  if (nf != NULL || resultbuf == NULL)\n    {\n      result = NULL;\n      allocated = 0;\n    }\n  else\n    {\n      result = resultbuf;\n      allocated = *lengthp;\n    }\n  length = 0;\n\n  {\n    const UNIT *s_end = s + n;\n\n    /* Helper for evaluating the FINAL_SIGMA condition:\n       Last character that was not case-ignorable.  */\n    ucs4_t last_char_except_ignorable =\n      prefix_context.last_char_except_ignorable;\n\n    /* Helper for evaluating the AFTER_SOFT_DOTTED and AFTER_I conditions:\n       Last character that was of combining class 230 (\"Above\") or 0.  */\n    ucs4_t last_char_normal_or_above =\n      prefix_context.last_char_normal_or_above;\n\n    while (s < s_end)\n      {\n        ucs4_t uc;\n        int count = U_MBTOUC_UNSAFE (&uc, s, s_end - s);\n\n        ucs4_t mapped_uc[3];\n        unsigned int mapped_count;\n\n        if (uc < 0x10000)\n          {\n            /* Look first in the special-casing table.  */\n            char code[3];\n\n            code[0] = (uc >> 8) & 0xff;\n            code[1] = uc & 0xff;\n\n            for (code[2] = 0; ; code[2]++)\n              {\n                const struct special_casing_rule *rule =\n                  gl_unicase_special_lookup (code, 3);\n\n                if (rule == NULL)\n                  break;\n\n                /* Test if the condition applies.  */\n                /* Does the language apply?  */\n                if (rule->language[0] == '\\0'\n                    || (iso639_language != NULL\n                        && iso639_language[0] == rule->language[0]\n                        && iso639_language[1] == rule->language[1]))\n                  {\n                    /* Does the context apply?  */\n                    int context = rule->context;\n                    bool applies;\n\n                    if (context < 0)\n                      context = - context;\n                    switch (context)\n                      {\n                      case SCC_ALWAYS:\n                        applies = true;\n                        break;\n\n                      case SCC_FINAL_SIGMA:\n                        /* \"Before\" condition: preceded by a sequence\n                           consisting of a cased letter and a case-ignorable\n                           sequence.\n                           \"After\" condition: not followed by a sequence\n                           consisting of a case-ignorable sequence and then a\n                           cased letter.  */\n                        /* Test the \"before\" condition.  */\n                        applies = uc_is_cased (last_char_except_ignorable);\n                        /* Test the \"after\" condition.  */\n                        if (applies)\n                          {\n                            const UNIT *s2 = s + count;\n                            for (;;)\n                              {\n                                if (s2 < s_end)\n                                  {\n                                    ucs4_t uc2;\n                                    int count2 = U_MBTOUC_UNSAFE (&uc2, s2, s_end - s2);\n                                    /* Our uc_is_case_ignorable function is\n                                       known to return false for all cased\n                                       characters.  So we can call\n                                       uc_is_case_ignorable first.  */\n                                    if (!uc_is_case_ignorable (uc2))\n                                      {\n                                        applies = ! uc_is_cased (uc2);\n                                        break;\n                                      }\n                                    s2 += count2;\n                                  }\n                                else\n                                  {\n                                    applies = ! uc_is_cased (suffix_context.first_char_except_ignorable);\n                                    break;\n                                  }\n                              }\n                          }\n                        break;\n\n                      case SCC_AFTER_SOFT_DOTTED:\n                        /* \"Before\" condition: There is a Soft_Dotted character\n                           before it, with no intervening character of\n                           combining class 0 or 230 (Above).  */\n                        /* Test the \"before\" condition.  */\n                        applies = uc_is_property_soft_dotted (last_char_normal_or_above);\n                        break;\n\n                      case SCC_MORE_ABOVE:\n                        /* \"After\" condition: followed by a character of\n                           combining class 230 (Above) with no intervening\n                           character of combining class 0 or 230 (Above).  */\n                        /* Test the \"after\" condition.  */\n                        {\n                          const UNIT *s2 = s + count;\n                          applies = false;\n                          for (;;)\n                            {\n                              if (s2 < s_end)\n                                {\n                                  ucs4_t uc2;\n                                  int count2 = U_MBTOUC_UNSAFE (&uc2, s2, s_end - s2);\n                                  int ccc = uc_combining_class (uc2);\n                                  if (ccc == UC_CCC_A)\n                                    {\n                                      applies = true;\n                                      break;\n                                    }\n                                  if (ccc == UC_CCC_NR)\n                                    break;\n                                  s2 += count2;\n                                }\n                              else\n                                {\n                                  applies = ((suffix_context.bits & SCC_MORE_ABOVE_MASK) != 0);\n                                  break;\n                                }\n                            }\n                        }\n                        break;\n\n                      case SCC_BEFORE_DOT:\n                        /* \"After\" condition: followed by COMBINING DOT ABOVE\n                           (U+0307). Any sequence of characters with a\n                           combining class that is neither 0 nor 230 may\n                           intervene between the current character and the\n                           combining dot above.  */\n                        /* Test the \"after\" condition.  */\n                        {\n                          const UNIT *s2 = s + count;\n                          applies = false;\n                          for (;;)\n                            {\n                              if (s2 < s_end)\n                                {\n                                  ucs4_t uc2;\n                                  int count2 = U_MBTOUC_UNSAFE (&uc2, s2, s_end - s2);\n                                  if (uc2 == 0x0307) /* COMBINING DOT ABOVE */\n                                    {\n                                      applies = true;\n                                      break;\n                                    }\n                                  {\n                                    int ccc = uc_combining_class (uc2);\n                                    if (ccc == UC_CCC_A || ccc == UC_CCC_NR)\n                                      break;\n                                  }\n                                  s2 += count2;\n                                }\n                              else\n                                {\n                                  applies = ((suffix_context.bits & SCC_BEFORE_DOT_MASK) != 0);\n                                  break;\n                                }\n                            }\n                        }\n                        break;\n\n                      case SCC_AFTER_I:\n                        /* \"Before\" condition: There is an uppercase I before\n                           it, and there is no intervening character of\n                           combining class 0 or 230 (Above).  */\n                        /* Test the \"before\" condition.  */\n                        applies = (last_char_normal_or_above == 'I');\n                        break;\n\n                      default:\n                        abort ();\n                      }\n                    if (rule->context < 0)\n                      applies = !applies;\n\n                    if (applies)\n                      {\n                        /* The rule applies.\n                           Look up the mapping (0 to 3 characters).  */\n                        const unsigned short *mapped_in_rule =\n                          (const unsigned short *)((const char *)rule + offset_in_rule);\n\n                        if (mapped_in_rule[0] == 0)\n                          mapped_count = 0;\n                        else\n                          {\n                            mapped_uc[0] = mapped_in_rule[0];\n                            if (mapped_in_rule[1] == 0)\n                              mapped_count = 1;\n                            else\n                              {\n                                mapped_uc[1] = mapped_in_rule[1];\n                                if (mapped_in_rule[2] == 0)\n                                  mapped_count = 2;\n                                else\n                                  {\n                                    mapped_uc[2] = mapped_in_rule[2];\n                                    mapped_count = 3;\n                                  }\n                              }\n                          }\n                        goto found_mapping;\n                      }\n                  }\n\n                /* Optimization: Save a hash table lookup in the next round.  */\n                if (!rule->has_next)\n                  break;\n              }\n          }\n\n        /* No special-cased mapping.  So use the locale and context independent\n           mapping.  */\n        mapped_uc[0] = single_character_map (uc);\n        mapped_count = 1;\n\n       found_mapping:\n        /* Found the mapping: uc maps to mapped_uc[0..mapped_count-1].  */\n        {\n          unsigned int i;\n\n          for (i = 0; i < mapped_count; i++)\n            {\n              ucs4_t muc = mapped_uc[i];\n\n              /* Append muc to the result accumulator.  */\n              if (length < allocated)\n                {\n                  int ret = U_UCTOMB (result + length, muc, allocated - length);\n                  if (ret == -1)\n                    {\n                      errno = EINVAL;\n                      goto fail;\n                    }\n                  if (ret >= 0)\n                    {\n                      length += ret;\n                      goto done_appending;\n                    }\n                }\n              {\n                size_t old_allocated = allocated;\n                size_t new_allocated = 2 * old_allocated;\n                if (new_allocated < 64)\n                  new_allocated = 64;\n                if (new_allocated < old_allocated) /* integer overflow? */\n                  abort ();\n                {\n                  UNIT *larger_result;\n                  if (result == NULL)\n                    {\n                      larger_result = (UNIT *) malloc (new_allocated * sizeof (UNIT));\n                      if (larger_result == NULL)\n                        {\n                          errno = ENOMEM;\n                          goto fail;\n                        }\n                    }\n                  else if (result == resultbuf)\n                    {\n                      larger_result = (UNIT *) malloc (new_allocated * sizeof (UNIT));\n                      if (larger_result == NULL)\n                        {\n                          errno = ENOMEM;\n                          goto fail;\n                        }\n                      U_CPY (larger_result, resultbuf, length);\n                    }\n                  else\n                    {\n                      larger_result =\n                        (UNIT *) realloc (result, new_allocated * sizeof (UNIT));\n                      if (larger_result == NULL)\n                        {\n                          errno = ENOMEM;\n                          goto fail;\n                        }\n                    }\n                  result = larger_result;\n                  allocated = new_allocated;\n                  {\n                    int ret = U_UCTOMB (result + length, muc, allocated - length);\n                    if (ret == -1)\n                      {\n                        errno = EINVAL;\n                        goto fail;\n                      }\n                    if (ret < 0)\n                      abort ();\n                    length += ret;\n                    goto done_appending;\n                  }\n                }\n              }\n             done_appending: ;\n            }\n        }\n\n        if (!uc_is_case_ignorable (uc))\n          last_char_except_ignorable = uc;\n\n        {\n          int ccc = uc_combining_class (uc);\n          if (ccc == UC_CCC_A || ccc == UC_CCC_NR)\n            last_char_normal_or_above = uc;\n        }\n\n        s += count;\n      }\n  }\n\n  if (nf != NULL)\n    {\n      /* Finally, normalize the result.  */\n      UNIT *normalized_result;\n\n      normalized_result = U_NORMALIZE (nf, result, length, resultbuf, lengthp);\n      if (normalized_result == NULL)\n        goto fail;\n\n      free (result);\n      return normalized_result;\n    }\n\n  if (length == 0)\n    {\n      if (result == NULL)\n        {\n          /* Return a non-NULL value.  NULL means error.  */\n          result = (UNIT *) malloc (1);\n          if (result == NULL)\n            {\n              errno = ENOMEM;\n              goto fail;\n            }\n        }\n    }\n  else if (result != resultbuf && length < allocated)\n    {\n      /* Shrink the allocated memory if possible.  */\n      UNIT *memory;\n\n      memory = (UNIT *) realloc (result, length * sizeof (UNIT));\n      if (memory != NULL)\n        result = memory;\n    }\n\n  *lengthp = length;\n  return result;\n\n fail:\n  if (result != resultbuf)\n    {\n      int saved_errno = errno;\n      free (result);\n      errno = saved_errno;\n    }\n  return NULL;\n}",
      "lines": 399,
      "depth": 28,
      "decorators": [
        "UNIT",
        "*\nFUNC (const UNIT *s, size_t n,\n      casing_prefix_context_t prefix_context,\n      casing_suffix_context_t suffix_context,\n      const char *iso639_language,\n      ucs4_t (*single_character_map) (ucs4_t),\n      size_t offset_in_rule, /* offset in 'struct special_casing_rule' */\n      uninorm_t nf,\n      UNIT *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u-casexfrm.h": {
    "FUNC": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "char *\nFUNC (const UNIT *s, size_t n, const char *iso639_language, uninorm_t nf,\n      char *resultbuf, size_t *lengthp)\n{\n  UNIT foldedsbuf[2048 / sizeof (UNIT)];\n  UNIT *foldeds;\n  size_t foldeds_length;\n  char convsbuf[2048];\n  char *convs;\n  size_t convs_length;\n  char *result;\n\n  /* Casefold and normalize the Unicode string.  */\n  foldeds_length = sizeof (foldedsbuf) / sizeof (UNIT);\n  foldeds = U_CASEFOLD (s, n, iso639_language, nf, foldedsbuf, &foldeds_length);\n  if (foldeds == NULL)\n    /* errno is set here.  */\n    return NULL;\n\n  /* Convert it to locale encoding.  */\n  convs_length = sizeof (convsbuf) - 1;\n  convs = U_CONV_TO_ENCODING (locale_charset (),\n                              iconveh_error,\n                              foldeds, foldeds_length,\n                              NULL,\n                              convsbuf, &convs_length);\n  if (convs == NULL)\n    {\n      if (foldeds != foldedsbuf)\n        {\n          int saved_errno = errno;\n          free (foldeds);\n          errno = saved_errno;\n        }\n      return NULL;\n    }\n\n  if (foldeds != foldedsbuf)\n    free (foldeds);\n\n  /* Ensure one more byte is available.  */\n  if (convs != convsbuf)\n    {\n      char *memory = (char *) realloc (convs, convs_length + 1);\n      if (memory == NULL)\n        {\n          free (convs);\n          errno = ENOMEM;\n          return NULL;\n        }\n      convs = memory;\n    }\n\n  /* Apply locale dependent transformations for comparison.  */\n  result = amemxfrm (convs, convs_length, resultbuf, lengthp);\n  if (result == NULL)\n    {\n      if (convs != convsbuf)\n        {\n          int saved_errno = errno;\n          free (convs);\n          errno = saved_errno;\n        }\n      return NULL;\n    }\n\n  if (convs != convsbuf)\n    free (convs);\n  return result;\n}",
      "lines": 70,
      "depth": 11,
      "decorators": [
        "char",
        "*\nFUNC (const UNIT *s, size_t n, const char *iso639_language, uninorm_t nf,\n      char *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u-ct-casefold.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "UNIT *\nFUNC (const UNIT *s, size_t n,\n      casing_prefix_context_t prefix_context,\n      casing_suffix_context_t suffix_context,\n      const char *iso639_language,\n      uninorm_t nf,\n      UNIT *resultbuf, size_t *lengthp)\n{\n  /* Implement the three definitions of caseless matching, as described in\n     Unicode 5.0, section \"Default caseless matching\":\n       - If no normalization is requested, simply apply the casefolding.\n           X -> toCasefold(X).\n       - If canonical normalization is requested, apply it, and apply an NFD\n         before.\n           X -> NFD(toCasefold(NFD(X))).\n       - If compatibility normalization is requested, apply it twice, apply\n         the normalization after each, and apply an NFD before:\n           X -> NFKD(toCasefold(NFKD(toCasefold(NFD(X))))).  */\n  if (nf == NULL)\n    /* X -> toCasefold(X) */\n    return U_CASEMAP (s, n, prefix_context, suffix_context, iso639_language,\n                      uc_tocasefold, offsetof (struct special_casing_rule, casefold[0]),\n                      NULL,\n                      resultbuf, lengthp);\n  else\n    {\n      uninorm_t nfd = uninorm_decomposing_form (nf);\n      /* X -> nf(toCasefold(NFD(X))) or\n         X -> nf(toCasefold(nfd(toCasefold(NFD(X)))))  */\n      int repeat = (uninorm_is_compat_decomposing (nf) ? 2 : 1);\n      UNIT tmpbuf1[2048 / sizeof (UNIT)];\n      UNIT tmpbuf2[2048 / sizeof (UNIT)];\n      UNIT *tmp1;\n      size_t tmp1_length;\n      UNIT *tmp2;\n      size_t tmp2_length;\n\n      tmp1_length = sizeof (tmpbuf1) / sizeof (UNIT);\n      tmp1 = U_NORMALIZE (UNINORM_NFD, s, n, tmpbuf1, &tmp1_length);\n      if (tmp1 == NULL)\n        /* errno is set here.  */\n        return NULL;\n\n      do\n        {\n          tmp2_length = sizeof (tmpbuf2) / sizeof (UNIT);\n          tmp2 = U_CASEMAP (tmp1, tmp1_length,\n                            prefix_context, suffix_context, iso639_language,\n                            uc_tocasefold, offsetof (struct special_casing_rule, casefold[0]),\n                            NULL,\n                            tmpbuf2, &tmp2_length);\n          if (tmp2 == NULL)\n            {\n              int saved_errno = errno;\n              if (tmp1 != tmpbuf1)\n                free (tmp1);\n              errno = saved_errno;\n              return NULL;\n            }\n\n          if (tmp1 != tmpbuf1)\n            free (tmp1);\n\n          if (repeat > 1)\n            {\n              tmp1_length = sizeof (tmpbuf1) / sizeof (UNIT);\n              tmp1 = U_NORMALIZE (nfd, tmp2, tmp2_length,\n                                  tmpbuf1, &tmp1_length);\n            }\n          else\n            /* Last run through this loop.  */\n            tmp1 = U_NORMALIZE (nf, tmp2, tmp2_length,\n                                resultbuf, lengthp);\n          if (tmp1 == NULL)\n            {\n              int saved_errno = errno;\n              if (tmp2 != tmpbuf2)\n                free (tmp2);\n              errno = saved_errno;\n              return NULL;\n            }\n\n          if (tmp2 != tmpbuf2)\n            free (tmp2);\n        }\n      while (--repeat > 0);\n\n      return tmp1;\n    }\n}",
      "lines": 90,
      "depth": 14,
      "decorators": [
        "UNIT",
        "*\nFUNC (const UNIT *s, size_t n,\n      casing_prefix_context_t prefix_context,\n      casing_suffix_context_t suffix_context,\n      const char *iso639_language,\n      uninorm_t nf,\n      UNIT *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u-ct-totitle.h": {
    "FUNC": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        509,
        1
      ],
      "content": "UNIT *\nFUNC (const UNIT *s, size_t n,\n      casing_prefix_context_t prefix_context,\n      casing_suffix_context_t suffix_context,\n      const char *iso639_language,\n      uninorm_t nf,\n      UNIT *resultbuf, size_t *lengthp)\n{\n  /* The result being accumulated.  */\n  UNIT *result;\n  size_t length;\n  size_t allocated;\n  /* An array containing the word break positions.  */\n  char *wordbreaks;\n\n  /* Initialize the accumulator.  */\n  if (nf != NULL || resultbuf == NULL)\n    {\n      result = NULL;\n      allocated = 0;\n    }\n  else\n    {\n      result = resultbuf;\n      allocated = *lengthp;\n    }\n  length = 0;\n\n  /* Initialize the word breaks array.  */\n  if (n > 0)\n    {\n      wordbreaks = (char *) malloc (n);\n      if (wordbreaks == NULL)\n        {\n          errno = ENOMEM;\n          goto fail2;\n        }\n      U_WORDBREAKS (s, n, wordbreaks);\n    }\n  else\n    wordbreaks = NULL;\n\n  {\n    const UNIT *s_end = s + n;\n    const char *wp = wordbreaks;\n\n    /* When considering the string as segmented by word boundaries: For each\n       such segment:\n        - In the first part, we are searching for the first cased character.\n          In this state, in_word_first_part = true, and no conversion takes\n          place.\n        - In the second part, we are converting every character: the first\n          among these characters to title case, the other ones to lower case.\n          In this state, in_word_first_part = false.  */\n    bool in_word_first_part = true;\n\n    /* Helper for evaluating the FINAL_SIGMA condition:\n       Last character that was not case-ignorable.  */\n    ucs4_t last_char_except_ignorable =\n      prefix_context.last_char_except_ignorable;\n\n    /* Helper for evaluating the AFTER_SOFT_DOTTED and AFTER_I conditions:\n       Last character that was of combining class 230 (\"Above\") or 0.  */\n    ucs4_t last_char_normal_or_above =\n      prefix_context.last_char_normal_or_above;\n\n    while (s < s_end)\n      {\n        /* Fetch the next character.  */\n        ucs4_t uc;\n        int count = U_MBTOUC_UNSAFE (&uc, s, s_end - s);\n\n        ucs4_t (*single_character_map) (ucs4_t);\n        size_t offset_in_rule; /* offset in 'struct special_casing_rule' */\n\n        ucs4_t mapped_uc[3];\n        unsigned int mapped_count;\n\n        if (*wp)\n          /* Crossing a word boundary.  */\n          in_word_first_part = true;\n\n        /* Determine single_character_map, offset_in_rule.\n           There are three possibilities:\n             - uc should not be converted.\n             - uc should be titlecased.\n             - uc should be lowercased.  */\n        if (in_word_first_part)\n          {\n            if (uc_is_cased (uc))\n              {\n                /* uc is to be titlecased.  */\n                single_character_map = uc_totitle;\n                offset_in_rule = offsetof (struct special_casing_rule, title[0]);\n                in_word_first_part = false;\n              }\n            else\n              {\n                /* uc is not converted.  */\n                single_character_map = NULL;\n                offset_in_rule = 0;\n              }\n          }\n        else\n          {\n            /* uc is to be lowercased.  */\n            single_character_map = uc_tolower;\n            offset_in_rule = offsetof (struct special_casing_rule, lower[0]);\n          }\n\n        /* Actually map uc.  */\n        if (single_character_map == NULL)\n          {\n            mapped_uc[0] = uc;\n            mapped_count = 1;\n            goto found_mapping;\n          }\n\n        if (uc < 0x10000)\n          {\n            /* Look first in the special-casing table.  */\n            char code[3];\n\n            code[0] = (uc >> 8) & 0xff;\n            code[1] = uc & 0xff;\n\n            for (code[2] = 0; ; code[2]++)\n              {\n                const struct special_casing_rule *rule =\n                  gl_unicase_special_lookup (code, 3);\n\n                if (rule == NULL)\n                  break;\n\n                /* Test if the condition applies.  */\n                /* Does the language apply?  */\n                if (rule->language[0] == '\\0'\n                    || (iso639_language != NULL\n                        && iso639_language[0] == rule->language[0]\n                        && iso639_language[1] == rule->language[1]))\n                  {\n                    /* Does the context apply?  */\n                    int context = rule->context;\n                    bool applies;\n\n                    if (context < 0)\n                      context = - context;\n                    switch (context)\n                      {\n                      case SCC_ALWAYS:\n                        applies = true;\n                        break;\n\n                      case SCC_FINAL_SIGMA:\n                        /* \"Before\" condition: preceded by a sequence\n                           consisting of a cased letter and a case-ignorable\n                           sequence.\n                           \"After\" condition: not followed by a sequence\n                           consisting of a case-ignorable sequence and then a\n                           cased letter.  */\n                        /* Test the \"before\" condition.  */\n                        applies = uc_is_cased (last_char_except_ignorable);\n                        /* Test the \"after\" condition.  */\n                        if (applies)\n                          {\n                            const UNIT *s2 = s + count;\n                            for (;;)\n                              {\n                                if (s2 < s_end)\n                                  {\n                                    ucs4_t uc2;\n                                    int count2 = U_MBTOUC_UNSAFE (&uc2, s2, s_end - s2);\n                                    /* Our uc_is_case_ignorable function is\n                                       known to return false for all cased\n                                       characters.  So we can call\n                                       uc_is_case_ignorable first.  */\n                                    if (!uc_is_case_ignorable (uc2))\n                                      {\n                                        applies = ! uc_is_cased (uc2);\n                                        break;\n                                      }\n                                    s2 += count2;\n                                  }\n                                else\n                                  {\n                                    applies = ! uc_is_cased (suffix_context.first_char_except_ignorable);\n                                    break;\n                                  }\n                              }\n                          }\n                        break;\n\n                      case SCC_AFTER_SOFT_DOTTED:\n                        /* \"Before\" condition: There is a Soft_Dotted character\n                           before it, with no intervening character of\n                           combining class 0 or 230 (Above).  */\n                        /* Test the \"before\" condition.  */\n                        applies = uc_is_property_soft_dotted (last_char_normal_or_above);\n                        break;\n\n                      case SCC_MORE_ABOVE:\n                        /* \"After\" condition: followed by a character of\n                           combining class 230 (Above) with no intervening\n                           character of combining class 0 or 230 (Above).  */\n                        /* Test the \"after\" condition.  */\n                        {\n                          const UNIT *s2 = s + count;\n                          applies = false;\n                          for (;;)\n                            {\n                              if (s2 < s_end)\n                                {\n                                  ucs4_t uc2;\n                                  int count2 = U_MBTOUC_UNSAFE (&uc2, s2, s_end - s2);\n                                  int ccc = uc_combining_class (uc2);\n                                  if (ccc == UC_CCC_A)\n                                    {\n                                      applies = true;\n                                      break;\n                                    }\n                                  if (ccc == UC_CCC_NR)\n                                    break;\n                                  s2 += count2;\n                                }\n                              else\n                                {\n                                  applies = ((suffix_context.bits & SCC_MORE_ABOVE_MASK) != 0);\n                                  break;\n                                }\n                            }\n                        }\n                        break;\n\n                      case SCC_BEFORE_DOT:\n                        /* \"After\" condition: followed by COMBINING DOT ABOVE\n                           (U+0307). Any sequence of characters with a\n                           combining class that is neither 0 nor 230 may\n                           intervene between the current character and the\n                           combining dot above.  */\n                        /* Test the \"after\" condition.  */\n                        {\n                          const UNIT *s2 = s + count;\n                          applies = false;\n                          for (;;)\n                            {\n                              if (s2 < s_end)\n                                {\n                                  ucs4_t uc2;\n                                  int count2 = U_MBTOUC_UNSAFE (&uc2, s2, s_end - s2);\n                                  if (uc2 == 0x0307) /* COMBINING DOT ABOVE */\n                                    {\n                                      applies = true;\n                                      break;\n                                    }\n                                  {\n                                    int ccc = uc_combining_class (uc2);\n                                    if (ccc == UC_CCC_A || ccc == UC_CCC_NR)\n                                      break;\n                                  }\n                                  s2 += count2;\n                                }\n                              else\n                                {\n                                  applies = ((suffix_context.bits & SCC_BEFORE_DOT_MASK) != 0);\n                                  break;\n                                }\n                            }\n                        }\n                        break;\n\n                      case SCC_AFTER_I:\n                        /* \"Before\" condition: There is an uppercase I before\n                           it, and there is no intervening character of\n                           combining class 0 or 230 (Above).  */\n                        /* Test the \"before\" condition.  */\n                        applies = (last_char_normal_or_above == 'I');\n                        break;\n\n                      default:\n                        abort ();\n                      }\n                    if (rule->context < 0)\n                      applies = !applies;\n\n                    if (applies)\n                      {\n                        /* The rule applies.\n                           Look up the mapping (0 to 3 characters).  */\n                        const unsigned short *mapped_in_rule =\n                          (const unsigned short *)((const char *)rule + offset_in_rule);\n\n                        if (mapped_in_rule[0] == 0)\n                          mapped_count = 0;\n                        else\n                          {\n                            mapped_uc[0] = mapped_in_rule[0];\n                            if (mapped_in_rule[1] == 0)\n                              mapped_count = 1;\n                            else\n                              {\n                                mapped_uc[1] = mapped_in_rule[1];\n                                if (mapped_in_rule[2] == 0)\n                                  mapped_count = 2;\n                                else\n                                  {\n                                    mapped_uc[2] = mapped_in_rule[2];\n                                    mapped_count = 3;\n                                  }\n                              }\n                          }\n                        goto found_mapping;\n                      }\n                  }\n\n                /* Optimization: Save a hash table lookup in the next round.  */\n                if (!rule->has_next)\n                  break;\n              }\n          }\n\n        /* No special-cased mapping.  So use the locale and context independent\n           mapping.  */\n        mapped_uc[0] = single_character_map (uc);\n        mapped_count = 1;\n\n       found_mapping:\n        /* Found the mapping: uc maps to mapped_uc[0..mapped_count-1].  */\n        {\n          unsigned int i;\n\n          for (i = 0; i < mapped_count; i++)\n            {\n              ucs4_t muc = mapped_uc[i];\n\n              /* Append muc to the result accumulator.  */\n              if (length < allocated)\n                {\n                  int ret = U_UCTOMB (result + length, muc, allocated - length);\n                  if (ret == -1)\n                    {\n                      errno = EINVAL;\n                      goto fail1;\n                    }\n                  if (ret >= 0)\n                    {\n                      length += ret;\n                      goto done_appending;\n                    }\n                }\n              {\n                size_t old_allocated = allocated;\n                size_t new_allocated = 2 * old_allocated;\n                if (new_allocated < 64)\n                  new_allocated = 64;\n                if (new_allocated < old_allocated) /* integer overflow? */\n                  abort ();\n                {\n                  UNIT *larger_result;\n                  if (result == NULL)\n                    {\n                      larger_result = (UNIT *) malloc (new_allocated * sizeof (UNIT));\n                      if (larger_result == NULL)\n                        {\n                          errno = ENOMEM;\n                          goto fail1;\n                        }\n                    }\n                  else if (result == resultbuf)\n                    {\n                      larger_result = (UNIT *) malloc (new_allocated * sizeof (UNIT));\n                      if (larger_result == NULL)\n                        {\n                          errno = ENOMEM;\n                          goto fail1;\n                        }\n                      U_CPY (larger_result, resultbuf, length);\n                    }\n                  else\n                    {\n                      larger_result =\n                        (UNIT *) realloc (result, new_allocated * sizeof (UNIT));\n                      if (larger_result == NULL)\n                        {\n                          errno = ENOMEM;\n                          goto fail1;\n                        }\n                    }\n                  result = larger_result;\n                  allocated = new_allocated;\n                  {\n                    int ret = U_UCTOMB (result + length, muc, allocated - length);\n                    if (ret == -1)\n                      {\n                        errno = EINVAL;\n                        goto fail1;\n                      }\n                    if (ret < 0)\n                      abort ();\n                    length += ret;\n                    goto done_appending;\n                  }\n                }\n              }\n             done_appending: ;\n            }\n        }\n\n        if (!uc_is_case_ignorable (uc))\n          last_char_except_ignorable = uc;\n\n        {\n          int ccc = uc_combining_class (uc);\n          if (ccc == UC_CCC_A || ccc == UC_CCC_NR)\n            last_char_normal_or_above = uc;\n        }\n\n        s += count;\n        wp += count;\n      }\n  }\n\n  free (wordbreaks);\n\n  if (nf != NULL)\n    {\n      /* Finally, normalize the result.  */\n      UNIT *normalized_result;\n\n      normalized_result = U_NORMALIZE (nf, result, length, resultbuf, lengthp);\n      if (normalized_result == NULL)\n        goto fail2;\n\n      free (result);\n      return normalized_result;\n    }\n\n  if (length == 0)\n    {\n      if (result == NULL)\n        {\n          /* Return a non-NULL value.  NULL means error.  */\n          result = (UNIT *) malloc (1);\n          if (result == NULL)\n            {\n              errno = ENOMEM;\n              goto fail2;\n            }\n        }\n    }\n  else if (result != resultbuf && length < allocated)\n    {\n      /* Shrink the allocated memory if possible.  */\n      UNIT *memory;\n\n      memory = (UNIT *) realloc (result, length * sizeof (UNIT));\n      if (memory != NULL)\n        result = memory;\n    }\n\n  *lengthp = length;\n  return result;\n\n fail1:\n  {\n    int saved_errno = errno;\n    free (wordbreaks);\n    errno = saved_errno;\n  }\n fail2:\n  if (result != resultbuf)\n    {\n      int saved_errno = errno;\n      free (result);\n      errno = saved_errno;\n    }\n  return NULL;\n}",
      "lines": 477,
      "depth": 28,
      "decorators": [
        "UNIT",
        "*\nFUNC (const UNIT *s, size_t n,\n      casing_prefix_context_t prefix_context,\n      casing_suffix_context_t suffix_context,\n      const char *iso639_language,\n      uninorm_t nf,\n      UNIT *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u-is-cased.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "int\nFUNC (const UNIT *s, size_t n, const char *iso639_language,\n      bool *resultp)\n{\n  UNIT normsbuf[2048 / sizeof (UNIT)];\n  UNIT *norms;\n  size_t norms_length;\n  UNIT mappedbuf[2048 / sizeof (UNIT)];\n  UNIT *mapped_toupper;\n  UNIT *mapped_tolower;\n  UNIT *mapped_totitle;\n  size_t mapped_length;\n\n  /* Apply canonical decomposition to S.  */\n  norms_length = sizeof (normsbuf) / sizeof (UNIT);\n  norms = U_NORMALIZE (UNINORM_NFD, s, n, normsbuf, &norms_length);\n  if (norms == NULL)\n    /* errno is set here.  */\n    return -1;\n\n  mapped_length = sizeof (mappedbuf) / sizeof (UNIT);\n\n  /* Apply toupper mapping.  */\n  mapped_toupper = U_TOUPPER (norms, norms_length, iso639_language, NULL,\n                              mappedbuf, &mapped_length);\n  if (mapped_toupper == NULL)\n    goto fail;\n\n  /* Compare.  */\n  if (!(mapped_length == norms_length\n        && U_CMP (mapped_toupper, norms, norms_length) == 0))\n    {\n      if (mapped_toupper != mappedbuf)\n        free (mapped_toupper);\n      goto yes;\n    }\n\n  /* Apply tolower mapping.  */\n  mapped_tolower = U_TOLOWER (norms, norms_length, iso639_language, NULL,\n                              mapped_toupper, &mapped_length);\n  if (mapped_tolower == NULL)\n    {\n      if (mapped_toupper != mappedbuf)\n        {\n          int saved_errno = errno;\n          free (mapped_toupper);\n          errno = saved_errno;\n        }\n      goto fail;\n    }\n\n  if (mapped_toupper != mapped_tolower && mapped_toupper != mappedbuf)\n    free (mapped_toupper);\n\n  /* Compare.  */\n  if (!(mapped_length == norms_length\n        && U_CMP (mapped_tolower, norms, norms_length) == 0))\n    {\n      if (mapped_tolower != mappedbuf)\n        free (mapped_tolower);\n      goto yes;\n    }\n\n  /* Apply totitle mapping.  */\n  mapped_totitle = U_TOTITLE (norms, norms_length, iso639_language, NULL,\n                              mapped_tolower, &mapped_length);\n  if (mapped_totitle == NULL)\n    {\n      if (mapped_tolower != mappedbuf)\n        {\n          int saved_errno = errno;\n          free (mapped_tolower);\n          errno = saved_errno;\n        }\n      goto fail;\n    }\n\n  if (mapped_tolower != mapped_totitle && mapped_tolower != mappedbuf)\n    free (mapped_tolower);\n\n  /* Compare.  */\n  if (!(mapped_length == norms_length\n        && U_CMP (mapped_totitle, norms, norms_length) == 0))\n    {\n      if (mapped_totitle != mappedbuf)\n        free (mapped_totitle);\n      goto yes;\n    }\n\n  if (mapped_totitle != mappedbuf)\n    free (mapped_totitle);\n  if (norms != normsbuf)\n    free (norms);\n  *resultp = false;\n  return 0;\n\n yes:\n  if (norms != normsbuf)\n    free (norms);\n  *resultp = true;\n  return 0;\n\n fail:\n  if (norms != normsbuf)\n    {\n      int saved_errno = errno;\n      free (norms);\n      errno = saved_errno;\n    }\n  return -1;\n}",
      "lines": 111,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u-is-invariant.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "int\nFUNC (const UNIT *s, size_t n,\n      UNIT * (*mapping) (const UNIT *s, size_t n, const char *iso639_language,\n                         uninorm_t nf,\n                         UNIT *resultbuf, size_t *lengthp),\n      const char *iso639_language,\n      bool *resultp)\n{\n  UNIT normsbuf[2048 / sizeof (UNIT)];\n  UNIT *norms;\n  size_t norms_length;\n  UNIT mappedbuf[2048 / sizeof (UNIT)];\n  UNIT *mapped;\n  size_t mapped_length;\n\n  /* Apply canonical decomposition to S.  */\n  norms_length = sizeof (normsbuf) / sizeof (UNIT);\n  norms = U_NORMALIZE (UNINORM_NFD, s, n, normsbuf, &norms_length);\n  if (norms == NULL)\n    /* errno is set here.  */\n    return -1;\n\n  /* Apply mapping.  */\n  mapped_length = sizeof (mappedbuf) / sizeof (UNIT);\n  mapped = mapping (norms, norms_length, iso639_language, NULL,\n                    mappedbuf, &mapped_length);\n  if (mapped == NULL)\n    {\n      if (norms != normsbuf)\n        {\n          int saved_errno = errno;\n          free (norms);\n          errno = saved_errno;\n        }\n      return -1;\n    }\n\n  /* Compare.  */\n  *resultp = (mapped_length == norms_length\n              && U_CMP (mapped, norms, norms_length) == 0);\n\n  if (mapped != mappedbuf)\n    free (mapped);\n  if (norms != normsbuf)\n    free (norms);\n  return 0;\n}",
      "lines": 47,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u-prefix-context.h": {
    "FUNC1": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "casing_prefix_context_t\nFUNC1 (const UNIT *s, size_t n)\n{\n  return FUNC2 (s, n, unicase_empty_prefix_context);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "casing_prefix_context_t"
      ]
    },
    "FUNC2": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "casing_prefix_context_t\nFUNC2 (const UNIT *s, size_t n, casing_prefix_context_t a_context)\n{\n#if 0\n  /* Forward iteration.  Slow for long strings.  */\n  casing_prefix_context_t context = a_context;\n  const UNIT *s_end = s + n;\n\n  while (s < s_end)\n    {\n      ucs4_t uc;\n      int count = U_MBTOUC_UNSAFE (&uc, s, s_end - s);\n\n      if (!uc_is_case_ignorable (uc))\n        context.last_char_except_ignorable = uc;\n\n      {\n        int ccc = uc_combining_class (uc);\n        if (ccc == UC_CCC_A || ccc == UC_CCC_NR)\n          context.last_char_normal_or_above = uc;\n      }\n\n      s += count;\n    }\n\n  return context;\n#else\n  /* Iterate backwards, only as far as needed.  */\n  casing_prefix_context_t context;\n  ucs4_t last_char_except_ignorable = (ucs4_t)(-1);\n  ucs4_t last_char_normal_or_above = (ucs4_t)(-1);\n  const UNIT *p = s + n;\n\n  for (;;)\n    {\n      ucs4_t uc;\n      p = U_PREV (&uc, p, s);\n      if (p == NULL)\n        break;\n\n      if (last_char_except_ignorable == (ucs4_t)(-1))\n        {\n          if (!uc_is_case_ignorable (uc))\n            last_char_except_ignorable = uc;\n        }\n\n      if (last_char_normal_or_above == (ucs4_t)(-1))\n        {\n          int ccc = uc_combining_class (uc);\n          if (ccc == UC_CCC_A || ccc == UC_CCC_NR)\n            last_char_normal_or_above = uc;\n        }\n\n      if (last_char_except_ignorable != (ucs4_t)(-1)\n          && last_char_normal_or_above != (ucs4_t)(-1))\n        break;\n    }\n  context.last_char_except_ignorable =\n    (last_char_except_ignorable != (ucs4_t)(-1)\n     ? last_char_except_ignorable\n     : a_context.last_char_except_ignorable);\n  context.last_char_normal_or_above =\n    (last_char_normal_or_above != (ucs4_t)(-1)\n     ? last_char_normal_or_above\n     : a_context.last_char_normal_or_above);\n\n  return context;\n#endif\n}",
      "lines": 69,
      "depth": 14,
      "decorators": [
        "casing_prefix_context_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u-suffix-context.h": {
    "FUNC1": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "casing_suffix_context_t\nFUNC1 (const UNIT *s, size_t n)\n{\n  return FUNC2 (s, n, unicase_empty_suffix_context);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "casing_suffix_context_t"
      ]
    },
    "FUNC2": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "casing_suffix_context_t\nFUNC2 (const UNIT *s, size_t n, casing_suffix_context_t a_context)\n{\n  casing_suffix_context_t context;\n  /* Evaluate all three conditions in a single pass through the string S.\n     The three variables are -1 as long as the value of the condition has\n     not been determined.  */\n  ucs4_t first_char_except_ignorable = (ucs4_t)(-1);\n  int scc_MORE_ABOVE = -1;\n  int scc_BEFORE_DOT = -1;\n  const UNIT *s_end = s + n;\n\n  while (s < s_end)\n    {\n      ucs4_t uc;\n      int count = U_MBTOUC_UNSAFE (&uc, s, s_end - s);\n\n      if (first_char_except_ignorable == (ucs4_t)(-1))\n        {\n          if (!uc_is_case_ignorable (uc))\n            first_char_except_ignorable = uc;\n        }\n\n      if (scc_MORE_ABOVE < 0)\n        {\n          int ccc = uc_combining_class (uc);\n          if (ccc == UC_CCC_A)\n            scc_MORE_ABOVE = SCC_MORE_ABOVE_MASK;\n          else if (ccc == UC_CCC_NR)\n            scc_MORE_ABOVE = 0;\n        }\n\n      if (scc_BEFORE_DOT < 0)\n        {\n          if (uc == 0x0307) /* COMBINING DOT ABOVE */\n            scc_BEFORE_DOT = SCC_BEFORE_DOT_MASK;\n          else\n            {\n              int ccc = uc_combining_class (uc);\n              if (ccc == UC_CCC_A || ccc == UC_CCC_NR)\n                scc_BEFORE_DOT = 0;\n            }\n        }\n\n      if (first_char_except_ignorable != (ucs4_t)(-1)\n          && (scc_MORE_ABOVE | scc_BEFORE_DOT) >= 0)\n        /* All conditions have been determined.  */\n        break;\n\n      s += count;\n    }\n\n  /* For those conditions that have not been determined so far, use the\n     value from the argument context.  */\n  context.first_char_except_ignorable =\n    (first_char_except_ignorable != (ucs4_t)(-1)\n     ? first_char_except_ignorable\n     : a_context.first_char_except_ignorable);\n  context.bits =\n    (scc_MORE_ABOVE >= 0\n     ? scc_MORE_ABOVE\n     : a_context.bits & SCC_MORE_ABOVE_MASK)\n    | (scc_BEFORE_DOT >= 0\n       ? scc_BEFORE_DOT\n       : a_context.bits & SCC_BEFORE_DOT_MASK);\n  return context;\n}",
      "lines": 67,
      "depth": 13,
      "decorators": [
        "casing_suffix_context_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u-totitle.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "UNIT *\nFUNC (const UNIT *s, size_t n, const char *iso639_language,\n      uninorm_t nf,\n      UNIT *resultbuf, size_t *lengthp)\n{\n  return U_CT_TOTITLE (s, n,\n                       unicase_empty_prefix_context, unicase_empty_suffix_context,\n                       iso639_language,\n                       nf,\n                       resultbuf, lengthp);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "UNIT",
        "*\nFUNC (const UNIT *s, size_t n, const char *iso639_language,\n      uninorm_t nf,\n      UNIT *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u16-casecmp.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u16-casecoll.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u16-casefold.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u16-casemap.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u16-casexfrm.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u16-ct-casefold.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u16-ct-tolower.c": {
    "u16_ct_tolower": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "uint16_t *\nu16_ct_tolower (const uint16_t *s, size_t n,\n                casing_prefix_context_t prefix_context,\n                casing_suffix_context_t suffix_context,\n                const char *iso639_language,\n                uninorm_t nf,\n                uint16_t *resultbuf, size_t *lengthp)\n{\n  return u16_casemap (s, n, prefix_context, suffix_context, iso639_language,\n                      uc_tolower, offsetof (struct special_casing_rule, lower[0]),\n                      nf,\n                      resultbuf, lengthp);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "uint16_t",
        "*\nu16_ct_tolower (const uint16_t *s, size_t n,\n                casing_prefix_context_t prefix_context,\n                casing_suffix_context_t suffix_context,\n                const char *iso639_language,\n                uninorm_t nf,\n                uint16_t *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u16-ct-totitle.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u16-ct-toupper.c": {
    "u16_ct_toupper": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "uint16_t *\nu16_ct_toupper (const uint16_t *s, size_t n,\n                casing_prefix_context_t prefix_context,\n                casing_suffix_context_t suffix_context,\n                const char *iso639_language,\n                uninorm_t nf,\n                uint16_t *resultbuf, size_t *lengthp)\n{\n  return u16_casemap (s, n, prefix_context, suffix_context, iso639_language,\n                      uc_toupper, offsetof (struct special_casing_rule, upper[0]),\n                      nf,\n                      resultbuf, lengthp);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "uint16_t",
        "*\nu16_ct_toupper (const uint16_t *s, size_t n,\n                casing_prefix_context_t prefix_context,\n                casing_suffix_context_t suffix_context,\n                const char *iso639_language,\n                uninorm_t nf,\n                uint16_t *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u16-is-cased.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u16-is-casefolded.c": {
    "u16_is_casefolded": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nu16_is_casefolded (const uint16_t *s, size_t n, const char *iso639_language,\n                   bool *resultp)\n{\n  return u16_is_invariant (s, n, u16_casefold, iso639_language, resultp);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u16-is-invariant.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u16-is-lowercase.c": {
    "u16_is_lowercase": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nu16_is_lowercase (const uint16_t *s, size_t n, const char *iso639_language,\n                  bool *resultp)\n{\n  return u16_is_invariant (s, n, u16_tolower, iso639_language, resultp);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u16-is-titlecase.c": {
    "u16_is_titlecase": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nu16_is_titlecase (const uint16_t *s, size_t n, const char *iso639_language,\n                  bool *resultp)\n{\n  return u16_is_invariant (s, n, u16_totitle, iso639_language, resultp);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u16-is-uppercase.c": {
    "u16_is_uppercase": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nu16_is_uppercase (const uint16_t *s, size_t n, const char *iso639_language,\n                  bool *resultp)\n{\n  return u16_is_invariant (s, n, u16_toupper, iso639_language, resultp);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u16-prefix-context.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u16-suffix-context.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u16-tolower.c": {
    "u16_tolower": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "uint16_t *\nu16_tolower (const uint16_t *s, size_t n, const char *iso639_language,\n             uninorm_t nf,\n             uint16_t *resultbuf, size_t *lengthp)\n{\n  return u16_casemap (s, n,\n                      unicase_empty_prefix_context, unicase_empty_suffix_context,\n                      iso639_language,\n                      uc_tolower, offsetof (struct special_casing_rule, lower[0]),\n                      nf,\n                      resultbuf, lengthp);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "uint16_t",
        "*\nu16_tolower (const uint16_t *s, size_t n, const char *iso639_language,\n             uninorm_t nf,\n             uint16_t *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u16-totitle.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u16-toupper.c": {
    "u16_toupper": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "uint16_t *\nu16_toupper (const uint16_t *s, size_t n, const char *iso639_language,\n             uninorm_t nf,\n             uint16_t *resultbuf, size_t *lengthp)\n{\n  return u16_casemap (s, n,\n                      unicase_empty_prefix_context, unicase_empty_suffix_context,\n                      iso639_language,\n                      uc_toupper, offsetof (struct special_casing_rule, upper[0]),\n                      nf,\n                      resultbuf, lengthp);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "uint16_t",
        "*\nu16_toupper (const uint16_t *s, size_t n, const char *iso639_language,\n             uninorm_t nf,\n             uint16_t *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u32-casecmp.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u32-casecoll.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u32-casefold.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u32-casemap.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u32-casexfrm.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u32-ct-casefold.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u32-ct-tolower.c": {
    "u32_ct_tolower": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "uint32_t *\nu32_ct_tolower (const uint32_t *s, size_t n,\n                casing_prefix_context_t prefix_context,\n                casing_suffix_context_t suffix_context,\n                const char *iso639_language,\n                uninorm_t nf,\n                uint32_t *resultbuf, size_t *lengthp)\n{\n  return u32_casemap (s, n, prefix_context, suffix_context, iso639_language,\n                      uc_tolower, offsetof (struct special_casing_rule, lower[0]),\n                      nf,\n                      resultbuf, lengthp);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "uint32_t",
        "*\nu32_ct_tolower (const uint32_t *s, size_t n,\n                casing_prefix_context_t prefix_context,\n                casing_suffix_context_t suffix_context,\n                const char *iso639_language,\n                uninorm_t nf,\n                uint32_t *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u32-ct-totitle.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u32-ct-toupper.c": {
    "u32_ct_toupper": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "uint32_t *\nu32_ct_toupper (const uint32_t *s, size_t n,\n                casing_prefix_context_t prefix_context,\n                casing_suffix_context_t suffix_context,\n                const char *iso639_language,\n                uninorm_t nf,\n                uint32_t *resultbuf, size_t *lengthp)\n{\n  return u32_casemap (s, n, prefix_context, suffix_context, iso639_language,\n                      uc_toupper, offsetof (struct special_casing_rule, upper[0]),\n                      nf,\n                      resultbuf, lengthp);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "uint32_t",
        "*\nu32_ct_toupper (const uint32_t *s, size_t n,\n                casing_prefix_context_t prefix_context,\n                casing_suffix_context_t suffix_context,\n                const char *iso639_language,\n                uninorm_t nf,\n                uint32_t *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u32-is-cased.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u32-is-casefolded.c": {
    "u32_is_casefolded": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nu32_is_casefolded (const uint32_t *s, size_t n, const char *iso639_language,\n                   bool *resultp)\n{\n  return u32_is_invariant (s, n, u32_casefold, iso639_language, resultp);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u32-is-invariant.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u32-is-lowercase.c": {
    "u32_is_lowercase": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nu32_is_lowercase (const uint32_t *s, size_t n, const char *iso639_language,\n                  bool *resultp)\n{\n  return u32_is_invariant (s, n, u32_tolower, iso639_language, resultp);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u32-is-titlecase.c": {
    "u32_is_titlecase": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nu32_is_titlecase (const uint32_t *s, size_t n, const char *iso639_language,\n                  bool *resultp)\n{\n  return u32_is_invariant (s, n, u32_totitle, iso639_language, resultp);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u32-is-uppercase.c": {
    "u32_is_uppercase": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nu32_is_uppercase (const uint32_t *s, size_t n, const char *iso639_language,\n                  bool *resultp)\n{\n  return u32_is_invariant (s, n, u32_toupper, iso639_language, resultp);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u32-prefix-context.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u32-suffix-context.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u32-tolower.c": {
    "u32_tolower": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "uint32_t *\nu32_tolower (const uint32_t *s, size_t n, const char *iso639_language,\n             uninorm_t nf,\n             uint32_t *resultbuf, size_t *lengthp)\n{\n  return u32_casemap (s, n,\n                      unicase_empty_prefix_context, unicase_empty_suffix_context,\n                      iso639_language,\n                      uc_tolower, offsetof (struct special_casing_rule, lower[0]),\n                      nf,\n                      resultbuf, lengthp);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "uint32_t",
        "*\nu32_tolower (const uint32_t *s, size_t n, const char *iso639_language,\n             uninorm_t nf,\n             uint32_t *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u32-totitle.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u32-toupper.c": {
    "u32_toupper": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "uint32_t *\nu32_toupper (const uint32_t *s, size_t n, const char *iso639_language,\n             uninorm_t nf,\n             uint32_t *resultbuf, size_t *lengthp)\n{\n  return u32_casemap (s, n,\n                      unicase_empty_prefix_context, unicase_empty_suffix_context,\n                      iso639_language,\n                      uc_toupper, offsetof (struct special_casing_rule, upper[0]),\n                      nf,\n                      resultbuf, lengthp);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "uint32_t",
        "*\nu32_toupper (const uint32_t *s, size_t n, const char *iso639_language,\n             uninorm_t nf,\n             uint32_t *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u8-casecmp.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u8-casecoll.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u8-casefold.c": {
    "read_file": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "char *\nread_file (FILE *stream)\n{\n#define BUFSIZE 4096\n  char *buf = NULL;\n  int alloc = 0;\n  int size = 0;\n  int count;\n\n  while (! feof (stream))\n    {\n      if (size + BUFSIZE > alloc)\n        {\n          alloc = alloc + alloc / 2;\n          if (alloc < size + BUFSIZE)\n            alloc = size + BUFSIZE;\n          buf = realloc (buf, alloc);\n          if (buf == NULL)\n            {\n              fprintf (stderr, \"out of memory\\n\");\n              exit (1);\n            }\n        }\n      count = fread (buf + size, 1, BUFSIZE, stream);\n      if (count == 0)\n        {\n          if (ferror (stream))\n            {\n              perror (\"fread\");\n              exit (1);\n            }\n        }\n      else\n        size += count;\n    }\n  buf = realloc (buf, size + 1);\n  if (buf == NULL)\n    {\n      fprintf (stderr, \"out of memory\\n\");\n      exit (1);\n    }\n  buf[size] = '\\0';\n  return buf;\n#undef BUFSIZE\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "char",
        "*\nread_file (FILE *stream)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "int\nmain (int argc, char * argv[])\n{\n  setlocale (LC_ALL, \"\");\n  if (argc == 1)\n    {\n      /* Display the case folded input string.  */\n      char *input = read_file (stdin);\n      int length = strlen (input);\n      size_t output_length;\n      uint8_t *output =\n        u8_casefold ((uint8_t *) input, length, uc_locale_language (),\n                    NULL,\n                    NULL, &output_length);\n\n      fwrite (output, 1, output_length, stdout);\n\n      return 0;\n    }\n  else\n    return 1;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u8-casemap.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u8-casexfrm.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u8-ct-casefold.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u8-ct-tolower.c": {
    "u8_ct_tolower": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "uint8_t *\nu8_ct_tolower (const uint8_t *s, size_t n,\n               casing_prefix_context_t prefix_context,\n               casing_suffix_context_t suffix_context,\n               const char *iso639_language,\n               uninorm_t nf,\n               uint8_t *resultbuf, size_t *lengthp)\n{\n  return u8_casemap (s, n, prefix_context, suffix_context, iso639_language,\n                     uc_tolower, offsetof (struct special_casing_rule, lower[0]),\n                     nf,\n                     resultbuf, lengthp);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "uint8_t",
        "*\nu8_ct_tolower (const uint8_t *s, size_t n,\n               casing_prefix_context_t prefix_context,\n               casing_suffix_context_t suffix_context,\n               const char *iso639_language,\n               uninorm_t nf,\n               uint8_t *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u8-ct-totitle.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u8-ct-toupper.c": {
    "u8_ct_toupper": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "uint8_t *\nu8_ct_toupper (const uint8_t *s, size_t n,\n               casing_prefix_context_t prefix_context,\n               casing_suffix_context_t suffix_context,\n               const char *iso639_language,\n               uninorm_t nf,\n               uint8_t *resultbuf, size_t *lengthp)\n{\n  return u8_casemap (s, n, prefix_context, suffix_context, iso639_language,\n                     uc_toupper, offsetof (struct special_casing_rule, upper[0]),\n                     nf,\n                     resultbuf, lengthp);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "uint8_t",
        "*\nu8_ct_toupper (const uint8_t *s, size_t n,\n               casing_prefix_context_t prefix_context,\n               casing_suffix_context_t suffix_context,\n               const char *iso639_language,\n               uninorm_t nf,\n               uint8_t *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u8-is-cased.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u8-is-casefolded.c": {
    "u8_is_casefolded": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nu8_is_casefolded (const uint8_t *s, size_t n, const char *iso639_language,\n                  bool *resultp)\n{\n  return u8_is_invariant (s, n, u8_casefold, iso639_language, resultp);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u8-is-invariant.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u8-is-lowercase.c": {
    "u8_is_lowercase": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nu8_is_lowercase (const uint8_t *s, size_t n, const char *iso639_language,\n                 bool *resultp)\n{\n  return u8_is_invariant (s, n, u8_tolower, iso639_language, resultp);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u8-is-titlecase.c": {
    "u8_is_titlecase": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nu8_is_titlecase (const uint8_t *s, size_t n, const char *iso639_language,\n                 bool *resultp)\n{\n  return u8_is_invariant (s, n, u8_totitle, iso639_language, resultp);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u8-is-uppercase.c": {
    "u8_is_uppercase": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nu8_is_uppercase (const uint8_t *s, size_t n, const char *iso639_language,\n                 bool *resultp)\n{\n  return u8_is_invariant (s, n, u8_toupper, iso639_language, resultp);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u8-prefix-context.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u8-suffix-context.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/u8-tolower.c": {
    "u8_tolower": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "uint8_t *\nu8_tolower (const uint8_t *s, size_t n, const char *iso639_language,\n            uninorm_t nf,\n            uint8_t *resultbuf, size_t *lengthp)\n{\n  return u8_casemap (s, n,\n                     unicase_empty_prefix_context, unicase_empty_suffix_context,\n                     iso639_language,\n                     uc_tolower, offsetof (struct special_casing_rule, lower[0]),\n                     nf,\n                     resultbuf, lengthp);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "uint8_t",
        "*\nu8_tolower (const uint8_t *s, size_t n, const char *iso639_language,\n            uninorm_t nf,\n            uint8_t *resultbuf, size_t *lengthp)",
        "*"
      ]
    },
    "read_file": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "char *\nread_file (FILE *stream)\n{\n#define BUFSIZE 4096\n  char *buf = NULL;\n  int alloc = 0;\n  int size = 0;\n  int count;\n\n  while (! feof (stream))\n    {\n      if (size + BUFSIZE > alloc)\n        {\n          alloc = alloc + alloc / 2;\n          if (alloc < size + BUFSIZE)\n            alloc = size + BUFSIZE;\n          buf = realloc (buf, alloc);\n          if (buf == NULL)\n            {\n              fprintf (stderr, \"out of memory\\n\");\n              exit (1);\n            }\n        }\n      count = fread (buf + size, 1, BUFSIZE, stream);\n      if (count == 0)\n        {\n          if (ferror (stream))\n            {\n              perror (\"fread\");\n              exit (1);\n            }\n        }\n      else\n        size += count;\n    }\n  buf = realloc (buf, size + 1);\n  if (buf == NULL)\n    {\n      fprintf (stderr, \"out of memory\\n\");\n      exit (1);\n    }\n  buf[size] = '\\0';\n  return buf;\n#undef BUFSIZE\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "char",
        "*\nread_file (FILE *stream)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "int\nmain (int argc, char * argv[])\n{\n  setlocale (LC_ALL, \"\");\n  if (argc == 1)\n    {\n      /* Display the lower case of the input string.  */\n      char *input = read_file (stdin);\n      int length = strlen (input);\n      size_t output_length;\n      uint8_t *output =\n        u8_tolower ((uint8_t *) input, length, uc_locale_language (),\n                    NULL,\n                    NULL, &output_length);\n\n      fwrite (output, 1, output_length, stdout);\n\n      return 0;\n    }\n  else\n    return 1;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u8-totitle.c": {
    "read_file": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "char *\nread_file (FILE *stream)\n{\n#define BUFSIZE 4096\n  char *buf = NULL;\n  int alloc = 0;\n  int size = 0;\n  int count;\n\n  while (! feof (stream))\n    {\n      if (size + BUFSIZE > alloc)\n        {\n          alloc = alloc + alloc / 2;\n          if (alloc < size + BUFSIZE)\n            alloc = size + BUFSIZE;\n          buf = realloc (buf, alloc);\n          if (buf == NULL)\n            {\n              fprintf (stderr, \"out of memory\\n\");\n              exit (1);\n            }\n        }\n      count = fread (buf + size, 1, BUFSIZE, stream);\n      if (count == 0)\n        {\n          if (ferror (stream))\n            {\n              perror (\"fread\");\n              exit (1);\n            }\n        }\n      else\n        size += count;\n    }\n  buf = realloc (buf, size + 1);\n  if (buf == NULL)\n    {\n      fprintf (stderr, \"out of memory\\n\");\n      exit (1);\n    }\n  buf[size] = '\\0';\n  return buf;\n#undef BUFSIZE\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "char",
        "*\nread_file (FILE *stream)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "int\nmain (int argc, char * argv[])\n{\n  setlocale (LC_ALL, \"\");\n  if (argc == 1)\n    {\n      /* Display the upper case of the input string.  */\n      char *input = read_file (stdin);\n      int length = strlen (input);\n      size_t output_length;\n      uint8_t *output =\n        u8_toupper ((uint8_t *) input, length, uc_locale_language (),\n                    NULL,\n                    NULL, &output_length);\n\n      fwrite (output, 1, output_length, stdout);\n\n      return 0;\n    }\n  else\n    return 1;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/u8-toupper.c": {
    "u8_toupper": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "uint8_t *\nu8_toupper (const uint8_t *s, size_t n, const char *iso639_language,\n            uninorm_t nf,\n            uint8_t *resultbuf, size_t *lengthp)\n{\n  return u8_casemap (s, n,\n                     unicase_empty_prefix_context, unicase_empty_suffix_context,\n                     iso639_language,\n                     uc_toupper, offsetof (struct special_casing_rule, upper[0]),\n                     nf,\n                     resultbuf, lengthp);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "uint8_t",
        "*\nu8_toupper (const uint8_t *s, size_t n, const char *iso639_language,\n            uninorm_t nf,\n            uint8_t *resultbuf, size_t *lengthp)",
        "*"
      ]
    },
    "read_file": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "char *\nread_file (FILE *stream)\n{\n#define BUFSIZE 4096\n  char *buf = NULL;\n  int alloc = 0;\n  int size = 0;\n  int count;\n\n  while (! feof (stream))\n    {\n      if (size + BUFSIZE > alloc)\n        {\n          alloc = alloc + alloc / 2;\n          if (alloc < size + BUFSIZE)\n            alloc = size + BUFSIZE;\n          buf = realloc (buf, alloc);\n          if (buf == NULL)\n            {\n              fprintf (stderr, \"out of memory\\n\");\n              exit (1);\n            }\n        }\n      count = fread (buf + size, 1, BUFSIZE, stream);\n      if (count == 0)\n        {\n          if (ferror (stream))\n            {\n              perror (\"fread\");\n              exit (1);\n            }\n        }\n      else\n        size += count;\n    }\n  buf = realloc (buf, size + 1);\n  if (buf == NULL)\n    {\n      fprintf (stderr, \"out of memory\\n\");\n      exit (1);\n    }\n  buf[size] = '\\0';\n  return buf;\n#undef BUFSIZE\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "char",
        "*\nread_file (FILE *stream)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "int\nmain (int argc, char * argv[])\n{\n  setlocale (LC_ALL, \"\");\n  if (argc == 1)\n    {\n      /* Display the upper case of the input string.  */\n      char *input = read_file (stdin);\n      int length = strlen (input);\n      size_t output_length;\n      uint8_t *output =\n        u8_toupper ((uint8_t *) input, length, uc_locale_language (),\n                    NULL,\n                    NULL, &output_length);\n\n      fwrite (output, 1, output_length, stdout);\n\n      return 0;\n    }\n  else\n    return 1;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/ulc-casecmp.c": {
    "ulc_u8_casefold": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "static uint8_t *\nulc_u8_casefold (const char *s, size_t n, const char *iso639_language,\n                 uninorm_t nf,\n                 uint8_t *resultbuf, size_t *lengthp)\n{\n  uint8_t convbuf[2048 / sizeof (uint8_t)];\n  uint8_t *conv;\n  size_t conv_length;\n  uint8_t *result;\n\n  /* Convert the string to UTF-8.  */\n  conv_length = sizeof (convbuf) / sizeof (uint8_t);\n  conv =\n    u8_conv_from_encoding (locale_charset (), iconveh_error, s, n, NULL,\n                           convbuf, &conv_length);\n  if (conv == NULL)\n    /* errno is set here.  */\n    return NULL;\n\n  /* Case-fold and normalize.  */\n  result = u8_casefold (conv, conv_length, iso639_language, nf,\n                        resultbuf, lengthp);\n  if (result == NULL)\n    {\n      if (conv != convbuf)\n        {\n          int saved_errno = errno;\n          free (conv);\n          errno = saved_errno;\n        }\n      return NULL;\n    }\n\n  if (conv != convbuf)\n    free (conv);\n  return result;\n}",
      "lines": 37,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "uint8_t",
        "*\nulc_u8_casefold (const char *s, size_t n, const char *iso639_language,\n                 uninorm_t nf,\n                 uint8_t *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/ulc-casecoll.c": {},
  "libunistring/libunistring-0.9.10/lib/unicase/ulc-casexfrm.c": {
    "ulc_casexfrm": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "char *\nulc_casexfrm (const char *s, size_t n, const char *iso639_language,\n              uninorm_t nf,\n              char *resultbuf, size_t *lengthp)\n{\n  uint8_t convbuf[2048 / sizeof (uint8_t)];\n  uint8_t *conv;\n  size_t conv_length;\n  char *result;\n\n  /* Convert the string to UTF-8.  */\n  conv_length = sizeof (convbuf) / sizeof (uint8_t);\n  conv =\n    u8_conv_from_encoding (locale_charset (), iconveh_error, s, n, NULL,\n                           convbuf, &conv_length);\n  if (conv == NULL)\n    /* errno is set here.  */\n    return NULL;\n\n  /* Case-fold and normalize.  */\n  result = u8_casexfrm (conv, conv_length, iso639_language, nf,\n                        resultbuf, lengthp);\n  if (result == NULL)\n    {\n      if (conv != convbuf)\n        {\n          int saved_errno = errno;\n          free (conv);\n          errno = saved_errno;\n        }\n      return NULL;\n    }\n\n  if (conv != convbuf)\n    free (conv);\n  return result;\n}",
      "lines": 37,
      "depth": 10,
      "decorators": [
        "char",
        "*\nulc_casexfrm (const char *s, size_t n, const char *iso639_language,\n              uninorm_t nf,\n              char *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unicase/unicasemap.h": {},
  "libunistring/libunistring-0.9.10/lib/uniconv/u-conv-from-enc.h": {
    "FUNC": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "UNIT *\nFUNC (const char *fromcode,\n      enum iconv_ilseq_handler handler,\n      const char *src, size_t srclen,\n      size_t *offsets,\n      UNIT *resultbuf, size_t *lengthp)\n{\n#if HAVE_UTF_NAME\n  char *result = (char *) resultbuf;\n  size_t length = *lengthp * sizeof (UNIT);\n\n  if (mem_iconveha (src, srclen, fromcode, UTF_NAME, true, handler,\n                    offsets, &result, &length) < 0)\n    return NULL;\n  if (offsets != NULL)\n    {\n      /* Convert 'char *' offsets to 'UNIT *' offsets.  */\n      size_t *offsets_end = offsets + srclen;\n      size_t *o;\n\n      for (o = offsets; o < offsets_end; o++)\n        if (*o != (size_t)(-1))\n          *o = *o / sizeof (UNIT);\n    }\n  if ((length % sizeof (UNIT)) != 0)\n    abort ();\n  *lengthp = length / sizeof (UNIT);\n  return (UNIT *) result;\n#else\n  uint8_t *utf8_string;\n  size_t utf8_length;\n  UNIT *result;\n\n  utf8_string =\n    u8_conv_from_encoding (fromcode, handler, src, srclen, offsets,\n                           NULL, &utf8_length);\n  if (utf8_string == NULL)\n    return NULL;\n  result = U8_TO_U (utf8_string, utf8_length, resultbuf, lengthp);\n  if (result == NULL)\n    {\n      int saved_errno = errno;\n      free (utf8_string);\n      errno = saved_errno;\n      return NULL;\n    }\n  if (offsets != NULL)\n    {\n      size_t length = *lengthp;\n      size_t *offsets_end = offsets + srclen;\n      size_t *o;\n      size_t off8 = 0;  /* offset into utf8_string */\n      size_t offunit = 0;       /* offset into result */\n\n      for (o = offsets; o < offsets_end; o++)\n        if (*o != (size_t)(-1))\n          {\n            while (off8 < *o)\n              {\n                int count8 = u8_mblen (utf8_string + off8, utf8_length - off8);\n                int countunit = U_MBLEN (result + offunit, length - offunit);\n                if (count8 < 0 || countunit < 0)\n                  abort ();\n                off8 += count8;\n                offunit += countunit;\n              }\n            if (*o != off8)\n              abort ();\n            *o = offunit;\n          }\n    }\n  free (utf8_string);\n  return result;\n#endif\n}",
      "lines": 75,
      "depth": 17,
      "decorators": [
        "UNIT",
        "*\nFUNC (const char *fromcode,\n      enum iconv_ilseq_handler handler,\n      const char *src, size_t srclen,\n      size_t *offsets,\n      UNIT *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uniconv/u-conv-to-enc.h": {
    "FUNC": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "char *\nFUNC (const char *tocode,\n      enum iconv_ilseq_handler handler,\n      const UNIT *src, size_t srclen,\n      size_t *offsets,\n      char *resultbuf, size_t *lengthp)\n{\n#if HAVE_UTF_NAME\n  size_t *scaled_offsets;\n  char *result;\n  size_t length;\n\n  if (offsets != NULL && srclen > 0)\n    {\n      scaled_offsets =\n        (size_t *) malloc (srclen * sizeof (UNIT) * sizeof (size_t));\n      if (scaled_offsets == NULL)\n        {\n          errno = ENOMEM;\n          return NULL;\n        }\n    }\n  else\n    scaled_offsets = NULL;\n\n  result = resultbuf;\n  length = *lengthp;\n  if (mem_iconveha ((const char *) src, srclen * sizeof (UNIT),\n                    UTF_NAME, tocode,\n                    handler == iconveh_question_mark, handler,\n                    scaled_offsets, &result, &length) < 0)\n    {\n      int saved_errno = errno;\n      free (scaled_offsets);\n      errno = saved_errno;\n      return NULL;\n    }\n\n  if (offsets != NULL)\n    {\n      /* Convert scaled_offsets[srclen * sizeof (UNIT)] to\n         offsets[srclen].  */\n      size_t i;\n\n      for (i = 0; i < srclen; i++)\n        offsets[i] = scaled_offsets[i * sizeof (UNIT)];\n      free (scaled_offsets);\n    }\n\n  if (result == NULL) /* when (resultbuf == NULL && length == 0)  */\n    {\n      result = (char *) malloc (1);\n      if (result == NULL)\n        {\n          errno = ENOMEM;\n          return NULL;\n        }\n    }\n  *lengthp = length;\n  return result;\n#else\n  uint8_t tmpbuf[4096];\n  size_t tmpbufsize = SIZEOF (tmpbuf);\n  uint8_t *utf8_src;\n  size_t utf8_srclen;\n  size_t *scaled_offsets;\n  char *result;\n\n  utf8_src = U_TO_U8 (src, srclen, tmpbuf, &tmpbufsize);\n  if (utf8_src == NULL)\n    return NULL;\n  utf8_srclen = tmpbufsize;\n\n  if (offsets != NULL && utf8_srclen > 0)\n    {\n      scaled_offsets = (size_t *) malloc (utf8_srclen * sizeof (size_t));\n      if (scaled_offsets == NULL)\n        {\n          if (utf8_src != tmpbuf)\n            free (utf8_src);\n          errno = ENOMEM;\n          return NULL;\n        }\n    }\n  else\n    scaled_offsets = NULL;\n\n  result = u8_conv_to_encoding (tocode, handler, utf8_src, utf8_srclen,\n                                scaled_offsets, resultbuf, lengthp);\n  if (result == NULL)\n    {\n      int saved_errno = errno;\n      free (scaled_offsets);\n      if (utf8_src != tmpbuf)\n        free (utf8_src);\n      errno = saved_errno;\n      return NULL;\n    }\n  if (offsets != NULL)\n    {\n      size_t iunit;     /* offset into src */\n      size_t i8;        /* offset into utf8_src */\n\n      for (iunit = 0; iunit < srclen; iunit++)\n        offsets[iunit] = (size_t)(-1);\n\n      iunit = 0;\n      i8 = 0;\n      while (iunit < srclen && i8 < utf8_srclen)\n        {\n          int countunit;\n          int count8;\n\n          offsets[iunit] = scaled_offsets[i8];\n\n          countunit = U_MBLEN (src + iunit, srclen - iunit);\n          count8 = u8_mblen (utf8_src + i8, utf8_srclen - i8);\n          if (countunit < 0 || count8 < 0)\n            abort ();\n          iunit += countunit;\n          i8 += count8;\n        }\n      /* Check that utf8_src has been traversed entirely.  */\n      if (i8 < utf8_srclen)\n        abort ();\n      /* Check that src has been traversed entirely, except possibly for an\n         incomplete sequence of units at the end.  */\n      if (iunit < srclen)\n        {\n          offsets[iunit] = *lengthp;\n          if (!(U_MBLEN (src + iunit, srclen - iunit) < 0))\n            abort ();\n        }\n      free (scaled_offsets);\n    }\n  if (utf8_src != tmpbuf)\n    free (utf8_src);\n  return result;\n#endif\n}",
      "lines": 140,
      "depth": 17,
      "decorators": [
        "char",
        "*\nFUNC (const char *tocode,\n      enum iconv_ilseq_handler handler,\n      const UNIT *src, size_t srclen,\n      size_t *offsets,\n      char *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uniconv/u-strconv-from-enc.h": {
    "FUNC": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "UNIT *\nFUNC (const char *string,\n      const char *fromcode,\n      enum iconv_ilseq_handler handler)\n{\n  UNIT *result;\n  size_t length;\n\n  result =\n    U_CONV_FROM_ENCODING (fromcode, handler,\n                          string, strlen (string) + 1, NULL,\n                          NULL, &length);\n  if (result == NULL)\n    return NULL;\n  /* Verify the result has exactly one NUL unit, at the end.  */\n  if (!(length > 0 && result[length-1] == 0\n        && U_STRLEN (result) == length-1))\n    {\n      free (result);\n      errno = EILSEQ;\n      return NULL;\n    }\n  return result;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "UNIT",
        "*\nFUNC (const char *string,\n      const char *fromcode,\n      enum iconv_ilseq_handler handler)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uniconv/u-strconv-to-enc.h": {
    "FUNC": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "char *\nFUNC (const UNIT *string,\n      const char *tocode,\n      enum iconv_ilseq_handler handler)\n{\n#if HAVE_UTF_NAME\n  char *result = NULL;\n  size_t length = 0;\n\n  if (mem_iconveha ((const char *) string, (U_STRLEN (string) + 1) * sizeof (UNIT),\n                    UTF_NAME, tocode,\n                    handler == iconveh_question_mark, handler,\n                    NULL, &result, &length) < 0)\n    return NULL;\n  /* Verify the result has exactly one NUL byte, at the end.  */\n  if (!(length > 0 && result[length-1] == '\\0' && strlen (result) == length-1))\n    {\n      free (result);\n      errno = EILSEQ;\n      return NULL;\n    }\n  return result;\n#else\n  uint8_t tmpbuf[4096];\n  size_t tmpbufsize = SIZEOF (tmpbuf);\n  uint8_t *utf8_string;\n  char *result;\n\n  utf8_string = U_TO_U8 (string, U_STRLEN (string) + 1, tmpbuf, &tmpbufsize);\n  if (utf8_string == NULL)\n    return NULL;\n  result = u8_strconv_to_encoding (utf8_string, tocode, handler);\n  if (result == NULL)\n    {\n      if (utf8_string != tmpbuf)\n        {\n          int saved_errno = errno;\n          free (utf8_string);\n          errno = saved_errno;\n        }\n      return NULL;\n    }\n  if (utf8_string != tmpbuf)\n    free (utf8_string);\n  return result;\n#endif\n}",
      "lines": 47,
      "depth": 14,
      "decorators": [
        "char",
        "*\nFUNC (const UNIT *string,\n      const char *tocode,\n      enum iconv_ilseq_handler handler)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uniconv/u16-conv-from-enc.c": {},
  "libunistring/libunistring-0.9.10/lib/uniconv/u16-conv-to-enc.c": {
    "FUNC": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "static DST_UNIT *\nFUNC (const SRC_UNIT *s, size_t n, DST_UNIT *resultbuf, size_t *lengthp)\n{\n  const SRC_UNIT *s_end = s + n;\n  /* Output string accumulator.  */\n  DST_UNIT *result;\n  size_t allocated;\n  size_t length;\n\n  if (resultbuf != NULL)\n    {\n      result = resultbuf;\n      allocated = *lengthp;\n    }\n  else\n    {\n      result = NULL;\n      allocated = 0;\n    }\n  length = 0;\n  /* Invariants:\n     result is either == resultbuf or == NULL or malloc-allocated.\n     If length > 0, then result != NULL.  */\n\n  while (s < s_end)\n    {\n      ucs4_t uc;\n      int count;\n\n      /* Fetch a Unicode character from the input string.  */\n      count = u16_mbtoucr (&uc, s, s_end - s);\n      if (count < 0)\n        {\n          if (count == -2)\n            /* Incomplete sequence of units.  */\n            break;\n          if (!(result == resultbuf || result == NULL))\n            free (result);\n          errno = EILSEQ;\n          return NULL;\n        }\n      s += count;\n\n      /* Store it in the output string.  */\n      count = u8_uctomb (result + length, uc, allocated - length);\n      if (count == -1)\n        {\n          if (!(result == resultbuf || result == NULL))\n            free (result);\n          errno = EILSEQ;\n          return NULL;\n        }\n      if (count == -2)\n        {\n          DST_UNIT *memory;\n\n          allocated = (allocated > 0 ? 2 * allocated : 12);\n          if (length + 6 > allocated)\n            allocated = length + 6;\n          if (result == resultbuf || result == NULL)\n            memory = (DST_UNIT *) malloc (allocated * sizeof (DST_UNIT));\n          else\n            memory =\n              (DST_UNIT *) realloc (result, allocated * sizeof (DST_UNIT));\n\n          if (memory == NULL)\n            {\n              if (!(result == resultbuf || result == NULL))\n                free (result);\n              errno = ENOMEM;\n              return NULL;\n            }\n          if (result == resultbuf && length > 0)\n            memcpy ((char *) memory, (char *) result,\n                    length * sizeof (DST_UNIT));\n          result = memory;\n          count = u8_uctomb (result + length, uc, allocated - length);\n          if (count < 0)\n            abort ();\n        }\n      length += count;\n    }\n\n  if (length == 0)\n    {\n      if (result == NULL)\n        {\n          /* Return a non-NULL value.  NULL means error.  */\n          result = (DST_UNIT *) malloc (1);\n          if (result == NULL)\n            {\n              errno = ENOMEM;\n              return NULL;\n            }\n        }\n    }\n  else if (result != resultbuf && length < allocated)\n    {\n      /* Shrink the allocated memory if possible.  */\n      DST_UNIT *memory;\n\n      memory = (DST_UNIT *) realloc (result, length * sizeof (DST_UNIT));\n      if (memory != NULL)\n        result = memory;\n    }\n\n  *lengthp = length;\n  return result;\n}",
      "lines": 109,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "DST_UNIT",
        "*\nFUNC (const SRC_UNIT *s, size_t n, DST_UNIT *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uniconv/u16-strconv-from-enc.c": {},
  "libunistring/libunistring-0.9.10/lib/uniconv/u16-strconv-from-locale.c": {
    "u16_strconv_from_locale": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "uint16_t *\nu16_strconv_from_locale (const char *string)\n{\n  const char *encoding = locale_charset ();\n  return u16_strconv_from_encoding (string, encoding, iconveh_question_mark);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "uint16_t",
        "*\nu16_strconv_from_locale (const char *string)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uniconv/u16-strconv-to-enc.c": {},
  "libunistring/libunistring-0.9.10/lib/uniconv/u16-strconv-to-locale.c": {
    "u16_strconv_to_locale": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "char *\nu16_strconv_to_locale (const uint16_t *string)\n{\n  const char *encoding = locale_charset ();\n  return u16_strconv_to_encoding (string, encoding, iconveh_question_mark);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nu16_strconv_to_locale (const uint16_t *string)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uniconv/u32-conv-from-enc.c": {},
  "libunistring/libunistring-0.9.10/lib/uniconv/u32-conv-to-enc.c": {},
  "libunistring/libunistring-0.9.10/lib/uniconv/u32-strconv-from-enc.c": {},
  "libunistring/libunistring-0.9.10/lib/uniconv/u32-strconv-from-locale.c": {
    "u32_strconv_from_locale": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "uint32_t *\nu32_strconv_from_locale (const char *string)\n{\n  const char *encoding = locale_charset ();\n  return u32_strconv_from_encoding (string, encoding, iconveh_question_mark);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "uint32_t",
        "*\nu32_strconv_from_locale (const char *string)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uniconv/u32-strconv-to-enc.c": {},
  "libunistring/libunistring-0.9.10/lib/uniconv/u32-strconv-to-locale.c": {
    "u32_strconv_to_locale": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "char *\nu32_strconv_to_locale (const uint32_t *string)\n{\n  const char *encoding = locale_charset ();\n  return u32_strconv_to_encoding (string, encoding, iconveh_question_mark);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nu32_strconv_to_locale (const uint32_t *string)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uniconv/u8-conv-from-enc.c": {
    "u8_conv_from_encoding": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "uint8_t *\nu8_conv_from_encoding (const char *fromcode,\n                       enum iconv_ilseq_handler handler,\n                       const char *src, size_t srclen,\n                       size_t *offsets,\n                       uint8_t *resultbuf, size_t *lengthp)\n{\n  if (STRCASEEQ (fromcode, \"UTF-8\", 'U','T','F','-','8',0,0,0,0))\n    {\n      /* Conversion from UTF-8 to UTF-8.  No need to go through iconv().  */\n      uint8_t *result;\n\n      if (u8_check ((const uint8_t *) src, srclen))\n        {\n          errno = EILSEQ;\n          return NULL;\n        }\n\n      if (offsets != NULL)\n        {\n          size_t i;\n\n          for (i = 0; i < srclen; )\n            {\n              int count = u8_mblen ((const uint8_t *) src + i, srclen - i);\n              /* We can rely on count > 0 because of the previous u8_check.  */\n              if (count <= 0)\n                abort ();\n              offsets[i] = i;\n              i++;\n              while (--count > 0)\n                offsets[i++] = (size_t)(-1);\n            }\n        }\n\n      /* Memory allocation.  */\n      if (resultbuf != NULL && *lengthp >= srclen)\n        result = resultbuf;\n      else\n        {\n          result = (uint8_t *) malloc (srclen > 0 ? srclen : 1);\n          if (result == NULL)\n            {\n              errno = ENOMEM;\n              return NULL;\n            }\n        }\n\n      memcpy ((char *) result, src, srclen);\n      *lengthp = srclen;\n      return result;\n    }\n  else\n    {\n      char *result = (char *) resultbuf;\n      size_t length = *lengthp;\n\n      if (mem_iconveha (src, srclen, fromcode, \"UTF-8\", true, handler,\n                        offsets, &result, &length) < 0)\n        return NULL;\n\n      if (result == NULL) /* when (resultbuf == NULL && length == 0)  */\n        {\n          result = (char *) malloc (1);\n          if (result == NULL)\n            {\n              errno = ENOMEM;\n              return NULL;\n            }\n        }\n      *lengthp = length;\n      return (uint8_t *) result;\n    }\n}",
      "lines": 74,
      "depth": 17,
      "decorators": [
        "uint8_t",
        "*\nu8_conv_from_encoding (const char *fromcode,\n                       enum iconv_ilseq_handler handler,\n                       const char *src, size_t srclen,\n                       size_t *offsets,\n                       uint8_t *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uniconv/u8-conv-to-enc.c": {
    "u8_conv_to_encoding": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "char *\nu8_conv_to_encoding (const char *tocode,\n                     enum iconv_ilseq_handler handler,\n                     const uint8_t *src, size_t srclen,\n                     size_t *offsets,\n                     char *resultbuf, size_t *lengthp)\n{\n  if (STRCASEEQ (tocode, \"UTF-8\", 'U','T','F','-','8',0,0,0,0))\n    {\n      char *result;\n\n      /* Conversion from UTF-8 to UTF-8.  No need to go through iconv().  */\n      if (u8_check (src, srclen))\n        {\n          errno = EILSEQ;\n          return NULL;\n        }\n\n      /* Memory allocation.  */\n      if (resultbuf != NULL && *lengthp >= srclen)\n        result = resultbuf;\n      else\n        {\n          result = (char *) malloc (srclen > 0 ? srclen : 1);\n          if (result == NULL)\n            {\n              errno = ENOMEM;\n              return NULL;\n            }\n        }\n\n      memcpy (result, (const char *) src, srclen);\n      *lengthp = srclen;\n      return result;\n    }\n  else\n    {\n      char *result = resultbuf;\n      size_t length = *lengthp;\n\n      if (mem_iconveha ((const char *) src, srclen,\n                        \"UTF-8\", tocode,\n                        handler == iconveh_question_mark, handler,\n                        offsets, &result, &length) < 0)\n        return NULL;\n\n      if (result == NULL) /* when (resultbuf == NULL && length == 0)  */\n        {\n          result = (char *) malloc (1);\n          if (result == NULL)\n            {\n              errno = ENOMEM;\n              return NULL;\n            }\n        }\n      *lengthp = length;\n      return result;\n    }\n}",
      "lines": 59,
      "depth": 14,
      "decorators": [
        "char",
        "*\nu8_conv_to_encoding (const char *tocode,\n                     enum iconv_ilseq_handler handler,\n                     const uint8_t *src, size_t srclen,\n                     size_t *offsets,\n                     char *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uniconv/u8-strconv-from-enc.c": {},
  "libunistring/libunistring-0.9.10/lib/uniconv/u8-strconv-from-locale.c": {
    "u8_strconv_from_locale": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "uint8_t *\nu8_strconv_from_locale (const char *string)\n{\n  const char *encoding = locale_charset ();\n  return u8_strconv_from_encoding (string, encoding, iconveh_question_mark);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "uint8_t",
        "*\nu8_strconv_from_locale (const char *string)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uniconv/u8-strconv-to-enc.c": {
    "u8_strconv_to_encoding": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "char *\nu8_strconv_to_encoding (const uint8_t *string,\n                        const char *tocode,\n                        enum iconv_ilseq_handler handler)\n{\n  char *result;\n  size_t length;\n\n  if (STRCASEEQ (tocode, \"UTF-8\", 'U','T','F','-','8',0,0,0,0))\n    {\n      /* Conversion from UTF-8 to UTF-8.  No need to go through iconv().  */\n      length = u8_strlen (string) + 1;\n      if (u8_check (string, length))\n        {\n          errno = EILSEQ;\n          return NULL;\n        }\n      result = (char *) malloc (length);\n      if (result == NULL)\n        {\n          errno = ENOMEM;\n          return NULL;\n        }\n      memcpy (result, (const char *) string, length);\n      return result;\n    }\n  else\n    {\n      result = NULL;\n      length = 0;\n      if (mem_iconveha ((const char *) string, u8_strlen (string) + 1,\n                        \"UTF-8\", tocode,\n                        handler == iconveh_question_mark, handler,\n                        NULL, &result, &length) < 0)\n        return NULL;\n      /* Verify the result has exactly one NUL byte, at the end.  */\n      if (!(length > 0 && result[length-1] == '\\0'\n            && strlen (result) == length-1))\n        {\n          free (result);\n          errno = EILSEQ;\n          return NULL;\n        }\n      return result;\n    }\n}",
      "lines": 46,
      "depth": 14,
      "decorators": [
        "char",
        "*\nu8_strconv_to_encoding (const uint8_t *string,\n                        const char *tocode,\n                        enum iconv_ilseq_handler handler)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uniconv/u8-strconv-to-locale.c": {
    "u8_strconv_to_locale": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "char *\nu8_strconv_to_locale (const uint8_t *string)\n{\n  const char *encoding = locale_charset ();\n  return u8_strconv_to_encoding (string, encoding, iconveh_question_mark);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nu8_strconv_to_locale (const uint8_t *string)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/bidi_byname.c": {
    "uc_bidi_class_byname": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nuc_bidi_class_byname (const char *bidi_class_name)\n{\n  size_t len;\n\n  len = strlen (bidi_class_name);\n  if (len <= MAX_WORD_LENGTH)\n    {\n      char buf[MAX_WORD_LENGTH + 1];\n      const struct named_bidi_class *found;\n\n      /* Copy bidi_class_name into buf, converting '_' and '-' to ' '.  */\n      {\n        const char *p = bidi_class_name;\n        char *q = buf;\n\n        for (;; p++, q++)\n          {\n            char c = *p;\n\n            if (c == '_' || c == '-')\n              c = ' ';\n            *q = c;\n            if (c == '\\0')\n              break;\n          }\n      }\n      /* Here q == buf + len.  */\n\n      /* Do a hash table lookup, with case-insensitive comparison.  */\n      found = uc_bidi_class_lookup (buf, len);\n      if (found != NULL)\n        return found->bidi_class;\n    }\n  /* Invalid bidi class name.  */\n  return -1;\n}",
      "lines": 37,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "uc_bidi_category_byname": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nuc_bidi_category_byname (const char *category_name)\n{\n  return uc_bidi_class_byname (category_name);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/bidi_byname.h": {
    "gperf_case_strcmp": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static int\ngperf_case_strcmp (register const char *s1, register const char *s2)\n{\n  for (;;)\n    {\n      unsigned char c1 = gperf_downcase[(unsigned char)*s1++];\n      unsigned char c2 = gperf_downcase[(unsigned char)*s2++];\n      if (c1 != 0 && c1 == c2)\n        continue;\n      return (int)c1 - (int)c2;\n    }\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "bidi_class_hash": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "static unsigned int\nbidi_class_hash (register const char *str, register size_t len)\n{\n  static const unsigned char asso_values[] =\n    {\n      88, 88, 88, 88, 88, 88, 88, 88, 88, 88,\n      88, 88, 88, 88, 88, 88, 88, 88, 88, 88,\n      88, 88, 88, 88, 88, 88, 88, 88, 88, 88,\n      88, 88, 14, 88, 88, 88, 88, 88, 88, 88,\n      88, 88, 88, 88, 88, 88, 88, 88, 88, 88,\n      88, 88, 88, 88, 88, 88, 88, 88, 88, 88,\n      88, 88, 88, 88, 88,  5, 31, 22, 88,  2,\n      53,  2, 48, 11, 88, 52,  5, 60,  2,  9,\n       4, 88,  2, 34, 30, 41, 88, 28, 88, 88,\n      88, 88, 88, 88, 88, 88, 88,  5, 31, 22,\n      88,  2, 53,  2, 48, 11, 88, 52,  5, 60,\n       2,  9,  4, 88,  2, 34, 30, 41, 88, 28,\n      88, 88, 88, 88, 88, 88, 88, 88, 88, 88,\n      88, 88, 88, 88, 88, 88, 88, 88, 88, 88,\n      88, 88, 88, 88, 88, 88, 88, 88, 88, 88,\n      88, 88, 88, 88, 88, 88, 88, 88, 88, 88,\n      88, 88, 88, 88, 88, 88, 88, 88, 88, 88,\n      88, 88, 88, 88, 88, 88, 88, 88, 88, 88,\n      88, 88, 88, 88, 88, 88, 88, 88, 88, 88,\n      88, 88, 88, 88, 88, 88, 88, 88, 88, 88,\n      88, 88, 88, 88, 88, 88, 88, 88, 88, 88,\n      88, 88, 88, 88, 88, 88, 88, 88, 88, 88,\n      88, 88, 88, 88, 88, 88, 88, 88, 88, 88,\n      88, 88, 88, 88, 88, 88, 88, 88, 88, 88,\n      88, 88, 88, 88, 88, 88, 88, 88, 88, 88,\n      88, 88, 88, 88, 88, 88\n    };\n  register unsigned int hval = len;\n\n  switch (hval)\n    {\n      default:\n        hval += asso_values[(unsigned char)str[8]];\n      /*FALLTHROUGH*/\n      case 8:\n      case 7:\n      case 6:\n      case 5:\n      case 4:\n      case 3:\n      case 2:\n      case 1:\n        hval += asso_values[(unsigned char)str[0]];\n        break;\n    }\n  return hval + asso_values[(unsigned char)str[len - 1]];\n}",
      "lines": 52,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "uc_bidi_class_lookup": {
      "start_point": [
        441,
        0
      ],
      "end_point": [
        461,
        1
      ],
      "content": "const struct named_bidi_class *\nuc_bidi_class_lookup (register const char *str, register size_t len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register unsigned int key = bidi_class_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE)\n        {\n          register int o = bidi_class_names[key].name;\n          if (o >= 0)\n            {\n              register const char *s = o + bidi_class_stringpool;\n\n              if ((((unsigned char)*str ^ (unsigned char)*s) & ~32) == 0 && !gperf_case_strcmp (str, s))\n                return &bidi_class_names[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 20,
      "decorators": [
        "const",
        "const",
        "struct named_bidi_class",
        "struct",
        "named_bidi_class",
        "*\nuc_bidi_class_lookup (register const char *str, register size_t len)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/bidi_longname.c": {
    "uc_bidi_class_long_name": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "const char *\nuc_bidi_class_long_name (int bidi_class)\n{\n  if (bidi_class >= 0\n      && bidi_class < sizeof (u_bidi_class_long_name) / sizeof (u_bidi_class_long_name[0]))\n    return u_bidi_class_long_name[bidi_class];\n  return NULL;\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nuc_bidi_class_long_name (int bidi_class)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/bidi_name.c": {
    "uc_bidi_class_name": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "const char *\nuc_bidi_class_name (int bidi_class)\n{\n  if (bidi_class >= 0 && bidi_class < sizeof (u_bidi_class_name) / sizeof (u_bidi_class_name[0]))\n    return u_bidi_class_name[bidi_class];\n  return NULL;\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nuc_bidi_class_name (int bidi_class)",
        "*"
      ]
    },
    "uc_bidi_category_name": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "const char *\nuc_bidi_category_name (int category)\n{\n  return uc_bidi_class_name (category);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nuc_bidi_category_name (int category)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/bidi_of.c": {
    "uc_bidi_class": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nuc_bidi_class (ucs4_t uc)\n{\n  unsigned int index1 = uc >> bidi_category_header_0;\n  if (index1 < bidi_category_header_1)\n    {\n      int lookup1 = u_bidi_category.level1[index1];\n      if (lookup1 >= 0)\n        {\n          unsigned int index2 = (uc >> bidi_category_header_2) & bidi_category_header_3;\n          int lookup2 = u_bidi_category.level2[lookup1 + index2];\n          if (lookup2 >= 0)\n            {\n              unsigned int index3 = ((uc & bidi_category_header_4) + lookup2) * 5;\n              /* level3 contains 5-bit values, packed into 16-bit words.  */\n              unsigned int lookup3 =\n                ((u_bidi_category.level3[index3>>4]\n                  | ((unsigned int) u_bidi_category.level3[(index3>>4)+1] << 16))\n                 >> (index3 % 16))\n                & 0x1f;\n\n              return lookup3;\n            }\n        }\n    }\n  return UC_BIDI_L;\n}",
      "lines": 27,
      "depth": 23,
      "decorators": [
        "int"
      ]
    },
    "uc_bidi_category": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "int\nuc_bidi_category (ucs4_t uc)\n{\n  return uc_bidi_class (uc);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/bidi_of.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/bidi_test.c": {
    "uc_is_bidi_class": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "bool\nuc_is_bidi_class (ucs4_t uc, int bidi_class)\n{\n  return (uc_bidi_class (uc) == bidi_class);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "uc_is_bidi_category": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "bool\nuc_is_bidi_category (ucs4_t uc, int category)\n{\n  return uc_is_bidi_class (uc, category);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/bitmap.h": {
    "bitmap_lookup": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "static inline int\nbitmap_lookup (const void *table, ucs4_t uc)\n{\n  unsigned int index1 = uc >> header_0;\n  if (index1 < ((const int *) table)[0])\n    {\n      int lookup1 = ((const int *) table)[1 + index1];\n      if (lookup1 >= 0)\n        {\n          unsigned int index2 = (uc >> header_2) & header_3;\n          int lookup2 = ((const short *) table)[lookup1 + index2];\n          if (lookup2 >= 0)\n            {\n              unsigned int index3 = (uc >> 5) & header_4;\n              unsigned int lookup3 = ((const int *) table)[lookup2 + index3];\n\n              return (lookup3 >> (uc & 0x1f)) & 1;\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 22,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/blocks.c": {
    "uc_block": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "const uc_block_t *\nuc_block (ucs4_t uc)\n{\n  unsigned int first_index;\n  unsigned int last_index;\n\n  if (uc < blocks_level1_threshold)\n    {\n      unsigned int index1 = uc >> blocks_level1_shift;\n      first_index = blocks_level1[2 * index1];\n      last_index = blocks_level1[2 * index1 + 1];\n    }\n  else\n    {\n      first_index = blocks_upper_first_index;\n      last_index = blocks_upper_last_index;\n    }\n  /* We know that the relevant blocks are blocks[i] with\n     first_index <= i < last_index.  Now perform a binary search.  */\n  while (first_index < last_index)\n    {\n      unsigned int mid_index = (first_index + last_index) / 2;\n      if (blocks[mid_index].end < uc)\n        first_index = mid_index + 1;\n      else if (uc < blocks[mid_index].start)\n        last_index = mid_index;\n      else\n        return &blocks[mid_index];\n    }\n  return NULL;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "const",
        "const",
        "uc_block_t",
        "*\nuc_block (ucs4_t uc)",
        "*"
      ]
    },
    "uc_all_blocks": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "void\nuc_all_blocks (const uc_block_t **blocksp, size_t *countp)\n{\n  *blocksp = blocks;\n  *countp = sizeof (blocks) / sizeof (blocks[0]);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/blocks.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/block_test.c": {
    "uc_is_block": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "bool\nuc_is_block (ucs4_t uc, const uc_block_t *block)\n{\n  if (block != NULL)\n    return ((ucs4_t) (uc - block->start) <= block->end - block->start);\n  else\n    return false;\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/categ_and.c": {
    "uc_general_category_and": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "uc_general_category_t\nuc_general_category_and (uc_general_category_t category1,\n                         uc_general_category_t category2)\n{\n  uint32_t bitmask;\n  uc_general_category_t result;\n\n  bitmask = category1.bitmask & category2.bitmask;\n\n  if (bitmask == category1.bitmask)\n    return category1;\n\n  if (bitmask == category2.bitmask)\n    return category2;\n\n  if (bitmask == 0)\n    return _UC_CATEGORY_NONE;\n\n  result.bitmask = bitmask;\n  result.generic = 1;\n  result.lookup.lookup_fn = &uc_is_general_category_withtable;\n  return result;\n}",
      "lines": 23,
      "depth": 7,
      "decorators": [
        "uc_general_category_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/categ_and_not.c": {
    "uc_general_category_and_not": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "uc_general_category_t\nuc_general_category_and_not (uc_general_category_t category1,\n                             uc_general_category_t category2)\n{\n  uint32_t bitmask;\n  uc_general_category_t result;\n\n  bitmask = category1.bitmask & ~category2.bitmask;\n\n  if (bitmask == category1.bitmask)\n    return category1;\n\n  if (bitmask == 0)\n    return _UC_CATEGORY_NONE;\n\n  result.bitmask = bitmask;\n  result.generic = 1;\n  result.lookup.lookup_fn = &uc_is_general_category_withtable;\n  return result;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "uc_general_category_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/categ_byname.c": {
    "uc_general_category_byname": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "uc_general_category_t\nuc_general_category_byname (const char *category_name)\n{\n  size_t len;\n\n  len = strlen (category_name);\n  if (len <= MAX_WORD_LENGTH)\n    {\n      char buf[MAX_WORD_LENGTH + 1];\n      const struct named_category *found;\n\n      /* Copy category_name into buf, converting '_' and '-' to ' '.  */\n      {\n        const char *p = category_name;\n        char *q = buf;\n\n        for (;; p++, q++)\n          {\n            char c = *p;\n\n            if (c == '_' || c == '-')\n              c = ' ';\n            *q = c;\n            if (c == '\\0')\n              break;\n          }\n      }\n      /* Here q == buf + len.  */\n\n      /* Do a hash table lookup, with case-insensitive comparison.  */\n      found = uc_general_category_lookup (buf, len);\n      if (found != NULL)\n        /* Use a 'switch' statement here, because a table would introduce\n           load-time relocations.  */\n        switch (found->category_index)\n          {\n          case UC_CATEGORY_INDEX_L:\n            return UC_CATEGORY_L;\n          case UC_CATEGORY_INDEX_LC:\n            return UC_CATEGORY_LC;\n          case UC_CATEGORY_INDEX_Lu:\n            return UC_CATEGORY_Lu;\n          case UC_CATEGORY_INDEX_Ll:\n            return UC_CATEGORY_Ll;\n          case UC_CATEGORY_INDEX_Lt:\n            return UC_CATEGORY_Lt;\n          case UC_CATEGORY_INDEX_Lm:\n            return UC_CATEGORY_Lm;\n          case UC_CATEGORY_INDEX_Lo:\n            return UC_CATEGORY_Lo;\n          case UC_CATEGORY_INDEX_M:\n            return UC_CATEGORY_M;\n          case UC_CATEGORY_INDEX_Mn:\n            return UC_CATEGORY_Mn;\n          case UC_CATEGORY_INDEX_Mc:\n            return UC_CATEGORY_Mc;\n          case UC_CATEGORY_INDEX_Me:\n            return UC_CATEGORY_Me;\n          case UC_CATEGORY_INDEX_N:\n            return UC_CATEGORY_N;\n          case UC_CATEGORY_INDEX_Nd:\n            return UC_CATEGORY_Nd;\n          case UC_CATEGORY_INDEX_Nl:\n            return UC_CATEGORY_Nl;\n          case UC_CATEGORY_INDEX_No:\n            return UC_CATEGORY_No;\n          case UC_CATEGORY_INDEX_P:\n            return UC_CATEGORY_P;\n          case UC_CATEGORY_INDEX_Pc:\n            return UC_CATEGORY_Pc;\n          case UC_CATEGORY_INDEX_Pd:\n            return UC_CATEGORY_Pd;\n          case UC_CATEGORY_INDEX_Ps:\n            return UC_CATEGORY_Ps;\n          case UC_CATEGORY_INDEX_Pe:\n            return UC_CATEGORY_Pe;\n          case UC_CATEGORY_INDEX_Pi:\n            return UC_CATEGORY_Pi;\n          case UC_CATEGORY_INDEX_Pf:\n            return UC_CATEGORY_Pf;\n          case UC_CATEGORY_INDEX_Po:\n            return UC_CATEGORY_Po;\n          case UC_CATEGORY_INDEX_S:\n            return UC_CATEGORY_S;\n          case UC_CATEGORY_INDEX_Sm:\n            return UC_CATEGORY_Sm;\n          case UC_CATEGORY_INDEX_Sc:\n            return UC_CATEGORY_Sc;\n          case UC_CATEGORY_INDEX_Sk:\n            return UC_CATEGORY_Sk;\n          case UC_CATEGORY_INDEX_So:\n            return UC_CATEGORY_So;\n          case UC_CATEGORY_INDEX_Z:\n            return UC_CATEGORY_Z;\n          case UC_CATEGORY_INDEX_Zs:\n            return UC_CATEGORY_Zs;\n          case UC_CATEGORY_INDEX_Zl:\n            return UC_CATEGORY_Zl;\n          case UC_CATEGORY_INDEX_Zp:\n            return UC_CATEGORY_Zp;\n          case UC_CATEGORY_INDEX_C:\n            return UC_CATEGORY_C;\n          case UC_CATEGORY_INDEX_Cc:\n            return UC_CATEGORY_Cc;\n          case UC_CATEGORY_INDEX_Cf:\n            return UC_CATEGORY_Cf;\n          case UC_CATEGORY_INDEX_Cs:\n            return UC_CATEGORY_Cs;\n          case UC_CATEGORY_INDEX_Co:\n            return UC_CATEGORY_Co;\n          case UC_CATEGORY_INDEX_Cn:\n            return UC_CATEGORY_Cn;\n          default:\n            abort ();\n          }\n    }\n  /* Invalid category name.  */\n  return _UC_CATEGORY_NONE;\n}",
      "lines": 119,
      "depth": 13,
      "decorators": [
        "uc_general_category_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/categ_byname.h": {
    "gperf_case_strcmp": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static int\ngperf_case_strcmp (register const char *s1, register const char *s2)\n{\n  for (;;)\n    {\n      unsigned char c1 = gperf_downcase[(unsigned char)*s1++];\n      unsigned char c2 = gperf_downcase[(unsigned char)*s2++];\n      if (c1 != 0 && c1 == c2)\n        continue;\n      return (int)c1 - (int)c2;\n    }\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "general_category_hash": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "static unsigned int\ngeneral_category_hash (register const char *str, register size_t len)\n{\n  static const unsigned char asso_values[] =\n    {\n      151, 151, 151, 151, 151, 151, 151, 151, 151, 151,\n      151, 151, 151, 151, 151, 151, 151, 151, 151, 151,\n      151, 151, 151, 151, 151, 151, 151, 151, 151, 151,\n      151, 151,   1, 151, 151, 151, 151, 151, 151, 151,\n      151, 151, 151, 151, 151, 151, 151, 151, 151, 151,\n      151, 151, 151, 151, 151, 151, 151, 151, 151, 151,\n      151, 151, 151, 151, 151,  16, 151,   1,  66,  21,\n        9,  25, 151,  62, 151,  49,   0,  51,   4,   7,\n        6, 151,  25,  42,   5,   8, 151, 151, 151,   0,\n       45, 151, 151, 151, 151, 151, 151,  16, 151,   1,\n       66,  21,   9,  25, 151,  62, 151,  49,   0,  51,\n        4,   7,   6, 151,  25,  42,   5,   8, 151, 151,\n      151,   0,  45, 151, 151, 151, 151, 151, 151, 151,\n      151, 151, 151, 151, 151, 151, 151, 151, 151, 151,\n      151, 151, 151, 151, 151, 151, 151, 151, 151, 151,\n      151, 151, 151, 151, 151, 151, 151, 151, 151, 151,\n      151, 151, 151, 151, 151, 151, 151, 151, 151, 151,\n      151, 151, 151, 151, 151, 151, 151, 151, 151, 151,\n      151, 151, 151, 151, 151, 151, 151, 151, 151, 151,\n      151, 151, 151, 151, 151, 151, 151, 151, 151, 151,\n      151, 151, 151, 151, 151, 151, 151, 151, 151, 151,\n      151, 151, 151, 151, 151, 151, 151, 151, 151, 151,\n      151, 151, 151, 151, 151, 151, 151, 151, 151, 151,\n      151, 151, 151, 151, 151, 151, 151, 151, 151, 151,\n      151, 151, 151, 151, 151, 151, 151, 151, 151, 151,\n      151, 151, 151, 151, 151, 151\n    };\n  register unsigned int hval = len;\n\n  switch (hval)\n    {\n      default:\n        hval += asso_values[(unsigned char)str[6]];\n      /*FALLTHROUGH*/\n      case 6:\n      case 5:\n      case 4:\n      case 3:\n      case 2:\n        hval += asso_values[(unsigned char)str[1]];\n      /*FALLTHROUGH*/\n      case 1:\n        hval += asso_values[(unsigned char)str[0]];\n        break;\n    }\n  return hval + asso_values[(unsigned char)str[len - 1]];\n}",
      "lines": 52,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "uc_general_category_lookup": {
      "start_point": [
        595,
        0
      ],
      "end_point": [
        615,
        1
      ],
      "content": "const struct named_category *\nuc_general_category_lookup (register const char *str, register size_t len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register unsigned int key = general_category_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE)\n        {\n          register int o = general_category_names[key].name;\n          if (o >= 0)\n            {\n              register const char *s = o + general_category_stringpool;\n\n              if ((((unsigned char)*str ^ (unsigned char)*s) & ~32) == 0 && !gperf_case_strcmp (str, s))\n                return &general_category_names[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 20,
      "decorators": [
        "const",
        "const",
        "struct named_category",
        "struct",
        "named_category",
        "*\nuc_general_category_lookup (register const char *str, register size_t len)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/categ_C.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_C.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Cc.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Cc.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Cf.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Cf.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Cn.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Cn.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Co.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Co.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Cs.c": {
    "uc_is_category_Cs": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "static bool\nuc_is_category_Cs (ucs4_t uc)\n{\n  return (uc >= 0xd800 && uc < 0xe000);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Cs.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_L.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_L.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_LC.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_LC.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Ll.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Ll.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Lm.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Lm.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Lo.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Lo.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_longname.c": {
    "uc_general_category_long_name": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "const char *\nuc_general_category_long_name (uc_general_category_t category)\n{\n  uint32_t bitmask = category.bitmask;\n  /* bitmask should consist of a single bit.  */\n  if (bitmask != 0)\n    {\n      if ((bitmask & (bitmask - 1)) == 0)\n        {\n          int bit;\n          /* Take log2 using a variant of Robert Harley's method.\n             Found by Bruno Haible 1996.  */\n          uint32_t n = bitmask;\n          static const char ord2_tab[64] =\n            {\n              -1,  0,  1, 12,  2,  6, -1, 13,  3, -1,  7, -1, -1, -1, -1, 14,\n              10,  4, -1, -1,  8, -1, -1, 25, -1, -1, -1, -1, -1, 21, 27, 15,\n              31, 11,  5, -1, -1, -1, -1, -1,  9, -1, -1, 24, -1, -1, 20, 26,\n              30, -1, -1, -1, -1, 23, -1, 19, 29, -1, 22, 18, 28, 17, 16, -1\n            };\n          n += n << 4;\n          n += n << 6;\n          n = (n << 16) - n;\n          bit = ord2_tab[n >> 26];\n\n          if (bit < sizeof (u_category_long_name) / sizeof (u_category_long_name[0]))\n            return u_category_long_name[bit];\n        }\n      else\n        {\n          if (bitmask == UC_CATEGORY_MASK_L)\n            return \"Letter\";\n          if (bitmask == UC_CATEGORY_MASK_LC)\n            return \"Cased Letter\";\n          if (bitmask == UC_CATEGORY_MASK_M)\n            return \"Mark\";\n          if (bitmask == UC_CATEGORY_MASK_N)\n            return \"Number\";\n          if (bitmask == UC_CATEGORY_MASK_P)\n            return \"Punctuation\";\n          if (bitmask == UC_CATEGORY_MASK_S)\n            return \"Symbol\";\n          if (bitmask == UC_CATEGORY_MASK_Z)\n            return \"Separator\";\n          if (bitmask == UC_CATEGORY_MASK_C)\n            return \"Other\";\n        }\n    }\n  return NULL;\n}",
      "lines": 50,
      "depth": 14,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nuc_general_category_long_name (uc_general_category_t category)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Lt.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Lt.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Lu.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Lu.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_M.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_M.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Mc.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Mc.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Me.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Me.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Mn.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Mn.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_N.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_N.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_name.c": {
    "uc_general_category_name": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "const char *\nuc_general_category_name (uc_general_category_t category)\n{\n  uint32_t bitmask = category.bitmask;\n  /* bitmask should consist of a single bit.  */\n  if (bitmask != 0)\n    {\n      if ((bitmask & (bitmask - 1)) == 0)\n        {\n          int bit;\n          /* Take log2 using a variant of Robert Harley's method.\n             Found by Bruno Haible 1996.  */\n          uint32_t n = bitmask;\n          static const char ord2_tab[64] =\n            {\n              -1,  0,  1, 12,  2,  6, -1, 13,  3, -1,  7, -1, -1, -1, -1, 14,\n              10,  4, -1, -1,  8, -1, -1, 25, -1, -1, -1, -1, -1, 21, 27, 15,\n              31, 11,  5, -1, -1, -1, -1, -1,  9, -1, -1, 24, -1, -1, 20, 26,\n              30, -1, -1, -1, -1, 23, -1, 19, 29, -1, 22, 18, 28, 17, 16, -1\n            };\n          n += n << 4;\n          n += n << 6;\n          n = (n << 16) - n;\n          bit = ord2_tab[n >> 26];\n\n          if (bit < sizeof (u_category_name) / sizeof (u_category_name[0]))\n            return u_category_name[bit];\n        }\n      else\n        {\n          if (bitmask == UC_CATEGORY_MASK_L)\n            return \"L\";\n          if (bitmask == UC_CATEGORY_MASK_LC)\n            return \"LC\";\n          if (bitmask == UC_CATEGORY_MASK_M)\n            return \"M\";\n          if (bitmask == UC_CATEGORY_MASK_N)\n            return \"N\";\n          if (bitmask == UC_CATEGORY_MASK_P)\n            return \"P\";\n          if (bitmask == UC_CATEGORY_MASK_S)\n            return \"S\";\n          if (bitmask == UC_CATEGORY_MASK_Z)\n            return \"Z\";\n          if (bitmask == UC_CATEGORY_MASK_C)\n            return \"C\";\n        }\n    }\n  return NULL;\n}",
      "lines": 50,
      "depth": 14,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nuc_general_category_name (uc_general_category_t category)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Nd.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Nd.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Nl.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Nl.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_No.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_No.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_none.c": {
    "always_false": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "static bool\nalways_false (ucs4_t uc, uint32_t bitmask)\n{\n  return false;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/categ_of.c": {
    "lookup_withtable": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static inline int\nlookup_withtable (ucs4_t uc)\n{\n  unsigned int index1 = uc >> category_header_0;\n  if (index1 < category_header_1)\n    {\n      int lookup1 = u_category.level1[index1];\n      if (lookup1 >= 0)\n        {\n          unsigned int index2 = (uc >> category_header_2) & category_header_3;\n          int lookup2 = u_category.level2[lookup1 + index2];\n          if (lookup2 >= 0)\n            {\n              unsigned int index3 = ((uc & category_header_4) + lookup2) * 5;\n              /* level3 contains 5-bit values, packed into 16-bit words.  */\n              unsigned int lookup3 =\n                ((u_category.level3[index3>>4]\n                  | ((unsigned int) u_category.level3[(index3>>4)+1] << 16))\n                 >> (index3 % 16))\n                & 0x1f;\n\n              return lookup3;\n            }\n        }\n      return 29; /* = log2(UC_CATEGORY_MASK_Cn) */\n    }\n  return -1;\n}",
      "lines": 28,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "uc_is_general_category_withtable": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "bool\nuc_is_general_category_withtable (ucs4_t uc, uint32_t bitmask)\n{\n  int bit = lookup_withtable (uc);\n\n  if (bit >= 0)\n    return ((bitmask >> bit) & 1);\n  else\n    return false;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "uc_general_category": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "uc_general_category_t\nuc_general_category (ucs4_t uc)\n{\n  int bit = lookup_withtable (uc);\n  uc_general_category_t result;\n\n  if (bit >= 0)\n    {\n      result.bitmask = 1 << bit;\n      result.generic = 1;\n      result.lookup.lookup_fn = &uc_is_general_category_withtable;\n      return result;\n    }\n  else\n    return _UC_CATEGORY_NONE;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "uc_general_category_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/categ_of.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_or.c": {
    "uc_general_category_or": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "uc_general_category_t\nuc_general_category_or (uc_general_category_t category1,\n                        uc_general_category_t category2)\n{\n  uint32_t bitmask;\n  uc_general_category_t result;\n\n  bitmask = category1.bitmask | category2.bitmask;\n\n  if (bitmask == category1.bitmask)\n    return category1;\n\n  if (bitmask == category2.bitmask)\n    return category2;\n\n  result.bitmask = bitmask;\n  result.generic = 1;\n  result.lookup.lookup_fn = &uc_is_general_category_withtable;\n  return result;\n}",
      "lines": 20,
      "depth": 7,
      "decorators": [
        "uc_general_category_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/categ_P.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_P.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Pc.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Pc.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Pd.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Pd.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Pe.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Pe.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Pf.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Pf.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Pi.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Pi.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Po.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Po.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Ps.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Ps.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_S.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_S.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Sc.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Sc.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Sk.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Sk.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Sm.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Sm.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_So.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_So.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_test.c": {
    "uc_is_general_category": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_general_category (ucs4_t uc, uc_general_category_t category)\n{\n  if (category.generic)\n    return category.lookup.lookup_fn (uc, category.bitmask);\n  else\n    return bitmap_lookup (category.lookup.table, uc);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Z.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Z.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Zl.c": {
    "uc_is_category_Zl": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "static bool\nuc_is_category_Zl (ucs4_t uc)\n{\n  return (uc == 0x2028);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Zl.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Zp.c": {
    "uc_is_category_Zp": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "static bool\nuc_is_category_Zp (ucs4_t uc)\n{\n  return (uc == 0x2029);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Zp.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Zs.c": {},
  "libunistring/libunistring-0.9.10/lib/unictype/categ_Zs.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/combiningclass.c": {
    "uc_combining_class": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nuc_combining_class (ucs4_t uc)\n{\n  unsigned int index1 = uc >> combclass_header_0;\n  if (index1 < combclass_header_1)\n    {\n      int lookup1 = u_combclass.level1[index1];\n      if (lookup1 >= 0)\n        {\n          unsigned int index2 = (uc >> combclass_header_2) & combclass_header_3;\n          int lookup2 = u_combclass.level2[lookup1 + index2];\n          if (lookup2 >= 0)\n            {\n              unsigned int index3 = (uc & combclass_header_4);\n              unsigned int lookup3 = u_combclass.level3[lookup2 + index3];\n\n              return lookup3;\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/combiningclass.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/combiningclass_byname.c": {
    "uc_combining_class_byname": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nuc_combining_class_byname (const char *ccc_name)\n{\n  size_t len;\n\n  len = strlen (ccc_name);\n  if (len <= MAX_WORD_LENGTH)\n    {\n      char buf[MAX_WORD_LENGTH + 1];\n      const struct named_combining_class *found;\n\n      /* Copy ccc_name into buf, converting '_' and '-' to ' '.  */\n      {\n        const char *p = ccc_name;\n        char *q = buf;\n\n        for (;; p++, q++)\n          {\n            char c = *p;\n\n            if (c == '_' || c == '-')\n              c = ' ';\n            *q = c;\n            if (c == '\\0')\n              break;\n          }\n      }\n      /* Here q == buf + len.  */\n\n      /* Do a hash table lookup, with case-insensitive comparison.  */\n      found = uc_combining_class_lookup (buf, len);\n      if (found != NULL)\n        return found->combining_class;\n    }\n  /* Invalid combining class name.  */\n  return -1;\n}",
      "lines": 37,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/combiningclass_byname.h": {
    "gperf_case_strcmp": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static int\ngperf_case_strcmp (register const char *s1, register const char *s2)\n{\n  for (;;)\n    {\n      unsigned char c1 = gperf_downcase[(unsigned char)*s1++];\n      unsigned char c2 = gperf_downcase[(unsigned char)*s2++];\n      if (c1 != 0 && c1 == c2)\n        continue;\n      return (int)c1 - (int)c2;\n    }\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "combining_class_hash": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "static unsigned int\ncombining_class_hash (register const char *str, register size_t len)\n{\n  static const unsigned char asso_values[] =\n    {\n      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,\n      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,\n      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,\n      67, 67, 28, 67, 67, 67, 67, 67, 67, 67,\n      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,\n      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,\n      67, 67, 67, 67, 67,  4,  1, 67, 31,  1,\n      67,  2,  8,  6, 67, 47, 15, 67, 11,  1,\n      67, 67,  9,  6, 10,  3,  2, 22, 67, 13,\n      67, 67, 67, 67, 67, 67, 67,  4,  1, 67,\n      31,  1, 67,  2,  8,  6, 67, 47, 15, 67,\n      11,  1, 67, 67,  9,  6, 10,  3,  2, 22,\n      67, 13, 67, 67, 67, 67, 67, 67, 67, 67,\n      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,\n      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,\n      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,\n      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,\n      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,\n      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,\n      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,\n      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,\n      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,\n      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,\n      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,\n      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,\n      67, 67, 67, 67, 67, 67\n    };\n  register unsigned int hval = len;\n\n  switch (hval)\n    {\n      default:\n        hval += asso_values[(unsigned char)str[5]];\n      /*FALLTHROUGH*/\n      case 5:\n      case 4:\n      case 3:\n      case 2:\n      case 1:\n        hval += asso_values[(unsigned char)str[0]];\n        break;\n    }\n  return hval + asso_values[(unsigned char)str[len - 1]];\n}",
      "lines": 49,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "uc_combining_class_lookup": {
      "start_point": [
        372,
        0
      ],
      "end_point": [
        392,
        1
      ],
      "content": "const struct named_combining_class *\nuc_combining_class_lookup (register const char *str, register size_t len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register unsigned int key = combining_class_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE)\n        {\n          register int o = combining_class_names[key].name;\n          if (o >= 0)\n            {\n              register const char *s = o + combining_class_stringpool;\n\n              if ((((unsigned char)*str ^ (unsigned char)*s) & ~32) == 0 && !gperf_case_strcmp (str, s))\n                return &combining_class_names[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 20,
      "decorators": [
        "const",
        "const",
        "struct named_combining_class",
        "struct",
        "named_combining_class",
        "*\nuc_combining_class_lookup (register const char *str, register size_t len)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/combiningclass_longname.c": {
    "uc_combining_class_long_name": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "const char *\nuc_combining_class_long_name (int ccc)\n{\n  if (ccc >= 0)\n    {\n      int index;\n\n      if (ccc < 10)\n        index = u_combining_class_index_part1[ccc];\n      else if (ccc >= 200 && ccc < 241)\n        index = u_combining_class_index_part2[ccc - 200];\n      else\n        return NULL;\n\n      if (index >= 0)\n        {\n          if (index < sizeof (u_combining_class_long_name) / sizeof (u_combining_class_long_name[0]))\n            return u_combining_class_long_name[index];\n          else\n            abort ();\n        }\n    }\n  return NULL;\n}",
      "lines": 24,
      "depth": 14,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nuc_combining_class_long_name (int ccc)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/combiningclass_name.c": {
    "uc_combining_class_name": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "const char *\nuc_combining_class_name (int ccc)\n{\n  if (ccc >= 0)\n    {\n      int index;\n\n      if (ccc < 10)\n        index = u_combining_class_index_part1[ccc];\n      else if (ccc >= 200 && ccc < 241)\n        index = u_combining_class_index_part2[ccc - 200];\n      else\n        return NULL;\n\n      if (index >= 0)\n        {\n          if (index < sizeof (u_combining_class_name) / sizeof (u_combining_class_name[0]))\n            return u_combining_class_name[index];\n          else\n            abort ();\n        }\n    }\n  return NULL;\n}",
      "lines": 24,
      "depth": 14,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nuc_combining_class_name (int ccc)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/ctype_alnum.c": {
    "uc_is_alnum": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_alnum (ucs4_t uc)\n{\n  return bitmap_lookup (&u_is_alnum, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/ctype_alnum.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/ctype_alpha.c": {
    "uc_is_alpha": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_alpha (ucs4_t uc)\n{\n  return bitmap_lookup (&u_is_alpha, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/ctype_alpha.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/ctype_blank.c": {
    "uc_is_blank": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_blank (ucs4_t uc)\n{\n  return bitmap_lookup (&u_is_blank, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/ctype_blank.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/ctype_cntrl.c": {
    "uc_is_cntrl": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_cntrl (ucs4_t uc)\n{\n  return bitmap_lookup (&u_is_cntrl, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/ctype_cntrl.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/ctype_digit.c": {
    "uc_is_digit": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_digit (ucs4_t uc)\n{\n  return bitmap_lookup (&u_is_digit, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/ctype_digit.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/ctype_graph.c": {
    "uc_is_graph": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_graph (ucs4_t uc)\n{\n  return bitmap_lookup (&u_is_graph, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/ctype_graph.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/ctype_lower.c": {
    "uc_is_lower": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_lower (ucs4_t uc)\n{\n  return bitmap_lookup (&u_is_lower, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/ctype_lower.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/ctype_print.c": {
    "uc_is_print": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_print (ucs4_t uc)\n{\n  return bitmap_lookup (&u_is_print, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/ctype_print.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/ctype_punct.c": {
    "uc_is_punct": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_punct (ucs4_t uc)\n{\n  return bitmap_lookup (&u_is_punct, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/ctype_punct.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/ctype_space.c": {
    "uc_is_space": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_space (ucs4_t uc)\n{\n  return bitmap_lookup (&u_is_space, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/ctype_space.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/ctype_upper.c": {
    "uc_is_upper": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_upper (ucs4_t uc)\n{\n  return bitmap_lookup (&u_is_upper, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/ctype_upper.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/ctype_xdigit.c": {
    "uc_is_xdigit": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_xdigit (ucs4_t uc)\n{\n  return bitmap_lookup (&u_is_xdigit, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/ctype_xdigit.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/decdigit.c": {
    "uc_decimal_value": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\nuc_decimal_value (ucs4_t uc)\n{\n  unsigned int index1 = uc >> decdigit_header_0;\n  if (index1 < decdigit_header_1)\n    {\n      int lookup1 = u_decdigit.level1[index1];\n      if (lookup1 >= 0)\n        {\n          unsigned int index2 = (uc >> decdigit_header_2) & decdigit_header_3;\n          int lookup2 = u_decdigit.level2[lookup1 + index2];\n          if (lookup2 >= 0)\n            {\n              unsigned int index3 = (uc & decdigit_header_4) + lookup2;\n              /* level3 contains 4-bit values.  */\n              unsigned int lookup3 =\n                (u_decdigit.level3[index3>>1] >> ((index3 % 2) * 4)) & 0x0f;\n\n              return (int) lookup3 - 1;\n            }\n        }\n    }\n  return -1;\n}",
      "lines": 24,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/decdigit.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/digit.c": {
    "uc_digit_value": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\nuc_digit_value (ucs4_t uc)\n{\n  unsigned int index1 = uc >> digit_header_0;\n  if (index1 < digit_header_1)\n    {\n      int lookup1 = u_digit.level1[index1];\n      if (lookup1 >= 0)\n        {\n          unsigned int index2 = (uc >> digit_header_2) & digit_header_3;\n          int lookup2 = u_digit.level2[lookup1 + index2];\n          if (lookup2 >= 0)\n            {\n              unsigned int index3 = (uc & digit_header_4) + lookup2;\n              /* level3 contains 4-bit values.  */\n              unsigned int lookup3 =\n                (u_digit.level3[index3>>1] >> ((index3 % 2) * 4)) & 0x0f;\n\n              return (int) lookup3 - 1;\n            }\n        }\n    }\n  return -1;\n}",
      "lines": 24,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/digit.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/identsyntaxmap.h": {
    "identsyntax_lookup": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static inline int\nidentsyntax_lookup (ucs4_t uc)\n{\n  unsigned int index1 = uc >> identsyntax_header_0;\n  if (index1 < identsyntax_header_1)\n    {\n      int lookup1 = TABLE.level1[index1];\n      if (lookup1 >= 0)\n        {\n          unsigned int index2 = (uc >> identsyntax_header_2) & identsyntax_header_3;\n          int lookup2 = TABLE.level2[lookup1 + index2];\n          if (lookup2 >= 0)\n            {\n              unsigned int index3 = (uc & identsyntax_header_4) + lookup2;\n              /* level3 contains 2-bit values.  */\n              unsigned int lookup3 = TABLE.level3[index3 >> 3];\n\n              return (lookup3 >> (2 * (index3 & 7))) & 3;\n            }\n        }\n    }\n  return UC_IDENTIFIER_INVALID;\n}",
      "lines": 23,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/joininggroup_byname.c": {
    "uc_joining_group_byname": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nuc_joining_group_byname (const char *joining_group_name)\n{\n  size_t len;\n\n  len = strlen (joining_group_name);\n  if (len <= MAX_WORD_LENGTH)\n    {\n      char buf[MAX_WORD_LENGTH + 1];\n      const struct named_joining_group *found;\n\n      /* Copy joining_group_name into buf, converting '_' and '-' to ' '.  */\n      {\n        const char *p = joining_group_name;\n        char *q = buf;\n\n        for (;; p++, q++)\n          {\n            char c = *p;\n\n            if (c == '_' || c == '-')\n              c = ' ';\n            *q = c;\n            if (c == '\\0')\n              break;\n          }\n      }\n      /* Here q == buf + len.  */\n\n      /* Do a hash table lookup, with case-insensitive comparison.  */\n      found = uc_joining_group_lookup (buf, len);\n      if (found != NULL)\n        return found->joining_group;\n    }\n  /* Invalid joining group name.  */\n  return -1;\n}",
      "lines": 37,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/joininggroup_byname.h": {
    "gperf_case_strcmp": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static int\ngperf_case_strcmp (register const char *s1, register const char *s2)\n{\n  for (;;)\n    {\n      unsigned char c1 = gperf_downcase[(unsigned char)*s1++];\n      unsigned char c2 = gperf_downcase[(unsigned char)*s2++];\n      if (c1 != 0 && c1 == c2)\n        continue;\n      return (int)c1 - (int)c2;\n    }\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "joining_group_hash": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "static unsigned int\njoining_group_hash (register const char *str, register size_t len)\n{\n  static const unsigned short asso_values[] =\n    {\n      319, 319, 319, 319, 319, 319, 319, 319, 319, 319,\n      319, 319, 319, 319, 319, 319, 319, 319, 319, 319,\n      319, 319, 319, 319, 319, 319, 319, 319, 319, 319,\n      319, 319,   8,   5, 319, 319, 319, 319, 319, 319,\n      319, 319, 319, 319, 319, 319, 319, 319, 319, 319,\n      319, 319, 319, 319, 319, 319, 319, 319, 319, 319,\n      319, 319, 319, 319, 319,  11,  20,   2, 113,   5,\n        5,  59,   2,   5, 125, 155,  14,   8,  80,  41,\n       29, 140, 125,  23,  50,  56,  32,  47,  17,  53,\n      104,   2, 319, 319, 319, 319, 319,  11,  20,   2,\n      113,   5,   5,  59,   2,   5, 125, 155,  14,   8,\n       80,  41,  29, 140, 125,  23,  50,  56,  32,  47,\n       17,  53, 104,   2, 319, 319, 319, 319, 319, 319,\n      319, 319, 319, 319, 319, 319, 319, 319, 319, 319,\n      319, 319, 319, 319, 319, 319, 319, 319, 319, 319,\n      319, 319, 319, 319, 319, 319, 319, 319, 319, 319,\n      319, 319, 319, 319, 319, 319, 319, 319, 319, 319,\n      319, 319, 319, 319, 319, 319, 319, 319, 319, 319,\n      319, 319, 319, 319, 319, 319, 319, 319, 319, 319,\n      319, 319, 319, 319, 319, 319, 319, 319, 319, 319,\n      319, 319, 319, 319, 319, 319, 319, 319, 319, 319,\n      319, 319, 319, 319, 319, 319, 319, 319, 319, 319,\n      319, 319, 319, 319, 319, 319, 319, 319, 319, 319,\n      319, 319, 319, 319, 319, 319, 319, 319, 319, 319,\n      319, 319, 319, 319, 319, 319, 319, 319, 319, 319,\n      319, 319, 319, 319, 319, 319, 319\n    };\n  register unsigned int hval = len;\n\n  switch (hval)\n    {\n      default:\n        hval += asso_values[(unsigned char)str[11]+1];\n      /*FALLTHROUGH*/\n      case 11:\n        hval += asso_values[(unsigned char)str[10]];\n      /*FALLTHROUGH*/\n      case 10:\n      case 9:\n      case 8:\n      case 7:\n      case 6:\n      case 5:\n      case 4:\n      case 3:\n      case 2:\n        hval += asso_values[(unsigned char)str[1]];\n      /*FALLTHROUGH*/\n      case 1:\n        hval += asso_values[(unsigned char)str[0]];\n        break;\n    }\n  return hval + asso_values[(unsigned char)str[len - 1]];\n}",
      "lines": 59,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "uc_joining_group_lookup": {
      "start_point": [
        745,
        0
      ],
      "end_point": [
        765,
        1
      ],
      "content": "const struct named_joining_group *\nuc_joining_group_lookup (register const char *str, register size_t len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register unsigned int key = joining_group_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE)\n        {\n          register int o = joining_group_names[key].name;\n          if (o >= 0)\n            {\n              register const char *s = o + joining_group_stringpool;\n\n              if ((((unsigned char)*str ^ (unsigned char)*s) & ~32) == 0 && !gperf_case_strcmp (str, s))\n                return &joining_group_names[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 20,
      "decorators": [
        "const",
        "const",
        "struct named_joining_group",
        "struct",
        "named_joining_group",
        "*\nuc_joining_group_lookup (register const char *str, register size_t len)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/joininggroup_name.c": {
    "uc_joining_group_name": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "const char *\nuc_joining_group_name (int joining_group)\n{\n  if (joining_group >= 0\n      && joining_group < sizeof (joining_group_index) / sizeof (joining_group_index[0]))\n    return joining_group_stringpool + joining_group_index[joining_group];\n  return NULL;\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nuc_joining_group_name (int joining_group)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/joininggroup_name.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/joininggroup_of.c": {
    "uc_joining_group": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nuc_joining_group (ucs4_t uc)\n{\n  unsigned int index1 = uc >> joining_group_header_0;\n  if (index1 < joining_group_header_1)\n    {\n      int lookup1 = u_joining_group.level1[index1];\n      if (lookup1 >= 0)\n        {\n          unsigned int index2 = (uc >> joining_group_header_2) & joining_group_header_3;\n          int lookup2 = u_joining_group.level2[lookup1 + index2];\n          if (lookup2 >= 0)\n            {\n              unsigned int index3 = ((uc & joining_group_header_4) + lookup2) * 7;\n              /* level3 contains 7-bit values, packed into 16-bit words.  */\n              unsigned int lookup3 =\n                ((u_joining_group.level3[index3>>4]\n                  | ((unsigned int) u_joining_group.level3[(index3>>4)+1] << 16))\n                 >> (index3 % 16))\n                & 0x7f;\n\n              return lookup3;\n            }\n        }\n    }\n  return UC_JOINING_GROUP_NONE;\n}",
      "lines": 27,
      "depth": 23,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/joininggroup_of.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/joiningtype_byname.c": {
    "uc_joining_type_byname": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nuc_joining_type_byname (const char *joining_type_name)\n{\n  size_t len;\n\n  len = strlen (joining_type_name);\n  if (len <= MAX_WORD_LENGTH)\n    {\n      char buf[MAX_WORD_LENGTH + 1];\n      const struct named_joining_type *found;\n\n      /* Copy joining_type_name into buf, converting '_' and '-' to ' '.  */\n      {\n        const char *p = joining_type_name;\n        char *q = buf;\n\n        for (;; p++, q++)\n          {\n            char c = *p;\n\n            if (c == '_' || c == '-')\n              c = ' ';\n            *q = c;\n            if (c == '\\0')\n              break;\n          }\n      }\n      /* Here q == buf + len.  */\n\n      /* Do a hash table lookup, with case-insensitive comparison.  */\n      found = uc_joining_type_lookup (buf, len);\n      if (found != NULL)\n        return found->joining_type;\n    }\n  /* Invalid joining type name.  */\n  return -1;\n}",
      "lines": 37,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/joiningtype_byname.h": {
    "gperf_case_strcmp": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static int\ngperf_case_strcmp (register const char *s1, register const char *s2)\n{\n  for (;;)\n    {\n      unsigned char c1 = gperf_downcase[(unsigned char)*s1++];\n      unsigned char c2 = gperf_downcase[(unsigned char)*s2++];\n      if (c1 != 0 && c1 == c2)\n        continue;\n      return (int)c1 - (int)c2;\n    }\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "joining_type_hash": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "static unsigned int\njoining_type_hash (register const char *str, register size_t len)\n{\n  static const unsigned char asso_values[] =\n    {\n      22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n      22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n      22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n      22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n      22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n      22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n      22, 22, 22, 22, 22, 22, 22,  3,  4, 22,\n      22, 22, 22, 22,  9, 22,  0, 22,  8, 22,\n      22, 22,  1, 22,  6,  2, 22, 22, 22, 22,\n      22, 22, 22, 22, 22, 22, 22, 22, 22,  3,\n       4, 22, 22, 22, 22, 22,  9, 22,  0, 22,\n       8, 22, 22, 22,  1, 22,  6,  2, 22, 22,\n      22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n      22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n      22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n      22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n      22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n      22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n      22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n      22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n      22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n      22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n      22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n      22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n      22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n      22, 22, 22, 22, 22, 22\n    };\n  return len + asso_values[(unsigned char)str[0]];\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "uc_joining_type_lookup": {
      "start_point": [
        207,
        0
      ],
      "end_point": [
        227,
        1
      ],
      "content": "const struct named_joining_type *\nuc_joining_type_lookup (register const char *str, register size_t len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register unsigned int key = joining_type_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE)\n        {\n          register int o = joining_type_names[key].name;\n          if (o >= 0)\n            {\n              register const char *s = o + joining_type_stringpool;\n\n              if ((((unsigned char)*str ^ (unsigned char)*s) & ~32) == 0 && !gperf_case_strcmp (str, s))\n                return &joining_type_names[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 20,
      "decorators": [
        "const",
        "const",
        "struct named_joining_type",
        "struct",
        "named_joining_type",
        "*\nuc_joining_type_lookup (register const char *str, register size_t len)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/joiningtype_longname.c": {
    "uc_joining_type_long_name": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "const char *\nuc_joining_type_long_name (int joining_type)\n{\n  if (joining_type >= 0\n      && joining_type < sizeof (u_joining_type_long_name) / sizeof (u_joining_type_long_name[0]))\n    return u_joining_type_long_name[joining_type];\n  return NULL;\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nuc_joining_type_long_name (int joining_type)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/joiningtype_name.c": {
    "uc_joining_type_name": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "const char *\nuc_joining_type_name (int joining_type)\n{\n  if (joining_type >= 0\n      && joining_type < sizeof (u_joining_type_name) / sizeof (u_joining_type_name[0]))\n    return u_joining_type_name[joining_type];\n  return NULL;\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nuc_joining_type_name (int joining_type)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/joiningtype_of.c": {
    "uc_joining_type": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\nuc_joining_type (ucs4_t uc)\n{\n  unsigned int index1 = uc >> joining_type_header_0;\n  if (index1 < joining_type_header_1)\n    {\n      int lookup1 = u_joining_type.level1[index1];\n      if (lookup1 >= 0)\n        {\n          unsigned int index2 = (uc >> joining_type_header_2) & joining_type_header_3;\n          int lookup2 = u_joining_type.level2[lookup1 + index2];\n          if (lookup2 >= 0)\n            {\n              unsigned int index3 = (uc & joining_type_header_4) + lookup2;\n              /* level3 contains 4-bit values.  */\n              unsigned int lookup3 =\n                (u_joining_type.level3[index3>>1] >> ((index3 % 2) * 4))\n                & 0x0f;\n\n              if (lookup3 != 0x0f)\n                return lookup3;\n            }\n        }\n    }\n  if (uc_is_general_category_withtable\n       (uc, UC_CATEGORY_MASK_Mn | UC_CATEGORY_MASK_Me | UC_CATEGORY_MASK_Cf))\n    return UC_JOINING_TYPE_T;\n  return UC_JOINING_TYPE_U;\n}",
      "lines": 29,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/joiningtype_of.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/mirror.c": {
    "uc_mirror_char": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "bool\nuc_mirror_char (ucs4_t uc, ucs4_t *puc)\n{\n  unsigned int index1 = uc >> mirror_header_0;\n  if (index1 < mirror_header_1)\n    {\n      int lookup1 = u_mirror.level1[index1];\n      if (lookup1 >= 0)\n        {\n          unsigned int index2 = (uc >> mirror_header_2) & mirror_header_3;\n          int lookup2 = u_mirror.level2[lookup1 + index2];\n          if (lookup2 >= 0)\n            {\n              unsigned int index3 = (uc & mirror_header_4);\n              int lookup3 = u_mirror.level3[lookup2 + index3];\n\n              *puc = uc + lookup3;\n              return (lookup3 != 0);\n            }\n        }\n    }\n  *puc = uc;\n  return false;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/mirror.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/numeric.c": {
    "uc_numeric_value": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "uc_fraction_t\nuc_numeric_value (ucs4_t uc)\n{\n  unsigned int index1 = uc >> numeric_header_0;\n  if (index1 < numeric_header_1)\n    {\n      int lookup1 = u_numeric.level1[index1];\n      if (lookup1 >= 0)\n        {\n          unsigned int index2 = (uc >> numeric_header_2) & numeric_header_3;\n          int lookup2 = u_numeric.level2[lookup1 + index2];\n          if (lookup2 >= 0)\n            {\n              unsigned int index3 = ((uc & numeric_header_4) + lookup2) * 8;\n              /* level3 contains 8-bit values, packed into 16-bit words.  */\n              unsigned int lookup3 =\n                ((u_numeric.level3[index3>>4]\n                  | (u_numeric.level3[(index3>>4)+1] << 16))\n                 >> (index3 % 16))\n                & 0xff;\n\n              return u_numeric_values[lookup3];\n            }\n        }\n    }\n  {\n    const uc_fraction_t default_value = { 0, 0 };\n    return default_value;\n  }\n}",
      "lines": 30,
      "depth": 22,
      "decorators": [
        "uc_fraction_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/numeric.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_alphabetic.c": {
    "uc_is_property_alphabetic": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_alphabetic (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_alphabetic, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_alphabetic.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_ascii_hex_digit.c": {
    "uc_is_property_ascii_hex_digit": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_ascii_hex_digit (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_ascii_hex_digit, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_ascii_hex_digit.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_arabic_digit.c": {
    "uc_is_property_bidi_arabic_digit": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          42,
          1
        ],
        "content": "bool\nuc_is_property_bidi_arabic_digit (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_bidi_arabic_digit, uc);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "bool\nuc_is_property_bidi_arabic_digit (ucs4_t uc)\n{\n  return (uc_bidi_category (uc) == UC_BIDI_AN);\n}",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "bool"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_arabic_digit.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_arabic_right_to_left.c": {
    "uc_is_property_bidi_arabic_right_to_left": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          42,
          1
        ],
        "content": "bool\nuc_is_property_bidi_arabic_right_to_left (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_bidi_arabic_right_to_left, uc);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "bool\nuc_is_property_bidi_arabic_right_to_left (ucs4_t uc)\n{\n  return (uc_bidi_category (uc) == UC_BIDI_AL);\n}",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "bool"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_arabic_right_to_left.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_block_separator.c": {
    "uc_is_property_bidi_block_separator": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          42,
          1
        ],
        "content": "bool\nuc_is_property_bidi_block_separator (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_bidi_block_separator, uc);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "bool\nuc_is_property_bidi_block_separator (ucs4_t uc)\n{\n  return (uc_bidi_category (uc) == UC_BIDI_B);\n}",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "bool"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_block_separator.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_boundary_neutral.c": {
    "uc_is_property_bidi_boundary_neutral": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          42,
          1
        ],
        "content": "bool\nuc_is_property_bidi_boundary_neutral (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_bidi_boundary_neutral, uc);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "bool\nuc_is_property_bidi_boundary_neutral (ucs4_t uc)\n{\n  return (uc_bidi_category (uc) == UC_BIDI_BN);\n}",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "bool"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_boundary_neutral.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_common_separator.c": {
    "uc_is_property_bidi_common_separator": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          42,
          1
        ],
        "content": "bool\nuc_is_property_bidi_common_separator (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_bidi_common_separator, uc);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "bool\nuc_is_property_bidi_common_separator (ucs4_t uc)\n{\n  return (uc_bidi_category (uc) == UC_BIDI_CS);\n}",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "bool"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_common_separator.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_control.c": {
    "uc_is_property_bidi_control": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_bidi_control (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_bidi_control, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_control.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_embedding_or_override.c": {
    "uc_is_property_bidi_embedding_or_override": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          42,
          1
        ],
        "content": "bool\nuc_is_property_bidi_embedding_or_override (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_bidi_embedding_or_override, uc);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          52,
          1
        ],
        "content": "bool\nuc_is_property_bidi_embedding_or_override (ucs4_t uc)\n{\n  int category = uc_bidi_category (uc);\n  return (category == UC_BIDI_LRE || category == UC_BIDI_LRO\n          || category == UC_BIDI_RLE || category == UC_BIDI_RLO);\n}",
        "lines": 7,
        "depth": 9,
        "decorators": [
          "bool"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_embedding_or_override.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_european_digit.c": {
    "uc_is_property_bidi_european_digit": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          42,
          1
        ],
        "content": "bool\nuc_is_property_bidi_european_digit (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_bidi_european_digit, uc);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "bool\nuc_is_property_bidi_european_digit (ucs4_t uc)\n{\n  return (uc_bidi_category (uc) == UC_BIDI_EN);\n}",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "bool"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_european_digit.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_eur_num_separator.c": {
    "uc_is_property_bidi_eur_num_separator": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          42,
          1
        ],
        "content": "bool\nuc_is_property_bidi_eur_num_separator (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_bidi_eur_num_separator, uc);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "bool\nuc_is_property_bidi_eur_num_separator (ucs4_t uc)\n{\n  return (uc_bidi_category (uc) == UC_BIDI_ES);\n}",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "bool"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_eur_num_separator.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_eur_num_terminator.c": {
    "uc_is_property_bidi_eur_num_terminator": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          42,
          1
        ],
        "content": "bool\nuc_is_property_bidi_eur_num_terminator (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_bidi_eur_num_terminator, uc);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "bool\nuc_is_property_bidi_eur_num_terminator (ucs4_t uc)\n{\n  return (uc_bidi_category (uc) == UC_BIDI_ET);\n}",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "bool"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_eur_num_terminator.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_hebrew_right_to_left.c": {
    "uc_is_property_bidi_hebrew_right_to_left": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          42,
          1
        ],
        "content": "bool\nuc_is_property_bidi_hebrew_right_to_left (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_bidi_hebrew_right_to_left, uc);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "bool\nuc_is_property_bidi_hebrew_right_to_left (ucs4_t uc)\n{\n  return (uc_bidi_category (uc) == UC_BIDI_R);\n}",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "bool"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_hebrew_right_to_left.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_left_to_right.c": {
    "uc_is_property_bidi_left_to_right": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          42,
          1
        ],
        "content": "bool\nuc_is_property_bidi_left_to_right (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_bidi_left_to_right, uc);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "bool\nuc_is_property_bidi_left_to_right (ucs4_t uc)\n{\n  return (uc_bidi_category (uc) == UC_BIDI_L);\n}",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "bool"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_left_to_right.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_non_spacing_mark.c": {
    "uc_is_property_bidi_non_spacing_mark": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          42,
          1
        ],
        "content": "bool\nuc_is_property_bidi_non_spacing_mark (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_bidi_non_spacing_mark, uc);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "bool\nuc_is_property_bidi_non_spacing_mark (ucs4_t uc)\n{\n  return (uc_bidi_category (uc) == UC_BIDI_NSM);\n}",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "bool"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_non_spacing_mark.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_other_neutral.c": {
    "uc_is_property_bidi_other_neutral": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          42,
          1
        ],
        "content": "bool\nuc_is_property_bidi_other_neutral (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_bidi_other_neutral, uc);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "bool\nuc_is_property_bidi_other_neutral (ucs4_t uc)\n{\n  return (uc_bidi_category (uc) == UC_BIDI_ON);\n}",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "bool"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_other_neutral.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_pdf.c": {
    "uc_is_property_bidi_pdf": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          42,
          1
        ],
        "content": "bool\nuc_is_property_bidi_pdf (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_bidi_pdf, uc);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "bool\nuc_is_property_bidi_pdf (ucs4_t uc)\n{\n  return (uc_bidi_category (uc) == UC_BIDI_PDF);\n}",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "bool"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_pdf.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_segment_separator.c": {
    "uc_is_property_bidi_segment_separator": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          42,
          1
        ],
        "content": "bool\nuc_is_property_bidi_segment_separator (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_bidi_segment_separator, uc);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "bool\nuc_is_property_bidi_segment_separator (ucs4_t uc)\n{\n  return (uc_bidi_category (uc) == UC_BIDI_S);\n}",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "bool"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_segment_separator.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_whitespace.c": {
    "uc_is_property_bidi_whitespace": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          42,
          1
        ],
        "content": "bool\nuc_is_property_bidi_whitespace (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_bidi_whitespace, uc);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "bool\nuc_is_property_bidi_whitespace (ucs4_t uc)\n{\n  return (uc_bidi_category (uc) == UC_BIDI_WS);\n}",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "bool"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_bidi_whitespace.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_byname.c": {
    "uc_property_byname": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        347,
        1
      ],
      "content": "uc_property_t\nuc_property_byname (const char *property_name)\n{\n  char buf[MAX_WORD_LENGTH + 1];\n  const char *cp;\n  char *bp;\n  unsigned int count;\n  const struct named_property *found;\n\n  for (cp = property_name, bp = buf, count = MAX_WORD_LENGTH + 1; ; cp++, bp++)\n    {\n      unsigned char c = (unsigned char) *cp;\n      if (c >= 0x80)\n        goto invalid;\n      if (c >= 'A' && c <= 'Z')\n        c += 'a' - 'A';\n      else if (c == ' ' || c == '-')\n        c = '_';\n      *bp = c;\n      if (c == '\\0')\n        break;\n      if (--count == 0)\n        goto invalid;\n    }\n  found = uc_property_lookup (buf, bp - buf);\n  if (found != NULL)\n    /* Use a 'switch' statement here, because a table would introduce load-time\n       relocations.  */\n    switch (found->property_index)\n      {\n      case UC_PROPERTY_INDEX_WHITE_SPACE:\n        return UC_PROPERTY_WHITE_SPACE;\n      case UC_PROPERTY_INDEX_ALPHABETIC:\n        return UC_PROPERTY_ALPHABETIC;\n      case UC_PROPERTY_INDEX_OTHER_ALPHABETIC:\n        return UC_PROPERTY_OTHER_ALPHABETIC;\n      case UC_PROPERTY_INDEX_NOT_A_CHARACTER:\n        return UC_PROPERTY_NOT_A_CHARACTER;\n      case UC_PROPERTY_INDEX_DEFAULT_IGNORABLE_CODE_POINT:\n        return UC_PROPERTY_DEFAULT_IGNORABLE_CODE_POINT;\n      case UC_PROPERTY_INDEX_OTHER_DEFAULT_IGNORABLE_CODE_POINT:\n        return UC_PROPERTY_OTHER_DEFAULT_IGNORABLE_CODE_POINT;\n      case UC_PROPERTY_INDEX_DEPRECATED:\n        return UC_PROPERTY_DEPRECATED;\n      case UC_PROPERTY_INDEX_LOGICAL_ORDER_EXCEPTION:\n        return UC_PROPERTY_LOGICAL_ORDER_EXCEPTION;\n      case UC_PROPERTY_INDEX_VARIATION_SELECTOR:\n        return UC_PROPERTY_VARIATION_SELECTOR;\n      case UC_PROPERTY_INDEX_PRIVATE_USE:\n        return UC_PROPERTY_PRIVATE_USE;\n      case UC_PROPERTY_INDEX_UNASSIGNED_CODE_VALUE:\n        return UC_PROPERTY_UNASSIGNED_CODE_VALUE;\n      case UC_PROPERTY_INDEX_UPPERCASE:\n        return UC_PROPERTY_UPPERCASE;\n      case UC_PROPERTY_INDEX_OTHER_UPPERCASE:\n        return UC_PROPERTY_OTHER_UPPERCASE;\n      case UC_PROPERTY_INDEX_LOWERCASE:\n        return UC_PROPERTY_LOWERCASE;\n      case UC_PROPERTY_INDEX_OTHER_LOWERCASE:\n        return UC_PROPERTY_OTHER_LOWERCASE;\n      case UC_PROPERTY_INDEX_TITLECASE:\n        return UC_PROPERTY_TITLECASE;\n      case UC_PROPERTY_INDEX_CASED:\n        return UC_PROPERTY_CASED;\n      case UC_PROPERTY_INDEX_CASE_IGNORABLE:\n        return UC_PROPERTY_CASE_IGNORABLE;\n      case UC_PROPERTY_INDEX_CHANGES_WHEN_LOWERCASED:\n        return UC_PROPERTY_CHANGES_WHEN_LOWERCASED;\n      case UC_PROPERTY_INDEX_CHANGES_WHEN_UPPERCASED:\n        return UC_PROPERTY_CHANGES_WHEN_UPPERCASED;\n      case UC_PROPERTY_INDEX_CHANGES_WHEN_TITLECASED:\n        return UC_PROPERTY_CHANGES_WHEN_TITLECASED;\n      case UC_PROPERTY_INDEX_CHANGES_WHEN_CASEFOLDED:\n        return UC_PROPERTY_CHANGES_WHEN_CASEFOLDED;\n      case UC_PROPERTY_INDEX_CHANGES_WHEN_CASEMAPPED:\n        return UC_PROPERTY_CHANGES_WHEN_CASEMAPPED;\n      case UC_PROPERTY_INDEX_SOFT_DOTTED:\n        return UC_PROPERTY_SOFT_DOTTED;\n      case UC_PROPERTY_INDEX_ID_START:\n        return UC_PROPERTY_ID_START;\n      case UC_PROPERTY_INDEX_OTHER_ID_START:\n        return UC_PROPERTY_OTHER_ID_START;\n      case UC_PROPERTY_INDEX_ID_CONTINUE:\n        return UC_PROPERTY_ID_CONTINUE;\n      case UC_PROPERTY_INDEX_OTHER_ID_CONTINUE:\n        return UC_PROPERTY_OTHER_ID_CONTINUE;\n      case UC_PROPERTY_INDEX_XID_START:\n        return UC_PROPERTY_XID_START;\n      case UC_PROPERTY_INDEX_XID_CONTINUE:\n        return UC_PROPERTY_XID_CONTINUE;\n      case UC_PROPERTY_INDEX_PATTERN_WHITE_SPACE:\n        return UC_PROPERTY_PATTERN_WHITE_SPACE;\n      case UC_PROPERTY_INDEX_PATTERN_SYNTAX:\n        return UC_PROPERTY_PATTERN_SYNTAX;\n      case UC_PROPERTY_INDEX_JOIN_CONTROL:\n        return UC_PROPERTY_JOIN_CONTROL;\n      case UC_PROPERTY_INDEX_GRAPHEME_BASE:\n        return UC_PROPERTY_GRAPHEME_BASE;\n      case UC_PROPERTY_INDEX_GRAPHEME_EXTEND:\n        return UC_PROPERTY_GRAPHEME_EXTEND;\n      case UC_PROPERTY_INDEX_OTHER_GRAPHEME_EXTEND:\n        return UC_PROPERTY_OTHER_GRAPHEME_EXTEND;\n      case UC_PROPERTY_INDEX_GRAPHEME_LINK:\n        return UC_PROPERTY_GRAPHEME_LINK;\n      case UC_PROPERTY_INDEX_BIDI_CONTROL:\n        return UC_PROPERTY_BIDI_CONTROL;\n      case UC_PROPERTY_INDEX_BIDI_LEFT_TO_RIGHT:\n        return UC_PROPERTY_BIDI_LEFT_TO_RIGHT;\n      case UC_PROPERTY_INDEX_BIDI_HEBREW_RIGHT_TO_LEFT:\n        return UC_PROPERTY_BIDI_HEBREW_RIGHT_TO_LEFT;\n      case UC_PROPERTY_INDEX_BIDI_ARABIC_RIGHT_TO_LEFT:\n        return UC_PROPERTY_BIDI_ARABIC_RIGHT_TO_LEFT;\n      case UC_PROPERTY_INDEX_BIDI_EUROPEAN_DIGIT:\n        return UC_PROPERTY_BIDI_EUROPEAN_DIGIT;\n      case UC_PROPERTY_INDEX_BIDI_EUR_NUM_SEPARATOR:\n        return UC_PROPERTY_BIDI_EUR_NUM_SEPARATOR;\n      case UC_PROPERTY_INDEX_BIDI_EUR_NUM_TERMINATOR:\n        return UC_PROPERTY_BIDI_EUR_NUM_TERMINATOR;\n      case UC_PROPERTY_INDEX_BIDI_ARABIC_DIGIT:\n        return UC_PROPERTY_BIDI_ARABIC_DIGIT;\n      case UC_PROPERTY_INDEX_BIDI_COMMON_SEPARATOR:\n        return UC_PROPERTY_BIDI_COMMON_SEPARATOR;\n      case UC_PROPERTY_INDEX_BIDI_BLOCK_SEPARATOR:\n        return UC_PROPERTY_BIDI_BLOCK_SEPARATOR;\n      case UC_PROPERTY_INDEX_BIDI_SEGMENT_SEPARATOR:\n        return UC_PROPERTY_BIDI_SEGMENT_SEPARATOR;\n      case UC_PROPERTY_INDEX_BIDI_WHITESPACE:\n        return UC_PROPERTY_BIDI_WHITESPACE;\n      case UC_PROPERTY_INDEX_BIDI_NON_SPACING_MARK:\n        return UC_PROPERTY_BIDI_NON_SPACING_MARK;\n      case UC_PROPERTY_INDEX_BIDI_BOUNDARY_NEUTRAL:\n        return UC_PROPERTY_BIDI_BOUNDARY_NEUTRAL;\n      case UC_PROPERTY_INDEX_BIDI_PDF:\n        return UC_PROPERTY_BIDI_PDF;\n      case UC_PROPERTY_INDEX_BIDI_EMBEDDING_OR_OVERRIDE:\n        return UC_PROPERTY_BIDI_EMBEDDING_OR_OVERRIDE;\n      case UC_PROPERTY_INDEX_BIDI_OTHER_NEUTRAL:\n        return UC_PROPERTY_BIDI_OTHER_NEUTRAL;\n      case UC_PROPERTY_INDEX_HEX_DIGIT:\n        return UC_PROPERTY_HEX_DIGIT;\n      case UC_PROPERTY_INDEX_ASCII_HEX_DIGIT:\n        return UC_PROPERTY_ASCII_HEX_DIGIT;\n      case UC_PROPERTY_INDEX_IDEOGRAPHIC:\n        return UC_PROPERTY_IDEOGRAPHIC;\n      case UC_PROPERTY_INDEX_UNIFIED_IDEOGRAPH:\n        return UC_PROPERTY_UNIFIED_IDEOGRAPH;\n      case UC_PROPERTY_INDEX_RADICAL:\n        return UC_PROPERTY_RADICAL;\n      case UC_PROPERTY_INDEX_IDS_BINARY_OPERATOR:\n        return UC_PROPERTY_IDS_BINARY_OPERATOR;\n      case UC_PROPERTY_INDEX_IDS_TRINARY_OPERATOR:\n        return UC_PROPERTY_IDS_TRINARY_OPERATOR;\n      case UC_PROPERTY_INDEX_ZERO_WIDTH:\n        return UC_PROPERTY_ZERO_WIDTH;\n      case UC_PROPERTY_INDEX_SPACE:\n        return UC_PROPERTY_SPACE;\n      case UC_PROPERTY_INDEX_NON_BREAK:\n        return UC_PROPERTY_NON_BREAK;\n      case UC_PROPERTY_INDEX_ISO_CONTROL:\n        return UC_PROPERTY_ISO_CONTROL;\n      case UC_PROPERTY_INDEX_FORMAT_CONTROL:\n        return UC_PROPERTY_FORMAT_CONTROL;\n      case UC_PROPERTY_INDEX_DASH:\n        return UC_PROPERTY_DASH;\n      case UC_PROPERTY_INDEX_HYPHEN:\n        return UC_PROPERTY_HYPHEN;\n      case UC_PROPERTY_INDEX_PUNCTUATION:\n        return UC_PROPERTY_PUNCTUATION;\n      case UC_PROPERTY_INDEX_LINE_SEPARATOR:\n        return UC_PROPERTY_LINE_SEPARATOR;\n      case UC_PROPERTY_INDEX_PARAGRAPH_SEPARATOR:\n        return UC_PROPERTY_PARAGRAPH_SEPARATOR;\n      case UC_PROPERTY_INDEX_QUOTATION_MARK:\n        return UC_PROPERTY_QUOTATION_MARK;\n      case UC_PROPERTY_INDEX_SENTENCE_TERMINAL:\n        return UC_PROPERTY_SENTENCE_TERMINAL;\n      case UC_PROPERTY_INDEX_TERMINAL_PUNCTUATION:\n        return UC_PROPERTY_TERMINAL_PUNCTUATION;\n      case UC_PROPERTY_INDEX_CURRENCY_SYMBOL:\n        return UC_PROPERTY_CURRENCY_SYMBOL;\n      case UC_PROPERTY_INDEX_MATH:\n        return UC_PROPERTY_MATH;\n      case UC_PROPERTY_INDEX_OTHER_MATH:\n        return UC_PROPERTY_OTHER_MATH;\n      case UC_PROPERTY_INDEX_PAIRED_PUNCTUATION:\n        return UC_PROPERTY_PAIRED_PUNCTUATION;\n      case UC_PROPERTY_INDEX_LEFT_OF_PAIR:\n        return UC_PROPERTY_LEFT_OF_PAIR;\n      case UC_PROPERTY_INDEX_COMBINING:\n        return UC_PROPERTY_COMBINING;\n      case UC_PROPERTY_INDEX_COMPOSITE:\n        return UC_PROPERTY_COMPOSITE;\n      case UC_PROPERTY_INDEX_DECIMAL_DIGIT:\n        return UC_PROPERTY_DECIMAL_DIGIT;\n      case UC_PROPERTY_INDEX_NUMERIC:\n        return UC_PROPERTY_NUMERIC;\n      case UC_PROPERTY_INDEX_DIACRITIC:\n        return UC_PROPERTY_DIACRITIC;\n      case UC_PROPERTY_INDEX_EXTENDER:\n        return UC_PROPERTY_EXTENDER;\n      case UC_PROPERTY_INDEX_IGNORABLE_CONTROL:\n        return UC_PROPERTY_IGNORABLE_CONTROL;\n      default:\n        abort ();\n      }\n invalid:\n  return UC_PROPERTY_NONE;\n}",
      "lines": 208,
      "depth": 11,
      "decorators": [
        "uc_property_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_byname.h": {
    "properties_hash": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "static unsigned int\nproperties_hash (register const char *str, register size_t len)\n{\n  static const unsigned short asso_values[] =\n    {\n      620, 620, 620, 620, 620, 620, 620, 620, 620, 620,\n      620, 620, 620, 620, 620, 620, 620, 620, 620, 620,\n      620, 620, 620, 620, 620, 620, 620, 620, 620, 620,\n      620, 620, 620, 620, 620, 620, 620, 620, 620, 620,\n      620, 620, 620, 620, 620, 620, 620, 620, 620, 620,\n      620, 620, 620, 620, 620, 620, 620, 620, 620, 620,\n      620, 620, 620, 620, 620, 620, 620, 620, 620, 620,\n      620, 620, 620, 620, 620, 620, 620, 620, 620, 620,\n      620, 620, 620, 620, 620, 620, 620, 620, 620, 620,\n      620, 620, 620, 620, 620, 110, 620,  29,  17, 101,\n        2,   2, 167, 230,  92,   2,  65,  62,  41, 152,\n       74,   2, 104,  14,  14,  20,   5,  80,  41, 140,\n      181,  68,  35, 620, 620, 620, 620, 620\n    };\n  register unsigned int hval = len;\n\n  switch (hval)\n    {\n      default:\n        hval += asso_values[(unsigned char)str[17]];\n      /*FALLTHROUGH*/\n      case 17:\n      case 16:\n      case 15:\n      case 14:\n        hval += asso_values[(unsigned char)str[13]];\n      /*FALLTHROUGH*/\n      case 13:\n      case 12:\n      case 11:\n      case 10:\n      case 9:\n      case 8:\n        hval += asso_values[(unsigned char)str[7]];\n      /*FALLTHROUGH*/\n      case 7:\n      case 6:\n      case 5:\n      case 4:\n      case 3:\n      case 2:\n        hval += asso_values[(unsigned char)str[1]];\n      /*FALLTHROUGH*/\n      case 1:\n        hval += asso_values[(unsigned char)str[0]];\n        break;\n    }\n  return hval + asso_values[(unsigned char)str[len - 1]];\n}",
      "lines": 54,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "uc_property_lookup": {
      "start_point": [
        1058,
        0
      ],
      "end_point": [
        1078,
        1
      ],
      "content": "const struct named_property *\nuc_property_lookup (register const char *str, register size_t len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register unsigned int key = properties_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE)\n        {\n          register int o = properties[key].name;\n          if (o >= 0)\n            {\n              register const char *s = o + properties_stringpool;\n\n              if (*str == *s && !strcmp (str + 1, s + 1))\n                return &properties[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "struct named_property",
        "struct",
        "named_property",
        "*\nuc_property_lookup (register const char *str, register size_t len)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_cased.c": {
    "uc_is_property_cased": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_cased (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_cased, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_cased.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_case_ignorable.c": {
    "uc_is_property_case_ignorable": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_case_ignorable (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_case_ignorable, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_case_ignorable.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_changes_when_casefolded.c": {
    "uc_is_property_changes_when_casefolded": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_changes_when_casefolded (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_changes_when_casefolded, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_changes_when_casefolded.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_changes_when_casemapped.c": {
    "uc_is_property_changes_when_casemapped": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_changes_when_casemapped (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_changes_when_casemapped, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_changes_when_casemapped.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_changes_when_lowercased.c": {
    "uc_is_property_changes_when_lowercased": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_changes_when_lowercased (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_changes_when_lowercased, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_changes_when_lowercased.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_changes_when_titlecased.c": {
    "uc_is_property_changes_when_titlecased": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_changes_when_titlecased (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_changes_when_titlecased, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_changes_when_titlecased.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_changes_when_uppercased.c": {
    "uc_is_property_changes_when_uppercased": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_changes_when_uppercased (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_changes_when_uppercased, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_changes_when_uppercased.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_combining.c": {
    "uc_is_property_combining": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_combining (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_combining, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_combining.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_composite.c": {
    "uc_is_property_composite": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_composite (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_composite, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_composite.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_currency_symbol.c": {
    "uc_is_property_currency_symbol": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          42,
          1
        ],
        "content": "bool\nuc_is_property_currency_symbol (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_currency_symbol, uc);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "bool\nuc_is_property_currency_symbol (ucs4_t uc)\n{\n  return uc_is_general_category (uc, UC_CATEGORY_Sc);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "bool"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_currency_symbol.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_dash.c": {
    "uc_is_property_dash": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_dash (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_dash, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_dash.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_decimal_digit.c": {
    "uc_is_property_decimal_digit": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          42,
          1
        ],
        "content": "bool\nuc_is_property_decimal_digit (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_decimal_digit, uc);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "bool\nuc_is_property_decimal_digit (ucs4_t uc)\n{\n  return uc_is_general_category (uc, UC_CATEGORY_Nd);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "bool"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_decimal_digit.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_default_ignorable_code_point.c": {
    "uc_is_property_default_ignorable_code_point": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_default_ignorable_code_point (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_default_ignorable_code_point, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_default_ignorable_code_point.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_deprecated.c": {
    "uc_is_property_deprecated": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_deprecated (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_deprecated, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_deprecated.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_diacritic.c": {
    "uc_is_property_diacritic": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_diacritic (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_diacritic, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_diacritic.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_extender.c": {
    "uc_is_property_extender": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_extender (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_extender, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_extender.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_format_control.c": {
    "uc_is_property_format_control": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_format_control (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_format_control, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_format_control.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_grapheme_base.c": {
    "uc_is_property_grapheme_base": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_grapheme_base (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_grapheme_base, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_grapheme_base.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_grapheme_extend.c": {
    "uc_is_property_grapheme_extend": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_grapheme_extend (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_grapheme_extend, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_grapheme_extend.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_grapheme_link.c": {
    "uc_is_property_grapheme_link": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_grapheme_link (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_grapheme_link, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_grapheme_link.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_hex_digit.c": {
    "uc_is_property_hex_digit": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_hex_digit (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_hex_digit, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_hex_digit.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_hyphen.c": {
    "uc_is_property_hyphen": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_hyphen (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_hyphen, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_hyphen.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_ideographic.c": {
    "uc_is_property_ideographic": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_ideographic (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_ideographic, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_ideographic.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_ids_binary_operator.c": {
    "uc_is_property_ids_binary_operator": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_ids_binary_operator (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_ids_binary_operator, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_ids_binary_operator.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_ids_trinary_operator.c": {
    "uc_is_property_ids_trinary_operator": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_ids_trinary_operator (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_ids_trinary_operator, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_ids_trinary_operator.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_id_continue.c": {
    "uc_is_property_id_continue": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_id_continue (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_id_continue, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_id_continue.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_id_start.c": {
    "uc_is_property_id_start": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_id_start (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_id_start, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_id_start.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_ignorable_control.c": {
    "uc_is_property_ignorable_control": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_ignorable_control (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_ignorable_control, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_ignorable_control.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_iso_control.c": {
    "uc_is_property_iso_control": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          42,
          1
        ],
        "content": "bool\nuc_is_property_iso_control (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_iso_control, uc);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "bool\nuc_is_property_iso_control (ucs4_t uc)\n{\n  return uc_is_general_category (uc, UC_CATEGORY_Cc);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "bool"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_iso_control.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_join_control.c": {
    "uc_is_property_join_control": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          42,
          1
        ],
        "content": "bool\nuc_is_property_join_control (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_join_control, uc);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "bool\nuc_is_property_join_control (ucs4_t uc)\n{\n  return (uc >= 0x200C && uc <= 0x200D);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_join_control.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_left_of_pair.c": {
    "uc_is_property_left_of_pair": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_left_of_pair (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_left_of_pair, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_left_of_pair.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_line_separator.c": {
    "uc_is_property_line_separator": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          42,
          1
        ],
        "content": "bool\nuc_is_property_line_separator (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_line_separator, uc);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "bool\nuc_is_property_line_separator (ucs4_t uc)\n{\n  return uc_is_category_Zl (uc);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          54,
          0
        ],
        "end_point": [
          58,
          1
        ],
        "content": "bool\nuc_is_property_line_separator (ucs4_t uc)\n{\n  return (uc == 0x2028);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "bool"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_line_separator.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_logical_order_exception.c": {
    "uc_is_property_logical_order_exception": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_logical_order_exception (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_logical_order_exception, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_logical_order_exception.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_lowercase.c": {
    "uc_is_property_lowercase": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_lowercase (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_lowercase, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_lowercase.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_math.c": {
    "uc_is_property_math": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_math (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_math, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_math.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_non_break.c": {
    "uc_is_property_non_break": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_non_break (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_non_break, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_non_break.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_not_a_character.c": {
    "uc_is_property_not_a_character": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_not_a_character (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_not_a_character, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_not_a_character.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_numeric.c": {
    "uc_is_property_numeric": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_numeric (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_numeric, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_numeric.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_other_alphabetic.c": {
    "uc_is_property_other_alphabetic": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_other_alphabetic (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_other_alphabetic, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_other_alphabetic.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_other_default_ignorable_code_point.c": {
    "uc_is_property_other_default_ignorable_code_point": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_other_default_ignorable_code_point (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_other_default_ignorable_code_point, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_other_default_ignorable_code_point.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_other_grapheme_extend.c": {
    "uc_is_property_other_grapheme_extend": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_other_grapheme_extend (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_other_grapheme_extend, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_other_grapheme_extend.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_other_id_continue.c": {
    "uc_is_property_other_id_continue": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_other_id_continue (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_other_id_continue, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_other_id_continue.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_other_id_start.c": {
    "uc_is_property_other_id_start": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_other_id_start (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_other_id_start, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_other_id_start.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_other_lowercase.c": {
    "uc_is_property_other_lowercase": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_other_lowercase (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_other_lowercase, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_other_lowercase.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_other_math.c": {
    "uc_is_property_other_math": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_other_math (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_other_math, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_other_math.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_other_uppercase.c": {
    "uc_is_property_other_uppercase": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_other_uppercase (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_other_uppercase, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_other_uppercase.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_paired_punctuation.c": {
    "uc_is_property_paired_punctuation": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_paired_punctuation (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_paired_punctuation, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_paired_punctuation.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_paragraph_separator.c": {
    "uc_is_property_paragraph_separator": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          42,
          1
        ],
        "content": "bool\nuc_is_property_paragraph_separator (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_paragraph_separator, uc);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "bool\nuc_is_property_paragraph_separator (ucs4_t uc)\n{\n  return uc_is_category_Zp (uc);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          54,
          0
        ],
        "end_point": [
          58,
          1
        ],
        "content": "bool\nuc_is_property_paragraph_separator (ucs4_t uc)\n{\n  return (uc == 0x2029);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "bool"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_paragraph_separator.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_pattern_syntax.c": {
    "uc_is_property_pattern_syntax": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_pattern_syntax (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_pattern_syntax, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_pattern_syntax.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_pattern_white_space.c": {
    "uc_is_property_pattern_white_space": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_pattern_white_space (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_pattern_white_space, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_pattern_white_space.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_private_use.c": {
    "uc_is_property_private_use": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          42,
          1
        ],
        "content": "bool\nuc_is_property_private_use (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_private_use, uc);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          52,
          1
        ],
        "content": "bool\nuc_is_property_private_use (ucs4_t uc)\n{\n  return (uc >= 0xE000 && uc <= 0xF8FF)\n         || (uc >= 0xF0000 && uc <= 0xFFFFD)\n         || (uc >= 0x100000 && uc <= 0x10FFFD);\n}",
        "lines": 7,
        "depth": 9,
        "decorators": [
          "bool"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_private_use.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_punctuation.c": {
    "uc_is_property_punctuation": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          42,
          1
        ],
        "content": "bool\nuc_is_property_punctuation (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_punctuation, uc);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "bool\nuc_is_property_punctuation (ucs4_t uc)\n{\n  return uc_is_general_category (uc, UC_CATEGORY_P);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "bool"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_punctuation.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_quotation_mark.c": {
    "uc_is_property_quotation_mark": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_quotation_mark (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_quotation_mark, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_quotation_mark.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_radical.c": {
    "uc_is_property_radical": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_radical (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_radical, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_radical.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_sentence_terminal.c": {
    "uc_is_property_sentence_terminal": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_sentence_terminal (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_sentence_terminal, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_sentence_terminal.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_soft_dotted.c": {
    "uc_is_property_soft_dotted": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_soft_dotted (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_soft_dotted, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_soft_dotted.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_space.c": {
    "uc_is_property_space": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          42,
          1
        ],
        "content": "bool\nuc_is_property_space (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_space, uc);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "bool\nuc_is_property_space (ucs4_t uc)\n{\n  return uc_is_general_category (uc, UC_CATEGORY_Zs);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "bool"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_space.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_terminal_punctuation.c": {
    "uc_is_property_terminal_punctuation": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_terminal_punctuation (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_terminal_punctuation, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_terminal_punctuation.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_test.c": {
    "uc_is_property": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "bool\nuc_is_property (ucs4_t uc, uc_property_t property)\n{\n  return property.test_fn (uc);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_titlecase.c": {
    "uc_is_property_titlecase": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          42,
          1
        ],
        "content": "bool\nuc_is_property_titlecase (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_titlecase, uc);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "bool\nuc_is_property_titlecase (ucs4_t uc)\n{\n  return uc_is_general_category (uc, UC_CATEGORY_Lt);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "bool"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_titlecase.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_unassigned_code_value.c": {
    "uc_is_property_unassigned_code_value": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_unassigned_code_value (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_unassigned_code_value, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_unassigned_code_value.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_unified_ideograph.c": {
    "uc_is_property_unified_ideograph": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_unified_ideograph (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_unified_ideograph, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_unified_ideograph.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_uppercase.c": {
    "uc_is_property_uppercase": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_uppercase (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_uppercase, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_uppercase.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_variation_selector.c": {
    "uc_is_property_variation_selector": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_variation_selector (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_variation_selector, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_variation_selector.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_white_space.c": {
    "uc_is_property_white_space": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_white_space (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_white_space, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_white_space.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_xid_continue.c": {
    "uc_is_property_xid_continue": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_xid_continue (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_xid_continue, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_xid_continue.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_xid_start.c": {
    "uc_is_property_xid_start": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_xid_start (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_xid_start, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_xid_start.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/pr_zero_width.c": {
    "uc_is_property_zero_width": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_property_zero_width (ucs4_t uc)\n{\n  return bitmap_lookup (&u_property_zero_width, uc);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/pr_zero_width.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/scripts.c": {
    "uc_script": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "const uc_script_t *\nuc_script (ucs4_t uc)\n{\n  unsigned int index1 = uc >> script_header_0;\n  if (index1 < script_header_1)\n    {\n      int lookup1 = u_script.level1[index1];\n      if (lookup1 >= 0)\n        {\n          unsigned int index2 = (uc >> script_header_2) & script_header_3;\n          int lookup2 = u_script.level2[lookup1 + index2];\n          if (lookup2 >= 0)\n            {\n              unsigned int index3 = (uc & script_header_4);\n              unsigned char lookup3 = u_script.level3[lookup2 + index3];\n\n              if (lookup3 != 0xff)\n                return &scripts[lookup3];\n            }\n        }\n    }\n  return NULL;\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "const",
        "const",
        "uc_script_t",
        "*\nuc_script (ucs4_t uc)",
        "*"
      ]
    },
    "uc_script_byname": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "const uc_script_t *\nuc_script_byname (const char *script_name)\n{\n  const struct named_script *found;\n\n  found = uc_script_lookup (script_name, strlen (script_name));\n  if (found != NULL)\n    return &scripts[found->index];\n  else\n    return NULL;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "const",
        "const",
        "uc_script_t",
        "*\nuc_script_byname (const char *script_name)",
        "*"
      ]
    },
    "uc_is_script": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "bool\nuc_is_script (ucs4_t uc, const uc_script_t *script)\n{\n  return uc_script (uc) == script;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    },
    "uc_all_scripts": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "void\nuc_all_scripts (const uc_script_t **scriptsp, size_t *countp)\n{\n  *scriptsp = scripts;\n  *countp = sizeof (scripts) / sizeof (scripts[0]);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/scripts.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/scripts_byname.h": {
    "scripts_hash": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "static unsigned int\nscripts_hash (register const char *str, register size_t len)\n{\n  static const unsigned char asso_values[] =\n    {\n      211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n      211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n      211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n      211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n      211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n      211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n      211, 211, 211, 211, 211,   9,   0,  16,  40,  28,\n      211,  64,  66,  24,  68,  47,  29,   8,  71,  44,\n       16, 211,  61,  26,  19,  46, 102,  23, 211,   0,\n      211, 211, 211, 211, 211,  51, 211,   3,  54,  55,\n       36,   3,  55,  51,  36,  11,  48,  26,   6,   2,\n        0,   1,  70, 211,  16,  64,  11,  18,  46,   3,\n      211,  83, 211, 211, 211, 211, 211, 211, 211, 211,\n      211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n      211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n      211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n      211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n      211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n      211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n      211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n      211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n      211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n      211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n      211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n      211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n      211, 211, 211, 211, 211, 211\n    };\n  register unsigned int hval = len;\n\n  switch (hval)\n    {\n      default:\n        hval += asso_values[(unsigned char)str[7]];\n      /*FALLTHROUGH*/\n      case 7:\n      case 6:\n      case 5:\n        hval += asso_values[(unsigned char)str[4]];\n      /*FALLTHROUGH*/\n      case 4:\n      case 3:\n        hval += asso_values[(unsigned char)str[2]];\n      /*FALLTHROUGH*/\n      case 2:\n      case 1:\n        hval += asso_values[(unsigned char)str[0]];\n        break;\n    }\n  return hval;\n}",
      "lines": 55,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "uc_script_lookup": {
      "start_point": [
        684,
        0
      ],
      "end_point": [
        704,
        1
      ],
      "content": "const struct named_script *\nuc_script_lookup (register const char *str, register size_t len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register unsigned int key = scripts_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE)\n        {\n          register int o = script_names[key].name;\n          if (o >= 0)\n            {\n              register const char *s = o + script_stringpool;\n\n              if (*str == *s && !strcmp (str + 1, s + 1))\n                return &script_names[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "struct named_script",
        "struct",
        "named_script",
        "*\nuc_script_lookup (register const char *str, register size_t len)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/sy_c_ident.c": {
    "uc_c_ident_category": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "int\nuc_c_ident_category (ucs4_t uc)\n{\n  return identsyntax_lookup (uc);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/sy_c_ident.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/sy_c_whitespace.c": {
    "uc_is_c_whitespace": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "bool\nuc_is_c_whitespace (ucs4_t uc)\n{\n  return (uc == ' ' || (uc <= 0x000D && uc >= 0x0009));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/sy_java_ident.c": {
    "uc_java_ident_category": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "int\nuc_java_ident_category (ucs4_t uc)\n{\n  return identsyntax_lookup (uc);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unictype/sy_java_ident.h": {},
  "libunistring/libunistring-0.9.10/lib/unictype/sy_java_whitespace.c": {
    "uc_is_java_whitespace": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "bool\nuc_is_java_whitespace (ucs4_t uc)\n{\n  return (uc == ' ' || (uc <= 0x000D && uc >= 0x0009 && uc != 0x000B));\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unigbrk/gbrkprop.h": {},
  "libunistring/libunistring-0.9.10/lib/unigbrk/u-grapheme-breaks.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "void\nFUNC (const UNIT *s, size_t n, char *p)\n{\n  if (n > 0)\n    {\n      const UNIT *s_end = s + n;\n\n      /* Grapheme Cluster break property of the last character.\n         -1 at the very beginning of the string.  */\n      int last_char_prop = -1;\n\n      /* Grapheme Cluster break property of the last complex character.\n         -1 at the very beginning of the string.  */\n      int last_compchar_prop = -1;\n\n      size_t ri_count = 0;\n\n      /* Don't break inside multibyte characters.  */\n      memset (p, 0, n);\n\n      while (s < s_end)\n        {\n          ucs4_t uc;\n          int count = U_MBTOUC (&uc, s, s_end - s);\n          int prop = uc_graphemeclusterbreak_property (uc);\n\n          /* Break at the start of the string (GB1).  */\n          if (last_char_prop < 0)\n            *p = 1;\n          else\n            {\n              /* No break between CR and LF (GB3).  */\n              if (last_char_prop == GBP_CR && prop == GBP_LF)\n                /* *p = 0 */;\n              /* Break before and after newlines (GB4, GB5).  */\n              else if ((last_char_prop == GBP_CR\n                        || last_char_prop == GBP_LF\n                        || last_char_prop == GBP_CONTROL)\n                       || (prop == GBP_CR\n                           || prop == GBP_LF\n                           || prop == GBP_CONTROL))\n                *p = 1;\n              /* No break between Hangul syllable sequences (GB6, GB7, GB8).  */\n              else if ((last_char_prop == GBP_L\n                        && (prop == GBP_L\n                            || prop == GBP_V\n                            || prop == GBP_LV\n                            || prop == GBP_LVT))\n                       || ((last_char_prop == GBP_LV\n                            || last_char_prop == GBP_V)\n                           && (prop == GBP_V\n                               || prop == GBP_T))\n                       || ((last_char_prop == GBP_LVT\n                            || last_char_prop == GBP_T)\n                           && prop == GBP_T))\n                /* *p = 0 */;\n              /* No break before extending characters or ZWJ (GB9).  */\n              else if (prop == GBP_EXTEND || prop == GBP_ZWJ)\n                /* *p = 0 */;\n              /* No break before SpacingMarks (GB9a).  */\n              else if (prop == GBP_SPACINGMARK)\n                /* *p = 0 */;\n              /* No break after Prepend characters (GB9b).  */\n              else if (last_char_prop == GBP_PREPEND)\n                /* *p = 0 */;\n              /* No break within emoji modifier sequences (GB10).  */\n              else if ((last_compchar_prop == GBP_EB\n                        || last_compchar_prop == GBP_EBG)\n                       && prop == GBP_EM)\n                /* *p = 0 */;\n              /* No break within emoji zwj sequences (GB11).  */\n              else if (last_char_prop == GBP_ZWJ\n                       && (prop == GBP_GAZ\n                           || prop == GBP_EBG))\n                /* *p = 0 */;\n              /* No break between RI if there is an odd number of RI\n                 characters before (GB12, GB13).  */\n              else if (prop == GBP_RI)\n                {\n                  if (ri_count % 2 == 0)\n                    *p = 1;\n                  /* else *p = 0; */\n                }\n              /* Break everywhere (GBP999).  */\n              else\n                *p = 1;\n            }\n\n          last_char_prop = prop;\n\n          if (!(prop == GBP_EXTEND\n                && (last_compchar_prop == GBP_EB\n                    || last_compchar_prop == GBP_EBG)))\n            last_compchar_prop = prop;\n\n          if (prop == GBP_RI)\n            ri_count++;\n          else\n            ri_count = 0;\n\n          s += count;\n          p += count;\n        }\n    }\n}",
      "lines": 105,
      "depth": 23,
      "decorators": [
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unigbrk/u16-grapheme-breaks.c": {},
  "libunistring/libunistring-0.9.10/lib/unigbrk/u16-grapheme-next.c": {
    "u16_grapheme_next": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "const uint16_t *\nu16_grapheme_next (const uint16_t *s, const uint16_t *end)\n{\n  ucs4_t prev;\n  int mblen;\n\n  if (s == end)\n    return NULL;\n\n  for (s += u16_mbtouc (&prev, s, end - s); s != end; s += mblen)\n    {\n      ucs4_t next;\n\n      mblen = u16_mbtouc (&next, s, end - s);\n      if (uc_is_grapheme_break (prev, next))\n        break;\n\n      prev = next;\n    }\n\n  return s;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "uint16_t",
        "*\nu16_grapheme_next (const uint16_t *s, const uint16_t *end)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unigbrk/u16-grapheme-prev.c": {
    "u16_grapheme_prev": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "const uint16_t *\nu16_grapheme_prev (const uint16_t *s, const uint16_t *start)\n{\n  ucs4_t next;\n\n  if (s == start)\n    return NULL;\n\n  s = u16_prev (&next, s, start);\n  while (s != start)\n    {\n      const uint16_t *prev_s;\n      ucs4_t prev;\n\n      prev_s = u16_prev (&prev, s, start);\n      if (prev_s == NULL)\n        {\n          /* Ill-formed UTF-16 encoding. */\n          return start;\n        }\n\n      if (uc_is_grapheme_break (prev, next))\n        break;\n\n      s = prev_s;\n      next = prev;\n    }\n\n  return s;\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "uint16_t",
        "*\nu16_grapheme_prev (const uint16_t *s, const uint16_t *start)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unigbrk/u32-grapheme-breaks.c": {},
  "libunistring/libunistring-0.9.10/lib/unigbrk/u32-grapheme-next.c": {
    "u32_grapheme_next": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "const uint32_t *\nu32_grapheme_next (const uint32_t *s, const uint32_t *end)\n{\n  ucs4_t prev;\n\n  if (s == end)\n    return NULL;\n\n  u32_mbtouc (&prev, s, end - s);\n  for (s++; s != end; s++)\n    {\n      ucs4_t next;\n\n      u32_mbtouc (&next, s, end - s);\n      if (uc_is_grapheme_break (prev, next))\n        break;\n\n      prev = next;\n    }\n\n  return s;\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "const",
        "const",
        "uint32_t",
        "*\nu32_grapheme_next (const uint32_t *s, const uint32_t *end)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unigbrk/u32-grapheme-prev.c": {
    "u32_grapheme_prev": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "const uint32_t *\nu32_grapheme_prev (const uint32_t *s, const uint32_t *start)\n{\n  ucs4_t next;\n\n  if (s == start)\n    return NULL;\n\n  u32_prev (&next, s, start);\n  for (s--; s != start; s--)\n    {\n      ucs4_t prev;\n\n      if (u32_prev (&prev, s, start) == NULL)\n        {\n          /* Ill-formed UTF-32 encoding. */\n          return start;\n        }\n\n      if (uc_is_grapheme_break (prev, next))\n        break;\n\n      next = prev;\n    }\n\n  return s;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "const",
        "const",
        "uint32_t",
        "*\nu32_grapheme_prev (const uint32_t *s, const uint32_t *start)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unigbrk/u8-grapheme-breaks.c": {},
  "libunistring/libunistring-0.9.10/lib/unigbrk/u8-grapheme-next.c": {
    "u8_grapheme_next": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "const uint8_t *\nu8_grapheme_next (const uint8_t *s, const uint8_t *end)\n{\n  ucs4_t prev;\n  int mblen;\n\n  if (s == end)\n    return NULL;\n\n  for (s += u8_mbtouc (&prev, s, end - s); s != end; s += mblen)\n    {\n      ucs4_t next;\n\n      mblen = u8_mbtouc (&next, s, end - s);\n      if (uc_is_grapheme_break (prev, next))\n        break;\n\n      prev = next;\n    }\n\n  return s;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "uint8_t",
        "*\nu8_grapheme_next (const uint8_t *s, const uint8_t *end)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unigbrk/u8-grapheme-prev.c": {
    "u8_grapheme_prev": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "const uint8_t *\nu8_grapheme_prev (const uint8_t *s, const uint8_t *start)\n{\n  ucs4_t next;\n\n  if (s == start)\n    return NULL;\n\n  s = u8_prev (&next, s, start);\n  while (s != start)\n    {\n      const uint8_t *prev_s;\n      ucs4_t prev;\n\n      prev_s = u8_prev (&prev, s, start);\n      if (prev_s == NULL)\n        {\n          /* Ill-formed UTF-8 encoding. */\n          return start;\n        }\n\n      if (uc_is_grapheme_break (prev, next))\n        break;\n\n      s = prev_s;\n      next = prev;\n    }\n\n  return s;\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "uint8_t",
        "*\nu8_grapheme_prev (const uint8_t *s, const uint8_t *start)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unigbrk/uc-gbrk-prop.c": {
    "uc_graphemeclusterbreak_property": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "int\nuc_graphemeclusterbreak_property (ucs4_t uc)\n{\n  unsigned int index1 = uc >> gbrkprop_header_0;\n  if (index1 < gbrkprop_header_1)\n    {\n      int lookup1 = unigbrkprop.level1[index1];\n      if (lookup1 >= 0)\n        {\n          unsigned int index2 = (uc >> gbrkprop_header_2) & gbrkprop_header_3;\n          int lookup2 = unigbrkprop.level2[lookup1 + index2];\n          if (lookup2 >= 0)\n            {\n              unsigned int index3 = uc & gbrkprop_header_4;\n              return unigbrkprop.level3[lookup2 + index3];\n            }\n        }\n    }\n  return GBP_OTHER;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unigbrk/uc-grapheme-breaks.c": {
    "uc_grapheme_breaks_mbtouc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "static int\nuc_grapheme_breaks_mbtouc (ucs4_t *puc, const ucs4_t *s, size_t n)\n{\n  *puc = *s;\n  return 1;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unigbrk/uc-is-grapheme-break.c": {
    "uc_is_grapheme_break": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "bool\nuc_is_grapheme_break (ucs4_t a, ucs4_t b)\n{\n  int a_gcp, b_gcp;\n\n  if ((a | b) < 0x300)\n    {\n      /* GB3 is the only relevant rule for this case. */\n      return a != '\\r' || b != '\\n';\n    }\n\n  a_gcp = uc_graphemeclusterbreak_property (a);\n  b_gcp = uc_graphemeclusterbreak_property (b);\n  return (gb_table[a_gcp] >> b_gcp) & 1;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unigbrk/ulc-grapheme-breaks.c": {
    "is_utf8_encoding": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "static int\nis_utf8_encoding (const char *encoding)\n{\n  if (STRCASEEQ (encoding, \"UTF-8\", 'U', 'T', 'F', '-', '8', 0, 0, 0, 0))\n    return 1;\n  return 0;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ascii_grapheme_breaks": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "static void\nascii_grapheme_breaks (const char *s, size_t n, char *p)\n{\n  size_t i;\n\n  p[0] = 1;\n  for (i = 1; i < n; i++)\n    {\n      bool is_ascii = c_isprint (s[i]) || c_isspace (s[i]);\n      p[i] = is_ascii && (s[i] != '\\n' || s[i - 1] != '\\r');\n    }\n}",
      "lines": 12,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ulc_grapheme_breaks": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "void\nulc_grapheme_breaks (const char *s, size_t n, char *p)\n{\n  if (n > 0)\n    {\n      const char *encoding = locale_charset ();\n\n      if (is_utf8_encoding (encoding))\n        u8_grapheme_breaks ((const uint8_t *) s, n, p);\n      else\n        {\n          /* Convert the string to UTF-8 and build a translation table\n             from offsets into s to offsets into the translated string.  */\n          size_t *offsets = (size_t *) malloc (n * sizeof (size_t));\n\n          if (offsets != NULL)\n            {\n              uint8_t *t;\n              size_t m;\n\n              t = u8_conv_from_encoding (encoding, iconveh_question_mark,\n                                         s, n, offsets, NULL, &m);\n              if (t != NULL)\n                {\n                  char *q = (char *) (m > 0 ? malloc (m) : NULL);\n\n                  if (m == 0 || q != NULL)\n                    {\n                      size_t i;\n\n                      /* Determine the grapheme breaks of the UTF-8 string.  */\n                      u8_grapheme_breaks (t, m, q);\n\n                      /* Translate the result back to the original string.  */\n                      memset (p, 0, n);\n                      for (i = 0; i < n; i++)\n                        if (offsets[i] != (size_t)(-1))\n                          p[i] = q[offsets[i]];\n\n                      free (q);\n                      free (t);\n                      free (offsets);\n                      return;\n                    }\n                  free (t);\n                }\n              free (offsets);\n            }\n\n          /* Impossible to convert. */\n#if C_CTYPE_ASCII\n          /* Fall back to ASCII as best we can. */\n          ascii_grapheme_breaks (s, n, p);\n#else\n          /* We cannot make any assumptions. */\n          p[0] = 1;\n          memset (p + 1, 0, n - 1);\n#endif\n        }\n    }\n}",
      "lines": 61,
      "depth": 19,
      "decorators": [
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unilbrk/lbrkprop1.h": {},
  "libunistring/libunistring-0.9.10/lib/unilbrk/lbrkprop2.h": {},
  "libunistring/libunistring-0.9.10/lib/unilbrk/lbrktables.c": {},
  "libunistring/libunistring-0.9.10/lib/unilbrk/lbrktables.h": {
    "unilbrkprop_lookup": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "static inline unsigned char\nunilbrkprop_lookup (ucs4_t uc)\n{\n  unsigned int index1 = uc >> lbrkprop_header_0;\n  if (index1 < lbrkprop_header_1)\n    {\n      int lookup1 = unilbrkprop.level1[index1];\n      if (lookup1 >= 0)\n        {\n          unsigned int index2 = (uc >> lbrkprop_header_2) & lbrkprop_header_3;\n          int lookup2 = unilbrkprop.level2[lookup1 + index2];\n          if (lookup2 >= 0)\n            {\n              unsigned int index3 = uc & lbrkprop_header_4;\n              return unilbrkprop.level3[lookup2 + index3];\n            }\n        }\n    }\n  return LBP_XX;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "unsigned char",
        "unsigned",
        "char"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unilbrk/u16-possible-linebreaks.c": {
    "u16_possible_linebreaks": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "void\nu16_possible_linebreaks (const uint16_t *s, size_t n, const char *encoding, char *p)\n{\n  int LBP_AI_REPLACEMENT = (is_cjk_encoding (encoding) ? LBP_ID : LBP_AL);\n  const uint16_t *s_end = s + n;\n  int last_prop = LBP_BK; /* line break property of last non-space character */\n  char *seen_space = NULL; /* Was a space seen after the last non-space character? */\n  char *seen_space2 = NULL; /* At least two spaces after the last non-space? */\n\n  /* Don't break inside multibyte characters.  */\n  memset (p, UC_BREAK_PROHIBITED, n);\n\n  while (s < s_end)\n    {\n      ucs4_t uc;\n      int count = u16_mbtouc_unsafe (&uc, s, s_end - s);\n      int prop = unilbrkprop_lookup (uc);\n\n      if (prop == LBP_BK)\n        {\n          /* Mandatory break.  */\n          *p = UC_BREAK_MANDATORY;\n          last_prop = LBP_BK;\n          seen_space = NULL;\n          seen_space2 = NULL;\n        }\n      else\n        {\n          char *q;\n\n          /* Resolve property values whose behaviour is not fixed.  */\n          switch (prop)\n            {\n            case LBP_AI:\n              /* Resolve ambiguous.  */\n              prop = LBP_AI_REPLACEMENT;\n              break;\n            case LBP_CB:\n              /* This is arbitrary.  */\n              prop = LBP_ID;\n              break;\n            case LBP_SA:\n              /* We don't handle complex scripts yet.\n                 Treat LBP_SA like LBP_XX.  */\n            case LBP_XX:\n              /* This is arbitrary.  */\n              prop = LBP_AL;\n              break;\n            }\n\n          /* Deal with spaces and combining characters.  */\n          q = p;\n          if (prop == LBP_SP)\n            {\n              /* Don't break just before a space.  */\n              *p = UC_BREAK_PROHIBITED;\n              seen_space2 = seen_space;\n              seen_space = p;\n            }\n          else if (prop == LBP_ZW)\n            {\n              /* Don't break just before a zero-width space.  */\n              *p = UC_BREAK_PROHIBITED;\n              last_prop = LBP_ZW;\n              seen_space = NULL;\n              seen_space2 = NULL;\n            }\n          else if (prop == LBP_CM)\n            {\n              /* Don't break just before a combining character, except immediately after a\n                 zero-width space.  */\n              if (last_prop == LBP_ZW)\n                {\n                  /* Break after zero-width space.  */\n                  *p = UC_BREAK_POSSIBLE;\n                  /* A combining character turns a preceding space into LBP_ID.  */\n                  last_prop = LBP_ID;\n                }\n              else\n                {\n                  *p = UC_BREAK_PROHIBITED;\n                  /* A combining character turns a preceding space into LBP_ID.  */\n                  if (seen_space != NULL)\n                    {\n                      q = seen_space;\n                      seen_space = seen_space2;\n                      prop = LBP_ID;\n                      goto lookup_via_table;\n                    }\n                }\n            }\n          else\n            {\n             lookup_via_table:\n              /* prop must be usable as an index for table 7.3 of UTR #14.  */\n              if (!(prop >= 0 && prop < sizeof (unilbrk_table) / sizeof (unilbrk_table[0])))\n                abort ();\n\n              if (last_prop == LBP_BK)\n                {\n                  /* Don't break at the beginning of a line.  */\n                  *q = UC_BREAK_PROHIBITED;\n                }\n              else if (last_prop == LBP_ZW)\n                {\n                  /* Break after zero-width space.  */\n                  *q = UC_BREAK_POSSIBLE;\n                }\n              else\n                {\n                  switch (unilbrk_table [last_prop] [prop])\n                    {\n                    case D:\n                      *q = UC_BREAK_POSSIBLE;\n                      break;\n                    case I:\n                      *q = (seen_space != NULL ? UC_BREAK_POSSIBLE : UC_BREAK_PROHIBITED);\n                      break;\n                    case P:\n                      *q = UC_BREAK_PROHIBITED;\n                      break;\n                    default:\n                      abort ();\n                    }\n                }\n              last_prop = prop;\n              seen_space = NULL;\n              seen_space2 = NULL;\n            }\n        }\n\n      s += count;\n      p += count;\n    }\n}",
      "lines": 135,
      "depth": 22,
      "decorators": [
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unilbrk/u16-width-linebreaks.c": {
    "u16_width_linebreaks": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "int\nu16_width_linebreaks (const uint16_t *s, size_t n,\n                      int width, int start_column, int at_end_columns,\n                      const char *o, const char *encoding,\n                      char *p)\n{\n  const uint16_t *s_end;\n  char *last_p;\n  int last_column;\n  int piece_width;\n\n  u16_possible_linebreaks (s, n, encoding, p);\n\n  s_end = s + n;\n  last_p = NULL;\n  last_column = start_column;\n  piece_width = 0;\n  while (s < s_end)\n    {\n      ucs4_t uc;\n      int count = u16_mbtouc_unsafe (&uc, s, s_end - s);\n\n      /* Respect the override.  */\n      if (o != NULL && *o != UC_BREAK_UNDEFINED)\n        *p = *o;\n\n      if (*p == UC_BREAK_POSSIBLE || *p == UC_BREAK_MANDATORY)\n        {\n          /* An atomic piece of text ends here.  */\n          if (last_p != NULL && last_column + piece_width > width)\n            {\n              /* Insert a line break.  */\n              *last_p = UC_BREAK_POSSIBLE;\n              last_column = 0;\n            }\n        }\n\n      if (*p == UC_BREAK_MANDATORY)\n        {\n          /* uc is a line break character.  */\n          /* Start a new piece at column 0.  */\n          last_p = NULL;\n          last_column = 0;\n          piece_width = 0;\n        }\n      else\n        {\n          /* uc is not a line break character.  */\n          int w;\n\n          if (*p == UC_BREAK_POSSIBLE)\n            {\n              /* Start a new piece.  */\n              last_p = p;\n              last_column += piece_width;\n              piece_width = 0;\n              /* No line break for the moment, may be turned into\n                 UC_BREAK_POSSIBLE later, via last_p. */\n            }\n\n          *p = UC_BREAK_PROHIBITED;\n\n          w = uc_width (uc, encoding);\n          if (w >= 0) /* ignore control characters in the string */\n            piece_width += w;\n        }\n\n      s += count;\n      p += count;\n      if (o != NULL)\n        o += count;\n    }\n\n  /* The last atomic piece of text ends here.  */\n  if (last_p != NULL && last_column + piece_width + at_end_columns > width)\n    {\n      /* Insert a line break.  */\n      *last_p = UC_BREAK_POSSIBLE;\n      last_column = 0;\n    }\n\n  return last_column + piece_width;\n}",
      "lines": 83,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unilbrk/u32-possible-linebreaks.c": {
    "u32_possible_linebreaks": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "void\nu32_possible_linebreaks (const uint32_t *s, size_t n, const char *encoding, char *p)\n{\n  int LBP_AI_REPLACEMENT = (is_cjk_encoding (encoding) ? LBP_ID : LBP_AL);\n  const uint32_t *s_end = s + n;\n  int last_prop = LBP_BK; /* line break property of last non-space character */\n  char *seen_space = NULL; /* Was a space seen after the last non-space character? */\n  char *seen_space2 = NULL; /* At least two spaces after the last non-space? */\n\n  while (s < s_end)\n    {\n      ucs4_t uc = *s;\n      int prop = unilbrkprop_lookup (uc);\n\n      if (prop == LBP_BK)\n        {\n          /* Mandatory break.  */\n          *p = UC_BREAK_MANDATORY;\n          last_prop = LBP_BK;\n          seen_space = NULL;\n          seen_space2 = NULL;\n        }\n      else\n        {\n          char *q;\n\n          /* Resolve property values whose behaviour is not fixed.  */\n          switch (prop)\n            {\n            case LBP_AI:\n              /* Resolve ambiguous.  */\n              prop = LBP_AI_REPLACEMENT;\n              break;\n            case LBP_CB:\n              /* This is arbitrary.  */\n              prop = LBP_ID;\n              break;\n            case LBP_SA:\n              /* We don't handle complex scripts yet.\n                 Treat LBP_SA like LBP_XX.  */\n            case LBP_XX:\n              /* This is arbitrary.  */\n              prop = LBP_AL;\n              break;\n            }\n\n          /* Deal with spaces and combining characters.  */\n          q = p;\n          if (prop == LBP_SP)\n            {\n              /* Don't break just before a space.  */\n              *p = UC_BREAK_PROHIBITED;\n              seen_space2 = seen_space;\n              seen_space = p;\n            }\n          else if (prop == LBP_ZW)\n            {\n              /* Don't break just before a zero-width space.  */\n              *p = UC_BREAK_PROHIBITED;\n              last_prop = LBP_ZW;\n              seen_space = NULL;\n              seen_space2 = NULL;\n            }\n          else if (prop == LBP_CM)\n            {\n              /* Don't break just before a combining character, except immediately after a\n                 zero-width space.  */\n              if (last_prop == LBP_ZW)\n                {\n                  /* Break after zero-width space.  */\n                  *p = UC_BREAK_POSSIBLE;\n                  /* A combining character turns a preceding space into LBP_ID.  */\n                  last_prop = LBP_ID;\n                }\n              else\n                {\n                  *p = UC_BREAK_PROHIBITED;\n                  /* A combining character turns a preceding space into LBP_ID.  */\n                  if (seen_space != NULL)\n                    {\n                      q = seen_space;\n                      seen_space = seen_space2;\n                      prop = LBP_ID;\n                      goto lookup_via_table;\n                    }\n                }\n            }\n          else\n            {\n             lookup_via_table:\n              /* prop must be usable as an index for table 7.3 of UTR #14.  */\n              if (!(prop >= 0 && prop < sizeof (unilbrk_table) / sizeof (unilbrk_table[0])))\n                abort ();\n\n              if (last_prop == LBP_BK)\n                {\n                  /* Don't break at the beginning of a line.  */\n                  *q = UC_BREAK_PROHIBITED;\n                }\n              else if (last_prop == LBP_ZW)\n                {\n                  /* Break after zero-width space.  */\n                  *q = UC_BREAK_POSSIBLE;\n                }\n              else\n                {\n                  switch (unilbrk_table [last_prop] [prop])\n                    {\n                    case D:\n                      *q = UC_BREAK_POSSIBLE;\n                      break;\n                    case I:\n                      *q = (seen_space != NULL ? UC_BREAK_POSSIBLE : UC_BREAK_PROHIBITED);\n                      break;\n                    case P:\n                      *q = UC_BREAK_PROHIBITED;\n                      break;\n                    default:\n                      abort ();\n                    }\n                }\n              last_prop = prop;\n              seen_space = NULL;\n              seen_space2 = NULL;\n            }\n        }\n\n      s++;\n      p++;\n    }\n}",
      "lines": 131,
      "depth": 22,
      "decorators": [
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unilbrk/u32-width-linebreaks.c": {
    "u32_width_linebreaks": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "int\nu32_width_linebreaks (const uint32_t *s, size_t n,\n                      int width, int start_column, int at_end_columns,\n                      const char *o, const char *encoding,\n                      char *p)\n{\n  const uint32_t *s_end;\n  char *last_p;\n  int last_column;\n  int piece_width;\n\n  u32_possible_linebreaks (s, n, encoding, p);\n\n  s_end = s + n;\n  last_p = NULL;\n  last_column = start_column;\n  piece_width = 0;\n  while (s < s_end)\n    {\n      ucs4_t uc = *s;\n\n      /* Respect the override.  */\n      if (o != NULL && *o != UC_BREAK_UNDEFINED)\n        *p = *o;\n\n      if (*p == UC_BREAK_POSSIBLE || *p == UC_BREAK_MANDATORY)\n        {\n          /* An atomic piece of text ends here.  */\n          if (last_p != NULL && last_column + piece_width > width)\n            {\n              /* Insert a line break.  */\n              *last_p = UC_BREAK_POSSIBLE;\n              last_column = 0;\n            }\n        }\n\n      if (*p == UC_BREAK_MANDATORY)\n        {\n          /* uc is a line break character.  */\n          /* Start a new piece at column 0.  */\n          last_p = NULL;\n          last_column = 0;\n          piece_width = 0;\n        }\n      else\n        {\n          /* uc is not a line break character.  */\n          int w;\n\n          if (*p == UC_BREAK_POSSIBLE)\n            {\n              /* Start a new piece.  */\n              last_p = p;\n              last_column += piece_width;\n              piece_width = 0;\n              /* No line break for the moment, may be turned into\n                 UC_BREAK_POSSIBLE later, via last_p. */\n            }\n\n          *p = UC_BREAK_PROHIBITED;\n\n          w = uc_width (uc, encoding);\n          if (w >= 0) /* ignore control characters in the string */\n            piece_width += w;\n        }\n\n      s++;\n      p++;\n      if (o != NULL)\n        o++;\n    }\n\n  /* The last atomic piece of text ends here.  */\n  if (last_p != NULL && last_column + piece_width + at_end_columns > width)\n    {\n      /* Insert a line break.  */\n      *last_p = UC_BREAK_POSSIBLE;\n      last_column = 0;\n    }\n\n  return last_column + piece_width;\n}",
      "lines": 82,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unilbrk/u8-possible-linebreaks.c": {
    "u8_possible_linebreaks": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "void\nu8_possible_linebreaks (const uint8_t *s, size_t n, const char *encoding, char *p)\n{\n  int LBP_AI_REPLACEMENT = (is_cjk_encoding (encoding) ? LBP_ID : LBP_AL);\n  const uint8_t *s_end = s + n;\n  int last_prop = LBP_BK; /* line break property of last non-space character */\n  char *seen_space = NULL; /* Was a space seen after the last non-space character? */\n  char *seen_space2 = NULL; /* At least two spaces after the last non-space? */\n\n  /* Don't break inside multibyte characters.  */\n  memset (p, UC_BREAK_PROHIBITED, n);\n\n  while (s < s_end)\n    {\n      ucs4_t uc;\n      int count = u8_mbtouc_unsafe (&uc, s, s_end - s);\n      int prop = unilbrkprop_lookup (uc);\n\n      if (prop == LBP_BK)\n        {\n          /* Mandatory break.  */\n          *p = UC_BREAK_MANDATORY;\n          last_prop = LBP_BK;\n          seen_space = NULL;\n          seen_space2 = NULL;\n        }\n      else\n        {\n          char *q;\n\n          /* Resolve property values whose behaviour is not fixed.  */\n          switch (prop)\n            {\n            case LBP_AI:\n              /* Resolve ambiguous.  */\n              prop = LBP_AI_REPLACEMENT;\n              break;\n            case LBP_CB:\n              /* This is arbitrary.  */\n              prop = LBP_ID;\n              break;\n            case LBP_SA:\n              /* We don't handle complex scripts yet.\n                 Treat LBP_SA like LBP_XX.  */\n            case LBP_XX:\n              /* This is arbitrary.  */\n              prop = LBP_AL;\n              break;\n            }\n\n          /* Deal with spaces and combining characters.  */\n          q = p;\n          if (prop == LBP_SP)\n            {\n              /* Don't break just before a space.  */\n              *p = UC_BREAK_PROHIBITED;\n              seen_space2 = seen_space;\n              seen_space = p;\n            }\n          else if (prop == LBP_ZW)\n            {\n              /* Don't break just before a zero-width space.  */\n              *p = UC_BREAK_PROHIBITED;\n              last_prop = LBP_ZW;\n              seen_space = NULL;\n              seen_space2 = NULL;\n            }\n          else if (prop == LBP_CM)\n            {\n              /* Don't break just before a combining character, except immediately after a\n                 zero-width space.  */\n              if (last_prop == LBP_ZW)\n                {\n                  /* Break after zero-width space.  */\n                  *p = UC_BREAK_POSSIBLE;\n                  /* A combining character turns a preceding space into LBP_ID.  */\n                  last_prop = LBP_ID;\n                }\n              else\n                {\n                  *p = UC_BREAK_PROHIBITED;\n                  /* A combining character turns a preceding space into LBP_ID.  */\n                  if (seen_space != NULL)\n                    {\n                      q = seen_space;\n                      seen_space = seen_space2;\n                      prop = LBP_ID;\n                      goto lookup_via_table;\n                    }\n                }\n            }\n          else\n            {\n             lookup_via_table:\n              /* prop must be usable as an index for table 7.3 of UTR #14.  */\n              if (!(prop >= 0 && prop < sizeof (unilbrk_table) / sizeof (unilbrk_table[0])))\n                abort ();\n\n              if (last_prop == LBP_BK)\n                {\n                  /* Don't break at the beginning of a line.  */\n                  *q = UC_BREAK_PROHIBITED;\n                }\n              else if (last_prop == LBP_ZW)\n                {\n                  /* Break after zero-width space.  */\n                  *q = UC_BREAK_POSSIBLE;\n                }\n              else\n                {\n                  switch (unilbrk_table [last_prop] [prop])\n                    {\n                    case D:\n                      *q = UC_BREAK_POSSIBLE;\n                      break;\n                    case I:\n                      *q = (seen_space != NULL ? UC_BREAK_POSSIBLE : UC_BREAK_PROHIBITED);\n                      break;\n                    case P:\n                      *q = UC_BREAK_PROHIBITED;\n                      break;\n                    default:\n                      abort ();\n                    }\n                }\n              last_prop = prop;\n              seen_space = NULL;\n              seen_space2 = NULL;\n            }\n        }\n\n      s += count;\n      p += count;\n    }\n}",
      "lines": 135,
      "depth": 22,
      "decorators": [
        "void"
      ]
    },
    "read_file": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "char *\nread_file (FILE *stream)\n{\n#define BUFSIZE 4096\n  char *buf = NULL;\n  int alloc = 0;\n  int size = 0;\n  int count;\n\n  while (! feof (stream))\n    {\n      if (size + BUFSIZE > alloc)\n        {\n          alloc = alloc + alloc / 2;\n          if (alloc < size + BUFSIZE)\n            alloc = size + BUFSIZE;\n          buf = realloc (buf, alloc);\n          if (buf == NULL)\n            {\n              fprintf (stderr, \"out of memory\\n\");\n              exit (1);\n            }\n        }\n      count = fread (buf + size, 1, BUFSIZE, stream);\n      if (count == 0)\n        {\n          if (ferror (stream))\n            {\n              perror (\"fread\");\n              exit (1);\n            }\n        }\n      else\n        size += count;\n    }\n  buf = realloc (buf, size + 1);\n  if (buf == NULL)\n    {\n      fprintf (stderr, \"out of memory\\n\");\n      exit (1);\n    }\n  buf[size] = '\\0';\n  return buf;\n#undef BUFSIZE\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "char",
        "*\nread_file (FILE *stream)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        228,
        0
      ],
      "end_point": [
        267,
        1
      ],
      "content": "int\nmain (int argc, char * argv[])\n{\n  if (argc == 1)\n    {\n      /* Display all the break opportunities in the input string.  */\n      char *input = read_file (stdin);\n      int length = strlen (input);\n      char *breaks = malloc (length);\n      int i;\n\n      u8_possible_linebreaks ((uint8_t *) input, length, \"UTF-8\", breaks);\n\n      for (i = 0; i < length; i++)\n        {\n          switch (breaks[i])\n            {\n            case UC_BREAK_POSSIBLE:\n              /* U+2027 in UTF-8 encoding */\n              putc (0xe2, stdout); putc (0x80, stdout); putc (0xa7, stdout);\n              break;\n            case UC_BREAK_MANDATORY:\n              /* U+21B2 (or U+21B5) in UTF-8 encoding */\n              putc (0xe2, stdout); putc (0x86, stdout); putc (0xb2, stdout);\n              break;\n            case UC_BREAK_PROHIBITED:\n              break;\n            default:\n              abort ();\n            }\n          putc (input[i], stdout);\n        }\n\n      free (breaks);\n\n      return 0;\n    }\n  else\n    return 1;\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unilbrk/u8-width-linebreaks.c": {
    "u8_width_linebreaks": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "int\nu8_width_linebreaks (const uint8_t *s, size_t n,\n                     int width, int start_column, int at_end_columns,\n                     const char *o, const char *encoding,\n                     char *p)\n{\n  const uint8_t *s_end;\n  char *last_p;\n  int last_column;\n  int piece_width;\n\n  u8_possible_linebreaks (s, n, encoding, p);\n\n  s_end = s + n;\n  last_p = NULL;\n  last_column = start_column;\n  piece_width = 0;\n  while (s < s_end)\n    {\n      ucs4_t uc;\n      int count = u8_mbtouc_unsafe (&uc, s, s_end - s);\n\n      /* Respect the override.  */\n      if (o != NULL && *o != UC_BREAK_UNDEFINED)\n        *p = *o;\n\n      if (*p == UC_BREAK_POSSIBLE || *p == UC_BREAK_MANDATORY)\n        {\n          /* An atomic piece of text ends here.  */\n          if (last_p != NULL && last_column + piece_width > width)\n            {\n              /* Insert a line break.  */\n              *last_p = UC_BREAK_POSSIBLE;\n              last_column = 0;\n            }\n        }\n\n      if (*p == UC_BREAK_MANDATORY)\n        {\n          /* uc is a line break character.  */\n          /* Start a new piece at column 0.  */\n          last_p = NULL;\n          last_column = 0;\n          piece_width = 0;\n        }\n      else\n        {\n          /* uc is not a line break character.  */\n          int w;\n\n          if (*p == UC_BREAK_POSSIBLE)\n            {\n              /* Start a new piece.  */\n              last_p = p;\n              last_column += piece_width;\n              piece_width = 0;\n              /* No line break for the moment, may be turned into\n                 UC_BREAK_POSSIBLE later, via last_p. */\n            }\n\n          *p = UC_BREAK_PROHIBITED;\n\n          w = uc_width (uc, encoding);\n          if (w >= 0) /* ignore control characters in the string */\n            piece_width += w;\n        }\n\n      s += count;\n      p += count;\n      if (o != NULL)\n        o += count;\n    }\n\n  /* The last atomic piece of text ends here.  */\n  if (last_p != NULL && last_column + piece_width + at_end_columns > width)\n    {\n      /* Insert a line break.  */\n      *last_p = UC_BREAK_POSSIBLE;\n      last_column = 0;\n    }\n\n  return last_column + piece_width;\n}",
      "lines": 83,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "read_file": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "char *\nread_file (FILE *stream)\n{\n#define BUFSIZE 4096\n  char *buf = NULL;\n  int alloc = 0;\n  int size = 0;\n  int count;\n\n  while (! feof (stream))\n    {\n      if (size + BUFSIZE > alloc)\n        {\n          alloc = alloc + alloc / 2;\n          if (alloc < size + BUFSIZE)\n            alloc = size + BUFSIZE;\n          buf = realloc (buf, alloc);\n          if (buf == NULL)\n            {\n              fprintf (stderr, \"out of memory\\n\");\n              exit (1);\n            }\n        }\n      count = fread (buf + size, 1, BUFSIZE, stream);\n      if (count == 0)\n        {\n          if (ferror (stream))\n            {\n              perror (\"fread\");\n              exit (1);\n            }\n        }\n      else\n        size += count;\n    }\n  buf = realloc (buf, size + 1);\n  if (buf == NULL)\n    {\n      fprintf (stderr, \"out of memory\\n\");\n      exit (1);\n    }\n  buf[size] = '\\0';\n  return buf;\n#undef BUFSIZE\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "char",
        "*\nread_file (FILE *stream)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "int\nmain (int argc, char * argv[])\n{\n  if (argc == 2)\n    {\n      /* Insert line breaks for a given width.  */\n      int width = atoi (argv[1]);\n      char *input = read_file (stdin);\n      int length = strlen (input);\n      char *breaks = malloc (length);\n      int i;\n\n      u8_width_linebreaks ((uint8_t *) input, length, width, 0, 0, NULL, \"UTF-8\", breaks);\n\n      for (i = 0; i < length; i++)\n        {\n          switch (breaks[i])\n            {\n            case UC_BREAK_POSSIBLE:\n              putc ('\\n', stdout);\n              break;\n            case UC_BREAK_MANDATORY:\n              break;\n            case UC_BREAK_PROHIBITED:\n              break;\n            default:\n              abort ();\n            }\n          putc (input[i], stdout);\n        }\n\n      free (breaks);\n\n      return 0;\n    }\n  else\n    return 1;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unilbrk/ulc-common.c": {
    "is_utf8_encoding": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\nis_utf8_encoding (const char *encoding)\n{\n  if (STRCASEEQ (encoding, \"UTF-8\", 'U', 'T', 'F', '-', '8', 0, 0, 0, 0))\n    return 1;\n  return 0;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "is_all_ascii": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\nis_all_ascii (const char *s, size_t n)\n{\n  for (; n > 0; s++, n--)\n    {\n      unsigned char c = (unsigned char) *s;\n\n      if (!(c_isprint (c) || c_isspace (c)))\n        return 0;\n    }\n  return 1;\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unilbrk/ulc-common.h": {},
  "libunistring/libunistring-0.9.10/lib/unilbrk/ulc-possible-linebreaks.c": {
    "ulc_possible_linebreaks": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "void\nulc_possible_linebreaks (const char *s, size_t n, const char *encoding,\n                         char *p)\n{\n  if (n > 0)\n    {\n      if (is_utf8_encoding (encoding))\n        u8_possible_linebreaks ((const uint8_t *) s, n, encoding, p);\n      else\n        {\n          /* Convert the string to UTF-8 and build a translation table\n             from offsets into s to offsets into the translated string.  */\n          size_t *offsets = (size_t *) malloc (n * sizeof (size_t));\n\n          if (offsets != NULL)\n            {\n              uint8_t *t;\n              size_t m;\n\n              t = u8_conv_from_encoding (encoding, iconveh_question_mark,\n                                         s, n, offsets, NULL, &m);\n              if (t != NULL)\n                {\n                  char *q = (char *) (m > 0 ? malloc (m) : NULL);\n\n                  if (m == 0 || q != NULL)\n                    {\n                      size_t i;\n\n                      /* Determine the possible line breaks of the UTF-8\n                         string.  */\n                      u8_possible_linebreaks (t, m, encoding, q);\n\n                      /* Translate the result back to the original string.  */\n                      memset (p, UC_BREAK_PROHIBITED, n);\n                      for (i = 0; i < n; i++)\n                        if (offsets[i] != (size_t)(-1))\n                          p[i] = q[offsets[i]];\n\n                      free (q);\n                      free (t);\n                      free (offsets);\n                      return;\n                    }\n                  free (t);\n                }\n              free (offsets);\n            }\n\n          /* Impossible to convert.  */\n#if C_CTYPE_ASCII\n          if (is_all_ascii (s, n))\n            {\n              /* ASCII is a subset of UTF-8.  */\n              u8_possible_linebreaks ((const uint8_t *) s, n, encoding, p);\n              return;\n            }\n#endif\n          /* We have a non-ASCII string and cannot convert it.\n             Don't produce line breaks except those already present in the\n             input string.  All we assume here is that the encoding is\n             minimally ASCII compatible.  */\n          {\n            const char *s_end = s + n;\n            while (s < s_end)\n              {\n                *p = (*s == '\\n' ? UC_BREAK_MANDATORY : UC_BREAK_PROHIBITED);\n                s++;\n                p++;\n              }\n          }\n        }\n    }\n}",
      "lines": 74,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "read_file": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "char *\nread_file (FILE *stream)\n{\n#define BUFSIZE 4096\n  char *buf = NULL;\n  int alloc = 0;\n  int size = 0;\n  int count;\n\n  while (! feof (stream))\n    {\n      if (size + BUFSIZE > alloc)\n        {\n          alloc = alloc + alloc / 2;\n          if (alloc < size + BUFSIZE)\n            alloc = size + BUFSIZE;\n          buf = realloc (buf, alloc);\n          if (buf == NULL)\n            {\n              fprintf (stderr, \"out of memory\\n\");\n              exit (1);\n            }\n        }\n      count = fread (buf + size, 1, BUFSIZE, stream);\n      if (count == 0)\n        {\n          if (ferror (stream))\n            {\n              perror (\"fread\");\n              exit (1);\n            }\n        }\n      else\n        size += count;\n    }\n  buf = realloc (buf, size + 1);\n  if (buf == NULL)\n    {\n      fprintf (stderr, \"out of memory\\n\");\n      exit (1);\n    }\n  buf[size] = '\\0';\n  return buf;\n#undef BUFSIZE\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "char",
        "*\nread_file (FILE *stream)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "int\nmain (int argc, char * argv[])\n{\n  setlocale (LC_CTYPE, \"\");\n  if (argc == 1)\n    {\n      /* Display all the break opportunities in the input string.  */\n      char *input = read_file (stdin);\n      int length = strlen (input);\n      char *breaks = malloc (length);\n      int i;\n\n      ulc_possible_linebreaks (input, length, locale_charset (), breaks);\n\n      for (i = 0; i < length; i++)\n        {\n          switch (breaks[i])\n            {\n            case UC_BREAK_POSSIBLE:\n              putc ('|', stdout);\n              break;\n            case UC_BREAK_MANDATORY:\n              break;\n            case UC_BREAK_PROHIBITED:\n              break;\n            default:\n              abort ();\n            }\n          putc (input[i], stdout);\n        }\n\n      free (breaks);\n\n      return 0;\n    }\n  else\n    return 1;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unilbrk/ulc-width-linebreaks.c": {
    "ulc_width_linebreaks": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "int\nulc_width_linebreaks (const char *s, size_t n,\n                      int width, int start_column, int at_end_columns,\n                      const char *o, const char *encoding,\n                      char *p)\n{\n  if (n > 0)\n    {\n      if (is_utf8_encoding (encoding))\n        return u8_width_linebreaks ((const uint8_t *) s, n, width, start_column, at_end_columns, o, encoding, p);\n      else\n        {\n          /* Convert the string to UTF-8 and build a translation table\n             from offsets into s to offsets into the translated string.  */\n          size_t *offsets = (size_t *) malloc (n * sizeof (size_t));\n\n          if (offsets != NULL)\n            {\n              uint8_t *t;\n              size_t m;\n\n              t = u8_conv_from_encoding (encoding, iconveh_question_mark,\n                                         s, n, offsets, NULL, &m);\n              if (t != NULL)\n                {\n                  char *memory =\n                    (char *) (m > 0 ? malloc (m + (o != NULL ? m : 0)) : NULL);\n\n                  if (m == 0 || memory != NULL)\n                    {\n                      char *q = (char *) memory;\n                      char *o8 = (o != NULL ? (char *) (q + m) : NULL);\n                      int res_column;\n                      size_t i;\n\n                      /* Translate the overrides to the UTF-8 string.  */\n                      if (o != NULL)\n                        {\n                          memset (o8, UC_BREAK_UNDEFINED, m);\n                          for (i = 0; i < n; i++)\n                            if (offsets[i] != (size_t)(-1))\n                              o8[offsets[i]] = o[i];\n                        }\n\n                      /* Determine the line breaks of the UTF-8 string.  */\n                      res_column =\n                        u8_width_linebreaks (t, m, width, start_column, at_end_columns, o8, encoding, q);\n\n                      /* Translate the result back to the original string.  */\n                      memset (p, UC_BREAK_PROHIBITED, n);\n                      for (i = 0; i < n; i++)\n                        if (offsets[i] != (size_t)(-1))\n                          p[i] = q[offsets[i]];\n\n                      free (memory);\n                      free (t);\n                      free (offsets);\n                      return res_column;\n                    }\n                  free (t);\n                }\n              free (offsets);\n            }\n          /* Impossible to convert.  */\n#if C_CTYPE_ASCII\n          if (is_all_ascii (s, n))\n            {\n              /* ASCII is a subset of UTF-8.  */\n              return u8_width_linebreaks ((const uint8_t *) s, n, width, start_column, at_end_columns, o, encoding, p);\n            }\n#endif\n          /* We have a non-ASCII string and cannot convert it.\n             Don't produce line breaks except those already present in the\n             input string.  All we assume here is that the encoding is\n             minimally ASCII compatible.  */\n          {\n            const char *s_end = s + n;\n            while (s < s_end)\n              {\n                *p = ((o != NULL && *o == UC_BREAK_MANDATORY) || *s == '\\n'\n                      ? UC_BREAK_MANDATORY\n                      : UC_BREAK_PROHIBITED);\n                s++;\n                p++;\n                if (o != NULL)\n                  o++;\n              }\n            /* We cannot compute widths in this case.  */\n          }\n        }\n    }\n  return start_column;\n}",
      "lines": 93,
      "depth": 22,
      "decorators": [
        "int"
      ]
    },
    "read_file": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "char *\nread_file (FILE *stream)\n{\n#define BUFSIZE 4096\n  char *buf = NULL;\n  int alloc = 0;\n  int size = 0;\n  int count;\n\n  while (! feof (stream))\n    {\n      if (size + BUFSIZE > alloc)\n        {\n          alloc = alloc + alloc / 2;\n          if (alloc < size + BUFSIZE)\n            alloc = size + BUFSIZE;\n          buf = realloc (buf, alloc);\n          if (buf == NULL)\n            {\n              fprintf (stderr, \"out of memory\\n\");\n              exit (1);\n            }\n        }\n      count = fread (buf + size, 1, BUFSIZE, stream);\n      if (count == 0)\n        {\n          if (ferror (stream))\n            {\n              perror (\"fread\");\n              exit (1);\n            }\n        }\n      else\n        size += count;\n    }\n  buf = realloc (buf, size + 1);\n  if (buf == NULL)\n    {\n      fprintf (stderr, \"out of memory\\n\");\n      exit (1);\n    }\n  buf[size] = '\\0';\n  return buf;\n#undef BUFSIZE\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "char",
        "*\nread_file (FILE *stream)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "int\nmain (int argc, char * argv[])\n{\n  setlocale (LC_CTYPE, \"\");\n  if (argc == 2)\n    {\n      /* Insert line breaks for a given width.  */\n      int width = atoi (argv[1]);\n      char *input = read_file (stdin);\n      int length = strlen (input);\n      char *breaks = malloc (length);\n      int i;\n\n      ulc_width_linebreaks (input, length, width, 0, 0, NULL, locale_charset (), breaks);\n\n      for (i = 0; i < length; i++)\n        {\n          switch (breaks[i])\n            {\n            case UC_BREAK_POSSIBLE:\n              putc ('\\n', stdout);\n              break;\n            case UC_BREAK_MANDATORY:\n              break;\n            case UC_BREAK_PROHIBITED:\n              break;\n            default:\n              abort ();\n            }\n          putc (input[i], stdout);\n        }\n\n      free (breaks);\n\n      return 0;\n    }\n  else\n    return 1;\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uniname/uniname.c": {
    "unicode_name_word": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "static const char *\nunicode_name_word (unsigned int index, unsigned int *lengthp)\n{\n  unsigned int i1;\n  unsigned int i2;\n  unsigned int i;\n\n  assert (index < UNICODE_CHARNAME_NUM_WORDS);\n\n  /* Binary search for i with\n       unicode_name_by_length[i].ind_offset <= index\n     and\n       index < unicode_name_by_length[i+1].ind_offset\n   */\n\n  i1 = 0;\n  i2 = SIZEOF (unicode_name_by_length) - 1;\n  while (i2 - i1 > 1)\n    {\n      unsigned int i = (i1 + i2) >> 1;\n      if (unicode_name_by_length[i].ind_offset <= index)\n        i1 = i;\n      else\n        i2 = i;\n    }\n  i = i1;\n  assert (unicode_name_by_length[i].ind_offset <= index\n          && index < unicode_name_by_length[i+1].ind_offset);\n  *lengthp = i;\n  return &unicode_name_words[unicode_name_by_length[i].extra_offset\n                             + (index-unicode_name_by_length[i].ind_offset)*i];\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nunicode_name_word (unsigned int index, unsigned int *lengthp)",
        "*"
      ]
    },
    "unicode_name_word_lookup": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "static int\nunicode_name_word_lookup (const char *word, unsigned int length)\n{\n  if (length > 0 && length < SIZEOF (unicode_name_by_length) - 1)\n    {\n      /* Binary search among the words of given length.  */\n      unsigned int extra_offset = unicode_name_by_length[length].extra_offset;\n      unsigned int i0 = unicode_name_by_length[length].ind_offset;\n      unsigned int i1 = i0;\n      unsigned int i2 = unicode_name_by_length[length+1].ind_offset;\n      while (i2 - i1 > 0)\n        {\n          unsigned int i = (i1 + i2) >> 1;\n          const char *p = &unicode_name_words[extra_offset + (i-i0)*length];\n          const char *w = word;\n          unsigned int n = length;\n          for (;;)\n            {\n              if (*p < *w)\n                {\n                  if (i1 == i)\n                    return -1;\n                  /* Note here: i1 < i < i2.  */\n                  i1 = i;\n                  break;\n                }\n              if (*p > *w)\n                {\n                  /* Note here: i1 <= i < i2.  */\n                  i2 = i;\n                  break;\n                }\n              p++; w++; n--;\n              if (n == 0)\n                return i;\n            }\n        }\n    }\n  return -1;\n}",
      "lines": 40,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "unicode_code_to_index": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "static uint16_t\nunicode_code_to_index (ucs4_t c)\n{\n  /* Binary search in unicode_ranges.  */\n  unsigned int i1 = 0;\n  unsigned int i2 = SIZEOF (unicode_ranges);\n\n  for (;;)\n    {\n      unsigned int i = (i1 + i2) >> 1;\n      ucs4_t start_code =\n        unicode_ranges[i].index + unicode_ranges[i].gap;\n      ucs4_t end_code =\n        start_code + unicode_ranges[i].length - 1;\n\n      if (start_code <= c && c <= end_code)\n        return c - unicode_ranges[i].gap;\n\n      if (end_code < c)\n        {\n          if (i1 == i)\n            break;\n          /* Note here: i1 < i < i2.  */\n          i1 = i;\n        }\n      else if (c < start_code)\n        {\n          if (i2 == i)\n            break;\n          /* Note here: i1 <= i < i2.  */\n          i2 = i;\n        }\n    }\n  return UNINAME_INVALID_INDEX;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "uint16_t"
      ]
    },
    "unicode_index_to_code": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        212,
        1
      ],
      "content": "static ucs4_t\nunicode_index_to_code (uint16_t index)\n{\n  /* Binary search in unicode_ranges.  */\n  unsigned int i1 = 0;\n  unsigned int i2 = SIZEOF (unicode_ranges);\n\n  for (;;)\n    {\n      unsigned int i = (i1 + i2) >> 1;\n      uint16_t start_index = unicode_ranges[i].index;\n      uint16_t end_index = start_index + unicode_ranges[i].length - 1;\n\n      if (start_index <= index && index <= end_index)\n        return index + unicode_ranges[i].gap;\n\n      if (end_index < index)\n        {\n          if (i1 == i)\n            break;\n          /* Note here: i1 < i < i2.  */\n          i1 = i;\n        }\n      else if (index < start_index)\n        {\n          if (i2 == i)\n            break;\n          /* Note here: i1 <= i < i2.  */\n          i2 = i;\n        }\n    }\n  return UNINAME_INVALID;\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "ucs4_t"
      ]
    },
    "unicode_character_name": {
      "start_point": [
        235,
        0
      ],
      "end_point": [
        361,
        1
      ],
      "content": "char *\nunicode_character_name (ucs4_t c, char *buf)\n{\n  if (c >= 0xAC00 && c <= 0xD7A3)\n    {\n      /* Special case for Hangul syllables. Keeps the tables small.  */\n      char *ptr;\n      unsigned int tmp;\n      unsigned int index1;\n      unsigned int index2;\n      unsigned int index3;\n      const char *q;\n\n      /* buf needs to have at least 16 + 7 bytes here.  */\n      memcpy (buf, \"HANGUL SYLLABLE \", 16);\n      ptr = buf + 16;\n\n      tmp = c - 0xAC00;\n      index3 = tmp % 28; tmp = tmp / 28;\n      index2 = tmp % 21; tmp = tmp / 21;\n      index1 = tmp;\n\n      q = jamo_initial_short_name[index1];\n      while (*q != '\\0')\n        *ptr++ = *q++;\n      q = jamo_medial_short_name[index2];\n      while (*q != '\\0')\n        *ptr++ = *q++;\n      q = jamo_final_short_name[index3];\n      while (*q != '\\0')\n        *ptr++ = *q++;\n      *ptr = '\\0';\n      return buf;\n    }\n  else if ((c >= 0xF900 && c <= 0xFA2D) || (c >= 0xFA30 && c <= 0xFA6A)\n           || (c >= 0xFA70 && c <= 0xFAD9) || (c >= 0x2F800 && c <= 0x2FA1D))\n    {\n      /* Special case for CJK compatibility ideographs. Keeps the tables\n         small.  */\n      char *ptr;\n      int i;\n\n      /* buf needs to have at least 28 + 5 bytes here.  */\n      memcpy (buf, \"CJK COMPATIBILITY IDEOGRAPH-\", 28);\n      ptr = buf + 28;\n\n      for (i = (c < 0x10000 ? 12 : 16); i >= 0; i -= 4)\n        {\n          unsigned int x = (c >> i) & 0xf;\n          *ptr++ = (x < 10 ? '0' : 'A' - 10) + x;\n        }\n      *ptr = '\\0';\n      return buf;\n    }\n  else if ((c >= 0xFE00 && c <= 0xFE0F) || (c >= 0xE0100 && c <= 0xE01EF))\n    {\n      /* Special case for variation selectors. Keeps the tables\n         small.  */\n\n      /* buf needs to have at least 19 + 3 bytes here.  */\n      sprintf (buf, \"VARIATION SELECTOR-%d\",\n               c <= 0xFE0F ? c - 0xFE00 + 1 : c - 0xE0100 + 17);\n      return buf;\n    }\n  else\n    {\n      uint16_t index = unicode_code_to_index (c);\n      const uint16_t *words = NULL;\n\n      if (index != UNINAME_INVALID_INDEX)\n        {\n          /* Binary search in unicode_code_to_name.  */\n          unsigned int i1 = 0;\n          unsigned int i2 = SIZEOF (unicode_index_to_name);\n          for (;;)\n            {\n              unsigned int i = (i1 + i2) >> 1;\n              if (unicode_index_to_name[i].index == index)\n                {\n                  words = &unicode_names[unicode_index_to_name[i].name];\n                  break;\n                }\n              else if (unicode_index_to_name[i].index < index)\n                {\n                  if (i1 == i)\n                    {\n                      words = NULL;\n                      break;\n                    }\n                  /* Note here: i1 < i < i2.  */\n                  i1 = i;\n                }\n              else if (unicode_index_to_name[i].index > index)\n                {\n                  if (i2 == i)\n                    {\n                      words = NULL;\n                      break;\n                    }\n                  /* Note here: i1 <= i < i2.  */\n                  i2 = i;\n                }\n            }\n        }\n      if (words != NULL)\n        {\n          /* Found it in unicode_index_to_name. Now concatenate the words.  */\n          /* buf needs to have at least UNICODE_CHARNAME_MAX_LENGTH bytes.  */\n          char *ptr = buf;\n          for (;;)\n            {\n              unsigned int wordlen;\n              const char *word = unicode_name_word (*words>>1, &wordlen);\n              do\n                *ptr++ = *word++;\n              while (--wordlen > 0);\n              if ((*words & 1) == 0)\n                break;\n              *ptr++ = ' ';\n              words++;\n            }\n          *ptr = '\\0';\n          return buf;\n        }\n      return NULL;\n    }\n}",
      "lines": 127,
      "depth": 19,
      "decorators": [
        "char",
        "*\nunicode_character_name (ucs4_t c, char *buf)",
        "*"
      ]
    },
    "unicode_name_character": {
      "start_point": [
        365,
        0
      ],
      "end_point": [
        634,
        1
      ],
      "content": "ucs4_t\nunicode_name_character (const char *name)\n{\n  unsigned int len = strlen (name);\n  if (len > 1 && len <= UNICODE_CHARNAME_MAX_LENGTH)\n    {\n      /* Test for \"word1 word2 ...\" syntax.  */\n      char buf[UNICODE_CHARNAME_MAX_LENGTH];\n      char *ptr = buf;\n      for (;;)\n        {\n          char c = *name++;\n          if (!(c >= ' ' && c <= '~'))\n            break;\n          *ptr++ = (c >= 'a' && c <= 'z' ? c - 'a' + 'A' : c);\n          if (--len == 0)\n            goto filled_buf;\n        }\n      if (false)\n      filled_buf:\n        {\n          {\n            /* Special case for variation selector aliases. Keeps the\n               tables small.  */\n            const char *p1 = buf;\n            if (ptr >= buf + 3 && *p1++ == 'V')\n              {\n                if (*p1++ == 'S')\n                  {\n                    if (*p1 != '0')\n                      {\n                        unsigned int c = 0;\n                        for (;;)\n                          {\n                            if (*p1 >= '0' && *p1 <= '9')\n                              c += (*p1 - '0');\n                            p1++;\n                            if (p1 == ptr)\n                              {\n                                if (c >= 1 && c <= 16)\n                                  return c - 1 + 0xFE00;\n                                else if (c >= 17 && c <= 256)\n                                  return c - 17 + 0xE0100;\n                                else\n                                  break;\n                              }\n                            c = c * 10;\n                          }\n                      }\n                  }\n              }\n          }\n          {\n            /* Convert the constituents to uint16_t words.  */\n            uint16_t words[UNICODE_CHARNAME_MAX_WORDS];\n            uint16_t *wordptr = words;\n            {\n              const char *p1 = buf;\n              for (;;)\n                {\n                  {\n                    int word;\n                    const char *p2 = p1;\n                    while (p2 < ptr && *p2 != ' ')\n                      p2++;\n                    word = unicode_name_word_lookup (p1, p2 - p1);\n                    if (word < 0)\n                      break;\n                    if (wordptr == &words[UNICODE_CHARNAME_MAX_WORDS])\n                      break;\n                    *wordptr++ = word;\n                    if (p2 == ptr)\n                      goto filled_words;\n                    p1 = p2 + 1;\n                  }\n                  /* Special case for Hangul syllables. Keeps the tables small. */\n                  if (wordptr == &words[2]\n                      && words[0] == UNICODE_CHARNAME_WORD_HANGUL\n                      && words[1] == UNICODE_CHARNAME_WORD_SYLLABLE)\n                    {\n                      /* Split the last word [p1..ptr) into three parts:\n                           1) [BCDGHJKMNPRST]\n                           2) [AEIOUWY]\n                           3) [BCDGHIJKLMNPST]\n                       */\n                      const char *p2;\n                      const char *p3;\n                      const char *p4;\n\n                      p2 = p1;\n                      while (p2 < ptr\n                             && (*p2 == 'B' || *p2 == 'C' || *p2 == 'D'\n                                 || *p2 == 'G' || *p2 == 'H' || *p2 == 'J'\n                                 || *p2 == 'K' || *p2 == 'M' || *p2 == 'N'\n                                 || *p2 == 'P' || *p2 == 'R' || *p2 == 'S'\n                                 || *p2 == 'T'))\n                        p2++;\n                      p3 = p2;\n                      while (p3 < ptr\n                             && (*p3 == 'A' || *p3 == 'E' || *p3 == 'I'\n                                 || *p3 == 'O' || *p3 == 'U' || *p3 == 'W'\n                                 || *p3 == 'Y'))\n                        p3++;\n                      p4 = p3;\n                      while (p4 < ptr\n                             && (*p4 == 'B' || *p4 == 'C' || *p4 == 'D'\n                                 || *p4 == 'G' || *p4 == 'H' || *p4 == 'I'\n                                 || *p4 == 'J' || *p4 == 'K' || *p4 == 'L'\n                                 || *p4 == 'M' || *p4 == 'N' || *p4 == 'P'\n                                 || *p4 == 'S' || *p4 == 'T'))\n                        p4++;\n                      if (p4 == ptr)\n                        {\n                          unsigned int n1 = p2 - p1;\n                          unsigned int n2 = p3 - p2;\n                          unsigned int n3 = p4 - p3;\n\n                          if (n1 <= 2 && (n2 >= 1 && n2 <= 3) && n3 <= 2)\n                            {\n                              unsigned int index1;\n\n                              for (index1 = 0; index1 < 19; index1++)\n                                if (memcmp (jamo_initial_short_name[index1], p1, n1) == 0\n                                    && jamo_initial_short_name[index1][n1] == '\\0')\n                                  {\n                                    unsigned int index2;\n\n                                    for (index2 = 0; index2 < 21; index2++)\n                                      if (memcmp (jamo_medial_short_name[index2], p2, n2) == 0\n                                          && jamo_medial_short_name[index2][n2] == '\\0')\n                                        {\n                                          unsigned int index3;\n\n                                          for (index3 = 0; index3 < 28; index3++)\n                                            if (memcmp (jamo_final_short_name[index3], p3, n3) == 0\n                                                && jamo_final_short_name[index3][n3] == '\\0')\n                                              {\n                                                return 0xAC00 + (index1 * 21 + index2) * 28 + index3;\n                                              }\n                                          break;\n                                        }\n                                    break;\n                                  }\n                            }\n                        }\n                    }\n                  /* Special case for CJK compatibility ideographs. Keeps the\n                     tables small.  */\n                  if (wordptr == &words[2]\n                      && words[0] == UNICODE_CHARNAME_WORD_CJK\n                      && words[1] == UNICODE_CHARNAME_WORD_COMPATIBILITY\n                      && p1 + 14 <= ptr\n                      && p1 + 15 >= ptr\n                      && memcmp (p1, \"IDEOGRAPH-\", 10) == 0)\n                    {\n                      const char *p2 = p1 + 10;\n\n                      if (*p2 != '0')\n                        {\n                          unsigned int c = 0;\n\n                          for (;;)\n                            {\n                              if (*p2 >= '0' && *p2 <= '9')\n                                c += (*p2 - '0');\n                              else if (*p2 >= 'A' && *p2 <= 'F')\n                                c += (*p2 - 'A' + 10);\n                              else\n                                break;\n                              p2++;\n                              if (p2 == ptr)\n                                {\n                                  if ((c >= 0xF900 && c <= 0xFA2D)\n                                      || (c >= 0xFA30 && c <= 0xFA6A)\n                                      || (c >= 0xFA70 && c <= 0xFAD9)\n                                      || (c >= 0x2F800 && c <= 0x2FA1D))\n                                    return c;\n                                  else\n                                    break;\n                                }\n                              c = c << 4;\n                            }\n                        }\n                    }\n                  /* Special case for variation selectors. Keeps the\n                     tables small.  */\n                  if (wordptr == &words[1]\n                      && words[0] == UNICODE_CHARNAME_WORD_VARIATION\n                      && p1 + 10 <= ptr\n                      && p1 + 12 >= ptr\n                      && memcmp (p1, \"SELECTOR-\", 9) == 0)\n                    {\n                      const char *p2 = p1 + 9;\n\n                      if (*p2 != '0')\n                        {\n                          unsigned int c = 0;\n\n                          for (;;)\n                            {\n                              if (*p2 >= '0' && *p2 <= '9')\n                                c += (*p2 - '0');\n                              p2++;\n                              if (p2 == ptr)\n                                {\n                                  if (c >= 1 && c <= 16)\n                                    return c - 1 + 0xFE00;\n                                  else if (c >= 17 && c <= 256)\n                                    return c - 17 + 0xE0100;\n                                  else\n                                    break;\n                                }\n                              c = c * 10;\n                            }\n                        }\n                    }\n                }\n            }\n            if (false)\n            filled_words:\n              {\n                /* Multiply by 2, to simplify later comparisons.  */\n                unsigned int words_length = wordptr - words;\n                {\n                  int i = words_length - 1;\n                  words[i] = 2 * words[i];\n                  for (; --i >= 0; )\n                    words[i] = 2 * words[i] + 1;\n                }\n                /* Binary search in unicode_name_to_index.  */\n                {\n                  unsigned int i1 = 0;\n                  unsigned int i2 = SIZEOF (unicode_name_to_index);\n                  for (;;)\n                    {\n                      unsigned int i = (i1 + i2) >> 1;\n                      const uint16_t *w = words;\n                      const uint16_t *p = &unicode_names[unicode_name_to_index[i].name];\n                      unsigned int n = words_length;\n                      for (;;)\n                        {\n                          if (*p < *w)\n                            {\n                              if (i1 == i)\n                                goto name_not_found;\n                              /* Note here: i1 < i < i2.  */\n                              i1 = i;\n                              break;\n                            }\n                          else if (*p > *w)\n                            {\n                              if (i2 == i)\n                                goto name_not_found;\n                              /* Note here: i1 <= i < i2.  */\n                              i2 = i;\n                              break;\n                            }\n                          p++; w++; n--;\n                          if (n == 0)\n                            return unicode_index_to_code (unicode_name_to_index[i].index);\n                        }\n                    }\n                }\n              name_not_found: ;\n              }\n          }\n        }\n    }\n  return UNINAME_INVALID;\n}",
      "lines": 270,
      "depth": 34,
      "decorators": [
        "ucs4_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uniname/uninames.h": {},
  "libunistring/libunistring-0.9.10/lib/uninorm/canonical-decomposition.c": {
    "uc_canonical_decomposition": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "int\nuc_canonical_decomposition (ucs4_t uc, ucs4_t *decomposition)\n{\n  if (uc >= 0xAC00 && uc < 0xD7A4)\n    {\n      /* Hangul syllable.  See Unicode standard, chapter 3, section\n         \"Hangul Syllable Decomposition\",  See also the clarification at\n         <http://www.unicode.org/versions/Unicode5.1.0/>, section\n         \"Clarification of Hangul Jamo Handling\".  */\n      unsigned int t;\n\n      uc -= 0xAC00;\n      t = uc % 28;\n\n      if (t == 0)\n        {\n          unsigned int v, l;\n\n          uc = uc / 28;\n          v = uc % 21;\n          l = uc / 21;\n\n          decomposition[0] = 0x1100 + l;\n          decomposition[1] = 0x1161 + v;\n          return 2;\n        }\n      else\n        {\n#if 1 /* Return the pairwise decomposition, not the full decomposition.  */\n          decomposition[0] = 0xAC00 + uc - t; /* = 0xAC00 + (l * 21 + v) * 28; */\n          decomposition[1] = 0x11A7 + t;\n          return 2;\n#else\n          unsigned int v, l;\n\n          uc = uc / 28;\n          v = uc % 21;\n          l = uc / 21;\n\n          decomposition[0] = 0x1100 + l;\n          decomposition[1] = 0x1161 + v;\n          decomposition[2] = 0x11A7 + t;\n          return 3;\n#endif\n        }\n    }\n  else if (uc < 0x110000)\n    {\n      unsigned short entry = decomp_index (uc);\n      /* An entry of (unsigned short)(-1) denotes an absent entry.\n         Otherwise, bit 15 of the entry tells whether the decomposition\n         is a canonical one.  */\n      if (entry < 0x8000)\n        {\n          const unsigned char *p;\n          unsigned int element;\n          unsigned int length;\n\n          p = &gl_uninorm_decomp_chars_table[3 * entry];\n          element = (p[0] << 16) | (p[1] << 8) | p[2];\n          /* The first element has 5 bits for the decomposition type.  */\n          if (((element >> 18) & 0x1f) != UC_DECOMP_CANONICAL)\n            abort ();\n          length = 1;\n          for (;;)\n            {\n              /* Every element has an 18 bits wide Unicode code point.  */\n              *decomposition = element & 0x3ffff;\n              /* Bit 23 tells whether there are more elements,  */\n              if ((element & (1 << 23)) == 0)\n                break;\n              p += 3;\n              element = (p[0] << 16) | (p[1] << 8) | p[2];\n              decomposition++;\n              length++;\n            }\n          return length;\n        }\n    }\n  return -1;\n}",
      "lines": 81,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uninorm/compat-decomposition.c": {
    "uc_compat_decomposition": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "int\nuc_compat_decomposition (ucs4_t uc, ucs4_t *decomposition)\n{\n  int tag;\n\n  return uc_decomposition (uc, &tag, decomposition);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uninorm/composition-table.h": {
    "gl_uninorm_compose_hash": {
      "start_point": [
        20,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static unsigned int\ngl_uninorm_compose_hash (register const char *str, register size_t len)\n{\n  static const unsigned short asso_values[] =\n    {\n         7,    1,    0,    3,   58,  132,  531,   62,    4,   33,\n       117,  268,  476,  135,  509,  481,  103,  265,  249,  495,\n        61,  124,  336,  409,  703,  241,  435,  462,  738, 1566,\n        48,   13,  901,  766,  322,  635,  192,  621,  846,   13,\n       337,   65,  161,  130,  103,   28,  255,  640,  133,  342,\n       172,   52, 1566,  818,  201,   34,  695,   50,   31, 1566,\n        16,   35,  438,  139,   63,   89,  272,    2,  588,  167,\n        12,  375,  289,   61,   44,  548,  431,  452,  395,  180,\n       794,  853,  362,  561,  456,  202,  677,  360,  195,  300,\n       572,  715, 1566,  291, 1566,  276,  814,   26,  634,  579,\n       270,   98,  423,  415,  323,   42,  862,  657,  559,  324,\n       262,  124,  863, 1566,  251,  538,  236,  133,   47,  406,\n       691,  219,  590,    5,   56,   83, 1566,    1, 1566, 1566,\n        65,   39, 1566, 1566,   37,   35, 1566, 1566, 1566, 1566,\n      1566, 1566, 1566, 1566,    4,  527,   18, 1566,    0,  849,\n      1566,  781, 1566,  572,   59,   73, 1566,  204, 1566,  417,\n       618,  511,   20, 1566, 1566,  708,  167, 1566,  855,  685,\n      1566,  333,   73,  136,   71,  625,  611,  523,   12,  311,\n        11,  649,   10,  505,   62,  482, 1566,  113, 1566,  126,\n         7,  476, 1566,  614,  853,    1,   41,  560,  553,  261,\n       104,  719,  668,  854,   19,   10,    9,  728,   31, 1566,\n       442, 1566,  749,  313,   12,    0,  659,    3, 1566,  329,\n        37, 1566, 1566, 1566,   44, 1566,  847, 1566,   33,    4,\n        23,    1,   33,   24,  757,    4, 1566, 1566, 1566,    3,\n        93,   73,   72, 1566,  824,   20,   17, 1566,    0, 1566,\n      1566, 1566,   77,   46,  460, 1566, 1566\n    };\n  return asso_values[(unsigned char)str[5]+1] + asso_values[(unsigned char)str[2]] + asso_values[(unsigned char)str[1]];\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "gl_uninorm_compose_lookup": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        2196,
        1
      ],
      "content": "const struct composition_rule *\ngl_uninorm_compose_lookup (register const char *str, register size_t len)\n{\n  static const unsigned char lengthtable[] =\n    {\n       0,  6,  6,  0,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  0,  6,  6,\n       6,  6,  6,  6,  6,  0,  6,  6,  6,  6,  6,  6,  6,  6,\n       0,  6,  6,  6,  6,  6,  6,  6,  6,  0,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  0,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  0,\n       6,  6,  6,  0,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  0,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  0,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  0,  6,  6,  0,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  0,  6,  6,  0,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  0,  6,  6,  6,  6,  6,  6,  0,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       0,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  0,  6,  6,\n       0,  6,  0,  6,  0,  6,  6,  6,  6,  0,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  0,  6,  6,  6,  6,  0,  6,\n       6,  6,  0,  6,  0,  6,  6,  6,  6,  0,  6,  6,  0,  6,\n       6,  6,  0,  6,  0,  0,  0,  6,  0,  6,  0,  6,  6,  6,\n       6,  0,  6,  6,  6,  6,  6,  0,  6,  0,  6,  0,  0,  6,\n       6,  6,  6,  0,  6,  0,  0,  6,  6,  0,  6,  6,  6,  0,\n       6,  0,  0,  0,  6,  0,  6,  6,  0,  6,  6,  0,  0,  0,\n       0,  6,  0,  0,  0,  0,  0,  0,  0,  0,  6,  0,  6,  0,\n       0,  0,  0,  0,  6,  6,  0,  0,  0,  0,  6,  6,  6,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  6,  6,\n       0,  0,  0,  0,  0,  0,  6,  6,  0,  6,  6,  6,  0,  6,\n       0,  6,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  6,\n       6,  0,  0,  0,  6,  0,  0,  6,  6,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  6,  0,  0,  0,  6,  6,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  6,  0,  0,  0,  0,  0,  0,\n       0,  6,  6,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  6,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  6,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  6,  0,  0,  0,  0,  0,  6,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  6,\n       0,  0,  0,  6,  0,  0,  0,  0,  0,  6,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  6,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  6,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  6,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  6,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  6,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  6\n    };\n  static const struct composition_rule wordlist[] =\n    {\n      {\"\"},\n#line 581 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\002\\000\\003\\001\", 0x1eae},\n#line 583 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\002\\000\\003\\000\", 0x1eb0},\n      {\"\"},\n#line 582 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\003\\000\\003\\001\", 0x1eaf},\n#line 584 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\003\\000\\003\\000\", 0x1eb1},\n#line 566 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\177\\000\\003\\007\", 0x1e9b},\n#line 247 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\370\\000\\003\\001\", 0x01ff},\n#line 421 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\347\\000\\003\\001\", 0x1e09},\n#line 99 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000C\\000\\003\\001\", 0x0106},\n#line 459 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\357\\000\\003\\001\", 0x1e2f},\n#line 243 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\345\\000\\003\\001\", 0x01fb},\n#line 101 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000C\\000\\003\\002\", 0x0108},\n#line 103 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000C\\000\\003\\007\", 0x010a},\n#line 662 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\001\\000\\003\\001\", 0x1f05},\n#line 660 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\001\\000\\003\\000\", 0x1f03},\n#line 664 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\001\\000\\003B\", 0x1f07},\n#line 669 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\010\\000\\003\\001\", 0x1f0c},\n#line 667 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\010\\000\\003\\000\", 0x1f0a},\n#line 671 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\010\\000\\003B\", 0x1f0e},\n#line 661 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\000\\000\\003\\001\", 0x1f04},\n#line 659 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\000\\000\\003\\000\", 0x1f02},\n#line 663 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\000\\000\\003B\", 0x1f06},\n#line 442 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000F\\000\\003\\007\", 0x1e1e},\n#line 860 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\316\\000\\003E\", 0x1ff4},\n#line 766 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\002\\000\\003E\", 0x1f82},\n#line 765 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\001\\000\\003E\", 0x1f81},\n#line 489 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\365\\000\\003\\001\", 0x1e4d},\n#line 767 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\003\\000\\003E\", 0x1f83},\n#line 772 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\010\\000\\003E\", 0x1f88},\n#line 245 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\346\\000\\003\\001\", 0x01fd},\n#line 515 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001a\\000\\003\\007\", 0x1e67},\n#line 764 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\000\\000\\003E\", 0x1f80},\n#line 67 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003\\001\", 0x00e1},\n#line 66 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003\\000\", 0x00e0},\n#line 818 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\266\\000\\003E\", 0x1fb7},\n#line 68 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003\\002\", 0x00e2},\n#line 279 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003\\007\", 0x0227},\n#line 787 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037'\\000\\003E\", 0x1f97},\n#line 746 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037a\\000\\003\\001\", 0x1f65},\n#line 744 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037a\\000\\003\\000\", 0x1f63},\n#line 748 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037a\\000\\003B\", 0x1f67},\n#line 862 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\366\\000\\003E\", 0x1ff7},\n#line 533 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001i\\000\\003\\001\", 0x1e79},\n#line 215 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\334\\000\\003\\001\", 0x01d7},\n#line 219 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\334\\000\\003\\000\", 0x01db},\n#line 670 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\011\\000\\003\\001\", 0x1f0d},\n#line 668 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\011\\000\\003\\000\", 0x1f0b},\n#line 672 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\011\\000\\003B\", 0x1f0f},\n#line 78 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000i\\000\\003\\001\", 0x00ed},\n#line 77 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000i\\000\\003\\000\", 0x00ec},\n#line 797 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037a\\000\\003E\", 0x1fa1},\n#line 79 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000i\\000\\003\\002\", 0x00ee},\n#line 793 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037-\\000\\003E\", 0x1f9d},\n#line 138 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000J\\000\\003\\002\", 0x0134},\n#line 754 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037i\\000\\003\\001\", 0x1f6d},\n#line 752 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037i\\000\\003\\000\", 0x1f6b},\n#line 756 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037i\\000\\003B\", 0x1f6f},\n#line 773 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\011\\000\\003E\", 0x1f89},\n#line 587 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\002\\000\\003\\003\", 0x1eb4},\n#line 491 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\365\\000\\003\\010\", 0x1e4f},\n#line 624 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\036\\315\\000\\003\\002\", 0x1ed9},\n#line 588 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\003\\000\\003\\003\", 0x1eb5},\n#line 714 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0379\\000\\003\\001\", 0x1f3d},\n#line 712 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0379\\000\\003\\000\", 0x1f3b},\n#line 716 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0379\\000\\003B\", 0x1f3f},\n#line 70 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003\\010\", 0x00e4},\n#line 805 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037i\\000\\003E\", 0x1fa9},\n#line 52 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\003\\001\", 0x00cd},\n#line 51 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\003\\000\", 0x00cc},\n#line 623 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\036\\314\\000\\003\\002\", 0x1ed8},\n#line 53 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\003\\002\", 0x00ce},\n#line 137 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\003\\007\", 0x0130},\n#line 884 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000<\\000\\0038\", 0x226e},\n#line 728 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037I\\000\\003\\001\", 0x1f4d},\n#line 726 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037I\\000\\003\\000\", 0x1f4b},\n#line 721 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037@\\000\\003\\001\", 0x1f44},\n#line 719 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037@\\000\\003\\000\", 0x1f42},\n#line 698 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037)\\000\\003\\001\", 0x1f2d},\n#line 696 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037)\\000\\003\\000\", 0x1f2b},\n#line 700 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037)\\000\\003B\", 0x1f2f},\n#line 858 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037|\\000\\003E\", 0x1ff2},\n#line 80 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000i\\000\\003\\010\", 0x00ef},\n#line 768 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\004\\000\\003E\", 0x1f84},\n#line 216 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\374\\000\\003\\001\", 0x01d8},\n#line 220 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\374\\000\\003\\000\", 0x01dc},\n#line 826 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\256\\000\\003E\", 0x1fc4},\n#line 771 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\007\\000\\003E\", 0x1f87},\n#line 816 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\254\\000\\003E\", 0x1fb4},\n#line 328 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004:\\000\\003\\001\", 0x045c},\n#line 789 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037)\\000\\003E\", 0x1f99},\n#line 69 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003\\003\", 0x00e3},\n#line 881 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000=\\000\\0038\", 0x2260},\n#line 360 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004C\\000\\003\\010\", 0x04f1},\n#line 342 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\331\\000\\003\\010\", 0x04db},\n#line 96 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003\\006\", 0x0103},\n#line 41 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003\\001\", 0x00c1},\n#line 40 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003\\000\", 0x00c0},\n#line 98 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003(\", 0x0105},\n#line 42 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003\\002\", 0x00c2},\n#line 278 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003\\007\", 0x0226},\n#line 54 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\003\\010\", 0x00cf},\n#line 722 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037A\\000\\003\\001\", 0x1f45},\n#line 720 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037A\\000\\003\\000\", 0x1f43},\n#line 363 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004'\\000\\003\\010\", 0x04f4},\n#line 74 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003\\001\", 0x00e9},\n#line 73 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003\\000\", 0x00e8},\n#line 130 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000i\\000\\003\\003\", 0x0129},\n#line 75 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003\\002\", 0x00ea},\n#line 114 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003\\007\", 0x0117},\n#line 326 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0043\\000\\003\\001\", 0x0453},\n#line 134 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000i\\000\\003\\006\", 0x012d},\n#line 537 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000v\\000\\003\\003\", 0x1e7d},\n#line 605 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\036\\270\\000\\003\\002\", 0x1ec6},\n#line 136 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000i\\000\\003(\", 0x012f},\n#line 354 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\351\\000\\003\\010\", 0x04eb},\n#line 677 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\020\\000\\003\\001\", 0x1f14},\n#line 675 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\020\\000\\003\\000\", 0x1f12},\n#line 585 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\002\\000\\003\\011\", 0x1eb2},\n#line 355 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004-\\000\\003\\010\", 0x04ec},\n#line 377 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0113\\000\\011<\", 0x0934},\n#line 586 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\003\\000\\003\\011\", 0x1eb3},\n#line 330 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004C\\000\\003\\006\", 0x045e},\n#line 801 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037e\\000\\003E\", 0x1fa5},\n#line 353 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\350\\000\\003\\010\", 0x04ea},\n#line 346 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0047\\000\\003\\010\", 0x04df},\n#line 129 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\003\\003\", 0x0128},\n#line 441 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\002)\\000\\003\\006\", 0x1e1d},\n#line 792 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037,\\000\\003E\", 0x1f9c},\n#line 44 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003\\010\", 0x00c4},\n#line 133 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\003\\006\", 0x012c},\n#line 83 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003\\001\", 0x00f3},\n#line 82 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003\\000\", 0x00f2},\n#line 135 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\003(\", 0x012e},\n#line 84 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003\\002\", 0x00f4},\n#line 287 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003\\007\", 0x022f},\n#line 249 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003\\017\", 0x0201},\n#line 234 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\353\\000\\003\\004\", 0x01ed},\n#line 76 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003\\010\", 0x00eb},\n#line 351 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\036\\000\\003\\010\", 0x04e6},\n#line 88 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003\\001\", 0x00fa},\n#line 87 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003\\000\", 0x00f9},\n#line 774 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\012\\000\\003E\", 0x1f8a},\n#line 89 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003\\002\", 0x00fb},\n#line 105 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000C\\000\\003\\014\", 0x010c},\n#line 224 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\002'\\000\\003\\004\", 0x01e1},\n#line 705 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0370\\000\\003\\001\", 0x1f34},\n#line 703 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0370\\000\\003\\000\", 0x1f32},\n#line 707 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0370\\000\\003B\", 0x1f36},\n#line 811 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037o\\000\\003E\", 0x1faf},\n#line 570 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003\\011\", 0x1ea3},\n#line 282 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\326\\000\\003\\004\", 0x022a},\n#line 257 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000i\\000\\003\\017\", 0x0209},\n#line 236 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\002\\222\\000\\003\\014\", 0x01ef},\n#line 43 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003\\003\", 0x00c3},\n#line 791 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037+\\000\\003E\", 0x1f9b},\n#line 283 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\366\\000\\003\\004\", 0x022b},\n#line 769 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\005\\000\\003E\", 0x1f85},\n#line 95 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003\\006\", 0x0102},\n#line 285 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\365\\000\\003\\004\", 0x022d},\n#line 777 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\015\\000\\003E\", 0x1f8d},\n#line 97 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003(\", 0x0104},\n#line 226 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\346\\000\\003\\004\", 0x01e3},\n#line 596 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003\\003\", 0x1ebd},\n#line 86 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003\\010\", 0x00f6},\n#line 94 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003\\004\", 0x0101},\n#line 608 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000i\\000\\003\\011\", 0x1ec9},\n#line 112 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003\\006\", 0x0115},\n#line 206 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003\\014\", 0x01ce},\n#line 397 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\015\\331\\000\\015\\317\", 0x0ddc},\n#line 116 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003(\", 0x0119},\n#line 256 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\003\\017\", 0x0208},\n#line 222 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\344\\000\\003\\004\", 0x01df},\n#line 90 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003\\010\", 0x00fc},\n#line 48 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003\\001\", 0x00c9},\n#line 47 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003\\000\", 0x00c8},\n#line 213 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\334\\000\\003\\004\", 0x01d5},\n#line 49 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003\\002\", 0x00ca},\n#line 113 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003\\007\", 0x0116},\n#line 217 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\334\\000\\003\\014\", 0x01d9},\n#line 221 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\304\\000\\003\\004\", 0x01de},\n#line 132 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000i\\000\\003\\004\", 0x012b},\n#line 399 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\015\\331\\000\\015\\337\", 0x0dde},\n#line 315 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\025\\000\\003\\000\", 0x0400},\n#line 208 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000i\\000\\003\\014\", 0x01d0},\n#line 607 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\003\\011\", 0x1ec8},\n#line 790 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037*\\000\\003E\", 0x1f9a},\n#line 57 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003\\001\", 0x00d3},\n#line 56 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003\\000\", 0x00d2},\n#line 85 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003\\003\", 0x00f5},\n#line 58 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003\\002\", 0x00d4},\n#line 286 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003\\007\", 0x022e},\n#line 358 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004C\\000\\003\\004\", 0x04ef},\n#line 157 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003\\006\", 0x014f},\n#line 337 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\020\\000\\003\\010\", 0x04d2},\n#line 963 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\357\\0000\\231\", 0x30f7},\n#line 232 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003(\", 0x01eb},\n#line 933 \"./uninorm/composition-table.gperf\"\n      {\"\\0000{\\0000\\231\", 0x307c},\n#line 179 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003\\003\", 0x0169},\n#line 248 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003\\017\", 0x0200},\n#line 131 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\003\\004\", 0x012a},\n#line 376 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0110\\000\\011<\", 0x0931},\n#line 183 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003\\006\", 0x016d},\n#line 207 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\003\\014\", 0x01cf},\n#line 935 \"./uninorm/composition-table.gperf\"\n      {\"\\0000F\\0000\\231\", 0x3094},\n#line 189 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003(\", 0x0173},\n#line 550 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000X\\000\\003\\007\", 0x1e8a},\n#line 50 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003\\010\", 0x00cb},\n#line 253 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003\\017\", 0x0205},\n#line 62 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003\\001\", 0x00da},\n#line 61 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003\\000\", 0x00d9},\n#line 934 \"./uninorm/composition-table.gperf\"\n      {\"\\0000{\\0000\\232\", 0x307d},\n#line 63 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003\\002\", 0x00db},\n#line 569 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003\\011\", 0x1ea2},\n#line 469 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0367\\000\\003\\004\", 0x1e39},\n#line 316 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\025\\000\\003\\010\", 0x0401},\n#line 214 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\374\\000\\003\\004\", 0x01d6},\n#line 784 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037$\\000\\003E\", 0x1f94},\n#line 921 \"./uninorm/composition-table.gperf\"\n      {\"\\0000a\\0000\\231\", 0x3062},\n#line 218 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\374\\000\\003\\014\", 0x01da},\n#line 60 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003\\010\", 0x00d6},\n#line 365 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004+\\000\\003\\010\", 0x04f8},\n#line 594 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003\\011\", 0x1ebb},\n#line 335 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\020\\000\\003\\006\", 0x04d0},\n#line 338 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0040\\000\\003\\010\", 0x04d3},\n#line 568 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003#\", 0x1ea1},\n#line 91 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000y\\000\\003\\001\", 0x00fd},\n#line 650 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000y\\000\\003\\000\", 0x1ef3},\n#line 93 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003\\004\", 0x0100},\n#line 193 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000y\\000\\003\\002\", 0x0177},\n#line 555 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000y\\000\\003\\007\", 0x1e8f},\n#line 205 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003\\014\", 0x01cd},\n#line 595 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003\\003\", 0x1ebc},\n#line 949 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\304\\0000\\231\", 0x30c5},\n#line 261 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003\\017\", 0x020d},\n#line 552 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000X\\000\\003\\010\", 0x1e8c},\n#line 111 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003\\006\", 0x0114},\n#line 110 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003\\004\", 0x0113},\n#line 967 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\375\\0000\\231\", 0x30fe},\n#line 115 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003(\", 0x0118},\n#line 118 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003\\014\", 0x011b},\n#line 610 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000i\\000\\003#\", 0x1ecb},\n#line 64 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003\\010\", 0x00dc},\n#line 269 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003\\017\", 0x0215},\n#line 339 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\025\\000\\003\\006\", 0x04d6},\n#line 59 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003\\003\", 0x00d5},\n#line 539 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000v\\000\\003#\", 0x1e7f},\n#line 519 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000t\\000\\003\\007\", 0x1e6b},\n#line 614 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003\\011\", 0x1ecf},\n#line 156 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003\\006\", 0x014e},\n#line 434 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\022\\000\\003\\001\", 0x1e16},\n#line 432 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\022\\000\\003\\000\", 0x1e14},\n#line 231 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003(\", 0x01ea},\n#line 336 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0040\\000\\003\\006\", 0x04d1},\n#line 684 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\031\\000\\003\\001\", 0x1f1d},\n#line 682 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\031\\000\\003\\000\", 0x1f1b},\n#line 275 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000t\\000\\003&\", 0x021b},\n#line 638 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003\\011\", 0x1ee7},\n#line 161 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000r\\000\\003\\001\", 0x0155},\n#line 92 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000y\\000\\003\\010\", 0x00ff},\n#line 609 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\003#\", 0x1eca},\n#line 824 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037t\\000\\003E\", 0x1fc2},\n#line 501 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000r\\000\\003\\007\", 0x1e59},\n#line 155 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003\\004\", 0x014d},\n#line 966 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\362\\0000\\231\", 0x30fa},\n#line 965 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\361\\0000\\231\", 0x30f9},\n#line 210 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003\\014\", 0x01d2},\n#line 178 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003\\003\", 0x0168},\n#line 420 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\307\\000\\003\\001\", 0x1e08},\n#line 149 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000n\\000\\003\\001\", 0x0144},\n#line 241 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000n\\000\\003\\000\", 0x01f9},\n#line 182 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003\\006\", 0x016c},\n#line 181 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003\\004\", 0x016b},\n#line 481 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000n\\000\\003\\007\", 0x1e45},\n#line 188 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003(\", 0x0172},\n#line 212 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003\\014\", 0x01d4},\n#line 563 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000t\\000\\003\\010\", 0x1e97},\n#line 252 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003\\017\", 0x0204},\n#line 678 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\021\\000\\003\\001\", 0x1f15},\n#line 676 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\021\\000\\003\\000\", 0x1f13},\n#line 794 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037.\\000\\003E\", 0x1f9e},\n#line 423 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000d\\000\\003\\007\", 0x1e0b},\n#line 251 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003\\021\", 0x0203},\n#line 414 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000B\\000\\003\\007\", 0x1e02},\n#line 656 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000y\\000\\003\\003\", 0x1ef9},\n#line 964 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\360\\0000\\231\", 0x30f8},\n#line 393 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\015F\\000\\015>\", 0x0d4a},\n#line 810 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037n\\000\\003E\", 0x1fae},\n#line 567 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003#\", 0x1ea0},\n#line 969 \"./uninorm/composition-table.gperf\"\n      {\"\\001\\020\\233\\001\\020\\272\", 0x1109c},\n#line 260 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003\\017\", 0x020c},\n#line 593 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003\\011\", 0x1eba},\n#line 344 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0046\\000\\003\\010\", 0x04dd},\n#line 775 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\013\\000\\003E\", 0x1f8b},\n#line 332 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004u\\000\\003\\017\", 0x0477},\n#line 800 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037d\\000\\003E\", 0x1fa4},\n#line 951 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\310\\0000\\231\", 0x30c9},\n#line 592 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003#\", 0x1eb9},\n#line 259 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000i\\000\\003\\021\", 0x020b},\n#line 127 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000H\\000\\003\\002\", 0x0124},\n#line 446 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000H\\000\\003\\007\", 0x1e22},\n#line 71 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003\\012\", 0x00e5},\n#line 727 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037H\\000\\003\\001\", 0x1f4c},\n#line 725 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037H\\000\\003\\000\", 0x1f4a},\n#line 613 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003\\011\", 0x1ece},\n#line 945 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\273\\0000\\231\", 0x30bc},\n#line 109 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003\\004\", 0x0112},\n#line 65 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Y\\000\\003\\001\", 0x00dd},\n#line 649 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Y\\000\\003\\000\", 0x1ef2},\n#line 117 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003\\014\", 0x011a},\n#line 192 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Y\\000\\003\\002\", 0x0176},\n#line 554 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Y\\000\\003\\007\", 0x1e8e},\n#line 268 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003\\017\", 0x0214},\n#line 739 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037Y\\000\\003\\001\", 0x1f5d},\n#line 738 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037Y\\000\\003\\000\", 0x1f5b},\n#line 740 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037Y\\000\\003B\", 0x1f5f},\n#line 925 \"./uninorm/composition-table.gperf\"\n      {\"\\0000o\\0000\\231\", 0x3070},\n#line 258 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\003\\021\", 0x020a},\n#line 946 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\275\\0000\\231\", 0x30be},\n#line 154 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003\\004\", 0x014c},\n#line 488 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\325\\000\\003\\001\", 0x1e4c},\n#line 334 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0046\\000\\003\\006\", 0x04c2},\n#line 209 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003\\014\", 0x01d1},\n#line 612 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003#\", 0x1ecd},\n#line 532 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001h\\000\\003\\001\", 0x1e78},\n#line 929 \"./uninorm/composition-table.gperf\"\n      {\"\\0000u\\0000\\231\", 0x3076},\n#line 637 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003\\011\", 0x1ee6},\n#line 81 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000n\\000\\003\\003\", 0x00f1},\n#line 938 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\255\\0000\\231\", 0x30ae},\n#line 450 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000H\\000\\003\\010\", 0x1e26},\n#line 926 \"./uninorm/composition-table.gperf\"\n      {\"\\0000o\\0000\\232\", 0x3071},\n#line 475 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000m\\000\\003\\001\", 0x1e3f},\n#line 636 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003#\", 0x1ee5},\n#line 128 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000h\\000\\003\\002\", 0x0125},\n#line 447 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000h\\000\\003\\007\", 0x1e23},\n#line 477 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000m\\000\\003\\007\", 0x1e41},\n#line 753 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037h\\000\\003\\001\", 0x1f6c},\n#line 751 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037h\\000\\003\\000\", 0x1f6a},\n#line 755 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037h\\000\\003B\", 0x1f6e},\n#line 930 \"./uninorm/composition-table.gperf\"\n      {\"\\0000u\\0000\\232\", 0x3077},\n#line 194 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Y\\000\\003\\010\", 0x0178},\n#line 180 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003\\004\", 0x016a},\n#line 395 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\015F\\000\\015W\", 0x0d4c},\n#line 654 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000y\\000\\003\\011\", 0x1ef7},\n#line 211 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003\\014\", 0x01d3},\n#line 250 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003\\021\", 0x0202},\n#line 46 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000C\\000\\003'\", 0x00c7},\n#line 782 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\\"\\000\\003E\", 0x1f92},\n#line 804 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037h\\000\\003E\", 0x1fa8},\n#line 809 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037m\\000\\003E\", 0x1fad},\n#line 697 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037(\\000\\003\\001\", 0x1f2c},\n#line 695 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037(\\000\\003\\000\", 0x1f2a},\n#line 699 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037(\\000\\003B\", 0x1f2e},\n#line 490 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\325\\000\\003\\010\", 0x1e4e},\n#line 255 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003\\021\", 0x0207},\n#line 706 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0371\\000\\003\\001\", 0x1f35},\n#line 704 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0371\\000\\003\\000\", 0x1f33},\n#line 708 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0371\\000\\003B\", 0x1f37},\n#line 291 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000y\\000\\003\\004\", 0x0233},\n#line 962 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\246\\0000\\231\", 0x30f4},\n#line 437 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003-\", 0x1e19},\n#line 265 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000r\\000\\003\\017\", 0x0211},\n#line 788 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037(\\000\\003E\", 0x1f98},\n#line 451 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000h\\000\\003\\010\", 0x1e27},\n#line 45 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003\\012\", 0x00c5},\n#line 655 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Y\\000\\003\\003\", 0x1ef8},\n#line 591 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003#\", 0x1eb8},\n#line 542 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000W\\000\\003\\001\", 0x1e82},\n#line 540 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000W\\000\\003\\000\", 0x1e80},\n#line 160 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000R\\000\\003\\001\", 0x0154},\n#line 190 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000W\\000\\003\\002\", 0x0174},\n#line 546 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000W\\000\\003\\007\", 0x1e86},\n#line 912 \"./uninorm/composition-table.gperf\"\n      {\"\\0000O\\0000\\231\", 0x3050},\n#line 500 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000R\\000\\003\\007\", 0x1e58},\n#line 878 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"C\\000\\0038\", 0x2244},\n#line 872 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\003\\000\\0038\", 0x2204},\n#line 873 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\010\\000\\0038\", 0x2209},\n#line 893 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"{\\000\\0038\", 0x2281},\n#line 177 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000t\\000\\003\\014\", 0x0165},\n#line 611 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003#\", 0x1ecc},\n#line 263 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003\\021\", 0x020f},\n#line 468 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0366\\000\\003\\004\", 0x1e38},\n#line 238 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000G\\000\\003\\001\", 0x01f4},\n#line 908 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\264\\000\\0038\", 0x22ec},\n#line 906 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\262\\000\\0038\", 0x22ea},\n#line 119 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000G\\000\\003\\002\", 0x011c},\n#line 123 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000G\\000\\003\\007\", 0x0120},\n#line 288 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\002.\\000\\003\\004\", 0x0230},\n#line 877 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"<\\000\\0038\", 0x2241},\n#line 271 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003\\021\", 0x0217},\n#line 905 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\222\\000\\0038\", 0x22e3},\n#line 457 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000i\\000\\0030\", 0x1e2d},\n#line 898 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\242\\000\\0038\", 0x22ac},\n#line 165 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000r\\000\\003\\014\", 0x0159},\n#line 915 \"./uninorm/composition-table.gperf\"\n      {\"\\0000U\\0000\\231\", 0x3056},\n#line 531 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003-\", 0x1e77},\n#line 936 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\235\\0000\\231\", 0x309e},\n#line 331 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004t\\000\\003\\017\", 0x0476},\n#line 882 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"a\\000\\0038\", 0x2262},\n#line 440 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\002(\\000\\003\\006\", 0x1e1c},\n#line 544 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000W\\000\\003\\010\", 0x1e84},\n#line 635 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003#\", 0x1ee4},\n#line 148 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000N\\000\\003\\001\", 0x0143},\n#line 240 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000N\\000\\003\\000\", 0x01f8},\n#line 153 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000n\\000\\003\\014\", 0x0148},\n#line 375 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\011(\\000\\011<\", 0x0929},\n#line 480 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000N\\000\\003\\007\", 0x1e44},\n#line 897 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\207\\000\\0038\", 0x2289},\n#line 185 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003\\012\", 0x016f},\n#line 896 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\206\\000\\0038\", 0x2288},\n#line 456 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\0030\", 0x1e2c},\n#line 895 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\203\\000\\0038\", 0x2285},\n#line 108 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000d\\000\\003\\014\", 0x010f},\n#line 543 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000w\\000\\003\\001\", 0x1e83},\n#line 541 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000w\\000\\003\\000\", 0x1e81},\n#line 523 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000t\\000\\0031\", 0x1e6f},\n#line 191 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000w\\000\\003\\002\", 0x0175},\n#line 547 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000w\\000\\003\\007\", 0x1e87},\n#line 652 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000y\\000\\003#\", 0x1ef5},\n#line 890 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"v\\000\\0038\", 0x2278},\n#line 297 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\237\\000\\003\\001\", 0x038c},\n#line 863 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\237\\000\\003\\000\", 0x1ff8},\n#line 239 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000g\\000\\003\\001\", 0x01f5},\n#line 254 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003\\021\", 0x0206},\n#line 653 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Y\\000\\003\\011\", 0x1ef6},\n#line 120 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000g\\000\\003\\002\", 0x011d},\n#line 124 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000g\\000\\003\\007\", 0x0121},\n#line 343 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\026\\000\\003\\010\", 0x04dc},\n#line 902 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"|\\000\\0038\", 0x22e0},\n#line 436 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003-\", 0x1e18},\n#line 507 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000r\\000\\0031\", 0x1e5f},\n#line 276 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000H\\000\\003\\014\", 0x021e},\n#line 494 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001L\\000\\003\\001\", 0x1e52},\n#line 492 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001L\\000\\003\\000\", 0x1e50},\n#line 443 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000f\\000\\003\\007\", 0x1e1f},\n#line 521 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000t\\000\\003#\", 0x1e6d},\n#line 262 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003\\021\", 0x020e},\n#line 894 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\202\\000\\0038\", 0x2284},\n#line 142 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000L\\000\\003\\001\", 0x0139},\n#line 290 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Y\\000\\003\\004\", 0x0232},\n#line 803 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037g\\000\\003E\", 0x1fa7},\n#line 485 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000n\\000\\0031\", 0x1e49},\n#line 281 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003'\", 0x0229},\n#line 927 \"./uninorm/composition-table.gperf\"\n      {\"\\0000r\\0000\\231\", 0x3073},\n#line 121 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000G\\000\\003\\006\", 0x011e},\n#line 313 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\322\\000\\003\\001\", 0x03d3},\n#line 545 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000w\\000\\003\\010\", 0x1e85},\n#line 439 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\0030\", 0x1e1b},\n#line 802 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037f\\000\\003E\", 0x1fa6},\n#line 427 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000d\\000\\0031\", 0x1e0f},\n#line 503 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000r\\000\\003#\", 0x1e5b},\n#line 418 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000B\\000\\0031\", 0x1e06},\n#line 284 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\325\\000\\003\\004\", 0x022c},\n#line 495 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001M\\000\\003\\001\", 0x1e53},\n#line 493 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001M\\000\\003\\000\", 0x1e51},\n#line 903 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"}\\000\\0038\", 0x22e1},\n#line 333 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\026\\000\\003\\006\", 0x04c1},\n#line 928 \"./uninorm/composition-table.gperf\"\n      {\"\\0000r\\0000\\232\", 0x3074},\n#line 270 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003\\021\", 0x0216},\n#line 474 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000M\\000\\003\\001\", 0x1e3e},\n#line 55 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000N\\000\\003\\003\", 0x00d1},\n#line 483 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000n\\000\\003#\", 0x1e47},\n#line 922 \"./uninorm/composition-table.gperf\"\n      {\"\\0000d\\0000\\231\", 0x3065},\n#line 476 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000M\\000\\003\\007\", 0x1e40},\n#line 530 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003-\", 0x1e76},\n#line 277 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000h\\000\\003\\014\", 0x021f},\n#line 364 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004G\\000\\003\\010\", 0x04f5},\n#line 518 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000T\\000\\003\\007\", 0x1e6a},\n#line 920 \"./uninorm/composition-table.gperf\"\n      {\"\\0000_\\0000\\231\", 0x3060},\n#line 425 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000d\\000\\003#\", 0x1e0d},\n#line 887 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"e\\000\\0038\", 0x2271},\n#line 416 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000B\\000\\003#\", 0x1e04},\n#line 264 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000R\\000\\003\\017\", 0x0210},\n#line 844 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\376\\000\\003\\001\", 0x1fde},\n#line 843 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\376\\000\\003\\000\", 0x1fdd},\n#line 845 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\376\\000\\003B\", 0x1fdf},\n#line 274 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000T\\000\\003&\", 0x021a},\n#line 184 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003\\012\", 0x016e},\n#line 314 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\322\\000\\003\\010\", 0x03d4},\n#line 310 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\277\\000\\003\\001\", 0x03cc},\n#line 761 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\277\\000\\003\\000\", 0x1f78},\n#line 723 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\237\\000\\003\\023\", 0x1f48},\n#line 529 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\0030\", 0x1e75},\n#line 919 \"./uninorm/composition-table.gperf\"\n      {\"\\0000]\\0000\\231\", 0x305e},\n#line 122 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000g\\000\\003\\006\", 0x011f},\n#line 306 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\271\\000\\003\\001\", 0x03af},\n#line 760 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\271\\000\\003\\000\", 0x1f76},\n#line 838 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\271\\000\\003B\", 0x1fd6},\n#line 448 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000H\\000\\003#\", 0x1e24},\n#line 833 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\277\\000\\003\\001\", 0x1fce},\n#line 832 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\277\\000\\003\\000\", 0x1fcd},\n#line 834 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\277\\000\\003B\", 0x1fcf},\n#line 917 \"./uninorm/composition-table.gperf\"\n      {\"\\0000Y\\0000\\231\", 0x305a},\n#line 319 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\032\\000\\003\\001\", 0x040c},\n#line 565 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000y\\000\\003\\012\", 0x1e99},\n#line 885 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000>\\000\\0038\", 0x226f},\n#line 435 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\023\\000\\003\\001\", 0x1e17},\n#line 433 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\023\\000\\003\\000\", 0x1e15},\n#line 525 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000t\\000\\003-\", 0x1e71},\n#line 651 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Y\\000\\003#\", 0x1ef4},\n#line 345 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\027\\000\\003\\010\", 0x04de},\n#line 776 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\014\\000\\003E\", 0x1f8c},\n#line 562 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000h\\000\\0031\", 0x1e96},\n#line 941 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\263\\0000\\231\", 0x30b4},\n#line 164 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000R\\000\\003\\014\", 0x0158},\n#line 956 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\325\\0000\\231\", 0x30d6},\n#line 779 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\017\\000\\003E\", 0x1f8f},\n#line 267 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000r\\000\\003\\021\", 0x0213},\n#line 305 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\267\\000\\003\\001\", 0x03ae},\n#line 759 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\267\\000\\003\\000\", 0x1f74},\n#line 827 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\267\\000\\003B\", 0x1fc6},\n#line 280 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003'\", 0x0228},\n#line 626 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\241\\000\\003\\001\", 0x1edb},\n#line 628 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\241\\000\\003\\000\", 0x1edd},\n#line 444 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000G\\000\\003\\004\", 0x1e20},\n#line 924 \"./uninorm/composition-table.gperf\"\n      {\"\\0000h\\0000\\231\", 0x3069},\n#line 438 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\0030\", 0x1e1a},\n#line 227 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000G\\000\\003\\014\", 0x01e6},\n#line 308 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\271\\000\\003\\010\", 0x03ca},\n#line 957 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\325\\0000\\232\", 0x30d7},\n#line 825 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\267\\000\\003E\", 0x1fc3},\n#line 960 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\333\\0000\\231\", 0x30dc},\n#line 449 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000h\\000\\003#\", 0x1e25},\n#line 479 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000m\\000\\003#\", 0x1e43},\n#line 487 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000n\\000\\003-\", 0x1e4b},\n#line 937 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\253\\0000\\231\", 0x30ac},\n#line 303 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\261\\000\\003\\001\", 0x03ac},\n#line 757 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\261\\000\\003\\000\", 0x1f70},\n#line 817 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\261\\000\\003B\", 0x1fb6},\n#line 352 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004>\\000\\003\\010\", 0x04e7},\n#line 293 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\221\\000\\003\\001\", 0x0386},\n#line 821 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\221\\000\\003\\000\", 0x1fba},\n#line 431 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000d\\000\\003-\", 0x1e13},\n#line 606 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\036\\271\\000\\003\\002\", 0x1ec7},\n#line 778 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\016\\000\\003E\", 0x1f8e},\n#line 961 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\333\\0000\\232\", 0x30dd},\n#line 362 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004C\\000\\003\\013\", 0x04f3},\n#line 152 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000N\\000\\003\\014\", 0x0147},\n#line 815 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\261\\000\\003E\", 0x1fb3},\n#line 879 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"E\\000\\0038\", 0x2247},\n#line 717 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\277\\000\\003\\023\", 0x1f40},\n#line 506 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000R\\000\\0031\", 0x1e5e},\n#line 822 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\221\\000\\003E\", 0x1fbc},\n#line 356 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004M\\000\\003\\010\", 0x04ed},\n#line 724 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\237\\000\\003\\024\", 0x1f49},\n#line 167 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000s\\000\\003\\001\", 0x015b},\n#line 701 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\271\\000\\003\\023\", 0x1f30},\n#line 835 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\271\\000\\003\\006\", 0x1fd0},\n#line 169 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000s\\000\\003\\002\", 0x015d},\n#line 509 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000s\\000\\003\\007\", 0x1e61},\n#line 977 \"./uninorm/composition-table.gperf\"\n      {\"\\001\\024\\271\\001\\024\\275\", 0x114be},\n#line 528 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\0030\", 0x1e74},\n#line 916 \"./uninorm/composition-table.gperf\"\n      {\"\\0000W\\0000\\231\", 0x3058},\n#line 317 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\023\\000\\003\\001\", 0x0403},\n#line 445 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000g\\000\\003\\004\", 0x1e21},\n#line 460 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000K\\000\\003\\001\", 0x1e30},\n#line 770 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\006\\000\\003E\", 0x1f86},\n#line 228 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000g\\000\\003\\014\", 0x01e7},\n#line 273 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000s\\000\\003&\", 0x0219},\n#line 548 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000W\\000\\003#\", 0x1e88},\n#line 244 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\306\\000\\003\\001\", 0x01fc},\n#line 502 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000R\\000\\003#\", 0x1e5a},\n#line 580 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\036\\241\\000\\003\\002\", 0x1ead},\n#line 311 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\305\\000\\003\\001\", 0x03cd},\n#line 762 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\305\\000\\003\\000\", 0x1f7a},\n#line 851 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\305\\000\\003B\", 0x1fe6},\n#line 143 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000l\\000\\003\\001\", 0x013a},\n#line 242 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\305\\000\\003\\001\", 0x01fa},\n#line 166 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000S\\000\\003\\001\", 0x015a},\n#line 685 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\267\\000\\003\\023\", 0x1f20},\n#line 632 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\241\\000\\003\\003\", 0x1ee1},\n#line 168 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000S\\000\\003\\002\", 0x015c},\n#line 508 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000S\\000\\003\\007\", 0x1e60},\n#line 146 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000L\\000\\003\\014\", 0x013d},\n#line 484 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000N\\000\\0031\", 0x1e48},\n#line 296 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\231\\000\\003\\001\", 0x038a},\n#line 842 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\231\\000\\003\\000\", 0x1fda},\n#line 512 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001Z\\000\\003\\007\", 0x1e64},\n#line 828 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\306\\000\\003E\", 0x1fc7},\n#line 195 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Z\\000\\003\\001\", 0x0179},\n#line 175 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000t\\000\\003'\", 0x0163},\n#line 272 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000S\\000\\003&\", 0x0218},\n#line 556 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Z\\000\\003\\002\", 0x1e90},\n#line 197 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Z\\000\\003\\007\", 0x017b},\n#line 808 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037l\\000\\003E\", 0x1fac},\n      {\"\"},\n#line 100 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000c\\000\\003\\001\", 0x0107},\n#line 657 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\261\\000\\003\\023\", 0x1f00},\n#line 812 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\261\\000\\003\\006\", 0x1fb0},\n#line 102 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000c\\000\\003\\002\", 0x0109},\n#line 104 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000c\\000\\003\\007\", 0x010b},\n#line 665 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\221\\000\\003\\023\", 0x1f08},\n#line 819 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\221\\000\\003\\006\", 0x1fb8},\n      {\"\"},\n#line 482 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000N\\000\\003#\", 0x1e46},\n#line 163 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000r\\000\\003'\", 0x0157},\n#line 309 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\305\\000\\003\\010\", 0x03cb},\n#line 196 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000z\\000\\003\\001\", 0x017a},\n#line 176 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000T\\000\\003\\014\", 0x0164},\n#line 422 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000D\\000\\003\\007\", 0x1e0a},\n#line 557 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000z\\000\\003\\002\", 0x1e91},\n#line 198 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000z\\000\\003\\007\", 0x017c},\n      {\"\"},\n#line 718 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\277\\000\\003\\024\", 0x1f41},\n#line 799 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037c\\000\\003E\", 0x1fa3},\n#line 549 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000w\\000\\003#\", 0x1e89},\n#line 151 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000n\\000\\003'\", 0x0146},\n#line 159 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003\\013\", 0x0151},\n#line 301 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\231\\000\\003\\010\", 0x03aa},\n#line 702 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\271\\000\\003\\024\", 0x1f31},\n#line 470 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000L\\000\\0031\", 0x1e3a},\n      {\"\"},\n#line 640 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\260\\000\\003\\001\", 0x1ee9},\n#line 642 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\260\\000\\003\\000\", 0x1eeb},\n#line 429 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000d\\000\\003'\", 0x1e11},\n#line 923 \"./uninorm/composition-table.gperf\"\n      {\"\\0000f\\0000\\231\", 0x3067},\n#line 187 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003\\013\", 0x0171},\n#line 836 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\271\\000\\003\\004\", 0x1fd1},\n#line 266 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000R\\000\\003\\021\", 0x0212},\n#line 625 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\240\\000\\003\\001\", 0x1eda},\n#line 627 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\240\\000\\003\\000\", 0x1edc},\n#line 590 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\036\\241\\000\\003\\006\", 0x1eb7},\n#line 318 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\006\\000\\003\\010\", 0x0407},\n#line 888 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"r\\000\\0038\", 0x2274},\n#line 729 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\305\\000\\003\\023\", 0x1f50},\n#line 846 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\305\\000\\003\\006\", 0x1fe0},\n#line 639 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\257\\000\\003\\001\", 0x1ee8},\n#line 641 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\257\\000\\003\\000\", 0x1eea},\n      {\"\"},\n#line 630 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\241\\000\\003\\011\", 0x1edf},\n#line 466 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000L\\000\\003#\", 0x1e36},\n#line 517 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\036c\\000\\003\\007\", 0x1e69},\n#line 686 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\267\\000\\003\\024\", 0x1f21},\n#line 452 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000H\\000\\003'\", 0x1e28},\n#line 954 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\322\\0000\\231\", 0x30d3},\n#line 522 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000T\\000\\0031\", 0x1e6e},\n#line 709 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\231\\000\\003\\023\", 0x1f38},\n#line 840 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\231\\000\\003\\006\", 0x1fd8},\n#line 856 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\241\\000\\003\\024\", 0x1fec},\n#line 366 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004K\\000\\003\\010\", 0x04f9},\n#line 874 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\013\\000\\0038\", 0x220c},\n#line 235 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\267\\000\\003\\014\", 0x01ee},\n#line 886 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"d\\000\\0038\", 0x2270},\n      {\"\"},\n#line 911 \"./uninorm/composition-table.gperf\"\n      {\"\\0000M\\0000\\231\", 0x304e},\n#line 415 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000b\\000\\003\\007\", 0x1e03},\n#line 785 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037%\\000\\003E\", 0x1f95},\n      {\"\"},\n#line 955 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\322\\0000\\232\", 0x30d4},\n#line 394 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\015G\\000\\015>\", 0x0d4b},\n#line 658 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\261\\000\\003\\024\", 0x1f01},\n#line 478 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000M\\000\\003#\", 0x1e42},\n#line 304 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\265\\000\\003\\001\", 0x03ad},\n#line 758 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\265\\000\\003\\000\", 0x1f72},\n#line 666 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\221\\000\\003\\024\", 0x1f09},\n#line 520 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000T\\000\\003#\", 0x1e6c},\n#line 975 \"./uninorm/composition-table.gperf\"\n      {\"\\001\\024\\271\\001\\024\\272\", 0x114bb},\n#line 486 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000N\\000\\003-\", 0x1e4a},\n#line 813 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\261\\000\\003\\004\", 0x1fb1},\n#line 798 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037b\\000\\003E\", 0x1fa2},\n#line 783 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037#\\000\\003E\", 0x1f93},\n#line 880 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"H\\000\\0038\", 0x2249},\n#line 820 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\221\\000\\003\\004\", 0x1fb9},\n#line 158 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003\\013\", 0x0150},\n#line 461 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000k\\000\\003\\001\", 0x1e31},\n#line 795 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037/\\000\\003E\", 0x1f9f},\n#line 246 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\330\\000\\003\\001\", 0x01fe},\n#line 453 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000h\\000\\003'\", 0x1e29},\n#line 947 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\277\\0000\\231\", 0x30c0},\n#line 579 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\036\\240\\000\\003\\002\", 0x1eac},\n#line 646 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\260\\000\\003\\003\", 0x1eef},\n#line 300 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\312\\000\\003\\001\", 0x0390},\n#line 837 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\312\\000\\003\\000\", 0x1fd2},\n#line 839 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\312\\000\\003B\", 0x1fd7},\n#line 944 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\271\\0000\\231\", 0x30ba},\n#line 597 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\312\\000\\003\\001\", 0x1ebe},\n#line 599 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\312\\000\\003\\000\", 0x1ec0},\n#line 631 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\240\\000\\003\\003\", 0x1ee0},\n#line 849 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\301\\000\\003\\023\", 0x1fe4},\n#line 408 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\033<\\000\\0335\", 0x1b3d},\n#line 173 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000s\\000\\003\\014\", 0x0161},\n#line 564 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000w\\000\\003\\012\", 0x1e98},\n#line 807 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037k\\000\\003E\", 0x1fab},\n#line 907 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\263\\000\\0038\", 0x22eb},\n#line 645 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\257\\000\\003\\003\", 0x1eee},\n#line 186 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003\\013\", 0x0170},\n#line 516 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\036b\\000\\003\\007\", 0x1e68},\n#line 730 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\305\\000\\003\\024\", 0x1f51},\n#line 299 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\251\\000\\003\\001\", 0x038f},\n#line 864 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\251\\000\\003\\000\", 0x1ffa},\n#line 229 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000K\\000\\003\\014\", 0x01e8},\n#line 535 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001k\\000\\003\\010\", 0x1e7b},\n#line 225 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\306\\000\\003\\004\", 0x01e2},\n#line 472 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000L\\000\\003-\", 0x1e3c},\n#line 407 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\033:\\000\\0335\", 0x1b3b},\n#line 847 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\305\\000\\003\\004\", 0x1fe1},\n#line 403 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\033\\011\\000\\0335\", 0x1b0a},\n#line 943 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\267\\0000\\231\", 0x30b8},\n      {\"\"},\n#line 710 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\231\\000\\003\\024\", 0x1f39},\n#line 865 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\251\\000\\003E\", 0x1ffc},\n#line 147 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000l\\000\\003\\014\", 0x013e},\n#line 551 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000x\\000\\003\\007\", 0x1e8b},\n#line 172 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000S\\000\\003\\014\", 0x0160},\n#line 634 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\241\\000\\003#\", 0x1ee3},\n#line 901 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\253\\000\\0038\", 0x22af},\n#line 162 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000R\\000\\003'\", 0x0156},\n#line 841 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\231\\000\\003\\004\", 0x1fd9},\n#line 713 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0378\\000\\003\\001\", 0x1f3c},\n#line 711 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0378\\000\\003\\000\", 0x1f3a},\n#line 715 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0378\\000\\003B\", 0x1f3e},\n#line 298 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\245\\000\\003\\001\", 0x038e},\n#line 855 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\245\\000\\003\\000\", 0x1fea},\n#line 673 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\265\\000\\003\\023\", 0x1f10},\n#line 199 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Z\\000\\003\\014\", 0x017d},\n#line 940 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\261\\0000\\231\", 0x30b2},\n#line 683 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\030\\000\\003\\001\", 0x1f1c},\n#line 681 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\030\\000\\003\\000\", 0x1f1a},\n#line 524 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000T\\000\\003-\", 0x1e70},\n#line 125 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000G\\000\\003'\", 0x0122},\n#line 513 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001[\\000\\003\\007\", 0x1e65},\n#line 106 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000c\\000\\003\\014\", 0x010d},\n#line 312 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\311\\000\\003\\001\", 0x03ce},\n#line 763 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\311\\000\\003\\000\", 0x1f7c},\n#line 861 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\311\\000\\003B\", 0x1ff6},\n#line 402 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\033\\007\\000\\0335\", 0x1b08},\n#line 359 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004#\\000\\003\\010\", 0x04f0},\n#line 464 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000K\\000\\0031\", 0x1e34},\n#line 589 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\036\\240\\000\\003\\006\", 0x1eb6},\n#line 644 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\260\\000\\003\\011\", 0x1eed},\n#line 107 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000D\\000\\003\\014\", 0x010e},\n#line 553 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000x\\000\\003\\010\", 0x1e8d},\n#line 200 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000z\\000\\003\\014\", 0x017e},\n#line 603 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\312\\000\\003\\003\", 0x1ec4},\n#line 859 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\311\\000\\003E\", 0x1ff3},\n#line 458 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\317\\000\\003\\001\", 0x1e2e},\n#line 629 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\240\\000\\003\\011\", 0x1ede},\n#line 511 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000s\\000\\003#\", 0x1e63},\n#line 471 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000l\\000\\0031\", 0x1e3b},\n#line 150 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000N\\000\\003'\", 0x0145},\n#line 910 \"./uninorm/composition-table.gperf\"\n      {\"\\0000K\\0000\\231\", 0x304c},\n#line 850 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\301\\000\\003\\024\", 0x1fe5},\n#line 536 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000V\\000\\003\\003\", 0x1e7c},\n#line 643 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\257\\000\\003\\011\", 0x1eec},\n#line 302 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\245\\000\\003\\010\", 0x03ab},\n#line 950 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\306\\0000\\231\", 0x30c7},\n#line 368 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\006'\\000\\006T\", 0x0623},\n#line 462 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000K\\000\\003#\", 0x1e32},\n      {\"\"},\n#line 749 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\251\\000\\003\\023\", 0x1f68},\n#line 341 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\330\\000\\003\\010\", 0x04da},\n#line 560 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Z\\000\\0031\", 0x1e94},\n#line 504 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\036Z\\000\\003\\004\", 0x1e5c},\n#line 914 \"./uninorm/composition-table.gperf\"\n      {\"\\0000S\\0000\\231\", 0x3054},\n#line 329 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0048\\000\\003\\000\", 0x045d},\n#line 321 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004#\\000\\003\\006\", 0x040e},\n#line 615 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\324\\000\\003\\001\", 0x1ed0},\n#line 617 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\324\\000\\003\\000\", 0x1ed2},\n#line 467 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000l\\000\\003#\", 0x1e37},\n#line 126 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000g\\000\\003'\", 0x0123},\n#line 510 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000S\\000\\003#\", 0x1e62},\n#line 527 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003$\", 0x1e73},\n#line 320 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\030\\000\\003\\000\", 0x040d},\n      {\"\"},\n#line 598 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\352\\000\\003\\001\", 0x1ebf},\n#line 600 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\352\\000\\003\\000\", 0x1ec1},\n      {\"\"},\n#line 426 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000D\\000\\0031\", 0x1e0e},\n#line 327 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004V\\000\\003\\010\", 0x0457},\n#line 561 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000z\\000\\0031\", 0x1e95},\n#line 378 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\011\\307\\000\\011\\276\", 0x09cb},\n#line 558 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Z\\000\\003#\", 0x1e92},\n#line 289 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\002/\\000\\003\\004\", 0x0231},\n#line 853 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\245\\000\\003\\006\", 0x1fe8},\n#line 972 \"./uninorm/composition-table.gperf\"\n      {\"\\001\\0212\\001\\021'\", 0x1112f},\n#line 144 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000L\\000\\003'\", 0x013b},\n#line 674 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\265\\000\\003\\024\", 0x1f11},\n#line 371 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\006J\\000\\006T\", 0x0626},\n#line 891 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"w\\000\\0038\", 0x2279},\n#line 690 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037!\\000\\003\\001\", 0x1f25},\n#line 688 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037!\\000\\003\\000\", 0x1f23},\n#line 692 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037!\\000\\003B\", 0x1f27},\n#line 381 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\013G\\000\\013>\", 0x0b4b},\n#line 741 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\311\\000\\003\\023\", 0x1f60},\n#line 295 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\227\\000\\003\\001\", 0x0389},\n#line 830 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\227\\000\\003\\000\", 0x1fca},\n#line 350 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0048\\000\\003\\010\", 0x04e5},\n#line 424 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000D\\000\\003#\", 0x1e0c},\n#line 968 \"./uninorm/composition-table.gperf\"\n      {\"\\001\\020\\231\\001\\020\\272\", 0x1109a},\n#line 559 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000z\\000\\003#\", 0x1e93},\n      {\"\"},\n#line 781 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037!\\000\\003E\", 0x1f91},\n#line 601 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\312\\000\\003\\011\", 0x1ec2},\n      {\"\"},\n#line 349 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\030\\000\\003\\010\", 0x04e4},\n#line 401 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\033\\005\\000\\0335\", 0x1b06},\n#line 831 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\227\\000\\003E\", 0x1fcc},\n#line 978 \"./uninorm/composition-table.gperf\"\n      {\"\\001\\025\\270\\001\\025\\257\", 0x115ba},\n#line 405 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\033\\015\\000\\0335\", 0x1b0e},\n#line 230 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000k\\000\\003\\014\", 0x01e9},\n#line 174 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000T\\000\\003'\", 0x0162},\n#line 496 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000P\\000\\003\\001\", 0x1e54},\n#line 410 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\033?\\000\\0335\", 0x1b41},\n      {\"\"},\n#line 648 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\260\\000\\003#\", 0x1ef1},\n#line 498 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000P\\000\\003\\007\", 0x1e56},\n#line 948 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\301\\0000\\231\", 0x30c2},\n#line 733 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037P\\000\\003\\001\", 0x1f54},\n#line 731 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037P\\000\\003\\000\", 0x1f52},\n#line 735 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037P\\000\\003B\", 0x1f56},\n      {\"\"},\n#line 633 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\240\\000\\003#\", 0x1ee2},\n#line 750 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\251\\000\\003\\024\", 0x1f69},\n#line 419 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000b\\000\\0031\", 0x1e07},\n#line 621 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\324\\000\\003\\003\", 0x1ed6},\n#line 323 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0048\\000\\003\\006\", 0x0439},\n#line 868 \"./uninorm/composition-table.gperf\"\n      {\"\\000!\\224\\000\\0038\", 0x21ae},\n#line 939 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\257\\0000\\231\", 0x30b0},\n#line 647 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\257\\000\\003#\", 0x1ef0},\n#line 514 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001`\\000\\003\\007\", 0x1e66},\n#line 866 \"./uninorm/composition-table.gperf\"\n      {\"\\000!\\220\\000\\0038\", 0x219a},\n#line 473 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000l\\000\\003-\", 0x1e3d},\n#line 604 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\352\\000\\003\\003\", 0x1ec5},\n#line 322 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\030\\000\\003\\006\", 0x0419},\n#line 883 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"M\\000\\0038\", 0x226d},\n#line 357 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004#\\000\\003\\004\", 0x04ee},\n      {\"\"},\n#line 745 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037`\\000\\003\\001\", 0x1f64},\n#line 743 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037`\\000\\003\\000\", 0x1f62},\n#line 747 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037`\\000\\003B\", 0x1f66},\n#line 526 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003$\", 0x1e72},\n#line 616 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\364\\000\\003\\001\", 0x1ed1},\n#line 618 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\364\\000\\003\\000\", 0x1ed3},\n#line 417 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000b\\000\\003#\", 0x1e05},\n#line 867 \"./uninorm/composition-table.gperf\"\n      {\"\\000!\\222\\000\\0038\", 0x219b},\n#line 737 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\245\\000\\003\\024\", 0x1f59},\n#line 465 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000k\\000\\0031\", 0x1e35},\n      {\"\"},\n#line 382 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\013G\\000\\013W\", 0x0b4c},\n#line 796 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037`\\000\\003E\", 0x1fa0},\n      {\"\"},\n#line 942 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\265\\0000\\231\", 0x30b6},\n      {\"\"},\n#line 854 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\245\\000\\003\\004\", 0x1fe9},\n      {\"\"},\n#line 693 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\227\\000\\003\\023\", 0x1f28},\n#line 742 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\311\\000\\003\\024\", 0x1f61},\n#line 869 \"./uninorm/composition-table.gperf\"\n      {\"\\000!\\320\\000\\0038\", 0x21cd},\n#line 387 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\014F\\000\\014V\", 0x0c48},\n      {\"\"},\n#line 430 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000D\\000\\003-\", 0x1e12},\n#line 958 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\330\\0000\\231\", 0x30d9},\n#line 294 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\225\\000\\003\\001\", 0x0388},\n#line 829 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\225\\000\\003\\000\", 0x1fc8},\n#line 572 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\342\\000\\003\\001\", 0x1ea5},\n#line 574 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\342\\000\\003\\000\", 0x1ea7},\n#line 463 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000k\\000\\003#\", 0x1e33},\n#line 307 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\313\\000\\003\\001\", 0x03b0},\n#line 848 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\313\\000\\003\\000\", 0x1fe2},\n#line 852 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\313\\000\\003B\", 0x1fe7},\n#line 571 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\302\\000\\003\\001\", 0x1ea4},\n#line 573 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\302\\000\\003\\000\", 0x1ea6},\n#line 292 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\250\\000\\003\\001\", 0x0385},\n#line 857 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\250\\000\\003\\000\", 0x1fed},\n#line 823 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\250\\000\\003B\", 0x1fc1},\n#line 959 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\330\\0000\\232\", 0x30da},\n#line 734 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037Q\\000\\003\\001\", 0x1f55},\n#line 732 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037Q\\000\\003\\000\", 0x1f53},\n#line 736 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037Q\\000\\003B\", 0x1f57},\n#line 202 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003\\033\", 0x01a1},\n#line 497 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000p\\000\\003\\001\", 0x1e55},\n#line 786 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037&\\000\\003E\", 0x1f96},\n#line 139 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000j\\000\\003\\002\", 0x0135},\n#line 619 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\324\\000\\003\\011\", 0x1ed4},\n#line 499 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000p\\000\\003\\007\", 0x1e57},\n      {\"\"},\n#line 538 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000V\\000\\003#\", 0x1e7e},\n#line 324 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0045\\000\\003\\000\", 0x0450},\n#line 204 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003\\033\", 0x01b0},\n#line 413 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003%\", 0x1e01},\n      {\"\"},\n#line 602 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\352\\000\\003\\011\", 0x1ec3},\n#line 171 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000s\\000\\003'\", 0x015f},\n#line 931 \"./uninorm/composition-table.gperf\"\n      {\"\\0000x\\0000\\231\", 0x3079},\n      {\"\"},\n#line 348 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0048\\000\\003\\004\", 0x04e3},\n      {\"\"},\n#line 806 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037j\\000\\003E\", 0x1faa},\n#line 814 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037p\\000\\003E\", 0x1fb2},\n#line 622 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\364\\000\\003\\003\", 0x1ed7},\n#line 233 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\352\\000\\003\\004\", 0x01ec},\n      {\"\"},\n#line 140 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000K\\000\\003'\", 0x0136},\n#line 347 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\030\\000\\003\\004\", 0x04e2},\n      {\"\"},\n#line 505 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\036[\\000\\003\\004\", 0x1e5d},\n#line 534 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001j\\000\\003\\010\", 0x1e7a},\n#line 932 \"./uninorm/composition-table.gperf\"\n      {\"\\0000x\\0000\\232\", 0x307a},\n      {\"\"},\n#line 904 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\221\\000\\0038\", 0x22e2},\n      {\"\"}, {\"\"}, {\"\"},\n#line 145 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000l\\000\\003'\", 0x013c},\n      {\"\"},\n#line 170 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000S\\000\\003'\", 0x015e},\n      {\"\"},\n#line 918 \"./uninorm/composition-table.gperf\"\n      {\"\\0000[\\0000\\231\", 0x305c},\n#line 694 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\227\\000\\003\\024\", 0x1f29},\n#line 325 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0045\\000\\003\\010\", 0x0451},\n#line 889 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"s\\000\\0038\", 0x2275},\n      {\"\"},\n#line 578 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\342\\000\\003\\003\", 0x1eab},\n#line 679 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\225\\000\\003\\023\", 0x1f18},\n#line 689 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037 \\000\\003\\001\", 0x1f24},\n#line 687 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037 \\000\\003\\000\", 0x1f22},\n#line 691 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037 \\000\\003B\", 0x1f26},\n      {\"\"},\n#line 577 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\302\\000\\003\\003\", 0x1eaa},\n      {\"\"},\n#line 952 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\317\\0000\\231\", 0x30d0},\n      {\"\"}, {\"\"},\n#line 72 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000c\\000\\003'\", 0x00e7},\n#line 970 \"./uninorm/composition-table.gperf\"\n      {\"\\001\\020\\245\\001\\020\\272\", 0x110ab},\n#line 201 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003\\033\", 0x01a0},\n#line 780 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037 \\000\\003E\", 0x1f90},\n      {\"\"},\n#line 406 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\033\\021\\000\\0335\", 0x1b12},\n      {\"\"}, {\"\"},\n#line 404 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\033\\013\\000\\0335\", 0x1b0c},\n#line 428 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000D\\000\\003'\", 0x1e10},\n      {\"\"},\n#line 953 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\317\\0000\\232\", 0x30d1},\n#line 411 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\033B\\000\\0335\", 0x1b43},\n#line 454 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000H\\000\\003.\", 0x1e2a},\n      {\"\"},\n#line 340 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0045\\000\\003\\006\", 0x04d7},\n      {\"\"}, {\"\"}, {\"\"},\n#line 412 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003%\", 0x1e00},\n      {\"\"},\n#line 971 \"./uninorm/composition-table.gperf\"\n      {\"\\001\\0211\\001\\021'\", 0x1112e},\n#line 383 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\013\\222\\000\\013\\327\", 0x0b94},\n      {\"\"},\n#line 203 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003\\033\", 0x01af},\n#line 620 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\364\\000\\003\\011\", 0x1ed5},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 379 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\011\\307\\000\\011\\327\", 0x09cc},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 892 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"z\\000\\0038\", 0x2280},\n      {\"\"},\n#line 388 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\014\\277\\000\\014\\325\", 0x0cc0},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 455 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000h\\000\\003.\", 0x1e2b},\n#line 576 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\342\\000\\003\\011\", 0x1ea9},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 680 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\225\\000\\003\\024\", 0x1f19},\n#line 575 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\302\\000\\003\\011\", 0x1ea8},\n#line 223 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\002&\\000\\003\\004\", 0x01e0},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 396 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\015\\331\\000\\015\\312\", 0x0dda},\n#line 876 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"%\\000\\0038\", 0x2226},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 367 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\006'\\000\\006S\", 0x0622},\n#line 141 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000k\\000\\003'\", 0x0137},\n      {\"\"},\n#line 380 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\013G\\000\\013V\", 0x0b48},\n#line 237 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000j\\000\\003\\014\", 0x01f0},\n#line 385 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\013\\307\\000\\013\\276\", 0x0bcb},\n      {\"\"},\n#line 875 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"#\\000\\0038\", 0x2224},\n      {\"\"},\n#line 973 \"./uninorm/composition-table.gperf\"\n      {\"\\001\\023G\\001\\023>\", 0x1134b},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"},\n#line 909 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\265\\000\\0038\", 0x22ed},\n#line 369 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\006H\\000\\006T\", 0x0624},\n      {\"\"}, {\"\"}, {\"\"},\n#line 398 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\015\\334\\000\\015\\312\", 0x0ddd},\n      {\"\"}, {\"\"},\n#line 390 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\014\\306\\000\\014\\326\", 0x0cc8},\n#line 391 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\014\\306\\000\\014\\302\", 0x0cca},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"},\n#line 389 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\014\\306\\000\\014\\325\", 0x0cc7},\n      {\"\"}, {\"\"}, {\"\"},\n#line 913 \"./uninorm/composition-table.gperf\"\n      {\"\\0000Q\\0000\\231\", 0x3052},\n#line 372 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\006\\325\\000\\006T\", 0x06c0},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"},\n#line 900 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\251\\000\\0038\", 0x22ae},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 974 \"./uninorm/composition-table.gperf\"\n      {\"\\001\\023G\\001\\023W\", 0x1134c},\n#line 976 \"./uninorm/composition-table.gperf\"\n      {\"\\001\\024\\271\\001\\024\\260\", 0x114bc},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 409 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\033>\\000\\0335\", 0x1b40},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 392 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\014\\312\\000\\014\\325\", 0x0ccb},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"},\n#line 361 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004#\\000\\003\\013\", 0x04f2},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 374 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\006\\322\\000\\006T\", 0x06d3},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 979 \"./uninorm/composition-table.gperf\"\n      {\"\\001\\025\\271\\001\\025\\257\", 0x115bb},\n      {\"\"}, {\"\"}, {\"\"},\n#line 370 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\006'\\000\\006U\", 0x0625},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 899 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\250\\000\\0038\", 0x22ad},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"},\n#line 871 \"./uninorm/composition-table.gperf\"\n      {\"\\000!\\322\\000\\0038\", 0x21cf},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"},\n#line 384 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\013\\306\\000\\013\\276\", 0x0bca},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 373 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\006\\301\\000\\006T\", 0x06c2},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 400 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\020%\\000\\020.\", 0x1026},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 386 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\013\\306\\000\\013\\327\", 0x0bcc},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"},\n#line 870 \"./uninorm/composition-table.gperf\"\n      {\"\\000!\\324\\000\\0038\", 0x21ce}\n    };\n\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register unsigned int key = gl_uninorm_compose_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE)\n        if (len == lengthtable[key])\n          {\n            register const char *s = wordlist[key].codes;\n\n            if (*str == *s && !memcmp (str + 1, s + 1, len - 1))\n              return &wordlist[key];\n          }\n    }\n  return 0;\n}",
      "lines": 2142,
      "depth": 15,
      "decorators": [
        "const",
        "const",
        "struct composition_rule",
        "struct",
        "composition_rule",
        "*\ngl_uninorm_compose_lookup (register const char *str, register size_t len)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uninorm/composition.c": {
    "uc_composition": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "ucs4_t\nuc_composition (ucs4_t uc1, ucs4_t uc2)\n{\n  if (uc1 < 0x12000 && uc2 < 0x12000)\n    {\n      if (uc2 >= 0x1161 && uc2 < 0x1161 + 21\n          && uc1 >= 0x1100 && uc1 < 0x1100 + 19)\n        {\n          /* Hangul: Combine single letter L and single letter V to form\n             two-letter syllable LV.  */\n          return 0xAC00 + ((uc1 - 0x1100) * 21 + (uc2 - 0x1161)) * 28;\n        }\n      else if (uc2 > 0x11A7 && uc2 < 0x11A7 + 28\n               && uc1 >= 0xAC00 && uc1 < 0xD7A4 && ((uc1 - 0xAC00) % 28) == 0)\n        {\n          /* Hangul: Combine two-letter syllable LV with single-letter T\n             to form three-letter syllable LVT.  */\n          return uc1 + (uc2 - 0x11A7);\n        }\n      else\n        {\n#if 0\n          unsigned int uc = MUL1 * uc1 * MUL2 * uc2;\n          unsigned int index1 = uc >> composition_header_0;\n          if (index1 < composition_header_1)\n            {\n              int lookup1 = u_composition.level1[index1];\n              if (lookup1 >= 0)\n                {\n                  unsigned int index2 = (uc >> composition_header_2) & composition_header_3;\n                  int lookup2 = u_composition.level2[lookup1 + index2];\n                  if (lookup2 >= 0)\n                    {\n                      unsigned int index3 = (uc & composition_header_4);\n                      unsigned int lookup3 = u_composition.level3[lookup2 + index3];\n                      if ((lookup3 >> 16) == uc2)\n                        return lookup3 & ((1U << 16) - 1);\n                    }\n                }\n            }\n#else\n          char codes[6];\n          const struct composition_rule *rule;\n\n          codes[0] = (uc1 >> 16) & 0xff;\n          codes[1] = (uc1 >> 8) & 0xff;\n          codes[2] = uc1 & 0xff;\n          codes[3] = (uc2 >> 16) & 0xff;\n          codes[4] = (uc2 >> 8) & 0xff;\n          codes[5] = uc2 & 0xff;\n\n          rule = gl_uninorm_compose_lookup (codes, 6);\n          if (rule != NULL)\n            return rule->combined;\n#endif\n        }\n    }\n  return 0;\n}",
      "lines": 59,
      "depth": 22,
      "decorators": [
        "ucs4_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uninorm/decompose-internal.c": {},
  "libunistring/libunistring-0.9.10/lib/uninorm/decompose-internal.h": {},
  "libunistring/libunistring-0.9.10/lib/uninorm/decomposing-form.c": {
    "uninorm_decomposing_form": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "uninorm_t\nuninorm_decomposing_form (uninorm_t nf)\n{\n  return nf->decomposing_variant;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "uninorm_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uninorm/decomposition-table.c": {},
  "libunistring/libunistring-0.9.10/lib/uninorm/decomposition-table.h": {
    "decomp_index": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static inline unsigned short\ndecomp_index (ucs4_t uc)\n{\n  unsigned int index1 = uc >> decomp_header_0;\n  if (index1 < decomp_header_1)\n    {\n      int lookup1 = gl_uninorm_decomp_index_table.level1[index1];\n      if (lookup1 >= 0)\n        {\n          unsigned int index2 = (uc >> decomp_header_2) & decomp_header_3;\n          int lookup2 = gl_uninorm_decomp_index_table.level2[lookup1 + index2];\n          if (lookup2 >= 0)\n            {\n              unsigned int index3 = uc & decomp_header_4;\n              return gl_uninorm_decomp_index_table.level3[lookup2 + index3];\n            }\n        }\n    }\n  return (unsigned short)(-1);\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "unsigned short",
        "unsigned",
        "short"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uninorm/decomposition-table1.h": {},
  "libunistring/libunistring-0.9.10/lib/uninorm/decomposition-table2.h": {},
  "libunistring/libunistring-0.9.10/lib/uninorm/decomposition.c": {
    "uc_decomposition": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "int\nuc_decomposition (ucs4_t uc, int *decomp_tag, ucs4_t *decomposition)\n{\n  if (uc >= 0xAC00 && uc < 0xD7A4)\n    {\n      /* Hangul syllable.  See Unicode standard, chapter 3, section\n         \"Hangul Syllable Decomposition\",  See also the clarification at\n         <http://www.unicode.org/versions/Unicode5.1.0/>, section\n         \"Clarification of Hangul Jamo Handling\".  */\n      unsigned int t;\n\n      uc -= 0xAC00;\n      t = uc % 28;\n\n      *decomp_tag = UC_DECOMP_CANONICAL;\n      if (t == 0)\n        {\n          unsigned int v, l;\n\n          uc = uc / 28;\n          v = uc % 21;\n          l = uc / 21;\n\n          decomposition[0] = 0x1100 + l;\n          decomposition[1] = 0x1161 + v;\n          return 2;\n        }\n      else\n        {\n#if 1 /* Return the pairwise decomposition, not the full decomposition.  */\n          decomposition[0] = 0xAC00 + uc - t; /* = 0xAC00 + (l * 21 + v) * 28; */\n          decomposition[1] = 0x11A7 + t;\n          return 2;\n#else\n          unsigned int v, l;\n\n          uc = uc / 28;\n          v = uc % 21;\n          l = uc / 21;\n\n          decomposition[0] = 0x1100 + l;\n          decomposition[1] = 0x1161 + v;\n          decomposition[2] = 0x11A7 + t;\n          return 3;\n#endif\n        }\n    }\n  else if (uc < 0x110000)\n    {\n      unsigned short entry = decomp_index (uc);\n      if (entry != (unsigned short)(-1))\n        {\n          const unsigned char *p;\n          unsigned int element;\n          unsigned int length;\n\n          p = &gl_uninorm_decomp_chars_table[3 * (entry & 0x7FFF)];\n          element = (p[0] << 16) | (p[1] << 8) | p[2];\n          /* The first element has 5 bits for the decomposition type.  */\n          *decomp_tag = (element >> 18) & 0x1f;\n          length = 1;\n          for (;;)\n            {\n              /* Every element has an 18 bits wide Unicode code point.  */\n              *decomposition = element & 0x3ffff;\n              /* Bit 23 tells whether there are more elements,  */\n              if ((element & (1 << 23)) == 0)\n                break;\n              p += 3;\n              element = (p[0] << 16) | (p[1] << 8) | p[2];\n              decomposition++;\n              length++;\n            }\n          return length;\n        }\n    }\n  return -1;\n}",
      "lines": 78,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uninorm/nfc.c": {},
  "libunistring/libunistring-0.9.10/lib/uninorm/nfd.c": {},
  "libunistring/libunistring-0.9.10/lib/uninorm/nfkc.c": {},
  "libunistring/libunistring-0.9.10/lib/uninorm/nfkd.c": {},
  "libunistring/libunistring-0.9.10/lib/uninorm/normalize-internal.h": {},
  "libunistring/libunistring-0.9.10/lib/uninorm/u-normalize-internal.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        388,
        1
      ],
      "content": "UNIT *\nFUNC (uninorm_t nf, const UNIT *s, size_t n,\n      UNIT *resultbuf, size_t *lengthp)\n{\n  int (*decomposer) (ucs4_t uc, ucs4_t *decomposition) = nf->decomposer;\n  ucs4_t (*composer) (ucs4_t uc1, ucs4_t uc2) = nf->composer;\n\n  /* The result being accumulated.  */\n  UNIT *result;\n  size_t length;\n  size_t allocated;\n  /* The buffer for sorting.  */\n  #define SORTBUF_PREALLOCATED 64\n  struct ucs4_with_ccc sortbuf_preallocated[2 * SORTBUF_PREALLOCATED];\n  struct ucs4_with_ccc *sortbuf; /* array of size 2 * sortbuf_allocated */\n  size_t sortbuf_allocated;\n  size_t sortbuf_count;\n\n  /* Initialize the accumulator.  */\n  if (resultbuf == NULL)\n    {\n      result = NULL;\n      allocated = 0;\n    }\n  else\n    {\n      result = resultbuf;\n      allocated = *lengthp;\n    }\n  length = 0;\n\n  /* Initialize the buffer for sorting.  */\n  sortbuf = sortbuf_preallocated;\n  sortbuf_allocated = SORTBUF_PREALLOCATED;\n  sortbuf_count = 0;\n\n  {\n    const UNIT *s_end = s + n;\n\n    for (;;)\n      {\n        int count;\n        ucs4_t decomposed[UC_DECOMPOSITION_MAX_LENGTH];\n        int decomposed_count;\n        int i;\n\n        if (s < s_end)\n          {\n            /* Fetch the next character.  */\n            count = U_MBTOUC_UNSAFE (&decomposed[0], s, s_end - s);\n            decomposed_count = 1;\n\n            /* Decompose it, recursively.\n               It would be possible to precompute the recursive decomposition\n               and store it in a table.  But this would significantly increase\n               the size of the decomposition tables, because for example for\n               U+1FC1 the recursive canonical decomposition and the recursive\n               compatibility decomposition are different.  */\n            {\n              int curr;\n\n              for (curr = 0; curr < decomposed_count; )\n                {\n                  /* Invariant: decomposed[0..curr-1] is fully decomposed, i.e.\n                     all elements are atomic.  */\n                  ucs4_t curr_decomposed[UC_DECOMPOSITION_MAX_LENGTH];\n                  int curr_decomposed_count;\n\n                  curr_decomposed_count = decomposer (decomposed[curr], curr_decomposed);\n                  if (curr_decomposed_count >= 0)\n                    {\n                      /* Move curr_decomposed[0..curr_decomposed_count-1] over\n                         decomposed[curr], making room.  It's not worth using\n                         memcpy() here, since the counts are so small.  */\n                      int shift = curr_decomposed_count - 1;\n\n                      if (shift < 0)\n                        abort ();\n                      if (shift > 0)\n                        {\n                          int j;\n\n                          decomposed_count += shift;\n                          if (decomposed_count > UC_DECOMPOSITION_MAX_LENGTH)\n                            abort ();\n                          for (j = decomposed_count - 1 - shift; j > curr; j--)\n                            decomposed[j + shift] = decomposed[j];\n                        }\n                      for (; shift >= 0; shift--)\n                        decomposed[curr + shift] = curr_decomposed[shift];\n                    }\n                  else\n                    {\n                      /* decomposed[curr] is atomic.  */\n                      curr++;\n                    }\n                }\n            }\n          }\n        else\n          {\n            count = 0;\n            decomposed_count = 0;\n          }\n\n        i = 0;\n        for (;;)\n          {\n            ucs4_t uc;\n            int ccc;\n\n            if (s < s_end)\n              {\n                /* Fetch the next character from the decomposition.  */\n                if (i == decomposed_count)\n                  break;\n                uc = decomposed[i];\n                ccc = uc_combining_class (uc);\n              }\n            else\n              {\n                /* End of string reached.  */\n                uc = 0;\n                ccc = 0;\n              }\n\n            if (ccc == 0)\n              {\n                size_t j;\n\n                /* Apply the canonical ordering algorithm to the accumulated\n                   sequence of characters.  */\n                if (sortbuf_count > 1)\n                  gl_uninorm_decompose_merge_sort_inplace (sortbuf, sortbuf_count,\n                                                           sortbuf + sortbuf_count);\n\n                if (composer != NULL)\n                  {\n                    /* Attempt to combine decomposed characters, as specified\n                       in the Unicode Standard Annex #15 \"Unicode Normalization\n                       Forms\".  We need to check\n                         1. whether the first accumulated character is a\n                            \"starter\" (i.e. has ccc = 0).  This is usually the\n                            case.  But when the string starts with a\n                            non-starter, the sortbuf also starts with a\n                            non-starter.  Btw, this check could also be\n                            omitted, because the composition table has only\n                            entries (code1, code2) for which code1 is a\n                            starter; if the first accumulated character is not\n                            a starter, no lookup will succeed.\n                         2. If the sortbuf has more than one character, check\n                            for each of these characters that are not \"blocked\"\n                            from the starter (i.e. have a ccc that is higher\n                            than the ccc of the previous character) whether it\n                            can be combined with the first character.\n                         3. If only one character is left in sortbuf, check\n                            whether it can be combined with the next character\n                            (also a starter).  */\n                    if (sortbuf_count > 0 && sortbuf[0].ccc == 0)\n                      {\n                        for (j = 1; j < sortbuf_count; )\n                          {\n                            if (sortbuf[j].ccc > sortbuf[j - 1].ccc)\n                              {\n                                ucs4_t combined =\n                                  composer (sortbuf[0].code, sortbuf[j].code);\n                                if (combined)\n                                  {\n                                    size_t k;\n\n                                    sortbuf[0].code = combined;\n                                    /* sortbuf[0].ccc = 0, still valid.  */\n                                    for (k = j + 1; k < sortbuf_count; k++)\n                                      sortbuf[k - 1] = sortbuf[k];\n                                    sortbuf_count--;\n                                    continue;\n                                  }\n                              }\n                            j++;\n                          }\n                        if (s < s_end && sortbuf_count == 1)\n                          {\n                            ucs4_t combined =\n                              composer (sortbuf[0].code, uc);\n                            if (combined)\n                              {\n                                uc = combined;\n                                ccc = 0;\n                                /* uc could be further combined with subsequent\n                                   characters.  So don't put it into sortbuf[0] in\n                                   this round, only in the next round.  */\n                                sortbuf_count = 0;\n                              }\n                          }\n                      }\n                  }\n\n                for (j = 0; j < sortbuf_count; j++)\n                  {\n                    ucs4_t muc = sortbuf[j].code;\n\n                    /* Append muc to the result accumulator.  */\n                    if (length < allocated)\n                      {\n                        int ret =\n                          U_UCTOMB (result + length, muc, allocated - length);\n                        if (ret == -1)\n                          {\n                            errno = EINVAL;\n                            goto fail;\n                          }\n                        if (ret >= 0)\n                          {\n                            length += ret;\n                            goto done_appending;\n                          }\n                      }\n                    {\n                      size_t old_allocated = allocated;\n                      size_t new_allocated = 2 * old_allocated;\n                      if (new_allocated < 64)\n                        new_allocated = 64;\n                      if (new_allocated < old_allocated) /* integer overflow? */\n                        abort ();\n                      {\n                        UNIT *larger_result;\n                        if (result == NULL)\n                          {\n                            larger_result =\n                              (UNIT *) malloc (new_allocated * sizeof (UNIT));\n                            if (larger_result == NULL)\n                              {\n                                errno = ENOMEM;\n                                goto fail;\n                              }\n                          }\n                        else if (result == resultbuf)\n                          {\n                            larger_result =\n                              (UNIT *) malloc (new_allocated * sizeof (UNIT));\n                            if (larger_result == NULL)\n                              {\n                                errno = ENOMEM;\n                                goto fail;\n                              }\n                            U_CPY (larger_result, resultbuf, length);\n                          }\n                        else\n                          {\n                            larger_result =\n                              (UNIT *) realloc (result, new_allocated * sizeof (UNIT));\n                            if (larger_result == NULL)\n                              {\n                                errno = ENOMEM;\n                                goto fail;\n                              }\n                          }\n                        result = larger_result;\n                        allocated = new_allocated;\n                        {\n                          int ret =\n                            U_UCTOMB (result + length, muc, allocated - length);\n                          if (ret == -1)\n                            {\n                              errno = EINVAL;\n                              goto fail;\n                            }\n                          if (ret < 0)\n                            abort ();\n                          length += ret;\n                          goto done_appending;\n                        }\n                      }\n                    }\n                   done_appending: ;\n                  }\n\n                /* sortbuf is now empty.  */\n                sortbuf_count = 0;\n              }\n\n            if (!(s < s_end))\n              /* End of string reached.  */\n              break;\n\n            /* Append (uc, ccc) to sortbuf.  */\n            if (sortbuf_count == sortbuf_allocated)\n              {\n                struct ucs4_with_ccc *new_sortbuf;\n\n                sortbuf_allocated = 2 * sortbuf_allocated;\n                if (sortbuf_allocated < sortbuf_count) /* integer overflow? */\n                  abort ();\n                new_sortbuf =\n                  (struct ucs4_with_ccc *) malloc (2 * sortbuf_allocated * sizeof (struct ucs4_with_ccc));\n                if (new_sortbuf == NULL)\n                  {\n                    errno = ENOMEM;\n                    goto fail;\n                  }\n                memcpy (new_sortbuf, sortbuf,\n                        sortbuf_count * sizeof (struct ucs4_with_ccc));\n                if (sortbuf != sortbuf_preallocated)\n                  free (sortbuf);\n                sortbuf = new_sortbuf;\n              }\n            sortbuf[sortbuf_count].code = uc;\n            sortbuf[sortbuf_count].ccc = ccc;\n            sortbuf_count++;\n\n            i++;\n          }\n\n        if (!(s < s_end))\n          /* End of string reached.  */\n          break;\n\n        s += count;\n      }\n  }\n\n  if (length == 0)\n    {\n      if (result == NULL)\n        {\n          /* Return a non-NULL value.  NULL means error.  */\n          result = (UNIT *) malloc (1);\n          if (result == NULL)\n            {\n              errno = ENOMEM;\n              goto fail;\n            }\n        }\n    }\n  else if (result != resultbuf && length < allocated)\n    {\n      /* Shrink the allocated memory if possible.  */\n      UNIT *memory;\n\n      memory = (UNIT *) realloc (result, length * sizeof (UNIT));\n      if (memory != NULL)\n        result = memory;\n    }\n\n  if (sortbuf_count > 0)\n    abort ();\n  if (sortbuf != sortbuf_preallocated)\n    free (sortbuf);\n\n  *lengthp = length;\n  return result;\n\n fail:\n  {\n    int saved_errno = errno;\n    if (sortbuf != sortbuf_preallocated)\n      free (sortbuf);\n    if (result != resultbuf)\n      free (result);\n    errno = saved_errno;\n  }\n  return NULL;\n}",
      "lines": 363,
      "depth": 25,
      "decorators": [
        "UNIT",
        "*\nFUNC (uninorm_t nf, const UNIT *s, size_t n,\n      UNIT *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uninorm/u-normcmp.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "int\nFUNC (const UNIT *s1, size_t n1, const UNIT *s2, size_t n2,\n      uninorm_t nf, int *resultp)\n{\n  UNIT buf1[2048 / sizeof (UNIT)];\n  UNIT buf2[2048 / sizeof (UNIT)];\n  UNIT *norms1;\n  size_t norms1_length;\n  UNIT *norms2;\n  size_t norms2_length;\n  int cmp;\n\n  /* Normalize S1.  */\n  norms1_length = sizeof (buf1) / sizeof (UNIT);\n  norms1 = U_NORMALIZE (nf, s1, n1, buf1, &norms1_length);\n  if (norms1 == NULL)\n    /* errno is set here.  */\n    return -1;\n\n  /* Normalize S2.  */\n  norms2_length = sizeof (buf2) / sizeof (UNIT);\n  norms2 = U_NORMALIZE (nf, s2, n2, buf2, &norms2_length);\n  if (norms2 == NULL)\n    {\n      if (norms1 != buf1)\n        {\n          int saved_errno = errno;\n          free (norms1);\n          errno = saved_errno;\n        }\n      return -1;\n    }\n\n  /* Compare the normalized strings.  */\n  cmp = U_CMP2 (norms1, norms1_length, norms2, norms2_length);\n  if (cmp > 0)\n    cmp = 1;\n  else if (cmp < 0)\n    cmp = -1;\n\n  if (norms2 != buf2)\n    free (norms2);\n  if (norms1 != buf1)\n    free (norms1);\n  *resultp = cmp;\n  return 0;\n}",
      "lines": 47,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uninorm/u-normcoll.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "int\nFUNC (const UNIT *s1, size_t n1, const UNIT *s2, size_t n2,\n      uninorm_t nf, int *resultp)\n{\n  char buf1[2048];\n  char buf2[2048];\n  char *transformed1;\n  size_t transformed1_length;\n  char *transformed2;\n  size_t transformed2_length;\n  int cmp;\n\n  /* Normalize and transform S1.  */\n  transformed1_length = sizeof (buf1);\n  transformed1 = U_NORMXFRM (s1, n1, nf, buf1, &transformed1_length);\n  if (transformed1 == NULL)\n    /* errno is set here.  */\n    return -1;\n\n  /* Normalize and transform S2.  */\n  transformed2_length = sizeof (buf2);\n  transformed2 = U_NORMXFRM (s2, n2, nf, buf2, &transformed2_length);\n  if (transformed2 == NULL)\n    {\n      if (transformed1 != buf1)\n        {\n          int saved_errno = errno;\n          free (transformed1);\n          errno = saved_errno;\n        }\n      return -1;\n    }\n\n  /* Compare the transformed strings.  */\n  cmp = memcmp2 (transformed1, transformed1_length,\n                 transformed2, transformed2_length);\n  if (cmp < 0)\n    cmp = -1;\n  else if (cmp > 0)\n    cmp = 1;\n\n  if (transformed2 != buf2)\n    free (transformed2);\n  if (transformed1 != buf1)\n    free (transformed1);\n  *resultp = cmp;\n  return 0;\n}",
      "lines": 48,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uninorm/u-normxfrm.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "char *\nFUNC (const UNIT *s, size_t n, uninorm_t nf,\n      char *resultbuf, size_t *lengthp)\n{\n  UNIT normsbuf[2048 / sizeof (UNIT)];\n  UNIT *norms;\n  size_t norms_length;\n  char convsbuf[2048];\n  char *convs;\n  size_t convs_length;\n  char *result;\n\n  /* Normalize the Unicode string.  */\n  norms_length = sizeof (normsbuf) / sizeof (UNIT);\n  norms = U_NORMALIZE (nf, s, n, normsbuf, &norms_length);\n  if (norms == NULL)\n    /* errno is set here.  */\n    return NULL;\n\n  /* Convert it to locale encoding.  */\n  convs_length = sizeof (convsbuf) - 1;\n  convs = U_CONV_TO_ENCODING (locale_charset (),\n                              iconveh_error,\n                              norms, norms_length,\n                              NULL,\n                              convsbuf, &convs_length);\n  if (convs == NULL)\n    {\n      if (norms != normsbuf)\n        {\n          int saved_errno = errno;\n          free (norms);\n          errno = saved_errno;\n        }\n      return NULL;\n    }\n\n  if (norms != normsbuf)\n    free (norms);\n\n  /* Ensure one more byte is available.  */\n  if (convs != convsbuf)\n    {\n      char *memory = (char *) realloc (convs, convs_length + 1);\n      if (memory == NULL)\n        {\n          free (convs);\n          errno = ENOMEM;\n          return NULL;\n        }\n      convs = memory;\n    }\n\n  /* Apply locale dependent transformations for comparison.  */\n  result = amemxfrm (convs, convs_length, resultbuf, lengthp);\n  if (result == NULL)\n    {\n      if (convs != convsbuf)\n        {\n          int saved_errno = errno;\n          free (convs);\n          errno = saved_errno;\n        }\n      return NULL;\n    }\n\n  if (convs != convsbuf)\n    free (convs);\n  return result;\n}",
      "lines": 70,
      "depth": 11,
      "decorators": [
        "char",
        "*\nFUNC (const UNIT *s, size_t n, uninorm_t nf,\n      char *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uninorm/u16-normalize.c": {},
  "libunistring/libunistring-0.9.10/lib/uninorm/u16-normcmp.c": {},
  "libunistring/libunistring-0.9.10/lib/uninorm/u16-normcoll.c": {},
  "libunistring/libunistring-0.9.10/lib/uninorm/u16-normxfrm.c": {},
  "libunistring/libunistring-0.9.10/lib/uninorm/u32-normalize.c": {},
  "libunistring/libunistring-0.9.10/lib/uninorm/u32-normcmp.c": {},
  "libunistring/libunistring-0.9.10/lib/uninorm/u32-normcoll.c": {},
  "libunistring/libunistring-0.9.10/lib/uninorm/u32-normxfrm.c": {},
  "libunistring/libunistring-0.9.10/lib/uninorm/u8-normalize.c": {},
  "libunistring/libunistring-0.9.10/lib/uninorm/u8-normcmp.c": {},
  "libunistring/libunistring-0.9.10/lib/uninorm/u8-normcoll.c": {},
  "libunistring/libunistring-0.9.10/lib/uninorm/u8-normxfrm.c": {},
  "libunistring/libunistring-0.9.10/lib/uninorm/uninorm-filter.c": {
    "uninorm_filter_create": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "struct uninorm_filter *\nuninorm_filter_create (uninorm_t nf,\n                       int (*stream_func) (void *stream_data, ucs4_t uc),\n                       void *stream_data)\n{\n  struct uninorm_filter *filter =\n    (struct uninorm_filter *) malloc (sizeof (struct uninorm_filter));\n\n  if (filter == NULL)\n    /* errno is ENOMEM. */\n    return NULL;\n\n  filter->decomposer = nf->decomposer;\n  filter->composer = nf->composer;\n  filter->stream_func = stream_func;\n  filter->stream_data = stream_data;\n  filter->sortbuf = filter->sortbuf_preallocated;\n  filter->sortbuf_allocated = SORTBUF_PREALLOCATED;\n  filter->sortbuf_count = 0;\n\n  return filter;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "struct uninorm_filter",
        "struct",
        "uninorm_filter",
        "*\nuninorm_filter_create (uninorm_t nf,\n                       int (*stream_func) (void *stream_data, ucs4_t uc),\n                       void *stream_data)",
        "*"
      ]
    },
    "uninorm_filter_write": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        275,
        1
      ],
      "content": "int\nuninorm_filter_write (struct uninorm_filter *filter, ucs4_t uc_arg)\n{\n  ucs4_t decomposed[UC_DECOMPOSITION_MAX_LENGTH];\n  int decomposed_count;\n\n  /* Accept the next character.  */\n  decomposed[0] = uc_arg;\n  decomposed_count = 1;\n\n  /* Decompose it, recursively.\n     It would be possible to precompute the recursive decomposition\n     and store it in a table.  But this would significantly increase\n     the size of the decomposition tables, because for example for\n     U+1FC1 the recursive canonical decomposition and the recursive\n     compatibility decomposition are different.  */\n  {\n    int curr;\n\n    for (curr = 0; curr < decomposed_count; )\n      {\n        /* Invariant: decomposed[0..curr-1] is fully decomposed, i.e.\n           all elements are atomic.  */\n        ucs4_t curr_decomposed[UC_DECOMPOSITION_MAX_LENGTH];\n        int curr_decomposed_count;\n\n        curr_decomposed_count =\n          filter->decomposer (decomposed[curr], curr_decomposed);\n        if (curr_decomposed_count >= 0)\n          {\n            /* Move curr_decomposed[0..curr_decomposed_count-1] over\n               decomposed[curr], making room.  It's not worth using\n               memcpy() here, since the counts are so small.  */\n            int shift = curr_decomposed_count - 1;\n\n            if (shift < 0)\n              abort ();\n            if (shift > 0)\n              {\n                int j;\n\n                decomposed_count += shift;\n                if (decomposed_count > UC_DECOMPOSITION_MAX_LENGTH)\n                  abort ();\n                for (j = decomposed_count - 1 - shift; j > curr; j--)\n                  decomposed[j + shift] = decomposed[j];\n              }\n            for (; shift >= 0; shift--)\n              decomposed[curr + shift] = curr_decomposed[shift];\n          }\n        else\n          {\n            /* decomposed[curr] is atomic.  */\n            curr++;\n          }\n      }\n  }\n\n  {\n    /* Cache sortbuf and sortbuf_count in local register variables.  */\n    struct ucs4_with_ccc *sortbuf = filter->sortbuf;\n    size_t sortbuf_count = filter->sortbuf_count;\n    int i;\n\n    for (i = 0; i < decomposed_count; i++)\n      {\n        /* Fetch the next character from the decomposition.  */\n        ucs4_t uc = decomposed[i];\n        int ccc = uc_combining_class (uc);\n\n        if (ccc == 0)\n          {\n            size_t j;\n\n            /* Apply the canonical ordering algorithm to the accumulated\n               sequence of characters.  */\n            if (sortbuf_count > 1)\n              gl_uninorm_decompose_merge_sort_inplace (sortbuf, sortbuf_count,\n                                                       sortbuf + sortbuf_count);\n\n            if (filter->composer != NULL)\n              {\n                /* Attempt to combine decomposed characters, as specified\n                   in the Unicode Standard Annex #15 \"Unicode Normalization\n                   Forms\".  We need to check\n                     1. whether the first accumulated character is a\n                        \"starter\" (i.e. has ccc = 0).  This is usually the\n                        case.  But when the string starts with a\n                        non-starter, the sortbuf also starts with a\n                        non-starter.  Btw, this check could also be\n                        omitted, because the composition table has only\n                        entries (code1, code2) for which code1 is a\n                        starter; if the first accumulated character is not\n                        a starter, no lookup will succeed.\n                     2. If the sortbuf has more than one character, check\n                        for each of these characters that are not \"blocked\"\n                        from the starter (i.e. have a ccc that is higher\n                        than the ccc of the previous character) whether it\n                        can be combined with the first character.\n                     3. If only one character is left in sortbuf, check\n                        whether it can be combined with the next character\n                        (also a starter).  */\n                if (sortbuf_count > 0 && sortbuf[0].ccc == 0)\n                  {\n                    for (j = 1; j < sortbuf_count; )\n                      {\n                        if (sortbuf[j].ccc > sortbuf[j - 1].ccc)\n                          {\n                            ucs4_t combined =\n                              filter->composer (sortbuf[0].code, sortbuf[j].code);\n                            if (combined)\n                              {\n                                size_t k;\n\n                                sortbuf[0].code = combined;\n                                /* sortbuf[0].ccc = 0, still valid.  */\n                                for (k = j + 1; k < sortbuf_count; k++)\n                                  sortbuf[k - 1] = sortbuf[k];\n                                sortbuf_count--;\n                                continue;\n                              }\n                          }\n                        j++;\n                      }\n                    if (sortbuf_count == 1)\n                      {\n                        ucs4_t combined =\n                          filter->composer (sortbuf[0].code, uc);\n                        if (combined)\n                          {\n                            uc = combined;\n                            ccc = 0;\n                            /* uc could be further combined with subsequent\n                               characters.  So don't put it into sortbuf[0] in\n                               this round, only in the next round.  */\n                            sortbuf_count = 0;\n                          }\n                      }\n                  }\n              }\n\n            for (j = 0; j < sortbuf_count; j++)\n              {\n                ucs4_t muc = sortbuf[j].code;\n\n                /* Output muc to the encapsulated stream.  */\n                int ret = filter->stream_func (filter->stream_data, muc);\n                if (ret < 0)\n                  {\n                    /* errno is set here.  */\n                    filter->sortbuf_count = 0;\n                    return -1;\n                  }\n              }\n\n            /* sortbuf is now empty.  */\n            sortbuf_count = 0;\n          }\n\n        /* Append (uc, ccc) to sortbuf.  */\n        if (sortbuf_count == filter->sortbuf_allocated)\n          {\n            struct ucs4_with_ccc *new_sortbuf;\n\n            filter->sortbuf_allocated = 2 * filter->sortbuf_allocated;\n            if (filter->sortbuf_allocated < sortbuf_count) /* integer overflow? */\n              abort ();\n            new_sortbuf =\n              (struct ucs4_with_ccc *)\n              malloc (2 * filter->sortbuf_allocated * sizeof (struct ucs4_with_ccc));\n            if (new_sortbuf == NULL)\n              {\n                /* errno is ENOMEM. */\n                filter->sortbuf_count = sortbuf_count;\n                return -1;\n              }\n            memcpy (new_sortbuf, filter->sortbuf,\n                    sortbuf_count * sizeof (struct ucs4_with_ccc));\n            if (filter->sortbuf != filter->sortbuf_preallocated)\n              free (filter->sortbuf);\n            filter->sortbuf = new_sortbuf;\n            /* Update cache of filter->sortbuf.  */\n            sortbuf = filter->sortbuf;\n          }\n        sortbuf[sortbuf_count].code = uc;\n        sortbuf[sortbuf_count].ccc = ccc;\n        sortbuf_count++;\n      }\n\n    filter->sortbuf_count = sortbuf_count;\n  }\n\n  return 0;\n}",
      "lines": 194,
      "depth": 23,
      "decorators": [
        "int"
      ]
    },
    "uninorm_filter_flush": {
      "start_point": [
        283,
        0
      ],
      "end_point": [
        362,
        1
      ],
      "content": "int\nuninorm_filter_flush (struct uninorm_filter *filter)\n{\n  /* Cache sortbuf and sortbuf_count in local register variables.  */\n  struct ucs4_with_ccc * const sortbuf = filter->sortbuf;\n  size_t sortbuf_count = filter->sortbuf_count;\n  size_t j;\n\n  /* Apply the canonical ordering algorithm to the accumulated\n     sequence of characters.  */\n  if (sortbuf_count > 1)\n    gl_uninorm_decompose_merge_sort_inplace (sortbuf, sortbuf_count,\n                                             sortbuf + sortbuf_count);\n\n  if (filter->composer != NULL)\n    {\n      /* Attempt to combine decomposed characters, as specified\n         in the Unicode Standard Annex #15 \"Unicode Normalization\n         Forms\".  We need to check\n           1. whether the first accumulated character is a\n              \"starter\" (i.e. has ccc = 0).  This is usually the\n              case.  But when the string starts with a\n              non-starter, the sortbuf also starts with a\n              non-starter.  Btw, this check could also be\n              omitted, because the composition table has only\n              entries (code1, code2) for which code1 is a\n              starter; if the first accumulated character is not\n              a starter, no lookup will succeed.\n           2. If the sortbuf has more than one character, check\n              for each of these characters that are not \"blocked\"\n              from the starter (i.e. have a ccc that is higher\n              than the ccc of the previous character) whether it\n              can be combined with the first character.\n           3. If only one character is left in sortbuf, check\n              whether it can be combined with the next character\n              (also a starter).  */\n      if (sortbuf_count > 0 && sortbuf[0].ccc == 0)\n        {\n          for (j = 1; j < sortbuf_count; )\n            {\n              if (sortbuf[j].ccc > sortbuf[j - 1].ccc)\n                {\n                  ucs4_t combined =\n                    filter->composer (sortbuf[0].code, sortbuf[j].code);\n                  if (combined)\n                    {\n                      size_t k;\n\n                      sortbuf[0].code = combined;\n                      /* sortbuf[0].ccc = 0, still valid.  */\n                      for (k = j + 1; k < sortbuf_count; k++)\n                        sortbuf[k - 1] = sortbuf[k];\n                      sortbuf_count--;\n                      continue;\n                    }\n                }\n              j++;\n            }\n        }\n    }\n\n  for (j = 0; j < sortbuf_count; j++)\n    {\n      ucs4_t muc = sortbuf[j].code;\n\n      /* Output muc to the encapsulated stream.  */\n      int ret = filter->stream_func (filter->stream_data, muc);\n      if (ret < 0)\n        {\n          /* errno is set here.  */\n          filter->sortbuf_count = 0;\n          return -1;\n        }\n    }\n\n  /* sortbuf is now empty.  */\n  filter->sortbuf_count = 0;\n\n  return 0;\n}",
      "lines": 80,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "uninorm_filter_free": {
      "start_point": [
        367,
        0
      ],
      "end_point": [
        383,
        1
      ],
      "content": "int\nuninorm_filter_free (struct uninorm_filter *filter)\n{\n  int ret = uninorm_filter_flush (filter);\n\n  if (ret < 0)\n    /* errno is set here.  */\n    return -1;\n\n  if (filter->sortbuf_count > 0)\n    abort ();\n  if (filter->sortbuf != filter->sortbuf_preallocated)\n    free (filter->sortbuf);\n  free (filter);\n\n  return 0;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistdio/u-asnprintf.h": {
    "ASNPRINTF": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "DCHAR_T *\nASNPRINTF (DCHAR_T *resultbuf, size_t *lengthp, const FCHAR_T *format, ...)\n{\n  va_list args;\n  DCHAR_T *result;\n\n  va_start (args, format);\n  result = VASNPRINTF (resultbuf, lengthp, format, args);\n  va_end (args);\n  return result;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "DCHAR_T",
        "*\nASNPRINTF (DCHAR_T *resultbuf, size_t *lengthp, const FCHAR_T *format, ...)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistdio/u-asprintf.h": {
    "ASPRINTF": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int\nASPRINTF (DCHAR_T **resultp, const FCHAR_T *format, ...)\n{\n  va_list args;\n  int result;\n\n  va_start (args, format);\n  result = VASPRINTF (resultp, format, args);\n  va_end (args);\n  return result;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistdio/u-printf-args.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u-printf-args.h": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u-printf-parse.h": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u-snprintf.h": {
    "SNPRINTF": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int\nSNPRINTF (DCHAR_T *buf, size_t size, const FCHAR_T *format, ...)\n{\n  va_list args;\n  int result;\n\n  va_start (args, format);\n  result = VSNPRINTF (buf, size, format, args);\n  va_end (args);\n  return result;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistdio/u-sprintf.h": {
    "SPRINTF": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int\nSPRINTF (DCHAR_T *buf, const FCHAR_T *format, ...)\n{\n  va_list args;\n  int result;\n\n  va_start (args, format);\n  result = VSPRINTF (buf, format, args);\n  va_end (args);\n  return result;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistdio/u-vasprintf.h": {
    "VASPRINTF": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nVASPRINTF (DCHAR_T **resultp, const FCHAR_T *format, va_list args)\n{\n  size_t length;\n  DCHAR_T *result = VASNPRINTF (NULL, &length, format, args);\n  if (result == NULL)\n    return -1;\n\n  if (length > INT_MAX)\n    {\n      free (result);\n      errno = EOVERFLOW;\n      return -1;\n    }\n\n  *resultp = result;\n  /* Return the number of resulting units, excluding the trailing NUL.  */\n  return length;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistdio/u-vsnprintf.h": {
    "VSNPRINTF": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nVSNPRINTF (DCHAR_T *buf, size_t size, const FCHAR_T *format, va_list args)\n{\n  size_t length;\n  DCHAR_T *result;\n\n  if (size == 0)\n    buf = NULL;\n  else\n    length = size;\n  result = VASNPRINTF (buf, &length, format, args);\n  if (result == NULL)\n    return -1;\n\n  if (result != buf)\n    {\n      if (size != 0)\n        {\n          /* The result did not fit into the buffer.  Copy the initial segment\n             into the buffer, truncating it if necessary.  */\n          size_t n = (length < size ? length : size - 1);\n          DCHAR_CPY (buf, result, n);\n          buf[n] = '\\0';\n        }\n      free (result);\n    }\n\n  if (length > INT_MAX)\n    {\n      errno = EOVERFLOW;\n      return -1;\n    }\n\n  /* Return the number of resulting units, excluding the trailing NUL.  */\n  return length;\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistdio/u-vsprintf.h": {
    "VSPRINTF": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "int\nVSPRINTF (DCHAR_T *buf, const FCHAR_T *format, va_list args)\n{\n  /* Pass an infinite length.  But note that *vasnprintf may fail if the buffer\n     argument is larger than INT_MAX (if that fits into a 'size_t' at all).\n     Also note that glibc's iconv fails with E2BIG when we pass a length that\n     is so large that buf + length wraps around, i.e.\n     (uintptr_t) (buf + length) < (uintptr_t) buf.  */\n  size_t length;\n  DCHAR_T *result;\n\n  /* Set length = min (SIZE_MAX, INT_MAX, - (uintptr_t) buf - 1).  */\n  length = (SIZE_MAX < INT_MAX ? SIZE_MAX : INT_MAX);\n  if (length > (~ (uintptr_t) buf) / sizeof (DCHAR_T))\n    length = (~ (uintptr_t) buf) / sizeof (DCHAR_T);\n\n  result = VASNPRINTF (buf, &length, format, args);\n  if (result == NULL)\n    return -1;\n\n  /* The infinite buffer size guarantees that the result is not malloc()ed.  */\n  if (result != buf)\n    {\n      /* length is near SIZE_MAX.  */\n      free (result);\n      errno = EOVERFLOW;\n      return -1;\n    }\n\n  if (length > INT_MAX)\n    {\n      errno = EOVERFLOW;\n      return -1;\n    }\n\n  /* Return the number of resulting units, excluding the trailing NUL.  */\n  return length;\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistdio/u16-asnprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u16-asprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u16-printf-parse.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u16-snprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u16-sprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u16-u16-asnprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u16-u16-asprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u16-u16-snprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u16-u16-sprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u16-u16-vasnprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u16-u16-vasprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u16-u16-vsnprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u16-u16-vsprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u16-vasnprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u16-vasprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u16-vsnprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u16-vsprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u32-asnprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u32-asprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u32-printf-parse.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u32-snprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u32-sprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u32-u32-asnprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u32-u32-asprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u32-u32-snprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u32-u32-sprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u32-u32-vasnprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u32-u32-vasprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u32-u32-vsnprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u32-u32-vsprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u32-vasnprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u32-vasprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u32-vsnprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u32-vsprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u8-asnprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u8-asprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u8-printf-parse.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u8-snprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u8-sprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u8-u8-asnprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u8-u8-asprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u8-u8-snprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u8-u8-sprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u8-u8-vasnprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u8-u8-vasprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u8-u8-vsnprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u8-u8-vsprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u8-vasnprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u8-vasprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u8-vsnprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/u8-vsprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/ulc-asnprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/ulc-asprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/ulc-fprintf.c": {
    "ulc_fprintf": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "int\nulc_fprintf (FILE *fp, const char *format, ...)\n{\n  char buf[2000];\n  char *output;\n  size_t len;\n  size_t lenbuf = sizeof (buf);\n  va_list args;\n\n  va_start (args, format);\n  output = ulc_vasnprintf (buf, &lenbuf, format, args);\n  len = lenbuf;\n  va_end (args);\n\n  if (!output)\n    {\n      fseterr (fp);\n      return -1;\n    }\n\n  if (fwrite (output, 1, len, fp) < len)\n    {\n      if (output != buf)\n        {\n          int saved_errno = errno;\n          free (output);\n          errno = saved_errno;\n        }\n      return -1;\n    }\n\n  if (len > INT_MAX)\n    {\n      errno = EOVERFLOW;\n      fseterr (fp);\n      return -1;\n    }\n\n  return len;\n}",
      "lines": 40,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistdio/ulc-printf-parse.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/ulc-snprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/ulc-sprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/ulc-vasnprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/ulc-vasprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/ulc-vfprintf.c": {
    "ulc_vfprintf": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "int\nulc_vfprintf (FILE *fp, const char *format, va_list args)\n{\n  char buf[2000];\n  char *output;\n  size_t len;\n  size_t lenbuf = sizeof (buf);\n\n  output = ulc_vasnprintf (buf, &lenbuf, format, args);\n  len = lenbuf;\n\n  if (!output)\n    {\n      fseterr (fp);\n      return -1;\n    }\n\n  if (fwrite (output, 1, len, fp) < len)\n    {\n      if (output != buf)\n        {\n          int saved_errno = errno;\n          free (output);\n          errno = saved_errno;\n        }\n      return -1;\n    }\n\n  if (len > INT_MAX)\n    {\n      errno = EOVERFLOW;\n      fseterr (fp);\n      return -1;\n    }\n\n  return len;\n}",
      "lines": 37,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistdio/ulc-vsnprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistdio/ulc-vsprintf.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u-cmp2.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\nFUNC (const UNIT *s1, size_t n1, const UNIT *s2, size_t n2)\n{\n  int cmp = U_CMP (s1, s2, MIN (n1, n2));\n\n  if (cmp == 0)\n    {\n      if (n1 < n2)\n        cmp = -1;\n      else if (n1 > n2)\n        cmp = 1;\n    }\n\n  return cmp;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u-cpy-alloc.h": {
    "FUNC": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "UNIT *\nFUNC (const UNIT *s, size_t n)\n{\n  UNIT *dest;\n\n  dest = (UNIT *) malloc (n > 0 ? n * sizeof (UNIT) : 1);\n  if (dest != NULL)\n    {\n#if 0\n      UNIT *destptr = dest;\n\n      for (; n > 0; n--)\n        *destptr++ = *s++;\n#else\n      memcpy ((char *) dest, (const char *) s, n * sizeof (UNIT));\n#endif\n    }\n  return dest;\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "UNIT",
        "*\nFUNC (const UNIT *s, size_t n)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u-cpy.h": {
    "FUNC": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "UNIT *\nFUNC (UNIT *dest, const UNIT *src, size_t n)\n{\n#if 0\n  UNIT *destptr = dest;\n\n  for (; n > 0; n--)\n    *destptr++ = *src++;\n#else\n  memcpy ((char *) dest, (const char *) src, n * sizeof (UNIT));\n#endif\n  return dest;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "UNIT",
        "*\nFUNC (UNIT *dest, const UNIT *src, size_t n)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u-endswith.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "bool\nFUNC (const UNIT *str, const UNIT *suffix)\n{\n  size_t len = U_STRLEN (str);\n  size_t suffixlen = U_STRLEN (suffix);\n\n  if (len >= suffixlen)\n    return (U_CMP (str + (len - suffixlen), suffix, suffixlen) == 0);\n  else\n    return false;\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u-move.h": {
    "FUNC": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "UNIT *\nFUNC (UNIT *dest, const UNIT *src, size_t n)\n{\n#if 0\n  if (dest < src)\n    {\n      UNIT *destptr = dest;\n      const UNIT *srcptr = src;\n\n      for (; n > 0; n--)\n        *destptr++ = *srcptr++;\n    }\n  else if (dest > src)\n    {\n      UNIT *destptr = dest + n - 1;\n      const UNIT *srcptr = src + n - 1;\n\n      for (; n > 0; n--)\n        *destptr-- = *srcptr--;\n    }\n#else\n  memmove ((char *) dest, (const char *) src, n * sizeof (UNIT));\n#endif\n  return dest;\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "UNIT",
        "*\nFUNC (UNIT *dest, const UNIT *src, size_t n)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u-set.h": {
    "FUNC": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "UNIT *\nFUNC (UNIT *s, ucs4_t uc, size_t n)\n{\n  if (n > 0)\n    {\n      if (IS_SINGLE_UNIT (uc))\n        {\n          UNIT *ptr = s;\n\n          for (; n > 0; n--)\n            *ptr++ = uc;\n        }\n      else\n        {\n          errno = EILSEQ;\n          return NULL;\n        }\n    }\n  return s;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "UNIT",
        "*\nFUNC (UNIT *s, ucs4_t uc, size_t n)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u-startswith.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "bool\nFUNC (const UNIT *str, const UNIT *prefix)\n{\n  for (;;)\n    {\n      UNIT uc1 = *str++;\n      UNIT uc2 = *prefix++;\n      if (uc2 == 0)\n        return true;\n      if (uc1 != uc2)\n        return false;\n    }\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u-stpcpy.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "UNIT *\nFUNC (UNIT *dest, const UNIT *src)\n{\n  for (; (*dest = *src) != 0; src++, dest++)\n    ;\n  return dest;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "UNIT",
        "*\nFUNC (UNIT *dest, const UNIT *src)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u-stpncpy.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "UNIT *\nFUNC (UNIT *dest, const UNIT *src, size_t n)\n{\n  for (; n > 0 && (*dest = *src) != 0; src++, dest++, n--)\n    ;\n\n  /* This behavior is rarely useful, but it is here for consistency with\n     strncpy and wcsncpy.  */\n  {\n    UNIT *destptr = dest;\n\n    for (; n > 0; n--)\n      *destptr++ = 0;\n  }\n\n  return dest;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "UNIT",
        "*\nFUNC (UNIT *dest, const UNIT *src, size_t n)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u-strcat.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "UNIT *\nFUNC (UNIT *dest, const UNIT *src)\n{\n  UNIT *destptr = dest + U_STRLEN (dest);\n\n  for (; (*destptr = *src) != 0; src++, destptr++)\n    ;\n  return dest;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "UNIT",
        "*\nFUNC (UNIT *dest, const UNIT *src)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u-strcoll.h": {
    "FUNC": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "int\nFUNC (const UNIT *s1, const UNIT *s2)\n{\n  /* When this function succeeds, it sets errno back to its original value.\n     When it fails, it sets errno, but also returns a meaningful return value,\n     for the sake of callers which ignore errno.  */\n  int final_errno = errno;\n  const char *encoding = locale_charset ();\n  char *sl1;\n  char *sl2;\n  int result;\n\n  /* Pass iconveh_error here, not iconveh_question_mark.  Otherwise the\n     conversion to locale encoding can do transliteration or map some\n     characters to question marks, leading to results that depend on the\n     iconv() implementation and are not obvious.  */\n  sl1 = U_STRCONV_TO_ENCODING (s1, encoding, iconveh_error);\n  if (sl1 != NULL)\n    {\n      sl2 = U_STRCONV_TO_ENCODING (s2, encoding, iconveh_error);\n      if (sl2 != NULL)\n        {\n          /* Compare sl1 and sl2.  */\n          errno = 0;\n          result = strcoll (sl1, sl2);\n          if (errno == 0)\n            {\n              /* strcoll succeeded.  */\n              free (sl1);\n              free (sl2);\n              /* The conversion to locale encoding can drop Unicode TAG\n                 characters.  Therefore sl1 and sl2 may be equal when s1\n                 and s2 were in fact different.  Return a nonzero result\n                 in this case.  */\n              if (result == 0)\n                result = U_STRCMP (s1, s2);\n            }\n          else\n            {\n              /* strcoll failed.  */\n              final_errno = errno;\n              free (sl1);\n              free (sl2);\n              result = U_STRCMP (s1, s2);\n            }\n        }\n      else\n        {\n          /* s1 could be converted to locale encoding, s2 not.  */\n          final_errno = errno;\n          free (sl1);\n          result = -1;\n        }\n    }\n  else\n    {\n      final_errno = errno;\n      sl2 = U_STRCONV_TO_ENCODING (s2, encoding, iconveh_error);\n      if (sl2 != NULL)\n        {\n          /* s2 could be converted to locale encoding, s1 not.  */\n          free (sl2);\n          result = 1;\n        }\n      else\n        {\n          /* Neither s1 nor s2 could be converted to locale encoding.  */\n          result = U_STRCMP (s1, s2);\n        }\n    }\n\n  errno = final_errno;\n  return result;\n}",
      "lines": 74,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u-strcpy.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "UNIT *\nFUNC (UNIT *dest, const UNIT *src)\n{\n  UNIT *destptr = dest;\n\n  for (; (*destptr = *src) != 0; src++, destptr++)\n    ;\n  return dest;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "UNIT",
        "*\nFUNC (UNIT *dest, const UNIT *src)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u-strcspn.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "size_t\nFUNC (const UNIT *str, const UNIT *reject)\n{\n  /* Optimize two cases.  */\n  if (reject[0] == 0)\n    return U_STRLEN (str);\n  {\n    ucs4_t uc;\n    int count = U_STRMBTOUC (&uc, reject);\n    if (count >= 0 && reject[count] == 0)\n      {\n        const UNIT *found = U_STRCHR (str, uc);\n        if (found != NULL)\n          return found - str;\n        else\n          return U_STRLEN (str);\n      }\n  }\n  /* General case.  */\n  {\n    const UNIT *ptr = str;\n\n    for (;;)\n      {\n        ucs4_t uc;\n        int count = U_STRMBTOUC (&uc, ptr);\n        if (count == 0)\n          return ptr - str;\n        if (count < 0)\n          break;\n        if (U_STRCHR (reject, uc))\n          return ptr - str;\n        ptr += count;\n      }\n    return U_STRLEN (str);\n  }\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u-strdup.h": {
    "FUNC": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "UNIT *\nFUNC (const UNIT *s)\n{\n  size_t n = U_STRLEN (s) + 1;\n  UNIT *dest;\n\n  dest = (UNIT *) malloc (n * sizeof (UNIT));\n  if (dest != NULL)\n    {\n#if 0\n      UNIT *destptr = dest;\n\n      for (; n > 0; n--)\n        *destptr++ = *s++;\n#else\n      memcpy ((char *) dest, (const char *) s, n * sizeof (UNIT));\n#endif\n    }\n  return dest;\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "UNIT",
        "*\nFUNC (const UNIT *s)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u-strlen.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "size_t\nFUNC (const UNIT *s)\n{\n  const UNIT *ptr;\n\n  for (ptr = s; *ptr != 0; ptr++)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u-strncat.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "UNIT *\nFUNC (UNIT *dest, const UNIT *src, size_t n)\n{\n  UNIT *destptr = dest + U_STRLEN (dest);\n\n  for (; n > 0 && (*destptr = *src) != 0; src++, destptr++, n--)\n    ;\n  if (n == 0)\n    *destptr = 0;\n  return dest;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "UNIT",
        "*\nFUNC (UNIT *dest, const UNIT *src, size_t n)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u-strncpy.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "UNIT *\nFUNC (UNIT *dest, const UNIT *src, size_t n)\n{\n  UNIT *destptr = dest;\n\n  for (; n > 0 && (*destptr = *src) != 0; src++, destptr++, n--)\n    ;\n\n  /* This behavior is rarely useful, but it is here for consistency with\n     strncpy and wcsncpy.  */\n  for (; n > 0; n--)\n    *destptr++ = 0;\n\n  return dest;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "UNIT",
        "*\nFUNC (UNIT *dest, const UNIT *src, size_t n)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u-strnlen.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "size_t\nFUNC (const UNIT *s, size_t maxlen)\n{\n  const UNIT *ptr;\n\n  for (ptr = s; maxlen > 0 && *ptr != 0; ptr++, maxlen--)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "size_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u-strpbrk.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "UNIT *\nFUNC (const UNIT *str, const UNIT *accept)\n{\n  /* Optimize two cases.  */\n  if (accept[0] == 0)\n    return NULL;\n  {\n    ucs4_t uc;\n    int count = U_STRMBTOUC (&uc, accept);\n    if (count >= 0 && accept[count] == 0)\n      return U_STRCHR (str, uc);\n  }\n  /* General case.  */\n  {\n    const UNIT *ptr = str;\n\n    for (;;)\n      {\n        ucs4_t uc;\n        int count = U_STRMBTOUC (&uc, ptr);\n        if (count <= 0)\n          break;\n        if (U_STRCHR (accept, uc))\n          return (UNIT *) ptr;\n        ptr += count;\n      }\n    return NULL;\n  }\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "UNIT",
        "*\nFUNC (const UNIT *str, const UNIT *accept)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u-strspn.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "size_t\nFUNC (const UNIT *str, const UNIT *accept)\n{\n  /* Optimize two cases.  */\n  if (accept[0] == 0)\n    return 0;\n  {\n    ucs4_t uc;\n    int count = U_STRMBTOUC (&uc, accept);\n    if (count >= 0 && accept[count] == 0)\n      {\n        const UNIT *ptr = str;\n        for (; *ptr != 0; ptr += count)\n          if (U_CMP (ptr, accept, count) != 0)\n            break;\n        return ptr - str;\n      }\n  }\n  /* General case.  */\n  {\n    const UNIT *ptr = str;\n\n    for (;;)\n      {\n        ucs4_t uc;\n        int count = U_STRMBTOUC (&uc, ptr);\n        if (count == 0)\n          return ptr - str;\n        if (count < 0)\n          break;\n        if (!U_STRCHR (accept, uc))\n          return ptr - str;\n        ptr += count;\n      }\n    return U_STRLEN (str);\n  }\n}",
      "lines": 37,
      "depth": 12,
      "decorators": [
        "size_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u-strstr.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "UNIT *\nFUNC (const UNIT *haystack, const UNIT *needle)\n{\n  UNIT first = needle[0];\n\n  /* Is needle empty?  */\n  if (first == 0)\n    return (UNIT *) haystack;\n\n  /* Is needle nearly empty (only one unit)?  */\n  if (needle[1] == 0)\n    return U_STRCHR (haystack, first);\n\n#ifdef U_STRMBTOUC\n  /* Is needle nearly empty (only one character)?  */\n  {\n    ucs4_t first_uc;\n    int count = U_STRMBTOUC (&first_uc, needle);\n    if (count > 0 && needle[count] == 0)\n      return U_STRCHR (haystack, first_uc);\n  }\n#endif\n\n#if UNIT_IS_UINT8_T\n  return (uint8_t *) strstr ((const char *) haystack, (const char *) needle);\n#else\n  {\n    /* Minimizing the worst-case complexity:\n       Let n = U_STRLEN(haystack), m = U_STRLEN(needle).\n       The na\u00c3\u00afve algorithm is O(n*m) worst-case.\n       The Knuth-Morris-Pratt algorithm is O(n) worst-case but it needs a\n       memory allocation.\n       To achieve linear complexity and yet amortize the cost of the\n       memory allocation, we activate the Knuth-Morris-Pratt algorithm\n       only once the na\u00c3\u00afve algorithm has already run for some time; more\n       precisely, when\n         - the outer loop count is >= 10,\n         - the average number of comparisons per outer loop is >= 5,\n         - the total number of comparisons is >= m.\n       But we try it only once.  If the memory allocation attempt failed,\n       we don't retry it.  */\n    bool try_kmp = true;\n    size_t outer_loop_count = 0;\n    size_t comparison_count = 0;\n    size_t last_ccount = 0;                  /* last comparison count */\n    const UNIT *needle_last_ccount = needle; /* = needle + last_ccount */\n\n    /* Speed up the following searches of needle by caching its first\n       character.  */\n    UNIT b = *needle++;\n\n    for (;; haystack++)\n      {\n        if (*haystack == 0)\n          /* No match.  */\n          return NULL;\n\n        /* See whether it's advisable to use an asymptotically faster\n           algorithm.  */\n        if (try_kmp\n            && outer_loop_count >= 10\n            && comparison_count >= 5 * outer_loop_count)\n          {\n            /* See if needle + comparison_count now reaches the end of\n               needle.  */\n            if (needle_last_ccount != NULL)\n              {\n                needle_last_ccount +=\n                  U_STRNLEN (needle_last_ccount,\n                             comparison_count - last_ccount);\n                if (*needle_last_ccount == 0)\n                  needle_last_ccount = NULL;\n                last_ccount = comparison_count;\n              }\n            if (needle_last_ccount == NULL)\n              {\n                /* Try the Knuth-Morris-Pratt algorithm.  */\n                const UNIT *result;\n                bool success =\n                  knuth_morris_pratt (haystack,\n                                      needle - 1, U_STRLEN (needle - 1),\n                                      &result);\n                if (success)\n                  return (UNIT *) result;\n                try_kmp = false;\n              }\n          }\n\n        outer_loop_count++;\n        comparison_count++;\n        if (*haystack == b)\n          /* The first character matches.  */\n          {\n            const UNIT *rhaystack = haystack + 1;\n            const UNIT *rneedle = needle;\n\n            for (;; rhaystack++, rneedle++)\n              {\n                if (*rneedle == 0)\n                  /* Found a match.  */\n                  return (UNIT *) haystack;\n                if (*rhaystack == 0)\n                  /* No match.  */\n                  return NULL;\n                comparison_count++;\n                if (*rhaystack != *rneedle)\n                  /* Nothing in this round.  */\n                  break;\n              }\n          }\n      }\n  }\n#endif\n}",
      "lines": 114,
      "depth": 19,
      "decorators": [
        "UNIT",
        "*\nFUNC (const UNIT *haystack, const UNIT *needle)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u-strtok.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "UNIT *\nFUNC (UNIT *str, const UNIT *delim, UNIT **ptr)\n{\n  if (str == NULL)\n    {\n      str = *ptr;\n      if (str == NULL)\n        return NULL; /* reminder that end of token sequence has been reached */\n    }\n\n  /* Skip leading delimiters.  */\n  str += U_STRSPN (str, delim);\n\n  /* Found a token?  */\n  if (*str == 0)\n    {\n      *ptr = NULL;\n      return NULL;\n    }\n\n  /* Move past the token. */\n  {\n    UNIT *token_end = U_STRPBRK (str, delim);\n    if (token_end)\n      {\n        *ptr = token_end + U_STRMBLEN (token_end);\n        /* NUL-terminate the token.  */\n        *token_end = 0;\n      }\n    else\n      *ptr = NULL;\n  }\n\n  return str;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "UNIT",
        "*\nFUNC (UNIT *str, const UNIT *delim, UNIT **ptr)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u16-check.c": {
    "u16_check": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "const uint16_t *\nu16_check (const uint16_t *s, size_t n)\n{\n  const uint16_t *s_end = s + n;\n\n  while (s < s_end)\n    {\n      /* Keep in sync with unistr.h and u16-mbtouc-aux.c.  */\n      uint16_t c = *s;\n\n      if (c < 0xd800 || c >= 0xe000)\n        {\n          s++;\n          continue;\n        }\n      if (c < 0xdc00)\n        {\n          if (s + 2 <= s_end\n              && s[1] >= 0xdc00 && s[1] < 0xe000)\n            {\n              s += 2;\n              continue;\n            }\n        }\n      /* invalid or incomplete multibyte character */\n      return s;\n    }\n  return NULL;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "const",
        "const",
        "uint16_t",
        "*\nu16_check (const uint16_t *s, size_t n)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u16-chr.c": {
    "u16_chr": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "uint16_t *\nu16_chr (const uint16_t *s, size_t n, ucs4_t uc)\n{\n  uint16_t c[2];\n\n  if (uc < 0x10000)\n    {\n      uint16_t c0 = uc;\n\n      for (; n > 0; s++, n--)\n        {\n          if (*s == c0)\n            return (uint16_t *) s;\n        }\n    }\n  else\n    switch (u16_uctomb_aux (c, uc, 2))\n      {\n      case 2:\n        if (n > 1)\n          {\n            uint16_t c0 = c[0];\n            uint16_t c1 = c[1];\n\n            for (n--; n > 0; s++, n--)\n              {\n                if (*s == c0 && s[1] == c1)\n                  return (uint16_t *) s;\n              }\n          }\n        break;\n      }\n  return NULL;\n}",
      "lines": 34,
      "depth": 16,
      "decorators": [
        "uint16_t",
        "*\nu16_chr (const uint16_t *s, size_t n, ucs4_t uc)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u16-cmp.c": {
    "u16_cmp": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\nu16_cmp (const uint16_t *s1, const uint16_t *s2, size_t n)\n{\n  /* Note that the UTF-16 encoding does NOT preserve lexicographic order.\n     Namely, if uc1 is a 16-bit character and [uc2a,uc2b] is a surrogate pair,\n     we must enforce uc1 < [uc2a,uc2b], even if uc1 > uc2a.  */\n  for (; n > 0;)\n    {\n      uint16_t c1 = *s1++;\n      uint16_t c2 = *s2++;\n      if (c1 == c2)\n        {\n          n--;\n          continue;\n        }\n      if (c1 < 0xd800 || c1 >= 0xe000)\n        {\n          if (!(c2 < 0xd800 || c2 >= 0xe000))\n            /* c2 is a surrogate, but c1 is not.  */\n            return -1;\n        }\n      else\n        {\n          if (c2 < 0xd800 || c2 >= 0xe000)\n            /* c1 is a surrogate, but c2 is not.  */\n            return 1;\n        }\n      return (int)c1 - (int)c2;\n      /* > 0 if c1 > c2, < 0 if c1 < c2. */\n    }\n  return 0;\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u16-cmp2.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u16-cpy-alloc.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u16-cpy.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u16-endswith.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u16-mblen.c": {
    "u16_mblen": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\nu16_mblen (const uint16_t *s, size_t n)\n{\n  if (n > 0)\n    {\n      /* Keep in sync with unistr.h and u16-mbtouc-aux.c.  */\n      uint16_t c = *s;\n\n      if (c < 0xd800 || c >= 0xe000)\n        return (c != 0 ? 1 : 0);\n      if (c < 0xdc00)\n        {\n          if (n >= 2\n              && s[1] >= 0xdc00 && s[1] < 0xe000)\n            return 2;\n        }\n    }\n  /* invalid or incomplete multibyte character */\n  return -1;\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u16-mbsnlen.c": {
    "u16_mbsnlen": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "size_t\nu16_mbsnlen (const uint16_t *s, size_t n)\n{\n  size_t characters;\n\n  characters = 0;\n  while (n > 0)\n    {\n      ucs4_t uc;\n      int count = u16_mbtoucr (&uc, s, n);\n      characters++;\n      if (count == -2)\n        break;\n      if (count <= 0)\n        count = 1;\n      s += count;\n      n -= count;\n    }\n  return characters;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "size_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u16-mbtouc-aux.c": {
    "u16_mbtouc_aux": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\nu16_mbtouc_aux (ucs4_t *puc, const uint16_t *s, size_t n)\n{\n  uint16_t c = *s;\n\n  if (c < 0xdc00)\n    {\n      if (n >= 2)\n        {\n          if (s[1] >= 0xdc00 && s[1] < 0xe000)\n            {\n              *puc = 0x10000 + ((c - 0xd800) << 10) + (s[1] - 0xdc00);\n              return 2;\n            }\n          /* invalid multibyte character */\n        }\n      else\n        {\n          /* incomplete multibyte character */\n        }\n    }\n  /* invalid multibyte character */\n  *puc = 0xfffd;\n  return 1;\n}",
      "lines": 25,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u16-mbtouc-unsafe-aux.c": {
    "u16_mbtouc_unsafe_aux": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\nu16_mbtouc_unsafe_aux (ucs4_t *puc, const uint16_t *s, size_t n)\n{\n  uint16_t c = *s;\n\n  if (c < 0xdc00)\n    {\n      if (n >= 2)\n        {\n          if (s[1] >= 0xdc00 && s[1] < 0xe000)\n            {\n              *puc = 0x10000 + ((c - 0xd800) << 10) + (s[1] - 0xdc00);\n              return 2;\n            }\n          /* invalid multibyte character */\n        }\n      else\n        {\n          /* incomplete multibyte character */\n        }\n    }\n  /* invalid multibyte character */\n  *puc = 0xfffd;\n  return 1;\n}",
      "lines": 25,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u16-mbtouc-unsafe.c": {
    "u16_mbtouc_unsafe": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int\nu16_mbtouc_unsafe (ucs4_t *puc, const uint16_t *s, size_t n)\n{\n  uint16_t c = *s;\n\n  if (c < 0xd800 || c >= 0xe000)\n    {\n      *puc = c;\n      return 1;\n    }\n  if (c < 0xdc00)\n    {\n      if (n >= 2)\n        {\n          if (s[1] >= 0xdc00 && s[1] < 0xe000)\n            {\n              *puc = 0x10000 + ((c - 0xd800) << 10) + (s[1] - 0xdc00);\n              return 2;\n            }\n          /* invalid multibyte character */\n        }\n      else\n        {\n          /* incomplete multibyte character */\n        }\n    }\n  /* invalid multibyte character */\n  *puc = 0xfffd;\n  return 1;\n}",
      "lines": 30,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u16-mbtouc.c": {
    "u16_mbtouc": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\nu16_mbtouc (ucs4_t *puc, const uint16_t *s, size_t n)\n{\n  uint16_t c = *s;\n\n  if (c < 0xd800 || c >= 0xe000)\n    {\n      *puc = c;\n      return 1;\n    }\n  if (c < 0xdc00)\n    {\n      if (n >= 2)\n        {\n          if (s[1] >= 0xdc00 && s[1] < 0xe000)\n            {\n              *puc = 0x10000 + ((c - 0xd800) << 10) + (s[1] - 0xdc00);\n              return 2;\n            }\n          /* invalid multibyte character */\n        }\n      else\n        {\n          /* incomplete multibyte character */\n        }\n    }\n  /* invalid multibyte character */\n  *puc = 0xfffd;\n  return 1;\n}",
      "lines": 30,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u16-mbtoucr.c": {
    "u16_mbtoucr": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\nu16_mbtoucr (ucs4_t *puc, const uint16_t *s, size_t n)\n{\n  uint16_t c = *s;\n\n  if (c < 0xd800 || c >= 0xe000)\n    {\n      *puc = c;\n      return 1;\n    }\n  if (c < 0xdc00)\n    {\n      if (n >= 2)\n        {\n          if (s[1] >= 0xdc00 && s[1] < 0xe000)\n            {\n              *puc = 0x10000 + ((c - 0xd800) << 10) + (s[1] - 0xdc00);\n              return 2;\n            }\n          /* invalid multibyte character */\n        }\n      else\n        {\n          /* incomplete multibyte character */\n          *puc = 0xfffd;\n          return -2;\n        }\n    }\n  /* invalid multibyte character */\n  *puc = 0xfffd;\n  return -1;\n}",
      "lines": 32,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u16-move.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u16-next.c": {
    "u16_next": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "const uint16_t *\nu16_next (ucs4_t *puc, const uint16_t *s)\n{\n  int count;\n\n  count = u16_strmbtouc (puc, s);\n  if (count > 0)\n    return s + count;\n  else\n    {\n      if (count < 0)\n        *puc = 0xfffd;\n      return NULL;\n    }\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "const",
        "const",
        "uint16_t",
        "*\nu16_next (ucs4_t *puc, const uint16_t *s)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u16-prev.c": {
    "u16_prev": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "const uint16_t *\nu16_prev (ucs4_t *puc, const uint16_t *s, const uint16_t *start)\n{\n  /* Keep in sync with unistr.h and utf16-ucs4.c.  */\n  if (s != start)\n    {\n      uint16_t c_1 = s[-1];\n\n      if (c_1 < 0xd800 || c_1 >= 0xe000)\n        {\n          *puc = c_1;\n          return s - 1;\n        }\n      if (c_1 >= 0xdc00)\n        if (s - 1 != start)\n          {\n            uint16_t c_2 = s[-2];\n\n            if (c_2 >= 0xd800 && c_2 < 0xdc00)\n              {\n                *puc = 0x10000 + ((c_2 - 0xd800) << 10) + (c_1 - 0xdc00);\n                return s - 2;\n              }\n          }\n    }\n  return NULL;\n}",
      "lines": 27,
      "depth": 18,
      "decorators": [
        "const",
        "const",
        "uint16_t",
        "*\nu16_prev (ucs4_t *puc, const uint16_t *s, const uint16_t *start)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u16-set.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u16-startswith.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u16-stpcpy.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u16-stpncpy.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u16-strcat.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u16-strchr.c": {
    "u16_strchr": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "uint16_t *\nu16_strchr (const uint16_t *s, ucs4_t uc)\n{\n  uint16_t c[2];\n\n  if (uc < 0x10000)\n    {\n      uint16_t c0 = uc;\n\n      for (;; s++)\n        {\n          if (*s == c0)\n            break;\n          if (*s == 0)\n            goto notfound;\n        }\n      return (uint16_t *) s;\n    }\n  else\n    switch (u16_uctomb_aux (c, uc, 2))\n      {\n      case 2:\n        if (*s == 0)\n          goto notfound;\n        {\n          uint16_t c0 = c[0];\n          uint16_t c1 = c[1];\n\n          for (;; s++)\n            {\n              if (s[1] == 0)\n                goto notfound;\n              if (*s == c0 && s[1] == c1)\n                break;\n            }\n          return (uint16_t *) s;\n        }\n      }\nnotfound:\n  return NULL;\n}",
      "lines": 41,
      "depth": 15,
      "decorators": [
        "uint16_t",
        "*\nu16_strchr (const uint16_t *s, ucs4_t uc)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u16-strcmp.c": {
    "u16_strcmp": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "int\nu16_strcmp (const uint16_t *s1, const uint16_t *s2)\n{\n  /* Note that the UTF-16 encoding does NOT preserve lexicographic order.\n     Namely, if uc1 is a 16-bit character and [uc2a,uc2b] is a surrogate pair,\n     we must enforce uc1 < [uc2a,uc2b], even if uc1 > uc2a.  */\n  for (;;)\n    {\n      uint16_t c1 = *s1++;\n      uint16_t c2 = *s2++;\n      if (c1 != 0 && c1 == c2)\n        continue;\n      if (c1 < 0xd800 || c1 >= 0xe000)\n        {\n          if (!(c2 < 0xd800 || c2 >= 0xe000))\n            /* c2 is a surrogate, but c1 is not.  */\n            return -1;\n        }\n      else\n        {\n          if (c2 < 0xd800 || c2 >= 0xe000)\n            /* c1 is a surrogate, but c2 is not.  */\n            return 1;\n        }\n      return (int)c1 - (int)c2;\n      /* > 0 if c1 > c2, < 0 if c1 < c2. */\n    }\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u16-strcoll.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u16-strcpy.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u16-strcspn.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u16-strdup.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u16-strlen.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u16-strmblen.c": {
    "u16_strmblen": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "int\nu16_strmblen (const uint16_t *s)\n{\n  /* Keep in sync with unistr.h and u16-mbtouc-aux.c.  */\n  uint16_t c = *s;\n\n  if (c < 0xd800 || c >= 0xe000)\n    return (c != 0 ? 1 : 0);\n  if (c < 0xdc00)\n    {\n      if (s[1] >= 0xdc00 && s[1] < 0xe000)\n        return 2;\n    }\n  /* invalid or incomplete multibyte character */\n  return -1;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u16-strmbtouc.c": {
    "u16_strmbtouc": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\nu16_strmbtouc (ucs4_t *puc, const uint16_t *s)\n{\n  /* Keep in sync with unistr.h and u16-mbtouc-aux.c.  */\n  uint16_t c = *s;\n\n  if (c < 0xd800 || c >= 0xe000)\n    {\n      *puc = c;\n      return (c != 0 ? 1 : 0);\n    }\n  if (c < 0xdc00)\n    {\n      if (s[1] >= 0xdc00 && s[1] < 0xe000)\n        {\n          *puc = 0x10000 + ((c - 0xd800) << 10) + (s[1] - 0xdc00);\n          return 2;\n        }\n    }\n  /* invalid or incomplete multibyte character */\n  return -1;\n}",
      "lines": 22,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u16-strncat.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u16-strncmp.c": {
    "u16_strncmp": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\nu16_strncmp (const uint16_t *s1, const uint16_t *s2, size_t n)\n{\n  /* Note that the UTF-16 encoding does NOT preserve lexicographic order.\n     Namely, if uc1 is a 16-bit character and [uc2a,uc2b] is a surrogate pair,\n     we must enforce uc1 < [uc2a,uc2b], even if uc1 > uc2a.  */\n  for (; n > 0;)\n    {\n      uint16_t c1 = *s1++;\n      uint16_t c2 = *s2++;\n      if (c1 != 0 && c1 == c2)\n        {\n          n--;\n          continue;\n        }\n      if (c1 < 0xd800 || c1 >= 0xe000)\n        {\n          if (!(c2 < 0xd800 || c2 >= 0xe000))\n            /* c2 is a surrogate, but c1 is not.  */\n            return -1;\n        }\n      else\n        {\n          if (c2 < 0xd800 || c2 >= 0xe000)\n            /* c1 is a surrogate, but c2 is not.  */\n            return 1;\n        }\n      return (int)c1 - (int)c2;\n      /* > 0 if c1 > c2, < 0 if c1 < c2, = 0 if c1 and c2 are both 0. */\n    }\n  return 0;\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u16-strncpy.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u16-strnlen.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u16-strpbrk.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u16-strrchr.c": {
    "u16_strrchr": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "uint16_t *\nu16_strrchr (const uint16_t *s, ucs4_t uc)\n{\n  /* Calling u16_strlen and then searching from the other end would cause more\n     memory accesses. Avoid that, at the cost of a few more comparisons.  */\n  uint16_t *result = NULL;\n  uint16_t c[2];\n\n  if (uc < 0x10000)\n    {\n      uint16_t c0 = uc;\n\n      for (;; s++)\n        {\n          if (*s == c0)\n            result = (uint16_t *) s;\n          if (*s == 0)\n            break;\n        }\n    }\n  else\n    switch (u16_uctomb_aux (c, uc, 2))\n      {\n      case 2:\n        if (*s)\n          {\n            uint16_t c0 = c[0];\n            uint16_t c1 = c[1];\n\n            /* FIXME: Maybe walking the string via u16_mblen is a win?  */\n            for (;; s++)\n              {\n                if (s[1] == 0)\n                  break;\n                if (*s == c0 && s[1] == c1)\n                  result = (uint16_t *) s;\n              }\n          }\n        break;\n      }\n  return result;\n}",
      "lines": 42,
      "depth": 17,
      "decorators": [
        "uint16_t",
        "*\nu16_strrchr (const uint16_t *s, ucs4_t uc)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u16-strspn.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u16-strstr.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u16-strtok.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u16-to-u32.c": {
    "FUNC": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "DST_UNIT *\nFUNC (const SRC_UNIT *s, size_t n, DST_UNIT *resultbuf, size_t *lengthp)\n{\n  const SRC_UNIT *s_end = s + n;\n  /* Output string accumulator.  */\n  DST_UNIT *result;\n  size_t allocated;\n  size_t length;\n\n  if (resultbuf != NULL)\n    {\n      result = resultbuf;\n      allocated = *lengthp;\n    }\n  else\n    {\n      result = NULL;\n      allocated = 0;\n    }\n  length = 0;\n  /* Invariants:\n     result is either == resultbuf or == NULL or malloc-allocated.\n     If length > 0, then result != NULL.  */\n\n  while (s < s_end)\n    {\n      ucs4_t uc;\n      int count;\n\n      /* Fetch a Unicode character from the input string.  */\n      count = u16_mbtoucr (&uc, s, s_end - s);\n      if (count < 0)\n        {\n          if (!(result == resultbuf || result == NULL))\n            free (result);\n          errno = EILSEQ;\n          return NULL;\n        }\n      s += count;\n\n      /* Store it in the output string.  */\n      if (length + 1 > allocated)\n        {\n          DST_UNIT *memory;\n\n          allocated = (allocated > 0 ? 2 * allocated : 12);\n          if (length + 1 > allocated)\n            allocated = length + 1;\n          if (result == resultbuf || result == NULL)\n            memory = (DST_UNIT *) malloc (allocated * sizeof (DST_UNIT));\n          else\n            memory =\n              (DST_UNIT *) realloc (result, allocated * sizeof (DST_UNIT));\n\n          if (memory == NULL)\n            {\n              if (!(result == resultbuf || result == NULL))\n                free (result);\n              errno = ENOMEM;\n              return NULL;\n            }\n          if (result == resultbuf && length > 0)\n            memcpy ((char *) memory, (char *) result,\n                    length * sizeof (DST_UNIT));\n          result = memory;\n        }\n      result[length++] = uc;\n    }\n\n  if (length == 0)\n    {\n      if (result == NULL)\n        {\n          /* Return a non-NULL value.  NULL means error.  */\n          result = (DST_UNIT *) malloc (1);\n          if (result == NULL)\n            {\n              errno = ENOMEM;\n              return NULL;\n            }\n        }\n    }\n  else if (result != resultbuf && length < allocated)\n    {\n      /* Shrink the allocated memory if possible.  */\n      DST_UNIT *memory;\n\n      memory = (DST_UNIT *) realloc (result, length * sizeof (DST_UNIT));\n      if (memory != NULL)\n        result = memory;\n    }\n\n  *lengthp = length;\n  return result;\n}",
      "lines": 95,
      "depth": 16,
      "decorators": [
        "DST_UNIT",
        "*\nFUNC (const SRC_UNIT *s, size_t n, DST_UNIT *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u16-to-u8.c": {
    "FUNC": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "DST_UNIT *\nFUNC (const SRC_UNIT *s, size_t n, DST_UNIT *resultbuf, size_t *lengthp)\n{\n  const SRC_UNIT *s_end = s + n;\n  /* Output string accumulator.  */\n  DST_UNIT *result;\n  size_t allocated;\n  size_t length;\n\n  if (resultbuf != NULL)\n    {\n      result = resultbuf;\n      allocated = *lengthp;\n    }\n  else\n    {\n      result = NULL;\n      allocated = 0;\n    }\n  length = 0;\n  /* Invariants:\n     result is either == resultbuf or == NULL or malloc-allocated.\n     If length > 0, then result != NULL.  */\n\n  while (s < s_end)\n    {\n      ucs4_t uc;\n      int count;\n\n      /* Fetch a Unicode character from the input string.  */\n      count = u16_mbtoucr (&uc, s, s_end - s);\n      if (count < 0)\n        {\n          if (!(result == resultbuf || result == NULL))\n            free (result);\n          errno = EILSEQ;\n          return NULL;\n        }\n      s += count;\n\n      /* Store it in the output string.  */\n      count = u8_uctomb (result + length, uc, allocated - length);\n      if (count == -1)\n        {\n          if (!(result == resultbuf || result == NULL))\n            free (result);\n          errno = EILSEQ;\n          return NULL;\n        }\n      if (count == -2)\n        {\n          DST_UNIT *memory;\n\n          allocated = (allocated > 0 ? 2 * allocated : 12);\n          if (length + 6 > allocated)\n            allocated = length + 6;\n          if (result == resultbuf || result == NULL)\n            memory = (DST_UNIT *) malloc (allocated * sizeof (DST_UNIT));\n          else\n            memory =\n              (DST_UNIT *) realloc (result, allocated * sizeof (DST_UNIT));\n\n          if (memory == NULL)\n            {\n              if (!(result == resultbuf || result == NULL))\n                free (result);\n              errno = ENOMEM;\n              return NULL;\n            }\n          if (result == resultbuf && length > 0)\n            memcpy ((char *) memory, (char *) result,\n                    length * sizeof (DST_UNIT));\n          result = memory;\n          count = u8_uctomb (result + length, uc, allocated - length);\n          if (count < 0)\n            abort ();\n        }\n      length += count;\n    }\n\n  if (length == 0)\n    {\n      if (result == NULL)\n        {\n          /* Return a non-NULL value.  NULL means error.  */\n          result = (DST_UNIT *) malloc (1);\n          if (result == NULL)\n            {\n              errno = ENOMEM;\n              return NULL;\n            }\n        }\n    }\n  else if (result != resultbuf && length < allocated)\n    {\n      /* Shrink the allocated memory if possible.  */\n      DST_UNIT *memory;\n\n      memory = (DST_UNIT *) realloc (result, length * sizeof (DST_UNIT));\n      if (memory != NULL)\n        result = memory;\n    }\n\n  *lengthp = length;\n  return result;\n}",
      "lines": 106,
      "depth": 16,
      "decorators": [
        "DST_UNIT",
        "*\nFUNC (const SRC_UNIT *s, size_t n, DST_UNIT *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u16-uctomb-aux.c": {
    "u16_uctomb_aux": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "int\nu16_uctomb_aux (uint16_t *s, ucs4_t uc, int n)\n{\n  if (uc < 0xd800)\n    {\n      /* The case n >= 1 is already handled by the caller.  */\n    }\n  else if (uc < 0x10000)\n    {\n      if (uc >= 0xe000)\n        {\n          if (n >= 1)\n            {\n              s[0] = uc;\n              return 1;\n            }\n        }\n      else\n        return -1;\n    }\n  else\n    {\n      if (uc < 0x110000)\n        {\n          if (n >= 2)\n            {\n              s[0] = 0xd800 + ((uc - 0x10000) >> 10);\n              s[1] = 0xdc00 + ((uc - 0x10000) & 0x3ff);\n              return 2;\n            }\n        }\n      else\n        return -1;\n    }\n  return -2;\n}",
      "lines": 36,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u16-uctomb.c": {
    "u16_uctomb": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int\nu16_uctomb (uint16_t *s, ucs4_t uc, int n)\n{\n  if (uc < 0xd800)\n    {\n      if (n > 0)\n        {\n          s[0] = uc;\n          return 1;\n        }\n      /* else return -2, below.  */\n    }\n  else if (uc < 0x10000)\n    {\n      if (uc >= 0xe000)\n        {\n          if (n >= 1)\n            {\n              s[0] = uc;\n              return 1;\n            }\n        }\n      else\n        return -1;\n    }\n  else\n    {\n      if (uc < 0x110000)\n        {\n          if (n >= 2)\n            {\n              s[0] = 0xd800 + ((uc - 0x10000) >> 10);\n              s[1] = 0xdc00 + ((uc - 0x10000) & 0x3ff);\n              return 2;\n            }\n        }\n      else\n        return -1;\n    }\n  return -2;\n}",
      "lines": 41,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u32-check.c": {
    "u32_check": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "const uint32_t *\nu32_check (const uint32_t *s, size_t n)\n{\n  const uint32_t *s_end = s + n;\n\n  while (s < s_end)\n    {\n      uint32_t c = *s;\n\n      if (c < 0xd800 || (c >= 0xe000 && c < 0x110000))\n        s++;\n      else\n        /* invalid Unicode character */\n        return s;\n    }\n  return NULL;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "const",
        "const",
        "uint32_t",
        "*\nu32_check (const uint32_t *s, size_t n)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u32-chr.c": {
    "u32_chr": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "uint32_t *\nu32_chr (const uint32_t *s, size_t n, ucs4_t uc)\n{\n  for (; n > 0; s++, n--)\n    {\n      if (*s == uc)\n        return (uint32_t *) s;\n    }\n  return NULL;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "uint32_t",
        "*\nu32_chr (const uint32_t *s, size_t n, ucs4_t uc)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u32-cmp.c": {
    "u32_cmp": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nu32_cmp (const uint32_t *s1, const uint32_t *s2, size_t n)\n{\n  for (; n > 0;)\n    {\n      uint32_t uc1 = *s1++;\n      uint32_t uc2 = *s2++;\n      if (uc1 == uc2)\n        {\n          n--;\n          continue;\n        }\n      /* Note that uc1 and uc2 each have at most 31 bits. */\n      return (int)uc1 - (int)uc2;\n      /* > 0 if uc1 > uc2, < 0 if uc1 < uc2. */\n    }\n  return 0;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u32-cmp2.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u32-cpy-alloc.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u32-cpy.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u32-endswith.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u32-mblen.c": {
    "u32_mblen": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nu32_mblen (const uint32_t *s, size_t n)\n{\n  if (n > 0)\n    {\n      uint32_t c = *s;\n\n      if (c < 0xd800 || (c >= 0xe000 && c < 0x110000))\n        return (c != 0 ? 1 : 0);\n    }\n  /* invalid or incomplete multibyte character */\n  return -1;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u32-mbsnlen.c": {
    "u32_mbsnlen": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "size_t\nu32_mbsnlen (const uint32_t *s, size_t n)\n{\n  return n;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u32-mbtouc-unsafe.c": {
    "u32_mbtouc_unsafe": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "int\nu32_mbtouc_unsafe (ucs4_t *puc, const uint32_t *s, size_t n)\n{\n  uint32_t c = *s;\n\n  if (c < 0xd800 || (c >= 0xe000 && c < 0x110000))\n    *puc = c;\n  else\n    /* invalid multibyte character */\n    *puc = 0xfffd;\n  return 1;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u32-mbtouc.c": {
    "u32_mbtouc": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nu32_mbtouc (ucs4_t *puc, const uint32_t *s, size_t n)\n{\n  uint32_t c = *s;\n\n  if (c < 0xd800 || (c >= 0xe000 && c < 0x110000))\n    *puc = c;\n  else\n    /* invalid multibyte character */\n    *puc = 0xfffd;\n  return 1;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u32-mbtoucr.c": {
    "u32_mbtoucr": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "int\nu32_mbtoucr (ucs4_t *puc, const uint32_t *s, size_t n)\n{\n  uint32_t c = *s;\n\n  if (c < 0xd800 || (c >= 0xe000 && c < 0x110000))\n    {\n      *puc = c;\n      return 1;\n    }\n  else\n    {\n      /* invalid multibyte character */\n      *puc = 0xfffd;\n      return -1;\n    }\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u32-move.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u32-next.c": {
    "u32_next": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "const uint32_t *\nu32_next (ucs4_t *puc, const uint32_t *s)\n{\n  int count;\n\n  count = u32_strmbtouc (puc, s);\n  if (count > 0)\n    return s + count;\n  else\n    {\n      if (count < 0)\n        *puc = 0xfffd;\n      return NULL;\n    }\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "const",
        "const",
        "uint32_t",
        "*\nu32_next (ucs4_t *puc, const uint32_t *s)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u32-prev.c": {
    "u32_prev": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "const uint32_t *\nu32_prev (ucs4_t *puc, const uint32_t *s, const uint32_t *start)\n{\n  if (s != start)\n    {\n      uint32_t c_1 = s[-1];\n\n      if (c_1 < 0xd800 || (c_1 >= 0xe000 && c_1 < 0x110000))\n        {\n          *puc = c_1;\n          return s - 1;\n        }\n    }\n  return NULL;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "const",
        "const",
        "uint32_t",
        "*\nu32_prev (ucs4_t *puc, const uint32_t *s, const uint32_t *start)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u32-set.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u32-startswith.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u32-stpcpy.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u32-stpncpy.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u32-strcat.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u32-strchr.c": {
    "u32_strchr": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "uint32_t *\nu32_strchr (const uint32_t *s, ucs4_t uc)\n{\n  for (;; s++)\n    {\n      if (*s == uc)\n        break;\n      if (*s == 0)\n        goto notfound;\n    }\n  return (uint32_t *) s;\nnotfound:\n  return NULL;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "uint32_t",
        "*\nu32_strchr (const uint32_t *s, ucs4_t uc)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u32-strcmp.c": {
    "u32_strcmp": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "int\nu32_strcmp (const uint32_t *s1, const uint32_t *s2)\n{\n  for (;;)\n    {\n      uint32_t uc1 = *s1++;\n      uint32_t uc2 = *s2++;\n      if (uc1 != 0 && uc1 == uc2)\n        continue;\n      /* Note that uc1 and uc2 each have at most 31 bits. */\n      return (int)uc1 - (int)uc2;\n      /* > 0 if uc1 > uc2, < 0 if uc1 < uc2. */\n    }\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u32-strcoll.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u32-strcpy.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u32-strcspn.c": {
    "FUNC": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "size_t\nFUNC (const UNIT *str, const UNIT *reject)\n{\n  /* Optimize two cases.  */\n  if (reject[0] == 0)\n    return U_STRLEN (str);\n  if (reject[1] == 0)\n    {\n      ucs4_t uc = reject[0];\n      const UNIT *ptr = str;\n      for (; *ptr != 0; ptr++)\n        if (*ptr == uc)\n          break;\n      return ptr - str;\n    }\n  /* General case.  */\n  {\n    const UNIT *ptr = str;\n    for (; *ptr != 0; ptr++)\n      if (U_STRCHR (reject, *ptr))\n        break;\n    return ptr - str;\n  }\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "size_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u32-strdup.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u32-strlen.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u32-strmblen.c": {
    "u32_strmblen": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\nu32_strmblen (const uint32_t *s)\n{\n  uint32_t c = *s;\n\n  if (c < 0xd800 || (c >= 0xe000 && c < 0x110000))\n    return (c != 0 ? 1 : 0);\n  /* invalid multibyte character */\n  return -1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u32-strmbtouc.c": {
    "u32_strmbtouc": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nu32_strmbtouc (ucs4_t *puc, const uint32_t *s)\n{\n  uint32_t c = *s;\n\n  if (c < 0xd800 || (c >= 0xe000 && c < 0x110000))\n    {\n      *puc = c;\n      return (c != 0 ? 1 : 0);\n    }\n  /* invalid multibyte character */\n  return -1;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u32-strncat.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u32-strncmp.c": {
    "u32_strncmp": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nu32_strncmp (const uint32_t *s1, const uint32_t *s2, size_t n)\n{\n  for (; n > 0;)\n    {\n      uint32_t uc1 = *s1++;\n      uint32_t uc2 = *s2++;\n      if (uc1 != 0 && uc1 == uc2)\n        {\n          n--;\n          continue;\n        }\n      /* Note that uc1 and uc2 each have at most 31 bits. */\n      return (int)uc1 - (int)uc2;\n      /* > 0 if uc1 > uc2, < 0 if uc1 < uc2, = 0 if uc1 and uc2 are both 0.  */\n    }\n  return 0;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u32-strncpy.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u32-strnlen.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u32-strpbrk.c": {
    "FUNC": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "UNIT *\nFUNC (const UNIT *str, const UNIT *accept)\n{\n  /* Optimize two cases.  */\n  if (accept[0] == 0)\n    return NULL;\n  if (accept[1] == 0)\n    {\n      ucs4_t uc = accept[0];\n      const UNIT *ptr = str;\n      for (; *ptr != 0; ptr++)\n        if (*ptr == uc)\n          return (UNIT *) ptr;\n      return NULL;\n    }\n  /* General case.  */\n  {\n    const UNIT *ptr = str;\n    for (; *ptr != 0; ptr++)\n      if (U_STRCHR (accept, *ptr))\n        return (UNIT *) ptr;\n    return NULL;\n  }\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "UNIT",
        "*\nFUNC (const UNIT *str, const UNIT *accept)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u32-strrchr.c": {
    "u32_strrchr": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "uint32_t *\nu32_strrchr (const uint32_t *s, ucs4_t uc)\n{\n  /* Calling u32_strlen and then searching from the other end would cause more\n     memory accesses. Avoid that, at the cost of a few more comparisons.  */\n  uint32_t *result = NULL;\n\n  for (;; s++)\n    {\n      if (*s == uc)\n        result = (uint32_t *) s;\n      if (*s == 0)\n        break;\n    }\n  return result;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "uint32_t",
        "*\nu32_strrchr (const uint32_t *s, ucs4_t uc)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u32-strspn.c": {
    "FUNC": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "size_t\nFUNC (const UNIT *str, const UNIT *accept)\n{\n  /* Optimize two cases.  */\n  if (accept[0] == 0)\n    return 0;\n  if (accept[1] == 0)\n    {\n      ucs4_t uc = accept[0];\n      const UNIT *ptr = str;\n      for (; *ptr != 0; ptr++)\n        if (*ptr != uc)\n          break;\n      return ptr - str;\n    }\n  /* General case.  */\n  {\n    const UNIT *ptr = str;\n    for (; *ptr != 0; ptr++)\n      if (!U_STRCHR (accept, *ptr))\n        break;\n    return ptr - str;\n  }\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u32-strstr.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u32-strtok.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u32-to-u16.c": {
    "FUNC": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "DST_UNIT *\nFUNC (const SRC_UNIT *s, size_t n, DST_UNIT *resultbuf, size_t *lengthp)\n{\n  const SRC_UNIT *s_end = s + n;\n  /* Output string accumulator.  */\n  DST_UNIT *result;\n  size_t allocated;\n  size_t length;\n\n  if (resultbuf != NULL)\n    {\n      result = resultbuf;\n      allocated = *lengthp;\n    }\n  else\n    {\n      result = NULL;\n      allocated = 0;\n    }\n  length = 0;\n  /* Invariants:\n     result is either == resultbuf or == NULL or malloc-allocated.\n     If length > 0, then result != NULL.  */\n\n  while (s < s_end)\n    {\n      ucs4_t uc;\n      int count;\n\n      /* Fetch a Unicode character from the input string.  */\n      uc = *s++;\n      /* No need to call the safe variant u32_mbtouc, because\n         u16_uctomb will verify uc anyway.  */\n\n      /* Store it in the output string.  */\n      count = u16_uctomb (result + length, uc, allocated - length);\n      if (count == -1)\n        {\n          if (!(result == resultbuf || result == NULL))\n            free (result);\n          errno = EILSEQ;\n          return NULL;\n        }\n      if (count == -2)\n        {\n          DST_UNIT *memory;\n\n          allocated = (allocated > 0 ? 2 * allocated : 12);\n          if (length + 2 > allocated)\n            allocated = length + 2;\n          if (result == resultbuf || result == NULL)\n            memory = (DST_UNIT *) malloc (allocated * sizeof (DST_UNIT));\n          else\n            memory =\n              (DST_UNIT *) realloc (result, allocated * sizeof (DST_UNIT));\n\n          if (memory == NULL)\n            {\n              if (!(result == resultbuf || result == NULL))\n                free (result);\n              errno = ENOMEM;\n              return NULL;\n            }\n          if (result == resultbuf && length > 0)\n            memcpy ((char *) memory, (char *) result,\n                    length * sizeof (DST_UNIT));\n          result = memory;\n          count = u16_uctomb (result + length, uc, allocated - length);\n          if (count < 0)\n            abort ();\n        }\n      length += count;\n    }\n\n  if (length == 0)\n    {\n      if (result == NULL)\n        {\n          /* Return a non-NULL value.  NULL means error.  */\n          result = (DST_UNIT *) malloc (1);\n          if (result == NULL)\n            {\n              errno = ENOMEM;\n              return NULL;\n            }\n        }\n    }\n  else if (result != resultbuf && length < allocated)\n    {\n      /* Shrink the allocated memory if possible.  */\n      DST_UNIT *memory;\n\n      memory = (DST_UNIT *) realloc (result, length * sizeof (DST_UNIT));\n      if (memory != NULL)\n        result = memory;\n    }\n\n  *lengthp = length;\n  return result;\n}",
      "lines": 100,
      "depth": 16,
      "decorators": [
        "DST_UNIT",
        "*\nFUNC (const SRC_UNIT *s, size_t n, DST_UNIT *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u32-to-u8.c": {
    "FUNC": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "DST_UNIT *\nFUNC (const SRC_UNIT *s, size_t n, DST_UNIT *resultbuf, size_t *lengthp)\n{\n  const SRC_UNIT *s_end = s + n;\n  /* Output string accumulator.  */\n  DST_UNIT *result;\n  size_t allocated;\n  size_t length;\n\n  if (resultbuf != NULL)\n    {\n      result = resultbuf;\n      allocated = *lengthp;\n    }\n  else\n    {\n      result = NULL;\n      allocated = 0;\n    }\n  length = 0;\n  /* Invariants:\n     result is either == resultbuf or == NULL or malloc-allocated.\n     If length > 0, then result != NULL.  */\n\n  while (s < s_end)\n    {\n      ucs4_t uc;\n      int count;\n\n      /* Fetch a Unicode character from the input string.  */\n      uc = *s++;\n      /* No need to call the safe variant u32_mbtouc, because\n         u8_uctomb will verify uc anyway.  */\n\n      /* Store it in the output string.  */\n      count = u8_uctomb (result + length, uc, allocated - length);\n      if (count == -1)\n        {\n          if (!(result == resultbuf || result == NULL))\n            free (result);\n          errno = EILSEQ;\n          return NULL;\n        }\n      if (count == -2)\n        {\n          DST_UNIT *memory;\n\n          allocated = (allocated > 0 ? 2 * allocated : 12);\n          if (length + 6 > allocated)\n            allocated = length + 6;\n          if (result == resultbuf || result == NULL)\n            memory = (DST_UNIT *) malloc (allocated * sizeof (DST_UNIT));\n          else\n            memory =\n              (DST_UNIT *) realloc (result, allocated * sizeof (DST_UNIT));\n\n          if (memory == NULL)\n            {\n              if (!(result == resultbuf || result == NULL))\n                free (result);\n              errno = ENOMEM;\n              return NULL;\n            }\n          if (result == resultbuf && length > 0)\n            memcpy ((char *) memory, (char *) result,\n                    length * sizeof (DST_UNIT));\n          result = memory;\n          count = u8_uctomb (result + length, uc, allocated - length);\n          if (count < 0)\n            abort ();\n        }\n      length += count;\n    }\n\n  if (length == 0)\n    {\n      if (result == NULL)\n        {\n          /* Return a non-NULL value.  NULL means error.  */\n          result = (DST_UNIT *) malloc (1);\n          if (result == NULL)\n            {\n              errno = ENOMEM;\n              return NULL;\n            }\n        }\n    }\n  else if (result != resultbuf && length < allocated)\n    {\n      /* Shrink the allocated memory if possible.  */\n      DST_UNIT *memory;\n\n      memory = (DST_UNIT *) realloc (result, length * sizeof (DST_UNIT));\n      if (memory != NULL)\n        result = memory;\n    }\n\n  *lengthp = length;\n  return result;\n}",
      "lines": 100,
      "depth": 16,
      "decorators": [
        "DST_UNIT",
        "*\nFUNC (const SRC_UNIT *s, size_t n, DST_UNIT *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u32-uctomb.c": {
    "u32_uctomb": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\nu32_uctomb (uint32_t *s, ucs4_t uc, int n)\n{\n  if (uc < 0xd800 || (uc >= 0xe000 && uc < 0x110000))\n    {\n      if (n > 0)\n        {\n          *s = uc;\n          return 1;\n        }\n      else\n        return -2;\n    }\n  else\n    return -1;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-check.c": {
    "u8_check": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "const uint8_t *\nu8_check (const uint8_t *s, size_t n)\n{\n  const uint8_t *s_end = s + n;\n\n  while (s < s_end)\n    {\n      /* Keep in sync with unistr.h and u8-mbtouc-aux.c.  */\n      uint8_t c = *s;\n\n      if (c < 0x80)\n        {\n          s++;\n          continue;\n        }\n      if (c >= 0xc2)\n        {\n          if (c < 0xe0)\n            {\n              if (s + 2 <= s_end\n                  && (s[1] ^ 0x80) < 0x40)\n                {\n                  s += 2;\n                  continue;\n                }\n            }\n          else if (c < 0xf0)\n            {\n              if (s + 3 <= s_end\n                  && (s[1] ^ 0x80) < 0x40 && (s[2] ^ 0x80) < 0x40\n                  && (c >= 0xe1 || s[1] >= 0xa0)\n                  && (c != 0xed || s[1] < 0xa0))\n                {\n                  s += 3;\n                  continue;\n                }\n            }\n          else if (c < 0xf8)\n            {\n              if (s + 4 <= s_end\n                  && (s[1] ^ 0x80) < 0x40 && (s[2] ^ 0x80) < 0x40\n                  && (s[3] ^ 0x80) < 0x40\n                  && (c >= 0xf1 || s[1] >= 0x90)\n                  && (c < 0xf4 || (c == 0xf4 && s[1] < 0x90)))\n                {\n                  s += 4;\n                  continue;\n                }\n            }\n        }\n      /* invalid or incomplete multibyte character */\n      return s;\n    }\n  return NULL;\n}",
      "lines": 55,
      "depth": 22,
      "decorators": [
        "const",
        "const",
        "uint8_t",
        "*\nu8_check (const uint8_t *s, size_t n)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-chr.c": {
    "u8_chr": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "uint8_t *\nu8_chr (const uint8_t *s, size_t n, ucs4_t uc)\n{\n  if (uc < 0x80)\n    {\n      uint8_t c0 = uc;\n\n      return (uint8_t *) memchr ((const char *) s, c0, n);\n    }\n\n  {\n    uint8_t c[6];\n    size_t uc_size;\n    uc_size = u8_uctomb_aux (c, uc, 6);\n\n    if (n < uc_size)\n      return NULL;\n\n    /* For multibyte character matching we use a Boyer-Moore like\n       algorithm that searches for the last byte, skipping multi-byte\n       jumps, and matches back from there.\n\n       Instead of using a table as is usual for Boyer-Moore, we compare\n       the candidate last byte s[UC_SIZE-1] with each of the possible\n       bytes in the UTF-8 representation of UC.  If the final byte does\n       not match, we will perform up to UC_SIZE comparisons per memory\n       load---but each comparison lets us skip one byte in the input!\n\n       If the final byte matches, the \"real\" Boyer-Moore algorithm\n       is approximated.  Instead, u8_chr just looks for other cN that\n       are equal to the final byte and uses those to try realigning to\n       another possible match.  For example, when searching for 0xF0\n       0xAA 0xBB 0xAA it will always skip forward by two bytes, even if\n       the character in the string was for example 0xF1 0xAA 0xBB 0xAA.\n       The advantage of this scheme is that the skip count after a failed\n       match can be computed outside the loop, and that it keeps the\n       complexity low for a pretty rare case.  In particular, since c[0]\n       is never between 0x80 and 0xBF, c[0] is never equal to c[UC_SIZE-1]\n       and this is optimal for two-byte UTF-8 characters.  */\n    switch (uc_size)\n      {\n      case 2:\n        {\n          uint8_t c0 = c[0];\n          uint8_t c1 = c[1];\n          const uint8_t *end = s + n - 1;\n\n          do\n            {\n              /* Here s < end.\n                 Test whether s[0..1] == { c0, c1 }.  */\n              uint8_t s1 = s[1];\n              if (s1 == c1)\n                {\n                  if (*s == c0)\n                    return (uint8_t *) s;\n                  else\n                    /* Skip the search at s + 1, because s[1] = c1 < c0.  */\n                    s += 2;\n                }\n              else\n                {\n                  if (s1 == c0)\n                    s++;\n                  else\n                    /* Skip the search at s + 1, because s[1] != c0.  */\n                    s += 2;\n                }\n            }\n          while (s < end);\n          break;\n        }\n\n      case 3:\n        {\n          uint8_t c0 = c[0];\n          uint8_t c1 = c[1];\n          uint8_t c2 = c[2];\n          const uint8_t *end = s + n - 2;\n          size_t skip;\n\n          if (c2 == c1)\n            skip = 1;\n          else\n            skip = 3;\n\n          do\n            {\n              /* Here s < end.\n                 Test whether s[0..2] == { c0, c1, c2 }.  */\n              uint8_t s2 = s[2];\n              if (s2 == c2)\n                {\n                  if (s[1] == c1 && *s == c0)\n                    return (uint8_t *) s;\n                  else\n                    /* If c2 != c1:\n                         Skip the search at s + 1, because s[2] == c2 != c1.\n                       Skip the search at s + 2, because s[2] == c2 < c0.  */\n                    s += skip;\n                }\n              else\n                {\n                  if (s2 == c1)\n                    s++;\n                  else if (s2 == c0)\n                    /* Skip the search at s + 1, because s[2] != c1.  */\n                    s += 2;\n                  else\n                    /* Skip the search at s + 1, because s[2] != c1.\n                       Skip the search at s + 2, because s[2] != c0.  */\n                    s += 3;\n                }\n            }\n          while (s < end);\n          break;\n        }\n\n      case 4:\n        {\n          uint8_t c0 = c[0];\n          uint8_t c1 = c[1];\n          uint8_t c2 = c[2];\n          uint8_t c3 = c[3];\n          const uint8_t *end = s + n - 3;\n          size_t skip;\n\n          if (c3 == c2)\n            skip = 1;\n          else if (c3 == c1)\n            skip = 2;\n          else\n            skip = 4;\n\n          do\n            {\n              /* Here s < end.\n                 Test whether s[0..3] == { c0, c1, c2, c3 }.  */\n              uint8_t s3 = s[3];\n              if (s3 == c3)\n                {\n                  if (s[2] == c2 && s[1] == c1 && *s == c0)\n                    return (uint8_t *) s;\n                  else\n                    /* If c3 != c2:\n                         Skip the search at s + 1, because s[3] == c3 != c2.\n                       If c3 != c1:\n                         Skip the search at s + 2, because s[3] == c3 != c1.\n                       Skip the search at s + 3, because s[3] == c3 < c0.  */\n                    s += skip;\n                }\n              else\n                {\n                  if (s3 == c2)\n                    s++;\n                  else if (s3 == c1)\n                    /* Skip the search at s + 1, because s[3] != c2.  */\n                    s += 2;\n                  else if (s3 == c0)\n                    /* Skip the search at s + 1, because s[3] != c2.\n                       Skip the search at s + 2, because s[3] != c1.  */\n                    s += 3;\n                  else\n                    /* Skip the search at s + 1, because s[3] != c2.\n                       Skip the search at s + 2, because s[3] != c1.\n                       Skip the search at s + 3, because s[3] != c0.  */\n                    s += 4;\n                }\n            }\n          while (s < end);\n          break;\n        }\n      }\n    return NULL;\n  }\n}",
      "lines": 176,
      "depth": 18,
      "decorators": [
        "uint8_t",
        "*\nu8_chr (const uint8_t *s, size_t n, ucs4_t uc)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-cmp.c": {
    "u8_cmp": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nu8_cmp (const uint8_t *s1, const uint8_t *s2, size_t n)\n{\n  /* Use the fact that the UTF-8 encoding preserves lexicographic order.  */\n  return memcmp ((const char *) s1, (const char *) s2, n);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-cmp2.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u8-cpy-alloc.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u8-cpy.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u8-endswith.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u8-mblen.c": {
    "u8_mblen": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nu8_mblen (const uint8_t *s, size_t n)\n{\n  if (n > 0)\n    {\n      /* Keep in sync with unistr.h and u8-mbtouc-aux.c.  */\n      uint8_t c = *s;\n\n      if (c < 0x80)\n        return (c != 0 ? 1 : 0);\n      if (c >= 0xc2)\n        {\n          if (c < 0xe0)\n            {\n              if (n >= 2\n                  && (s[1] ^ 0x80) < 0x40)\n                return 2;\n            }\n          else if (c < 0xf0)\n            {\n              if (n >= 3\n                  && (s[1] ^ 0x80) < 0x40 && (s[2] ^ 0x80) < 0x40\n                  && (c >= 0xe1 || s[1] >= 0xa0)\n                  && (c != 0xed || s[1] < 0xa0))\n                return 3;\n            }\n          else if (c < 0xf8)\n            {\n              if (n >= 4\n                  && (s[1] ^ 0x80) < 0x40 && (s[2] ^ 0x80) < 0x40\n                  && (s[3] ^ 0x80) < 0x40\n                  && (c >= 0xf1 || s[1] >= 0x90)\n                  && (c < 0xf4 || (c == 0xf4 && s[1] < 0x90)))\n                return 4;\n            }\n        }\n    }\n  /* invalid or incomplete multibyte character */\n  return -1;\n}",
      "lines": 40,
      "depth": 22,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-mbsnlen.c": {
    "u8_mbsnlen": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "size_t\nu8_mbsnlen (const uint8_t *s, size_t n)\n{\n  size_t characters;\n\n  characters = 0;\n  while (n > 0)\n    {\n      ucs4_t uc;\n      int count = u8_mbtoucr (&uc, s, n);\n      characters++;\n      if (count == -2)\n        break;\n      if (count < 0)\n        count = u8_mbtouc (&uc, s, n);\n      else if (count == 0)\n        count = 1;\n      s += count;\n      n -= count;\n    }\n  return characters;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-mbtouc-aux.c": {
    "u8_mbtouc_aux": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "int\nu8_mbtouc_aux (ucs4_t *puc, const uint8_t *s, size_t n)\n{\n  uint8_t c = *s;\n\n  if (c >= 0xc2)\n    {\n      if (c < 0xe0)\n        {\n          if (n >= 2)\n            {\n              if ((s[1] ^ 0x80) < 0x40)\n                {\n                  *puc = ((unsigned int) (c & 0x1f) << 6)\n                         | (unsigned int) (s[1] ^ 0x80);\n                  return 2;\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              return 1;\n            }\n        }\n      else if (c < 0xf0)\n        {\n          if (n >= 3)\n            {\n              if ((s[1] ^ 0x80) < 0x40)\n                {\n                  if ((s[2] ^ 0x80) < 0x40)\n                    {\n                      if ((c >= 0xe1 || s[1] >= 0xa0)\n                          && (c != 0xed || s[1] < 0xa0))\n                        {\n                          *puc = ((unsigned int) (c & 0x0f) << 12)\n                                 | ((unsigned int) (s[1] ^ 0x80) << 6)\n                                 | (unsigned int) (s[2] ^ 0x80);\n                          return 3;\n                        }\n                      /* invalid multibyte character */\n                      *puc = 0xfffd;\n                      return 3;\n                    }\n                  /* invalid multibyte character */\n                  *puc = 0xfffd;\n                  return 2;\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              if (n == 1 || (s[1] ^ 0x80) >= 0x40)\n                return 1;\n              else\n                return 2;\n            }\n        }\n      else if (c < 0xf8)\n        {\n          if (n >= 4)\n            {\n              if ((s[1] ^ 0x80) < 0x40)\n                {\n                  if ((s[2] ^ 0x80) < 0x40)\n                    {\n                      if ((s[3] ^ 0x80) < 0x40)\n                        {\n                          if ((c >= 0xf1 || s[1] >= 0x90)\n                              && (c < 0xf4 || (c == 0xf4 && s[1] < 0x90)))\n                            {\n                              *puc = ((unsigned int) (c & 0x07) << 18)\n                                     | ((unsigned int) (s[1] ^ 0x80) << 12)\n                                     | ((unsigned int) (s[2] ^ 0x80) << 6)\n                                     | (unsigned int) (s[3] ^ 0x80);\n                              return 4;\n                            }\n                          /* invalid multibyte character */\n                          *puc = 0xfffd;\n                          return 4;\n                        }\n                      /* invalid multibyte character */\n                      *puc = 0xfffd;\n                      return 3;\n                    }\n                  /* invalid multibyte character */\n                  *puc = 0xfffd;\n                  return 2;\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              if (n == 1 || (s[1] ^ 0x80) >= 0x40)\n                return 1;\n              else if (n == 2 || (s[2] ^ 0x80) >= 0x40)\n                return 2;\n              else\n                return 3;\n            }\n        }\n    }\n  /* invalid multibyte character */\n  *puc = 0xfffd;\n  return 1;\n}",
      "lines": 112,
      "depth": 30,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-mbtouc-unsafe-aux.c": {
    "u8_mbtouc_unsafe_aux": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "int\nu8_mbtouc_unsafe_aux (ucs4_t *puc, const uint8_t *s, size_t n)\n{\n  uint8_t c = *s;\n\n  if (c >= 0xc2)\n    {\n      if (c < 0xe0)\n        {\n          if (n >= 2)\n            {\n              if ((s[1] ^ 0x80) < 0x40)\n                {\n                  *puc = ((unsigned int) (c & 0x1f) << 6)\n                         | (unsigned int) (s[1] ^ 0x80);\n                  return 2;\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              return 1;\n            }\n        }\n      else if (c < 0xf0)\n        {\n          if (n >= 3)\n            {\n              if ((s[1] ^ 0x80) < 0x40)\n                {\n                  if ((s[2] ^ 0x80) < 0x40)\n                    {\n                      if ((c >= 0xe1 || s[1] >= 0xa0)\n                          && (c != 0xed || s[1] < 0xa0))\n                        {\n                          *puc = ((unsigned int) (c & 0x0f) << 12)\n                                 | ((unsigned int) (s[1] ^ 0x80) << 6)\n                                 | (unsigned int) (s[2] ^ 0x80);\n                          return 3;\n                        }\n                      /* invalid multibyte character */\n                      *puc = 0xfffd;\n                      return 3;\n                    }\n                  /* invalid multibyte character */\n                  *puc = 0xfffd;\n                  return 2;\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              if (n == 1 || (s[1] ^ 0x80) >= 0x40)\n                return 1;\n              else\n                return 2;\n            }\n        }\n      else if (c < 0xf8)\n        {\n          if (n >= 4)\n            {\n              if ((s[1] ^ 0x80) < 0x40)\n                {\n                  if ((s[2] ^ 0x80) < 0x40)\n                    {\n                      if ((s[3] ^ 0x80) < 0x40)\n                        {\n                          if ((c >= 0xf1 || s[1] >= 0x90)\n                              && (c < 0xf4 || (c == 0xf4 && s[1] < 0x90))\n                             )\n                            {\n                              *puc = ((unsigned int) (c & 0x07) << 18)\n                                     | ((unsigned int) (s[1] ^ 0x80) << 12)\n                                     | ((unsigned int) (s[2] ^ 0x80) << 6)\n                                     | (unsigned int) (s[3] ^ 0x80);\n                              return 4;\n                            }\n                          /* invalid multibyte character */\n                          *puc = 0xfffd;\n                          return 4;\n                        }\n                      /* invalid multibyte character */\n                      *puc = 0xfffd;\n                      return 3;\n                    }\n                  /* invalid multibyte character */\n                  *puc = 0xfffd;\n                  return 2;\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              if (n == 1 || (s[1] ^ 0x80) >= 0x40)\n                return 1;\n              else if (n == 2 || (s[2] ^ 0x80) >= 0x40)\n                return 2;\n              else\n                return 3;\n            }\n        }\n    }\n  /* invalid multibyte character */\n  *puc = 0xfffd;\n  return 1;\n}",
      "lines": 113,
      "depth": 30,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-mbtouc-unsafe.c": {
    "u8_mbtouc_unsafe": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "int\nu8_mbtouc_unsafe (ucs4_t *puc, const uint8_t *s, size_t n)\n{\n  uint8_t c = *s;\n\n  if (c < 0x80)\n    {\n      *puc = c;\n      return 1;\n    }\n  else if (c >= 0xc2)\n    {\n      if (c < 0xe0)\n        {\n          if (n >= 2)\n            {\n              if ((s[1] ^ 0x80) < 0x40)\n                {\n                  *puc = ((unsigned int) (c & 0x1f) << 6)\n                         | (unsigned int) (s[1] ^ 0x80);\n                  return 2;\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              return 1;\n            }\n        }\n      else if (c < 0xf0)\n        {\n          if (n >= 3)\n            {\n              if ((s[1] ^ 0x80) < 0x40)\n                {\n                  if ((s[2] ^ 0x80) < 0x40)\n                    {\n                      if ((c >= 0xe1 || s[1] >= 0xa0)\n                          && (c != 0xed || s[1] < 0xa0))\n                        {\n                          *puc = ((unsigned int) (c & 0x0f) << 12)\n                                 | ((unsigned int) (s[1] ^ 0x80) << 6)\n                                 | (unsigned int) (s[2] ^ 0x80);\n                          return 3;\n                        }\n                      /* invalid multibyte character */\n                      *puc = 0xfffd;\n                      return 3;\n                    }\n                  /* invalid multibyte character */\n                  *puc = 0xfffd;\n                  return 2;\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              if (n == 1 || (s[1] ^ 0x80) >= 0x40)\n                return 1;\n              else\n                return 2;\n            }\n        }\n      else if (c < 0xf8)\n        {\n          if (n >= 4)\n            {\n              if ((s[1] ^ 0x80) < 0x40)\n                {\n                  if ((s[2] ^ 0x80) < 0x40)\n                    {\n                      if ((s[3] ^ 0x80) < 0x40)\n                        {\n                          if ((c >= 0xf1 || s[1] >= 0x90)\n                              && (c < 0xf4 || (c == 0xf4 && s[1] < 0x90))\n                             )\n                            {\n                              *puc = ((unsigned int) (c & 0x07) << 18)\n                                     | ((unsigned int) (s[1] ^ 0x80) << 12)\n                                     | ((unsigned int) (s[2] ^ 0x80) << 6)\n                                     | (unsigned int) (s[3] ^ 0x80);\n                              return 4;\n                            }\n                          /* invalid multibyte character */\n                          *puc = 0xfffd;\n                          return 4;\n                        }\n                      /* invalid multibyte character */\n                      *puc = 0xfffd;\n                      return 3;\n                    }\n                  /* invalid multibyte character */\n                  *puc = 0xfffd;\n                  return 2;\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              if (n == 1 || (s[1] ^ 0x80) >= 0x40)\n                return 1;\n              else if (n == 2 || (s[2] ^ 0x80) >= 0x40)\n                return 2;\n              else\n                return 3;\n            }\n        }\n    }\n  /* invalid multibyte character */\n  *puc = 0xfffd;\n  return 1;\n}",
      "lines": 118,
      "depth": 31,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-mbtouc.c": {
    "u8_mbtouc": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "int\nu8_mbtouc (ucs4_t *puc, const uint8_t *s, size_t n)\n{\n  uint8_t c = *s;\n\n  if (c < 0x80)\n    {\n      *puc = c;\n      return 1;\n    }\n  else if (c >= 0xc2)\n    {\n      if (c < 0xe0)\n        {\n          if (n >= 2)\n            {\n              if ((s[1] ^ 0x80) < 0x40)\n                {\n                  *puc = ((unsigned int) (c & 0x1f) << 6)\n                         | (unsigned int) (s[1] ^ 0x80);\n                  return 2;\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              return 1;\n            }\n        }\n      else if (c < 0xf0)\n        {\n          if (n >= 3)\n            {\n              if ((s[1] ^ 0x80) < 0x40)\n                {\n                  if ((s[2] ^ 0x80) < 0x40)\n                    {\n                      if ((c >= 0xe1 || s[1] >= 0xa0)\n                          && (c != 0xed || s[1] < 0xa0))\n                        {\n                          *puc = ((unsigned int) (c & 0x0f) << 12)\n                                 | ((unsigned int) (s[1] ^ 0x80) << 6)\n                                 | (unsigned int) (s[2] ^ 0x80);\n                          return 3;\n                        }\n                      /* invalid multibyte character */\n                      *puc = 0xfffd;\n                      return 3;\n                    }\n                  /* invalid multibyte character */\n                  *puc = 0xfffd;\n                  return 2;\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              if (n == 1 || (s[1] ^ 0x80) >= 0x40)\n                return 1;\n              else\n                return 2;\n            }\n        }\n      else if (c < 0xf8)\n        {\n          if (n >= 4)\n            {\n              if ((s[1] ^ 0x80) < 0x40)\n                {\n                  if ((s[2] ^ 0x80) < 0x40)\n                    {\n                      if ((s[3] ^ 0x80) < 0x40)\n                        {\n                          if ((c >= 0xf1 || s[1] >= 0x90)\n                              && (c < 0xf4 || (c == 0xf4 && s[1] < 0x90)))\n                            {\n                              *puc = ((unsigned int) (c & 0x07) << 18)\n                                     | ((unsigned int) (s[1] ^ 0x80) << 12)\n                                     | ((unsigned int) (s[2] ^ 0x80) << 6)\n                                     | (unsigned int) (s[3] ^ 0x80);\n                              return 4;\n                            }\n                          /* invalid multibyte character */\n                          *puc = 0xfffd;\n                          return 4;\n                        }\n                      /* invalid multibyte character */\n                      *puc = 0xfffd;\n                      return 3;\n                    }\n                  /* invalid multibyte character */\n                  *puc = 0xfffd;\n                  return 2;\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              if (n == 1 || (s[1] ^ 0x80) >= 0x40)\n                return 1;\n              else if (n == 2 || (s[2] ^ 0x80) >= 0x40)\n                return 2;\n              else\n                return 3;\n            }\n        }\n    }\n  /* invalid multibyte character */\n  *puc = 0xfffd;\n  return 1;\n}",
      "lines": 117,
      "depth": 31,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-mbtoucr.c": {
    "u8_mbtoucr": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "int\nu8_mbtoucr (ucs4_t *puc, const uint8_t *s, size_t n)\n{\n  uint8_t c = *s;\n\n  if (c < 0x80)\n    {\n      *puc = c;\n      return 1;\n    }\n  else if (c >= 0xc2)\n    {\n      if (c < 0xe0)\n        {\n          if (n >= 2)\n            {\n              if ((s[1] ^ 0x80) < 0x40)\n                {\n                  *puc = ((unsigned int) (c & 0x1f) << 6)\n                         | (unsigned int) (s[1] ^ 0x80);\n                  return 2;\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              return -2;\n            }\n        }\n      else if (c < 0xf0)\n        {\n          if (n >= 2)\n            {\n              if ((s[1] ^ 0x80) < 0x40\n                  && (c >= 0xe1 || s[1] >= 0xa0)\n                  && (c != 0xed || s[1] < 0xa0))\n                {\n                  if (n >= 3)\n                    {\n                      if ((s[2] ^ 0x80) < 0x40)\n                        {\n                          *puc = ((unsigned int) (c & 0x0f) << 12)\n                                 | ((unsigned int) (s[1] ^ 0x80) << 6)\n                                 | (unsigned int) (s[2] ^ 0x80);\n                          return 3;\n                        }\n                      /* invalid multibyte character */\n                    }\n                  else\n                    {\n                      /* incomplete multibyte character */\n                      *puc = 0xfffd;\n                      return -2;\n                    }\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              return -2;\n            }\n        }\n      else if (c < 0xf8)\n        {\n          if (n >= 2)\n            {\n              if ((s[1] ^ 0x80) < 0x40\n                  && (c >= 0xf1 || s[1] >= 0x90)\n                  && (c < 0xf4 || (c == 0xf4 && s[1] < 0x90)))\n                {\n                  if (n >= 3)\n                    {\n                      if ((s[2] ^ 0x80) < 0x40)\n                        {\n                          if (n >= 4)\n                            {\n                              if ((s[3] ^ 0x80) < 0x40)\n                                {\n                                  *puc = ((unsigned int) (c & 0x07) << 18)\n                                         | ((unsigned int) (s[1] ^ 0x80) << 12)\n                                         | ((unsigned int) (s[2] ^ 0x80) << 6)\n                                         | (unsigned int) (s[3] ^ 0x80);\n                                  return 4;\n                                }\n                              /* invalid multibyte character */\n                            }\n                          else\n                            {\n                              /* incomplete multibyte character */\n                              *puc = 0xfffd;\n                              return -2;\n                            }\n                        }\n                      /* invalid multibyte character */\n                    }\n                  else\n                    {\n                      /* incomplete multibyte character */\n                      *puc = 0xfffd;\n                      return -2;\n                    }\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              return -2;\n            }\n        }\n    }\n  /* invalid multibyte character */\n  *puc = 0xfffd;\n  return -1;\n}",
      "lines": 120,
      "depth": 33,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-move.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u8-next.c": {
    "u8_next": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "const uint8_t *\nu8_next (ucs4_t *puc, const uint8_t *s)\n{\n  int count;\n\n  count = u8_strmbtouc (puc, s);\n  if (count > 0)\n    return s + count;\n  else\n    {\n      if (count < 0)\n        *puc = 0xfffd;\n      return NULL;\n    }\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "const",
        "const",
        "uint8_t",
        "*\nu8_next (ucs4_t *puc, const uint8_t *s)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-prev.c": {
    "u8_prev": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "const uint8_t *\nu8_prev (ucs4_t *puc, const uint8_t *s, const uint8_t *start)\n{\n  /* Keep in sync with unistr.h and u8-mbtouc-aux.c.  */\n  if (s != start)\n    {\n      uint8_t c_1 = s[-1];\n\n      if (c_1 < 0x80)\n        {\n          *puc = c_1;\n          return s - 1;\n        }\n      if ((c_1 ^ 0x80) < 0x40)\n        if (s - 1 != start)\n          {\n            uint8_t c_2 = s[-2];\n\n            if (c_2 >= 0xc2 && c_2 < 0xe0)\n              {\n                *puc = ((unsigned int) (c_2 & 0x1f) << 6)\n                       | (unsigned int) (c_1 ^ 0x80);\n                return s - 2;\n              }\n            if ((c_2 ^ 0x80) < 0x40)\n              if (s - 2 != start)\n                {\n                  uint8_t c_3 = s[-3];\n\n                  if (c_3 >= 0xe0 && c_3 < 0xf0\n                      && (c_3 >= 0xe1 || c_2 >= 0xa0)\n                      && (c_3 != 0xed || c_2 < 0xa0))\n                    {\n                      *puc = ((unsigned int) (c_3 & 0x0f) << 12)\n                             | ((unsigned int) (c_2 ^ 0x80) << 6)\n                             | (unsigned int) (c_1 ^ 0x80);\n                      return s - 3;\n                    }\n                  if ((c_3 ^ 0x80) < 0x40)\n                    if (s - 3 != start)\n                      {\n                        uint8_t c_4 = s[-4];\n\n                        if (c_4 >= 0xf0 && c_4 < 0xf8\n                            && (c_4 >= 0xf1 || c_3 >= 0x90)\n                            && (c_4 < 0xf4 || (c_4 == 0xf4 && c_3 < 0x90)))\n                          {\n                            *puc = ((unsigned int) (c_4 & 0x07) << 18)\n                                   | ((unsigned int) (c_3 ^ 0x80) << 12)\n                                   | ((unsigned int) (c_2 ^ 0x80) << 6)\n                                   | (unsigned int) (c_1 ^ 0x80);\n                            return s - 4;\n                          }\n                      }\n                }\n          }\n    }\n  return NULL;\n}",
      "lines": 59,
      "depth": 26,
      "decorators": [
        "const",
        "const",
        "uint8_t",
        "*\nu8_prev (ucs4_t *puc, const uint8_t *s, const uint8_t *start)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-set.c": {
    "FUNC": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "UNIT *\nFUNC (UNIT *s, ucs4_t uc, size_t n)\n{\n  if (n > 0)\n    {\n      if (IS_SINGLE_UNIT (uc))\n        memset ((char *) s, uc, n);\n      else\n        {\n          errno = EILSEQ;\n          return NULL;\n        }\n    }\n  return s;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "UNIT",
        "*\nFUNC (UNIT *s, ucs4_t uc, size_t n)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-startswith.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u8-stpcpy.c": {
    "u8_stpcpy": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "uint8_t *\nu8_stpcpy (uint8_t *dest, const uint8_t *src)\n{\n  return (uint8_t *) stpcpy ((char *) dest, (const char *) src);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "uint8_t",
        "*\nu8_stpcpy (uint8_t *dest, const uint8_t *src)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-stpncpy.c": {
    "u8_stpncpy": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "uint8_t *\nu8_stpncpy (uint8_t *dest, const uint8_t *src, size_t n)\n{\n  return (uint8_t *) stpncpy ((char *) dest, (const char *) src, n);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "uint8_t",
        "*\nu8_stpncpy (uint8_t *dest, const uint8_t *src, size_t n)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-strcat.c": {
    "u8_strcat": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "uint8_t *\nu8_strcat (uint8_t *dest, const uint8_t *src)\n{\n  return (uint8_t *) strcat ((char *) dest, (const char *) src);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "uint8_t",
        "*\nu8_strcat (uint8_t *dest, const uint8_t *src)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-strchr.c": {
    "u8_strchr": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        248,
        1
      ],
      "content": "uint8_t *\nu8_strchr (const uint8_t *s, ucs4_t uc)\n{\n  uint8_t c[6];\n\n  if (uc < 0x80)\n    {\n      uint8_t c0 = uc;\n\n      if (false)\n        {\n          /* Unoptimized code.  */\n          for (;;)\n            {\n              uint8_t s0 = *s;\n              if (s0 == c0)\n                return (uint8_t *) s;\n              s++;\n              if (s0 == 0)\n                break;\n            }\n        }\n      else\n        {\n          /* Optimized code.\n             strchr() is often so well optimized, that it's worth the\n             added function call.  */\n          return (uint8_t *) strchr ((const char *) s, c0);\n        }\n    }\n  else\n      /* Loops equivalent to strstr, optimized for a specific length (2, 3, 4)\n         of the needle.  We use an algorithm similar to Boyer-Moore which\n         is documented in lib/unistr/u8-chr.c.  There is additional\n         complication because we need to check after every byte for\n         a NUL byte, but the idea is the same. */\n    switch (u8_uctomb_aux (c, uc, 6))\n      {\n      case 2:\n        if (*s == 0 || s[1] == 0)\n          break;\n        {\n          uint8_t c0 = c[0];\n          uint8_t c1 = c[1];\n          /* Search for { c0, c1 }.  */\n          uint8_t s1 = s[1];\n\n          for (;;)\n            {\n              /* Here s[0] != 0, s[1] != 0.\n                 Test whether s[0..1] == { c0, c1 }.  */\n              if (s1 == c1)\n                {\n                  if (*s == c0)\n                    return (uint8_t *) s;\n                  else\n                    /* Skip the search at s + 1, because s[1] = c1 < c0.  */\n                    goto case2_skip2;\n                }\n              else\n                {\n                  if (s1 == c0)\n                    goto case2_skip1;\n                  else\n                    /* Skip the search at s + 1, because s[1] != c0.  */\n                    goto case2_skip2;\n                }\n             case2_skip2:\n              s++;\n              s1 = s[1];\n              if (s[1] == 0)\n                break;\n             case2_skip1:\n              s++;\n              s1 = s[1];\n              if (s[1] == 0)\n                break;\n            }\n        }\n        break;\n\n      case 3:\n        if (*s == 0 || s[1] == 0 || s[2] == 0)\n          break;\n        {\n          uint8_t c0 = c[0];\n          uint8_t c1 = c[1];\n          uint8_t c2 = c[2];\n          /* Search for { c0, c1, c2 }.  */\n          uint8_t s2 = s[2];\n\n          for (;;)\n            {\n              /* Here s[0] != 0, s[1] != 0, s[2] != 0.\n                 Test whether s[0..2] == { c0, c1, c2 }.  */\n              if (s2 == c2)\n                {\n                  if (s[1] == c1 && *s == c0)\n                    return (uint8_t *) s;\n                  else\n                    /* If c2 != c1:\n                         Skip the search at s + 1, because s[2] == c2 != c1.\n                       Skip the search at s + 2, because s[2] == c2 < c0.  */\n                    if (c2 == c1)\n                      goto case3_skip1;\n                    else\n                      goto case3_skip3;\n                }\n              else\n                {\n                  if (s2 == c1)\n                    goto case3_skip1;\n                  else if (s2 == c0)\n                    /* Skip the search at s + 1, because s[2] != c1.  */\n                    goto case3_skip2;\n                  else\n                    /* Skip the search at s + 1, because s[2] != c1.\n                       Skip the search at s + 2, because s[2] != c0.  */\n                    goto case3_skip3;\n                }\n             case3_skip3:\n              s++;\n              s2 = s[2];\n              if (s[2] == 0)\n                break;\n             case3_skip2:\n              s++;\n              s2 = s[2];\n              if (s[2] == 0)\n                break;\n             case3_skip1:\n              s++;\n              s2 = s[2];\n              if (s[2] == 0)\n                break;\n            }\n        }\n        break;\n\n      case 4:\n        if (*s == 0 || s[1] == 0 || s[2] == 0 || s[3] == 0)\n          break;\n        {\n          uint8_t c0 = c[0];\n          uint8_t c1 = c[1];\n          uint8_t c2 = c[2];\n          uint8_t c3 = c[3];\n          /* Search for { c0, c1, c2, c3 }.  */\n          uint8_t s3 = s[3];\n\n          for (;;)\n            {\n              /* Here s[0] != 0, s[1] != 0, s[2] != 0, s[3] != 0.\n                 Test whether s[0..3] == { c0, c1, c2, c3 }.  */\n              if (s3 == c3)\n                {\n                  if (s[2] == c2 && s[1] == c1 && *s == c0)\n                    return (uint8_t *) s;\n                  else\n                    /* If c3 != c2:\n                         Skip the search at s + 1, because s[3] == c3 != c2.\n                       If c3 != c1:\n                         Skip the search at s + 2, because s[3] == c3 != c1.\n                       Skip the search at s + 3, because s[3] == c3 < c0.  */\n                    if (c3 == c2)\n                      goto case4_skip1;\n                    else if (c3 == c1)\n                      goto case4_skip2;\n                    else\n                      goto case4_skip4;\n                }\n              else\n                {\n                  if (s3 == c2)\n                    goto case4_skip1;\n                  else if (s3 == c1)\n                    /* Skip the search at s + 1, because s[3] != c2.  */\n                    goto case4_skip2;\n                  else if (s3 == c0)\n                    /* Skip the search at s + 1, because s[3] != c2.\n                       Skip the search at s + 2, because s[3] != c1.  */\n                    goto case4_skip3;\n                  else\n                    /* Skip the search at s + 1, because s[3] != c2.\n                       Skip the search at s + 2, because s[3] != c1.\n                       Skip the search at s + 3, because s[3] != c0.  */\n                    goto case4_skip4;\n                }\n             case4_skip4:\n              s++;\n              s3 = s[3];\n              if (s[3] == 0)\n                break;\n             case4_skip3:\n              s++;\n              s3 = s[3];\n              if (s[3] == 0)\n                break;\n             case4_skip2:\n              s++;\n              s3 = s[3];\n              if (s[3] == 0)\n                break;\n             case4_skip1:\n              s++;\n              s3 = s[3];\n              if (s[3] == 0)\n                break;\n            }\n        }\n        break;\n      }\n\n  return NULL;\n}",
      "lines": 215,
      "depth": 18,
      "decorators": [
        "uint8_t",
        "*\nu8_strchr (const uint8_t *s, ucs4_t uc)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-strcmp.c": {
    "u8_strcmp": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nu8_strcmp (const uint8_t *s1, const uint8_t *s2)\n{\n  /* Use the fact that the UTF-8 encoding preserves lexicographic order.  */\n  return strcmp ((const char *) s1, (const char *) s2);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-strcoll.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u8-strcpy.c": {
    "u8_strcpy": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "uint8_t *\nu8_strcpy (uint8_t *dest, const uint8_t *src)\n{\n  return (uint8_t *) strcpy ((char *) dest, (const char *) src);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "uint8_t",
        "*\nu8_strcpy (uint8_t *dest, const uint8_t *src)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-strcspn.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u8-strdup.c": {
    "u8_strdup": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "uint8_t *\nu8_strdup (const uint8_t *s)\n{\n  return (uint8_t *) strdup ((const char *) s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "uint8_t",
        "*\nu8_strdup (const uint8_t *s)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-strlen.c": {
    "u8_strlen": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "size_t\nu8_strlen (const uint8_t *s)\n{\n  return strlen ((const char *) s);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "size_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-strmblen.c": {
    "u8_strmblen": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "int\nu8_strmblen (const uint8_t *s)\n{\n  /* Keep in sync with unistr.h and u8-mbtouc-aux.c.  */\n  uint8_t c = *s;\n\n  if (c < 0x80)\n    return (c != 0 ? 1 : 0);\n  if (c >= 0xc2)\n    {\n      if (c < 0xe0)\n        {\n          if ((s[1] ^ 0x80) < 0x40)\n            return 2;\n        }\n      else if (c < 0xf0)\n        {\n          if ((s[1] ^ 0x80) < 0x40 && (s[2] ^ 0x80) < 0x40\n              && (c >= 0xe1 || s[1] >= 0xa0)\n              && (c != 0xed || s[1] < 0xa0))\n            return 3;\n        }\n      else if (c < 0xf8)\n        {\n          if ((s[1] ^ 0x80) < 0x40 && (s[2] ^ 0x80) < 0x40\n              && (s[3] ^ 0x80) < 0x40\n              && (c >= 0xf1 || s[1] >= 0x90)\n              && (c < 0xf4 || (c == 0xf4 && s[1] < 0x90)))\n            return 4;\n        }\n    }\n  /* invalid or incomplete multibyte character */\n  return -1;\n}",
      "lines": 34,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-strmbtouc.c": {
    "u8_strmbtouc": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "int\nu8_strmbtouc (ucs4_t *puc, const uint8_t *s)\n{\n  /* Keep in sync with unistr.h and u8-mbtouc-aux.c.  */\n  uint8_t c = *s;\n\n  if (c < 0x80)\n    {\n      *puc = c;\n      return (c != 0 ? 1 : 0);\n    }\n  if (c >= 0xc2)\n    {\n      if (c < 0xe0)\n        {\n          if ((s[1] ^ 0x80) < 0x40)\n            {\n              *puc = ((unsigned int) (c & 0x1f) << 6)\n                     | (unsigned int) (s[1] ^ 0x80);\n              return 2;\n            }\n        }\n      else if (c < 0xf0)\n        {\n          if ((s[1] ^ 0x80) < 0x40 && (s[2] ^ 0x80) < 0x40\n              && (c >= 0xe1 || s[1] >= 0xa0)\n              && (c != 0xed || s[1] < 0xa0))\n            {\n              *puc = ((unsigned int) (c & 0x0f) << 12)\n                     | ((unsigned int) (s[1] ^ 0x80) << 6)\n                     | (unsigned int) (s[2] ^ 0x80);\n              return 3;\n            }\n        }\n      else if (c < 0xf8)\n        {\n          if ((s[1] ^ 0x80) < 0x40 && (s[2] ^ 0x80) < 0x40\n              && (s[3] ^ 0x80) < 0x40\n              && (c >= 0xf1 || s[1] >= 0x90)\n              && (c < 0xf4 || (c == 0xf4 && s[1] < 0x90)))\n            {\n              *puc = ((unsigned int) (c & 0x07) << 18)\n                     | ((unsigned int) (s[1] ^ 0x80) << 12)\n                     | ((unsigned int) (s[2] ^ 0x80) << 6)\n                     | (unsigned int) (s[3] ^ 0x80);\n              return 4;\n            }\n        }\n    }\n  /* invalid or incomplete multibyte character */\n  return -1;\n}",
      "lines": 52,
      "depth": 22,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-strncat.c": {
    "u8_strncat": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "uint8_t *\nu8_strncat (uint8_t *dest, const uint8_t *src, size_t n)\n{\n  return (uint8_t *) strncat ((char *) dest, (const char *) src, n);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "uint8_t",
        "*\nu8_strncat (uint8_t *dest, const uint8_t *src, size_t n)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-strncmp.c": {
    "u8_strncmp": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nu8_strncmp (const uint8_t *s1, const uint8_t *s2, size_t n)\n{\n  /* Use the fact that the UTF-8 encoding preserves lexicographic order.  */\n  return strncmp ((const char *) s1, (const char *) s2, n);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-strncpy.c": {
    "u8_strncpy": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "uint8_t *\nu8_strncpy (uint8_t *dest, const uint8_t *src, size_t n)\n{\n  return (uint8_t *) strncpy ((char *) dest, (const char *) src, n);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "uint8_t",
        "*\nu8_strncpy (uint8_t *dest, const uint8_t *src, size_t n)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-strnlen.c": {
    "u8_strnlen": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "size_t\nu8_strnlen (const uint8_t *s, size_t maxlen)\n{\n  return strnlen ((const char *) s, maxlen);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "size_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-strpbrk.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u8-strrchr.c": {
    "u8_strrchr": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "uint8_t *\nu8_strrchr (const uint8_t *s, ucs4_t uc)\n{\n  /* Calling u8_strlen and then searching from the other end would cause more\n     memory accesses. Avoid that, at the cost of a few more comparisons.  */\n  uint8_t *result = NULL;\n  uint8_t c[6];\n\n  if (uc < 0x80)\n    {\n      uint8_t c0 = uc;\n\n      for (;; s++)\n        {\n          if (*s == c0)\n            result = (uint8_t *) s;\n          if (*s == 0)\n            break;\n        }\n    }\n  else\n    switch (u8_uctomb_aux (c, uc, 6))\n      {\n      case 2:\n        if (*s)\n          {\n            uint8_t c0 = c[0];\n            uint8_t c1 = c[1];\n\n            /* FIXME: Maybe walking the string via u8_mblen is a win?  */\n            for (;; s++)\n              {\n                if (s[1] == 0)\n                  break;\n                if (*s == c0 && s[1] == c1)\n                  result = (uint8_t *) s;\n              }\n          }\n        break;\n\n      case 3:\n        if (*s && s[1])\n          {\n            uint8_t c0 = c[0];\n            uint8_t c1 = c[1];\n            uint8_t c2 = c[2];\n\n            /* FIXME: Maybe walking the string via u8_mblen is a win?  */\n            for (;; s++)\n              {\n                if (s[2] == 0)\n                  break;\n                if (*s == c0 && s[1] == c1 && s[2] == c2)\n                  result = (uint8_t *) s;\n              }\n          }\n        break;\n\n      case 4:\n        if (*s && s[1] && s[2])\n          {\n            uint8_t c0 = c[0];\n            uint8_t c1 = c[1];\n            uint8_t c2 = c[2];\n            uint8_t c3 = c[3];\n\n            /* FIXME: Maybe walking the string via u8_mblen is a win?  */\n            for (;; s++)\n              {\n                if (s[3] == 0)\n                  break;\n                if (*s == c0 && s[1] == c1 && s[2] == c2 && s[3] == c3)\n                  result = (uint8_t *) s;\n              }\n          }\n        break;\n      }\n  return result;\n}",
      "lines": 79,
      "depth": 18,
      "decorators": [
        "uint8_t",
        "*\nu8_strrchr (const uint8_t *s, ucs4_t uc)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-strspn.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u8-strstr.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u8-strtok.c": {},
  "libunistring/libunistring-0.9.10/lib/unistr/u8-to-u16.c": {
    "FUNC": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "DST_UNIT *\nFUNC (const SRC_UNIT *s, size_t n, DST_UNIT *resultbuf, size_t *lengthp)\n{\n  const SRC_UNIT *s_end = s + n;\n  /* Output string accumulator.  */\n  DST_UNIT *result;\n  size_t allocated;\n  size_t length;\n\n  if (resultbuf != NULL)\n    {\n      result = resultbuf;\n      allocated = *lengthp;\n    }\n  else\n    {\n      result = NULL;\n      allocated = 0;\n    }\n  length = 0;\n  /* Invariants:\n     result is either == resultbuf or == NULL or malloc-allocated.\n     If length > 0, then result != NULL.  */\n\n  while (s < s_end)\n    {\n      ucs4_t uc;\n      int count;\n\n      /* Fetch a Unicode character from the input string.  */\n      count = u8_mbtoucr (&uc, s, s_end - s);\n      if (count < 0)\n        {\n          if (!(result == resultbuf || result == NULL))\n            free (result);\n          errno = EILSEQ;\n          return NULL;\n        }\n      s += count;\n\n      /* Store it in the output string.  */\n      count = u16_uctomb (result + length, uc, allocated - length);\n      if (count == -1)\n        {\n          if (!(result == resultbuf || result == NULL))\n            free (result);\n          errno = EILSEQ;\n          return NULL;\n        }\n      if (count == -2)\n        {\n          DST_UNIT *memory;\n\n          allocated = (allocated > 0 ? 2 * allocated : 12);\n          if (length + 2 > allocated)\n            allocated = length + 2;\n          if (result == resultbuf || result == NULL)\n            memory = (DST_UNIT *) malloc (allocated * sizeof (DST_UNIT));\n          else\n            memory =\n              (DST_UNIT *) realloc (result, allocated * sizeof (DST_UNIT));\n\n          if (memory == NULL)\n            {\n              if (!(result == resultbuf || result == NULL))\n                free (result);\n              errno = ENOMEM;\n              return NULL;\n            }\n          if (result == resultbuf && length > 0)\n            memcpy ((char *) memory, (char *) result,\n                    length * sizeof (DST_UNIT));\n          result = memory;\n          count = u16_uctomb (result + length, uc, allocated - length);\n          if (count < 0)\n            abort ();\n        }\n      length += count;\n    }\n\n  if (length == 0)\n    {\n      if (result == NULL)\n        {\n          /* Return a non-NULL value.  NULL means error.  */\n          result = (DST_UNIT *) malloc (1);\n          if (result == NULL)\n            {\n              errno = ENOMEM;\n              return NULL;\n            }\n        }\n    }\n  else if (result != resultbuf && length < allocated)\n    {\n      /* Shrink the allocated memory if possible.  */\n      DST_UNIT *memory;\n\n      memory = (DST_UNIT *) realloc (result, length * sizeof (DST_UNIT));\n      if (memory != NULL)\n        result = memory;\n    }\n\n  *lengthp = length;\n  return result;\n}",
      "lines": 106,
      "depth": 16,
      "decorators": [
        "DST_UNIT",
        "*\nFUNC (const SRC_UNIT *s, size_t n, DST_UNIT *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-to-u32.c": {
    "FUNC": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "DST_UNIT *\nFUNC (const SRC_UNIT *s, size_t n, DST_UNIT *resultbuf, size_t *lengthp)\n{\n  const SRC_UNIT *s_end = s + n;\n  /* Output string accumulator.  */\n  DST_UNIT *result;\n  size_t allocated;\n  size_t length;\n\n  if (resultbuf != NULL)\n    {\n      result = resultbuf;\n      allocated = *lengthp;\n    }\n  else\n    {\n      result = NULL;\n      allocated = 0;\n    }\n  length = 0;\n  /* Invariants:\n     result is either == resultbuf or == NULL or malloc-allocated.\n     If length > 0, then result != NULL.  */\n\n  while (s < s_end)\n    {\n      ucs4_t uc;\n      int count;\n\n      /* Fetch a Unicode character from the input string.  */\n      count = u8_mbtoucr (&uc, s, s_end - s);\n      if (count < 0)\n        {\n          if (!(result == resultbuf || result == NULL))\n            free (result);\n          errno = EILSEQ;\n          return NULL;\n        }\n      s += count;\n\n      /* Store it in the output string.  */\n      if (length + 1 > allocated)\n        {\n          DST_UNIT *memory;\n\n          allocated = (allocated > 0 ? 2 * allocated : 12);\n          if (length + 1 > allocated)\n            allocated = length + 1;\n          if (result == resultbuf || result == NULL)\n            memory = (DST_UNIT *) malloc (allocated * sizeof (DST_UNIT));\n          else\n            memory =\n              (DST_UNIT *) realloc (result, allocated * sizeof (DST_UNIT));\n\n          if (memory == NULL)\n            {\n              if (!(result == resultbuf || result == NULL))\n                free (result);\n              errno = ENOMEM;\n              return NULL;\n            }\n          if (result == resultbuf && length > 0)\n            memcpy ((char *) memory, (char *) result,\n                    length * sizeof (DST_UNIT));\n          result = memory;\n        }\n      result[length++] = uc;\n    }\n\n  if (length == 0)\n    {\n      if (result == NULL)\n        {\n          /* Return a non-NULL value.  NULL means error.  */\n          result = (DST_UNIT *) malloc (1);\n          if (result == NULL)\n            {\n              errno = ENOMEM;\n              return NULL;\n            }\n        }\n    }\n  else if (result != resultbuf && length < allocated)\n    {\n      /* Shrink the allocated memory if possible.  */\n      DST_UNIT *memory;\n\n      memory = (DST_UNIT *) realloc (result, length * sizeof (DST_UNIT));\n      if (memory != NULL)\n        result = memory;\n    }\n\n  *lengthp = length;\n  return result;\n}",
      "lines": 95,
      "depth": 16,
      "decorators": [
        "DST_UNIT",
        "*\nFUNC (const SRC_UNIT *s, size_t n, DST_UNIT *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-uctomb-aux.c": {
    "u8_uctomb_aux": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "int\nu8_uctomb_aux (uint8_t *s, ucs4_t uc, int n)\n{\n  int count;\n\n  if (uc < 0x80)\n    /* The case n >= 1 is already handled by the caller.  */\n    return -2;\n  else if (uc < 0x800)\n    count = 2;\n  else if (uc < 0x10000)\n    {\n      if (uc < 0xd800 || uc >= 0xe000)\n        count = 3;\n      else\n        return -1;\n    }\n  else if (uc < 0x110000)\n    count = 4;\n  else\n    return -1;\n\n  if (n < count)\n    return -2;\n\n  switch (count) /* note: code falls through cases! */\n    {\n    case 4: s[3] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0x10000;\n      FALLTHROUGH;\n    case 3: s[2] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0x800;\n      FALLTHROUGH;\n    case 2: s[1] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0xc0;\n  /*case 1:*/ s[0] = uc;\n    }\n  return count;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistr/u8-uctomb.c": {
    "u8_uctomb": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "int\nu8_uctomb (uint8_t *s, ucs4_t uc, int n)\n{\n  if (uc < 0x80)\n    {\n      if (n > 0)\n        {\n          s[0] = uc;\n          return 1;\n        }\n      /* else return -2, below.  */\n    }\n  else\n    {\n      int count;\n\n      if (uc < 0x800)\n        count = 2;\n      else if (uc < 0x10000)\n        {\n          if (uc < 0xd800 || uc >= 0xe000)\n            count = 3;\n          else\n            return -1;\n        }\n      else if (uc < 0x110000)\n        count = 4;\n      else\n        return -1;\n\n      if (n >= count)\n        {\n          switch (count) /* note: code falls through cases! */\n            {\n            case 4: s[3] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0x10000;\n            case 3: s[2] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0x800;\n            case 2: s[1] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0xc0;\n          /*case 1:*/ s[0] = uc;\n            }\n          return count;\n        }\n    }\n  return -2;\n}",
      "lines": 44,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/unistring/cdefs.in.h": {},
  "libunistring/libunistring-0.9.10/lib/unistring/inline.h": {},
  "libunistring/libunistring-0.9.10/lib/unistring/version.in.h": {},
  "libunistring/libunistring-0.9.10/lib/unistring/woe32dll.in.h": {},
  "libunistring/libunistring-0.9.10/lib/uniwbrk/u-wordbreaks.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "void\nFUNC (const UNIT *s, size_t n, char *p)\n{\n  if (n > 0)\n    {\n      const UNIT *s_end = s + n;\n\n      /* Word break property of the last character.\n         -1 at the very beginning of the string.  */\n      int last_char_prop = -1;\n\n      /* Format and Extend characters are ignored; this means, the mostly used\n         unit is the complex character (= character with subsequent ignored\n         characters).\n         Word break property of the last complex character.\n         -1 at the very beginning of the string.  */\n      int last_compchar_prop = -1;\n      char *last_compchar_ptr = NULL;\n\n      /* For recognizing rules involving 3 complex characters:\n         Word break property of the second-to-last complex character.\n         -1 at the very beginning of the string.  */\n      int secondlast_compchar_prop = -1;\n\n      size_t ri_count = 0;\n\n      /* Don't break inside multibyte characters.  */\n      memset (p, 0, n);\n\n      while (s < s_end)\n        {\n          ucs4_t uc;\n          int count = U_MBTOUC_UNSAFE (&uc, s, s_end - s);\n          int prop = uc_wordbreak_property (uc);\n\n          /* No break at the start of the string.  */\n          if (last_char_prop >= 0)\n            {\n              /* No break between CR and LF (WB3).  */\n              if (last_char_prop == WBP_CR && prop == WBP_LF)\n                /* *p = 0 */;\n              /* Break before and after newlines (WB3a, WB3b).  */\n              else if ((last_char_prop == WBP_CR\n                        || last_char_prop == WBP_LF\n                        || last_char_prop == WBP_NEWLINE)\n                       || (prop == WBP_CR\n                           || prop == WBP_LF\n                           || prop == WBP_NEWLINE))\n                *p = 1;\n              /* No break within emoji zwj sequence (WB3c).  */\n              else if (last_char_prop == WBP_ZWJ &&\n                       (prop == WBP_GAZ || prop == WBP_EBG))\n                /* *p = 0 */;\n              /* Ignore Format and Extend characters.  */\n              else if (!(prop == WBP_EXTEND || prop == WBP_FORMAT || prop == WBP_ZWJ))\n                {\n                  /* No break in these situations (see UAX #29):\n\n                      secondlast          last             current\n\n    (ALetter | HL)   (MidLetter | MidNumLet | SQ) \u00c3\u0097 (ALetter | HL)      (WB7)\n    (ALetter | HL) \u00c3\u0097 (MidLetter | MidNumLet | SQ)   (ALetter | HL)      (WB6)\n                  Numeric   (MidNum | MidNumLet | SQ)    \u00c3\u0097 Numeric      (WB11)\n                  Numeric \u00c3\u0097 (MidNum | MidNumLet | SQ)      Numeric      (WB12)\n                                                        HL \u00c3\u0097 DQ HL      (WB7b)\n                                                        HL DQ \u00c3\u0097 HL      (WB7c)\n                                                ^ (RI RI)* RI \u00c3\u0097 RI      (WB15)\n                                            [^RI] (RI RI)* RI \u00c3\u0097 RI      (WB16)\n                   */\n                  /* No break across certain punctuation.  Also, disable word\n                     breaks that were recognized earlier (due to lookahead of\n                     only one complex character).  */\n                  if (((prop == WBP_ALETTER\n                        || prop == WBP_HL)\n                       && (last_compchar_prop == WBP_MIDLETTER\n                           || last_compchar_prop == WBP_MIDNUMLET\n                           || last_compchar_prop == WBP_SQ)\n                       && (secondlast_compchar_prop == WBP_ALETTER\n                           || secondlast_compchar_prop == WBP_HL))\n                      || (prop == WBP_NUMERIC\n                          && (last_compchar_prop == WBP_MIDNUM\n                              || last_compchar_prop == WBP_MIDNUMLET\n                              || last_compchar_prop == WBP_SQ)\n                          && secondlast_compchar_prop == WBP_NUMERIC)\n                      || (prop == WBP_HL\n                          && last_compchar_prop == WBP_DQ\n                          && secondlast_compchar_prop == WBP_HL))\n                    {\n                      *last_compchar_ptr = 0;\n                      /* *p = 0; */\n                    }\n                  /* Break before RI, if odd number of RI's are\n                     preceding (WB15, WB16).  */\n                  else if (last_compchar_prop == WBP_RI && prop == WBP_RI)\n                    {\n                      if (ri_count % 2 == 0)\n                        *p = 1;\n                      /* else *p = 0 */\n                    }\n                  /* Break after Format and Extend character.  */\n                  else if (last_compchar_prop == WBP_EXTEND\n                           || last_compchar_prop == WBP_FORMAT)\n                    *p = 1;\n                  else\n                    {\n                      int last_compchar_index =\n                        uniwbrk_prop_index[last_compchar_prop];\n                      int index = uniwbrk_prop_index[prop];\n\n                      /* Break between unknown pair (WB999).  */\n                      if (last_compchar_index < 0 || index < 0)\n                        *p = 1;\n                      /* Perform a single table lookup.  */\n                      else if (uniwbrk_table[last_compchar_index][index])\n                        *p = 1;\n                      /* else *p = 0; */\n                    }\n                }\n            }\n\n          last_char_prop = prop;\n\n          /* Ignore Format and Extend characters, except at the\n             start of the line.  */\n          if (last_compchar_prop < 0\n              || last_compchar_prop == WBP_CR\n              || last_compchar_prop == WBP_LF\n              || last_compchar_prop == WBP_NEWLINE\n              || !(prop == WBP_EXTEND || prop == WBP_FORMAT || prop == WBP_ZWJ))\n            {\n              secondlast_compchar_prop = last_compchar_prop;\n              last_compchar_prop = prop;\n              last_compchar_ptr = p;\n\n              if (prop == WBP_RI)\n                ri_count++;\n              else\n                ri_count = 0;\n            }\n\n          s += count;\n          p += count;\n        }\n    }\n}",
      "lines": 145,
      "depth": 25,
      "decorators": [
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uniwbrk/u16-wordbreaks.c": {},
  "libunistring/libunistring-0.9.10/lib/uniwbrk/u32-wordbreaks.c": {},
  "libunistring/libunistring-0.9.10/lib/uniwbrk/u8-wordbreaks.c": {
    "read_file": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "char *\nread_file (FILE *stream)\n{\n#define BUFSIZE 4096\n  char *buf = NULL;\n  int alloc = 0;\n  int size = 0;\n  int count;\n\n  while (! feof (stream))\n    {\n      if (size + BUFSIZE > alloc)\n        {\n          alloc = alloc + alloc / 2;\n          if (alloc < size + BUFSIZE)\n            alloc = size + BUFSIZE;\n          buf = realloc (buf, alloc);\n          if (buf == NULL)\n            {\n              fprintf (stderr, \"out of memory\\n\");\n              exit (1);\n            }\n        }\n      count = fread (buf + size, 1, BUFSIZE, stream);\n      if (count == 0)\n        {\n          if (ferror (stream))\n            {\n              perror (\"fread\");\n              exit (1);\n            }\n        }\n      else\n        size += count;\n    }\n  buf = realloc (buf, size + 1);\n  if (buf == NULL)\n    {\n      fprintf (stderr, \"out of memory\\n\");\n      exit (1);\n    }\n  buf[size] = '\\0';\n  return buf;\n#undef BUFSIZE\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "char",
        "*\nread_file (FILE *stream)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "int\nmain (int argc, char * argv[])\n{\n  if (argc == 1)\n    {\n      /* Display all the word breaks in the input string.  */\n      char *input = read_file (stdin);\n      int length = strlen (input);\n      char *breaks = malloc (length);\n      int i;\n\n      u8_wordbreaks ((uint8_t *) input, length, breaks);\n\n      for (i = 0; i < length; i++)\n        {\n          switch (breaks[i])\n            {\n            case 1:\n              /* U+2027 in UTF-8 encoding */\n              putc (0xe2, stdout); putc (0x80, stdout); putc (0xa7, stdout);\n              break;\n            case 0:\n              break;\n            default:\n              abort ();\n            }\n          putc (input[i], stdout);\n        }\n\n      free (breaks);\n\n      return 0;\n    }\n  else\n    return 1;\n}",
      "lines": 36,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uniwbrk/ulc-wordbreaks.c": {
    "ulc_wordbreaks": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "void\nulc_wordbreaks (const char *s, size_t n, char *p)\n{\n  if (n > 0)\n    {\n      const char *encoding = locale_charset ();\n\n      if (is_utf8_encoding (encoding))\n        u8_wordbreaks ((const uint8_t *) s, n, p);\n      else\n        {\n          /* Convert the string to UTF-8 and build a translation table\n             from offsets into s to offsets into the translated string.  */\n          size_t *offsets = (size_t *) malloc (n * sizeof (size_t));\n\n          if (offsets != NULL)\n            {\n              uint8_t *t;\n              size_t m;\n\n              t = u8_conv_from_encoding (encoding, iconveh_question_mark,\n                                         s, n, offsets, NULL, &m);\n              if (t != NULL)\n                {\n                  char *q = (char *) (m > 0 ? malloc (m) : NULL);\n\n                  if (m == 0 || q != NULL)\n                    {\n                      size_t i;\n\n                      /* Determine the word breaks of the UTF-8 string.  */\n                      u8_wordbreaks (t, m, q);\n\n                      /* Translate the result back to the original string.  */\n                      memset (p, 0, n);\n                      for (i = 0; i < n; i++)\n                        if (offsets[i] != (size_t)(-1))\n                          p[i] = q[offsets[i]];\n\n                      free (q);\n                      free (t);\n                      free (offsets);\n                      return;\n                    }\n                  free (t);\n                }\n              free (offsets);\n            }\n\n          /* Impossible to convert.  */\n#if C_CTYPE_ASCII\n          if (is_all_ascii (s, n))\n            {\n              /* ASCII is a subset of UTF-8.  */\n              u8_wordbreaks ((const uint8_t *) s, n, p);\n              return;\n            }\n#endif\n          /* We have a non-ASCII string and cannot convert it.\n             Don't produce any word breaks.  */\n          memset (p, 0, n);\n        }\n    }\n}",
      "lines": 64,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "read_file": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "char *\nread_file (FILE *stream)\n{\n#define BUFSIZE 4096\n  char *buf = NULL;\n  int alloc = 0;\n  int size = 0;\n  int count;\n\n  while (! feof (stream))\n    {\n      if (size + BUFSIZE > alloc)\n        {\n          alloc = alloc + alloc / 2;\n          if (alloc < size + BUFSIZE)\n            alloc = size + BUFSIZE;\n          buf = realloc (buf, alloc);\n          if (buf == NULL)\n            {\n              fprintf (stderr, \"out of memory\\n\");\n              exit (1);\n            }\n        }\n      count = fread (buf + size, 1, BUFSIZE, stream);\n      if (count == 0)\n        {\n          if (ferror (stream))\n            {\n              perror (\"fread\");\n              exit (1);\n            }\n        }\n      else\n        size += count;\n    }\n  buf = realloc (buf, size + 1);\n  if (buf == NULL)\n    {\n      fprintf (stderr, \"out of memory\\n\");\n      exit (1);\n    }\n  buf[size] = '\\0';\n  return buf;\n#undef BUFSIZE\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "char",
        "*\nread_file (FILE *stream)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "int\nmain (int argc, char * argv[])\n{\n  setlocale (LC_CTYPE, \"\");\n  if (argc == 1)\n    {\n      /* Display all the word breaks in the input string.  */\n      char *input = read_file (stdin);\n      int length = strlen (input);\n      char *breaks = malloc (length);\n      int i;\n\n      ulc_wordbreaks (input, length, breaks);\n\n      for (i = 0; i < length; i++)\n        {\n          switch (breaks[i])\n            {\n            case 1:\n              putc ('|', stdout);\n              break;\n            case 0:\n              break;\n            default:\n              abort ();\n            }\n          putc (input[i], stdout);\n        }\n\n      free (breaks);\n\n      return 0;\n    }\n  else\n    return 1;\n}",
      "lines": 36,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uniwbrk/wbrkprop.h": {},
  "libunistring/libunistring-0.9.10/lib/uniwbrk/wbrktable.c": {},
  "libunistring/libunistring-0.9.10/lib/uniwbrk/wbrktable.h": {},
  "libunistring/libunistring-0.9.10/lib/uniwbrk/wordbreak-property.c": {
    "uc_wordbreak_property": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "int\nuc_wordbreak_property (ucs4_t uc)\n{\n  unsigned int index1 = uc >> wbrkprop_header_0;\n  if (index1 < wbrkprop_header_1)\n    {\n      int lookup1 = uniwbrkprop.level1[index1];\n      if (lookup1 >= 0)\n        {\n          unsigned int index2 = (uc >> wbrkprop_header_2) & wbrkprop_header_3;\n          int lookup2 = uniwbrkprop.level2[lookup1 + index2];\n          if (lookup2 >= 0)\n            {\n              unsigned int index3 = uc & wbrkprop_header_4;\n              return uniwbrkprop.level3[lookup2 + index3];\n            }\n        }\n    }\n  return WBP_OTHER;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uniwidth/cjk.h": {
    "is_cjk_encoding": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "static int\nis_cjk_encoding (const char *encoding)\n{\n  if (0\n      /* Legacy Japanese encodings */\n      || STREQ_OPT (encoding, \"EUC-JP\", 'E', 'U', 'C', '-', 'J', 'P', 0, 0, 0)\n      /* Legacy Chinese encodings */\n      || STREQ_OPT (encoding, \"GB2312\", 'G', 'B', '2', '3', '1', '2', 0, 0, 0)\n      || STREQ_OPT (encoding, \"GBK\", 'G', 'B', 'K', 0, 0, 0, 0, 0, 0)\n      || STREQ_OPT (encoding, \"EUC-TW\", 'E', 'U', 'C', '-', 'T', 'W', 0, 0, 0)\n      || STREQ_OPT (encoding, \"BIG5\", 'B', 'I', 'G', '5', 0, 0, 0, 0, 0)\n      /* Legacy Korean encodings */\n      || STREQ_OPT (encoding, \"EUC-KR\", 'E', 'U', 'C', '-', 'K', 'R', 0, 0, 0)\n      || STREQ_OPT (encoding, \"CP949\", 'C', 'P', '9', '4', '9', 0, 0, 0, 0)\n      || STREQ_OPT (encoding, \"JOHAB\", 'J', 'O', 'H', 'A', 'B', 0, 0, 0, 0))\n    return 1;\n  return 0;\n}",
      "lines": 18,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uniwidth/u16-strwidth.c": {
    "u16_strwidth": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "int\nu16_strwidth (const uint16_t *s, const char *encoding)\n{\n  return u16_width (s, u16_strlen (s), encoding);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uniwidth/u16-width.c": {
    "u16_width": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nu16_width (const uint16_t *s, size_t n, const char *encoding)\n{\n  const uint16_t *s_end = s + n;\n  int width = 0;\n\n  while (s < s_end)\n    {\n      ucs4_t uc;\n      int w;\n\n      s += u16_mbtouc_unsafe (&uc, s, s_end - s);\n\n      if (uc == 0)\n        break; /* end of string reached */\n\n      w = uc_width (uc, encoding);\n      if (w >= 0) /* ignore control characters in the string */\n        width += w;\n    }\n\n  return width;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uniwidth/u32-strwidth.c": {
    "u32_strwidth": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "int\nu32_strwidth (const uint32_t *s, const char *encoding)\n{\n  return u32_width (s, u32_strlen (s), encoding);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uniwidth/u32-width.c": {
    "u32_width": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\nu32_width (const uint32_t *s, size_t n, const char *encoding)\n{\n  const uint32_t *s_end = s + n;\n  int width = 0;\n\n  while (s < s_end)\n    {\n      ucs4_t uc = *s++;\n      int w;\n\n      if (uc == 0)\n        break; /* end of string reached */\n\n      w = uc_width (uc, encoding);\n      if (w >= 0) /* ignore control characters in the string */\n        width += w;\n    }\n\n  return width;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uniwidth/u8-strwidth.c": {
    "u8_strwidth": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "int\nu8_strwidth (const uint8_t *s, const char *encoding)\n{\n  return u8_width (s, u8_strlen (s), encoding);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uniwidth/u8-width.c": {
    "u8_width": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nu8_width (const uint8_t *s, size_t n, const char *encoding)\n{\n  const uint8_t *s_end = s + n;\n  int width = 0;\n\n  while (s < s_end)\n    {\n      ucs4_t uc;\n      int w;\n\n      s += u8_mbtouc_unsafe (&uc, s, s_end - s);\n\n      if (uc == 0)\n        break; /* end of string reached */\n\n      w = uc_width (uc, encoding);\n      if (w >= 0) /* ignore control characters in the string */\n        width += w;\n    }\n\n  return width;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/lib/uniwidth/width.c": {
    "uc_width": {
      "start_point": [
        422,
        0
      ],
      "end_point": [
        476,
        1
      ],
      "content": "int\nuc_width (ucs4_t uc, const char *encoding)\n{\n  /* Test for non-spacing or control character.  */\n  if ((uc >> 9) < 248)\n    {\n      int ind = nonspacing_table_ind[uc >> 9];\n      if (ind >= 0)\n        if ((nonspacing_table_data[64*ind + ((uc >> 3) & 63)] >> (uc & 7)) & 1)\n          {\n            if (uc > 0 && uc < 0xa0)\n              return -1;\n            else\n              return 0;\n          }\n    }\n  else if ((uc >> 9) == (0xe0000 >> 9))\n    {\n      if (uc >= 0xe0100)\n        {\n          if (uc <= 0xe01ef)\n            return 0;\n        }\n      else\n        {\n          if (uc >= 0xe0020 ? uc <= 0xe007f : uc == 0xe0001)\n            return 0;\n        }\n    }\n  /* Test for double-width character.\n   * Generated from \"grep '^[^;]\\{4,5\\};[WF]' EastAsianWidth.txt\"\n   * and            \"grep '^[^;]\\{4,5\\};[^WF]' EastAsianWidth.txt\"\n   */\n  if (uc >= 0x1100\n      && ((uc < 0x1160) /* Hangul Jamo */\n          || (uc >= 0x2329 && uc < 0x232b) /* Angle Brackets */\n          || (uc >= 0x2e80 && uc < 0xa4d0  /* CJK ... Yi */\n              && !(uc == 0x303f) && !(uc >= 0x4dc0 && uc < 0x4e00))\n          || (uc >= 0xac00 && uc < 0xd7a4) /* Hangul Syllables */\n          || (uc >= 0xf900 && uc < 0xfb00) /* CJK Compatibility Ideographs */\n          || (uc >= 0xfe10 && uc < 0xfe20) /* Presentation Forms for Vertical */\n          || (uc >= 0xfe30 && uc < 0xfe70) /* CJK Compatibility Forms */\n          || (uc >= 0xff00 && uc < 0xff61) /* Fullwidth Forms */\n          || (uc >= 0xffe0 && uc < 0xffe7) /* Fullwidth Signs */\n          || (uc >= 0x20000 && uc <= 0x2ffff) /* Supplementary Ideographic Plane */\n          || (uc >= 0x30000 && uc <= 0x3ffff) /* Tertiary Ideographic Plane */\n     )   )\n    return 2;\n  /* In ancient CJK encodings, Cyrillic and most other characters are\n     double-width as well.  */\n  if (uc >= 0x00A1 && uc < 0xFF61 && uc != 0x20A9\n      && is_cjk_encoding (encoding))\n    return 2;\n  return 1;\n}",
      "lines": 55,
      "depth": 22,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/arg-nonnull.h": {},
  "libunistring/libunistring-0.9.10/tests/basename-lgpl.c": {
    "last_component": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "char *\nlast_component (char const *name)\n{\n  char const *base = name + FILE_SYSTEM_PREFIX_LEN (name);\n  char const *p;\n  bool saw_slash = false;\n\n  while (ISSLASH (*base))\n    base++;\n\n  for (p = base; *p; p++)\n    {\n      if (ISSLASH (*p))\n        saw_slash = true;\n      else if (saw_slash)\n        {\n          base = p;\n          saw_slash = false;\n        }\n    }\n\n  return (char *) base;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "char",
        "*\nlast_component (char const *name)",
        "*"
      ]
    },
    "base_len": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "size_t\nbase_len (char const *name)\n{\n  size_t len;\n  size_t prefix_len = FILE_SYSTEM_PREFIX_LEN (name);\n\n  for (len = strlen (name);  1 < len && ISSLASH (name[len - 1]);  len--)\n    continue;\n\n  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && len == 1\n      && ISSLASH (name[0]) && ISSLASH (name[1]) && ! name[2])\n    return 2;\n\n  if (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE && prefix_len\n      && len == prefix_len && ISSLASH (name[prefix_len]))\n    return prefix_len + 1;\n\n  return len;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/btowc.c": {
    "btowc": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "wint_t\nbtowc (int c)\n{\n  if (c != EOF)\n    {\n      char buf[1];\n      wchar_t wc;\n\n      buf[0] = c;\n      if (mbtowc (&wc, buf, 1) >= 0)\n        return wc;\n    }\n  return WEOF;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "wint_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/c++defs.h": {},
  "libunistring/libunistring-0.9.10/tests/ctype.in.h": {},
  "libunistring/libunistring-0.9.10/tests/dirname-lgpl.c": {
    "dir_len": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "size_t\ndir_len (char const *file)\n{\n  size_t prefix_length = FILE_SYSTEM_PREFIX_LEN (file);\n  size_t length;\n\n  /* Advance prefix_length beyond important leading slashes.  */\n  prefix_length += (prefix_length != 0\n                    ? (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                       && ISSLASH (file[prefix_length]))\n                    : (ISSLASH (file[0])\n                       ? ((DOUBLE_SLASH_IS_DISTINCT_ROOT\n                           && ISSLASH (file[1]) && ! ISSLASH (file[2])\n                           ? 2 : 1))\n                       : 0));\n\n  /* Strip the basename and any redundant slashes before it.  */\n  for (length = last_component (file) - file;\n       prefix_length < length; length--)\n    if (! ISSLASH (file[length - 1]))\n      break;\n  return length;\n}",
      "lines": 23,
      "depth": 17,
      "decorators": [
        "size_t"
      ]
    },
    "mdir_name": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "char *\nmdir_name (char const *file)\n{\n  size_t length = dir_len (file);\n  bool append_dot = (length == 0\n                     || (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                         && length == FILE_SYSTEM_PREFIX_LEN (file)\n                         && file[2] != '\\0' && ! ISSLASH (file[2])));\n  char *dir = malloc (length + append_dot + 1);\n  if (!dir)\n    return NULL;\n  memcpy (dir, file, length);\n  if (append_dot)\n    dir[length++] = '.';\n  dir[length] = '\\0';\n  return dir;\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "char",
        "*\nmdir_name (char const *file)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/dirname.h": {},
  "libunistring/libunistring-0.9.10/tests/dosname.h": {},
  "libunistring/libunistring-0.9.10/tests/error.c": {
    "is_open": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "static int\nis_open (int fd)\n{\n# if defined _WIN32 && ! defined __CYGWIN__\n  /* On native Windows: The initial state of unassigned standard file\n     descriptors is that they are open but point to an INVALID_HANDLE_VALUE.\n     There is no fcntl, and the gnulib replacement fcntl does not support\n     F_GETFL.  */\n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n# else\n#  ifndef F_GETFL\n#   error Please port fcntl to your platform\n#  endif\n  return 0 <= fcntl (fd, F_GETFL);\n# endif\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "flush_stdout": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "static void\nflush_stdout (void)\n{\n#if !_LIBC\n  int stdout_fd;\n\n# if GNULIB_FREOPEN_SAFER\n  /* Use of gnulib's freopen-safer module normally ensures that\n       fileno (stdout) == 1\n     whenever stdout is open.  */\n  stdout_fd = STDOUT_FILENO;\n# else\n  /* POSIX states that fileno (stdout) after fclose is unspecified.  But in\n     practice it is not a problem, because stdout is statically allocated and\n     the fd of a FILE stream is stored as a field in its allocated memory.  */\n  stdout_fd = fileno (stdout);\n# endif\n  /* POSIX states that fflush (stdout) after fclose is unspecified; it\n     is safe in glibc, but not on all other platforms.  fflush (NULL)\n     is always defined, but too draconian.  */\n  if (0 <= stdout_fd && is_open (stdout_fd))\n#endif\n    fflush (stdout);\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_errno_message": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        202,
        1
      ],
      "content": "static void\nprint_errno_message (int errnum)\n{\n  char const *s;\n\n#if _LIBC || GNULIB_STRERROR_R_POSIX || defined HAVE_STRERROR_R\n  char errbuf[1024];\n# if _LIBC || (!GNULIB_STRERROR_R_POSIX && STRERROR_R_CHAR_P)\n  s = __strerror_r (errnum, errbuf, sizeof errbuf);\n# else\n  if (__strerror_r (errnum, errbuf, sizeof errbuf) == 0)\n    s = errbuf;\n  else\n    s = 0;\n# endif\n#else\n  s = strerror (errnum);\n#endif\n\n#if !_LIBC\n  if (! s)\n    s = _(\"Unknown system error\");\n#endif\n\n#if _LIBC\n  __fxprintf (NULL, \": %s\", s);\n#else\n  fprintf (stderr, \": %s\", s);\n#endif\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "error_tail": {
      "start_point": [
        205,
        42
      ],
      "end_point": [
        286,
        1
      ],
      "content": "char *message, va_list args)\n{\n#if _LIBC\n  if (_IO_fwide (stderr, 0) > 0)\n    {\n      size_t len = strlen (message) + 1;\n      wchar_t *wmessage = NULL;\n      mbstate_t st;\n      size_t res;\n      const char *tmp;\n      bool use_malloc = false;\n\n      while (1)\n        {\n          if (__libc_use_alloca (len * sizeof (wchar_t)))\n            wmessage = (wchar_t *) alloca (len * sizeof (wchar_t));\n          else\n            {\n              if (!use_malloc)\n                wmessage = NULL;\n\n              wchar_t *p = (wchar_t *) realloc (wmessage,\n                                                len * sizeof (wchar_t));\n              if (p == NULL)\n                {\n                  free (wmessage);\n                  fputws_unlocked (L\"out of memory\\n\", stderr);\n                  return;\n                }\n              wmessage = p;\n              use_malloc = true;\n            }\n\n          memset (&st, '\\0', sizeof (st));\n          tmp = message;\n\n          res = mbsrtowcs (wmessage, &tmp, len, &st);\n          if (res != len)\n            break;\n\n          if (__builtin_expect (len >= SIZE_MAX / sizeof (wchar_t) / 2, 0))\n            {\n              /* This really should not happen if everything is fine.  */\n              res = (size_t) -1;\n              break;\n            }\n\n          len *= 2;\n        }\n\n      if (res == (size_t) -1)\n        {\n          /* The string cannot be converted.  */\n          if (use_malloc)\n            {\n              free (wmessage);\n              use_malloc = false;\n            }\n          wmessage = (wchar_t *) L\"???\";\n        }\n\n      __vfwprintf (stderr, wmessage, args);\n\n      if (use_malloc)\n        free (wmessage);\n    }\n  else\n#endif\n    vfprintf (stderr, message, args);\n\n  ++error_message_count;\n  if (errnum)\n    print_errno_message (errnum);\n#if _LIBC\n  __fxprintf (NULL, \"\\n\");\n#else\n  putc ('\\n', stderr);\n#endif\n  fflush (stderr);\n  if (status)\n    exit (status);\n}",
      "lines": 82,
      "depth": 18,
      "decorators": null
    },
    "error": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        331,
        1
      ],
      "content": "void\nerror (int status, int errnum, const char *message, ...)\n{\n  va_list args;\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s: \", program_name);\n#else\n      fprintf (stderr, \"%s: \", program_name);\n#endif\n    }\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n  va_end (args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "error_at_line": {
      "start_point": [
        337,
        0
      ],
      "end_point": [
        402,
        1
      ],
      "content": "void\nerror_at_line (int status, int errnum, const char *file_name,\n               unsigned int line_number, const char *message, ...)\n{\n  va_list args;\n\n  if (error_one_per_line)\n    {\n      static const char *old_file_name;\n      static unsigned int old_line_number;\n\n      if (old_line_number == line_number\n          && (file_name == old_file_name\n              || (old_file_name != NULL\n                  && file_name != NULL\n                  && strcmp (old_file_name, file_name) == 0)))\n\n        /* Simply return and print nothing.  */\n        return;\n\n      old_file_name = file_name;\n      old_line_number = line_number;\n    }\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s:\", program_name);\n#else\n      fprintf (stderr, \"%s:\", program_name);\n#endif\n    }\n\n#if _LIBC\n  __fxprintf (NULL, file_name != NULL ? \"%s:%u: \" : \" \",\n              file_name, line_number);\n#else\n  fprintf (stderr, file_name != NULL ? \"%s:%u: \" : \" \",\n           file_name, line_number);\n#endif\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n  va_end (args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 66,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/error.h": {},
  "libunistring/libunistring-0.9.10/tests/exitfail.c": {},
  "libunistring/libunistring-0.9.10/tests/exitfail.h": {},
  "libunistring/libunistring-0.9.10/tests/fdopen.c": {
    "fdopen_nothrow": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        38,
        5
      ],
      "content": "static FILE *\nfdopen_nothrow (int fd, const char *mode)\n{\n  FILE *result;\n\n  TRY_MSVC_INVAL\n    {\n      result = fdopen (fd, mode);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "FILE",
        "*\nfdopen_nothrow (int fd, const char *mode)",
        "*"
      ]
    },
    "rpl_fdopen": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "FILE *\nrpl_fdopen (int fd, const char *mode)\n{\n  int saved_errno = errno;\n  FILE *fp;\n\n  errno = 0;\n  fp = fdopen_nothrow (fd, mode);\n  if (fp == NULL)\n    {\n      if (errno == 0)\n        errno = EBADF;\n    }\n  else\n    errno = saved_errno;\n\n  return fp;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "FILE",
        "*\nrpl_fdopen (int fd, const char *mode)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/getpagesize.c": {
    "getpagesize": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int\ngetpagesize (void)\n{\n  SYSTEM_INFO system_info;\n  GetSystemInfo (&system_info);\n  return system_info.dwPageSize;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/getprogname.c": {
    "getprogname": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "char const *\ngetprogname (void)\n{\n# if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME                /* glibc, BeOS */\n  /* https://www.gnu.org/software/libc/manual/html_node/Error-Messages.html */\n  return program_invocation_short_name;\n# elif HAVE_DECL_PROGRAM_INVOCATION_NAME                    /* glibc, BeOS */\n  /* https://www.gnu.org/software/libc/manual/html_node/Error-Messages.html */\n  return last_component (program_invocation_name);\n# elif HAVE_GETEXECNAME                                     /* Solaris */\n  /* https://docs.oracle.com/cd/E19253-01/816-5168/6mbb3hrb1/index.html */\n  const char *p = getexecname ();\n  if (!p)\n    p = \"?\";\n  return last_component (p);\n# elif HAVE_DECL___ARGV                                     /* mingw, MSVC */\n  /* https://msdn.microsoft.com/en-us/library/dn727674.aspx */\n  const char *p = __argv && __argv[0] ? __argv[0] : \"?\";\n  return last_component (p);\n# elif HAVE_VAR___PROGNAME                                  /* OpenBSD, QNX */\n  /* https://man.openbsd.org/style.9 */\n  /* http://www.qnx.de/developers/docs/6.5.0/index.jsp?topic=%2Fcom.qnx.doc.neutrino_lib_ref%2Fp%2F__progname.html */\n  /* Be careful to declare this only when we absolutely need it\n     (OpenBSD 5.1), rather than when it's available.  Otherwise,\n     its mere declaration makes program_invocation_short_name\n     malfunction (have zero length) with Fedora 25's glibc.  */\n  extern char *__progname;\n  const char *p = __progname;\n  return p && p[0] ? p : \"?\";\n# elif _AIX                                                 /* AIX */\n  /* Idea by Bastien ROUCARI\u00c3\u0088S,\n     https://lists.gnu.org/r/bug-gnulib/2010-12/msg00095.html\n     Reference: https://www.ibm.com/support/knowledgecenter/en/ssw_aix_61/com.ibm.aix.basetrf1/getprocs.htm\n  */\n  static char *p;\n  static int first = 1;\n  if (first)\n    {\n      first = 0;\n      pid_t pid = getpid ();\n      struct procentry64 procs;\n      p = (0 < getprocs64 (&procs, sizeof procs, NULL, 0, &pid, 1)\n           ? strdup (procs.pi_comm)\n           : NULL);\n      if (!p)\n        p = \"?\";\n    }\n  return p;\n# elif defined __hpux\n  static char *p;\n  static int first = 1;\n  if (first)\n    {\n      first = 0;\n      pid_t pid = getpid ();\n      struct pst_status status;\n      p = (0 < pstat_getproc (&status, sizeof status, 0, pid)\n           ? strdup (status.pst_ucomm)\n           : NULL);\n      if (!p)\n        p = \"?\";\n    }\n  return p;\n# elif __MVS__                                              /* z/OS */\n  /* https://www.ibm.com/support/knowledgecenter/SSLTBW_2.1.0/com.ibm.zos.v2r1.bpxbd00/rtwgetp.htm */\n  static char *p = \"?\";\n  static int first = 1;\n  if (first)\n    {\n      pid_t pid = getpid ();\n      int token;\n      W_PSPROC buf;\n      first = 0;\n      memset (&buf, 0, sizeof(buf));\n      buf.ps_cmdptr    = (char *) malloc (buf.ps_cmdlen    = PS_CMDBLEN_LONG);\n      buf.ps_conttyptr = (char *) malloc (buf.ps_conttylen = PS_CONTTYBLEN);\n      buf.ps_pathptr   = (char *) malloc (buf.ps_pathlen   = PS_PATHBLEN);\n      if (buf.ps_cmdptr && buf.ps_conttyptr && buf.ps_pathptr)\n        {\n          for (token = 0; token >= 0;\n               token = w_getpsent (token, &buf, sizeof(buf)))\n            {\n              if (token > 0 && buf.ps_pid == pid)\n                {\n                  char *s = strdup (last_component (buf.ps_pathptr));\n                  if (s)\n                    p = s;\n                  break;\n                }\n            }\n        }\n      free (buf.ps_cmdptr);\n      free (buf.ps_conttyptr);\n      free (buf.ps_pathptr);\n    }\n  return p;\n# elif defined __sgi                                        /* IRIX */\n  char filename[50];\n  int fd;\n\n  sprintf (filename, \"/proc/pinfo/%d\", (int) getpid ());\n  fd = open (filename, O_RDONLY);\n  if (0 <= fd)\n    {\n      prpsinfo_t buf;\n      int ioctl_ok = 0 <= ioctl (fd, PIOCPSINFO, &buf);\n      close (fd);\n      if (ioctl_ok)\n        {\n          char *name = buf.pr_fname;\n          size_t namesize = sizeof buf.pr_fname;\n          char *namenul = memchr (name, '\\0', namesize);\n          size_t namelen = namenul ? namenul - name : namesize;\n          char *namecopy = malloc (namelen + 1);\n          if (namecopy)\n            {\n              namecopy[namelen] = 0;\n              return memcpy (namecopy, name, namelen);\n            }\n        }\n    }\n  return NULL;\n# else\n#  error \"getprogname module not ported to this OS\"\n# endif\n}",
      "lines": 126,
      "depth": 26,
      "decorators": [
        "char",
        "const",
        "const",
        "*\ngetprogname (void)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/getprogname.h": {},
  "libunistring/libunistring-0.9.10/tests/gettext.h": {
    "pgettext_aux": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "static const char *\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)\n{\n  const char *translation = dcgettext (domain, msg_ctxt_id, category);\n  if (translation == msg_ctxt_id)\n    return msgid;\n  else\n    return translation;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)",
        "*"
      ]
    },
    "npgettext_aux": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "static const char *\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)\n{\n  const char *translation =\n    dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n  if (translation == msg_ctxt_id || translation == msgid_plural)\n    return (n == 1 ? msgid : msgid_plural);\n  else\n    return translation;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)",
        "*"
      ]
    },
    "dcpgettext_expr": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "static const char *\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      int found_translation;\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcgettext (domain, msg_ctxt_id, category);\n      found_translation = (translation != msg_ctxt_id);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (found_translation)\n        return translation;\n    }\n  return msgid;\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)",
        "*"
      ]
    },
    "dcnpgettext_expr": {
      "start_point": [
        257,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "static const char *\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      int found_translation;\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n      found_translation = !(translation == msg_ctxt_id || translation == msgid_plural);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (found_translation)\n        return translation;\n    }\n  return (n == 1 ? msgid : msgid_plural);\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/iconvsupport.c": {
    "iconv_supports_encoding": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\niconv_supports_encoding (const char *encoding)\n{\n#if HAVE_ICONV\n  iconv_t cd = iconv_open (\"UTF-8\", encoding);\n  if (cd != (iconv_t) -1)\n    {\n      iconv_close (cd);\n      return 1;\n    }\n#endif\n  return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/infinity.h": {
    "Infinityf": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        28,
        1
      ],
      "content": "static float\nInfinityf ()\n{\n  static float zero = 0.0f;\n  return 1.0f / zero;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "float"
      ]
    },
    "Infinityd": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "static double\nInfinityd ()\n{\n  static double zero = 0.0;\n  return 1.0 / zero;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "Infinityl": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "static long double\nInfinityl ()\n{\n  static long double zero = 0.0L;\n  return 1.0L / zero;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "long double",
        "long",
        "double"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/intprops.h": {},
  "libunistring/libunistring-0.9.10/tests/inttypes.in.h": {},
  "libunistring/libunistring-0.9.10/tests/isblank.c": {
    "isblank": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nisblank (int c)\n{\n  /* On all known platforms, in all predefined locales, isblank(c) is likely\n     equivalent with  (c == ' ' || c == '\\t').  Look at the glibc definition\n     (in glibc/localedata/locales/i18n): The \"blank\" characters are '\\t', ' ',\n     U+1680, U+180E, U+2000..U+2006, U+2008..U+200A, U+205F, U+3000, and none\n     except the first two is present in a common 8-bit encoding.  Therefore\n     the substitute for other platforms is not more complicated than this.  */\n  return (c == ' ' || c == '\\t');\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/locale.in.h": {},
  "libunistring/libunistring-0.9.10/tests/macros.h": {},
  "libunistring/libunistring-0.9.10/tests/mbtowc-impl.h": {
    "mbtowc": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nmbtowc (wchar_t *pwc, const char *s, size_t n)\n{\n  if (s == NULL)\n    return 0;\n  else\n    {\n      mbstate_t state;\n      wchar_t wc;\n      size_t result;\n\n      memset (&state, 0, sizeof (mbstate_t));\n      result = mbrtowc (&wc, s, n, &state);\n      if (result == (size_t)-1 || result == (size_t)-2)\n        {\n          errno = EILSEQ;\n          return -1;\n        }\n      if (pwc != NULL)\n        *pwc = wc;\n      return (wc == 0 ? 0 : result);\n    }\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/mbtowc.c": {},
  "libunistring/libunistring-0.9.10/tests/minus-zero.h": {
    "compute_minus_zerof": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "static float\ncompute_minus_zerof (void)\n{\n  return -FLT_MIN * FLT_MIN;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "float"
      ]
    },
    "compute_minus_zerod": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static double\ncompute_minus_zerod (void)\n{\n  return -DBL_MIN * DBL_MIN;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "compute_minus_zerol": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "static long double\ncompute_minus_zerol (void)\n{\n  return -LDBL_MIN * LDBL_MIN;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "long double",
        "long",
        "double"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/msvc-inval.c": {
    "gl_msvc_invalid_parameter_handler": [
      {
        "start_point": [
          30,
          0
        ],
        "end_point": [
          37,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n}",
        "lines": 8,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          47,
          0
        ],
        "end_point": [
          55,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 9,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          96,
          0
        ],
        "end_point": [
          110,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  struct gl_msvc_inval_per_thread *current = gl_msvc_inval_current ();\n  if (current->restart_valid)\n    longjmp (current->restart, 1);\n  else\n    /* An invalid parameter notification from outside the gnulib code.\n       Give the caller a chance to intervene.  */\n    RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      }
    ],
    "gl_msvc_inval_current": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "struct gl_msvc_inval_per_thread *\ngl_msvc_inval_current (void)\n{\n  if (!tls_initialized)\n    {\n      tls_index = TlsAlloc ();\n      tls_initialized = 1;\n    }\n  if (tls_index == TLS_OUT_OF_INDEXES)\n    /* TlsAlloc had failed.  */\n    return &not_per_thread;\n  else\n    {\n      struct gl_msvc_inval_per_thread *pointer =\n        (struct gl_msvc_inval_per_thread *) TlsGetValue (tls_index);\n      if (pointer == NULL)\n        {\n          /* First call.  Allocate a new 'struct gl_msvc_inval_per_thread'.  */\n          pointer =\n            (struct gl_msvc_inval_per_thread *)\n            malloc (sizeof (struct gl_msvc_inval_per_thread));\n          if (pointer == NULL)\n            /* Could not allocate memory.  Use the global storage.  */\n            pointer = &not_per_thread;\n          TlsSetValue (tls_index, pointer);\n        }\n      return pointer;\n    }\n}",
      "lines": 29,
      "depth": 15,
      "decorators": [
        "struct gl_msvc_inval_per_thread",
        "struct",
        "gl_msvc_inval_per_thread",
        "*\ngl_msvc_inval_current (void)",
        "*"
      ]
    },
    "gl_msvc_inval_ensure_handler": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "void\ngl_msvc_inval_ensure_handler (void)\n{\n  if (gl_msvc_inval_initialized == 0)\n    {\n      _set_invalid_parameter_handler (gl_msvc_invalid_parameter_handler);\n      gl_msvc_inval_initialized = 1;\n    }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/msvc-inval.h": {},
  "libunistring/libunistring-0.9.10/tests/msvc-nothrow.c": {
    "_gl_nothrow_get_osfhandle": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        41,
        5
      ],
      "content": "intptr_t\n_gl_nothrow_get_osfhandle (int fd)\n{\n  intptr_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _get_osfhandle (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "intptr_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/msvc-nothrow.h": {},
  "libunistring/libunistring-0.9.10/tests/nan.h": {
    "NaNf": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static float\nNaNf ()\n{\n  static float zero = 0.0f;\n  return zero / zero;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "float"
      ]
    },
    "NaNd": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static double\nNaNd ()\n{\n  static double zero = 0.0;\n  return zero / zero;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "NaNl": [
      {
        "start_point": [
          70,
          0
        ],
        "end_point": [
          74,
          1
        ],
        "content": "static long double NaNl ()\n{\n  double zero = 0.0;\n  return zero / zero;\n}",
        "lines": 5,
        "depth": 5,
        "decorators": [
          "static",
          "static",
          "long double",
          "long",
          "double"
        ]
      },
      {
        "start_point": [
          76,
          0
        ],
        "end_point": [
          81,
          1
        ],
        "content": "static long double\nNaNl ()\n{\n  static long double zero = 0.0L;\n  return zero / zero;\n}",
        "lines": 6,
        "depth": 5,
        "decorators": [
          "static",
          "static",
          "long double",
          "long",
          "double"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/tests/pthread_sigmask.c": {},
  "libunistring/libunistring-0.9.10/tests/putenv.c": {
    "_unsetenv": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "static int\n_unsetenv (const char *name)\n{\n  size_t len;\n#if !HAVE_DECL__PUTENV\n  char **ep;\n#endif\n\n  if (name == NULL || *name == '\\0' || strchr (name, '=') != NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  len = strlen (name);\n\n#if HAVE_DECL__PUTENV\n  {\n    int putenv_result, putenv_errno;\n    char *name_ = malloc (len + 2);\n    memcpy (name_, name, len);\n    name_[len] = '=';\n    name_[len + 1] = 0;\n    putenv_result = _putenv (name_);\n    putenv_errno = errno;\n    free (name_);\n    __set_errno (putenv_errno);\n    return putenv_result;\n  }\n#else\n\n  LOCK;\n\n  ep = environ;\n  while (*ep != NULL)\n    if (!strncmp (*ep, name, len) && (*ep)[len] == '=')\n      {\n        /* Found it.  Remove this pointer by moving later ones back.  */\n        char **dp = ep;\n\n        do\n          dp[0] = dp[1];\n        while (*dp++);\n        /* Continue the loop in case NAME appears again.  */\n      }\n    else\n      ++ep;\n\n  UNLOCK;\n\n  return 0;\n#endif\n}",
      "lines": 53,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "putenv": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "int\nputenv (char *string)\n{\n  const char *name_end = strchr (string, '=');\n  char **ep;\n\n  if (name_end == NULL)\n    {\n      /* Remove the variable from the environment.  */\n      return _unsetenv (string);\n    }\n\n#if HAVE_DECL__PUTENV\n  /* Rely on _putenv to allocate the new environment.  If other\n     parts of the application use _putenv, the !HAVE_DECL__PUTENV code\n     would fight over who owns the environ vector, causing a crash.  */\n  if (name_end[1])\n    return _putenv (string);\n  else\n    {\n      /* _putenv (\"NAME=\") unsets NAME, so invoke _putenv (\"NAME= \")\n         to allocate the environ vector and then replace the new\n         entry with \"NAME=\".  */\n      int putenv_result, putenv_errno;\n      char *name_x = malloc (name_end - string + sizeof \"= \");\n      if (!name_x)\n        return -1;\n      memcpy (name_x, string, name_end - string + 1);\n      name_x[name_end - string + 1] = ' ';\n      name_x[name_end - string + 2] = 0;\n      putenv_result = _putenv (name_x);\n      putenv_errno = errno;\n      for (ep = environ; *ep; ep++)\n        if (strcmp (*ep, name_x) == 0)\n          {\n            *ep = string;\n            break;\n          }\n# if defined _WIN32 && ! defined __CYGWIN__\n      if (putenv_result == 0)\n        {\n          /* _putenv propagated \"NAME= \" into the subprocess environment;\n             fix that by calling SetEnvironmentVariable directly.  */\n          name_x[name_end - string] = 0;\n          putenv_result = SetEnvironmentVariable (name_x, \"\") ? 0 : -1;\n          putenv_errno = ENOMEM; /* ENOMEM is the only way to fail.  */\n        }\n# endif\n      free (name_x);\n      __set_errno (putenv_errno);\n      return putenv_result;\n    }\n#else\n  for (ep = environ; *ep; ep++)\n    if (strncmp (*ep, string, name_end - string) == 0\n        && (*ep)[name_end - string] == '=')\n      break;\n\n  if (*ep)\n    *ep = string;\n  else\n    {\n      static char **last_environ = NULL;\n      size_t size = ep - environ;\n      char **new_environ = malloc ((size + 2) * sizeof *new_environ);\n      if (! new_environ)\n        return -1;\n      new_environ[0] = string;\n      memcpy (new_environ + 1, environ, (size + 1) * sizeof *new_environ);\n      free (last_environ);\n      last_environ = new_environ;\n      environ = new_environ;\n    }\n\n  return 0;\n#endif\n}",
      "lines": 77,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/raise.c": {
    "raise_nothrow": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        44,
        5
      ],
      "content": "static int\nraise_nothrow (int sig)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = raise (sig);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_raise": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "int\nrpl_raise (int sig)\n{\n#if GNULIB_defined_signal_blocking && GNULIB_defined_SIGPIPE\n  if (sig == SIGPIPE)\n    return _gl_raise_SIGPIPE ();\n#endif\n\n#if HAVE_RAISE\n  return raise_nothrow (sig);\n#else\n  return kill (getpid (), sig);\n#endif\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/randomd.c": {},
  "libunistring/libunistring-0.9.10/tests/randoml.c": {},
  "libunistring/libunistring-0.9.10/tests/setenv.c": {
    "__add_to_environ": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        287,
        1
      ],
      "content": "int\n__add_to_environ (const char *name, const char *value, const char *combined,\n                  int replace)\n{\n  char **ep;\n  size_t size;\n  const size_t namelen = strlen (name);\n  const size_t vallen = value != NULL ? strlen (value) + 1 : 0;\n\n  LOCK;\n\n  /* We have to get the pointer now that we have the lock and not earlier\n     since another thread might have created a new environment.  */\n  ep = __environ;\n\n  size = 0;\n  if (ep != NULL)\n    {\n      for (; *ep != NULL; ++ep)\n        if (!strncmp (*ep, name, namelen) && (*ep)[namelen] == '=')\n          break;\n        else\n          ++size;\n    }\n\n  if (ep == NULL || *ep == NULL)\n    {\n      char **new_environ;\n#ifdef USE_TSEARCH\n      char *new_value;\n#endif\n\n      /* We allocated this space; we can extend it.  */\n      new_environ =\n        (char **) (last_environ == NULL\n                   ? malloc ((size + 2) * sizeof (char *))\n                   : realloc (last_environ, (size + 2) * sizeof (char *)));\n      if (new_environ == NULL)\n        {\n          /* It's easier to set errno to ENOMEM than to rely on the\n             'malloc-posix' and 'realloc-posix' gnulib modules.  */\n          __set_errno (ENOMEM);\n          UNLOCK;\n          return -1;\n        }\n\n      /* If the whole entry is given add it.  */\n      if (combined != NULL)\n        /* We must not add the string to the search tree since it belongs\n           to the user.  */\n        new_environ[size] = (char *) combined;\n      else\n        {\n          /* See whether the value is already known.  */\n#ifdef USE_TSEARCH\n# ifdef _LIBC\n          new_value = (char *) alloca (namelen + 1 + vallen);\n          __mempcpy (__mempcpy (__mempcpy (new_value, name, namelen), \"=\", 1),\n                     value, vallen);\n# else\n          new_value = (char *) malloca (namelen + 1 + vallen);\n          if (new_value == NULL)\n            {\n              __set_errno (ENOMEM);\n              UNLOCK;\n              return -1;\n            }\n          memcpy (new_value, name, namelen);\n          new_value[namelen] = '=';\n          memcpy (&new_value[namelen + 1], value, vallen);\n# endif\n\n          new_environ[size] = KNOWN_VALUE (new_value);\n          if (new_environ[size] == NULL)\n#endif\n            {\n              new_environ[size] = (char *) malloc (namelen + 1 + vallen);\n              if (new_environ[size] == NULL)\n                {\n#if defined USE_TSEARCH && !defined _LIBC\n                  freea (new_value);\n#endif\n                  __set_errno (ENOMEM);\n                  UNLOCK;\n                  return -1;\n                }\n\n#ifdef USE_TSEARCH\n              memcpy (new_environ[size], new_value, namelen + 1 + vallen);\n#else\n              memcpy (new_environ[size], name, namelen);\n              new_environ[size][namelen] = '=';\n              memcpy (&new_environ[size][namelen + 1], value, vallen);\n#endif\n              /* And save the value now.  We cannot do this when we remove\n                 the string since then we cannot decide whether it is a\n                 user string or not.  */\n              STORE_VALUE (new_environ[size]);\n            }\n#if defined USE_TSEARCH && !defined _LIBC\n          freea (new_value);\n#endif\n        }\n\n      if (__environ != last_environ)\n        memcpy ((char *) new_environ, (char *) __environ,\n                size * sizeof (char *));\n\n      new_environ[size + 1] = NULL;\n\n      last_environ = __environ = new_environ;\n    }\n  else if (replace)\n    {\n      char *np;\n\n      /* Use the user string if given.  */\n      if (combined != NULL)\n        np = (char *) combined;\n      else\n        {\n#ifdef USE_TSEARCH\n          char *new_value;\n# ifdef _LIBC\n          new_value = alloca (namelen + 1 + vallen);\n          __mempcpy (__mempcpy (__mempcpy (new_value, name, namelen), \"=\", 1),\n                     value, vallen);\n# else\n          new_value = malloca (namelen + 1 + vallen);\n          if (new_value == NULL)\n            {\n              __set_errno (ENOMEM);\n              UNLOCK;\n              return -1;\n            }\n          memcpy (new_value, name, namelen);\n          new_value[namelen] = '=';\n          memcpy (&new_value[namelen + 1], value, vallen);\n# endif\n\n          np = KNOWN_VALUE (new_value);\n          if (np == NULL)\n#endif\n            {\n              np = (char *) malloc (namelen + 1 + vallen);\n              if (np == NULL)\n                {\n#if defined USE_TSEARCH && !defined _LIBC\n                  freea (new_value);\n#endif\n                  __set_errno (ENOMEM);\n                  UNLOCK;\n                  return -1;\n                }\n\n#ifdef USE_TSEARCH\n              memcpy (np, new_value, namelen + 1 + vallen);\n#else\n              memcpy (np, name, namelen);\n              np[namelen] = '=';\n              memcpy (&np[namelen + 1], value, vallen);\n#endif\n              /* And remember the value.  */\n              STORE_VALUE (np);\n            }\n#if defined USE_TSEARCH && !defined _LIBC\n          freea (new_value);\n#endif\n        }\n\n      *ep = np;\n    }\n\n  UNLOCK;\n\n  return 0;\n}",
      "lines": 177,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "setenv": {
      "start_point": [
        289,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "int\nsetenv (const char *name, const char *value, int replace)\n{\n  if (name == NULL || *name == '\\0' || strchr (name, '=') != NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  return __add_to_environ (name, value, NULL, replace);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "clearenv": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "int\nclearenv (void)\n{\n  LOCK;\n\n  if (__environ == last_environ && __environ != NULL)\n    {\n      /* We allocated this environment so we can free it.  */\n      free (__environ);\n      last_environ = NULL;\n    }\n\n  /* Clear the environment pointer removes the whole environment.  */\n  __environ = NULL;\n\n  UNLOCK;\n\n  return 0;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "free_mem": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "static void\nfree_mem (void)\n{\n  /* Remove all traces.  */\n  clearenv ();\n\n  /* Now remove the search tree.  */\n  __tdestroy (known_values, free);\n  known_values = NULL;\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rpl_setenv": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "int\nrpl_setenv (const char *name, const char *value, int replace)\n{\n  int result;\n  if (!name || !*name || strchr (name, '='))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  /* Call the real setenv even if replace is 0, in case implementation\n     has underlying data to update, such as when environ changes.  */\n  result = setenv (name, value, replace);\n  if (result == 0 && replace && *value == '=')\n    {\n      char *tmp = getenv (name);\n      if (!STREQ (tmp, value))\n        {\n          int saved_errno;\n          size_t len = strlen (value);\n          tmp = malloca (len + 2);\n          /* Since leading '=' is eaten, double it up.  */\n          *tmp = '=';\n          memcpy (tmp + 1, value, len + 1);\n          result = setenv (name, tmp, replace);\n          saved_errno = errno;\n          freea (tmp);\n          errno = saved_errno;\n        }\n    }\n  return result;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/setlocale.c": {
    "category_to_name": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static const char *\ncategory_to_name (int category)\n{\n  const char *retval;\n\n  switch (category)\n  {\n  case LC_COLLATE:\n    retval = \"LC_COLLATE\";\n    break;\n  case LC_CTYPE:\n    retval = \"LC_CTYPE\";\n    break;\n  case LC_MONETARY:\n    retval = \"LC_MONETARY\";\n    break;\n  case LC_NUMERIC:\n    retval = \"LC_NUMERIC\";\n    break;\n  case LC_TIME:\n    retval = \"LC_TIME\";\n    break;\n  case LC_MESSAGES:\n    retval = \"LC_MESSAGES\";\n    break;\n  default:\n    /* If you have a better idea for a default value let me know.  */\n    retval = \"LC_XXX\";\n  }\n\n  return retval;\n}",
      "lines": 32,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ncategory_to_name (int category)",
        "*"
      ]
    },
    "search": {
      "start_point": [
        567,
        0
      ],
      "end_point": [
        623,
        1
      ],
      "content": "static void\nsearch (const struct table_entry *table, size_t table_size, const char *string,\n        range_t *result)\n{\n  /* The table is sorted.  Perform a binary search.  */\n  size_t hi = table_size;\n  size_t lo = 0;\n  while (lo < hi)\n    {\n      /* Invariant:\n         for i < lo, strcmp (table[i].code, string) < 0,\n         for i >= hi, strcmp (table[i].code, string) > 0.  */\n      size_t mid = (hi + lo) >> 1; /* >= lo, < hi */\n      int cmp = strcmp (table[mid].code, string);\n      if (cmp < 0)\n        lo = mid + 1;\n      else if (cmp > 0)\n        hi = mid;\n      else\n        {\n          /* Found an i with\n               strcmp (language_table[i].code, string) == 0.\n             Find the entire interval of such i.  */\n          {\n            size_t i;\n\n            for (i = mid; i > lo; )\n              {\n                i--;\n                if (strcmp (table[i].code, string) < 0)\n                  {\n                    lo = i + 1;\n                    break;\n                  }\n              }\n          }\n          {\n            size_t i;\n\n            for (i = mid; i < hi; i++)\n              {\n                if (strcmp (table[i].code, string) > 0)\n                  {\n                    hi = i;\n                    break;\n                  }\n              }\n          }\n          /* The set of i with\n               strcmp (language_table[i].code, string) == 0\n             is the interval [lo, hi-1].  */\n          break;\n        }\n    }\n  result->lo = lo;\n  result->hi = hi;\n}",
      "lines": 57,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "setlocale_unixlike": {
      "start_point": [
        627,
        0
      ],
      "end_point": [
        783,
        1
      ],
      "content": "static char *\nsetlocale_unixlike (int category, const char *locale)\n{\n  char *result;\n  char llCC_buf[64];\n  char ll_buf[64];\n  char CC_buf[64];\n\n  /* The native Windows implementation of setlocale understands the special\n     locale name \"C\", but not \"POSIX\".  Therefore map \"POSIX\" to \"C\".  */\n#if defined _WIN32 && !defined __CYGWIN__\n  if (locale != NULL && strcmp (locale, \"POSIX\") == 0)\n    locale = \"C\";\n#endif\n\n  /* First, try setlocale with the original argument unchanged.  */\n  result = setlocale (category, locale);\n  if (result != NULL)\n    return result;\n\n  /* Otherwise, assume the argument is in the form\n       language[_territory][.codeset][@modifier]\n     and try to map it using the tables.  */\n  if (strlen (locale) < sizeof (llCC_buf))\n    {\n      /* Second try: Remove the codeset part.  */\n      {\n        const char *p = locale;\n        char *q = llCC_buf;\n\n        /* Copy the part before the dot.  */\n        for (; *p != '\\0' && *p != '.'; p++, q++)\n          *q = *p;\n        if (*p == '.')\n          /* Skip the part up to the '@', if any.  */\n          for (; *p != '\\0' && *p != '@'; p++)\n            ;\n        /* Copy the part starting with '@', if any.  */\n        for (; *p != '\\0'; p++, q++)\n          *q = *p;\n        *q = '\\0';\n      }\n      /* llCC_buf now contains\n           language[_territory][@modifier]\n       */\n      if (strcmp (llCC_buf, locale) != 0)\n        {\n          result = setlocale (category, llCC_buf);\n          if (result != NULL)\n            return result;\n        }\n      /* Look it up in language_table.  */\n      {\n        range_t range;\n        size_t i;\n\n        search (language_table,\n                sizeof (language_table) / sizeof (language_table[0]),\n                llCC_buf,\n                &range);\n\n        for (i = range.lo; i < range.hi; i++)\n          {\n            /* Try the replacement in language_table[i].  */\n            result = setlocale (category, language_table[i].english);\n            if (result != NULL)\n              return result;\n          }\n      }\n      /* Split language[_territory][@modifier]\n         into  ll_buf = language[@modifier]\n         and   CC_buf = territory\n       */\n      {\n        const char *underscore = strchr (llCC_buf, '_');\n        if (underscore != NULL)\n          {\n            const char *territory_start = underscore + 1;\n            const char *territory_end = strchr (territory_start, '@');\n            if (territory_end == NULL)\n              territory_end = territory_start + strlen (territory_start);\n\n            memcpy (ll_buf, llCC_buf, underscore - llCC_buf);\n            strcpy (ll_buf + (underscore - llCC_buf), territory_end);\n\n            memcpy (CC_buf, territory_start, territory_end - territory_start);\n            CC_buf[territory_end - territory_start] = '\\0';\n\n            {\n              /* Look up ll_buf in language_table\n                 and CC_buf in country_table.  */\n              range_t language_range;\n\n              search (language_table,\n                      sizeof (language_table) / sizeof (language_table[0]),\n                      ll_buf,\n                      &language_range);\n              if (language_range.lo < language_range.hi)\n                {\n                  range_t country_range;\n\n                  search (country_table,\n                          sizeof (country_table) / sizeof (country_table[0]),\n                          CC_buf,\n                          &country_range);\n                  if (country_range.lo < country_range.hi)\n                    {\n                      size_t i;\n                      size_t j;\n\n                      for (i = language_range.lo; i < language_range.hi; i++)\n                        for (j = country_range.lo; j < country_range.hi; j++)\n                          {\n                            /* Concatenate the replacements.  */\n                            const char *part1 = language_table[i].english;\n                            size_t part1_len = strlen (part1);\n                            const char *part2 = country_table[j].english;\n                            size_t part2_len = strlen (part2) + 1;\n                            char buf[64+64];\n\n                            if (!(part1_len + 1 + part2_len <= sizeof (buf)))\n                              abort ();\n                            memcpy (buf, part1, part1_len);\n                            buf[part1_len] = '_';\n                            memcpy (buf + part1_len + 1, part2, part2_len);\n\n                            /* Try the concatenated replacements.  */\n                            result = setlocale (category, buf);\n                            if (result != NULL)\n                              return result;\n                          }\n                    }\n\n                  /* Try omitting the country entirely.  This may set a locale\n                     corresponding to the wrong country, but is better than\n                     failing entirely.  */\n                  {\n                    size_t i;\n\n                    for (i = language_range.lo; i < language_range.hi; i++)\n                      {\n                        /* Try only the language replacement.  */\n                        result =\n                          setlocale (category, language_table[i].english);\n                        if (result != NULL)\n                          return result;\n                      }\n                  }\n                }\n            }\n          }\n      }\n    }\n\n  /* Failed.  */\n  return NULL;\n}",
      "lines": 157,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nsetlocale_unixlike (int category, const char *locale)",
        "*"
      ]
    },
    "setlocale_single": {
      "start_point": [
        795,
        0
      ],
      "end_point": [
        809,
        1
      ],
      "content": "static char *\nsetlocale_single (int category, const char *locale)\n{\n  if (category == LC_MESSAGES)\n    {\n      if (locale != NULL)\n        {\n          lc_messages_name[sizeof (lc_messages_name) - 1] = '\\0';\n          strncpy (lc_messages_name, locale, sizeof (lc_messages_name) - 1);\n        }\n      return lc_messages_name;\n    }\n  else\n    return setlocale_unixlike (category, locale);\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nsetlocale_single (int category, const char *locale)",
        "*"
      ]
    },
    "rpl_setlocale": {
      "start_point": [
        815,
        0
      ],
      "end_point": [
        943,
        1
      ],
      "content": "char *\nrpl_setlocale (int category, const char *locale)\n{\n  if (locale != NULL && locale[0] == '\\0')\n    {\n      /* A request to the set the current locale to the default locale.  */\n      if (category == LC_ALL)\n        {\n          /* Set LC_CTYPE first.  Then the other categories.  */\n          static int const categories[] =\n            {\n              LC_NUMERIC,\n              LC_TIME,\n              LC_COLLATE,\n              LC_MONETARY,\n              LC_MESSAGES\n            };\n          char *saved_locale;\n          const char *base_name;\n          unsigned int i;\n\n          /* Back up the old locale, in case one of the steps fails.  */\n          saved_locale = setlocale (LC_ALL, NULL);\n          if (saved_locale == NULL)\n            return NULL;\n          saved_locale = strdup (saved_locale);\n          if (saved_locale == NULL)\n            return NULL;\n\n          /* Set LC_CTYPE category.  Set all other categories (except possibly\n             LC_MESSAGES) to the same value in the same call; this is likely to\n             save calls.  */\n          base_name =\n            gl_locale_name_environ (LC_CTYPE, category_to_name (LC_CTYPE));\n          if (base_name == NULL)\n            base_name = gl_locale_name_default ();\n\n          if (setlocale_unixlike (LC_ALL, base_name) == NULL)\n            goto fail;\n# if defined _WIN32 && ! defined __CYGWIN__\n          /* On native Windows, setlocale(LC_ALL,...) may succeed but set the\n             LC_CTYPE category to an invalid value (\"C\") when it does not\n             support the specified encoding.  Report a failure instead.  */\n          if (strchr (base_name, '.') != NULL\n              && strcmp (setlocale (LC_CTYPE, NULL), \"C\") == 0)\n            goto fail;\n# endif\n\n          for (i = 0; i < sizeof (categories) / sizeof (categories[0]); i++)\n            {\n              int cat = categories[i];\n              const char *name;\n\n              name = gl_locale_name_environ (cat, category_to_name (cat));\n              if (name == NULL)\n                name = gl_locale_name_default ();\n\n              /* If name is the same as base_name, it has already been set\n                 through the setlocale call before the loop.  */\n              if (strcmp (name, base_name) != 0\n# if LC_MESSAGES == 1729\n                  || cat == LC_MESSAGES\n# endif\n                 )\n                if (setlocale_single (cat, name) == NULL)\n                  goto fail;\n            }\n\n          /* All steps were successful.  */\n          free (saved_locale);\n          return setlocale (LC_ALL, NULL);\n\n        fail:\n          if (saved_locale[0] != '\\0') /* don't risk an endless recursion */\n            setlocale (LC_ALL, saved_locale);\n          free (saved_locale);\n          return NULL;\n        }\n      else\n        {\n          const char *name =\n            gl_locale_name_environ (category, category_to_name (category));\n          if (name == NULL)\n            name = gl_locale_name_default ();\n\n          return setlocale_single (category, name);\n        }\n    }\n  else\n    {\n# if defined _WIN32 && ! defined __CYGWIN__\n      if (category == LC_ALL && locale != NULL && strchr (locale, '.') != NULL)\n        {\n          char *saved_locale;\n\n          /* Back up the old locale.  */\n          saved_locale = setlocale (LC_ALL, NULL);\n          if (saved_locale == NULL)\n            return NULL;\n          saved_locale = strdup (saved_locale);\n          if (saved_locale == NULL)\n            return NULL;\n\n          if (setlocale_unixlike (LC_ALL, locale) == NULL)\n            {\n              free (saved_locale);\n              return NULL;\n            }\n\n          /* On native Windows, setlocale(LC_ALL,...) may succeed but set the\n             LC_CTYPE category to an invalid value (\"C\") when it does not\n             support the specified encoding.  Report a failure instead.  */\n          if (strcmp (setlocale (LC_CTYPE, NULL), \"C\") == 0)\n            {\n              if (saved_locale[0] != '\\0') /* don't risk an endless recursion */\n                setlocale (LC_ALL, saved_locale);\n              free (saved_locale);\n              return NULL;\n            }\n\n          /* It was really successful.  */\n          free (saved_locale);\n          return setlocale (LC_ALL, NULL);\n        }\n      else\n# endif\n        return setlocale_single (category, locale);\n    }\n}",
      "lines": 129,
      "depth": 16,
      "decorators": [
        "char",
        "*\nrpl_setlocale (int category, const char *locale)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/signal.in.h": {},
  "libunistring/libunistring-0.9.10/tests/signature.h": {},
  "libunistring/libunistring-0.9.10/tests/sigprocmask.c": {
    "signal_nothrow": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        73,
        5
      ],
      "content": "static handler_t\nsignal_nothrow (int sig, handler_t handler)\n{\n  handler_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = signal (sig, handler);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "handler_t"
      ]
    },
    "ext_signal": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static handler_t\next_signal (int sig, handler_t handler)\n{\n  switch (sig)\n    {\n    case SIGPIPE:\n      {\n        handler_t old_handler = SIGPIPE_handler;\n        SIGPIPE_handler = handler;\n        return old_handler;\n      }\n    default: /* System defined signal */\n      return signal (sig, handler);\n    }\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "handler_t"
      ]
    },
    "sigismember": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "int\nsigismember (const sigset_t *set, int sig)\n{\n  if (sig >= 0 && sig < NSIG)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      return (*set >> sig) & 1;\n    }\n  else\n    return 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "sigemptyset": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "int\nsigemptyset (sigset_t *set)\n{\n  *set = 0;\n  return 0;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "sigaddset": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "int\nsigaddset (sigset_t *set, int sig)\n{\n  if (sig >= 0 && sig < NSIG)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      *set |= 1U << sig;\n      return 0;\n    }\n  else\n    {\n      errno = EINVAL;\n      return -1;\n    }\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "sigdelset": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "int\nsigdelset (sigset_t *set, int sig)\n{\n  if (sig >= 0 && sig < NSIG)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      *set &= ~(1U << sig);\n      return 0;\n    }\n  else\n    {\n      errno = EINVAL;\n      return -1;\n    }\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "sigfillset": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "int\nsigfillset (sigset_t *set)\n{\n  *set = ((2U << (NSIG - 1)) - 1) & ~ SIGABRT_COMPAT_MASK;\n  return 0;\n}",
      "lines": 6,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "blocked_handler": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "static void\nblocked_handler (int sig)\n{\n  /* Reinstall the handler, in case the signal occurs multiple times\n     while blocked.  There is an inherent race where an asynchronous\n     signal in between when the kernel uninstalled the handler and\n     when we reinstall it will trigger the default handler; oh\n     well.  */\n  signal (sig, blocked_handler);\n  if (sig >= 0 && sig < NSIG)\n    pending_array[sig] = 1;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sigpending": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "int\nsigpending (sigset_t *set)\n{\n  sigset_t pending = 0;\n  int sig;\n\n  for (sig = 0; sig < NSIG; sig++)\n    if (pending_array[sig])\n      pending |= 1U << sig;\n  *set = pending;\n  return 0;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "sigprocmask": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "int\nsigprocmask (int operation, const sigset_t *set, sigset_t *old_set)\n{\n  if (old_set != NULL)\n    *old_set = blocked_set;\n\n  if (set != NULL)\n    {\n      sigset_t new_blocked_set;\n      sigset_t to_unblock;\n      sigset_t to_block;\n\n      switch (operation)\n        {\n        case SIG_BLOCK:\n          new_blocked_set = blocked_set | *set;\n          break;\n        case SIG_SETMASK:\n          new_blocked_set = *set;\n          break;\n        case SIG_UNBLOCK:\n          new_blocked_set = blocked_set & ~*set;\n          break;\n        default:\n          errno = EINVAL;\n          return -1;\n        }\n      to_unblock = blocked_set & ~new_blocked_set;\n      to_block = new_blocked_set & ~blocked_set;\n\n      if (to_block != 0)\n        {\n          int sig;\n\n          for (sig = 0; sig < NSIG; sig++)\n            if ((to_block >> sig) & 1)\n              {\n                pending_array[sig] = 0;\n                if ((old_handlers[sig] = signal (sig, blocked_handler)) != SIG_ERR)\n                  blocked_set |= 1U << sig;\n              }\n        }\n\n      if (to_unblock != 0)\n        {\n          sig_atomic_t received[NSIG];\n          int sig;\n\n          for (sig = 0; sig < NSIG; sig++)\n            if ((to_unblock >> sig) & 1)\n              {\n                if (signal (sig, old_handlers[sig]) != blocked_handler)\n                  /* The application changed a signal handler while the signal\n                     was blocked, bypassing our rpl_signal replacement.\n                     We don't support this.  */\n                  abort ();\n                received[sig] = pending_array[sig];\n                blocked_set &= ~(1U << sig);\n                pending_array[sig] = 0;\n              }\n            else\n              received[sig] = 0;\n\n          for (sig = 0; sig < NSIG; sig++)\n            if (received[sig])\n              raise (sig);\n        }\n    }\n  return 0;\n}",
      "lines": 70,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "rpl_signal": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "handler_t\nrpl_signal (int sig, handler_t handler)\n{\n  /* We must provide a wrapper, so that a user can query what handler\n     they installed even if that signal is currently blocked.  */\n  if (sig >= 0 && sig < NSIG && sig != SIGKILL && sig != SIGSTOP\n      && handler != SIG_ERR)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      if (blocked_set & (1U << sig))\n        {\n          /* POSIX states that sigprocmask and signal are both\n             async-signal-safe.  This is not true of our\n             implementation - there is a slight data race where an\n             asynchronous interrupt on signal A can occur after we\n             install blocked_handler but before we have updated\n             old_handlers for signal B, such that handler A can see\n             stale information if it calls signal(B).  Oh well -\n             signal handlers really shouldn't try to manipulate the\n             installed handlers of unrelated signals.  */\n          handler_t result = old_handlers[sig];\n          old_handlers[sig] = handler;\n          return result;\n        }\n      else\n        return signal (sig, handler);\n    }\n  else\n    {\n      errno = EINVAL;\n      return SIG_ERR;\n    }\n}",
      "lines": 37,
      "depth": 10,
      "decorators": [
        "handler_t"
      ]
    },
    "_gl_raise_SIGPIPE": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        347,
        1
      ],
      "content": "int\n_gl_raise_SIGPIPE (void)\n{\n  if (blocked_set & (1U << SIGPIPE))\n    pending_array[SIGPIPE] = 1;\n  else\n    {\n      handler_t handler = SIGPIPE_handler;\n      if (handler == SIG_DFL)\n        exit (128 + SIGPIPE);\n      else if (handler != SIG_IGN)\n        (*handler) (SIGPIPE);\n    }\n  return 0;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/sleep.c": {
    "sleep": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "unsigned int\nsleep (unsigned int seconds)\n{\n  unsigned int remaining;\n\n  /* Sleep for 1 second many times, because\n       1. Sleep is not interruptible by Ctrl-C,\n       2. we want to avoid arithmetic overflow while multiplying with 1000.  */\n  for (remaining = seconds; remaining > 0; remaining--)\n    Sleep (1000);\n\n  return remaining;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "rpl_sleep": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "unsigned int\nrpl_sleep (unsigned int seconds)\n{\n  /* This requires int larger than 16 bits.  */\n  verify (UINT_MAX / 24 / 24 / 60 / 60);\n  const unsigned int limit = 24 * 24 * 60 * 60;\n  while (limit < seconds)\n    {\n      unsigned int result;\n      seconds -= limit;\n      result = sleep (limit);\n      if (result)\n        return seconds + result;\n    }\n  return sleep (seconds);\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/stdalign.in.h": {},
  "libunistring/libunistring-0.9.10/tests/stdio.in.h": {},
  "libunistring/libunistring-0.9.10/tests/strerror-override.c": {
    "strerror_override": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "const char *\nstrerror_override (int errnum)\n{\n  /* These error messages are taken from glibc/sysdeps/gnu/errlist.c.  */\n  switch (errnum)\n    {\n#if REPLACE_STRERROR_0\n    case 0:\n      return \"Success\";\n#endif\n\n#if GNULIB_defined_ESOCK /* native Windows platforms with older <errno.h> */\n    case EINPROGRESS:\n      return \"Operation now in progress\";\n    case EALREADY:\n      return \"Operation already in progress\";\n    case ENOTSOCK:\n      return \"Socket operation on non-socket\";\n    case EDESTADDRREQ:\n      return \"Destination address required\";\n    case EMSGSIZE:\n      return \"Message too long\";\n    case EPROTOTYPE:\n      return \"Protocol wrong type for socket\";\n    case ENOPROTOOPT:\n      return \"Protocol not available\";\n    case EPROTONOSUPPORT:\n      return \"Protocol not supported\";\n    case EOPNOTSUPP:\n      return \"Operation not supported\";\n    case EAFNOSUPPORT:\n      return \"Address family not supported by protocol\";\n    case EADDRINUSE:\n      return \"Address already in use\";\n    case EADDRNOTAVAIL:\n      return \"Cannot assign requested address\";\n    case ENETDOWN:\n      return \"Network is down\";\n    case ENETUNREACH:\n      return \"Network is unreachable\";\n    case ECONNRESET:\n      return \"Connection reset by peer\";\n    case ENOBUFS:\n      return \"No buffer space available\";\n    case EISCONN:\n      return \"Transport endpoint is already connected\";\n    case ENOTCONN:\n      return \"Transport endpoint is not connected\";\n    case ETIMEDOUT:\n      return \"Connection timed out\";\n    case ECONNREFUSED:\n      return \"Connection refused\";\n    case ELOOP:\n      return \"Too many levels of symbolic links\";\n    case EHOSTUNREACH:\n      return \"No route to host\";\n    case EWOULDBLOCK:\n      return \"Operation would block\";\n#endif\n#if GNULIB_defined_ESTREAMS /* native Windows platforms with older <errno.h> */\n    case ETXTBSY:\n      return \"Text file busy\";\n    case ENODATA:\n      return \"No data available\";\n    case ENOSR:\n      return \"Out of streams resources\";\n    case ENOSTR:\n      return \"Device not a stream\";\n    case ETIME:\n      return \"Timer expired\";\n    case EOTHER:\n      return \"Other error\";\n#endif\n#if GNULIB_defined_EWINSOCK /* native Windows platforms */\n    case ESOCKTNOSUPPORT:\n      return \"Socket type not supported\";\n    case EPFNOSUPPORT:\n      return \"Protocol family not supported\";\n    case ESHUTDOWN:\n      return \"Cannot send after transport endpoint shutdown\";\n    case ETOOMANYREFS:\n      return \"Too many references: cannot splice\";\n    case EHOSTDOWN:\n      return \"Host is down\";\n    case EPROCLIM:\n      return \"Too many processes\";\n    case EUSERS:\n      return \"Too many users\";\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n    case ESTALE:\n      return \"Stale NFS file handle\";\n    case EREMOTE:\n      return \"Object is remote\";\n# if HAVE_WINSOCK2_H\n      /* WSA_INVALID_HANDLE maps to EBADF */\n      /* WSA_NOT_ENOUGH_MEMORY maps to ENOMEM */\n      /* WSA_INVALID_PARAMETER maps to EINVAL */\n    case WSA_OPERATION_ABORTED:\n      return \"Overlapped operation aborted\";\n    case WSA_IO_INCOMPLETE:\n      return \"Overlapped I/O event object not in signaled state\";\n    case WSA_IO_PENDING:\n      return \"Overlapped operations will complete later\";\n      /* WSAEINTR maps to EINTR */\n      /* WSAEBADF maps to EBADF */\n      /* WSAEACCES maps to EACCES */\n      /* WSAEFAULT maps to EFAULT */\n      /* WSAEINVAL maps to EINVAL */\n      /* WSAEMFILE maps to EMFILE */\n      /* WSAEWOULDBLOCK maps to EWOULDBLOCK */\n      /* WSAEINPROGRESS maps to EINPROGRESS */\n      /* WSAEALREADY maps to EALREADY */\n      /* WSAENOTSOCK maps to ENOTSOCK */\n      /* WSAEDESTADDRREQ maps to EDESTADDRREQ */\n      /* WSAEMSGSIZE maps to EMSGSIZE */\n      /* WSAEPROTOTYPE maps to EPROTOTYPE */\n      /* WSAENOPROTOOPT maps to ENOPROTOOPT */\n      /* WSAEPROTONOSUPPORT maps to EPROTONOSUPPORT */\n      /* WSAESOCKTNOSUPPORT is ESOCKTNOSUPPORT */\n      /* WSAEOPNOTSUPP maps to EOPNOTSUPP */\n      /* WSAEPFNOSUPPORT is EPFNOSUPPORT */\n      /* WSAEAFNOSUPPORT maps to EAFNOSUPPORT */\n      /* WSAEADDRINUSE maps to EADDRINUSE */\n      /* WSAEADDRNOTAVAIL maps to EADDRNOTAVAIL */\n      /* WSAENETDOWN maps to ENETDOWN */\n      /* WSAENETUNREACH maps to ENETUNREACH */\n      /* WSAENETRESET maps to ENETRESET */\n      /* WSAECONNABORTED maps to ECONNABORTED */\n      /* WSAECONNRESET maps to ECONNRESET */\n      /* WSAENOBUFS maps to ENOBUFS */\n      /* WSAEISCONN maps to EISCONN */\n      /* WSAENOTCONN maps to ENOTCONN */\n      /* WSAESHUTDOWN is ESHUTDOWN */\n      /* WSAETOOMANYREFS is ETOOMANYREFS */\n      /* WSAETIMEDOUT maps to ETIMEDOUT */\n      /* WSAECONNREFUSED maps to ECONNREFUSED */\n      /* WSAELOOP maps to ELOOP */\n      /* WSAENAMETOOLONG maps to ENAMETOOLONG */\n      /* WSAEHOSTDOWN is EHOSTDOWN */\n      /* WSAEHOSTUNREACH maps to EHOSTUNREACH */\n      /* WSAENOTEMPTY maps to ENOTEMPTY */\n      /* WSAEPROCLIM is EPROCLIM */\n      /* WSAEUSERS is EUSERS */\n      /* WSAEDQUOT is EDQUOT */\n      /* WSAESTALE is ESTALE */\n      /* WSAEREMOTE is EREMOTE */\n    case WSASYSNOTREADY:\n      return \"Network subsystem is unavailable\";\n    case WSAVERNOTSUPPORTED:\n      return \"Winsock.dll version out of range\";\n    case WSANOTINITIALISED:\n      return \"Successful WSAStartup not yet performed\";\n    case WSAEDISCON:\n      return \"Graceful shutdown in progress\";\n    case WSAENOMORE: case WSA_E_NO_MORE:\n      return \"No more results\";\n    case WSAECANCELLED: case WSA_E_CANCELLED:\n      return \"Call was canceled\";\n    case WSAEINVALIDPROCTABLE:\n      return \"Procedure call table is invalid\";\n    case WSAEINVALIDPROVIDER:\n      return \"Service provider is invalid\";\n    case WSAEPROVIDERFAILEDINIT:\n      return \"Service provider failed to initialize\";\n    case WSASYSCALLFAILURE:\n      return \"System call failure\";\n    case WSASERVICE_NOT_FOUND:\n      return \"Service not found\";\n    case WSATYPE_NOT_FOUND:\n      return \"Class type not found\";\n    case WSAEREFUSED:\n      return \"Database query was refused\";\n    case WSAHOST_NOT_FOUND:\n      return \"Host not found\";\n    case WSATRY_AGAIN:\n      return \"Nonauthoritative host not found\";\n    case WSANO_RECOVERY:\n      return \"Nonrecoverable error\";\n    case WSANO_DATA:\n      return \"Valid name, no data record of requested type\";\n      /* WSA_QOS_* omitted */\n# endif\n#endif\n\n#if GNULIB_defined_ENOMSG\n    case ENOMSG:\n      return \"No message of desired type\";\n#endif\n\n#if GNULIB_defined_EIDRM\n    case EIDRM:\n      return \"Identifier removed\";\n#endif\n\n#if GNULIB_defined_ENOLINK\n    case ENOLINK:\n      return \"Link has been severed\";\n#endif\n\n#if GNULIB_defined_EPROTO\n    case EPROTO:\n      return \"Protocol error\";\n#endif\n\n#if GNULIB_defined_EMULTIHOP\n    case EMULTIHOP:\n      return \"Multihop attempted\";\n#endif\n\n#if GNULIB_defined_EBADMSG\n    case EBADMSG:\n      return \"Bad message\";\n#endif\n\n#if GNULIB_defined_EOVERFLOW\n    case EOVERFLOW:\n      return \"Value too large for defined data type\";\n#endif\n\n#if GNULIB_defined_ENOTSUP\n    case ENOTSUP:\n      return \"Not supported\";\n#endif\n\n#if GNULIB_defined_ENETRESET\n    case ENETRESET:\n      return \"Network dropped connection on reset\";\n#endif\n\n#if GNULIB_defined_ECONNABORTED\n    case ECONNABORTED:\n      return \"Software caused connection abort\";\n#endif\n\n#if GNULIB_defined_ESTALE\n    case ESTALE:\n      return \"Stale NFS file handle\";\n#endif\n\n#if GNULIB_defined_EDQUOT\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n#endif\n\n#if GNULIB_defined_ECANCELED\n    case ECANCELED:\n      return \"Operation canceled\";\n#endif\n\n#if GNULIB_defined_EOWNERDEAD\n    case EOWNERDEAD:\n      return \"Owner died\";\n#endif\n\n#if GNULIB_defined_ENOTRECOVERABLE\n    case ENOTRECOVERABLE:\n      return \"State not recoverable\";\n#endif\n\n#if GNULIB_defined_EILSEQ\n    case EILSEQ:\n      return \"Invalid or incomplete multibyte or wide character\";\n#endif\n\n    default:\n      return NULL;\n    }\n}",
      "lines": 269,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nstrerror_override (int errnum)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/strerror-override.h": {},
  "libunistring/libunistring-0.9.10/tests/strerror.c": {},
  "libunistring/libunistring-0.9.10/tests/stripslash.c": {
    "strip_trailing_slashes": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "bool\nstrip_trailing_slashes (char *file)\n{\n  char *base = last_component (file);\n  char *base_lim;\n  bool had_slash;\n\n  /* last_component returns \"\" for file system roots, but we need to turn\n     \"///\" into \"/\".  */\n  if (! *base)\n    base = file;\n  base_lim = base + base_len (base);\n  had_slash = (*base_lim != '\\0');\n  *base_lim = '\\0';\n  return had_slash;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-alloca-opt.c": {
    "do_allocation": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "static void\ndo_allocation (int n)\n{\n  void *ptr = alloca (n);\n  (void) ptr;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nmain ()\n{\n#if HAVE_ALLOCA\n  int i;\n\n  /* Repeat a lot of times, to make sure there's no memory leak.  */\n  for (i = 0; i < 100000; i++)\n    {\n      /* Try various values.\n         n = 0 gave a crash on Alpha with gcc-2.5.8.\n         Some versions of Mac OS X have a stack size limit of 512 KB.  */\n      func (34);\n      func (134);\n      func (399);\n      func (510823);\n      func (129321);\n      func (0);\n      func (4070);\n      func (4095);\n      func (1);\n      func (16582);\n    }\n#endif\n\n  return 0;\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-array-mergesort.c": {
    "cmp_double": {
      "start_point": [
        292,
        0
      ],
      "end_point": [
        298,
        1
      ],
      "content": "static int\ncmp_double (const void *a, const void *b)\n{\n  return (*(const double *)a < *(const double *)b ? -1 :\n          *(const double *)a > *(const double *)b ? 1 :\n          0);\n}",
      "lines": 7,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        300,
        0
      ],
      "end_point": [
        383,
        1
      ],
      "content": "int\nmain ()\n{\n  size_t n;\n\n  /* Test merge_sort_fromto.  */\n  for (n = 1; n <= NMAX; n++)\n    {\n      struct foo *dst;\n      struct foo *tmp;\n      double *qsort_result;\n      size_t i;\n\n      dst = (struct foo *) malloc ((n + 1) * sizeof (struct foo));\n      dst[n].x = 0x4A6A71FE; /* canary */\n      tmp = (struct foo *) malloc ((n / 2 + 1) * sizeof (struct foo));\n      tmp[n / 2].x = 0x587EF149; /* canary */\n\n      merge_sort_fromto (data, dst, n, tmp);\n\n      /* Verify the canaries.  */\n      ASSERT (dst[n].x == 0x4A6A71FE);\n      ASSERT (tmp[n / 2].x == 0x587EF149);\n\n      /* Verify the result.  */\n      qsort_result = (double *) malloc (n * sizeof (double));\n      for (i = 0; i < n; i++)\n        qsort_result[i] = data[i].x;\n      qsort (qsort_result, n, sizeof (double), cmp_double);\n      for (i = 0; i < n; i++)\n        ASSERT (dst[i].x == qsort_result[i]);\n\n      /* Verify the stability.  */\n      for (i = 0; i < n; i++)\n        if (i > 0 && dst[i - 1].x == dst[i].x)\n          ASSERT (dst[i - 1].index < dst[i].index);\n\n      free (qsort_result);\n      free (tmp);\n      free (dst);\n    }\n\n  /* Test merge_sort_inplace.  */\n  for (n = 1; n <= NMAX; n++)\n    {\n      struct foo *src;\n      struct foo *tmp;\n      double *qsort_result;\n      size_t i;\n\n      src = (struct foo *) malloc ((n + 1) * sizeof (struct foo));\n      src[n].x = 0x4A6A71FE; /* canary */\n      tmp = (struct foo *) malloc ((n + 1) * sizeof (struct foo));\n      tmp[n].x = 0x587EF149; /* canary */\n\n      for (i = 0; i < n; i++)\n        src[i] = data[i];\n\n      merge_sort_inplace (src, n, tmp);\n\n      /* Verify the canaries.  */\n      ASSERT (src[n].x == 0x4A6A71FE);\n      ASSERT (tmp[n].x == 0x587EF149);\n\n      /* Verify the result.  */\n      qsort_result = (double *) malloc (n * sizeof (double));\n      for (i = 0; i < n; i++)\n        qsort_result[i] = data[i].x;\n      qsort (qsort_result, n, sizeof (double), cmp_double);\n      for (i = 0; i < n; i++)\n        ASSERT (src[i].x == qsort_result[i]);\n\n      /* Verify the stability.  */\n      for (i = 0; i < n; i++)\n        if (i > 0 && src[i - 1].x == src[i].x)\n          ASSERT (src[i - 1].index < src[i].index);\n\n      free (qsort_result);\n      free (tmp);\n      free (src);\n    }\n\n  return 0;\n}",
      "lines": 84,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-btowc.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int c;\n\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  ASSERT (btowc (EOF) == WEOF);\n\n  if (argc > 1)\n    switch (argv[1][0])\n      {\n      case '1':\n        /* Locale encoding is ISO-8859-1 or ISO-8859-15.  */\n        for (c = 0; c < 0x80; c++)\n          ASSERT (btowc (c) == c);\n        for (c = 0xA0; c < 0x100; c++)\n          ASSERT (btowc (c) != WEOF);\n        return 0;\n\n      case '2':\n        /* Locale encoding is UTF-8.  */\n        for (c = 0; c < 0x80; c++)\n          ASSERT (btowc (c) == c);\n        for (c = 0x80; c < 0x100; c++)\n          ASSERT (btowc (c) == WEOF);\n        return 0;\n      }\n\n  return 1;\n}",
      "lines": 33,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-c-ctype.c": {
    "test_agree_with_C_locale": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "static void\ntest_agree_with_C_locale (void)\n{\n  int c;\n\n  for (c = 0; c <= UCHAR_MAX; c++)\n    {\n      ASSERT (c_isascii (c) == (isascii (c) != 0));\n      if (c_isascii (c))\n        {\n          ASSERT (c_isalnum (c) == (isalnum (c) != 0));\n          ASSERT (c_isalpha (c) == (isalpha (c) != 0));\n          ASSERT (c_isblank (c) == (isblank (c) != 0));\n          ASSERT (c_iscntrl (c) == (iscntrl (c) != 0));\n          ASSERT (c_isdigit (c) == (isdigit (c) != 0));\n          ASSERT (c_islower (c) == (islower (c) != 0));\n          ASSERT (c_isgraph (c) == (isgraph (c) != 0));\n          ASSERT (c_isprint (c) == (isprint (c) != 0));\n          ASSERT (c_ispunct (c) == (ispunct (c) != 0));\n          ASSERT (c_isspace (c) == (isspace (c) != 0));\n          ASSERT (c_isupper (c) == (isupper (c) != 0));\n          ASSERT (c_isxdigit (c) == (isxdigit (c) != 0));\n          ASSERT (c_tolower (c) == tolower (c));\n          ASSERT (c_toupper (c) == toupper (c));\n        }\n    }\n}",
      "lines": 27,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_all": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "static void\ntest_all (void)\n{\n  int c;\n  int n_isascii = 0;\n\n  for (c = CHAR_MIN; c <= UCHAR_MAX; c++)\n    {\n      if (! (0 <= c && c <= CHAR_MAX))\n        {\n          ASSERT (! c_isascii (c));\n          ASSERT (! c_isalnum (c));\n          ASSERT (! c_isalpha (c));\n          ASSERT (! c_isblank (c));\n          ASSERT (! c_iscntrl (c));\n          ASSERT (! c_isdigit (c));\n          ASSERT (! c_islower (c));\n          ASSERT (! c_isgraph (c));\n          ASSERT (! c_isprint (c));\n          ASSERT (! c_ispunct (c));\n          ASSERT (! c_isspace (c));\n          ASSERT (! c_isupper (c));\n          ASSERT (! c_isxdigit (c));\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == c);\n        }\n\n      n_isascii += c_isascii (c);\n\n#ifdef C_CTYPE_ASCII\n      ASSERT (c_isascii (c) == (0 <= c && c <= 0x7f));\n#endif\n\n      ASSERT (c_isascii (c) == (c_isprint (c) || c_iscntrl (c)));\n\n      ASSERT (c_isalnum (c) == (c_isalpha (c) || c_isdigit (c)));\n\n      ASSERT (c_isalpha (c) == (c_islower (c) || c_isupper (c)));\n\n      switch (c)\n        {\n        case '\\t': case ' ':\n          ASSERT (c_isblank (c) == 1);\n          break;\n        default:\n          ASSERT (c_isblank (c) == 0);\n          break;\n        }\n\n#ifdef C_CTYPE_ASCII\n      ASSERT (c_iscntrl (c) == ((c >= 0 && c < 0x20) || c == 0x7f));\n#endif\n\n      switch (c)\n        {\n        case '\\a': case '\\b': case '\\f': case '\\n':\n        case '\\r': case '\\t': case '\\v':\n          ASSERT (c_iscntrl (c));\n          break;\n        }\n\n      ASSERT (! (c_iscntrl (c) && c_isprint (c)));\n\n      switch (c)\n        {\n        case '0': case '1': case '2': case '3': case '4': case '5':\n        case '6': case '7': case '8': case '9':\n          ASSERT (c_isdigit (c) == 1);\n          break;\n        default:\n          ASSERT (c_isdigit (c) == 0);\n          break;\n        }\n\n      switch (c)\n        {\n        case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n        case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n        case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n        case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n        case 'y': case 'z':\n          ASSERT (c_islower (c) == 1);\n          ASSERT (c_toupper (c) == c - 'a' + 'A');\n          break;\n        default:\n          ASSERT (c_islower (c) == 0);\n          ASSERT (c_toupper (c) == c);\n          break;\n        }\n\n#ifdef C_CTYPE_ASCII\n      ASSERT (c_isgraph (c) == ((c >= 0x20 && c < 0x7f) && c != ' '));\n\n      ASSERT (c_isprint (c) == (c >= 0x20 && c < 0x7f));\n#endif\n\n      ASSERT (c_isgraph (c) == (c_isalnum (c) || c_ispunct (c)));\n\n      ASSERT (c_isprint (c) == (c_isgraph (c) || c == ' '));\n\n      switch (c)\n        {\n        case '!': case '\"': case '#': case '$': case '%': case '&': case '\\'':\n        case '(': case ')': case '*': case '+': case ',': case '-': case '.':\n        case '/': case ':': case ';': case '<': case '=': case '>': case '?':\n        case '@': case '[': case'\\\\': case ']': case '^': case '_': case '`':\n        case '{': case '|': case '}': case '~':\n          ASSERT (c_ispunct (c) == 1);\n          break;\n        default:\n          ASSERT (c_ispunct (c) == 0);\n          break;\n        }\n\n      switch (c)\n        {\n        case ' ': case '\\t': case '\\n': case '\\v': case '\\f': case '\\r':\n          ASSERT (c_isspace (c) == 1);\n          break;\n        default:\n          ASSERT (c_isspace (c) == 0);\n          break;\n        }\n\n      switch (c)\n        {\n        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n        case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n        case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n        case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n        case 'Y': case 'Z':\n          ASSERT (c_isupper (c) == 1);\n          ASSERT (c_tolower (c) == c - 'A' + 'a');\n          break;\n        default:\n          ASSERT (c_isupper (c) == 0);\n          ASSERT (c_tolower (c) == c);\n          break;\n        }\n\n      switch (c)\n        {\n        case '0': case '1': case '2': case '3': case '4': case '5':\n        case '6': case '7': case '8': case '9':\n        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n        case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n          ASSERT (c_isxdigit (c) == 1);\n          break;\n        default:\n          ASSERT (c_isxdigit (c) == 0);\n          break;\n        }\n    }\n\n  ASSERT (n_isascii == 128);\n}",
      "lines": 156,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        227,
        1
      ],
      "content": "int\nmain ()\n{\n  test_agree_with_C_locale ();\n\n  test_all ();\n\n  setlocale (LC_ALL, \"de_DE\");\n  test_all ();\n\n  setlocale (LC_ALL, \"ja_JP.EUC-JP\");\n  test_all ();\n\n  return 0;\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-c-strcasecmp.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  if (argc > 1)\n    {\n      /* configure should already have checked that the locale is supported.  */\n      if (setlocale (LC_ALL, \"\") == NULL)\n        return 1;\n    }\n\n  ASSERT (c_strcasecmp (\"paragraph\", \"Paragraph\") == 0);\n\n  ASSERT (c_strcasecmp (\"paragrapH\", \"parAgRaph\") == 0);\n\n  ASSERT (c_strcasecmp (\"paragraph\", \"paraLyzed\") < 0);\n  ASSERT (c_strcasecmp (\"paraLyzed\", \"paragraph\") > 0);\n\n  ASSERT (c_strcasecmp (\"para\", \"paragraph\") < 0);\n  ASSERT (c_strcasecmp (\"paragraph\", \"para\") > 0);\n\n  /* The following tests shows how c_strcasecmp() is different from\n     strcasecmp().  */\n\n  ASSERT (c_strcasecmp (\"\\311mile\", \"\\351mile\") < 0);\n  ASSERT (c_strcasecmp (\"\\351mile\", \"\\311mile\") > 0);\n\n  /* The following tests shows how c_strcasecmp() is different from\n     mbscasecmp().  */\n\n  ASSERT (c_strcasecmp (\"\\303\\266zg\\303\\274r\", \"\\303\\226ZG\\303\\234R\") > 0); /* \u00c3\u00b6zg\u00c3\u00bcr */\n  ASSERT (c_strcasecmp (\"\\303\\226ZG\\303\\234R\", \"\\303\\266zg\\303\\274r\") < 0); /* \u00c3\u00b6zg\u00c3\u00bcr */\n\n#if C_CTYPE_ASCII\n  /* This test shows how strings of different size cannot compare equal.  */\n  ASSERT (c_strcasecmp (\"turkish\", \"TURK\\304\\260SH\") < 0);\n  ASSERT (c_strcasecmp (\"TURK\\304\\260SH\", \"turkish\") > 0);\n#endif\n\n  return 0;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-c-strncasecmp.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  if (argc > 1)\n    {\n      /* configure should already have checked that the locale is supported.  */\n      if (setlocale (LC_ALL, \"\") == NULL)\n        return 1;\n    }\n\n  ASSERT (c_strncasecmp (\"paragraph\", \"Paragraph\", 1000000) == 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"Paragraph\", 9) == 0);\n\n  ASSERT (c_strncasecmp (\"paragrapH\", \"parAgRaph\", 1000000) == 0);\n  ASSERT (c_strncasecmp (\"paragrapH\", \"parAgRaph\", 9) == 0);\n\n  ASSERT (c_strncasecmp (\"paragraph\", \"paraLyzed\", 10) < 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"paraLyzed\", 9) < 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"paraLyzed\", 5) < 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"paraLyzed\", 4) == 0);\n  ASSERT (c_strncasecmp (\"paraLyzed\", \"paragraph\", 10) > 0);\n  ASSERT (c_strncasecmp (\"paraLyzed\", \"paragraph\", 9) > 0);\n  ASSERT (c_strncasecmp (\"paraLyzed\", \"paragraph\", 5) > 0);\n  ASSERT (c_strncasecmp (\"paraLyzed\", \"paragraph\", 4) == 0);\n\n  ASSERT (c_strncasecmp (\"para\", \"paragraph\", 10) < 0);\n  ASSERT (c_strncasecmp (\"para\", \"paragraph\", 9) < 0);\n  ASSERT (c_strncasecmp (\"para\", \"paragraph\", 5) < 0);\n  ASSERT (c_strncasecmp (\"para\", \"paragraph\", 4) == 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"para\", 10) > 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"para\", 9) > 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"para\", 5) > 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"para\", 4) == 0);\n\n  /* The following tests shows how c_strncasecmp() is different from\n     strncasecmp().  */\n\n  ASSERT (c_strncasecmp (\"\\311mily\", \"\\351mile\", 4) < 0);\n  ASSERT (c_strncasecmp (\"\\351mile\", \"\\311mily\", 4) > 0);\n\n  /* The following tests shows how c_strncasecmp() is different from\n     mbsncasecmp().  */\n\n  ASSERT (c_strncasecmp (\"\\303\\266zg\\303\\274r\", \"\\303\\226ZG\\303\\234R\", 99) > 0); /* \u00c3\u00b6zg\u00c3\u00bcr */\n  ASSERT (c_strncasecmp (\"\\303\\226ZG\\303\\234R\", \"\\303\\266zg\\303\\274r\", 99) < 0); /* \u00c3\u00b6zg\u00c3\u00bcr */\n\n#if C_CTYPE_ASCII\n  /* This test shows how strings of different size cannot compare equal.  */\n  ASSERT (c_strncasecmp (\"turkish\", \"TURK\\304\\260SH\", 7) < 0);\n  ASSERT (c_strncasecmp (\"TURK\\304\\260SH\", \"turkish\", 7) > 0);\n#endif\n\n  return 0;\n}",
      "lines": 54,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-ctype.c": {
    "main": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-environ.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nmain ()\n{\n  /* The environment variables that are set even in the weirdest situations\n     are HOME and PATH.\n     POSIX says that HOME is initialized by the system, and that PATH may be\n     unset.  But in practice it's more frequent to see HOME unset and PATH\n     set.  So we test the presence of PATH.  */\n  char **remaining_variables = environ;\n  char *string;\n\n  for (; (string = *remaining_variables) != NULL; remaining_variables++)\n    {\n      if (strncmp (string, \"PATH=\", 5) == 0)\n        /* Found the PATH environment variable.  */\n        return 0;\n    }\n  /* Failed to find the PATH environment variable.  */\n  return 1;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-errno.c": {
    "main": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Verify that errno can be assigned.  */\n  errno = EOVERFLOW;\n\n  /* snprintf() callers want to distinguish EINVAL and EOVERFLOW.  */\n  if (errno == EINVAL)\n    return 1;\n\n  return 0;\n}",
      "lines": 12,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-fdopen.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Test behavior on failure.  POSIX makes it hard to check for\n     failure, since the behavior is not well-defined on invalid file\n     descriptors, so try fdopen 1000 times and if that's not enough to\n     fail due to EMFILE, so be it.  */\n\n  int i;\n  for (i = 0; i < 1000; i++)\n    {\n      errno = 0;\n      if (! fdopen (STDOUT_FILENO, \"w\"))\n        {\n          ASSERT (errno != 0);\n          break;\n        }\n    }\n\n  return 0;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-fgetc.c": {
    "main": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *filename = \"test-fgetc.txt\";\n\n  /* We don't have an fgetc() function that installs an invalid parameter\n     handler so far.  So install that handler here, explicitly.  */\n#if HAVE_MSVC_INVALID_PARAMETER_HANDLER \\\n    && MSVC_INVALID_PARAMETER_HANDLING == DEFAULT_HANDLING\n  gl_msvc_inval_ensure_handler ();\n#endif\n\n  /* Prepare a file.  */\n  {\n    const char text[] = \"hello world\";\n    int fd = open (filename, O_RDWR | O_CREAT | O_TRUNC, 0600);\n    ASSERT (fd >= 0);\n    ASSERT (write (fd, text, sizeof (text)) == sizeof (text));\n    ASSERT (close (fd) == 0);\n  }\n\n  /* Test that fgetc() sets errno if someone else closes the stream\n     fd behind the back of stdio.  */\n  {\n    FILE *fp = fopen (filename, \"r\");\n    ASSERT (fp != NULL);\n    ASSERT (close (fileno (fp)) == 0);\n    errno = 0;\n    ASSERT (fgetc (fp) == EOF);\n    ASSERT (errno == EBADF);\n    ASSERT (ferror (fp));\n    fclose (fp);\n  }\n\n  /* Test that fgetc() sets errno if the stream was constructed with\n     an invalid file descriptor.  */\n  {\n    FILE *fp = fdopen (-1, \"r\");\n    if (fp != NULL)\n      {\n        errno = 0;\n        ASSERT (fgetc (fp) == EOF);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n  {\n    FILE *fp;\n    close (99);\n    fp = fdopen (99, \"r\");\n    if (fp != NULL)\n      {\n        errno = 0;\n        ASSERT (fgetc (fp) == EOF);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n\n  /* Clean up.  */\n  unlink (filename);\n\n  return 0;\n}",
      "lines": 66,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-float.c": {
    "pow2f": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static float\npow2f (int n)\n{\n  int k = n;\n  volatile float x = 1;\n  volatile float y = 2;\n  /* Invariant: 2^n == x * y^k.  */\n  if (k < 0)\n    {\n      y = 0.5f;\n      k = - k;\n    }\n  while (k > 0)\n    {\n      if (k != 2 * (k / 2))\n        {\n          x = x * y;\n          k = k - 1;\n        }\n      if (k == 0)\n        break;\n      y = y * y;\n      k = k / 2;\n    }\n  /* Now k == 0, hence x == 2^n.  */\n  return x;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "float"
      ]
    },
    "pow2d": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static double\npow2d (int n)\n{\n  int k = n;\n  volatile double x = 1;\n  volatile double y = 2;\n  /* Invariant: 2^n == x * y^k.  */\n  if (k < 0)\n    {\n      y = 0.5;\n      k = - k;\n    }\n  while (k > 0)\n    {\n      if (k != 2 * (k / 2))\n        {\n          x = x * y;\n          k = k - 1;\n        }\n      if (k == 0)\n        break;\n      y = y * y;\n      k = k / 2;\n    }\n  /* Now k == 0, hence x == 2^n.  */\n  return x;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "pow2l": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "static long double\npow2l (int n)\n{\n  int k = n;\n  volatile long double x = 1;\n  volatile long double y = 2;\n  /* Invariant: 2^n == x * y^k.  */\n  if (k < 0)\n    {\n      y = 0.5L;\n      k = - k;\n    }\n  while (k > 0)\n    {\n      if (k != 2 * (k / 2))\n        {\n          x = x * y;\n          k = k - 1;\n        }\n      if (k == 0)\n        break;\n      y = y * y;\n      k = k / 2;\n    }\n  /* Now k == 0, hence x == 2^n.  */\n  return x;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "long double",
        "long",
        "double"
      ]
    },
    "test_float": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "static void\ntest_float (void)\n{\n  /* Check that the value of FLT_MIN_EXP is well parenthesized.  */\n  ASSERT ((FLT_MIN_EXP % 101111) == (FLT_MIN_EXP) % 101111);\n\n  /* Check that the value of DBL_MIN_10_EXP is well parenthesized.  */\n  ASSERT ((FLT_MIN_10_EXP % 101111) == (FLT_MIN_10_EXP) % 101111);\n\n  /* Check that 'float' is as specified in IEEE 754.  */\n  ASSERT (FLT_MANT_DIG == 24);\n  ASSERT (FLT_MIN_EXP == -125);\n  ASSERT (FLT_MAX_EXP == 128);\n\n  /* Check the value of FLT_MIN_10_EXP.  */\n  ASSERT (FLT_MIN_10_EXP == - (int) (- (FLT_MIN_EXP - 1) * 0.30103));\n\n  /* Check the value of FLT_DIG.  */\n  ASSERT (FLT_DIG == (int) ((FLT_MANT_DIG - 1) * 0.30103));\n\n  /* Check the value of FLT_MIN_10_EXP.  */\n  ASSERT (FLT_MIN_10_EXP == - (int) (- (FLT_MIN_EXP - 1) * 0.30103));\n\n  /* Check the value of FLT_MAX_10_EXP.  */\n  ASSERT (FLT_MAX_10_EXP == (int) (FLT_MAX_EXP * 0.30103));\n\n  /* Check the value of FLT_MAX.  */\n  {\n    volatile float m = FLT_MAX;\n    int n;\n\n    ASSERT (m + m > m);\n    for (n = 0; n <= 2 * FLT_MANT_DIG; n++)\n      {\n        volatile float pow2_n = pow2f (n); /* 2^n */\n        volatile float x = m + (m / pow2_n);\n        if (x > m)\n          ASSERT (x + x == x);\n        else\n          ASSERT (!(x + x == x));\n      }\n  }\n\n  /* Check the value of FLT_MIN.  */\n  {\n    volatile float m = FLT_MIN;\n    volatile float x = pow2f (FLT_MIN_EXP - 1);\n    ASSERT (m == x);\n  }\n\n  /* Check the value of FLT_EPSILON.  */\n  {\n    volatile float e = FLT_EPSILON;\n    volatile float me;\n    int n;\n\n    me = 1.0f + e;\n    ASSERT (me > 1.0f);\n    ASSERT (me - 1.0f == e);\n    for (n = 0; n <= 2 * FLT_MANT_DIG; n++)\n      {\n        volatile float half_n = pow2f (- n); /* 2^-n */\n        volatile float x = me - half_n;\n        if (x < me)\n          ASSERT (x <= 1.0f);\n      }\n  }\n}",
      "lines": 68,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_double": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "static void\ntest_double (void)\n{\n  /* Check that the value of DBL_MIN_EXP is well parenthesized.  */\n  ASSERT ((DBL_MIN_EXP % 101111) == (DBL_MIN_EXP) % 101111);\n\n  /* Check that the value of DBL_MIN_10_EXP is well parenthesized.  */\n  ASSERT ((DBL_MIN_10_EXP % 101111) == (DBL_MIN_10_EXP) % 101111);\n\n  /* Check that 'double' is as specified in IEEE 754.  */\n  ASSERT (DBL_MANT_DIG == 53);\n  ASSERT (DBL_MIN_EXP == -1021);\n  ASSERT (DBL_MAX_EXP == 1024);\n\n  /* Check the value of DBL_MIN_10_EXP.  */\n  ASSERT (DBL_MIN_10_EXP == - (int) (- (DBL_MIN_EXP - 1) * 0.30103));\n\n  /* Check the value of DBL_DIG.  */\n  ASSERT (DBL_DIG == (int) ((DBL_MANT_DIG - 1) * 0.30103));\n\n  /* Check the value of DBL_MIN_10_EXP.  */\n  ASSERT (DBL_MIN_10_EXP == - (int) (- (DBL_MIN_EXP - 1) * 0.30103));\n\n  /* Check the value of DBL_MAX_10_EXP.  */\n  ASSERT (DBL_MAX_10_EXP == (int) (DBL_MAX_EXP * 0.30103));\n\n  /* Check the value of DBL_MAX.  */\n  {\n    volatile double m = DBL_MAX;\n    int n;\n\n    ASSERT (m + m > m);\n    for (n = 0; n <= 2 * DBL_MANT_DIG; n++)\n      {\n        volatile double pow2_n = pow2d (n); /* 2^n */\n        volatile double x = m + (m / pow2_n);\n        if (x > m)\n          ASSERT (x + x == x);\n        else\n          ASSERT (!(x + x == x));\n      }\n  }\n\n  /* Check the value of DBL_MIN.  */\n  {\n    volatile double m = DBL_MIN;\n    volatile double x = pow2d (DBL_MIN_EXP - 1);\n    ASSERT (m == x);\n  }\n\n  /* Check the value of DBL_EPSILON.  */\n  {\n    volatile double e = DBL_EPSILON;\n    volatile double me;\n    int n;\n\n    me = 1.0 + e;\n    ASSERT (me > 1.0);\n    ASSERT (me - 1.0 == e);\n    for (n = 0; n <= 2 * DBL_MANT_DIG; n++)\n      {\n        volatile double half_n = pow2d (- n); /* 2^-n */\n        volatile double x = me - half_n;\n        if (x < me)\n          ASSERT (x <= 1.0);\n      }\n  }\n}",
      "lines": 68,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_long_double": {
      "start_point": [
        289,
        0
      ],
      "end_point": [
        353,
        1
      ],
      "content": "static void\ntest_long_double (void)\n{\n  /* Check that the value of LDBL_MIN_EXP is well parenthesized.  */\n  ASSERT ((LDBL_MIN_EXP % 101111) == (LDBL_MIN_EXP) % 101111);\n\n  /* Check that the value of LDBL_MIN_10_EXP is well parenthesized.  */\n  ASSERT ((LDBL_MIN_10_EXP % 101111) == (LDBL_MIN_10_EXP) % 101111);\n\n  /* Check that 'long double' is at least as wide as 'double'.  */\n  ASSERT (LDBL_MANT_DIG >= DBL_MANT_DIG);\n  ASSERT (LDBL_MIN_EXP - LDBL_MANT_DIG <= DBL_MIN_EXP - DBL_MANT_DIG);\n  ASSERT (LDBL_MAX_EXP >= DBL_MAX_EXP);\n\n  /* Check the value of LDBL_DIG.  */\n  ASSERT (LDBL_DIG == (int)((LDBL_MANT_DIG - 1) * 0.30103));\n\n  /* Check the value of LDBL_MIN_10_EXP.  */\n  ASSERT (LDBL_MIN_10_EXP == - (int) (- (LDBL_MIN_EXP - 1) * 0.30103));\n\n  /* Check the value of LDBL_MAX_10_EXP.  */\n  ASSERT (LDBL_MAX_10_EXP == (int) (LDBL_MAX_EXP * 0.30103));\n\n  /* Check the value of LDBL_MAX.  */\n  {\n    volatile long double m = LDBL_MAX;\n    int n;\n\n    ASSERT (m + m > m);\n    for (n = 0; n <= 2 * LDBL_MANT_DIG; n++)\n      {\n        volatile long double pow2_n = pow2l (n); /* 2^n */\n        volatile long double x = m + (m / pow2_n);\n        if (x > m)\n          ASSERT (x + x == x);\n        else\n          ASSERT (!(x + x == x));\n      }\n  }\n\n  /* Check the value of LDBL_MIN.  */\n  {\n    volatile long double m = LDBL_MIN;\n    volatile long double x = pow2l (LDBL_MIN_EXP - 1);\n    ASSERT (m == x);\n  }\n\n  /* Check the value of LDBL_EPSILON.  */\n  {\n    volatile long double e = LDBL_EPSILON;\n    volatile long double me;\n    int n;\n\n    me = 1.0L + e;\n    ASSERT (me > 1.0L);\n    ASSERT (me - 1.0L == e);\n    for (n = 0; n <= 2 * LDBL_MANT_DIG; n++)\n      {\n        volatile long double half_n = pow2l (- n); /* 2^-n */\n        volatile long double x = me - half_n;\n        if (x < me)\n          ASSERT (x <= 1.0L);\n      }\n  }\n}",
      "lines": 65,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": [
      {
        "start_point": [
          355,
          0
        ],
        "end_point": [
          372,
          1
        ],
        "content": "int\nmain ()\n{\n  test_float ();\n  test_double ();\n\n  {\n    DECL_LONG_DOUBLE_ROUNDING\n\n    BEGIN_LONG_DOUBLE_ROUNDING ();\n\n    test_long_double ();\n\n    END_LONG_DOUBLE_ROUNDING ();\n  }\n\n  return 0;\n}",
        "lines": 18,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          376,
          0
        ],
        "end_point": [
          381,
          1
        ],
        "content": "int\nmain ()\n{\n  fprintf (stderr, \"Skipping test: FLT_RADIX is not 2.\\n\");\n  return 77;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/tests/test-fputc.c": {
    "main": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *filename = \"test-fputc.txt\";\n\n  /* We don't have an fputc() function that installs an invalid parameter\n     handler so far.  So install that handler here, explicitly.  */\n#if HAVE_MSVC_INVALID_PARAMETER_HANDLER \\\n    && MSVC_INVALID_PARAMETER_HANDLING == DEFAULT_HANDLING\n  gl_msvc_inval_ensure_handler ();\n#endif\n\n  /* Test that fputc() on an unbuffered stream sets errno if someone else\n     closes the stream fd behind the back of stdio.  */\n  {\n    FILE *fp = fopen (filename, \"w\");\n    ASSERT (fp != NULL);\n    setvbuf (fp, NULL, _IONBF, 0);\n    ASSERT (close (fileno (fp)) == 0);\n    errno = 0;\n    ASSERT (fputc ('x', fp) == EOF);\n    ASSERT (errno == EBADF);\n    ASSERT (ferror (fp));\n    fclose (fp);\n  }\n\n  /* Test that fputc() on an unbuffered stream sets errno if the stream\n     was constructed with an invalid file descriptor.  */\n  {\n    FILE *fp = fdopen (-1, \"w\");\n    if (fp != NULL)\n      {\n        setvbuf (fp, NULL, _IONBF, 0);\n        errno = 0;\n        ASSERT (fputc ('x', fp) == EOF);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n  {\n    FILE *fp;\n    close (99);\n    fp = fdopen (99, \"w\");\n    if (fp != NULL)\n      {\n        setvbuf (fp, NULL, _IONBF, 0);\n        errno = 0;\n        ASSERT (fputc ('x', fp) == EOF);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n\n  /* Clean up.  */\n  unlink (filename);\n\n  return 0;\n}",
      "lines": 60,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-fread.c": {
    "main": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *filename = \"test-fread.txt\";\n\n  /* We don't have an fread() function that installs an invalid parameter\n     handler so far.  So install that handler here, explicitly.  */\n#if HAVE_MSVC_INVALID_PARAMETER_HANDLER \\\n    && MSVC_INVALID_PARAMETER_HANDLING == DEFAULT_HANDLING\n  gl_msvc_inval_ensure_handler ();\n#endif\n\n  /* Prepare a file.  */\n  {\n    const char text[] = \"hello world\";\n    int fd = open (filename, O_RDWR | O_CREAT | O_TRUNC, 0600);\n    ASSERT (fd >= 0);\n    ASSERT (write (fd, text, sizeof (text)) == sizeof (text));\n    ASSERT (close (fd) == 0);\n  }\n\n  /* Test that fread() sets errno if someone else closes the stream\n     fd behind the back of stdio.  */\n  {\n    FILE *fp = fopen (filename, \"r\");\n    char buf[5];\n    ASSERT (fp != NULL);\n    ASSERT (close (fileno (fp)) == 0);\n    errno = 0;\n    ASSERT (fread (buf, 1, sizeof (buf), fp) == 0);\n    ASSERT (errno == EBADF);\n    ASSERT (ferror (fp));\n    fclose (fp);\n  }\n\n  /* Test that fread() sets errno if the stream was constructed with\n     an invalid file descriptor.  */\n  {\n    FILE *fp = fdopen (-1, \"r\");\n    if (fp != NULL)\n      {\n        char buf[1];\n        errno = 0;\n        ASSERT (fread (buf, 1, 1, fp) == 0);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n  {\n    FILE *fp;\n    close (99);\n    fp = fdopen (99, \"r\");\n    if (fp != NULL)\n      {\n        char buf[1];\n        errno = 0;\n        ASSERT (fread (buf, 1, 1, fp) == 0);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n\n  /* Clean up.  */\n  unlink (filename);\n\n  return 0;\n}",
      "lines": 69,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-frexp.c": {
    "main": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "int\nmain ()\n{\n  test_function ();\n\n  return 0;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-frexp.h": {
    "my_ldexp": {
      "start_point": [
        16,
        0
      ],
      "end_point": [
        24,
        1
      ],
      "content": "static DOUBLE\nmy_ldexp (DOUBLE x, int d)\n{\n  for (; d > 0; d--)\n    x *= L_(2.0);\n  for (; d < 0; d++)\n    x *= L_(0.5);\n  return x;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "DOUBLE"
      ]
    },
    "test_function": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "static void\ntest_function (void)\n{\n  int i;\n  VOLATILE DOUBLE x;\n\n  { /* NaN.  */\n    int exp = -9999;\n    DOUBLE mantissa;\n    x = NAN;\n    mantissa = FREXP (x, &exp);\n    ASSERT (ISNAN (mantissa));\n  }\n\n  { /* Positive infinity.  */\n    int exp = -9999;\n    DOUBLE mantissa;\n    x = INFINITY;\n    mantissa = FREXP (x, &exp);\n    ASSERT (mantissa == x);\n  }\n\n  { /* Negative infinity.  */\n    int exp = -9999;\n    DOUBLE mantissa;\n    x = - INFINITY;\n    mantissa = FREXP (x, &exp);\n    ASSERT (mantissa == x);\n  }\n\n  { /* Positive zero.  */\n    int exp = -9999;\n    DOUBLE mantissa;\n    x = L_(0.0);\n    mantissa = FREXP (x, &exp);\n    ASSERT (exp == 0);\n    ASSERT (mantissa == x);\n    ASSERT (!signbit (mantissa));\n  }\n\n  { /* Negative zero.  */\n    int exp = -9999;\n    DOUBLE mantissa;\n    x = MINUS_ZERO;\n    mantissa = FREXP (x, &exp);\n    ASSERT (exp == 0);\n    ASSERT (mantissa == x);\n    ASSERT (signbit (mantissa));\n  }\n\n  for (i = 1, x = L_(1.0); i <= MAX_EXP; i++, x *= L_(2.0))\n    {\n      int exp = -9999;\n      DOUBLE mantissa = FREXP (x, &exp);\n      ASSERT (exp == i);\n      ASSERT (mantissa == L_(0.5));\n    }\n  for (i = 1, x = L_(1.0); i >= MIN_NORMAL_EXP; i--, x *= L_(0.5))\n    {\n      int exp = -9999;\n      DOUBLE mantissa = FREXP (x, &exp);\n      ASSERT (exp == i);\n      ASSERT (mantissa == L_(0.5));\n    }\n  for (; i >= MIN_EXP - 100 && x > L_(0.0); i--, x *= L_(0.5))\n    {\n      int exp = -9999;\n      DOUBLE mantissa = FREXP (x, &exp);\n      ASSERT (exp == i);\n      ASSERT (mantissa == L_(0.5));\n    }\n\n  for (i = 1, x = - L_(1.0); i <= MAX_EXP; i++, x *= L_(2.0))\n    {\n      int exp = -9999;\n      DOUBLE mantissa = FREXP (x, &exp);\n      ASSERT (exp == i);\n      ASSERT (mantissa == - L_(0.5));\n    }\n  for (i = 1, x = - L_(1.0); i >= MIN_NORMAL_EXP; i--, x *= L_(0.5))\n    {\n      int exp = -9999;\n      DOUBLE mantissa = FREXP (x, &exp);\n      ASSERT (exp == i);\n      ASSERT (mantissa == - L_(0.5));\n    }\n  for (; i >= MIN_EXP - 100 && x < L_(0.0); i--, x *= L_(0.5))\n    {\n      int exp = -9999;\n      DOUBLE mantissa = FREXP (x, &exp);\n      ASSERT (exp == i);\n      ASSERT (mantissa == - L_(0.5));\n    }\n\n  for (i = 1, x = L_(1.01); i <= MAX_EXP; i++, x *= L_(2.0))\n    {\n      int exp = -9999;\n      DOUBLE mantissa = FREXP (x, &exp);\n      ASSERT (exp == i);\n      ASSERT (mantissa == L_(0.505));\n    }\n  for (i = 1, x = L_(1.01); i >= MIN_NORMAL_EXP; i--, x *= L_(0.5))\n    {\n      int exp = -9999;\n      DOUBLE mantissa = FREXP (x, &exp);\n      ASSERT (exp == i);\n      ASSERT (mantissa == L_(0.505));\n    }\n  for (; i >= MIN_EXP - 100 && x > L_(0.0); i--, x *= L_(0.5))\n    {\n      int exp = -9999;\n      DOUBLE mantissa = FREXP (x, &exp);\n      ASSERT (exp == i);\n      ASSERT (mantissa >= L_(0.5));\n      ASSERT (mantissa < L_(1.0));\n      ASSERT (mantissa == my_ldexp (x, - exp));\n    }\n\n  for (i = 1, x = L_(1.73205); i <= MAX_EXP; i++, x *= L_(2.0))\n    {\n      int exp = -9999;\n      DOUBLE mantissa = FREXP (x, &exp);\n      ASSERT (exp == i);\n      ASSERT (mantissa == L_(0.866025));\n    }\n  for (i = 1, x = L_(1.73205); i >= MIN_NORMAL_EXP; i--, x *= L_(0.5))\n    {\n      int exp = -9999;\n      DOUBLE mantissa = FREXP (x, &exp);\n      ASSERT (exp == i);\n      ASSERT (mantissa == L_(0.866025));\n    }\n  for (; i >= MIN_EXP - 100 && x > L_(0.0); i--, x *= L_(0.5))\n    {\n      int exp = -9999;\n      DOUBLE mantissa = FREXP (x, &exp);\n      ASSERT (exp == i || exp == i + 1);\n      ASSERT (mantissa >= L_(0.5));\n      ASSERT (mantissa < L_(1.0));\n      ASSERT (mantissa == my_ldexp (x, - exp));\n    }\n\n  /* Randomized tests.  */\n  for (i = 0; i < SIZEOF (RANDOM); i++)\n    {\n      x = L_(20.0) * RANDOM[i] - L_(10.0); /* -10.0 <= x <= 10.0 */\n      {\n        int exp = -9999;\n        DOUBLE mantissa = FREXP (x, &exp);\n        ASSERT (x == my_ldexp (mantissa, exp));\n      }\n    }\n}",
      "lines": 153,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-frexpl.c": {
    "main": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nmain ()\n{\n  DECL_LONG_DOUBLE_ROUNDING\n\n  BEGIN_LONG_DOUBLE_ROUNDING ();\n\n  test_function ();\n\n  return 0;\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-fseterr.c": {
    "main": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nmain ()\n{\n  /* All streams are initially created with the error indicator cleared.  */\n  if (ferror (stdout))\n    abort ();\n\n  /* Verify that fseterr() works.  */\n  fseterr (stdout);\n  if (!ferror (stdout))\n    abort ();\n\n  /* Verify fseterr's effect can be undone by clearerr().  */\n  clearerr (stdout);\n  if (ferror (stdout))\n    abort ();\n\n  return 0;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-fwrite.c": {
    "main": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *filename = \"test-fwrite.txt\";\n\n  /* We don't have an fwrite() function that installs an invalid parameter\n     handler so far.  So install that handler here, explicitly.  */\n#if HAVE_MSVC_INVALID_PARAMETER_HANDLER \\\n    && MSVC_INVALID_PARAMETER_HANDLING == DEFAULT_HANDLING\n  gl_msvc_inval_ensure_handler ();\n#endif\n\n  /* Test that fwrite() on an unbuffered stream sets errno if someone else\n     closes the stream fd behind the back of stdio.  */\n  {\n    FILE *fp = fopen (filename, \"w\");\n    char buf[5] = \"world\";\n    ASSERT (fp != NULL);\n    setvbuf (fp, NULL, _IONBF, 0);\n    ASSERT (close (fileno (fp)) == 0);\n    errno = 0;\n    ASSERT (fwrite (buf, 1, sizeof (buf), fp) == 0);\n    ASSERT (errno == EBADF);\n    ASSERT (ferror (fp));\n    fclose (fp);\n  }\n\n  /* Test that fwrite() on an unbuffered stream sets errno if the stream\n     was constructed with an invalid file descriptor.  */\n  {\n    FILE *fp = fdopen (-1, \"w\");\n    if (fp != NULL)\n      {\n        char buf[5] = \"world\";\n        setvbuf (fp, NULL, _IONBF, 0);\n        errno = 0;\n        ASSERT (fwrite (buf, 1, sizeof (buf), fp) == 0);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n  {\n    FILE *fp;\n    close (99);\n    fp = fdopen (99, \"w\");\n    if (fp != NULL)\n      {\n        char buf[5] = \"world\";\n        setvbuf (fp, NULL, _IONBF, 0);\n        errno = 0;\n        ASSERT (fwrite (buf, 1, sizeof (buf), fp) == 0);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n\n  /* Clean up.  */\n  unlink (filename);\n\n  return 0;\n}",
      "lines": 63,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-getprogname.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\nmain (void)\n{\n  char const *p = getprogname ();\n\n  /* libtool creates a temporary executable whose name is sometimes prefixed\n     with \"lt-\" (depends on the platform).  But the name of the temporary\n     executable is a detail that should not be visible to the end user and to\n     the test suite.  Remove this \"lt-\" prefix here.  */\n  if (strncmp (p, \"lt-\", 3) == 0)\n    p += 3;\n\n  /* Note: You can make this test fail\n     a) by running it on a case-insensitive file system (such as on Windows,\n        Cygwin, or on Mac OS X with a case-insensitive HFS+ file system),\n        with an invocation that contains upper case characters, e.g.\n        test-GETPROGNAME,\n     b) by hardlinking or symlinking it to a different name (e.g. test-foo)\n        and invoking it through that name.\n     That's not the intended use. The Makefile always invokes it as\n     'test-getprogname${EXEEXT}'. */\n#if defined __CYGWIN__\n  /* The Cygwin getprogname() function strips the \".exe\" suffix. */\n  assert (STREQ (p, \"test-getprogname\"));\n#else\n  assert (STREQ (p, \"test-getprogname\" EXEEXT));\n#endif\n\n  return 0;\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-iconv-h.c": {
    "main": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "int\nmain ()\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 4,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-iconv.c": {
    "main": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "int\nmain ()\n{\n#if HAVE_ICONV\n  /* Assume that iconv() supports at least the encodings ASCII, ISO-8859-1,\n     and UTF-8.  */\n  iconv_t cd_88591_to_utf8 = iconv_open (\"UTF-8\", \"ISO8859-1\");\n  iconv_t cd_utf8_to_88591 = iconv_open (\"ISO8859-1\", \"UTF-8\");\n\n#if defined __MVS__ && defined __IBMC__\n  /* String literals below are in ASCII, not EBCDIC.  */\n# pragma convert(\"ISO8859-1\")\n# define CONVERT_ENABLED\n#endif\n\n  ASSERT (cd_88591_to_utf8 != (iconv_t)(-1));\n  ASSERT (cd_utf8_to_88591 != (iconv_t)(-1));\n\n  /* Test conversion from ISO-8859-1 to UTF-8 with no errors.  */\n  {\n    static const char input[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n    static const char expected[] = \"\\303\\204rger mit b\\303\\266sen B\\303\\274bchen ohne Augenma\\303\\237\";\n    char buf[50];\n    const char *inptr = input;\n    size_t inbytesleft = strlen (input);\n    char *outptr = buf;\n    size_t outbytesleft = sizeof (buf);\n    size_t res = iconv (cd_88591_to_utf8,\n                        (ICONV_CONST char **) &inptr, &inbytesleft,\n                        &outptr, &outbytesleft);\n    ASSERT (res == 0 && inbytesleft == 0);\n    ASSERT (outptr == buf + strlen (expected));\n    ASSERT (memcmp (buf, expected, strlen (expected)) == 0);\n  }\n\n  /* Test conversion from ISO-8859-1 to UTF-8 with E2BIG.  */\n  {\n    static const char input[] = \"\\304\";\n    static char buf[2] = { (char)0xDE, (char)0xAD };\n    const char *inptr = input;\n    size_t inbytesleft = 1;\n    char *outptr = buf;\n    size_t outbytesleft = 1;\n    size_t res = iconv (cd_88591_to_utf8,\n                        (ICONV_CONST char **) &inptr, &inbytesleft,\n                        &outptr, &outbytesleft);\n    ASSERT (res == (size_t)(-1) && errno == E2BIG);\n    ASSERT (inbytesleft == 1);\n    ASSERT (outbytesleft == 1);\n    ASSERT ((unsigned char) buf[1] == 0xAD);\n    ASSERT ((unsigned char) buf[0] == 0xDE);\n  }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with no errors.  */\n  {\n    static const char input[] = \"\\303\\204rger mit b\\303\\266sen B\\303\\274bchen ohne Augenma\\303\\237\";\n    static const char expected[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n    char buf[50];\n    const char *inptr = input;\n    size_t inbytesleft = strlen (input);\n    char *outptr = buf;\n    size_t outbytesleft = sizeof (buf);\n    size_t res = iconv (cd_utf8_to_88591,\n                        (ICONV_CONST char **) &inptr, &inbytesleft,\n                        &outptr, &outbytesleft);\n    ASSERT (res == 0 && inbytesleft == 0);\n    ASSERT (outptr == buf + strlen (expected));\n    ASSERT (memcmp (buf, expected, strlen (expected)) == 0);\n  }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with EILSEQ.  */\n  {\n    static const char input[] = \"\\342\\202\\254\"; /* EURO SIGN */\n    char buf[10];\n    const char *inptr = input;\n    size_t inbytesleft = strlen (input);\n    char *outptr = buf;\n    size_t outbytesleft = sizeof (buf);\n    size_t res = iconv (cd_utf8_to_88591,\n                        (ICONV_CONST char **) &inptr, &inbytesleft,\n                        &outptr, &outbytesleft);\n    if (res == (size_t)(-1))\n      {\n        ASSERT (errno == EILSEQ);\n        ASSERT (inbytesleft == strlen (input) && outptr == buf);\n      }\n    else\n      {\n        ASSERT (res == 1);\n        ASSERT (inbytesleft == 0);\n      }\n  }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with EINVAL.  */\n  {\n    static const char input[] = \"\\342\";\n    char buf[10];\n    const char *inptr = input;\n    size_t inbytesleft = 1;\n    char *outptr = buf;\n    size_t outbytesleft = sizeof (buf);\n    size_t res = iconv (cd_utf8_to_88591,\n                        (ICONV_CONST char **) &inptr, &inbytesleft,\n                        &outptr, &outbytesleft);\n    ASSERT (res == (size_t)(-1) && errno == EINVAL);\n    ASSERT (inbytesleft == 1 && outptr == buf);\n  }\n\n  iconv_close (cd_88591_to_utf8);\n  iconv_close (cd_utf8_to_88591);\n\n#ifdef CONVERT_ENABLED\n# pragma convert(pop)\n#endif\n\n#endif /* HAVE_ICONV */\n\n  return 0;\n}",
      "lines": 119,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-intprops.c": {
    "main": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        390,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Use VERIFY for tests that must be integer constant expressions,\n     ASSERT otherwise.  */\n\n  /* TYPE_IS_INTEGER.  */\n  ASSERT (TYPE_IS_INTEGER (bool));\n  ASSERT (TYPE_IS_INTEGER (char));\n  ASSERT (TYPE_IS_INTEGER (signed char));\n  ASSERT (TYPE_IS_INTEGER (unsigned char));\n  ASSERT (TYPE_IS_INTEGER (short int));\n  ASSERT (TYPE_IS_INTEGER (unsigned short int));\n  ASSERT (TYPE_IS_INTEGER (int));\n  ASSERT (TYPE_IS_INTEGER (unsigned int));\n  ASSERT (TYPE_IS_INTEGER (long int));\n  ASSERT (TYPE_IS_INTEGER (unsigned long int));\n  ASSERT (TYPE_IS_INTEGER (intmax_t));\n  ASSERT (TYPE_IS_INTEGER (uintmax_t));\n  ASSERT (! TYPE_IS_INTEGER (float));\n  ASSERT (! TYPE_IS_INTEGER (double));\n  ASSERT (! TYPE_IS_INTEGER (long double));\n\n  /* TYPE_SIGNED.  */\n  /* VERIFY (! TYPE_SIGNED (bool)); // not guaranteed by gnulib substitute */\n  VERIFY (TYPE_SIGNED (signed char));\n  VERIFY (! TYPE_SIGNED (unsigned char));\n  VERIFY (TYPE_SIGNED (short int));\n  VERIFY (! TYPE_SIGNED (unsigned short int));\n  VERIFY (TYPE_SIGNED (int));\n  VERIFY (! TYPE_SIGNED (unsigned int));\n  VERIFY (TYPE_SIGNED (long int));\n  VERIFY (! TYPE_SIGNED (unsigned long int));\n  VERIFY (TYPE_SIGNED (intmax_t));\n  VERIFY (! TYPE_SIGNED (uintmax_t));\n  ASSERT (TYPE_SIGNED (float));\n  ASSERT (TYPE_SIGNED (double));\n  ASSERT (TYPE_SIGNED (long double));\n\n  /* Integer representation.  Check that it is two's complement.  */\n  VERIFY (INT_MIN + INT_MAX < 0);\n\n  /* TYPE_MINIMUM, TYPE_MAXIMUM.  */\n  VERIFY (TYPE_MINIMUM (char) == CHAR_MIN);\n  VERIFY (TYPE_MAXIMUM (char) == CHAR_MAX);\n  VERIFY (TYPE_MINIMUM (unsigned char) == 0);\n  VERIFY (TYPE_MAXIMUM (unsigned char) == UCHAR_MAX);\n  VERIFY (TYPE_MINIMUM (signed char) == SCHAR_MIN);\n  VERIFY (TYPE_MAXIMUM (signed char) == SCHAR_MAX);\n  VERIFY (TYPE_MINIMUM (short int) == SHRT_MIN);\n  VERIFY (TYPE_MAXIMUM (short int) == SHRT_MAX);\n  VERIFY (TYPE_MINIMUM (unsigned short int) == 0);\n  VERIFY (TYPE_MAXIMUM (unsigned short int) == USHRT_MAX);\n  VERIFY (TYPE_MINIMUM (int) == INT_MIN);\n  VERIFY (TYPE_MAXIMUM (int) == INT_MAX);\n  VERIFY (TYPE_MINIMUM (unsigned int) == 0);\n  VERIFY (TYPE_MAXIMUM (unsigned int) == UINT_MAX);\n  VERIFY (TYPE_MINIMUM (long int) == LONG_MIN);\n  VERIFY (TYPE_MAXIMUM (long int) == LONG_MAX);\n  VERIFY (TYPE_MINIMUM (unsigned long int) == 0);\n  VERIFY (TYPE_MAXIMUM (unsigned long int) == ULONG_MAX);\n  #ifdef LLONG_MAX\n   verify (TYPE_MINIMUM (long long int) == LLONG_MIN);\n   verify (TYPE_MAXIMUM (long long int) == LLONG_MAX);\n  #endif\n  VERIFY (TYPE_MINIMUM (intmax_t) == INTMAX_MIN);\n  VERIFY (TYPE_MAXIMUM (intmax_t) == INTMAX_MAX);\n  VERIFY (TYPE_MINIMUM (uintmax_t) == 0);\n  VERIFY (TYPE_MAXIMUM (uintmax_t) == UINTMAX_MAX);\n\n  /* TYPE_WIDTH.  */\n  #ifdef CHAR_WIDTH\n   verify (TYPE_WIDTH (char) == CHAR_WIDTH);\n   verify (TYPE_WIDTH (signed char) == SCHAR_WIDTH);\n   verify (TYPE_WIDTH (unsigned char) == UCHAR_WIDTH);\n   verify (TYPE_WIDTH (short int) == SHRT_WIDTH);\n   verify (TYPE_WIDTH (unsigned short int) == USHRT_WIDTH);\n   verify (TYPE_WIDTH (int) == INT_WIDTH);\n   verify (TYPE_WIDTH (unsigned int) == UINT_WIDTH);\n   verify (TYPE_WIDTH (long int) == LONG_WIDTH);\n   verify (TYPE_WIDTH (unsigned long int) == ULONG_WIDTH);\n   #ifdef LLONG_WIDTH\n    verify (TYPE_WIDTH (long long int) == LLONG_WIDTH);\n    verify (TYPE_WIDTH (unsigned long long int) == ULLONG_WIDTH);\n   #endif\n  #endif\n\n  /* INT_BITS_STRLEN_BOUND.  */\n  VERIFY (INT_BITS_STRLEN_BOUND (1) == 1);\n  VERIFY (INT_BITS_STRLEN_BOUND (2620) == 789);\n\n  /* INT_STRLEN_BOUND, INT_BUFSIZE_BOUND.  */\n  #ifdef INT32_MAX /* POSIX guarantees int32_t; this ports to non-POSIX.  */\n  VERIFY (INT_STRLEN_BOUND (int32_t) == sizeof (\"-2147483648\") - 1);\n  VERIFY (INT_BUFSIZE_BOUND (int32_t) == sizeof (\"-2147483648\"));\n  #endif\n  #ifdef INT64_MAX\n  VERIFY (INT_STRLEN_BOUND (int64_t) == sizeof (\"-9223372036854775808\") - 1);\n  VERIFY (INT_BUFSIZE_BOUND (int64_t) == sizeof (\"-9223372036854775808\"));\n  #endif\n\n  /* All the INT_<op>_RANGE_OVERFLOW tests are equally valid as\n     INT_<op>_OVERFLOW tests, so define macros to do both.  OP is the\n     operation, OPNAME its symbolic name, A and B its operands, T the\n     result type, V the overflow flag, and VRES the result if V and if\n     two's complement.  CHECK_BINOP is for most binary operatinos,\n     CHECK_SBINOP for binary +, -, * when the result type is signed,\n     and CHECK_UNOP for unary operations.  */\n  #define CHECK_BINOP(op, opname, a, b, t, v, vres)                       \\\n    VERIFY (INT_##opname##_RANGE_OVERFLOW (a, b, TYPE_MINIMUM (t),        \\\n                                           TYPE_MAXIMUM (t))              \\\n            == (v));                                                      \\\n    VERIFY (INT_##opname##_OVERFLOW (a, b) == (v))\n  #define CHECK_SBINOP(op, opname, a, b, t, v, vres)                      \\\n    CHECK_BINOP(op, opname, a, b, t, v, vres);                            \\\n    {                                                                     \\\n      t result;                                                           \\\n      ASSERT (INT_##opname##_WRAPV (a, b, &result) == (v));               \\\n      ASSERT (result == ((v) ? (vres) : ((a) op (b))));                   \\\n    }\n  #define CHECK_UNOP(op, opname, a, t, v)                                 \\\n    VERIFY (INT_##opname##_RANGE_OVERFLOW (a, TYPE_MINIMUM (t),           \\\n                                           TYPE_MAXIMUM (t))              \\\n            == (v));                                                      \\\n    VERIFY (INT_##opname##_OVERFLOW (a) == (v))\n\n  /* INT_<op>_RANGE_OVERFLOW, INT_<op>_OVERFLOW.  */\n  VERIFY (INT_ADD_RANGE_OVERFLOW (INT_MAX, 1, INT_MIN, INT_MAX));\n  VERIFY (INT_ADD_OVERFLOW (INT_MAX, 1));\n\n  CHECK_SBINOP (+, ADD, INT_MAX, 1, int, true, INT_MIN);\n  CHECK_SBINOP (+, ADD, INT_MAX, -1, int, false, INT_MAX - 1);\n  CHECK_SBINOP (+, ADD, INT_MIN, 1, int, false, INT_MIN + 1);\n  CHECK_SBINOP (+, ADD, INT_MIN, -1, int, true, INT_MAX);\n  CHECK_BINOP (+, ADD, UINT_MAX, 1u, unsigned int, true, 0u);\n  CHECK_BINOP (+, ADD, 0u, 1u, unsigned int, false, 1u);\n\n  CHECK_SBINOP (-, SUBTRACT, INT_MAX, 1, int, false, INT_MAX - 1);\n  CHECK_SBINOP (-, SUBTRACT, INT_MAX, -1, int, true, INT_MIN);\n  CHECK_SBINOP (-, SUBTRACT, INT_MIN, 1, int, true, INT_MAX);\n  CHECK_SBINOP (-, SUBTRACT, INT_MIN, -1, int, false, INT_MIN - -1);\n  CHECK_BINOP (-, SUBTRACT, UINT_MAX, 1u, unsigned int, false, UINT_MAX - 1u);\n  CHECK_BINOP (-, SUBTRACT, 0u, 1u, unsigned int, true, 0u - 1u);\n\n  CHECK_UNOP (-, NEGATE, INT_MIN, int, true);\n  CHECK_UNOP (-, NEGATE, 0, int, false);\n  CHECK_UNOP (-, NEGATE, INT_MAX, int, false);\n  CHECK_UNOP (-, NEGATE, 0u, unsigned int, false);\n  CHECK_UNOP (-, NEGATE, 1u, unsigned int, true);\n  CHECK_UNOP (-, NEGATE, UINT_MAX, unsigned int, true);\n\n  CHECK_SBINOP (*, MULTIPLY, INT_MAX, INT_MAX, int, true, 1);\n  CHECK_SBINOP (*, MULTIPLY, INT_MAX, INT_MIN, int, true, INT_MIN);\n  CHECK_SBINOP (*, MULTIPLY, INT_MIN, INT_MAX, int, true, INT_MIN);\n  CHECK_SBINOP (*, MULTIPLY, INT_MIN, INT_MIN, int, true, 0);\n  CHECK_SBINOP (*, MULTIPLY, -1, INT_MIN, int,\n                INT_NEGATE_OVERFLOW (INT_MIN), INT_MIN);\n  CHECK_SBINOP (*, MULTIPLY, LONG_MIN / INT_MAX, (long int) INT_MAX,\n                long int, false, LONG_MIN - LONG_MIN % INT_MAX);\n\n  CHECK_BINOP (/, DIVIDE, INT_MIN, -1, int,\n               INT_NEGATE_OVERFLOW (INT_MIN), INT_MIN);\n  CHECK_BINOP (/, DIVIDE, INT_MAX, 1, int, false, INT_MAX);\n  CHECK_BINOP (/, DIVIDE, (unsigned int) INT_MIN, -1u, unsigned int,\n               false, INT_MIN / -1u);\n\n  CHECK_BINOP (%, REMAINDER, INT_MIN, -1, int, INT_NEGATE_OVERFLOW (INT_MIN), 0);\n  CHECK_BINOP (%, REMAINDER, INT_MAX, 1, int, false, 0);\n  CHECK_BINOP (%, REMAINDER, (unsigned int) INT_MIN, -1u, unsigned int,\n               false, INT_MIN % -1u);\n\n  CHECK_BINOP (<<, LEFT_SHIFT, UINT_MAX, 1, unsigned int, true, UINT_MAX << 1);\n  CHECK_BINOP (<<, LEFT_SHIFT, UINT_MAX / 2 + 1, 1, unsigned int, true,\n               (UINT_MAX / 2 + 1) << 1);\n  CHECK_BINOP (<<, LEFT_SHIFT, UINT_MAX / 2, 1, unsigned int, false,\n               (UINT_MAX / 2) << 1);\n\n  /* INT_<op>_OVERFLOW and INT_<op>_WRAPV with mixed types.  */\n  #define CHECK_SUM(a, b, t, v, vres)                                     \\\n    CHECK_SUM1(a, b, t, v, vres);                                         \\\n    CHECK_SUM1(b, a, t, v, vres)\n  #define CHECK_SSUM(a, b, t, v, vres)                                    \\\n    CHECK_SSUM1(a, b, t, v, vres);                                        \\\n    CHECK_SSUM1(b, a, t, v, vres)\n  #define CHECK_SUM1(a, b, t, v, vres)                                    \\\n    VERIFY (INT_ADD_OVERFLOW (a, b) == (v))\n  #define CHECK_SSUM1(a, b, t, v, vres)                                   \\\n    CHECK_SUM1(a, b, t, v, vres);                                         \\\n    {                                                                     \\\n      t result;                                                           \\\n      ASSERT (INT_ADD_WRAPV (a, b, &result) == (v));                      \\\n      ASSERT (result == ((v) ? (vres) : ((a) + (b))));                    \\\n    }\n  CHECK_SSUM (-1, LONG_MIN, long int, true, LONG_MAX);\n  CHECK_SUM (-1, UINT_MAX, unsigned int, false, DONTCARE);\n  CHECK_SSUM (-1L, INT_MIN, long int, INT_MIN == LONG_MIN,\n              INT_MIN == LONG_MIN ? INT_MAX : DONTCARE);\n  CHECK_SUM (0u, -1, unsigned int, true, 0u + -1);\n  CHECK_SUM (0u, 0, unsigned int, false, DONTCARE);\n  CHECK_SUM (0u, 1, unsigned int, false, DONTCARE);\n  CHECK_SSUM (1, LONG_MAX, long int, true, LONG_MIN);\n  CHECK_SUM (1, UINT_MAX, unsigned int, true, 0u);\n  CHECK_SSUM (1L, INT_MAX, long int, INT_MAX == LONG_MAX,\n              INT_MAX == LONG_MAX ? INT_MIN : DONTCARE);\n  CHECK_SUM (1u, INT_MAX, unsigned int, INT_MAX == UINT_MAX, 1u + INT_MAX);\n  CHECK_SUM (1u, INT_MIN, unsigned int, true, 1u + INT_MIN);\n  {\n    long int result;\n    ASSERT (INT_ADD_WRAPV (1, INT_MAX, &result) == (INT_MAX == LONG_MAX));\n    ASSERT (INT_ADD_WRAPV (-1, INT_MIN, &result) == (INT_MIN == LONG_MIN));\n  }\n\n  #define CHECK_DIFFERENCE(a, b, t, v, vres)                              \\\n    VERIFY (INT_SUBTRACT_OVERFLOW (a, b) == (v))\n  #define CHECK_SDIFFERENCE(a, b, t, v, vres)                             \\\n    CHECK_DIFFERENCE(a, b, t, v, vres);                                   \\\n    {                                                                     \\\n      t result;                                                           \\\n      ASSERT (INT_SUBTRACT_WRAPV (a, b, &result) == (v));                 \\\n      ASSERT (result == ((v) ? (vres) : ((a) - (b))));                    \\\n    }\n  CHECK_DIFFERENCE (INT_MAX, 1u, unsigned int, UINT_MAX < INT_MAX - 1,\n                    INT_MAX - 1u);\n  CHECK_DIFFERENCE (UINT_MAX, 1, unsigned int, false, UINT_MAX - 1);\n  CHECK_DIFFERENCE (0u, -1, unsigned int, false, 0u - -1);\n  CHECK_DIFFERENCE (UINT_MAX, -1, unsigned int, true, UINT_MAX - -1);\n  CHECK_DIFFERENCE (INT_MIN, 1u, unsigned int, true, INT_MIN - 1u);\n  CHECK_DIFFERENCE (-1, 0u, unsigned int, true, -1 - 0u);\n  CHECK_SDIFFERENCE (-1, INT_MIN, int, false, -1 - INT_MIN);\n  CHECK_SDIFFERENCE (-1, INT_MAX, int, false, -1 - INT_MAX);\n  CHECK_SDIFFERENCE (0, INT_MIN, int, INT_MIN < -INT_MAX, INT_MIN);\n  CHECK_SDIFFERENCE (0, INT_MAX, int, false, 0 - INT_MAX);\n  {\n    long int result;\n    ASSERT (INT_SUBTRACT_WRAPV (INT_MAX, -1, &result) == (INT_MAX == LONG_MAX));\n    ASSERT (INT_SUBTRACT_WRAPV (INT_MIN, 1, &result) == (INT_MAX == LONG_MAX));\n  }\n\n  #define CHECK_PRODUCT(a, b, t, v, vres)                                 \\\n    CHECK_PRODUCT1(a, b, t, v, vres);                                     \\\n    CHECK_PRODUCT1(b, a, t, v, vres)\n  #define CHECK_SPRODUCT(a, b, t, v, vres)                                \\\n    CHECK_SPRODUCT1(a, b, t, v, vres);                                    \\\n    CHECK_SPRODUCT1(b, a, t, v, vres)\n  #define CHECK_PRODUCT1(a, b, t, v, vres)                                \\\n    VERIFY (INT_MULTIPLY_OVERFLOW (a, b) == (v))\n  #define CHECK_SPRODUCT1(a, b, t, v, vres)                               \\\n    CHECK_PRODUCT1(a, b, t, v, vres);                                     \\\n    {                                                                     \\\n      t result;                                                           \\\n      ASSERT (INT_MULTIPLY_WRAPV (a, b, &result) == (v));                 \\\n      ASSERT (result == ((v) ? (vres) : ((a) * (b))));                    \\\n    }\n  CHECK_PRODUCT (-1, 1u, unsigned int, true, -1 * 1u);\n  CHECK_SPRODUCT (-1, INT_MIN, int, INT_NEGATE_OVERFLOW (INT_MIN), INT_MIN);\n  CHECK_PRODUCT (-1, UINT_MAX, unsigned int, true, -1 * UINT_MAX);\n  CHECK_SPRODUCT (-32768, LONG_MAX / -32768 - 1, long int, true, LONG_MIN);\n  CHECK_SPRODUCT (-12345, LONG_MAX / -12345, long int, false, DONTCARE);\n  CHECK_SPRODUCT (0, -1, int, false, DONTCARE);\n  CHECK_SPRODUCT (0, 0, int, false, DONTCARE);\n  CHECK_PRODUCT (0, 0u, unsigned int, false, DONTCARE);\n  CHECK_SPRODUCT (0, 1, int, false, DONTCARE);\n  CHECK_SPRODUCT (0, INT_MAX, int, false, DONTCARE);\n  CHECK_SPRODUCT (0, INT_MIN, int, false, DONTCARE);\n  CHECK_PRODUCT (0, UINT_MAX, unsigned int, false, DONTCARE);\n  CHECK_PRODUCT (0u, -1, unsigned int, false, DONTCARE);\n  CHECK_PRODUCT (0u, 0, unsigned int, false, DONTCARE);\n  CHECK_PRODUCT (0u, 0u, unsigned int, false, DONTCARE);\n  CHECK_PRODUCT (0u, 1, unsigned int, false, DONTCARE);\n  CHECK_PRODUCT (0u, INT_MAX, unsigned int, false, DONTCARE);\n  CHECK_PRODUCT (0u, INT_MIN, unsigned int, false, DONTCARE);\n  CHECK_PRODUCT (0u, UINT_MAX, unsigned int, false, DONTCARE);\n  CHECK_SPRODUCT (1, INT_MAX, int, false, DONTCARE);\n  CHECK_SPRODUCT (1, INT_MIN, int, false, DONTCARE);\n  CHECK_PRODUCT (1, UINT_MAX, unsigned int, false, DONTCARE);\n  CHECK_PRODUCT (1u, INT_MIN, unsigned int, true, 1u * INT_MIN);\n  CHECK_PRODUCT (1u, INT_MAX, unsigned int, UINT_MAX < INT_MAX, 1u * INT_MAX);\n  CHECK_PRODUCT (INT_MAX, UINT_MAX, unsigned int, true, INT_MAX * UINT_MAX);\n  CHECK_PRODUCT (INT_MAX, ULONG_MAX, unsigned long int, true,\n                 INT_MAX * ULONG_MAX);\n  CHECK_SPRODUCT (INT_MIN, LONG_MAX / INT_MIN - 1, long int, true, LONG_MIN);\n  CHECK_SPRODUCT (INT_MIN, LONG_MAX / INT_MIN, long int, false, DONTCARE);\n  CHECK_PRODUCT (INT_MIN, UINT_MAX, unsigned int, true, INT_MIN * UINT_MAX);\n  CHECK_PRODUCT (INT_MIN, ULONG_MAX, unsigned long int, true,\n                 INT_MIN * ULONG_MAX);\n  {\n    long int result;\n    ASSERT (INT_MULTIPLY_WRAPV (INT_MAX, INT_MAX, &result)\n            == (LONG_MAX / INT_MAX < INT_MAX));\n    ASSERT (INT_MULTIPLY_WRAPV (INT_MAX, INT_MAX, &result)\n            || result == INT_MAX * (long int) INT_MAX);\n    ASSERT (INT_MULTIPLY_WRAPV (INT_MIN, INT_MIN, &result)\n            || result == INT_MIN * (long int) INT_MIN);\n  }\n\n# ifdef LLONG_MAX\n  {\n    long long int result;\n    ASSERT (INT_MULTIPLY_WRAPV (LONG_MAX, LONG_MAX, &result)\n            == (LLONG_MAX / LONG_MAX < LONG_MAX));\n    ASSERT (INT_MULTIPLY_WRAPV (LONG_MAX, LONG_MAX, &result)\n            || result == LONG_MAX * (long long int) LONG_MAX);\n    ASSERT (INT_MULTIPLY_WRAPV (LONG_MIN, LONG_MIN, &result)\n            || result == LONG_MIN * (long long int) LONG_MIN);\n  }\n# endif\n\n  #define CHECK_QUOTIENT(a, b, v) VERIFY (INT_DIVIDE_OVERFLOW (a, b) == (v))\n\n  CHECK_QUOTIENT (INT_MIN, -1L, INT_MIN == LONG_MIN);\n  CHECK_QUOTIENT (INT_MIN, UINT_MAX, false);\n  CHECK_QUOTIENT (INTMAX_MIN, UINTMAX_MAX, false);\n  CHECK_QUOTIENT (INTMAX_MIN, UINT_MAX, false);\n  CHECK_QUOTIENT (-11, 10u, true);\n  CHECK_QUOTIENT (-10, 10u, true);\n  CHECK_QUOTIENT (-9, 10u, false);\n  CHECK_QUOTIENT (11u, -10, true);\n  CHECK_QUOTIENT (10u, -10, true);\n  CHECK_QUOTIENT (9u, -10, false);\n\n  #define CHECK_REMAINDER(a, b, v) VERIFY (INT_REMAINDER_OVERFLOW (a, b) == (v))\n\n  CHECK_REMAINDER (INT_MIN, -1L, INT_MIN == LONG_MIN);\n  CHECK_REMAINDER (-1, UINT_MAX, true);\n  CHECK_REMAINDER ((intmax_t) -1, UINTMAX_MAX, true);\n  CHECK_REMAINDER (INTMAX_MIN, UINT_MAX,\n                   (INTMAX_MAX < UINT_MAX\n                    && - (unsigned int) INTMAX_MIN % UINT_MAX != 0));\n  CHECK_REMAINDER (INT_MIN, ULONG_MAX, INT_MIN % ULONG_MAX != 1);\n  CHECK_REMAINDER (1u, -1, false);\n  CHECK_REMAINDER (37*39u, -39, false);\n  CHECK_REMAINDER (37*39u + 1, -39, true);\n  CHECK_REMAINDER (37*39u - 1, -39, true);\n  CHECK_REMAINDER (LONG_MAX, -INT_MAX, false);\n\n  return 0;\n}",
      "lines": 337,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-inttypes.c": {
    "main": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-isblank.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  unsigned int c;\n\n  /* Verify the property in the \"C\" locale.\n     POSIX specifies in\n       <http://www.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html>\n     that\n       - in all locales, the blank characters include the <space> and <tab>\n         characters,\n       - in the \"POSIX\" locale (which is usually the same as the \"C\" locale),\n         the blank characters include only the ASCII <space> and <tab>\n         characters.  */\n  for (c = 0; c <= UCHAR_MAX; c++)\n    ASSERT (!isblank (c) == !(c == ' ' || c == '\\t'));\n  ASSERT (!isblank (EOF));\n\n  return 0;\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-isnand-nolibm.c": {},
  "libunistring/libunistring-0.9.10/tests/test-isnand.h": {
    "main": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Finite values.  */\n  ASSERT (!isnand (3.141));\n  ASSERT (!isnand (3.141e30));\n  ASSERT (!isnand (3.141e-30));\n  ASSERT (!isnand (-2.718));\n  ASSERT (!isnand (-2.718e30));\n  ASSERT (!isnand (-2.718e-30));\n  ASSERT (!isnand (0.0));\n  ASSERT (!isnand (minus_zerod));\n  /* Infinite values.  */\n  ASSERT (!isnand (Infinityd ()));\n  ASSERT (!isnand (- Infinityd ()));\n  /* Quiet NaN.  */\n  ASSERT (isnand (NaNd ()));\n#if defined DBL_EXPBIT0_WORD && defined DBL_EXPBIT0_BIT\n  /* Signalling NaN.  */\n  {\n    #define NWORDS \\\n      ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n    typedef union { double value; unsigned int word[NWORDS]; } memory_double;\n    memory_double m;\n    m.value = NaNd ();\n# if DBL_EXPBIT0_BIT > 0\n    m.word[DBL_EXPBIT0_WORD] ^= (unsigned int) 1 << (DBL_EXPBIT0_BIT - 1);\n# else\n    m.word[DBL_EXPBIT0_WORD + (DBL_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      ^= (unsigned int) 1 << (sizeof (unsigned int) * CHAR_BIT - 1);\n# endif\n    m.word[DBL_EXPBIT0_WORD + (DBL_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      |= (unsigned int) 1 << DBL_EXPBIT0_BIT;\n    ASSERT (isnand (m.value));\n  }\n#endif\n  return 0;\n}",
      "lines": 38,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-isnanf-nolibm.c": {},
  "libunistring/libunistring-0.9.10/tests/test-isnanf.h": {
    "main": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Finite values.  */\n  ASSERT (!isnanf (3.141f));\n  ASSERT (!isnanf (3.141e30f));\n  ASSERT (!isnanf (3.141e-30f));\n  ASSERT (!isnanf (-2.718f));\n  ASSERT (!isnanf (-2.718e30f));\n  ASSERT (!isnanf (-2.718e-30f));\n  ASSERT (!isnanf (0.0f));\n  ASSERT (!isnanf (minus_zerof));\n  /* Infinite values.  */\n  ASSERT (!isnanf (Infinityf ()));\n  ASSERT (!isnanf (- Infinityf ()));\n  /* Quiet NaN.  */\n  ASSERT (isnanf (NaNf ()));\n#if defined FLT_EXPBIT0_WORD && defined FLT_EXPBIT0_BIT\n  /* Signalling NaN.  */\n  {\n    #define NWORDS \\\n      ((sizeof (float) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n    typedef union { float value; unsigned int word[NWORDS]; } memory_float;\n    memory_float m;\n    m.value = NaNf ();\n# if FLT_EXPBIT0_BIT > 0\n    m.word[FLT_EXPBIT0_WORD] ^= (unsigned int) 1 << (FLT_EXPBIT0_BIT - 1);\n# else\n    m.word[FLT_EXPBIT0_WORD + (FLT_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      ^= (unsigned int) 1 << (sizeof (unsigned int) * CHAR_BIT - 1);\n# endif\n    if (FLT_EXPBIT0_WORD < NWORDS / 2)\n      m.word[FLT_EXPBIT0_WORD + 1] |= (unsigned int) 1 << FLT_EXPBIT0_BIT;\n    else\n      m.word[0] |= (unsigned int) 1;\n    ASSERT (isnanf (m.value));\n  }\n#endif\n  return 0;\n}",
      "lines": 40,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-isnanl-nolibm.c": {},
  "libunistring/libunistring-0.9.10/tests/test-isnanl.h": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "int\nmain ()\n{\n  #define NWORDS \\\n    ((sizeof (long double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n  typedef union { unsigned int word[NWORDS]; long double value; }\n          memory_long_double;\n\n  /* Finite values.  */\n  ASSERT (!isnanl (3.141L));\n  ASSERT (!isnanl (3.141e30L));\n  ASSERT (!isnanl (3.141e-30L));\n  ASSERT (!isnanl (-2.718L));\n  ASSERT (!isnanl (-2.718e30L));\n  ASSERT (!isnanl (-2.718e-30L));\n  ASSERT (!isnanl (0.0L));\n  ASSERT (!isnanl (minus_zerol));\n  /* Infinite values.  */\n  ASSERT (!isnanl (Infinityl ()));\n  ASSERT (!isnanl (- Infinityl ()));\n  /* Quiet NaN.  */\n  ASSERT (isnanl (NaNl ()));\n\n#if defined LDBL_EXPBIT0_WORD && defined LDBL_EXPBIT0_BIT\n  /* A bit pattern that is different from a Quiet NaN.  With a bit of luck,\n     it's a Signalling NaN.  */\n  {\n#if defined __powerpc__ && LDBL_MANT_DIG == 106\n    /* This is PowerPC \"double double\", a pair of two doubles.  Inf and Nan are\n       represented as the corresponding 64-bit IEEE values in the first double;\n       the second is ignored.  Manipulate only the first double.  */\n    #undef NWORDS\n    #define NWORDS \\\n      ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n#endif\n\n    memory_long_double m;\n    m.value = NaNl ();\n# if LDBL_EXPBIT0_BIT > 0\n    m.word[LDBL_EXPBIT0_WORD] ^= (unsigned int) 1 << (LDBL_EXPBIT0_BIT - 1);\n# else\n    m.word[LDBL_EXPBIT0_WORD + (LDBL_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      ^= (unsigned int) 1 << (sizeof (unsigned int) * CHAR_BIT - 1);\n# endif\n    m.word[LDBL_EXPBIT0_WORD + (LDBL_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      |= (unsigned int) 1 << LDBL_EXPBIT0_BIT;\n    ASSERT (isnanl (m.value));\n  }\n#endif\n\n#if ((defined __ia64 && LDBL_MANT_DIG == 64) || (defined __x86_64__ || defined __amd64__) || (defined __i386 || defined __i386__ || defined _I386 || defined _M_IX86 || defined _X86_)) && !HAVE_SAME_LONG_DOUBLE_AS_DOUBLE\n/* Representation of an 80-bit 'long double' as an initializer for a sequence\n   of 'unsigned int' words.  */\n# ifdef WORDS_BIGENDIAN\n#  define LDBL80_WORDS(exponent,manthi,mantlo) \\\n     { ((unsigned int) (exponent) << 16) | ((unsigned int) (manthi) >> 16), \\\n       ((unsigned int) (manthi) << 16) | ((unsigned int) (mantlo) >> 16),   \\\n       (unsigned int) (mantlo) << 16                                        \\\n     }\n# else\n#  define LDBL80_WORDS(exponent,manthi,mantlo) \\\n     { mantlo, manthi, exponent }\n# endif\n  { /* Quiet NaN.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0xFFFF, 0xC3333333, 0x00000000) };\n    ASSERT (isnanl (x.value));\n  }\n  {\n    /* Signalling NaN.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0xFFFF, 0x83333333, 0x00000000) };\n    ASSERT (isnanl (x.value));\n  }\n  /* isnanl should return something for noncanonical values.  */\n  { /* Pseudo-NaN.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0xFFFF, 0x40000001, 0x00000000) };\n    ASSERT (isnanl (x.value) || !isnanl (x.value));\n  }\n  { /* Pseudo-Infinity.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0xFFFF, 0x00000000, 0x00000000) };\n    ASSERT (isnanl (x.value) || !isnanl (x.value));\n  }\n  { /* Pseudo-Zero.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0x4004, 0x00000000, 0x00000000) };\n    ASSERT (isnanl (x.value) || !isnanl (x.value));\n  }\n  { /* Unnormalized number.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0x4000, 0x63333333, 0x00000000) };\n    ASSERT (isnanl (x.value) || !isnanl (x.value));\n  }\n  { /* Pseudo-Denormal.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0x0000, 0x83333333, 0x00000000) };\n    ASSERT (isnanl (x.value) || !isnanl (x.value));\n  }\n#endif\n\n  return 0;\n}",
      "lines": 104,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-iswblank.c": {
    "main": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Check that the function exist as a function or as a macro.  */\n  (void) iswblank (0);\n  /* Check that the isw* functions map WEOF to 0.  */\n  ASSERT (!iswblank (e));\n\n  return 0;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-langinfo.c": {
    "main": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-limits-h.c": {
    "main": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-locale.c": {
    "main": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "int\nmain ()\n{\n#if HAVE_NEWLOCALE\n  /* Check that the locale_t type and the LC_GLOBAL_LOCALE macro are defined.  */\n  locale_t b = LC_GLOBAL_LOCALE;\n  (void) b;\n#endif\n\n  /* Check that 'struct lconv' has the ISO C and POSIX specified members.  */\n  ls += sizeof (*l.decimal_point);\n  ls += sizeof (*l.thousands_sep);\n  ls += sizeof (*l.grouping);\n  ls += sizeof (*l.mon_decimal_point);\n  ls += sizeof (*l.mon_thousands_sep);\n  ls += sizeof (*l.mon_grouping);\n  ls += sizeof (*l.positive_sign);\n  ls += sizeof (*l.negative_sign);\n  ls += sizeof (*l.currency_symbol);\n  ls += sizeof (l.frac_digits);\n  ls += sizeof (l.p_cs_precedes);\n  ls += sizeof (l.p_sign_posn);\n  ls += sizeof (l.p_sep_by_space);\n  ls += sizeof (l.n_cs_precedes);\n  ls += sizeof (l.n_sign_posn);\n  ls += sizeof (l.n_sep_by_space);\n  ls += sizeof (*l.int_curr_symbol);\n  ls += sizeof (l.int_frac_digits);\n  ls += sizeof (l.int_p_cs_precedes);\n  ls += sizeof (l.int_p_sign_posn);\n  ls += sizeof (l.int_p_sep_by_space);\n  ls += sizeof (l.int_n_cs_precedes);\n  ls += sizeof (l.int_n_sign_posn);\n  ls += sizeof (l.int_n_sep_by_space);\n\n  return 0;\n}",
      "lines": 37,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-localename.c": {
    "test_locale_name": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "static void\ntest_locale_name (void)\n{\n  const char *name;\n\n  /* Check that gl_locale_name returns non-NULL.  */\n  ASSERT (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\") != NULL);\n\n  /* Get into a defined state,  */\n  setlocale (LC_ALL, \"en_US.UTF-8\");\n#if HAVE_NEWLOCALE && HAVE_USELOCALE\n  uselocale (LC_GLOBAL_LOCALE);\n#endif\n\n  /* Check that when all environment variables are unset,\n     gl_locale_name returns the default locale.  */\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LC_NUMERIC\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"),\n                  gl_locale_name_default ()) == 0);\n  ASSERT (strcmp (gl_locale_name (LC_NUMERIC, \"LC_NUMERIC\"),\n                  gl_locale_name_default ()) == 0);\n\n  /* Check that an empty environment variable is treated like an unset\n     environment variable.  */\n\n  setenv (\"LC_ALL\", \"\", 1);\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"),\n                  gl_locale_name_default ()) == 0);\n\n  unsetenv (\"LC_ALL\");\n  setenv (\"LC_CTYPE\", \"\", 1);\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"),\n                  gl_locale_name_default ()) == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"\", 1);\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"),\n                  gl_locale_name_default ()) == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  setenv (\"LANG\", \"\", 1);\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"),\n                  gl_locale_name_default ()) == 0);\n\n  /* Check that LC_ALL overrides the others, and LANG is overridden by the\n     others.  */\n\n  setenv (\"LC_ALL\", \"C\", 1);\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"), \"C\") == 0);\n\n  unsetenv (\"LC_ALL\");\n  setenv (\"LC_CTYPE\", \"C\", 1);\n  setenv (\"LC_MESSAGES\", \"C\", 1);\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"), \"C\") == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  setenv (\"LANG\", \"C\", 1);\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"), \"C\") == 0);\n\n  /* Check mixed situations.  */\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"fr_FR.UTF-8\", 1);\n  setenv (\"LANG\", \"de_DE.UTF-8\", 1);\n  if (setlocale (LC_ALL, \"\") != NULL)\n    {\n      name = gl_locale_name (LC_CTYPE, \"LC_CTYPE\");\n#if defined _WIN32 && !defined __CYGWIN__\n      /* On native Windows, here,\n           gl_locale_name_thread (LC_CTYPE, \"LC_CTYPE\")\n         returns NULL and\n           gl_locale_name_posix (LC_CTYPE, \"LC_CTYPE\")\n         returns either \"de_DE\" or \"de_DE.UTF-8\".  */\n      ASSERT (strcmp (name, \"de_DE\") == 0 || strcmp (name, \"de_DE.UTF-8\") == 0);\n#else\n      ASSERT (strcmp (name, \"de_DE.UTF-8\") == 0);\n#endif\n      name = gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\");\n      ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n    }\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"fr_FR.UTF-8\", 1);\n  unsetenv (\"LANG\");\n  if (setlocale (LC_ALL, \"\") != NULL)\n    {\n      name = gl_locale_name (LC_CTYPE, \"LC_CTYPE\");\n      ASSERT (strcmp (name, gl_locale_name_default ()) == 0);\n      name = gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\");\n      ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n    }\n\n#if HAVE_NEWLOCALE && HAVE_USELOCALE\n  /* Check that gl_locale_name considers the thread locale.  */\n  {\n    locale_t locale = newlocale (LC_ALL_MASK, \"fr_FR.UTF-8\", NULL);\n    if (locale != NULL)\n      {\n        uselocale (locale);\n        name = gl_locale_name (LC_CTYPE, \"LC_CTYPE\");\n        ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n        name = gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\");\n        ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n        uselocale (LC_GLOBAL_LOCALE);\n        freelocale (locale);\n      }\n  }\n\n  /* Check that gl_locale_name distinguishes different categories of the\n     thread locale, and that the name is the right one for each.  */\n  {\n    unsigned int i;\n\n    for (i = 0; i < SIZEOF (categories); i++)\n      {\n        int category_mask = categories[i].mask;\n        locale_t loc = newlocale (LC_ALL_MASK, \"fr_FR.UTF-8\", NULL);\n        if (loc != NULL)\n          {\n            locale_t locale = newlocale (category_mask, \"de_DE.UTF-8\", loc);\n            if (locale == NULL)\n              freelocale (loc);\n            else\n              {\n                unsigned int j;\n\n                uselocale (locale);\n                for (j = 0; j < SIZEOF (categories); j++)\n                  {\n                    const char *name_j =\n                      gl_locale_name (categories[j].cat, categories[j].string);\n                    if (j == i)\n                      ASSERT (strcmp (name_j, \"de_DE.UTF-8\") == 0);\n                    else\n                      ASSERT (strcmp (name_j, \"fr_FR.UTF-8\") == 0);\n                  }\n                uselocale (LC_GLOBAL_LOCALE);\n                freelocale (locale);\n              }\n          }\n      }\n  }\n#endif\n}",
      "lines": 173,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_locale_name_thread": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        488,
        1
      ],
      "content": "static void\ntest_locale_name_thread (void)\n{\n  /* Get into a defined state,  */\n  setlocale (LC_ALL, \"en_US.UTF-8\");\n\n#if HAVE_NEWLOCALE && HAVE_USELOCALE\n  /* Check that gl_locale_name_thread returns NULL when no thread locale is\n     set.  */\n  uselocale (LC_GLOBAL_LOCALE);\n  ASSERT (gl_locale_name_thread (LC_CTYPE, \"LC_CTYPE\") == NULL);\n  ASSERT (gl_locale_name_thread (LC_MESSAGES, \"LC_MESSAGES\") == NULL);\n\n  /* Check that gl_locale_name_thread considers the thread locale.  */\n  {\n    locale_t locale = newlocale (LC_ALL_MASK, \"fr_FR.UTF-8\", NULL);\n    if (locale != NULL)\n      {\n        const char *name;\n\n        uselocale (locale);\n        name = gl_locale_name_thread (LC_CTYPE, \"LC_CTYPE\");\n        ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n        name = gl_locale_name_thread (LC_MESSAGES, \"LC_MESSAGES\");\n        ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n        uselocale (LC_GLOBAL_LOCALE);\n        freelocale (locale);\n      }\n  }\n\n  /* Check that gl_locale_name_thread distinguishes different categories of the\n     thread locale, and that the name is the right one for each.  */\n  {\n    unsigned int i;\n\n    for (i = 0; i < SIZEOF (categories); i++)\n      {\n        int category_mask = categories[i].mask;\n        locale_t loc = newlocale (LC_ALL_MASK, \"fr_FR.UTF-8\", NULL);\n        if (loc != NULL)\n          {\n            locale_t locale = newlocale (category_mask, \"de_DE.UTF-8\", loc);\n            if (locale == NULL)\n              freelocale (loc);\n            else\n              {\n                unsigned int j;\n\n                uselocale (locale);\n                for (j = 0; j < SIZEOF (categories); j++)\n                  {\n                    const char *name_j =\n                      gl_locale_name_thread (categories[j].cat,\n                                             categories[j].string);\n                    if (j == i)\n                      ASSERT (strcmp (name_j, \"de_DE.UTF-8\") == 0);\n                    else\n                      ASSERT (strcmp (name_j, \"fr_FR.UTF-8\") == 0);\n                  }\n                uselocale (LC_GLOBAL_LOCALE);\n                freelocale (locale);\n              }\n          }\n      }\n  }\n\n  /* Check that gl_locale_name_thread returns a string that is allocated with\n     indefinite extent.  */\n  {\n    /* Try many locale names in turn, in order to defeat possible caches.  */\n    static const char * const choices[] =\n      {\n        \"C\",\n        \"POSIX\",\n        \"af_ZA\",\n        \"af_ZA.UTF-8\",\n        \"am_ET\",\n        \"am_ET.UTF-8\",\n        \"be_BY\",\n        \"be_BY.UTF-8\",\n        \"bg_BG\",\n        \"bg_BG.UTF-8\",\n        \"ca_ES\",\n        \"ca_ES.UTF-8\",\n        \"cs_CZ\",\n        \"cs_CZ.UTF-8\",\n        \"da_DK\",\n        \"da_DK.UTF-8\",\n        \"de_AT\",\n        \"de_AT.UTF-8\",\n        \"de_CH\",\n        \"de_CH.UTF-8\",\n        \"de_DE\",\n        \"de_DE.UTF-8\",\n        \"el_GR\",\n        \"el_GR.UTF-8\",\n        \"en_AU\",\n        \"en_AU.UTF-8\",\n        \"en_CA\",\n        \"en_CA.UTF-8\",\n        \"en_GB\",\n        \"en_GB.UTF-8\",\n        \"en_IE\",\n        \"en_IE.UTF-8\",\n        \"en_NZ\",\n        \"en_NZ.UTF-8\",\n        \"en_US\",\n        \"en_US.UTF-8\",\n        \"es_ES\",\n        \"es_ES.UTF-8\",\n        \"et_EE\",\n        \"et_EE.UTF-8\",\n        \"eu_ES\",\n        \"eu_ES.UTF-8\",\n        \"fi_FI\",\n        \"fi_FI.UTF-8\",\n        \"fr_BE\",\n        \"fr_BE.UTF-8\",\n        \"fr_CA\",\n        \"fr_CA.UTF-8\",\n        \"fr_CH\",\n        \"fr_CH.UTF-8\",\n        \"fr_FR\",\n        \"fr_FR.UTF-8\",\n        \"he_IL\",\n        \"he_IL.UTF-8\",\n        \"hr_HR\",\n        \"hr_HR.UTF-8\",\n        \"hu_HU\",\n        \"hu_HU.UTF-8\",\n        \"hy_AM\",\n        \"is_IS\",\n        \"is_IS.UTF-8\",\n        \"it_CH\",\n        \"it_CH.UTF-8\",\n        \"it_IT\",\n        \"it_IT.UTF-8\",\n        \"ja_JP.UTF-8\",\n        \"kk_KZ\",\n        \"kk_KZ.UTF-8\",\n        \"ko_KR.UTF-8\",\n        \"lt_LT\",\n        \"lt_LT.UTF-8\",\n        \"nl_BE\",\n        \"nl_BE.UTF-8\",\n        \"nl_NL\",\n        \"nl_NL.UTF-8\",\n        \"no_NO\",\n        \"no_NO.UTF-8\",\n        \"pl_PL\",\n        \"pl_PL.UTF-8\",\n        \"pt_BR\",\n        \"pt_BR.UTF-8\",\n        \"pt_PT\",\n        \"pt_PT.UTF-8\",\n        \"ro_RO\",\n        \"ro_RO.UTF-8\",\n        \"ru_RU\",\n        \"ru_RU.UTF-8\",\n        \"sk_SK\",\n        \"sk_SK.UTF-8\",\n        \"sl_SI\",\n        \"sl_SI.UTF-8\",\n        \"sv_SE\",\n        \"sv_SE.UTF-8\",\n        \"tr_TR\",\n        \"tr_TR.UTF-8\",\n        \"uk_UA\",\n        \"uk_UA.UTF-8\",\n        \"zh_CN\",\n        \"zh_CN.UTF-8\",\n        \"zh_HK\",\n        \"zh_HK.UTF-8\",\n        \"zh_TW\",\n        \"zh_TW.UTF-8\"\n      };\n    /* Remember which locales are available.  */\n    unsigned char /* bool */ available[SIZEOF (choices)];\n    /* Array of remembered results of gl_locale_name_thread.  */\n    const char *unsaved_names[SIZEOF (choices)][SIZEOF (categories)];\n    /* Array of remembered results of gl_locale_name_thread, stored in safe\n       memory.  */\n    char *saved_names[SIZEOF (choices)][SIZEOF (categories)];\n    unsigned int j;\n\n    for (j = 0; j < SIZEOF (choices); j++)\n      {\n        locale_t locale = newlocale (LC_ALL_MASK, choices[j], NULL);\n        available[j] = (locale != NULL);\n        if (locale != NULL)\n          {\n            unsigned int i;\n\n            uselocale (locale);\n            for (i = 0; i < SIZEOF (categories); i++)\n              {\n                unsaved_names[j][i] = gl_locale_name_thread (categories[i].cat, categories[i].string);\n                saved_names[j][i] = strdup (unsaved_names[j][i]);\n              }\n            uselocale (LC_GLOBAL_LOCALE);\n            freelocale (locale);\n          }\n      }\n    /* Verify the unsaved_names are still valid.  */\n    for (j = 0; j < SIZEOF (choices); j++)\n      if (available[j])\n        {\n          unsigned int i;\n\n          for (i = 0; i < SIZEOF (categories); i++)\n            ASSERT (strcmp (unsaved_names[j][i], saved_names[j][i]) == 0);\n        }\n    /* Allocate many locales, without freeing them.  This is an attempt at\n       overwriting as much of the previously allocated memory as possible.  */\n    for (j = SIZEOF (choices); j > 0; )\n      {\n        j--;\n        if (available[j])\n          {\n            locale_t locale = newlocale (LC_ALL_MASK, choices[j], NULL);\n            unsigned int i;\n\n            ASSERT (locale != NULL);\n            uselocale (locale);\n            for (i = 0; i < SIZEOF (categories); i++)\n              {\n                const char *name = gl_locale_name_thread (categories[i].cat, categories[i].string);\n                ASSERT (strcmp (unsaved_names[j][i], name) == 0);\n              }\n            uselocale (LC_GLOBAL_LOCALE);\n            freelocale (locale);\n          }\n      }\n    /* Verify the unsaved_names are still valid.  */\n    for (j = 0; j < SIZEOF (choices); j++)\n      if (available[j])\n        {\n          unsigned int i;\n\n          for (i = 0; i < SIZEOF (categories); i++)\n            {\n              ASSERT (strcmp (unsaved_names[j][i], saved_names[j][i]) == 0);\n              free (saved_names[j][i]);\n            }\n        }\n  }\n#else\n  /* Check that gl_locale_name_thread always returns NULL.  */\n  ASSERT (gl_locale_name_thread (LC_CTYPE, \"LC_CTYPE\") == NULL);\n  ASSERT (gl_locale_name_thread (LC_MESSAGES, \"LC_MESSAGES\") == NULL);\n#endif\n}",
      "lines": 252,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_locale_name_posix": {
      "start_point": [
        491,
        0
      ],
      "end_point": [
        626,
        1
      ],
      "content": "static void\ntest_locale_name_posix (void)\n{\n  const char *name;\n\n  /* Get into a defined state,  */\n  setlocale (LC_ALL, \"en_US.UTF-8\");\n#if HAVE_NEWLOCALE && HAVE_USELOCALE\n  uselocale (LC_GLOBAL_LOCALE);\n#endif\n\n  /* Check that when all environment variables are unset,\n     gl_locale_name_posix returns either NULL or the default locale.  */\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LC_NUMERIC\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (name == NULL || strcmp (name, gl_locale_name_default ()) == 0);\n  name = gl_locale_name_posix (LC_NUMERIC, \"LC_NUMERIC\");\n  ASSERT (name == NULL || strcmp (name, gl_locale_name_default ()) == 0);\n\n  /* Check that an empty environment variable is treated like an unset\n     environment variable.  */\n\n  setenv (\"LC_ALL\", \"\", 1);\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (name == NULL || strcmp (name, gl_locale_name_default ()) == 0);\n\n  unsetenv (\"LC_ALL\");\n  setenv (\"LC_CTYPE\", \"\", 1);\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (name == NULL || strcmp (name, gl_locale_name_default ()) == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"\", 1);\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (name == NULL || strcmp (name, gl_locale_name_default ()) == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  setenv (\"LANG\", \"\", 1);\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (name == NULL || strcmp (name, gl_locale_name_default ()) == 0);\n\n  /* Check that LC_ALL overrides the others, and LANG is overridden by the\n     others.  */\n\n  setenv (\"LC_ALL\", \"C\", 1);\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"C\") == 0);\n\n  unsetenv (\"LC_ALL\");\n  setenv (\"LC_CTYPE\", \"C\", 1);\n  setenv (\"LC_MESSAGES\", \"C\", 1);\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"C\") == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  setenv (\"LANG\", \"C\", 1);\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"C\") == 0);\n\n  /* Check mixed situations.  */\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"fr_FR.UTF-8\", 1);\n  setenv (\"LANG\", \"de_DE.UTF-8\", 1);\n  if (setlocale (LC_ALL, \"\") != NULL)\n    {\n      name = gl_locale_name_posix (LC_CTYPE, \"LC_CTYPE\");\n#if defined _WIN32 && !defined __CYGWIN__\n      ASSERT (strcmp (name, \"de_DE\") == 0 || strcmp (name, \"de_DE.UTF-8\") == 0);\n#else\n      ASSERT (strcmp (name, \"de_DE.UTF-8\") == 0);\n#endif\n      name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n      ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n    }\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"fr_FR.UTF-8\", 1);\n  unsetenv (\"LANG\");\n  if (setlocale (LC_ALL, \"\") != NULL)\n    {\n      name = gl_locale_name_posix (LC_CTYPE, \"LC_CTYPE\");\n      ASSERT (name == NULL || strcmp (name, gl_locale_name_default ()) == 0);\n      name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n      ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n    }\n\n#if HAVE_NEWLOCALE && HAVE_USELOCALE\n  /* Check that gl_locale_name_posix ignores the thread locale.  */\n  {\n    locale_t locale = newlocale (LC_ALL_MASK, \"fr_FR.UTF-8\", NULL);\n    if (locale != NULL)\n      {\n        unsetenv (\"LC_ALL\");\n        unsetenv (\"LC_CTYPE\");\n        unsetenv (\"LC_MESSAGES\");\n        setenv (\"LANG\", \"C\", 1);\n        setlocale (LC_ALL, \"\");\n        uselocale (locale);\n        name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n        ASSERT (strcmp (name, \"C\") == 0);\n        uselocale (LC_GLOBAL_LOCALE);\n        freelocale (locale);\n      }\n  }\n#endif\n}",
      "lines": 136,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_locale_name_environ": {
      "start_point": [
        629,
        0
      ],
      "end_point": [
        740,
        1
      ],
      "content": "static void\ntest_locale_name_environ (void)\n{\n  const char *name;\n\n  /* Get into a defined state,  */\n  setlocale (LC_ALL, \"en_US.UTF-8\");\n#if HAVE_NEWLOCALE && HAVE_USELOCALE\n  uselocale (LC_GLOBAL_LOCALE);\n#endif\n\n  /* Check that when all environment variables are unset,\n     gl_locale_name_environ returns NULL.  */\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LC_NUMERIC\");\n  unsetenv (\"LANG\");\n  ASSERT (gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\") == NULL);\n  ASSERT (gl_locale_name_environ (LC_NUMERIC, \"LC_NUMERIC\") == NULL);\n\n  /* Check that an empty environment variable is treated like an unset\n     environment variable.  */\n\n  setenv (\"LC_ALL\", \"\", 1);\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  ASSERT (gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\") == NULL);\n\n  unsetenv (\"LC_ALL\");\n  setenv (\"LC_CTYPE\", \"\", 1);\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  ASSERT (gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\") == NULL);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"\", 1);\n  unsetenv (\"LANG\");\n  ASSERT (gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\") == NULL);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  setenv (\"LANG\", \"\", 1);\n  ASSERT (gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\") == NULL);\n\n  /* Check that LC_ALL overrides the others, and LANG is overridden by the\n     others.  */\n\n  setenv (\"LC_ALL\", \"C\", 1);\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  name = gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"C\") == 0);\n\n  unsetenv (\"LC_ALL\");\n  setenv (\"LC_CTYPE\", \"C\", 1);\n  setenv (\"LC_MESSAGES\", \"C\", 1);\n  unsetenv (\"LANG\");\n  name = gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"C\") == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  setenv (\"LANG\", \"C\", 1);\n  name = gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"C\") == 0);\n\n  /* Check mixed situations.  */\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"fr_FR.UTF-8\", 1);\n  setenv (\"LANG\", \"de_DE.UTF-8\", 1);\n  name = gl_locale_name_environ (LC_CTYPE, \"LC_CTYPE\");\n  ASSERT (strcmp (name, \"de_DE.UTF-8\") == 0);\n  name = gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"fr_FR.UTF-8\", 1);\n  unsetenv (\"LANG\");\n  name = gl_locale_name_environ (LC_CTYPE, \"LC_CTYPE\");\n  ASSERT (name == NULL);\n  name = gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n\n#if HAVE_NEWLOCALE && HAVE_USELOCALE\n  /* Check that gl_locale_name_environ ignores the thread locale.  */\n  {\n    locale_t locale = newlocale (LC_ALL_MASK, \"fr_FR.UTF-8\", NULL);\n    if (locale != NULL)\n      {\n        unsetenv (\"LC_ALL\");\n        unsetenv (\"LC_CTYPE\");\n        unsetenv (\"LC_MESSAGES\");\n        setenv (\"LANG\", \"C\", 1);\n        setlocale (LC_ALL, \"\");\n        uselocale (locale);\n        name = gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\");\n        ASSERT (strcmp (name, \"C\") == 0);\n        uselocale (LC_GLOBAL_LOCALE);\n        freelocale (locale);\n      }\n  }\n#endif\n}",
      "lines": 112,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_locale_name_default": {
      "start_point": [
        743,
        0
      ],
      "end_point": [
        769,
        1
      ],
      "content": "static void\ntest_locale_name_default (void)\n{\n  const char *name = gl_locale_name_default ();\n\n  ASSERT (name != NULL);\n\n  /* Only Mac OS X and Windows have a facility for the user to set the default\n     locale.  */\n#if !((defined __APPLE__ && defined __MACH__) || (defined _WIN32 || defined __CYGWIN__))\n  ASSERT (strcmp (name, \"C\") == 0);\n#endif\n\n#if HAVE_NEWLOCALE && HAVE_USELOCALE\n  /* Check that gl_locale_name_default ignores the thread locale.  */\n  {\n    locale_t locale = newlocale (LC_ALL_MASK, \"fr_FR.UTF-8\", NULL);\n    if (locale != NULL)\n      {\n        uselocale (locale);\n        ASSERT (strcmp (gl_locale_name_default (), name) == 0);\n        uselocale (LC_GLOBAL_LOCALE);\n        freelocale (locale);\n      }\n  }\n#endif\n}",
      "lines": 27,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        771,
        0
      ],
      "end_point": [
        781,
        1
      ],
      "content": "int\nmain ()\n{\n  test_locale_name ();\n  test_locale_name_thread ();\n  test_locale_name_posix ();\n  test_locale_name_environ ();\n  test_locale_name_default ();\n\n  return 0;\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-lock.c": {
    "init_atomic_int": [
      {
        "start_point": [
          137,
          0
        ],
        "end_point": [
          140,
          1
        ],
        "content": "static void\ninit_atomic_int (struct atomic_int *ai)\n{\n}",
        "lines": 4,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          159,
          0
        ],
        "end_point": [
          163,
          1
        ],
        "content": "static void\ninit_atomic_int (struct atomic_int *ai)\n{\n  sem_init (&ai->semaphore, 0, 0);\n}",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          170,
          0
        ],
        "end_point": [
          206,
          1
        ],
        "content": "static void\ninit_atomic_int (struct atomic_int *ai)\n{\n  sem_t *s;\n  unsigned int count;\n  for (count = 0; ; count++)\n    {\n      char name[80];\n      /* Use getpid() in the name, so that different processes running at the\n         same time will not interfere.  Use ai in the name, so that different\n         atomic_int in the same process will not interfere.  Use a count in\n         the name, so that even in the (unlikely) case that a semaphore with\n         the specified name already exists, we can try a different name.  */\n      sprintf (name, \"test-lock-%lu-%p-%u\",\n               (unsigned long) getpid (), ai, count);\n      s = sem_open (name, O_CREAT | O_EXCL, 0600, 0);\n      if (s == SEM_FAILED)\n        {\n          if (errno == EEXIST)\n            /* Retry with a different name.  */\n            continue;\n          else\n            {\n              perror (\"sem_open failed\");\n              abort ();\n            }\n        }\n      else\n        {\n          /* Try not to leave a semaphore hanging around on the file system\n             eternally, if we can avoid it.  */\n          sem_unlink (name);\n          break;\n        }\n    }\n  ai->semaphore = s;\n}",
        "lines": 37,
        "depth": 13,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          237,
          0
        ],
        "end_point": [
          241,
          1
        ],
        "content": "static void\ninit_atomic_int (struct atomic_int *ai)\n{\n  gl_lock_init (ai->lock);\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      }
    ],
    "get_atomic_int_value": [
      {
        "start_point": [
          141,
          0
        ],
        "end_point": [
          145,
          1
        ],
        "content": "static int\nget_atomic_int_value (struct atomic_int *ai)\n{\n  return ai->value;\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          208,
          0
        ],
        "end_point": [
          221,
          1
        ],
        "content": "static int\nget_atomic_int_value (struct atomic_int *ai)\n{\n  if (sem_trywait (atomic_int_semaphore (ai)) == 0)\n    {\n      if (sem_post (atomic_int_semaphore (ai)))\n        abort ();\n      return 1;\n    }\n  else if (errno == EAGAIN)\n    return 0;\n  else\n    abort ();\n}",
        "lines": 14,
        "depth": 11,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          242,
          0
        ],
        "end_point": [
          249,
          1
        ],
        "content": "static int\nget_atomic_int_value (struct atomic_int *ai)\n{\n  gl_lock_lock (ai->lock);\n  int ret = ai->value;\n  gl_lock_unlock (ai->lock);\n  return ret;\n}",
        "lines": 8,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      }
    ],
    "set_atomic_int_value": [
      {
        "start_point": [
          146,
          0
        ],
        "end_point": [
          150,
          1
        ],
        "content": "static void\nset_atomic_int_value (struct atomic_int *ai, int new_value)\n{\n  ai->value = new_value;\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          222,
          0
        ],
        "end_point": [
          231,
          1
        ],
        "content": "static void\nset_atomic_int_value (struct atomic_int *ai, int new_value)\n{\n  if (new_value == 0)\n    /* It's already initialized with 0.  */\n    return;\n  /* To set the value 1: */\n  if (sem_post (atomic_int_semaphore (ai)))\n    abort ();\n}",
        "lines": 10,
        "depth": 9,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          250,
          0
        ],
        "end_point": [
          256,
          1
        ],
        "content": "static void\nset_atomic_int_value (struct atomic_int *ai, int new_value)\n{\n  gl_lock_lock (ai->lock);\n  ai->value = new_value;\n  gl_lock_unlock (ai->lock);\n}",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      }
    ],
    "random_account": {
      "start_point": [
        263,
        0
      ],
      "end_point": [
        267,
        1
      ],
      "content": "static int\nrandom_account (void)\n{\n  return ((unsigned int) rand () >> 3) % ACCOUNT_COUNT;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_accounts": {
      "start_point": [
        269,
        0
      ],
      "end_point": [
        279,
        1
      ],
      "content": "static void\ncheck_accounts (void)\n{\n  int i, sum;\n\n  sum = 0;\n  for (i = 0; i < ACCOUNT_COUNT; i++)\n    sum += account[i];\n  if (sum != ACCOUNT_COUNT * 1000)\n    abort ();\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "lock_mutator_thread": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        324,
        1
      ],
      "content": "static void *\nlock_mutator_thread (void *arg)\n{\n  int repeat;\n\n  for (repeat = REPEAT_COUNT; repeat > 0; repeat--)\n    {\n      int i1, i2, value;\n\n      dbgprintf (\"Mutator %p before lock\\n\", gl_thread_self_pointer ());\n      gl_lock_lock (my_lock);\n      dbgprintf (\"Mutator %p after  lock\\n\", gl_thread_self_pointer ());\n\n      i1 = random_account ();\n      i2 = random_account ();\n      value = ((unsigned int) rand () >> 3) % 10;\n      account[i1] += value;\n      account[i2] -= value;\n\n      dbgprintf (\"Mutator %p before unlock\\n\", gl_thread_self_pointer ());\n      gl_lock_unlock (my_lock);\n      dbgprintf (\"Mutator %p after  unlock\\n\", gl_thread_self_pointer ());\n\n      dbgprintf (\"Mutator %p before check lock\\n\", gl_thread_self_pointer ());\n      gl_lock_lock (my_lock);\n      check_accounts ();\n      gl_lock_unlock (my_lock);\n      dbgprintf (\"Mutator %p after  check unlock\\n\", gl_thread_self_pointer ());\n\n      yield ();\n    }\n\n  dbgprintf (\"Mutator %p dying.\\n\", gl_thread_self_pointer ());\n  return NULL;\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nlock_mutator_thread (void *arg)",
        "*"
      ]
    },
    "lock_checker_thread": {
      "start_point": [
        328,
        0
      ],
      "end_point": [
        344,
        1
      ],
      "content": "static void *\nlock_checker_thread (void *arg)\n{\n  while (get_atomic_int_value (&lock_checker_done) == 0)\n    {\n      dbgprintf (\"Checker %p before check lock\\n\", gl_thread_self_pointer ());\n      gl_lock_lock (my_lock);\n      check_accounts ();\n      gl_lock_unlock (my_lock);\n      dbgprintf (\"Checker %p after  check unlock\\n\", gl_thread_self_pointer ());\n\n      yield ();\n    }\n\n  dbgprintf (\"Checker %p dying.\\n\", gl_thread_self_pointer ());\n  return NULL;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nlock_checker_thread (void *arg)",
        "*"
      ]
    },
    "test_lock": {
      "start_point": [
        346,
        0
      ],
      "end_point": [
        370,
        1
      ],
      "content": "static void\ntest_lock (void)\n{\n  int i;\n  gl_thread_t checkerthread;\n  gl_thread_t threads[THREAD_COUNT];\n\n  /* Initialization.  */\n  for (i = 0; i < ACCOUNT_COUNT; i++)\n    account[i] = 1000;\n  init_atomic_int (&lock_checker_done);\n  set_atomic_int_value (&lock_checker_done, 0);\n\n  /* Spawn the threads.  */\n  checkerthread = gl_thread_create (lock_checker_thread, NULL);\n  for (i = 0; i < THREAD_COUNT; i++)\n    threads[i] = gl_thread_create (lock_mutator_thread, NULL);\n\n  /* Wait for the threads to terminate.  */\n  for (i = 0; i < THREAD_COUNT; i++)\n    gl_thread_join (threads[i], NULL);\n  set_atomic_int_value (&lock_checker_done, 1);\n  gl_thread_join (checkerthread, NULL);\n  check_accounts ();\n}",
      "lines": 25,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rwlock_mutator_thread": {
      "start_point": [
        381,
        0
      ],
      "end_point": [
        409,
        1
      ],
      "content": "static void *\nrwlock_mutator_thread (void *arg)\n{\n  int repeat;\n\n  for (repeat = REPEAT_COUNT; repeat > 0; repeat--)\n    {\n      int i1, i2, value;\n\n      dbgprintf (\"Mutator %p before wrlock\\n\", gl_thread_self_pointer ());\n      gl_rwlock_wrlock (my_rwlock);\n      dbgprintf (\"Mutator %p after  wrlock\\n\", gl_thread_self_pointer ());\n\n      i1 = random_account ();\n      i2 = random_account ();\n      value = ((unsigned int) rand () >> 3) % 10;\n      account[i1] += value;\n      account[i2] -= value;\n\n      dbgprintf (\"Mutator %p before unlock\\n\", gl_thread_self_pointer ());\n      gl_rwlock_unlock (my_rwlock);\n      dbgprintf (\"Mutator %p after  unlock\\n\", gl_thread_self_pointer ());\n\n      yield ();\n    }\n\n  dbgprintf (\"Mutator %p dying.\\n\", gl_thread_self_pointer ());\n  return NULL;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nrwlock_mutator_thread (void *arg)",
        "*"
      ]
    },
    "rwlock_checker_thread": {
      "start_point": [
        413,
        0
      ],
      "end_point": [
        429,
        1
      ],
      "content": "static void *\nrwlock_checker_thread (void *arg)\n{\n  while (get_atomic_int_value (&rwlock_checker_done) == 0)\n    {\n      dbgprintf (\"Checker %p before check rdlock\\n\", gl_thread_self_pointer ());\n      gl_rwlock_rdlock (my_rwlock);\n      check_accounts ();\n      gl_rwlock_unlock (my_rwlock);\n      dbgprintf (\"Checker %p after  check unlock\\n\", gl_thread_self_pointer ());\n\n      yield ();\n    }\n\n  dbgprintf (\"Checker %p dying.\\n\", gl_thread_self_pointer ());\n  return NULL;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nrwlock_checker_thread (void *arg)",
        "*"
      ]
    },
    "test_rwlock": {
      "start_point": [
        431,
        0
      ],
      "end_point": [
        457,
        1
      ],
      "content": "static void\ntest_rwlock (void)\n{\n  int i;\n  gl_thread_t checkerthreads[THREAD_COUNT];\n  gl_thread_t threads[THREAD_COUNT];\n\n  /* Initialization.  */\n  for (i = 0; i < ACCOUNT_COUNT; i++)\n    account[i] = 1000;\n  init_atomic_int (&rwlock_checker_done);\n  set_atomic_int_value (&rwlock_checker_done, 0);\n\n  /* Spawn the threads.  */\n  for (i = 0; i < THREAD_COUNT; i++)\n    checkerthreads[i] = gl_thread_create (rwlock_checker_thread, NULL);\n  for (i = 0; i < THREAD_COUNT; i++)\n    threads[i] = gl_thread_create (rwlock_mutator_thread, NULL);\n\n  /* Wait for the threads to terminate.  */\n  for (i = 0; i < THREAD_COUNT; i++)\n    gl_thread_join (threads[i], NULL);\n  set_atomic_int_value (&rwlock_checker_done, 1);\n  for (i = 0; i < THREAD_COUNT; i++)\n    gl_thread_join (checkerthreads[i], NULL);\n  check_accounts ();\n}",
      "lines": 27,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "recshuffle": {
      "start_point": [
        468,
        0
      ],
      "end_point": [
        490,
        1
      ],
      "content": "static void\nrecshuffle (void)\n{\n  int i1, i2, value;\n\n  dbgprintf (\"Mutator %p before lock\\n\", gl_thread_self_pointer ());\n  gl_recursive_lock_lock (my_reclock);\n  dbgprintf (\"Mutator %p after  lock\\n\", gl_thread_self_pointer ());\n\n  i1 = random_account ();\n  i2 = random_account ();\n  value = ((unsigned int) rand () >> 3) % 10;\n  account[i1] += value;\n  account[i2] -= value;\n\n  /* Recursive with probability 0.5.  */\n  if (((unsigned int) rand () >> 3) % 2)\n    recshuffle ();\n\n  dbgprintf (\"Mutator %p before unlock\\n\", gl_thread_self_pointer ());\n  gl_recursive_lock_unlock (my_reclock);\n  dbgprintf (\"Mutator %p after  unlock\\n\", gl_thread_self_pointer ());\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "reclock_mutator_thread": {
      "start_point": [
        492,
        0
      ],
      "end_point": [
        512,
        1
      ],
      "content": "static void *\nreclock_mutator_thread (void *arg)\n{\n  int repeat;\n\n  for (repeat = REPEAT_COUNT; repeat > 0; repeat--)\n    {\n      recshuffle ();\n\n      dbgprintf (\"Mutator %p before check lock\\n\", gl_thread_self_pointer ());\n      gl_recursive_lock_lock (my_reclock);\n      check_accounts ();\n      gl_recursive_lock_unlock (my_reclock);\n      dbgprintf (\"Mutator %p after  check unlock\\n\", gl_thread_self_pointer ());\n\n      yield ();\n    }\n\n  dbgprintf (\"Mutator %p dying.\\n\", gl_thread_self_pointer ());\n  return NULL;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nreclock_mutator_thread (void *arg)",
        "*"
      ]
    },
    "reclock_checker_thread": {
      "start_point": [
        516,
        0
      ],
      "end_point": [
        532,
        1
      ],
      "content": "static void *\nreclock_checker_thread (void *arg)\n{\n  while (get_atomic_int_value (&reclock_checker_done) == 0)\n    {\n      dbgprintf (\"Checker %p before check lock\\n\", gl_thread_self_pointer ());\n      gl_recursive_lock_lock (my_reclock);\n      check_accounts ();\n      gl_recursive_lock_unlock (my_reclock);\n      dbgprintf (\"Checker %p after  check unlock\\n\", gl_thread_self_pointer ());\n\n      yield ();\n    }\n\n  dbgprintf (\"Checker %p dying.\\n\", gl_thread_self_pointer ());\n  return NULL;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nreclock_checker_thread (void *arg)",
        "*"
      ]
    },
    "test_recursive_lock": {
      "start_point": [
        534,
        0
      ],
      "end_point": [
        558,
        1
      ],
      "content": "static void\ntest_recursive_lock (void)\n{\n  int i;\n  gl_thread_t checkerthread;\n  gl_thread_t threads[THREAD_COUNT];\n\n  /* Initialization.  */\n  for (i = 0; i < ACCOUNT_COUNT; i++)\n    account[i] = 1000;\n  init_atomic_int (&reclock_checker_done);\n  set_atomic_int_value (&reclock_checker_done, 0);\n\n  /* Spawn the threads.  */\n  checkerthread = gl_thread_create (reclock_checker_thread, NULL);\n  for (i = 0; i < THREAD_COUNT; i++)\n    threads[i] = gl_thread_create (reclock_mutator_thread, NULL);\n\n  /* Wait for the threads to terminate.  */\n  for (i = 0; i < THREAD_COUNT; i++)\n    gl_thread_join (threads[i], NULL);\n  set_atomic_int_value (&reclock_checker_done, 1);\n  gl_thread_join (checkerthread, NULL);\n  check_accounts ();\n}",
      "lines": 25,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "once_execute": {
      "start_point": [
        578,
        0
      ],
      "end_point": [
        584,
        1
      ],
      "content": "static void\nonce_execute (void)\n{\n  gl_lock_lock (performed_lock);\n  performed++;\n  gl_lock_unlock (performed_lock);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "once_contender_thread": {
      "start_point": [
        586,
        0
      ],
      "end_point": [
        622,
        1
      ],
      "content": "static void *\nonce_contender_thread (void *arg)\n{\n  int id = (int) (long) arg;\n  int repeat;\n\n  for (repeat = 0; repeat <= REPEAT_COUNT; repeat++)\n    {\n      /* Tell the main thread that we're ready.  */\n      gl_lock_lock (ready_lock[id]);\n      ready[id] = 1;\n      gl_lock_unlock (ready_lock[id]);\n\n      if (repeat == REPEAT_COUNT)\n        break;\n\n      dbgprintf (\"Contender %p waiting for signal for round %d\\n\",\n                 gl_thread_self_pointer (), repeat);\n#if ENABLE_LOCKING\n      /* Wait for the signal to go.  */\n      gl_rwlock_rdlock (fire_signal[repeat]);\n      /* And don't hinder the others (if the scheduler is unfair).  */\n      gl_rwlock_unlock (fire_signal[repeat]);\n#else\n      /* Wait for the signal to go.  */\n      while (fire_signal_state <= repeat)\n        yield ();\n#endif\n      dbgprintf (\"Contender %p got the     signal for round %d\\n\",\n                 gl_thread_self_pointer (), repeat);\n\n      /* Contend for execution.  */\n      gl_once (once_control, once_execute);\n    }\n\n  return NULL;\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nonce_contender_thread (void *arg)",
        "*"
      ]
    },
    "test_once": {
      "start_point": [
        624,
        0
      ],
      "end_point": [
        707,
        1
      ],
      "content": "static void\ntest_once (void)\n{\n  int i, repeat;\n  gl_thread_t threads[THREAD_COUNT];\n\n  /* Initialize all variables.  */\n  for (i = 0; i < THREAD_COUNT; i++)\n    {\n      ready[i] = 0;\n      gl_lock_init (ready_lock[i]);\n    }\n#if ENABLE_LOCKING\n  for (i = 0; i < REPEAT_COUNT; i++)\n    gl_rwlock_init (fire_signal[i]);\n#else\n  fire_signal_state = 0;\n#endif\n\n  /* Block all fire_signals.  */\n  for (i = REPEAT_COUNT-1; i >= 0; i--)\n    gl_rwlock_wrlock (fire_signal[i]);\n\n  /* Spawn the threads.  */\n  for (i = 0; i < THREAD_COUNT; i++)\n    threads[i] = gl_thread_create (once_contender_thread, (void *) (long) i);\n\n  for (repeat = 0; repeat <= REPEAT_COUNT; repeat++)\n    {\n      /* Wait until every thread is ready.  */\n      dbgprintf (\"Main thread before synchronizing for round %d\\n\", repeat);\n      for (;;)\n        {\n          int ready_count = 0;\n          for (i = 0; i < THREAD_COUNT; i++)\n            {\n              gl_lock_lock (ready_lock[i]);\n              ready_count += ready[i];\n              gl_lock_unlock (ready_lock[i]);\n            }\n          if (ready_count == THREAD_COUNT)\n            break;\n          yield ();\n        }\n      dbgprintf (\"Main thread after  synchronizing for round %d\\n\", repeat);\n\n      if (repeat > 0)\n        {\n          /* Check that exactly one thread executed the once_execute()\n             function.  */\n          if (performed != 1)\n            abort ();\n        }\n\n      if (repeat == REPEAT_COUNT)\n        break;\n\n      /* Preparation for the next round: Initialize once_control.  */\n      memcpy (&once_control, &fresh_once, sizeof (gl_once_t));\n\n      /* Preparation for the next round: Reset the performed counter.  */\n      performed = 0;\n\n      /* Preparation for the next round: Reset the ready flags.  */\n      for (i = 0; i < THREAD_COUNT; i++)\n        {\n          gl_lock_lock (ready_lock[i]);\n          ready[i] = 0;\n          gl_lock_unlock (ready_lock[i]);\n        }\n\n      /* Signal all threads simultaneously.  */\n      dbgprintf (\"Main thread giving signal for round %d\\n\", repeat);\n#if ENABLE_LOCKING\n      gl_rwlock_unlock (fire_signal[repeat]);\n#else\n      fire_signal_state = repeat + 1;\n#endif\n    }\n\n  /* Wait for the threads to terminate.  */\n  for (i = 0; i < THREAD_COUNT; i++)\n    gl_thread_join (threads[i], NULL);\n}",
      "lines": 84,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": [
      {
        "start_point": [
          712,
          0
        ],
        "end_point": [
          742,
          1
        ],
        "content": "int\nmain ()\n{\n#if TEST_PTH_THREADS\n  if (!pth_init ())\n    abort ();\n#endif\n\n#if DO_TEST_LOCK\n  printf (\"Starting test_lock ...\"); fflush (stdout);\n  test_lock ();\n  printf (\" OK\\n\"); fflush (stdout);\n#endif\n#if DO_TEST_RWLOCK\n  printf (\"Starting test_rwlock ...\"); fflush (stdout);\n  test_rwlock ();\n  printf (\" OK\\n\"); fflush (stdout);\n#endif\n#if DO_TEST_RECURSIVE_LOCK\n  printf (\"Starting test_recursive_lock ...\"); fflush (stdout);\n  test_recursive_lock ();\n  printf (\" OK\\n\"); fflush (stdout);\n#endif\n#if DO_TEST_ONCE\n  printf (\"Starting test_once ...\"); fflush (stdout);\n  test_once ();\n  printf (\" OK\\n\"); fflush (stdout);\n#endif\n\n  return 0;\n}",
        "lines": 31,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          750,
          0
        ],
        "end_point": [
          755,
          1
        ],
        "content": "int\nmain ()\n{\n  fputs (\"Skipping test: multithreading not enabled\\n\", stderr);\n  return 77;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/tests/test-malloca.c": {
    "do_allocation": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "static void\ndo_allocation (int n)\n{\n  void *ptr = malloca (n);\n  freea (ptr);\n  safe_alloca (n);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nmain ()\n{\n  int i;\n\n  /* This slows down malloc a lot.  */\n  unsetenv (\"MALLOC_PERTURB_\");\n\n  /* Repeat a lot of times, to make sure there's no memory leak.  */\n  for (i = 0; i < 50000; i++)\n    {\n      /* Try various values.\n         n = 0 gave a crash on Alpha with gcc-2.5.8.\n         Some versions of Mac OS X have a stack size limit of 512 KB.  */\n      func (34);\n      func (134);\n      func (399);\n      func (510823);\n      func (129321);\n      func (0);\n      func (4070);\n      func (4095);\n      func (1);\n      func (16582);\n    }\n\n  return 0;\n}",
      "lines": 28,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-math.c": {
    "numeric_equalf": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static int\nnumeric_equalf (float x, float y)\n{\n  return x == y;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "numeric_equald": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "static int\nnumeric_equald (double x, double y)\n{\n  return x == y;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "numeric_equall": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static int\nnumeric_equall (long double x, long double y)\n{\n  return x == y;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "int\nmain (void)\n{\n  double d = NAN;\n  double zero = 0.0;\n  ASSERT (!numeric_equald (d, d));\n\n  d = HUGE_VAL;\n  ASSERT (numeric_equald (d, 1.0 / zero));\n\n  ASSERT (numeric_equalf (HUGE_VALF, HUGE_VALF + HUGE_VALF));\n\n  ASSERT (numeric_equald (HUGE_VAL, HUGE_VAL + HUGE_VAL));\n\n  ASSERT (numeric_equall (HUGE_VALL, HUGE_VALL + HUGE_VALL));\n\n  /* Check the value of FP_ILOGB0.  */\n  ASSERT (FP_ILOGB0 == INT_MIN || FP_ILOGB0 == - INT_MAX);\n\n  /* Check the value of FP_ILOGBNAN.  */\n  ASSERT (FP_ILOGBNAN == INT_MIN || FP_ILOGBNAN == INT_MAX);\n\n  return 0;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-mbrtowc-w32.c": {
    "test_one_locale": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        693,
        1
      ],
      "content": "static int\ntest_one_locale (const char *name, int codepage)\n{\n  mbstate_t state;\n  wchar_t wc;\n  size_t ret;\n\n# if 1\n  /* Portable code to set the locale.  */\n  {\n    char name_with_codepage[1024];\n\n    sprintf (name_with_codepage, \"%s.%d\", name, codepage);\n\n    /* Set the locale.  */\n    if (setlocale (LC_ALL, name_with_codepage) == NULL)\n      return 77;\n  }\n# else\n  /* Hacky way to set a locale.codepage combination that setlocale() refuses\n     to set.  */\n  {\n    /* Codepage of the current locale, set with setlocale().\n       Not necessarily the same as GetACP().  */\n    extern __declspec(dllimport) unsigned int __lc_codepage;\n\n    /* Set the locale.  */\n    if (setlocale (LC_ALL, name) == NULL)\n      return 77;\n\n    /* Clobber the codepage and MB_CUR_MAX, both set by setlocale().  */\n    __lc_codepage = codepage;\n    switch (codepage)\n      {\n      case 1252:\n      case 1256:\n        MB_CUR_MAX = 1;\n        break;\n      case 932:\n      case 950:\n      case 936:\n        MB_CUR_MAX = 2;\n        break;\n      case 54936:\n      case 65001:\n        MB_CUR_MAX = 4;\n        break;\n      }\n\n    /* Test whether the codepage is really available.  */\n    memset (&state, '\\0', sizeof (mbstate_t));\n    if (mbrtowc (&wc, \" \", 1, &state) == (size_t)(-1))\n      return 77;\n  }\n# endif\n\n  /* Test zero-length input.  */\n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    wc = (wchar_t) 0xBADFACE;\n    ret = mbrtowc (&wc, \"x\", 0, &state);\n    /* gnulib's implementation returns (size_t)(-2).\n       The AIX 5.1 implementation returns (size_t)(-1).\n       glibc's implementation returns 0.  */\n    ASSERT (ret == (size_t)(-2) || ret == (size_t)(-1) || ret == 0);\n    ASSERT (mbsinit (&state));\n  }\n\n  /* Test NUL byte input.  */\n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    wc = (wchar_t) 0xBADFACE;\n    ret = mbrtowc (&wc, \"\", 1, &state);\n    ASSERT (ret == 0);\n    ASSERT (wc == 0);\n    ASSERT (mbsinit (&state));\n    ret = mbrtowc (NULL, \"\", 1, &state);\n    ASSERT (ret == 0);\n    ASSERT (mbsinit (&state));\n  }\n\n  /* Test single-byte input.  */\n  {\n    int c;\n    char buf[1];\n\n    memset (&state, '\\0', sizeof (mbstate_t));\n    for (c = 0; c < 0x100; c++)\n      switch (c)\n        {\n        case '\\t': case '\\v': case '\\f':\n        case ' ': case '!': case '\"': case '#': case '%':\n        case '&': case '\\'': case '(': case ')': case '*':\n        case '+': case ',': case '-': case '.': case '/':\n        case '0': case '1': case '2': case '3': case '4':\n        case '5': case '6': case '7': case '8': case '9':\n        case ':': case ';': case '<': case '=': case '>':\n        case '?':\n        case 'A': case 'B': case 'C': case 'D': case 'E':\n        case 'F': case 'G': case 'H': case 'I': case 'J':\n        case 'K': case 'L': case 'M': case 'N': case 'O':\n        case 'P': case 'Q': case 'R': case 'S': case 'T':\n        case 'U': case 'V': case 'W': case 'X': case 'Y':\n        case 'Z':\n        case '[': case '\\\\': case ']': case '^': case '_':\n        case 'a': case 'b': case 'c': case 'd': case 'e':\n        case 'f': case 'g': case 'h': case 'i': case 'j':\n        case 'k': case 'l': case 'm': case 'n': case 'o':\n        case 'p': case 'q': case 'r': case 's': case 't':\n        case 'u': case 'v': case 'w': case 'x': case 'y':\n        case 'z': case '{': case '|': case '}': case '~':\n          /* c is in the ISO C \"basic character set\".  */\n          buf[0] = c;\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, buf, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == c);\n          ASSERT (mbsinit (&state));\n          ret = mbrtowc (NULL, buf, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (mbsinit (&state));\n          break;\n        }\n  }\n\n  /* Test special calling convention, passing a NULL pointer.  */\n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    wc = (wchar_t) 0xBADFACE;\n    ret = mbrtowc (&wc, NULL, 5, &state);\n    ASSERT (ret == 0);\n    ASSERT (wc == (wchar_t) 0xBADFACE);\n    ASSERT (mbsinit (&state));\n  }\n\n  switch (codepage)\n    {\n    case 1252:\n      /* Locale encoding is CP1252, an extension of ISO-8859-1.  */\n      {\n        char input[] = \"B\\374\\337er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'B');\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 1, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == (unsigned char) '\\374');\n        ASSERT (wc == 0x00FC);\n        ASSERT (mbsinit (&state));\n        input[1] = '\\0';\n\n        /* Test support of NULL first argument.  */\n        ret = mbrtowc (NULL, input + 2, 3, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 2, 3, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == (unsigned char) '\\337');\n        ASSERT (wc == 0x00DF);\n        ASSERT (mbsinit (&state));\n        input[2] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 3, 2, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'e');\n        ASSERT (mbsinit (&state));\n        input[3] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 4, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'r');\n        ASSERT (mbsinit (&state));\n      }\n      return 0;\n\n    case 1256:\n      /* Locale encoding is CP1256, not the same as ISO-8859-6.  */\n      {\n        char input[] = \"x\\302\\341\\346y\"; /* \"x\u00d8\u00a2\u00d9\u0084\u00d9\u0088y\" */\n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'x');\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 1, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == (unsigned char) '\\302');\n        ASSERT (wc == 0x0622);\n        ASSERT (mbsinit (&state));\n        input[1] = '\\0';\n\n        /* Test support of NULL first argument.  */\n        ret = mbrtowc (NULL, input + 2, 3, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 2, 3, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == (unsigned char) '\\341');\n        ASSERT (wc == 0x0644);\n        ASSERT (mbsinit (&state));\n        input[2] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 3, 2, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == (unsigned char) '\\346');\n        ASSERT (wc == 0x0648);\n        ASSERT (mbsinit (&state));\n        input[3] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 4, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'y');\n        ASSERT (mbsinit (&state));\n      }\n      return 0;\n\n    case 932:\n      /* Locale encoding is CP932, similar to Shift_JIS.  */\n      {\n        char input[] = \"<\\223\\372\\226\\173\\214\\352>\"; /* \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == '<');\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 1, 2, &state);\n        ASSERT (ret == 2);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x65E5);\n        ASSERT (mbsinit (&state));\n        input[1] = '\\0';\n        input[2] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 3, 1, &state);\n        ASSERT (ret == (size_t)(-2));\n        ASSERT (wc == (wchar_t) 0xBADFACE);\n        ASSERT (!mbsinit (&state));\n        input[3] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 4, 4, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x672C);\n        ASSERT (mbsinit (&state));\n        input[4] = '\\0';\n\n        /* Test support of NULL first argument.  */\n        ret = mbrtowc (NULL, input + 5, 3, &state);\n        ASSERT (ret == 2);\n        ASSERT (mbsinit (&state));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 5, 3, &state);\n        ASSERT (ret == 2);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x8A9E);\n        ASSERT (mbsinit (&state));\n        input[5] = '\\0';\n        input[6] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 7, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == '>');\n        ASSERT (mbsinit (&state));\n\n        /* Test some invalid input.  */\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\377\", 1, &state); /* 0xFF */\n        ASSERT ((ret == (size_t)-1 && errno == EILSEQ) || ret == (size_t)-2);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\225\\377\", 2, &state); /* 0x95 0xFF */\n        ASSERT ((ret == (size_t)-1 && errno == EILSEQ) || (ret == 2 && wc == 0x30FB));\n      }\n      return 0;\n\n    case 950:\n      /* Locale encoding is CP950, similar to Big5.  */\n      {\n        char input[] = \"<\\244\\351\\245\\273\\273\\171>\"; /* \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == '<');\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 1, 2, &state);\n        ASSERT (ret == 2);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x65E5);\n        ASSERT (mbsinit (&state));\n        input[1] = '\\0';\n        input[2] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 3, 1, &state);\n        ASSERT (ret == (size_t)(-2));\n        ASSERT (wc == (wchar_t) 0xBADFACE);\n        ASSERT (!mbsinit (&state));\n        input[3] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 4, 4, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x672C);\n        ASSERT (mbsinit (&state));\n        input[4] = '\\0';\n\n        /* Test support of NULL first argument.  */\n        ret = mbrtowc (NULL, input + 5, 3, &state);\n        ASSERT (ret == 2);\n        ASSERT (mbsinit (&state));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 5, 3, &state);\n        ASSERT (ret == 2);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x8A9E);\n        ASSERT (mbsinit (&state));\n        input[5] = '\\0';\n        input[6] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 7, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == '>');\n        ASSERT (mbsinit (&state));\n\n        /* Test some invalid input.  */\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\377\", 1, &state); /* 0xFF */\n        ASSERT ((ret == (size_t)-1 && errno == EILSEQ) || ret == (size_t)-2);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\225\\377\", 2, &state); /* 0x95 0xFF */\n        ASSERT ((ret == (size_t)-1 && errno == EILSEQ) || (ret == 2 && wc == '?'));\n      }\n      return 0;\n\n    case 936:\n      /* Locale encoding is CP936 = GBK, an extension of GB2312.  */\n      {\n        char input[] = \"<\\310\\325\\261\\276\\325\\132>\"; /* \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == '<');\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 1, 2, &state);\n        ASSERT (ret == 2);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x65E5);\n        ASSERT (mbsinit (&state));\n        input[1] = '\\0';\n        input[2] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 3, 1, &state);\n        ASSERT (ret == (size_t)(-2));\n        ASSERT (wc == (wchar_t) 0xBADFACE);\n        ASSERT (!mbsinit (&state));\n        input[3] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 4, 4, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x672C);\n        ASSERT (mbsinit (&state));\n        input[4] = '\\0';\n\n        /* Test support of NULL first argument.  */\n        ret = mbrtowc (NULL, input + 5, 3, &state);\n        ASSERT (ret == 2);\n        ASSERT (mbsinit (&state));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 5, 3, &state);\n        ASSERT (ret == 2);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x8A9E);\n        ASSERT (mbsinit (&state));\n        input[5] = '\\0';\n        input[6] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 7, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == '>');\n        ASSERT (mbsinit (&state));\n\n        /* Test some invalid input.  */\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\377\", 1, &state); /* 0xFF */\n        ASSERT ((ret == (size_t)-1 && errno == EILSEQ) || ret == (size_t)-2);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\225\\377\", 2, &state); /* 0x95 0xFF */\n        ASSERT ((ret == (size_t)-1 && errno == EILSEQ) || (ret == 2 && wc == '?'));\n      }\n      return 0;\n\n    case 54936:\n      /* Locale encoding is CP54936 = GB18030.  */\n      {\n        char input[] = \"B\\250\\271\\201\\060\\211\\070er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'B');\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 1, 1, &state);\n        ASSERT (ret == (size_t)(-2));\n        ASSERT (wc == (wchar_t) 0xBADFACE);\n        ASSERT (!mbsinit (&state));\n        input[1] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 2, 7, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x00FC);\n        ASSERT (mbsinit (&state));\n        input[2] = '\\0';\n\n        /* Test support of NULL first argument.  */\n        ret = mbrtowc (NULL, input + 3, 6, &state);\n        ASSERT (ret == 4);\n        ASSERT (mbsinit (&state));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 3, 6, &state);\n        ASSERT (ret == 4);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x00DF);\n        ASSERT (mbsinit (&state));\n        input[3] = '\\0';\n        input[4] = '\\0';\n        input[5] = '\\0';\n        input[6] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 7, 2, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'e');\n        ASSERT (mbsinit (&state));\n        input[5] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 8, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'r');\n        ASSERT (mbsinit (&state));\n\n        /* Test some invalid input.  */\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\377\", 1, &state); /* 0xFF */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\225\\377\", 2, &state); /* 0x95 0xFF */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\201\\045\", 2, &state); /* 0x81 0x25 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\201\\060\\377\", 3, &state); /* 0x81 0x30 0xFF */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\201\\060\\377\\064\", 4, &state); /* 0x81 0x30 0xFF 0x34 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\201\\060\\211\\072\", 4, &state); /* 0x81 0x30 0x89 0x3A */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n      }\n      return 0;\n\n    case 65001:\n      /* Locale encoding is CP65001 = UTF-8.  */\n      {\n        char input[] = \"B\\303\\274\\303\\237er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'B');\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 1, 1, &state);\n        ASSERT (ret == (size_t)(-2));\n        ASSERT (wc == (wchar_t) 0xBADFACE);\n        ASSERT (!mbsinit (&state));\n        input[1] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 2, 5, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x00FC);\n        ASSERT (mbsinit (&state));\n        input[2] = '\\0';\n\n        /* Test support of NULL first argument.  */\n        ret = mbrtowc (NULL, input + 3, 4, &state);\n        ASSERT (ret == 2);\n        ASSERT (mbsinit (&state));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 3, 4, &state);\n        ASSERT (ret == 2);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x00DF);\n        ASSERT (mbsinit (&state));\n        input[3] = '\\0';\n        input[4] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 5, 2, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'e');\n        ASSERT (mbsinit (&state));\n        input[5] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 6, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'r');\n        ASSERT (mbsinit (&state));\n\n        /* Test some invalid input.  */\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\377\", 1, &state); /* 0xFF */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\303\\300\", 2, &state); /* 0xC3 0xC0 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\343\\300\", 2, &state); /* 0xE3 0xC0 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\343\\300\\200\", 3, &state); /* 0xE3 0xC0 0x80 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\343\\200\\300\", 3, &state); /* 0xE3 0x80 0xC0 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\363\\300\", 2, &state); /* 0xF3 0xC0 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\363\\300\\200\\200\", 4, &state); /* 0xF3 0xC0 0x80 0x80 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\363\\200\\300\", 3, &state); /* 0xF3 0x80 0xC0 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\363\\200\\300\\200\", 4, &state); /* 0xF3 0x80 0xC0 0x80 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\363\\200\\200\\300\", 4, &state); /* 0xF3 0x80 0x80 0xC0 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n      }\n      return 0;\n\n    default:\n      return 1;\n    }\n}",
      "lines": 664,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": [
      {
        "start_point": [
          695,
          0
        ],
        "end_point": [
          717,
          1
        ],
        "content": "int\nmain (int argc, char *argv[])\n{\n  int codepage = atoi (argv[argc - 1]);\n  int result;\n  int i;\n\n  result = 77;\n  for (i = 1; i < argc - 1; i++)\n    {\n      int ret = test_one_locale (argv[i], codepage);\n\n      if (ret != 77)\n        result = ret;\n    }\n\n  if (result == 77)\n    {\n      fprintf (stderr, \"Skipping test: found no locale with codepage %d\\n\",\n               codepage);\n    }\n  return result;\n}",
        "lines": 23,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          721,
          0
        ],
        "end_point": [
          726,
          1
        ],
        "content": "int\nmain (int argc, char *argv[])\n{\n  fputs (\"Skipping test: not a native Windows system\\n\", stderr);\n  return 77;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/tests/test-mbrtowc.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        356,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  mbstate_t state;\n  wchar_t wc;\n  size_t ret;\n\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  /* Test zero-length input.  */\n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    wc = (wchar_t) 0xBADFACE;\n    ret = mbrtowc (&wc, \"x\", 0, &state);\n    ASSERT (ret == (size_t)(-2));\n    ASSERT (mbsinit (&state));\n  }\n\n  /* Test NUL byte input.  */\n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    wc = (wchar_t) 0xBADFACE;\n    ret = mbrtowc (&wc, \"\", 1, &state);\n    ASSERT (ret == 0);\n    ASSERT (wc == 0);\n    ASSERT (mbsinit (&state));\n    ret = mbrtowc (NULL, \"\", 1, &state);\n    ASSERT (ret == 0);\n    ASSERT (mbsinit (&state));\n  }\n\n  /* Test single-byte input.  */\n  {\n    int c;\n    char buf[1];\n\n    memset (&state, '\\0', sizeof (mbstate_t));\n    for (c = 0; c < 0x100; c++)\n      switch (c)\n        {\n        default:\n          if (! (c && 1 < argc && argv[1][0] == '5'))\n            break;\n          FALLTHROUGH;\n        case '\\t': case '\\v': case '\\f':\n        case ' ': case '!': case '\"': case '#': case '%':\n        case '&': case '\\'': case '(': case ')': case '*':\n        case '+': case ',': case '-': case '.': case '/':\n        case '0': case '1': case '2': case '3': case '4':\n        case '5': case '6': case '7': case '8': case '9':\n        case ':': case ';': case '<': case '=': case '>':\n        case '?':\n        case 'A': case 'B': case 'C': case 'D': case 'E':\n        case 'F': case 'G': case 'H': case 'I': case 'J':\n        case 'K': case 'L': case 'M': case 'N': case 'O':\n        case 'P': case 'Q': case 'R': case 'S': case 'T':\n        case 'U': case 'V': case 'W': case 'X': case 'Y':\n        case 'Z':\n        case '[': case '\\\\': case ']': case '^': case '_':\n        case 'a': case 'b': case 'c': case 'd': case 'e':\n        case 'f': case 'g': case 'h': case 'i': case 'j':\n        case 'k': case 'l': case 'm': case 'n': case 'o':\n        case 'p': case 'q': case 'r': case 's': case 't':\n        case 'u': case 'v': case 'w': case 'x': case 'y':\n        case 'z': case '{': case '|': case '}': case '~':\n          /* c is in the ISO C \"basic character set\", or argv[1] starts\n             with '5' so we are testing all nonnull bytes.  */\n          buf[0] = c;\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, buf, 1, &state);\n          ASSERT (ret == 1);\n          if (c < 0x80)\n            /* c is an ASCII character.  */\n            ASSERT (wc == c);\n          else\n            /* argv[1] starts with '5', that is, we are testing the C or POSIX\n               locale.\n               On most platforms, the bytes 0x80..0xFF map to U+0080..U+00FF.\n               But on musl libc, the bytes 0x80..0xFF map to U+DF80..U+DFFF.  */\n            ASSERT (wc == (btowc (c) == WEOF ? c : btowc (c)));\n          ASSERT (mbsinit (&state));\n          ret = mbrtowc (NULL, buf, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (mbsinit (&state));\n          break;\n        }\n  }\n\n  /* Test special calling convention, passing a NULL pointer.  */\n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    wc = (wchar_t) 0xBADFACE;\n    ret = mbrtowc (&wc, NULL, 5, &state);\n    ASSERT (ret == 0);\n    ASSERT (wc == (wchar_t) 0xBADFACE);\n    ASSERT (mbsinit (&state));\n  }\n\n  if (argc > 1)\n    switch (argv[1][0])\n      {\n      case '1':\n        /* Locale encoding is ISO-8859-1 or ISO-8859-15.  */\n        {\n          char input[] = \"B\\374\\337er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n          memset (&state, '\\0', sizeof (mbstate_t));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'B');\n          ASSERT (mbsinit (&state));\n          input[0] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 1, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wctob (wc) == (unsigned char) '\\374');\n          ASSERT (mbsinit (&state));\n          input[1] = '\\0';\n\n          /* Test support of NULL first argument.  */\n          ret = mbrtowc (NULL, input + 2, 3, &state);\n          ASSERT (ret == 1);\n          ASSERT (mbsinit (&state));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 2, 3, &state);\n          ASSERT (ret == 1);\n          ASSERT (wctob (wc) == (unsigned char) '\\337');\n          ASSERT (mbsinit (&state));\n          input[2] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 3, 2, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'e');\n          ASSERT (mbsinit (&state));\n          input[3] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 4, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'r');\n          ASSERT (mbsinit (&state));\n        }\n        return 0;\n\n      case '2':\n        /* Locale encoding is UTF-8.  */\n        {\n          char input[] = \"B\\303\\274\\303\\237er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n          memset (&state, '\\0', sizeof (mbstate_t));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'B');\n          ASSERT (mbsinit (&state));\n          input[0] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 1, 1, &state);\n          ASSERT (ret == (size_t)(-2));\n          ASSERT (wc == (wchar_t) 0xBADFACE);\n          ASSERT (!mbsinit (&state));\n          input[1] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 2, 5, &state);\n          ASSERT (ret == 1);\n          ASSERT (wctob (wc) == EOF);\n          ASSERT (mbsinit (&state));\n          input[2] = '\\0';\n\n          /* Test support of NULL first argument.  */\n          ret = mbrtowc (NULL, input + 3, 4, &state);\n          ASSERT (ret == 2);\n          ASSERT (mbsinit (&state));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 3, 4, &state);\n          ASSERT (ret == 2);\n          ASSERT (wctob (wc) == EOF);\n          ASSERT (mbsinit (&state));\n          input[3] = '\\0';\n          input[4] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 5, 2, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'e');\n          ASSERT (mbsinit (&state));\n          input[5] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 6, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'r');\n          ASSERT (mbsinit (&state));\n        }\n        return 0;\n\n      case '3':\n        /* Locale encoding is EUC-JP.  */\n        {\n          char input[] = \"<\\306\\374\\313\\334\\270\\354>\"; /* \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n          memset (&state, '\\0', sizeof (mbstate_t));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == '<');\n          ASSERT (mbsinit (&state));\n          input[0] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 1, 2, &state);\n          ASSERT (ret == 2);\n          ASSERT (wctob (wc) == EOF);\n          ASSERT (mbsinit (&state));\n          input[1] = '\\0';\n          input[2] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 3, 1, &state);\n          ASSERT (ret == (size_t)(-2));\n          ASSERT (wc == (wchar_t) 0xBADFACE);\n          ASSERT (!mbsinit (&state));\n          input[3] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 4, 4, &state);\n          ASSERT (ret == 1);\n          ASSERT (wctob (wc) == EOF);\n          ASSERT (mbsinit (&state));\n          input[4] = '\\0';\n\n          /* Test support of NULL first argument.  */\n          ret = mbrtowc (NULL, input + 5, 3, &state);\n          ASSERT (ret == 2);\n          ASSERT (mbsinit (&state));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 5, 3, &state);\n          ASSERT (ret == 2);\n          ASSERT (wctob (wc) == EOF);\n          ASSERT (mbsinit (&state));\n          input[5] = '\\0';\n          input[6] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 7, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == '>');\n          ASSERT (mbsinit (&state));\n        }\n        return 0;\n\n      case '4':\n        /* Locale encoding is GB18030.  */\n        {\n          char input[] = \"B\\250\\271\\201\\060\\211\\070er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n          memset (&state, '\\0', sizeof (mbstate_t));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'B');\n          ASSERT (mbsinit (&state));\n          input[0] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 1, 1, &state);\n          ASSERT (ret == (size_t)(-2));\n          ASSERT (wc == (wchar_t) 0xBADFACE);\n          ASSERT (!mbsinit (&state));\n          input[1] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 2, 7, &state);\n          ASSERT (ret == 1);\n          ASSERT (wctob (wc) == EOF);\n          ASSERT (mbsinit (&state));\n          input[2] = '\\0';\n\n          /* Test support of NULL first argument.  */\n          ret = mbrtowc (NULL, input + 3, 6, &state);\n          ASSERT (ret == 4);\n          ASSERT (mbsinit (&state));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 3, 6, &state);\n          ASSERT (ret == 4);\n          ASSERT (wctob (wc) == EOF);\n          ASSERT (mbsinit (&state));\n          input[3] = '\\0';\n          input[4] = '\\0';\n          input[5] = '\\0';\n          input[6] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 7, 2, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'e');\n          ASSERT (mbsinit (&state));\n          input[5] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 8, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'r');\n          ASSERT (mbsinit (&state));\n        }\n        return 0;\n\n      case '5':\n        /* C locale; tested above.  */\n        return 0;\n      }\n\n  return 1;\n}",
      "lines": 325,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-mbsinit.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  static mbstate_t state;\n\n  ASSERT (mbsinit (NULL));\n\n  ASSERT (mbsinit (&state));\n\n  if (argc > 1)\n    {\n      static const char input[1] = \"\\303\";\n      wchar_t wc;\n      size_t ret;\n\n      /* configure should already have checked that the locale is supported.  */\n      if (setlocale (LC_ALL, \"\") == NULL)\n        return 1;\n\n      ret = mbrtowc (&wc, input, 1, &state);\n      ASSERT (ret == (size_t)(-2));\n      ASSERT (!mbsinit (&state));\n    }\n\n  return 0;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-memchr.c": {
    "main": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "int\nmain (void)\n{\n  size_t n = 0x100000;\n  char *input = malloc (n);\n  ASSERT (input);\n\n  input[0] = 'a';\n  input[1] = 'b';\n  memset (input + 2, 'c', 1024);\n  memset (input + 1026, 'd', n - 1028);\n  input[n - 2] = 'e';\n  input[n - 1] = 'a';\n\n  /* Basic behavior tests.  */\n  ASSERT (MEMCHR (input, 'a', n) == input);\n\n  ASSERT (MEMCHR (input, 'a', 0) == NULL);\n  ASSERT (MEMCHR (zerosize_ptr (), 'a', 0) == NULL);\n\n  ASSERT (MEMCHR (input, 'b', n) == input + 1);\n  ASSERT (MEMCHR (input, 'c', n) == input + 2);\n  ASSERT (MEMCHR (input, 'd', n) == input + 1026);\n\n  ASSERT (MEMCHR (input + 1, 'a', n - 1) == input + n - 1);\n  ASSERT (MEMCHR (input + 1, 'e', n - 1) == input + n - 2);\n  ASSERT (MEMCHR (input + 1, 0x789abc00 | 'e', n - 1) == input + n - 2);\n\n  ASSERT (MEMCHR (input, 'f', n) == NULL);\n  ASSERT (MEMCHR (input, '\\0', n) == NULL);\n\n  /* Check that a very long haystack is handled quickly if the byte is\n     found near the beginning.  */\n  {\n    size_t repeat = 10000;\n    for (; repeat > 0; repeat--)\n      {\n        ASSERT (MEMCHR (input, 'c', n) == input + 2);\n      }\n  }\n\n  /* Alignment tests.  */\n  {\n    int i, j;\n    for (i = 0; i < 32; i++)\n      {\n        for (j = 0; j < 256; j++)\n          input[i + j] = j;\n        for (j = 0; j < 256; j++)\n          {\n            ASSERT (MEMCHR (input + i, j, 256) == input + i + j);\n          }\n      }\n  }\n\n  /* Check that memchr() does not read past the first occurrence of the\n     byte being searched.  See the Austin Group's clarification\n     <http://www.opengroup.org/austin/docs/austin_454.txt>.\n     Test both '\\0' and something else, since some implementations\n     special-case searching for NUL.\n  */\n  {\n    char *page_boundary = (char *) zerosize_ptr ();\n    /* Too small, and we miss cache line boundary tests; too large,\n       and the test takes cubically longer to complete.  */\n    int limit = 257;\n\n    if (page_boundary != NULL)\n      {\n        for (n = 1; n <= limit; n++)\n          {\n            char *mem = page_boundary - n;\n            memset (mem, 'X', n);\n            ASSERT (MEMCHR (mem, 'U', n) == NULL);\n            ASSERT (MEMCHR (mem, 0, n) == NULL);\n\n            {\n              size_t i;\n              size_t k;\n\n              for (i = 0; i < n; i++)\n                {\n                  mem[i] = 'U';\n                  for (k = i + 1; k < n + limit; k++)\n                    ASSERT (MEMCHR (mem, 'U', k) == mem + i);\n                  mem[i] = 0;\n                  for (k = i + 1; k < n + limit; k++)\n                    ASSERT (MEMCHR (mem, 0, k) == mem + i);\n                  mem[i] = 'X';\n                }\n            }\n          }\n      }\n  }\n\n  free (input);\n\n  return 0;\n}",
      "lines": 99,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-once.c": {
    "a_init": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "static void\na_init (void)\n{\n  a = 42;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "int\nmain ()\n{\n  gl_once (a_once, a_init);\n\n  ASSERT (a == 42);\n\n  return 0;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-printf-frexp.c": {
    "my_ldexp": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "static double\nmy_ldexp (double x, int d)\n{\n  for (; d > 0; d--)\n    x *= 2.0;\n  for (; d < 0; d++)\n    x *= 0.5;\n  return x;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "main": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "int\nmain ()\n{\n  int i;\n  /* The use of 'volatile' guarantees that excess precision bits are dropped\n     when dealing with denormalized numbers.  It is necessary on x86 systems\n     where double-floats are not IEEE compliant by default, to avoid that the\n     results become platform and compiler option dependent.  'volatile' is a\n     portable alternative to gcc's -ffloat-store option.  */\n  volatile double x;\n\n  for (i = 1, x = 1.0; i <= DBL_MAX_EXP; i++, x *= 2.0)\n    {\n      int exp = -9999;\n      double mantissa = printf_frexp (x, &exp);\n      ASSERT (exp == i - 1);\n      ASSERT (mantissa == 1.0);\n    }\n  for (i = 1, x = 1.0; i >= DBL_MIN_EXP; i--, x *= 0.5)\n    {\n      int exp = -9999;\n      double mantissa = printf_frexp (x, &exp);\n      ASSERT (exp == i - 1);\n      ASSERT (mantissa == 1.0);\n    }\n  for (; i >= DBL_MIN_EXP - 100 && x > 0.0; i--, x *= 0.5)\n    {\n      int exp = -9999;\n      double mantissa = printf_frexp (x, &exp);\n      ASSERT (exp == DBL_MIN_EXP - 1);\n      ASSERT (mantissa == my_ldexp (1.0, i - DBL_MIN_EXP));\n    }\n\n  for (i = 1, x = 1.01; i <= DBL_MAX_EXP; i++, x *= 2.0)\n    {\n      int exp = -9999;\n      double mantissa = printf_frexp (x, &exp);\n      ASSERT (exp == i - 1);\n      ASSERT (mantissa == 1.01);\n    }\n  for (i = 1, x = 1.01; i >= DBL_MIN_EXP; i--, x *= 0.5)\n    {\n      int exp = -9999;\n      double mantissa = printf_frexp (x, &exp);\n      ASSERT (exp == i - 1);\n      ASSERT (mantissa == 1.01);\n    }\n  for (; i >= DBL_MIN_EXP - 100 && x > 0.0; i--, x *= 0.5)\n    {\n      int exp = -9999;\n      double mantissa = printf_frexp (x, &exp);\n      ASSERT (exp == DBL_MIN_EXP - 1);\n      ASSERT (mantissa >= my_ldexp (1.0, i - DBL_MIN_EXP));\n      ASSERT (mantissa <= my_ldexp (2.0, i - DBL_MIN_EXP));\n      ASSERT (mantissa == my_ldexp (x, - exp));\n    }\n\n  for (i = 1, x = 1.73205; i <= DBL_MAX_EXP; i++, x *= 2.0)\n    {\n      int exp = -9999;\n      double mantissa = printf_frexp (x, &exp);\n      ASSERT (exp == i - 1);\n      ASSERT (mantissa == 1.73205);\n    }\n  for (i = 1, x = 1.73205; i >= DBL_MIN_EXP; i--, x *= 0.5)\n    {\n      int exp = -9999;\n      double mantissa = printf_frexp (x, &exp);\n      ASSERT (exp == i - 1);\n      ASSERT (mantissa == 1.73205);\n    }\n  for (; i >= DBL_MIN_EXP - 100 && x > 0.0; i--, x *= 0.5)\n    {\n      int exp = -9999;\n      double mantissa = printf_frexp (x, &exp);\n      ASSERT (exp == DBL_MIN_EXP - 1);\n      ASSERT (mantissa >= my_ldexp (1.0, i - DBL_MIN_EXP));\n      ASSERT (mantissa <= my_ldexp (2.0, i - DBL_MIN_EXP));\n      ASSERT (mantissa == my_ldexp (x, - exp));\n    }\n\n  return 0;\n}",
      "lines": 83,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-printf-frexpl.c": {
    "my_ldexp": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static long double\nmy_ldexp (long double x, int d)\n{\n  for (; d > 0; d--)\n    x *= 2.0L;\n  for (; d < 0; d++)\n    x *= 0.5L;\n  return x;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "long double",
        "long",
        "double"
      ]
    },
    "main": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "int\nmain ()\n{\n  int i;\n  long double x;\n  DECL_LONG_DOUBLE_ROUNDING\n\n  BEGIN_LONG_DOUBLE_ROUNDING ();\n\n  for (i = 1, x = 1.0L; i <= LDBL_MAX_EXP; i++, x *= 2.0L)\n    {\n      int exp = -9999;\n      long double mantissa = printf_frexpl (x, &exp);\n      ASSERT (exp == i - 1);\n      ASSERT (mantissa == 1.0L);\n    }\n  for (i = 1, x = 1.0L; i >= MIN_NORMAL_EXP; i--, x *= 0.5L)\n    {\n      int exp = -9999;\n      long double mantissa = printf_frexpl (x, &exp);\n      ASSERT (exp == i - 1);\n      ASSERT (mantissa == 1.0L);\n    }\n  for (; i >= MIN_SUBNORMAL_EXP && x > 0.0L; i--, x *= 0.5L)\n    {\n      int exp = -9999;\n      long double mantissa = printf_frexpl (x, &exp);\n      ASSERT (exp == LDBL_MIN_EXP - 1);\n      ASSERT (mantissa == my_ldexp (1.0L, i - LDBL_MIN_EXP));\n    }\n\n  for (i = 1, x = 1.01L; i <= LDBL_MAX_EXP; i++, x *= 2.0L)\n    {\n      int exp = -9999;\n      long double mantissa = printf_frexpl (x, &exp);\n      ASSERT (exp == i - 1);\n      ASSERT (mantissa == 1.01L);\n    }\n  for (i = 1, x = 1.01L; i >= MIN_NORMAL_EXP; i--, x *= 0.5L)\n    {\n      int exp = -9999;\n      long double mantissa = printf_frexpl (x, &exp);\n      ASSERT (exp == i - 1);\n      ASSERT (mantissa == 1.01L);\n    }\n  for (; i >= MIN_SUBNORMAL_EXP && x > 0.0L; i--, x *= 0.5L)\n    {\n      int exp = -9999;\n      long double mantissa = printf_frexpl (x, &exp);\n      ASSERT (exp == LDBL_MIN_EXP - 1);\n      ASSERT (mantissa >= my_ldexp (1.0L, i - LDBL_MIN_EXP));\n      ASSERT (mantissa <= my_ldexp (2.0L, i - LDBL_MIN_EXP));\n      ASSERT (mantissa == my_ldexp (x, - exp));\n    }\n\n  for (i = 1, x = 1.73205L; i <= LDBL_MAX_EXP; i++, x *= 2.0L)\n    {\n      int exp = -9999;\n      long double mantissa = printf_frexpl (x, &exp);\n      ASSERT (exp == i - 1);\n      ASSERT (mantissa == 1.73205L);\n    }\n  for (i = 1, x = 1.73205L; i >= MIN_NORMAL_EXP; i--, x *= 0.5L)\n    {\n      int exp = -9999;\n      long double mantissa = printf_frexpl (x, &exp);\n      ASSERT (exp == i - 1);\n      ASSERT (mantissa == 1.73205L);\n    }\n  for (; i >= MIN_SUBNORMAL_EXP && x > 0.0L; i--, x *= 0.5L)\n    {\n      int exp = -9999;\n      long double mantissa = printf_frexpl (x, &exp);\n      ASSERT (exp == LDBL_MIN_EXP - 1);\n      ASSERT (mantissa >= my_ldexp (1.0L, i - LDBL_MIN_EXP));\n      ASSERT (mantissa <= my_ldexp (2.0L, i - LDBL_MIN_EXP));\n      ASSERT (mantissa == my_ldexp (x, - exp));\n    }\n\n  return 0;\n}",
      "lines": 81,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-pthread_sigmask1.c": {
    "sigint_handler": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "static void\nsigint_handler (int sig)\n{\n  sigint_occurred++;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": [
      {
        "start_point": [
          42,
          0
        ],
        "end_point": [
          80,
          1
        ],
        "content": "int\nmain (int argc, char *argv[])\n{\n  sigset_t set;\n  int pid = getpid ();\n  char command[80];\n\n  signal (SIGINT, sigint_handler);\n\n  sigemptyset (&set);\n  sigaddset (&set, SIGINT);\n\n  /* Check error handling.  */\n  ASSERT (pthread_sigmask (1729, &set, NULL) == EINVAL);\n\n  /* Block SIGINT.  */\n  ASSERT (pthread_sigmask (SIG_BLOCK, &set, NULL) == 0);\n\n  /* Request a SIGINT signal from outside.  */\n  sprintf (command, \"sh -c 'sleep 1; kill -%d %d' &\", SIGINT, pid);\n  ASSERT (system (command) == 0);\n\n  /* Wait.  */\n  sleep (2);\n\n  /* The signal should not have arrived yet, because it is blocked.  */\n  ASSERT (sigint_occurred == 0);\n\n  /* Unblock SIGINT.  */\n  ASSERT (pthread_sigmask (SIG_UNBLOCK, &set, NULL) == 0);\n\n  /* The signal should have arrived now, because POSIX says\n       \"If there are any pending unblocked signals after the call to\n        pthread_sigmask(), at least one of those signals shall be delivered\n        before the call to pthread_sigmask() returns.\"  */\n  ASSERT (sigint_occurred == 1);\n\n  return 0;\n}",
        "lines": 39,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          87,
          0
        ],
        "end_point": [
          92,
          1
        ],
        "content": "int\nmain ()\n{\n  fputs (\"Skipping test: native Windows platform\\n\", stderr);\n  return 77;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/tests/test-pthread_sigmask2.c": {
    "killer_thread_func": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "static void *\nkiller_thread_func (void *arg)\n{\n  sleep (1);\n  pthread_kill (main_thread, SIGINT);\n  return NULL;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nkiller_thread_func (void *arg)",
        "*"
      ]
    },
    "sigint_handler": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "static void\nsigint_handler (int sig)\n{\n  sigint_occurred++;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": [
      {
        "start_point": [
          51,
          0
        ],
        "end_point": [
          87,
          1
        ],
        "content": "int\nmain (int argc, char *argv[])\n{\n  sigset_t set;\n\n  signal (SIGINT, sigint_handler);\n\n  sigemptyset (&set);\n  sigaddset (&set, SIGINT);\n\n  /* Check error handling.  */\n  ASSERT (pthread_sigmask (1729, &set, NULL) == EINVAL);\n\n  /* Block SIGINT.  */\n  ASSERT (pthread_sigmask (SIG_BLOCK, &set, NULL) == 0);\n\n  /* Request a SIGINT signal from another thread.  */\n  main_thread = gl_thread_self ();\n  ASSERT (glthread_create (&killer_thread, killer_thread_func, NULL) == 0);\n\n  /* Wait.  */\n  sleep (2);\n\n  /* The signal should not have arrived yet, because it is blocked.  */\n  ASSERT (sigint_occurred == 0);\n\n  /* Unblock SIGINT.  */\n  ASSERT (pthread_sigmask (SIG_UNBLOCK, &set, NULL) == 0);\n\n  /* The signal should have arrived now, because POSIX says\n       \"If there are any pending unblocked signals after the call to\n        pthread_sigmask(), at least one of those signals shall be delivered\n        before the call to pthread_sigmask() returns.\"  */\n  ASSERT (sigint_occurred == 1);\n\n  return 0;\n}",
        "lines": 37,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          91,
          0
        ],
        "end_point": [
          96,
          1
        ],
        "content": "int\nmain ()\n{\n  fputs (\"Skipping test: POSIX threads not enabled\\n\", stderr);\n  return 77;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/tests/test-raise.c": {
    "handler": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "static _Noreturn void\nhandler (int sig)\n{\n  exit (0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "_Noreturn",
        "void",
        "void"
      ]
    },
    "main": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Test behaviour for invalid argument.  */\n  ASSERT (raise (-1) != 0);\n\n  /* Test behaviour for SIGINT.  */\n  ASSERT (signal (SIGINT, handler) != SIG_ERR);\n\n  raise (SIGINT);\n\n  /* We should not get here, because the handler takes away the control.  */\n  exit (1);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-rwlock1.c": {
    "timer_func": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static void *\ntimer_func (void *ignored)\n{\n  /* Step 13 (can be before or after step 12):\n     The timer thread takes the baton, then waits a moment to make sure\n     it can tell whether the second reader thread is blocked at step 12.  */\n  if (glthread_lock_lock (&baton))\n    UNEXPECTED (13);\n  usleep (100000);\n  /* By the time we get here, it's clear that the second reader thread is\n     blocked at step 12.  This is the desired behaviour.  */\n  SUCCEED ();\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ntimer_func (void *ignored)",
        "*"
      ]
    },
    "reader2_func": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "static void *\nreader2_func (void *ignored)\n{\n  int err;\n\n  /* Step 8 (can be before or after step 7):\n     The second reader thread takes the baton, then waits a moment to make sure\n     the writer thread has reached step 7.  */\n  if (glthread_lock_lock (&baton))\n    UNEXPECTED (8);\n  usleep (100000);\n  /* Step 9 omitted.  */\n  /* Step 10: Launch a timer, to test whether the next call blocks.  */\n  if (glthread_create (&timer, timer_func, NULL))\n    UNEXPECTED (10);\n  /* Step 11: Release the baton.  */\n  if (glthread_lock_unlock (&baton))\n    UNEXPECTED (11);\n  /* Step 12: The second reader thread requests the lock.  */\n  err = glthread_rwlock_rdlock (&lock);\n  if (err == 0)\n    FAILURE ();\n  else\n    UNEXPECTED (12);\n}",
      "lines": 25,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nreader2_func (void *ignored)",
        "*"
      ]
    },
    "writer_func": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "static void *\nwriter_func (void *ignored)\n{\n  /* Step 4: Take the baton, so that the second reader thread does not go ahead\n     too early.  */\n  if (glthread_lock_lock (&baton))\n    UNEXPECTED (4);\n  /* Step 5: Create the second reader thread.  */\n  if (glthread_create (&reader2, reader2_func, NULL))\n    UNEXPECTED (5);\n  /* Step 6: Release the baton.  */\n  if (glthread_lock_unlock (&baton))\n    UNEXPECTED (6);\n  /* Step 7: The writer thread requests the lock.  */\n  if (glthread_rwlock_wrlock (&lock))\n    UNEXPECTED (7);\n  return NULL;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nwriter_func (void *ignored)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "int\nmain ()\n{\n  reader1 = gl_thread_self ();\n\n  /* Step 1: The main thread initializes the lock and the baton.  */\n  if (glthread_rwlock_init (&lock))\n    UNEXPECTED (1);\n  if (glthread_lock_init (&baton))\n    UNEXPECTED (1);\n  /* Step 2: The main thread acquires the lock as a reader.  */\n  if (glthread_rwlock_rdlock (&lock))\n    UNEXPECTED (2);\n  /* Step 3: Create the writer thread.  */\n  if (glthread_create (&writer, writer_func, NULL))\n    UNEXPECTED (3);\n  /* Job done.  Go to sleep.  */\n  for (;;)\n    {\n      /* In cooperative threads implementations (Pth), give other threads\n         a chance to run.  */\n      gl_thread_yield ();\n      sleep (1);\n    }\n}",
      "lines": 25,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-setenv.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Test overwriting.  */\n  ASSERT (setenv (\"a\", \"==\", -1) == 0);\n  ASSERT (setenv (\"a\", \"2\", 0) == 0);\n  ASSERT (strcmp (getenv (\"a\"), \"==\") == 0);\n\n  /* Required to fail with EINVAL.  */\n  errno = 0;\n  ASSERT (setenv (\"\", \"\", 1) == -1);\n  ASSERT (errno == EINVAL);\n  errno = 0;\n  ASSERT (setenv (\"a=b\", \"\", 0) == -1);\n  ASSERT (errno == EINVAL);\n#if 0\n  /* glibc and gnulib's implementation guarantee this, but POSIX no\n     longer requires it: http://austingroupbugs.net/view.php?id=185  */\n  errno = 0;\n  ASSERT (setenv (NULL, \"\", 0) == -1);\n  ASSERT (errno == EINVAL);\n#endif\n\n  return 0;\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-setlocale1.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  char *name1;\n  char *name2;\n\n  /* Try to set the locale by implicitly looking at the LC_ALL environment\n     variable.\n     configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  name1 = strdup (setlocale (LC_ALL, NULL));\n\n  /* Reset the locale.  */\n  if (setlocale (LC_ALL, \"C\") == NULL)\n    return 1;\n\n  /* Try to set the locale by explicitly looking at the LC_ALL environment\n     variable.\n     configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, getenv (\"LC_ALL\")) == NULL)\n    return 1;\n\n  name2 = strdup (setlocale (LC_ALL, NULL));\n\n  /* Test that the two results are the same.  */\n  ASSERT (strcmp (name1, name2) == 0);\n  free (name1);\n  free (name2);\n\n  return 0;\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-setlocale2.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Try to set the locale by implicitly looking at the LC_ALL environment\n     variable.  */\n  if (setlocale (LC_ALL, \"\") != NULL)\n    /* It was successful.  Check whether LC_CTYPE is non-trivial.  */\n    if (strcmp (setlocale (LC_CTYPE, NULL), \"C\") == 0)\n      {\n        fprintf (stderr, \"setlocale did not fail for implicit %s\\n\",\n                 getenv (\"LC_ALL\"));\n        return 1;\n      }\n\n  /* Reset the locale.  */\n  if (setlocale (LC_ALL, \"C\") == NULL)\n    return 1;\n\n  /* Try to set the locale by explicitly looking at the LC_ALL environment\n     variable.  */\n  if (setlocale (LC_ALL, getenv (\"LC_ALL\")) != NULL)\n    /* It was successful.  Check whether LC_CTYPE is non-trivial.  */\n    if (strcmp (setlocale (LC_CTYPE, NULL), \"C\") == 0)\n      {\n        fprintf (stderr, \"setlocale did not fail for explicit %s\\n\",\n                 getenv (\"LC_ALL\"));\n        return 1;\n      }\n\n  return 0;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-signal-h.c": {
    "main": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "int\nmain (void)\n{\n  switch (0)\n    {\n      /* The following are guaranteed by C.  */\n    case 0:\n    case SIGABRT:\n    case SIGFPE:\n    case SIGILL:\n    case SIGINT:\n    case SIGSEGV:\n    case SIGTERM:\n      /* The following is guaranteed by gnulib.  */\n#if GNULIB_SIGPIPE || defined SIGPIPE\n    case SIGPIPE:\n#endif\n      /* Ensure no conflict with other standardized names.  */\n#ifdef SIGALRM\n    case SIGALRM:\n#endif\n      /* On Haiku, SIGBUS is mistakenly equal to SIGSEGV.  */\n#if defined SIGBUS && SIGBUS != SIGSEGV\n    case SIGBUS:\n#endif\n#ifdef SIGCHLD\n    case SIGCHLD:\n#endif\n#ifdef SIGCONT\n    case SIGCONT:\n#endif\n#ifdef SIGHUP\n    case SIGHUP:\n#endif\n#ifdef SIGKILL\n    case SIGKILL:\n#endif\n#ifdef SIGQUIT\n    case SIGQUIT:\n#endif\n#ifdef SIGSTOP\n    case SIGSTOP:\n#endif\n#ifdef SIGTSTP\n    case SIGTSTP:\n#endif\n#ifdef SIGTTIN\n    case SIGTTIN:\n#endif\n#ifdef SIGTTOU\n    case SIGTTOU:\n#endif\n#ifdef SIGUSR1\n    case SIGUSR1:\n#endif\n#ifdef SIGUSR2\n    case SIGUSR2:\n#endif\n#ifdef SIGSYS\n    case SIGSYS:\n#endif\n#ifdef SIGTRAP\n    case SIGTRAP:\n#endif\n#ifdef SIGURG\n    case SIGURG:\n#endif\n#ifdef SIGVTALRM\n    case SIGVTALRM:\n#endif\n#ifdef SIGXCPU\n    case SIGXCPU:\n#endif\n#ifdef SIGXFSZ\n    case SIGXFSZ:\n#endif\n      /* SIGRTMIN and SIGRTMAX need not be compile-time constants.  */\n#if 0\n# ifdef SIGRTMIN\n    case SIGRTMIN:\n# endif\n# ifdef SIGRTMAX\n    case SIGRTMAX:\n# endif\n#endif\n      ;\n    }\n  return s.a + s.b + s.c + s.e;\n}",
      "lines": 89,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-signbit.c": {
    "test_signbitf": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static void\ntest_signbitf ()\n{\n  /* Finite values.  */\n  ASSERT (!signbit (3.141f));\n  ASSERT (!signbit (3.141e30f));\n  ASSERT (!signbit (3.141e-30f));\n  ASSERT (signbit (-2.718f));\n  ASSERT (signbit (-2.718e30f));\n  ASSERT (signbit (-2.718e-30f));\n  /* Zeros.  */\n  ASSERT (!signbit (0.0f));\n  if (1.0f / minus_zerof < 0)\n    ASSERT (signbit (minus_zerof));\n  else\n    ASSERT (!signbit (minus_zerof));\n  /* Infinite values.  */\n  ASSERT (!signbit (Infinityf ()));\n  ASSERT (signbit (- Infinityf ()));\n  /* Quiet NaN.  */\n  (void) signbit (zerof / zerof);\n#if defined FLT_EXPBIT0_WORD && defined FLT_EXPBIT0_BIT\n  /* Signalling NaN.  */\n  {\n    #define NWORDS \\\n      ((sizeof (float) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n    typedef union { float value; unsigned int word[NWORDS]; } memory_float;\n    memory_float m;\n    m.value = zerof / zerof;\n# if FLT_EXPBIT0_BIT > 0\n    m.word[FLT_EXPBIT0_WORD] ^= (unsigned int) 1 << (FLT_EXPBIT0_BIT - 1);\n# else\n    m.word[FLT_EXPBIT0_WORD + (FLT_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      ^= (unsigned int) 1 << (sizeof (unsigned int) * CHAR_BIT - 1);\n# endif\n    if (FLT_EXPBIT0_WORD < NWORDS / 2)\n      m.word[FLT_EXPBIT0_WORD + 1] |= (unsigned int) 1 << FLT_EXPBIT0_BIT;\n    else\n      m.word[0] |= (unsigned int) 1;\n    (void) signbit (m.value);\n    #undef NWORDS\n  }\n#endif\n}",
      "lines": 44,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_signbitd": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "static void\ntest_signbitd ()\n{\n  /* Finite values.  */\n  ASSERT (!signbit (3.141));\n  ASSERT (!signbit (3.141e30));\n  ASSERT (!signbit (3.141e-30));\n  ASSERT (signbit (-2.718));\n  ASSERT (signbit (-2.718e30));\n  ASSERT (signbit (-2.718e-30));\n  /* Zeros.  */\n  ASSERT (!signbit (0.0));\n  if (1.0 / minus_zerod < 0)\n    ASSERT (signbit (minus_zerod));\n  else\n    ASSERT (!signbit (minus_zerod));\n  /* Infinite values.  */\n  ASSERT (!signbit (Infinityd ()));\n  ASSERT (signbit (- Infinityd ()));\n  /* Quiet NaN.  */\n  (void) signbit (zerod / zerod);\n#if defined DBL_EXPBIT0_WORD && defined DBL_EXPBIT0_BIT\n  /* Signalling NaN.  */\n  {\n    #define NWORDS \\\n      ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n    typedef union { double value; unsigned int word[NWORDS]; } memory_double;\n    memory_double m;\n    m.value = zerod / zerod;\n# if DBL_EXPBIT0_BIT > 0\n    m.word[DBL_EXPBIT0_WORD] ^= (unsigned int) 1 << (DBL_EXPBIT0_BIT - 1);\n# else\n    m.word[DBL_EXPBIT0_WORD + (DBL_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      ^= (unsigned int) 1 << (sizeof (unsigned int) * CHAR_BIT - 1);\n# endif\n    m.word[DBL_EXPBIT0_WORD + (DBL_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      |= (unsigned int) 1 << DBL_EXPBIT0_BIT;\n    (void) signbit (m.value);\n    #undef NWORDS\n  }\n#endif\n}",
      "lines": 42,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_signbitl": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "static void\ntest_signbitl ()\n{\n  /* Finite values.  */\n  ASSERT (!signbit (3.141L));\n  ASSERT (!signbit (3.141e30L));\n  ASSERT (!signbit (3.141e-30L));\n  ASSERT (signbit (-2.718L));\n  ASSERT (signbit (-2.718e30L));\n  ASSERT (signbit (-2.718e-30L));\n  /* Zeros.  */\n  ASSERT (!signbit (0.0L));\n  if (1.0L / minus_zerol < 0)\n    ASSERT (signbit (minus_zerol));\n  else\n    ASSERT (!signbit (minus_zerol));\n  /* Infinite values.  */\n  ASSERT (!signbit (Infinityl ()));\n  ASSERT (signbit (- Infinityl ()));\n  /* Quiet NaN.  */\n  (void) signbit (zerol / zerol);\n#if defined LDBL_EXPBIT0_WORD && defined LDBL_EXPBIT0_BIT\n  /* Signalling NaN.  */\n  {\n    #define NWORDS \\\n      ((sizeof (long double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n    typedef union { long double value; unsigned int word[NWORDS]; } memory_long_double;\n\n#if defined __powerpc__ && LDBL_MANT_DIG == 106\n    /* This is PowerPC \"double double\", a pair of two doubles.  Inf and Nan are\n       represented as the corresponding 64-bit IEEE values in the first double;\n       the second is ignored.  Manipulate only the first double.  */\n    #undef NWORDS\n    #define NWORDS \\\n      ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n#endif\n\n    memory_long_double m;\n    m.value = zerol / zerol;\n# if LDBL_EXPBIT0_BIT > 0\n    m.word[LDBL_EXPBIT0_WORD] ^= (unsigned int) 1 << (LDBL_EXPBIT0_BIT - 1);\n# else\n    m.word[LDBL_EXPBIT0_WORD + (LDBL_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      ^= (unsigned int) 1 << (sizeof (unsigned int) * CHAR_BIT - 1);\n# endif\n    m.word[LDBL_EXPBIT0_WORD + (LDBL_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      |= (unsigned int) 1 << LDBL_EXPBIT0_BIT;\n    (void) signbit (m.value);\n    #undef NWORDS\n  }\n#endif\n}",
      "lines": 52,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "int\nmain ()\n{\n  test_signbitf ();\n  test_signbitd ();\n  test_signbitl ();\n  return 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-sigprocmask.c": {
    "sigint_handler": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "static void\nsigint_handler (int sig)\n{\n  sigint_occurred++;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": [
      {
        "start_point": [
          42,
          0
        ],
        "end_point": [
          87,
          1
        ],
        "content": "int\nmain (int argc, char *argv[])\n{\n  sigset_t set;\n  pid_t pid = getpid ();\n  char command[80];\n\n  if (sizeof (int) < sizeof pid && 0x7fffffff < pid)\n    {\n      fputs (\"Skipping test: pid too large\\n\", stderr);\n      return 77;\n    }\n\n  signal (SIGINT, sigint_handler);\n\n  sigemptyset (&set);\n  sigaddset (&set, SIGINT);\n\n  /* Check error handling.  */\n  ASSERT (sigprocmask (1729, &set, NULL) == -1);\n  ASSERT (errno == EINVAL);\n\n  /* Block SIGINT.  */\n  ASSERT (sigprocmask (SIG_BLOCK, &set, NULL) == 0);\n\n  /* Request a SIGINT signal from outside.  */\n  sprintf (command, \"sh -c 'sleep 1; kill -%d %d' &\", SIGINT, (int) pid);\n  ASSERT (system (command) == 0);\n\n  /* Wait.  */\n  sleep (2);\n\n  /* The signal should not have arrived yet, because it is blocked.  */\n  ASSERT (sigint_occurred == 0);\n\n  /* Unblock SIGINT.  */\n  ASSERT (sigprocmask (SIG_UNBLOCK, &set, NULL) == 0);\n\n  /* The signal should have arrived now, because POSIX says\n       \"If there are any pending unblocked signals after the call to\n        sigprocmask(), at least one of those signals shall be delivered\n        before the call to sigprocmask() returns.\"  */\n  ASSERT (sigint_occurred == 1);\n\n  return 0;\n}",
        "lines": 46,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          94,
          0
        ],
        "end_point": [
          99,
          1
        ],
        "content": "int\nmain ()\n{\n  fputs (\"Skipping test: native Windows platform\\n\", stderr);\n  return 77;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/tests/test-sleep.c": {
    "handle_alarm": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "static void\nhandle_alarm (int sig)\n{\n  if (sig != SIGALRM)\n    _exit (1);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\nmain (void)\n{\n  ASSERT (sleep (1) <= 1);\n\n  ASSERT (sleep (0) == 0);\n\n#if HAVE_DECL_ALARM\n  {\n    const unsigned int pentecost = 50 * 24 * 60 * 60; /* 50 days.  */\n    unsigned int remaining;\n    signal (SIGALRM, handle_alarm);\n    alarm (1);\n    remaining = sleep (pentecost);\n    ASSERT (pentecost - 10 < remaining && remaining <= pentecost);\n  }\n#endif\n\n  return 0;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-stdalign.c": {
    "main": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "int\nmain ()\n{\n#if defined __SUNPRO_C\n  /* Avoid a test failure due to Sun Studio Developer Bug Report #2125432.  */\n  fputs (\"Skipping test: known Sun C compiler bug\\n\", stderr);\n  return 77;\n#elif defined __HP_cc && __ia64\n  /* Avoid a test failure due to HP-UX Itanium cc bug; see:\n     https://lists.gnu.org/r/bug-gnulib/2017-03/msg00078.html  */\n  fputs (\"Skipping test: known HP-UX Itanium cc compiler bug\\n\", stderr);\n  return 77;\n#else\n  CHECK_ALIGNED (static_char_alignas);\n  CHECK_ALIGNED (static_char_Alignas);\n  CHECK_ALIGNED (static_short_alignas);\n  CHECK_ALIGNED (static_short_Alignas);\n  CHECK_ALIGNED (static_int_alignas);\n  CHECK_ALIGNED (static_int_Alignas);\n  CHECK_ALIGNED (static_long_alignas);\n  CHECK_ALIGNED (static_long_Alignas);\n# ifdef INT64_MAX\n  CHECK_ALIGNED (static_int64_t_alignas);\n  CHECK_ALIGNED (static_int64_t_Alignas);\n# endif\n  CHECK_ALIGNED (static_float_alignas);\n  CHECK_ALIGNED (static_float_Alignas);\n  CHECK_ALIGNED (static_double_alignas);\n  CHECK_ALIGNED (static_double_Alignas);\n  /* CHECK_ALIGNED (static_longdouble_alignas); */\n  /* CHECK_ALIGNED (static_longdouble_Alignas); */\n  CHECK_ALIGNED (static_struct1_alignas);\n  CHECK_ALIGNED (static_struct1_Alignas);\n  CHECK_ALIGNED (static_struct2_alignas);\n  CHECK_ALIGNED (static_struct2_Alignas);\n  CHECK_ALIGNED (static_struct3_alignas);\n  CHECK_ALIGNED (static_struct3_Alignas);\n  CHECK_ALIGNED (static_struct4_alignas);\n  CHECK_ALIGNED (static_struct4_Alignas);\n  return 0;\n#endif\n}",
      "lines": 42,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-stdbool.c": {
    "main": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "int\nmain ()\n{\n  int error = 0;\n\n#if HAVE_STDBOOL_H || 3 <= __GNUC__ /* See above.  */\n# ifdef ADDRESS_CHECK_OKAY /* Avoid gcc warning.  */\n  /* A cast from a variable's address to bool is valid in expressions.  */\n  {\n    bool e1 = &s;\n    if (!e1)\n      error = 1;\n  }\n# endif\n#endif\n\n  /* Catch a bug in IBM AIX xlc compiler version 6.0.0.0\n     reported by James Lemley on 2005-10-05; see\n     https://lists.gnu.org/r/bug-coreutils/2005-10/msg00086.html\n     This is a runtime test, since a corresponding compile-time\n     test would rely on initializer extensions.  */\n  {\n    char digs[] = \"0123456789\";\n    if (&(digs + 5)[-2 + (bool) 1] != &digs[4])\n      error = 1;\n  }\n\n  return error;\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-stddef.c": {
    "main": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-stdint.c": {
    "main": {
      "start_point": [
        421,
        0
      ],
      "end_point": [
        425,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-stdio.c": {
    "main": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-stdlib.c": {
    "main": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\nmain (void)\n{\n  if (test_sys_wait_macros ())\n    return 1;\n\n  return exitcode;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-strerror.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "int\nmain (void)\n{\n  char *str;\n\n  errno = 0;\n  str = strerror (EACCES);\n  ASSERT (str);\n  ASSERT (*str);\n  ASSERT (errno == 0);\n\n  errno = 0;\n  str = strerror (ETIMEDOUT);\n  ASSERT (str);\n  ASSERT (*str);\n  ASSERT (errno == 0);\n\n  errno = 0;\n  str = strerror (EOVERFLOW);\n  ASSERT (str);\n  ASSERT (*str);\n  ASSERT (errno == 0);\n\n  /* POSIX requires strerror (0) to succeed.  Reject use of \"Unknown\n     error\", but allow \"Success\", \"No error\", or even Solaris' \"Error\n     0\" which are distinct patterns from true out-of-range strings.\n     http://austingroupbugs.net/view.php?id=382  */\n  errno = 0;\n  str = strerror (0);\n  ASSERT (str);\n  ASSERT (*str);\n  ASSERT (errno == 0);\n  ASSERT (strstr (str, \"nknown\") == NULL);\n  ASSERT (strstr (str, \"ndefined\") == NULL);\n\n  /* POSIX requires strerror to produce a non-NULL result for all\n     inputs; as an extension, we also guarantee a non-empty result.\n     Reporting EINVAL is optional.  */\n  errno = 0;\n  str = strerror (-3);\n  ASSERT (str);\n  ASSERT (*str);\n  ASSERT (errno == 0 || errno == EINVAL);\n\n  return 0;\n}",
      "lines": 46,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-striconveh.c": {
    "new_offsets": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "static size_t *\nnew_offsets (size_t n)\n{\n  size_t *offsets = (size_t *) malloc ((n + 1) * sizeof (size_t));\n  offsets[n] = MAGIC;\n  return offsets;\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "size_t",
        "*\nnew_offsets (size_t n)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        1111,
        1
      ],
      "content": "int\nmain ()\n{\n  static enum iconv_ilseq_handler handlers[] =\n    { iconveh_error, iconveh_question_mark, iconveh_escape_sequence };\n  size_t indirect;\n  size_t h;\n  size_t o;\n  size_t i;\n\n#if HAVE_ICONV\n  /* Assume that iconv() supports at least the encodings ASCII, ISO-8859-1,\n     ISO-8859-2, and UTF-8.  */\n  iconv_t cd_ascii_to_88591 = iconv_open (\"ISO-8859-1\", \"ASCII\");\n  iconv_t cd_88591_to_88592 = iconv_open (\"ISO-8859-2\", \"ISO-8859-1\");\n  iconv_t cd_88592_to_88591 = iconv_open (\"ISO-8859-1\", \"ISO-8859-2\");\n  iconv_t cd_ascii_to_utf8 = iconv_open (\"UTF-8\", \"ASCII\");\n  iconv_t cd_88591_to_utf8 = iconv_open (\"UTF-8\", \"ISO-8859-1\");\n  iconv_t cd_utf8_to_88591 = iconv_open (\"ISO-8859-1\", \"UTF-8\");\n  iconv_t cd_88592_to_utf8 = iconv_open (\"UTF-8\", \"ISO-8859-2\");\n  iconv_t cd_utf8_to_88592 = iconv_open (\"ISO-8859-2\", \"UTF-8\");\n  iconv_t cd_utf7_to_utf8 = iconv_open (\"UTF-8\", \"UTF-7\");\n  iconveh_t cdeh_ascii_to_88591;\n  iconveh_t cdeh_ascii_to_88591_indirectly;\n  iconveh_t cdeh_88592_to_88591;\n  iconveh_t cdeh_88592_to_88591_indirectly;\n  iconveh_t cdeh_ascii_to_utf8;\n  iconveh_t cdeh_88591_to_utf8;\n  iconveh_t cdeh_utf8_to_88591;\n  iconveh_t cdeh_utf7_to_utf8;\n\n  ASSERT (cd_ascii_to_utf8 != (iconv_t)(-1));\n  ASSERT (cd_88591_to_utf8 != (iconv_t)(-1));\n  ASSERT (cd_utf8_to_88591 != (iconv_t)(-1));\n  ASSERT (cd_88592_to_utf8 != (iconv_t)(-1));\n  ASSERT (cd_utf8_to_88592 != (iconv_t)(-1));\n\n  cdeh_ascii_to_88591.cd = cd_ascii_to_88591;\n  cdeh_ascii_to_88591.cd1 = cd_ascii_to_utf8;\n  cdeh_ascii_to_88591.cd2 = cd_utf8_to_88591;\n\n  cdeh_ascii_to_88591_indirectly.cd = (iconv_t)(-1);\n  cdeh_ascii_to_88591_indirectly.cd1 = cd_ascii_to_utf8;\n  cdeh_ascii_to_88591_indirectly.cd2 = cd_utf8_to_88591;\n\n  cdeh_88592_to_88591.cd = cd_88592_to_88591;\n  cdeh_88592_to_88591.cd1 = cd_88592_to_utf8;\n  cdeh_88592_to_88591.cd2 = cd_utf8_to_88591;\n\n  cdeh_88592_to_88591_indirectly.cd = (iconv_t)(-1);\n  cdeh_88592_to_88591_indirectly.cd1 = cd_88592_to_utf8;\n  cdeh_88592_to_88591_indirectly.cd2 = cd_utf8_to_88591;\n\n  cdeh_ascii_to_utf8.cd = cd_ascii_to_utf8;\n  cdeh_ascii_to_utf8.cd1 = cd_ascii_to_utf8;\n  cdeh_ascii_to_utf8.cd2 = (iconv_t)(-1);\n\n  cdeh_88591_to_utf8.cd = cd_88591_to_utf8;\n  cdeh_88591_to_utf8.cd1 = cd_88591_to_utf8;\n  cdeh_88591_to_utf8.cd2 = (iconv_t)(-1);\n\n  cdeh_utf8_to_88591.cd = cd_utf8_to_88591;\n  cdeh_utf8_to_88591.cd1 = (iconv_t)(-1);\n  cdeh_utf8_to_88591.cd2 = cd_utf8_to_88591;\n\n  cdeh_utf7_to_utf8.cd = cd_utf7_to_utf8;\n  cdeh_utf7_to_utf8.cd1 = cd_utf7_to_utf8;\n  cdeh_utf7_to_utf8.cd2 = (iconv_t)(-1);\n\n  /* ------------------------ Test mem_cd_iconveh() ------------------------ */\n\n  /* Test conversion from ISO-8859-2 to ISO-8859-1 with no errors.  */\n  for (indirect = 0; indirect <= 1; indirect++)\n    {\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n          static const char expected[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n          for (o = 0; o < 2; o++)\n            {\n              size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n              char *result = NULL;\n              size_t length = 0;\n              int retval = mem_cd_iconveh (input, strlen (input),\n                                           (indirect\n                                            ? &cdeh_88592_to_88591_indirectly\n                                            : &cdeh_88592_to_88591),\n                                           handler,\n                                           offsets,\n                                           &result, &length);\n              ASSERT (retval == 0);\n              ASSERT (length == strlen (expected));\n              ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);\n              if (o)\n                {\n                  for (i = 0; i < 37; i++)\n                    ASSERT (offsets[i] == i);\n                  ASSERT (offsets[37] == MAGIC);\n                  free (offsets);\n                }\n              free (result);\n            }\n        }\n    }\n\n  /* Test conversion from ASCII to ISO-8859-1 with invalid input (EILSEQ).  */\n  for (indirect = 0; indirect <= 1; indirect++)\n    {\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"Rafa\\263 Maszkowski\"; /* Rafa? Maszkowski */\n          for (o = 0; o < 2; o++)\n            {\n              size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n              char *result = NULL;\n              size_t length = 0;\n              int retval = mem_cd_iconveh (input, strlen (input),\n                                           (indirect\n                                            ? &cdeh_ascii_to_88591_indirectly\n                                            : &cdeh_ascii_to_88591),\n                                           handler,\n                                           offsets,\n                                           &result, &length);\n              switch (handler)\n                {\n                case iconveh_error:\n                  ASSERT (retval == -1 && errno == EILSEQ);\n                  ASSERT (result == NULL);\n                  if (o)\n                    free (offsets);\n                  break;\n                case iconveh_question_mark:\n                case iconveh_escape_sequence:\n                  {\n                    static const char expected[] = \"Rafa? Maszkowski\";\n                    ASSERT (retval == 0);\n                    ASSERT (length == strlen (expected));\n                    ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);\n                    if (o)\n                      {\n                        for (i = 0; i < 16; i++)\n                          ASSERT (offsets[i] == i);\n                        ASSERT (offsets[16] == MAGIC);\n                        free (offsets);\n                      }\n                    free (result);\n                  }\n                  break;\n                }\n            }\n        }\n    }\n\n  /* Test conversion from ISO-8859-2 to ISO-8859-1 with EILSEQ.  */\n  for (indirect = 0; indirect <= 1; indirect++)\n    {\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"Rafa\\263 Maszkowski\"; /* Rafa\u00c5\u0082 Maszkowski */\n          for (o = 0; o < 2; o++)\n            {\n              size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n              char *result = NULL;\n              size_t length = 0;\n              int retval = mem_cd_iconveh (input, strlen (input),\n                                           (indirect\n                                            ? &cdeh_88592_to_88591_indirectly\n                                            : &cdeh_88592_to_88591),\n                                           handler,\n                                           offsets,\n                                           &result, &length);\n              switch (handler)\n                {\n                case iconveh_error:\n                  ASSERT (retval == -1 && errno == EILSEQ);\n                  ASSERT (result == NULL);\n                  if (o)\n                    free (offsets);\n                  break;\n                case iconveh_question_mark:\n                  {\n                    static const char expected[] = \"Rafa? Maszkowski\";\n                    ASSERT (retval == 0);\n                    ASSERT (length == strlen (expected));\n                    ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);\n                    if (o)\n                      {\n                        for (i = 0; i < 16; i++)\n                          ASSERT (offsets[i] == i);\n                        ASSERT (offsets[16] == MAGIC);\n                        free (offsets);\n                      }\n                    free (result);\n                  }\n                  break;\n                case iconveh_escape_sequence:\n                  {\n                    static const char expected[] = \"Rafa\\\\u0142 Maszkowski\";\n                    ASSERT (retval == 0);\n                    ASSERT (length == strlen (expected));\n                    ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);\n                    if (o)\n                      {\n                        for (i = 0; i < 16; i++)\n                          ASSERT (offsets[i] == (i < 5 ? i :\n                                                 i + 5));\n                        ASSERT (offsets[16] == MAGIC);\n                        free (offsets);\n                      }\n                    free (result);\n                  }\n                  break;\n                }\n            }\n        }\n    }\n\n  /* Test conversion from ISO-8859-1 to UTF-8 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      static const char expected[] = \"\\303\\204rger mit b\\303\\266sen B\\303\\274bchen ohne Augenma\\303\\237\";\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n          char *result = NULL;\n          size_t length = 0;\n          int retval = mem_cd_iconveh (input, strlen (input),\n                                       &cdeh_88591_to_utf8,\n                                       handler,\n                                       offsets,\n                                       &result, &length);\n          ASSERT (retval == 0);\n          ASSERT (length == strlen (expected));\n          ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);\n          if (o)\n            {\n              for (i = 0; i < 37; i++)\n                ASSERT (offsets[i] == (i < 1 ? i :\n                                       i < 12 ? i + 1 :\n                                       i < 18 ? i + 2 :\n                                       i + 3));\n              ASSERT (offsets[37] == MAGIC);\n              free (offsets);\n            }\n          free (result);\n        }\n    }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"\\303\\204rger mit b\\303\\266sen B\\303\\274bchen ohne Augenma\\303\\237\";\n      static const char expected[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n          char *result = NULL;\n          size_t length = 0;\n          int retval = mem_cd_iconveh (input, strlen (input),\n                                       &cdeh_utf8_to_88591,\n                                       handler,\n                                       offsets,\n                                       &result, &length);\n          ASSERT (retval == 0);\n          ASSERT (length == strlen (expected));\n          ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);\n          if (o)\n            {\n              for (i = 0; i < 41; i++)\n                ASSERT (offsets[i] == (i < 1 ? i :\n                                       i == 1 ? (size_t)(-1) :\n                                       i < 13 ? i - 1 :\n                                       i == 13 ? (size_t)(-1) :\n                                       i < 20 ? i - 2 :\n                                       i == 20 ? (size_t)(-1) :\n                                       i < 40 ? i - 3 :\n                                       (size_t)(-1)));\n              ASSERT (offsets[41] == MAGIC);\n              free (offsets);\n            }\n          free (result);\n        }\n    }\n\n  /* Test conversion from ASCII to UTF-8 with invalid input (EILSEQ).  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"Rafa\\263 Maszkowski\"; /* Rafa? Maszkowski */\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n          char *result = NULL;\n          size_t length = 0;\n          int retval = mem_cd_iconveh (input, strlen (input),\n                                       &cdeh_ascii_to_utf8,\n                                       handler,\n                                       offsets,\n                                       &result, &length);\n          switch (handler)\n            {\n            case iconveh_error:\n              ASSERT (retval == -1 && errno == EILSEQ);\n              ASSERT (result == NULL);\n              if (o)\n                free (offsets);\n              break;\n            case iconveh_question_mark:\n            case iconveh_escape_sequence:\n              {\n                static const char expected[] = \"Rafa? Maszkowski\";\n                ASSERT (retval == 0);\n                ASSERT (length == strlen (expected));\n                ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);\n                if (o)\n                  {\n                    for (i = 0; i < 16; i++)\n                      ASSERT (offsets[i] == i);\n                    ASSERT (offsets[16] == MAGIC);\n                    free (offsets);\n                  }\n                free (result);\n              }\n              break;\n            }\n        }\n    }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with EILSEQ.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"Rafa\\305\\202 Maszkowski\"; /* Rafa\u00c5\u0082 Maszkowski */\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n          char *result = NULL;\n          size_t length = 0;\n          int retval = mem_cd_iconveh (input, strlen (input),\n                                       &cdeh_utf8_to_88591,\n                                       handler,\n                                       offsets,\n                                       &result, &length);\n          switch (handler)\n            {\n            case iconveh_error:\n              ASSERT (retval == -1 && errno == EILSEQ);\n              ASSERT (result == NULL);\n              if (o)\n                free (offsets);\n              break;\n            case iconveh_question_mark:\n              {\n                static const char expected[] = \"Rafa? Maszkowski\";\n                ASSERT (retval == 0);\n                ASSERT (length == strlen (expected));\n                ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);\n                if (o)\n                  {\n                    for (i = 0; i < 17; i++)\n                      ASSERT (offsets[i] == (i < 5 ? i :\n                                             i == 5 ? (size_t)(-1) :\n                                             i - 1));\n                    ASSERT (offsets[17] == MAGIC);\n                    free (offsets);\n                  }\n                free (result);\n              }\n              break;\n            case iconveh_escape_sequence:\n              {\n                static const char expected[] = \"Rafa\\\\u0142 Maszkowski\";\n                ASSERT (retval == 0);\n                ASSERT (length == strlen (expected));\n                ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);\n                if (o)\n                  {\n                    for (i = 0; i < 17; i++)\n                      ASSERT (offsets[i] == (i < 5 ? i :\n                                             i == 5 ? (size_t)(-1) :\n                                             i + 4));\n                    ASSERT (offsets[17] == MAGIC);\n                    free (offsets);\n                  }\n                free (result);\n              }\n              break;\n            }\n        }\n    }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with EINVAL.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"\\342\";\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n          char *result = NULL;\n          size_t length = 0;\n          int retval = mem_cd_iconveh (input, strlen (input),\n                                       &cdeh_utf8_to_88591,\n                                       handler,\n                                       offsets,\n                                       &result, &length);\n          ASSERT (retval == 0);\n          ASSERT (length == 0);\n          if (o)\n            {\n              ASSERT (offsets[0] == 0);\n              ASSERT (offsets[1] == MAGIC);\n              free (offsets);\n            }\n          free (result);\n        }\n    }\n\n  if (cd_utf7_to_utf8 != (iconv_t)(-1))\n    {\n      /* Disabled on Solaris, because Solaris 9 iconv() is buggy: it returns\n         -1 / EILSEQ when converting the 7th byte of the input \"+VDLYP9hA\".  */\n# if !(defined __sun && !defined _LIBICONV_VERSION)\n      /* Test conversion from UTF-7 to UTF-8 with EINVAL.  */\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          /* This is base64 encoded 0x54 0x32 0xD8 0x3F 0xD8 0x40.  It would\n             convert to U+5432 U+D83F U+D840 but these are Unicode surrogates.  */\n          static const char input[] = \"+VDLYP9hA\";\n          static const char expected1[] = \"\\345\\220\\262\"; /* \u00e5\u0090\u00b2 glibc */\n          static const char expected2[] = \"\"; /* libiconv */\n          char *result = NULL;\n          size_t length = 0;\n          int retval = mem_cd_iconveh (input, 7,\n                                       &cdeh_utf7_to_utf8,\n                                       handler,\n                                       NULL,\n                                       &result, &length);\n          ASSERT (retval == 0);\n          ASSERT (length == strlen (expected1) || length == strlen (expected2));\n          ASSERT (result != NULL);\n          if (length == strlen (expected1))\n            ASSERT (memcmp (result, expected1, strlen (expected1)) == 0);\n          else\n            ASSERT (memcmp (result, expected2, strlen (expected2)) == 0);\n          free (result);\n        }\n\n      /* Disabled on NetBSD, because NetBSD 5.0 iconv() is buggy: it converts\n         the input \"+2D/YQNhB\" to U+1FED8 U+3FD8 U+40D8.  */\n#  if !(defined __NetBSD__ && !defined _LIBICONV_VERSION)\n      /* Test conversion from UTF-7 to UTF-8 with EILSEQ.  */\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          /* This is base64 encoded 0xD8 0x3F 0xD8 0x40 0xD8 0x41.  It would\n             convert to U+D83F U+D840 U+D841 but these are Unicode surrogates.  */\n          static const char input[] = \"+2D/YQNhB\";\n          char *result = NULL;\n          size_t length = 0;\n          int retval = mem_cd_iconveh (input, strlen (input),\n                                       &cdeh_utf7_to_utf8,\n                                       handler,\n                                       NULL,\n                                       &result, &length);\n          switch (handler)\n            {\n            case iconveh_error:\n              ASSERT (retval == -1 && errno == EILSEQ);\n              ASSERT (result == NULL);\n              break;\n            case iconveh_question_mark:\n            case iconveh_escape_sequence:\n              {\n                /* glibc result */\n                static const char expected1[] = \"?????\";\n                /* libiconv <= 1.12 result */\n                static const char expected2[] = \"?2D/YQNhB\";\n                /* libiconv behaviour changed in version 1.13: the result is\n                   '?' U+0FF6 U+1036; this is U+D83F U+D840 U+D841 shifted left\n                   by 6 bits.  */\n                static const char expected3[] = \"?\\340\\277\\266\\341\\200\\266\";\n                ASSERT (retval == 0);\n                ASSERT (length == strlen (expected1)\n                        || length == strlen (expected2)\n                        || length == strlen (expected3));\n                ASSERT (result != NULL);\n                if (length == strlen (expected1))\n                  ASSERT (memcmp (result, expected1, strlen (expected1)) == 0);\n                else if (length == strlen (expected2))\n                  ASSERT (memcmp (result, expected2, strlen (expected2)) == 0);\n                else\n                  ASSERT (memcmp (result, expected3, strlen (expected3)) == 0);\n                free (result);\n              }\n              break;\n            }\n        }\n#  endif\n# endif\n    }\n\n  /* ------------------------ Test str_cd_iconveh() ------------------------ */\n\n  /* Test conversion from ISO-8859-2 to ISO-8859-1 with no errors.  */\n  for (indirect = 0; indirect <= 1; indirect++)\n    {\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n          static const char expected[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n          char *result = str_cd_iconveh (input,\n                                         (indirect\n                                          ? &cdeh_88592_to_88591_indirectly\n                                          : &cdeh_88592_to_88591),\n                                         handler);\n          ASSERT (result != NULL);\n          ASSERT (strcmp (result, expected) == 0);\n          free (result);\n        }\n    }\n\n  /* Test conversion from ASCII to ISO-8859-1 with invalid input (EILSEQ).  */\n  for (indirect = 0; indirect <= 1; indirect++)\n    {\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"Rafa\\263 Maszkowski\"; /* Rafa? Maszkowski */\n          char *result = str_cd_iconveh (input,\n                                         (indirect\n                                          ? &cdeh_ascii_to_88591_indirectly\n                                          : &cdeh_ascii_to_88591),\n                                         handler);\n          switch (handler)\n            {\n            case iconveh_error:\n              ASSERT (result == NULL && errno == EILSEQ);\n              break;\n            case iconveh_question_mark:\n            case iconveh_escape_sequence:\n              {\n                static const char expected[] = \"Rafa? Maszkowski\";\n                ASSERT (result != NULL);\n                ASSERT (strcmp (result, expected) == 0);\n                free (result);\n              }\n              break;\n            }\n        }\n    }\n\n  /* Test conversion from ISO-8859-2 to ISO-8859-1 with EILSEQ.  */\n  for (indirect = 0; indirect <= 1; indirect++)\n    {\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"Rafa\\263 Maszkowski\"; /* Rafa\u00c5\u0082 Maszkowski */\n          char *result = str_cd_iconveh (input,\n                                         (indirect\n                                          ? &cdeh_88592_to_88591_indirectly\n                                          : &cdeh_88592_to_88591),\n                                         handler);\n          switch (handler)\n            {\n            case iconveh_error:\n              ASSERT (result == NULL && errno == EILSEQ);\n              break;\n            case iconveh_question_mark:\n              {\n                static const char expected[] = \"Rafa? Maszkowski\";\n                ASSERT (result != NULL);\n                ASSERT (strcmp (result, expected) == 0);\n                free (result);\n              }\n              break;\n            case iconveh_escape_sequence:\n              {\n                static const char expected[] = \"Rafa\\\\u0142 Maszkowski\";\n                ASSERT (result != NULL);\n                ASSERT (strcmp (result, expected) == 0);\n                free (result);\n              }\n              break;\n            }\n        }\n    }\n\n  /* Test conversion from ISO-8859-1 to UTF-8 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      static const char expected[] = \"\\303\\204rger mit b\\303\\266sen B\\303\\274bchen ohne Augenma\\303\\237\";\n      char *result = str_cd_iconveh (input,\n                                     &cdeh_88591_to_utf8,\n                                     handler);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, expected) == 0);\n      free (result);\n    }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"\\303\\204rger mit b\\303\\266sen B\\303\\274bchen ohne Augenma\\303\\237\";\n      static const char expected[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      char *result = str_cd_iconveh (input,\n                                     &cdeh_utf8_to_88591,\n                                     handler);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, expected) == 0);\n      free (result);\n    }\n\n  /* Test conversion from ASCII to UTF-8 with invalid input (EILSEQ).  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"Rafa\\263 Maszkowski\"; /* Rafa? Maszkowski */\n      char *result = str_cd_iconveh (input,\n                                     &cdeh_ascii_to_utf8,\n                                     handler);\n      switch (handler)\n        {\n        case iconveh_error:\n          ASSERT (result == NULL && errno == EILSEQ);\n          break;\n        case iconveh_question_mark:\n        case iconveh_escape_sequence:\n          {\n            static const char expected[] = \"Rafa? Maszkowski\";\n            ASSERT (result != NULL);\n            ASSERT (strcmp (result, expected) == 0);\n            free (result);\n          }\n          break;\n        }\n    }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with EILSEQ.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"Costs: 27 \\342\\202\\254\"; /* EURO SIGN */\n      char *result = str_cd_iconveh (input,\n                                     &cdeh_utf8_to_88591,\n                                     handler);\n      switch (handler)\n        {\n        case iconveh_error:\n          ASSERT (result == NULL && errno == EILSEQ);\n          break;\n        case iconveh_question_mark:\n          {\n            static const char expected[] = \"Costs: 27 ?\";\n            ASSERT (result != NULL);\n            ASSERT (strcmp (result, expected) == 0);\n            free (result);\n          }\n          break;\n        case iconveh_escape_sequence:\n          {\n            static const char expected[] = \"Costs: 27 \\\\u20AC\";\n            ASSERT (result != NULL);\n            ASSERT (strcmp (result, expected) == 0);\n            free (result);\n          }\n          break;\n        }\n    }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with EINVAL.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"\\342\";\n      char *result = str_cd_iconveh (input,\n                                     &cdeh_utf8_to_88591,\n                                     handler);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"\") == 0);\n      free (result);\n    }\n\n  if (cd_88591_to_88592 != (iconv_t)(-1))\n    iconv_close (cd_88591_to_88592);\n  if (cd_88592_to_88591 != (iconv_t)(-1))\n    iconv_close (cd_88592_to_88591);\n  iconv_close (cd_88591_to_utf8);\n  iconv_close (cd_utf8_to_88591);\n  iconv_close (cd_88592_to_utf8);\n  iconv_close (cd_utf8_to_88592);\n\n  /* ------------------------- Test mem_iconveh() ------------------------- */\n\n  /* Test conversion from ISO-8859-2 to ISO-8859-1 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      static const char expected[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n          char *result = NULL;\n          size_t length = 0;\n          int retval = mem_iconveh (input, strlen (input),\n                                    \"ISO-8859-2\", \"ISO-8859-1\",\n                                    handler,\n                                    offsets,\n                                    &result, &length);\n          ASSERT (retval == 0);\n          ASSERT (length == strlen (expected));\n          ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);\n          if (o)\n            {\n              for (i = 0; i < 37; i++)\n                ASSERT (offsets[i] == i);\n              ASSERT (offsets[37] == MAGIC);\n              free (offsets);\n            }\n          free (result);\n        }\n    }\n\n  /* Test conversion from ISO-8859-2 to ISO-8859-1 with EILSEQ.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"Rafa\\263 Maszkowski\"; /* Rafa\u00c5\u0082 Maszkowski */\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n          char *result = NULL;\n          size_t length = 0;\n          int retval = mem_iconveh (input, strlen (input),\n                                    \"ISO-8859-2\", \"ISO-8859-1\",\n                                    handler,\n                                    offsets,\n                                    &result, &length);\n          switch (handler)\n            {\n            case iconveh_error:\n              ASSERT (retval == -1 && errno == EILSEQ);\n              ASSERT (result == NULL);\n              if (o)\n                free (offsets);\n              break;\n            case iconveh_question_mark:\n              {\n                static const char expected[] = \"Rafa? Maszkowski\";\n                ASSERT (retval == 0);\n                ASSERT (length == strlen (expected));\n                ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);\n                if (o)\n                  {\n                    for (i = 0; i < 16; i++)\n                      ASSERT (offsets[i] == i);\n                    ASSERT (offsets[16] == MAGIC);\n                    free (offsets);\n                  }\n                free (result);\n              }\n              break;\n            case iconveh_escape_sequence:\n              {\n                static const char expected[] = \"Rafa\\\\u0142 Maszkowski\";\n                ASSERT (retval == 0);\n                ASSERT (length == strlen (expected));\n                ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);\n                if (o)\n                  {\n                    for (i = 0; i < 16; i++)\n                      ASSERT (offsets[i] == (i < 5 ? i :\n                                             i + 5));\n                    ASSERT (offsets[16] == MAGIC);\n                    free (offsets);\n                  }\n                free (result);\n              }\n              break;\n            }\n        }\n    }\n\n  /* Test conversion from ISO-8859-1 to UTF-8 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      static const char expected[] = \"\\303\\204rger mit b\\303\\266sen B\\303\\274bchen ohne Augenma\\303\\237\";\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n          char *result = NULL;\n          size_t length = 0;\n          int retval = mem_iconveh (input, strlen (input),\n                                    \"ISO-8859-1\", \"UTF-8\",\n                                    handler,\n                                    offsets,\n                                    &result, &length);\n          ASSERT (retval == 0);\n          ASSERT (length == strlen (expected));\n          ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);\n          if (o)\n            {\n              for (i = 0; i < 37; i++)\n                ASSERT (offsets[i] == (i < 1 ? i :\n                                       i < 12 ? i + 1 :\n                                       i < 18 ? i + 2 :\n                                       i + 3));\n              ASSERT (offsets[37] == MAGIC);\n              free (offsets);\n            }\n          free (result);\n        }\n    }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"\\303\\204rger mit b\\303\\266sen B\\303\\274bchen ohne Augenma\\303\\237\";\n      static const char expected[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n          char *result = NULL;\n          size_t length = 0;\n          int retval = mem_iconveh (input, strlen (input),\n                                    \"UTF-8\", \"ISO-8859-1\",\n                                    handler,\n                                    offsets,\n                                    &result, &length);\n          ASSERT (retval == 0);\n          ASSERT (length == strlen (expected));\n          ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);\n          if (o)\n            {\n              for (i = 0; i < 41; i++)\n                ASSERT (offsets[i] == (i < 1 ? i :\n                                       i == 1 ? (size_t)(-1) :\n                                       i < 13 ? i - 1 :\n                                       i == 13 ? (size_t)(-1) :\n                                       i < 20 ? i - 2 :\n                                       i == 20 ? (size_t)(-1) :\n                                       i < 40 ? i - 3 :\n                                       (size_t)(-1)));\n              ASSERT (offsets[41] == MAGIC);\n              free (offsets);\n            }\n          free (result);\n        }\n    }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with EILSEQ.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"Rafa\\305\\202 Maszkowski\"; /* Rafa\u00c5\u0082 Maszkowski */\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n          char *result = NULL;\n          size_t length = 0;\n          int retval = mem_iconveh (input, strlen (input),\n                                    \"UTF-8\", \"ISO-8859-1\",\n                                    handler,\n                                    offsets,\n                                    &result, &length);\n          switch (handler)\n            {\n            case iconveh_error:\n              ASSERT (retval == -1 && errno == EILSEQ);\n              ASSERT (result == NULL);\n              if (o)\n                free (offsets);\n              break;\n            case iconveh_question_mark:\n              {\n                static const char expected[] = \"Rafa? Maszkowski\";\n                ASSERT (retval == 0);\n                ASSERT (length == strlen (expected));\n                ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);\n                if (o)\n                  {\n                    for (i = 0; i < 17; i++)\n                      ASSERT (offsets[i] == (i < 5 ? i :\n                                             i == 5 ? (size_t)(-1) :\n                                             i - 1));\n                    ASSERT (offsets[17] == MAGIC);\n                    free (offsets);\n                  }\n                free (result);\n              }\n              break;\n            case iconveh_escape_sequence:\n              {\n                static const char expected[] = \"Rafa\\\\u0142 Maszkowski\";\n                ASSERT (retval == 0);\n                ASSERT (length == strlen (expected));\n                ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);\n                if (o)\n                  {\n                    for (i = 0; i < 17; i++)\n                      ASSERT (offsets[i] == (i < 5 ? i :\n                                             i == 5 ? (size_t)(-1) :\n                                             i + 4));\n                    ASSERT (offsets[17] == MAGIC);\n                    free (offsets);\n                  }\n                free (result);\n              }\n              break;\n            }\n        }\n    }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with EINVAL.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"\\342\";\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n          char *result = NULL;\n          size_t length = 0;\n          int retval = mem_iconveh (input, strlen (input),\n                                    \"UTF-8\", \"ISO-8859-1\",\n                                    handler,\n                                    offsets,\n                                    &result, &length);\n          ASSERT (retval == 0);\n          ASSERT (length == 0);\n          if (o)\n            {\n              ASSERT (offsets[0] == 0);\n              ASSERT (offsets[1] == MAGIC);\n              free (offsets);\n            }\n          free (result);\n        }\n    }\n\n  /* ------------------------- Test str_iconveh() ------------------------- */\n\n  /* Test conversion from ISO-8859-2 to ISO-8859-1 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      static const char expected[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      char *result = str_iconveh (input, \"ISO-8859-2\", \"ISO-8859-1\", handler);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, expected) == 0);\n      free (result);\n    }\n\n  /* Test conversion from ISO-8859-2 to ISO-8859-1 with EILSEQ.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"Rafa\\263 Maszkowski\"; /* Rafa\u00c5\u0082 Maszkowski */\n      char *result = str_iconveh (input, \"ISO-8859-2\", \"ISO-8859-1\", handler);\n      switch (handler)\n        {\n        case iconveh_error:\n          ASSERT (result == NULL && errno == EILSEQ);\n          break;\n        case iconveh_question_mark:\n          {\n            static const char expected[] = \"Rafa? Maszkowski\";\n            ASSERT (result != NULL);\n            ASSERT (strcmp (result, expected) == 0);\n            free (result);\n          }\n          break;\n        case iconveh_escape_sequence:\n          {\n            static const char expected[] = \"Rafa\\\\u0142 Maszkowski\";\n            ASSERT (result != NULL);\n            ASSERT (strcmp (result, expected) == 0);\n            free (result);\n          }\n          break;\n        }\n    }\n\n  /* Test conversion from ISO-8859-1 to UTF-8 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      static const char expected[] = \"\\303\\204rger mit b\\303\\266sen B\\303\\274bchen ohne Augenma\\303\\237\";\n      char *result = str_iconveh (input, \"ISO-8859-1\", \"UTF-8\", handler);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, expected) == 0);\n      free (result);\n    }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"\\303\\204rger mit b\\303\\266sen B\\303\\274bchen ohne Augenma\\303\\237\";\n      static const char expected[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      char *result = str_iconveh (input, \"UTF-8\", \"ISO-8859-1\", handler);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, expected) == 0);\n      free (result);\n    }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with EILSEQ.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"Costs: 27 \\342\\202\\254\"; /* EURO SIGN */\n      char *result = str_iconveh (input, \"UTF-8\", \"ISO-8859-1\", handler);\n      switch (handler)\n        {\n        case iconveh_error:\n          ASSERT (result == NULL && errno == EILSEQ);\n          break;\n        case iconveh_question_mark:\n          {\n            static const char expected[] = \"Costs: 27 ?\";\n            ASSERT (result != NULL);\n            ASSERT (strcmp (result, expected) == 0);\n            free (result);\n          }\n          break;\n        case iconveh_escape_sequence:\n          {\n            static const char expected[] = \"Costs: 27 \\\\u20AC\";\n            ASSERT (result != NULL);\n            ASSERT (strcmp (result, expected) == 0);\n            free (result);\n          }\n          break;\n        }\n    }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with EINVAL.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"\\342\";\n      char *result = str_iconveh (input, \"UTF-8\", \"ISO-8859-1\", handler);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"\") == 0);\n      free (result);\n    }\n\n#endif\n\n  return 0;\n}",
      "lines": 1069,
      "depth": 25,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-striconveha.c": {
    "new_offsets": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "static size_t *\nnew_offsets (size_t n)\n{\n  size_t *offsets = (size_t *) malloc ((n + 1) * sizeof (size_t));\n  offsets[n] = MAGIC;\n  return offsets;\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "size_t",
        "*\nnew_offsets (size_t n)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        603,
        1
      ],
      "content": "int\nmain ()\n{\n  static enum iconv_ilseq_handler handlers[] =\n    { iconveh_error, iconveh_question_mark, iconveh_escape_sequence };\n  size_t h;\n  size_t o;\n  size_t i;\n\n#if HAVE_ICONV\n  /* Assume that iconv() supports at least the encodings ASCII, ISO-8859-1,\n     ISO-8859-2, and UTF-8.  */\n\n  /* ------------------------- Test mem_iconveha() ------------------------- */\n\n  /* Test conversion from ISO-8859-2 to ISO-8859-1 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      static const char expected[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n          char *result = NULL;\n          size_t length = 0;\n          int retval = mem_iconveha (input, strlen (input),\n                                     \"ISO-8859-2\", \"ISO-8859-1\",\n                                     false, handler,\n                                     offsets,\n                                     &result, &length);\n          ASSERT (retval == 0);\n          ASSERT (length == strlen (expected));\n          ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);\n          if (o)\n            {\n              for (i = 0; i < 37; i++)\n                ASSERT (offsets[i] == i);\n              ASSERT (offsets[37] == MAGIC);\n              free (offsets);\n            }\n          free (result);\n        }\n    }\n\n  /* Test conversion from ISO-8859-2 to ISO-8859-1 with EILSEQ.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"Rafa\\263 Maszkowski\"; /* Rafa\u00c5\u0082 Maszkowski */\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n          char *result = NULL;\n          size_t length = 0;\n          int retval = mem_iconveha (input, strlen (input),\n                                     \"ISO-8859-2\", \"ISO-8859-1\",\n                                     false, handler,\n                                     offsets,\n                                     &result, &length);\n          switch (handler)\n            {\n            case iconveh_error:\n              ASSERT (retval == -1 && errno == EILSEQ);\n              ASSERT (result == NULL);\n              if (o)\n                free (offsets);\n              break;\n            case iconveh_question_mark:\n              {\n                static const char expected[] = \"Rafa? Maszkowski\";\n                ASSERT (retval == 0);\n                ASSERT (length == strlen (expected));\n                ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);\n                if (o)\n                  {\n                    for (i = 0; i < 16; i++)\n                      ASSERT (offsets[i] == i);\n                    ASSERT (offsets[16] == MAGIC);\n                    free (offsets);\n                  }\n                free (result);\n              }\n              break;\n            case iconveh_escape_sequence:\n              {\n                static const char expected[] = \"Rafa\\\\u0142 Maszkowski\";\n                ASSERT (retval == 0);\n                ASSERT (length == strlen (expected));\n                ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);\n                if (o)\n                  {\n                    for (i = 0; i < 16; i++)\n                      ASSERT (offsets[i] == (i < 5 ? i :\n                                             i + 5));\n                    ASSERT (offsets[16] == MAGIC);\n                    free (offsets);\n                  }\n                free (result);\n              }\n              break;\n            }\n        }\n    }\n\n  /* Test conversion from ISO-8859-1 to UTF-8 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      static const char expected[] = \"\\303\\204rger mit b\\303\\266sen B\\303\\274bchen ohne Augenma\\303\\237\";\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n          char *result = NULL;\n          size_t length = 0;\n          int retval = mem_iconveha (input, strlen (input),\n                                     \"ISO-8859-1\", \"UTF-8\",\n                                     false, handler,\n                                     offsets,\n                                     &result, &length);\n          ASSERT (retval == 0);\n          ASSERT (length == strlen (expected));\n          ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);\n          if (o)\n            {\n              for (i = 0; i < 37; i++)\n                ASSERT (offsets[i] == (i < 1 ? i :\n                                       i < 12 ? i + 1 :\n                                       i < 18 ? i + 2 :\n                                       i + 3));\n              ASSERT (offsets[37] == MAGIC);\n              free (offsets);\n            }\n          free (result);\n        }\n    }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"\\303\\204rger mit b\\303\\266sen B\\303\\274bchen ohne Augenma\\303\\237\";\n      static const char expected[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n          char *result = NULL;\n          size_t length = 0;\n          int retval = mem_iconveha (input, strlen (input),\n                                     \"UTF-8\", \"ISO-8859-1\",\n                                     false, handler,\n                                     offsets,\n                                     &result, &length);\n          ASSERT (retval == 0);\n          ASSERT (length == strlen (expected));\n          ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);\n          if (o)\n            {\n              for (i = 0; i < 41; i++)\n                ASSERT (offsets[i] == (i < 1 ? i :\n                                       i == 1 ? (size_t)(-1) :\n                                       i < 13 ? i - 1 :\n                                       i == 13 ? (size_t)(-1) :\n                                       i < 20 ? i - 2 :\n                                       i == 20 ? (size_t)(-1) :\n                                       i < 40 ? i - 3 :\n                                       (size_t)(-1)));\n              ASSERT (offsets[41] == MAGIC);\n              free (offsets);\n            }\n          free (result);\n        }\n    }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with EILSEQ.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"Rafa\\305\\202 Maszkowski\"; /* Rafa\u00c5\u0082 Maszkowski */\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n          char *result = NULL;\n          size_t length = 0;\n          int retval = mem_iconveha (input, strlen (input),\n                                     \"UTF-8\", \"ISO-8859-1\",\n                                     false, handler,\n                                     offsets,\n                                     &result, &length);\n          switch (handler)\n            {\n            case iconveh_error:\n              ASSERT (retval == -1 && errno == EILSEQ);\n              ASSERT (result == NULL);\n              if (o)\n                free (offsets);\n              break;\n            case iconveh_question_mark:\n              {\n                static const char expected[] = \"Rafa? Maszkowski\";\n                ASSERT (retval == 0);\n                ASSERT (length == strlen (expected));\n                ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);\n                if (o)\n                  {\n                    for (i = 0; i < 17; i++)\n                      ASSERT (offsets[i] == (i < 5 ? i :\n                                             i == 5 ? (size_t)(-1) :\n                                             i - 1));\n                    ASSERT (offsets[17] == MAGIC);\n                    free (offsets);\n                  }\n                free (result);\n              }\n              break;\n            case iconveh_escape_sequence:\n              {\n                static const char expected[] = \"Rafa\\\\u0142 Maszkowski\";\n                ASSERT (retval == 0);\n                ASSERT (length == strlen (expected));\n                ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);\n                if (o)\n                  {\n                    for (i = 0; i < 17; i++)\n                      ASSERT (offsets[i] == (i < 5 ? i :\n                                             i == 5 ? (size_t)(-1) :\n                                             i + 4));\n                    ASSERT (offsets[17] == MAGIC);\n                    free (offsets);\n                  }\n                free (result);\n              }\n              break;\n            }\n        }\n    }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with EINVAL.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"\\342\";\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n          char *result = NULL;\n          size_t length = 0;\n          int retval = mem_iconveha (input, strlen (input),\n                                     \"UTF-8\", \"ISO-8859-1\",\n                                     false, handler,\n                                     offsets,\n                                     &result, &length);\n          ASSERT (retval == 0);\n          ASSERT (length == 0);\n          if (o)\n            {\n              ASSERT (offsets[0] == 0);\n              ASSERT (offsets[1] == MAGIC);\n              free (offsets);\n            }\n          free (result);\n        }\n    }\n\n  /* autodetect_jp is only supported when iconv() support ISO-2022-JP-2.  */\n# if defined _LIBICONV_VERSION || !(defined _AIX || defined __sgi || defined __hpux || defined __osf__ || defined __sun)\n  if (iconv_supports_encoding (\"ISO-2022-JP-2\"))\n    {\n      /* Test conversions from autodetect_jp to UTF-8.  */\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"\\244\\263\\244\\363\\244\\313\\244\\301\\244\\317\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af in EUC-JP */\n          static const char expected[] = \"\\343\\201\\223\\343\\202\\223\\343\\201\\253\\343\\201\\241\\343\\201\\257\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af */\n          for (o = 0; o < 2; o++)\n            {\n              size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n              char *result = NULL;\n              size_t length = 0;\n              int retval = mem_iconveha (input, strlen (input),\n                                         \"autodetect_jp\", \"UTF-8\",\n                                         false, handler,\n                                         offsets,\n                                         &result, &length);\n              ASSERT (retval == 0);\n              ASSERT (length == strlen (expected));\n              ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);\n              if (o)\n                {\n                  for (i = 0; i < 10; i++)\n                    ASSERT (offsets[i] == ((i % 2) == 0 ? (i / 2) * 3 : (size_t)(-1)));\n                  ASSERT (offsets[10] == MAGIC);\n                  free (offsets);\n                }\n              free (result);\n            }\n        }\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"\\202\\261\\202\\361\\202\\311\\202\\277\\202\\315\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af in Shift_JIS */\n          static const char expected[] = \"\\343\\201\\223\\343\\202\\223\\343\\201\\253\\343\\201\\241\\343\\201\\257\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af */\n          for (o = 0; o < 2; o++)\n            {\n              size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n              char *result = NULL;\n              size_t length = 0;\n              int retval = mem_iconveha (input, strlen (input),\n                                         \"autodetect_jp\", \"UTF-8\",\n                                         false, handler,\n                                         offsets,\n                                         &result, &length);\n              ASSERT (retval == 0);\n              ASSERT (length == strlen (expected));\n              ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);\n              if (o)\n                {\n                  for (i = 0; i < 10; i++)\n                    ASSERT (offsets[i] == ((i % 2) == 0 ? (i / 2) * 3 : (size_t)(-1)));\n                  ASSERT (offsets[10] == MAGIC);\n                  free (offsets);\n                }\n              free (result);\n            }\n        }\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"\\033$B$3$s$K$A$O\\033(B\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af in ISO-2022-JP-2 */\n          static const char expected[] = \"\\343\\201\\223\\343\\202\\223\\343\\201\\253\\343\\201\\241\\343\\201\\257\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af */\n          for (o = 0; o < 2; o++)\n            {\n              size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n              char *result = NULL;\n              size_t length = 0;\n              int retval = mem_iconveha (input, strlen (input),\n                                         \"autodetect_jp\", \"UTF-8\",\n                                         false, handler,\n                                         offsets,\n                                         &result, &length);\n              ASSERT (retval == 0);\n              ASSERT (length == strlen (expected));\n              ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);\n              if (o)\n                {\n                  for (i = 0; i < 16; i++)\n                    ASSERT (offsets[i] == (i == 0 ? 0 :\n                                           i == 5 ? 3 :\n                                           i == 7 ? 6 :\n                                           i == 9 ? 9 :\n                                           i == 11 ? 12 :\n                                           i == 13 ? 15 :\n                                           (size_t)(-1)));\n                  ASSERT (offsets[16] == MAGIC);\n                  free (offsets);\n                }\n              free (result);\n            }\n        }\n    }\n# endif\n\n# if (((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 2) || __GLIBC__ > 2) && !defined __UCLIBC__) || _LIBICONV_VERSION >= 0x0105\n  /* Test conversion from UTF-8 to ISO-8859-1 with transliteration.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"Costs: 27 \\342\\202\\254\"; /* EURO SIGN */\n      static const char expected[] = \"Costs: 27 EUR\";\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n          char *result = NULL;\n          size_t length = 0;\n          int retval = mem_iconveha (input, strlen (input),\n                                     \"UTF-8\", \"ISO-8859-1\",\n                                     true, handler,\n                                     offsets,\n                                     &result, &length);\n          ASSERT (retval == 0);\n          ASSERT (length == strlen (expected));\n          ASSERT (result != NULL && memcmp (result, expected, strlen (expected)) == 0);\n          if (o)\n            {\n              for (i = 0; i < 13; i++)\n                ASSERT (offsets[i] == (i < 11 ? i : (size_t)(-1)));\n              ASSERT (offsets[13] == MAGIC);\n              free (offsets);\n            }\n          free (result);\n        }\n    }\n# endif\n\n  /* ------------------------- Test str_iconveha() ------------------------- */\n\n  /* Test conversion from ISO-8859-2 to ISO-8859-1 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      static const char expected[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      char *result = str_iconveha (input, \"ISO-8859-2\", \"ISO-8859-1\", false, handler);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, expected) == 0);\n      free (result);\n    }\n\n  /* Test conversion from ISO-8859-2 to ISO-8859-1 with EILSEQ.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"Rafa\\263 Maszkowski\"; /* Rafa\u00c5\u0082 Maszkowski */\n      char *result = str_iconveha (input, \"ISO-8859-2\", \"ISO-8859-1\", false, handler);\n      switch (handler)\n        {\n        case iconveh_error:\n          ASSERT (result == NULL && errno == EILSEQ);\n          break;\n        case iconveh_question_mark:\n          {\n            static const char expected[] = \"Rafa? Maszkowski\";\n            ASSERT (result != NULL);\n            ASSERT (strcmp (result, expected) == 0);\n            free (result);\n          }\n          break;\n        case iconveh_escape_sequence:\n          {\n            static const char expected[] = \"Rafa\\\\u0142 Maszkowski\";\n            ASSERT (result != NULL);\n            ASSERT (strcmp (result, expected) == 0);\n            free (result);\n          }\n          break;\n        }\n    }\n\n  /* Test conversion from ISO-8859-1 to UTF-8 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      static const char expected[] = \"\\303\\204rger mit b\\303\\266sen B\\303\\274bchen ohne Augenma\\303\\237\";\n      char *result = str_iconveha (input, \"ISO-8859-1\", \"UTF-8\", false, handler);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, expected) == 0);\n      free (result);\n    }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"\\303\\204rger mit b\\303\\266sen B\\303\\274bchen ohne Augenma\\303\\237\";\n      static const char expected[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      char *result = str_iconveha (input, \"UTF-8\", \"ISO-8859-1\", false, handler);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, expected) == 0);\n      free (result);\n    }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with EILSEQ.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"Costs: 27 \\342\\202\\254\"; /* EURO SIGN */\n      char *result = str_iconveha (input, \"UTF-8\", \"ISO-8859-1\", false, handler);\n      switch (handler)\n        {\n        case iconveh_error:\n          ASSERT (result == NULL && errno == EILSEQ);\n          break;\n        case iconveh_question_mark:\n          {\n            static const char expected[] = \"Costs: 27 ?\";\n            ASSERT (result != NULL);\n            ASSERT (strcmp (result, expected) == 0);\n            free (result);\n          }\n          break;\n        case iconveh_escape_sequence:\n          {\n            static const char expected[] = \"Costs: 27 \\\\u20AC\";\n            ASSERT (result != NULL);\n            ASSERT (strcmp (result, expected) == 0);\n            free (result);\n          }\n          break;\n        }\n    }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with EINVAL.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"\\342\";\n      char *result = str_iconveha (input, \"UTF-8\", \"ISO-8859-1\", false, handler);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"\") == 0);\n      free (result);\n    }\n\n  /* autodetect_jp is only supported when iconv() support ISO-2022-JP-2.  */\n# if defined _LIBICONV_VERSION || !(defined _AIX || defined __sgi || defined __hpux || defined __osf__ || defined __sun)\n  if (iconv_supports_encoding (\"ISO-2022-JP-2\"))\n    {\n      /* Test conversions from autodetect_jp to UTF-8.  */\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"\\244\\263\\244\\363\\244\\313\\244\\301\\244\\317\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af in EUC-JP */\n          static const char expected[] = \"\\343\\201\\223\\343\\202\\223\\343\\201\\253\\343\\201\\241\\343\\201\\257\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af */\n          char *result = str_iconveha (input, \"autodetect_jp\", \"UTF-8\", false, handler);\n          ASSERT (result != NULL);\n          ASSERT (strcmp (result, expected) == 0);\n          free (result);\n        }\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"\\202\\261\\202\\361\\202\\311\\202\\277\\202\\315\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af in Shift_JIS */\n          static const char expected[] = \"\\343\\201\\223\\343\\202\\223\\343\\201\\253\\343\\201\\241\\343\\201\\257\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af */\n          char *result = str_iconveha (input, \"autodetect_jp\", \"UTF-8\", false, handler);\n          ASSERT (result != NULL);\n          ASSERT (strcmp (result, expected) == 0);\n          free (result);\n        }\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"\\033$B$3$s$K$A$O\\033(B\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af in ISO-2022-JP-2 */\n          static const char expected[] = \"\\343\\201\\223\\343\\202\\223\\343\\201\\253\\343\\201\\241\\343\\201\\257\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af */\n          char *result = str_iconveha (input, \"autodetect_jp\", \"UTF-8\", false, handler);\n          ASSERT (result != NULL);\n          ASSERT (strcmp (result, expected) == 0);\n          free (result);\n        }\n    }\n# endif\n\n# if (((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 2) || __GLIBC__ > 2) && !defined __UCLIBC__) || _LIBICONV_VERSION >= 0x0105\n  /* Test conversion from UTF-8 to ISO-8859-1 with transliteration.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"Costs: 27 \\342\\202\\254\"; /* EURO SIGN */\n      static const char expected[] = \"Costs: 27 EUR\";\n      char *result = str_iconveha (input, \"UTF-8\", \"ISO-8859-1\", true, handler);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, expected) == 0);\n      free (result);\n    }\n# endif\n\n#endif\n\n  return 0;\n}",
      "lines": 560,
      "depth": 27,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-string.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-strncat.c": {
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\"\n       in UTF-8 encoding.  */\n    static const char input[] =\n      { 'G', 'r', (char) 0xC3, (char) 0xBC, (char) 0xC3, (char) 0x9F, ' ',\n        'G', 'o', 't', 't', '.', ' ', (char) 0xD0, (char) 0x97, (char) 0xD0,\n        (char) 0xB4, (char) 0xD1, (char) 0x80, (char) 0xD0, (char) 0xB0,\n        (char) 0xD0, (char) 0xB2, (char) 0xD1, (char) 0x81, (char) 0xD1,\n        (char) 0x82, (char) 0xD0, (char) 0xB2, (char) 0xD1, (char) 0x83,\n        (char) 0xD0, (char) 0xB9, (char) 0xD1, (char) 0x82, (char) 0xD0,\n        (char) 0xB5, '!', ' ', 'x', '=', '(', '-', 'b', (char) 0xC2,\n        (char) 0xB1, 's', 'q', 'r', 't', '(', 'b', (char) 0xC2, (char) 0xB2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        (char) 0xE6, (char) 0x97, (char) 0xA5, (char) 0xE6, (char) 0x9C,\n        (char) 0xAC, (char) 0xE8, (char) 0xAA, (char) 0x9E, ',', (char) 0xE4,\n        (char) 0xB8, (char) 0xAD, (char) 0xE6, (char) 0x96, (char) 0x87, ',',\n        (char) 0xED, (char) 0x95, (char) 0x9C, (char) 0xEA, (char) 0xB8,\n        (char) 0x80, '\\0'\n      };\n    check (input, SIZEOF (input));\n  }\n\n  return 0;\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-strstr.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        278,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n#if HAVE_DECL_ALARM\n  /* Declare failure if test takes too long, by using default abort\n     caused by SIGALRM.  All known platforms that lack alarm also have\n     a quadratic strstr, and the replacement strstr is known to not\n     take too long.  */\n  int alarm_value = 50;\n  signal (SIGALRM, SIG_DFL);\n  alarm (alarm_value);\n#endif\n\n  {\n    const char input[] = \"foo\";\n    const char *result = strstr (input, \"\");\n    ASSERT (result == input);\n  }\n\n  {\n    const char input[] = \"foo\";\n    const char *result = strstr (input, \"o\");\n    ASSERT (result == input + 1);\n  }\n\n  {\n    /* On some platforms, the memchr() functions reads past the first\n       occurrence of the byte to be searched, leading to an out-of-bounds\n       read access for strstr().\n       See <https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=521737>.\n       This is a bug in memchr(), see the Austin Group's clarification\n       <http://www.opengroup.org/austin/docs/austin_454.txt>.  */\n    const char *fix = \"aBaaaaaaaaaaax\";\n    char *page_boundary = (char *) zerosize_ptr ();\n    size_t len = strlen (fix) + 1;\n    char *input = page_boundary ? page_boundary - len : malloc (len);\n    const char *result;\n\n    strcpy (input, fix);\n    result = strstr (input, \"B1x\");\n    ASSERT (result == NULL);\n    if (!page_boundary)\n      free (input);\n  }\n\n  {\n    const char input[] = \"ABC ABCDAB ABCDABCDABDE\";\n    const char *result = strstr (input, \"ABCDABD\");\n    ASSERT (result == input + 15);\n  }\n\n  {\n    const char input[] = \"ABC ABCDAB ABCDABCDABDE\";\n    const char *result = strstr (input, \"ABCDABE\");\n    ASSERT (result == NULL);\n  }\n\n  {\n    const char input[] = \"ABC ABCDAB ABCDABCDABDE\";\n    const char *result = strstr (input, \"ABCDABCD\");\n    ASSERT (result == input + 11);\n  }\n\n  /* Check that a long periodic needle does not cause false positives.  */\n  {\n    const char input[] = \"F_BD_CE_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD\"\n                         \"_C3_88_20_EF_BF_BD_EF_BF_BD_EF_BF_BD\"\n                         \"_C3_A7_20_EF_BF_BD\";\n    const char need[] = \"_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD\";\n    const char *result = strstr (input, need);\n    ASSERT (result == NULL);\n  }\n  {\n    const char input[] = \"F_BD_CE_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD\"\n                         \"_C3_88_20_EF_BF_BD_EF_BF_BD_EF_BF_BD\"\n                         \"_C3_A7_20_EF_BF_BD_DA_B5_C2_A6_20\"\n                         \"_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD\";\n    const char need[] = \"_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD\";\n    const char *result = strstr (input, need);\n    ASSERT (result == input + 115);\n  }\n\n  /* Check that a very long haystack is handled quickly if the needle is\n     short and occurs near the beginning.  */\n  {\n    size_t repeat = 10000;\n    size_t m = 1000000;\n    const char *needle =\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\n    char *haystack = (char *) malloc (m + 1);\n    if (haystack != NULL)\n      {\n        memset (haystack, 'A', m);\n        haystack[0] = 'B';\n        haystack[m] = '\\0';\n\n        for (; repeat > 0; repeat--)\n          {\n            ASSERT (strstr (haystack, needle) == haystack + 1);\n          }\n\n        free (haystack);\n      }\n  }\n\n  /* Check that a very long needle is discarded quickly if the haystack is\n     short.  */\n  {\n    size_t repeat = 10000;\n    size_t m = 1000000;\n    const char *haystack =\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"ABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABAB\";\n    char *needle = (char *) malloc (m + 1);\n    if (needle != NULL)\n      {\n        memset (needle, 'A', m);\n        needle[m] = '\\0';\n\n        for (; repeat > 0; repeat--)\n          {\n            ASSERT (strstr (haystack, needle) == NULL);\n          }\n\n        free (needle);\n      }\n  }\n\n  /* Check that the asymptotic worst-case complexity is not quadratic.  */\n  {\n    size_t m = 1000000;\n    char *haystack = (char *) malloc (2 * m + 2);\n    char *needle = (char *) malloc (m + 2);\n    if (haystack != NULL && needle != NULL)\n      {\n        const char *result;\n\n        memset (haystack, 'A', 2 * m);\n        haystack[2 * m] = 'B';\n        haystack[2 * m + 1] = '\\0';\n\n        memset (needle, 'A', m);\n        needle[m] = 'B';\n        needle[m + 1] = '\\0';\n\n        result = strstr (haystack, needle);\n        ASSERT (result == haystack + m);\n      }\n    free (needle);\n    free (haystack);\n  }\n\n  /* Sublinear speed is only possible in memmem; strstr must examine\n     every character of haystack to find its length.  */\n\n\n  {\n    /* Ensure that with a barely periodic \"short\" needle, strstr's\n       search does not mistakenly skip just past the match point.\n       This use of strstr would mistakenly return NULL before\n       gnulib v0.0-4927.  */\n    const char *haystack =\n      \"\\n\"\n      \"with_build_libsubdir\\n\"\n      \"with_local_prefix\\n\"\n      \"with_gxx_include_dir\\n\"\n      \"with_cpp_install_dir\\n\"\n      \"enable_generated_files_in_srcdir\\n\"\n      \"with_gnu_ld\\n\"\n      \"with_ld\\n\"\n      \"with_demangler_in_ld\\n\"\n      \"with_gnu_as\\n\"\n      \"with_as\\n\"\n      \"enable_largefile\\n\"\n      \"enable_werror_always\\n\"\n      \"enable_checking\\n\"\n      \"enable_coverage\\n\"\n      \"enable_gather_detailed_mem_stats\\n\"\n      \"enable_build_with_cxx\\n\"\n      \"with_stabs\\n\"\n      \"enable_multilib\\n\"\n      \"enable___cxa_atexit\\n\"\n      \"enable_decimal_float\\n\"\n      \"enable_fixed_point\\n\"\n      \"enable_threads\\n\"\n      \"enable_tls\\n\"\n      \"enable_objc_gc\\n\"\n      \"with_dwarf2\\n\"\n      \"enable_shared\\n\"\n      \"with_build_sysroot\\n\"\n      \"with_sysroot\\n\"\n      \"with_specs\\n\"\n      \"with_pkgversion\\n\"\n      \"with_bugurl\\n\"\n      \"enable_languages\\n\"\n      \"with_multilib_list\\n\";\n    const char *needle = \"\\n\"\n      \"with_gnu_ld\\n\";\n    const char* p = strstr (haystack, needle);\n    ASSERT (p - haystack == 114);\n  }\n\n  {\n    /* Same bug, shorter trigger.  */\n    const char *haystack = \"..wi.d.\";\n    const char *needle = \".d.\";\n    const char* p = strstr (haystack, needle);\n    ASSERT (p - haystack == 4);\n  }\n\n  {\n    /* Like the above, but trigger the flaw in two_way_long_needle\n       by using a needle of length LONG_NEEDLE_THRESHOLD (32) or greater.\n       Rather than trying to find the right alignment manually, I've\n       arbitrarily chosen the following needle and template for the\n       haystack, and ensure that for each placement of the needle in\n       that haystack, strstr finds it.  */\n    const char *needle = \"\\nwith_gnu_ld-extend-to-len-32-b\\n\";\n    const char *h =\n      \"\\n\"\n      \"with_build_libsubdir\\n\"\n      \"with_local_prefix\\n\"\n      \"with_gxx_include_dir\\n\"\n      \"with_cpp_install_dir\\n\"\n      \"with_e_\\n\"\n      \"..............................\\n\"\n      \"with_FGHIJKLMNOPQRSTUVWXYZ\\n\"\n      \"with_567890123456789\\n\"\n      \"with_multilib_list\\n\";\n    size_t h_len = strlen (h);\n    char *haystack = malloc (h_len + 1);\n    size_t i;\n    ASSERT (haystack);\n    for (i = 0; i < h_len - strlen (needle); i++)\n      {\n        const char *p;\n        memcpy (haystack, h, h_len + 1);\n        memcpy (haystack + i, needle, strlen (needle) + 1);\n        p = strstr (haystack, needle);\n        ASSERT (p);\n        ASSERT (p - haystack == i);\n      }\n    free (haystack);\n  }\n\n  return 0;\n}",
      "lines": 248,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-sys_types.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-sys_wait.h": {
    "test_sys_wait_macros": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static int\ntest_sys_wait_macros (void)\n{\n  /* Check subset of <sys/wait.h> macros that must be visible here.\n     Note that some of these macros are only portable when operating\n     on an lvalue.  */\n  int i;\n  for (i = 0; i < 0x8000; i = (i ? i << 1 : 1))\n    {\n      /* POSIX requires that for all valid process statuses, that\n         exactly one of these three macros is true.  But not all\n         possible 16-bit values map to valid process status.\n         Traditionally, 8 of the bits are for WIFEXITED, 7 of the bits\n         to tell between WIFSIGNALED and WIFSTOPPED, and either 0x80\n         or 0x8000 to flag that core was also dumped.  Since we don't\n         know which byte is WIFEXITED, we skip the both possible bits\n         that can signal core dump.  */\n      if (i == 0x80)\n        continue;\n      if (!!WIFSIGNALED (i) + !!WIFEXITED (i) + !!WIFSTOPPED (i) != 1)\n        return 1;\n    }\n  i = WEXITSTATUS (i) + WSTOPSIG (i) + WTERMSIG (i);\n\n  switch (i)\n    {\n#if 0\n  /* Gnulib doesn't guarantee these, yet.  */\n    case WNOHANG:\n    case WUNTRACED:\n#endif\n      break;\n    }\n  return 0;\n}",
      "lines": 35,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-thread_create.c": {
    "worker_thread_func": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "static void *\nworker_thread_func (void *arg)\n{\n  work_done = 1;\n  return &dummy;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nworker_thread_func (void *arg)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nmain ()\n{\n  main_thread_before = gl_thread_self ();\n\n  if (glthread_create (&worker_thread, worker_thread_func, NULL) == 0)\n    {\n      void *ret;\n\n      /* Check that gl_thread_self () has the same value before than after the\n         first call to gl_thread_create ().  */\n      main_thread_after = gl_thread_self ();\n      ASSERT (memcmp (&main_thread_before, &main_thread_after,\n                      sizeof (gl_thread_t))\n              == 0);\n\n      gl_thread_join (worker_thread, &ret);\n\n      /* Check the return value of the thread.  */\n      ASSERT (ret == &dummy);\n\n      /* Check that worker_thread_func () has finished executing.  */\n      ASSERT (work_done);\n\n      return 0;\n    }\n  else\n    {\n#if USE_POSIX_THREADS || USE_SOLARIS_THREADS || USE_PTH_THREADS || USE_WINDOWS_THREADS\n      fputs (\"glthread_create failed\\n\", stderr);\n      return 1;\n#else\n      fputs (\"Skipping test: multithreading not enabled\\n\", stderr);\n      return 77;\n#endif\n    }\n}",
      "lines": 37,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-thread_self.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Check that gl_thread_self () can be used with just $(LIBTHREAD), not\n     $(LIBMULTITHREAD), i.e. in libraries that are multithread-safe but don't\n     create threads themselves.  */\n  main_thread = gl_thread_self ();\n\n  return 0;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-time.c": {
    "main": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-unistd.c": {
    "main": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-unsetenv.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nmain (void)\n{\n  char entry[] = \"b=2\";\n\n  /* Test removal when multiple entries present.  */\n  ASSERT (putenv ((char *) \"a=1\") == 0);\n  ASSERT (putenv (entry) == 0);\n  entry[0] = 'a'; /* Unspecified what getenv(\"a\") would be at this point.  */\n  ASSERT (unsetenv (\"a\") == 0); /* Both entries will be removed.  */\n  ASSERT (getenv (\"a\") == NULL);\n  ASSERT (unsetenv (\"a\") == 0);\n\n  /* Required to fail with EINVAL.  */\n  errno = 0;\n  ASSERT (unsetenv (\"\") == -1);\n  ASSERT (errno == EINVAL);\n  errno = 0;\n  ASSERT (unsetenv (\"a=b\") == -1);\n  ASSERT (errno == EINVAL);\n#if 0\n  /* glibc and gnulib's implementation guarantee this, but POSIX no\n     longer requires it: http://austingroupbugs.net/view.php?id=185  */\n  errno = 0;\n  ASSERT (unsetenv (NULL) == -1);\n  ASSERT (errno == EINVAL);\n#endif\n\n  return 0;\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-usleep.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "int\nmain (void)\n{\n  time_t start = time (NULL);\n  ASSERT (usleep (1000000) == 0);\n  ASSERT (start < time (NULL));\n\n  ASSERT (usleep (0) == 0);\n\n  return 0;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-verify-try.c": {},
  "libunistring/libunistring-0.9.10/tests/test-verify.c": {
    "function": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "static int\nfunction (int n)\n{\n#if EXP_FAIL == 3\n  verify (n >= 0);                  /* should give ERROR: non-constant expression */\n#endif\n  verify (c == 2);                  /* should be ok */\n#if EXP_FAIL == 4\n  verify (1 + 1 == 3);              /* should give ERROR */\n#endif\n  verify (1 == 1); verify (1 == 1); /* should be ok */\n\n  if (n)\n    return ((void) verify_expr (1 == 1, 1), verify_expr (1 == 1, 8)); /* should be ok */\n#if EXP_FAIL == 5\n  return verify_expr (1 == 2, 5); /* should give ERROR */\n#endif\n  return 0;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int\nmain (void)\n{\n  return !(function (0) == 0 && function (1) == 8);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-wchar.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-wcrtomb-w32.c": {
    "test_one_locale": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        296,
        1
      ],
      "content": "static int\ntest_one_locale (const char *name, int codepage)\n{\n  char buf[64];\n  size_t ret;\n\n# if 1\n  /* Portable code to set the locale.  */\n  {\n    char name_with_codepage[1024];\n\n    sprintf (name_with_codepage, \"%s.%d\", name, codepage);\n\n    /* Set the locale.  */\n    if (setlocale (LC_ALL, name_with_codepage) == NULL)\n      return 77;\n  }\n# else\n  /* Hacky way to set a locale.codepage combination that setlocale() refuses\n     to set.  */\n  {\n    /* Codepage of the current locale, set with setlocale().\n       Not necessarily the same as GetACP().  */\n    extern __declspec(dllimport) unsigned int __lc_codepage;\n\n    /* Set the locale.  */\n    if (setlocale (LC_ALL, name) == NULL)\n      return 77;\n\n    /* Clobber the codepage and MB_CUR_MAX, both set by setlocale().  */\n    __lc_codepage = codepage;\n    switch (codepage)\n      {\n      case 1252:\n      case 1256:\n        MB_CUR_MAX = 1;\n        break;\n      case 932:\n      case 950:\n      case 936:\n        MB_CUR_MAX = 2;\n        break;\n      case 54936:\n      case 65001:\n        MB_CUR_MAX = 4;\n        break;\n      }\n\n    /* Test whether the codepage is really available.  */\n    {\n      mbstate_t state;\n      wchar_t wc;\n\n      memset (&state, '\\0', sizeof (mbstate_t));\n      if (mbrtowc (&wc, \" \", 1, &state) == (size_t)(-1))\n        return 77;\n    }\n  }\n# endif\n\n  /* Test NUL character.  */\n  {\n    buf[0] = 'x';\n    ret = wcrtomb (buf, 0, NULL);\n    ASSERT (ret == 1);\n    ASSERT (buf[0] == '\\0');\n  }\n\n  /* Test single bytes.  */\n  {\n    int c;\n\n    for (c = 0; c < 0x100; c++)\n      switch (c)\n        {\n        case '\\t': case '\\v': case '\\f':\n        case ' ': case '!': case '\"': case '#': case '%':\n        case '&': case '\\'': case '(': case ')': case '*':\n        case '+': case ',': case '-': case '.': case '/':\n        case '0': case '1': case '2': case '3': case '4':\n        case '5': case '6': case '7': case '8': case '9':\n        case ':': case ';': case '<': case '=': case '>':\n        case '?':\n        case 'A': case 'B': case 'C': case 'D': case 'E':\n        case 'F': case 'G': case 'H': case 'I': case 'J':\n        case 'K': case 'L': case 'M': case 'N': case 'O':\n        case 'P': case 'Q': case 'R': case 'S': case 'T':\n        case 'U': case 'V': case 'W': case 'X': case 'Y':\n        case 'Z':\n        case '[': case '\\\\': case ']': case '^': case '_':\n        case 'a': case 'b': case 'c': case 'd': case 'e':\n        case 'f': case 'g': case 'h': case 'i': case 'j':\n        case 'k': case 'l': case 'm': case 'n': case 'o':\n        case 'p': case 'q': case 'r': case 's': case 't':\n        case 'u': case 'v': case 'w': case 'x': case 'y':\n        case 'z': case '{': case '|': case '}': case '~':\n          /* c is in the ISO C \"basic character set\".  */\n          ret = wcrtomb (buf, btowc (c), NULL);\n          ASSERT (ret == 1);\n          ASSERT (buf[0] == (char) c);\n          break;\n        }\n  }\n\n  /* Test special calling convention, passing a NULL pointer.  */\n  {\n    ret = wcrtomb (NULL, '\\0', NULL);\n    ASSERT (ret == 1);\n    ret = wcrtomb (NULL, btowc ('x'), NULL);\n    ASSERT (ret == 1);\n  }\n\n  switch (codepage)\n    {\n    case 1252:\n      /* Locale encoding is CP1252, an extension of ISO-8859-1.  */\n      {\n        /* Convert \"B\\374\\337er\": \"B\u00c3\u00bc\u00c3\u009fer\" */\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x00FC, NULL);\n        ASSERT (ret == 1);\n        ASSERT (memcmp (buf, \"\\374\", 1) == 0);\n        ASSERT (buf[1] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x00DF, NULL);\n        ASSERT (ret == 1);\n        ASSERT (memcmp (buf, \"\\337\", 1) == 0);\n        ASSERT (buf[1] == 'x');\n      }\n      return 0;\n\n    case 1256:\n      /* Locale encoding is CP1256, not the same as ISO-8859-6.  */\n      {\n        /* Convert \"x\\302\\341\\346y\": \"x\u00d8\u00a2\u00d9\u0084\u00d9\u0088y\" */\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x0622, NULL);\n        ASSERT (ret == 1);\n        ASSERT (memcmp (buf, \"\\302\", 1) == 0);\n        ASSERT (buf[1] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x0644, NULL);\n        ASSERT (ret == 1);\n        ASSERT (memcmp (buf, \"\\341\", 1) == 0);\n        ASSERT (buf[1] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x0648, NULL);\n        ASSERT (ret == 1);\n        ASSERT (memcmp (buf, \"\\346\", 1) == 0);\n        ASSERT (buf[1] == 'x');\n      }\n      return 0;\n\n    case 932:\n      /* Locale encoding is CP932, similar to Shift_JIS.  */\n      {\n        /* Convert \"<\\223\\372\\226\\173\\214\\352>\": \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x65E5, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\223\\372\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x672C, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\226\\173\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x8A9E, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\214\\352\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n      }\n      return 0;\n\n    case 950:\n      /* Locale encoding is CP950, similar to Big5.  */\n      {\n        /* Convert \"<\\244\\351\\245\\273\\273\\171>\": \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x65E5, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\244\\351\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x672C, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\245\\273\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x8A9E, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\273\\171\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n      }\n      return 0;\n\n    case 936:\n      /* Locale encoding is CP936 = GBK, an extension of GB2312.  */\n      {\n        /* Convert \"<\\310\\325\\261\\276\\325\\132>\": \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x65E5, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\310\\325\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x672C, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\261\\276\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x8A9E, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\325\\132\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n      }\n      return 0;\n\n    case 54936:\n      /* Locale encoding is CP54936 = GB18030.  */\n      {\n        /* Convert \"B\\250\\271\\201\\060\\211\\070er\": \"B\u00c3\u00bc\u00c3\u009fer\" */\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x00FC, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\250\\271\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x00DF, NULL);\n        ASSERT (ret == 4);\n        ASSERT (memcmp (buf, \"\\201\\060\\211\\070\", 4) == 0);\n        ASSERT (buf[4] == 'x');\n      }\n      return 0;\n\n    case 65001:\n      /* Locale encoding is CP65001 = UTF-8.  */\n      {\n        /* Convert \"B\\303\\274\\303\\237er\": \"B\u00c3\u00bc\u00c3\u009fer\" */\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x00FC, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\303\\274\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x00DF, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\303\\237\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n      }\n      return 0;\n\n    default:\n      return 1;\n    }\n}",
      "lines": 268,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": [
      {
        "start_point": [
          298,
          0
        ],
        "end_point": [
          320,
          1
        ],
        "content": "int\nmain (int argc, char *argv[])\n{\n  int codepage = atoi (argv[argc - 1]);\n  int result;\n  int i;\n\n  result = 77;\n  for (i = 1; i < argc - 1; i++)\n    {\n      int ret = test_one_locale (argv[i], codepage);\n\n      if (ret != 77)\n        result = ret;\n    }\n\n  if (result == 77)\n    {\n      fprintf (stderr, \"Skipping test: found no locale with codepage %d\\n\",\n               codepage);\n    }\n  return result;\n}",
        "lines": 23,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          324,
          0
        ],
        "end_point": [
          329,
          1
        ],
        "content": "int\nmain (int argc, char *argv[])\n{\n  fputs (\"Skipping test: not a native Windows system\\n\", stderr);\n  return 77;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/tests/test-wcrtomb.c": {
    "check_character": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static void\ncheck_character (const char *s, size_t n)\n{\n  wchar_t wc;\n  char buf[64];\n  int iret;\n  size_t ret;\n\n  wc = (wchar_t) 0xBADFACE;\n  iret = mbtowc (&wc, s, n);\n  ASSERT (iret == n);\n\n  ret = wcrtomb (buf, wc, NULL);\n  ASSERT (ret == n);\n  ASSERT (memcmp (buf, s, n) == 0);\n\n  /* Test special calling convention, passing a NULL pointer.  */\n  ret = wcrtomb (NULL, wc, NULL);\n  ASSERT (ret == 1);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  char buf[64];\n  size_t ret;\n\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  /* Test NUL character.  */\n  {\n    buf[0] = 'x';\n    ret = wcrtomb (buf, 0, NULL);\n    ASSERT (ret == 1);\n    ASSERT (buf[0] == '\\0');\n  }\n\n  /* Test single bytes.  */\n  {\n    int c;\n\n    for (c = 0; c < 0x100; c++)\n      switch (c)\n        {\n        case '\\t': case '\\v': case '\\f':\n        case ' ': case '!': case '\"': case '#': case '%':\n        case '&': case '\\'': case '(': case ')': case '*':\n        case '+': case ',': case '-': case '.': case '/':\n        case '0': case '1': case '2': case '3': case '4':\n        case '5': case '6': case '7': case '8': case '9':\n        case ':': case ';': case '<': case '=': case '>':\n        case '?':\n        case 'A': case 'B': case 'C': case 'D': case 'E':\n        case 'F': case 'G': case 'H': case 'I': case 'J':\n        case 'K': case 'L': case 'M': case 'N': case 'O':\n        case 'P': case 'Q': case 'R': case 'S': case 'T':\n        case 'U': case 'V': case 'W': case 'X': case 'Y':\n        case 'Z':\n        case '[': case '\\\\': case ']': case '^': case '_':\n        case 'a': case 'b': case 'c': case 'd': case 'e':\n        case 'f': case 'g': case 'h': case 'i': case 'j':\n        case 'k': case 'l': case 'm': case 'n': case 'o':\n        case 'p': case 'q': case 'r': case 's': case 't':\n        case 'u': case 'v': case 'w': case 'x': case 'y':\n        case 'z': case '{': case '|': case '}': case '~':\n          /* c is in the ISO C \"basic character set\".  */\n          ret = wcrtomb (buf, btowc (c), NULL);\n          ASSERT (ret == 1);\n          ASSERT (buf[0] == (char) c);\n          break;\n        }\n  }\n\n  /* Test special calling convention, passing a NULL pointer.  */\n  {\n    ret = wcrtomb (NULL, '\\0', NULL);\n    ASSERT (ret == 1);\n    ret = wcrtomb (NULL, btowc ('x'), NULL);\n    ASSERT (ret == 1);\n  }\n\n  if (argc > 1)\n    switch (argv[1][0])\n      {\n      case '1':\n        /* Locale encoding is ISO-8859-1 or ISO-8859-15.  */\n        {\n          const char input[] = \"B\\374\\337er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n\n          check_character (input + 1, 1);\n          check_character (input + 2, 1);\n        }\n        return 0;\n\n      case '2':\n        /* Locale encoding is UTF-8.  */\n        {\n          const char input[] = \"B\\303\\274\\303\\237er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n\n          check_character (input + 1, 2);\n          check_character (input + 3, 2);\n        }\n        return 0;\n\n      case '3':\n        /* Locale encoding is EUC-JP.  */\n        {\n          const char input[] = \"<\\306\\374\\313\\334\\270\\354>\"; /* \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n\n          check_character (input + 1, 2);\n          check_character (input + 3, 2);\n          check_character (input + 5, 2);\n        }\n        return 0;\n\n      case '4':\n        /* Locale encoding is GB18030.  */\n        {\n          const char input[] = \"B\\250\\271\\201\\060\\211\\070er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n\n          check_character (input + 1, 2);\n          check_character (input + 3, 4);\n        }\n        return 0;\n      }\n\n  return 1;\n}",
      "lines": 109,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-wctype-h.c": {
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Check that the isw* functions exist as functions or as macros.  */\n  (void) iswalnum (0);\n  (void) iswalpha (0);\n  (void) iswcntrl (0);\n  (void) iswdigit (0);\n  (void) iswgraph (0);\n  (void) iswlower (0);\n  (void) iswprint (0);\n  (void) iswpunct (0);\n  (void) iswspace (0);\n  (void) iswupper (0);\n  (void) iswxdigit (0);\n\n  /* Check that the isw* functions map WEOF to 0.  */\n  ASSERT (!iswalnum (e));\n  ASSERT (!iswalpha (e));\n  ASSERT (!iswcntrl (e));\n  ASSERT (!iswdigit (e));\n  ASSERT (!iswgraph (e));\n  ASSERT (!iswlower (e));\n  ASSERT (!iswprint (e));\n  ASSERT (!iswpunct (e));\n  ASSERT (!iswspace (e));\n  ASSERT (!iswupper (e));\n  ASSERT (!iswxdigit (e));\n\n  /* Check that the tow* functions exist as functions or as macros.  */\n  (void) towlower (0);\n  (void) towupper (0);\n\n  /* Check that the tow* functions map WEOF to WEOF.  */\n  ASSERT (towlower (e) == e);\n  ASSERT (towupper (e) == e);\n\n  return 0;\n}",
      "lines": 39,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-wcwidth.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "int\nmain ()\n{\n  wchar_t wc;\n\n#ifdef C_CTYPE_ASCII\n  /* Test width of ASCII characters.  */\n  for (wc = 0x20; wc < 0x7F; wc++)\n    ASSERT (wcwidth (wc) == 1);\n#endif\n\n  /* Switch to an UTF-8 locale.  */\n  if (setlocale (LC_ALL, \"fr_FR.UTF-8\") != NULL\n      /* Check whether it's really an UTF-8 locale.\n         On OpenBSD 4.0, the setlocale call succeeds only for the LC_CTYPE\n         category and therefore returns \"C/fr_FR.UTF-8/C/C/C/C\", but the\n         LC_CTYPE category is effectively set to an ASCII LC_CTYPE category;\n         in particular, locale_charset() returns \"ASCII\".  */\n      && strcmp (locale_charset (), \"UTF-8\") == 0)\n    {\n      /* Test width of ASCII characters.  */\n      for (wc = 0x20; wc < 0x7F; wc++)\n        ASSERT (wcwidth (wc) == 1);\n\n      /* Test width of some non-spacing characters.  */\n      ASSERT (wcwidth (0x0301) == 0);\n      ASSERT (wcwidth (0x05B0) == 0);\n\n      /* Test width of some format control characters.  */\n      ASSERT (wcwidth (0x200E) <= 0);\n      ASSERT (wcwidth (0x2060) <= 0);\n#if 0  /* wchar_t may be only 16 bits.  */\n      ASSERT (wcwidth (0xE0001) <= 0);\n      ASSERT (wcwidth (0xE0044) <= 0);\n#endif\n\n      /* Test width of some zero width characters.  */\n      ASSERT (wcwidth (0x200B) == 0);\n      ASSERT (wcwidth (0xFEFF) <= 0);\n\n      /* Test width of some CJK characters.  */\n      ASSERT (wcwidth (0x3000) == 2);\n      ASSERT (wcwidth (0xB250) == 2);\n      ASSERT (wcwidth (0xFF1A) == 2);\n#if 0  /* wchar_t may be only 16 bits.  */\n      ASSERT (wcwidth (0x20369) == 2);\n      ASSERT (wcwidth (0x2F876) == 2);\n#endif\n    }\n\n  return 0;\n}",
      "lines": 52,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/test-xalloc-die.c": {
    "main": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "int\nmain (int argc _GL_UNUSED, char **argv)\n{\n  xalloc_die ();\n  return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/time.in.h": {},
  "libunistring/libunistring-0.9.10/tests/unsetenv.c": {
    "unsetenv": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "int\nunsetenv (const char *name)\n{\n  size_t len;\n  char **ep;\n\n  if (name == NULL || *name == '\\0' || strchr (name, '=') != NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  len = strlen (name);\n\n  LOCK;\n\n  ep = __environ;\n  while (*ep != NULL)\n    if (!strncmp (*ep, name, len) && (*ep)[len] == '=')\n      {\n        /* Found it.  Remove this pointer by moving later ones back.  */\n        char **dp = ep;\n\n        do\n          dp[0] = dp[1];\n        while (*dp++);\n        /* Continue the loop in case NAME appears again.  */\n      }\n    else\n      ++ep;\n\n  UNLOCK;\n\n  return 0;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "rpl_unsetenv": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "int\nrpl_unsetenv (const char *name)\n{\n  int result = 0;\n  if (!name || !*name || strchr (name, '='))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  while (getenv (name))\n# if !VOID_UNSETENV\n    result =\n# endif\n      unsetenv (name);\n  return result;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unused-parameter.h": {},
  "libunistring/libunistring-0.9.10/tests/usleep.c": {
    "usleep": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\nusleep (useconds_t micro)\n{\n  unsigned int seconds = micro / 1000000;\n  if (sizeof seconds < sizeof micro && micro / 1000000 != seconds)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  if (!HAVE_USLEEP && micro % 1000000)\n    seconds++;\n  while ((seconds = sleep (seconds)) != 0);\n\n#undef usleep\n#if !HAVE_USLEEP\n# define usleep(x) 0\n#endif\n  return usleep (micro % 1000000);\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/warn-on-use.h": {},
  "libunistring/libunistring-0.9.10/tests/wcrtomb.c": {
    "wcrtomb": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "size_t\nwcrtomb (char *s, wchar_t wc, mbstate_t *ps)\n{\n  /* This implementation of wcrtomb on top of wctomb() supports only\n     stateless encodings.  ps must be in the initial state.  */\n  if (ps != NULL && !mbsinit (ps))\n    {\n      errno = EINVAL;\n      return (size_t)(-1);\n    }\n\n  if (s == NULL)\n    /* We know the NUL wide character corresponds to the NUL character.  */\n    return 1;\n  else\n    {\n      int ret = wctomb (s, wc);\n\n      if (ret >= 0)\n        return ret;\n      else\n        {\n          errno = EILSEQ;\n          return (size_t)(-1);\n        }\n    }\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "size_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/wctob.c": {
    "wctob": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "int\nwctob (wint_t wc)\n{\n  char buf[64];\n\n  if (!(MB_CUR_MAX <= sizeof (buf)))\n    abort ();\n  /* Handle the case where WEOF is a value that does not fit in a wchar_t.  */\n  if (wc == (wchar_t)wc)\n    if (wctomb (buf, (wchar_t)wc) == 1)\n      return (unsigned char) buf[0];\n  return EOF;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/wctomb-impl.h": {
    "wctomb": {
      "start_point": [
        17,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\nwctomb (char *s, wchar_t wc)\n{\n  if (s == NULL)\n    return 0;\n  else\n    {\n      mbstate_t state;\n      size_t result;\n\n      memset (&state, 0, sizeof (mbstate_t));\n      result = wcrtomb (s, wc, &state);\n      if (result == (size_t)-1)\n        return -1;\n      return result;\n    }\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/wctomb.c": {},
  "libunistring/libunistring-0.9.10/tests/xalloc-die.c": {
    "xalloc_die": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "void\nxalloc_die (void)\n{\n  error (exit_failure, 0, \"%s\", _(\"memory exhausted\"));\n\n  /* _Noreturn cannot be given to error, since it may return if\n     its first argument is 0.  To help compilers understand the\n     xalloc_die does not return, call abort.  Also, the abort is a\n     safety feature if exit_failure is 0 (which shouldn't happen).  */\n  abort ();\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/xalloc.h": {
    "xnmalloc": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "XALLOC_INLINE void *\nxnmalloc (size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xmalloc (n * s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "XALLOC_INLINE",
        "void",
        "void",
        "*\nxnmalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xnrealloc": [
      {
        "start_point": [
          110,
          0
        ],
        "end_point": [
          116,
          1
        ],
        "content": "XALLOC_INLINE void *\nxnrealloc (void *p, size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xrealloc (p, n * s);\n}",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "XALLOC_INLINE",
          "void",
          "void",
          "*\nxnrealloc (void *p, size_t n, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          233,
          29
        ],
        "end_point": [
          237,
          1
        ],
        "content": "T *\nxnrealloc (T *p, size_t n, size_t s)\n{\n  return (T *) xnrealloc ((void *) p, n, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nxnrealloc (T *p, size_t n, size_t s)",
          "*"
        ]
      }
    ],
    "x2nrealloc": [
      {
        "start_point": [
          172,
          0
        ],
        "end_point": [
          207,
          1
        ],
        "content": "XALLOC_INLINE void *\nx2nrealloc (void *p, size_t *pn, size_t s)\n{\n  size_t n = *pn;\n\n  if (! p)\n    {\n      if (! n)\n        {\n          /* The approximate size to use for initial small allocation\n             requests, when the invoking code specifies an old size of\n             zero.  This is the largest \"small\" request for the GNU C\n             library malloc.  */\n          enum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };\n\n          n = DEFAULT_MXFAST / s;\n          n += !n;\n        }\n      if (xalloc_oversized (n, s))\n        xalloc_die ();\n    }\n  else\n    {\n      /* Set N = floor (1.5 * N) + 1 so that progress is made even if N == 0.\n         Check for overflow, so that N * S stays in both ptrdiff_t and\n         size_t range.  The check may be slightly conservative, but an\n         exact check isn't worth the trouble.  */\n      if ((PTRDIFF_MAX < SIZE_MAX ? PTRDIFF_MAX : SIZE_MAX) / 3 * 2 / s\n          <= n)\n        xalloc_die ();\n      n += n / 2 + 1;\n    }\n\n  *pn = n;\n  return xrealloc (p, n * s);\n}",
        "lines": 36,
        "depth": 14,
        "decorators": [
          "XALLOC_INLINE",
          "void",
          "void",
          "*\nx2nrealloc (void *p, size_t *pn, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          245,
          29
        ],
        "end_point": [
          249,
          1
        ],
        "content": "T *\nx2nrealloc (T *p, size_t *pn, size_t s)\n{\n  return (T *) x2nrealloc ((void *) p, pn, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nx2nrealloc (T *p, size_t *pn, size_t s)",
          "*"
        ]
      }
    ],
    "xcharalloc": {
      "start_point": [
        214,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "XALLOC_INLINE char *\nxcharalloc (size_t n)\n{\n  return XNMALLOC (n, char);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "XALLOC_INLINE",
        "char",
        "char",
        "*\nxcharalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        227,
        29
      ],
      "end_point": [
        231,
        1
      ],
      "content": "T *\nxrealloc (T *p, size_t s)\n{\n  return (T *) xrealloc ((void *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxrealloc (T *p, size_t s)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        239,
        29
      ],
      "end_point": [
        243,
        1
      ],
      "content": "T *\nx2realloc (T *p, size_t *pn)\n{\n  return (T *) x2realloc ((void *) p, pn);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nx2realloc (T *p, size_t *pn)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        251,
        29
      ],
      "end_point": [
        255,
        1
      ],
      "content": "T *\nxmemdup (T const *p, size_t s)\n{\n  return (T *) xmemdup ((void const *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxmemdup (T const *p, size_t s)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/xmalloc.c": {
    "xmalloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void *\nxmalloc (size_t n)\n{\n  void *p = malloc (n);\n  if (!p && n != 0)\n    xalloc_die ();\n  return p;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void",
        "*\nxmalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void *\nxrealloc (void *p, size_t n)\n{\n  if (!n && p)\n    {\n      /* The GNU and C99 realloc behaviors disagree here.  Act like\n         GNU, even if the underlying realloc is C99.  */\n      free (p);\n      return NULL;\n    }\n\n  p = realloc (p, n);\n  if (!p && n)\n    xalloc_die ();\n  return p;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxrealloc (void *p, size_t n)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void *\nx2realloc (void *p, size_t *pn)\n{\n  return x2nrealloc (p, pn, 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void",
        "*\nx2realloc (void *p, size_t *pn)",
        "*"
      ]
    },
    "xzalloc": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "void *\nxzalloc (size_t s)\n{\n  return memset (xmalloc (s), 0, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxzalloc (size_t s)",
        "*"
      ]
    },
    "xcalloc": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "void *\nxcalloc (size_t n, size_t s)\n{\n  void *p;\n  /* Test for overflow, since objects with size greater than\n     PTRDIFF_MAX cause pointer subtraction to go awry.  Omit size-zero\n     tests if HAVE_GNU_CALLOC, since GNU calloc never returns NULL if\n     successful.  */\n  if (xalloc_oversized (n, s)\n      || (! (p = calloc (n, s)) && (HAVE_GNU_CALLOC || n != 0)))\n    xalloc_die ();\n  return p;\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "void",
        "*\nxcalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void *\nxmemdup (void const *p, size_t s)\n{\n  return memcpy (xmalloc (s), p, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxmemdup (void const *p, size_t s)",
        "*"
      ]
    },
    "xstrdup": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "char *\nxstrdup (char const *string)\n{\n  return xmemdup (string, strlen (string) + 1);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "char",
        "*\nxstrdup (char const *string)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/zerosize-ptr.h": {
    "zerosize_ptr": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static void *\nzerosize_ptr (void)\n{\n/* Use mmap and mprotect when they exist.  Don't test HAVE_MMAP, because it is\n   not defined on HP-UX 11 (since it does not support MAP_FIXED).  */\n#if HAVE_SYS_MMAN_H && HAVE_MPROTECT\n# if HAVE_MAP_ANONYMOUS\n  const int flags = MAP_ANONYMOUS | MAP_PRIVATE;\n  const int fd = -1;\n# else /* !HAVE_MAP_ANONYMOUS */\n  const int flags = MAP_FILE | MAP_PRIVATE;\n  int fd = open (\"/dev/zero\", O_RDONLY, 0666);\n  if (fd >= 0)\n# endif\n    {\n      int pagesize = getpagesize ();\n      char *two_pages =\n        (char *) mmap (NULL, 2 * pagesize, PROT_READ | PROT_WRITE,\n                       flags, fd, 0);\n      if (two_pages != (char *)(-1)\n          && mprotect (two_pages + pagesize, pagesize, PROT_NONE) == 0)\n        return two_pages + pagesize;\n    }\n#endif\n  return NULL;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nzerosize_ptr (void)",
        "*"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/_Noreturn.h": {},
  "libunistring/libunistring-0.9.10/tests/glthread/thread.c": {
    "do_init_self_key": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "static void\ndo_init_self_key (void)\n{\n  self_key = TlsAlloc ();\n  /* If this fails, we're hosed.  */\n  if (self_key == (DWORD)-1)\n    abort ();\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "init_self_key": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "static void\ninit_self_key (void)\n{\n  gl_once_define(static, once)\n  gl_once (once, do_init_self_key);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_current_thread_handle": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "static HANDLE\nget_current_thread_handle (void)\n{\n  HANDLE this_handle;\n\n  /* GetCurrentThread() returns a pseudo-handle, i.e. only a symbolic\n     identifier, not a real handle.  */\n  if (!DuplicateHandle (GetCurrentProcess (), GetCurrentThread (),\n                        GetCurrentProcess (), &this_handle,\n                        0, FALSE, DUPLICATE_SAME_ACCESS))\n    abort ();\n  return this_handle;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "HANDLE"
      ]
    },
    "gl_thread_self_func": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "gl_thread_t\ngl_thread_self_func (void)\n{\n  gl_thread_t thread;\n\n  if (self_key == (DWORD)-1)\n    init_self_key ();\n  thread = TlsGetValue (self_key);\n  if (thread == NULL)\n    {\n      /* This happens only in threads that have not been created through\n         glthread_create(), such as the main thread.  */\n      for (;;)\n        {\n          thread =\n            (struct gl_thread_struct *)\n            malloc (sizeof (struct gl_thread_struct));\n          if (thread != NULL)\n            break;\n          /* Memory allocation failed.  There is not much we can do.  Have to\n             busy-loop, waiting for the availability of memory.  */\n          Sleep (1);\n        }\n\n      thread->handle = get_current_thread_handle ();\n      InitializeCriticalSection (&thread->handle_lock);\n      thread->result = NULL; /* just to be deterministic */\n      TlsSetValue (self_key, thread);\n    }\n  return thread;\n}",
      "lines": 31,
      "depth": 15,
      "decorators": [
        "gl_thread_t"
      ]
    },
    "wrapper_func": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static unsigned int WINAPI\nwrapper_func (void *varg)\n{\n  struct gl_thread_struct *thread = (struct gl_thread_struct *)varg;\n\n  EnterCriticalSection (&thread->handle_lock);\n  /* Create a new handle for the thread only if the parent thread did not yet\n     fill in the handle.  */\n  if (thread->handle == NULL)\n    thread->handle = get_current_thread_handle ();\n  LeaveCriticalSection (&thread->handle_lock);\n\n  if (self_key == (DWORD)-1)\n    init_self_key ();\n  TlsSetValue (self_key, thread);\n\n  /* Run the thread.  Store the exit value if the thread was not terminated\n     otherwise.  */\n  thread->result = thread->func (thread->arg);\n  return 0;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int",
        "WINAPI",
        "WINAPI"
      ]
    },
    "glthread_create_func": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "int\nglthread_create_func (gl_thread_t *threadp, void * (*func) (void *), void *arg)\n{\n  struct gl_thread_struct *thread =\n    (struct gl_thread_struct *) malloc (sizeof (struct gl_thread_struct));\n  if (thread == NULL)\n    return ENOMEM;\n  thread->handle = NULL;\n  InitializeCriticalSection (&thread->handle_lock);\n  thread->result = NULL; /* just to be deterministic */\n  thread->func = func;\n  thread->arg = arg;\n\n  {\n    unsigned int thread_id;\n    HANDLE thread_handle;\n\n    thread_handle = (HANDLE)\n      _beginthreadex (NULL, 100000, wrapper_func, thread, 0, &thread_id);\n      /* calls CreateThread with the same arguments */\n    if (thread_handle == NULL)\n      {\n        DeleteCriticalSection (&thread->handle_lock);\n        free (thread);\n        return EAGAIN;\n      }\n\n    EnterCriticalSection (&thread->handle_lock);\n    if (thread->handle == NULL)\n      thread->handle = thread_handle;\n    else\n      /* thread->handle was already set by the thread itself.  */\n      CloseHandle (thread_handle);\n    LeaveCriticalSection (&thread->handle_lock);\n\n    *threadp = thread;\n    return 0;\n  }\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "glthread_join_func": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "int\nglthread_join_func (gl_thread_t thread, void **retvalp)\n{\n  if (thread == NULL)\n    return EINVAL;\n\n  if (thread == gl_thread_self ())\n    return EDEADLK;\n\n  if (WaitForSingleObject (thread->handle, INFINITE) == WAIT_FAILED)\n    return EINVAL;\n\n  if (retvalp != NULL)\n    *retvalp = thread->result;\n\n  DeleteCriticalSection (&thread->handle_lock);\n  CloseHandle (thread->handle);\n  free (thread);\n\n  return 0;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "gl_thread_exit_func": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        227,
        1
      ],
      "content": "int\ngl_thread_exit_func (void *retval)\n{\n  gl_thread_t thread = gl_thread_self ();\n  thread->result = retval;\n  _endthreadex (0); /* calls ExitThread (0) */\n  abort ();\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/glthread/thread.h": {
    "gl_thread_create": {
      "start_point": [
        395,
        0
      ],
      "end_point": [
        405,
        1
      ],
      "content": "_GLTHREAD_THREAD_INLINE gl_thread_t\ngl_thread_create (void *(*func) (void *arg), void *arg)\n{\n  gl_thread_t thread;\n  int ret;\n\n  ret = glthread_create (&thread, func, arg);\n  if (ret != 0)\n    abort ();\n  return thread;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "_GLTHREAD_THREAD_INLINE",
        "gl_thread_t",
        "gl_thread_t"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/glthread/yield.h": {},
  "libunistring/libunistring-0.9.10/tests/unicase/test-casecmp.h": {
    "test_ascii": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static void\ntest_ascii (int (*my_casecmp) (const UNIT *, size_t, const UNIT *, size_t, const char *, uninorm_t, int *),\n            uninorm_t nf)\n{\n  /* Empty string.  */\n  {\n    int cmp;\n\n    ASSERT (my_casecmp (NULL, 0, NULL, 0, NULL, nf, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  {\n    static const UNIT input[] = { 'x', 'y' };\n    int cmp;\n\n    ASSERT (my_casecmp (input, SIZEOF (input), NULL, 0, NULL, nf, &cmp) == 0);\n    ASSERT (cmp == 1);\n\n    ASSERT (my_casecmp (NULL, 0, input, SIZEOF (input), NULL, nf, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), input, SIZEOF (input), NULL, nf, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n\n  /* Normal lexicographic order.  */\n  {\n    static const UNIT input1[] = { 'A', 'm', 'e', 'r', 'i', 'c', 'a' };\n    static const UNIT input2[] = { 'A', 'm', 'i', 'g', 'o' };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, nf, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_casecmp (input2, SIZEOF (input2), input1, SIZEOF (input1), NULL, nf, &cmp) == 0);\n    ASSERT (cmp == 1);\n  }\n\n  /* Shorter and longer strings.  */\n  {\n    static const UNIT input1[] = { 'R', 'e', 'a', 'g', 'a', 'n' };\n    static const UNIT input2[] = { 'R', 'e', 'a', 'g', 'a', 'n', 'o', 'm', 'i', 'c', 's' };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, nf, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_casecmp (input2, SIZEOF (input2), input1, SIZEOF (input1), NULL, nf, &cmp) == 0);\n    ASSERT (cmp == 1);\n  }\n}",
      "lines": 51,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-cased.c": {},
  "libunistring/libunistring-0.9.10/tests/unicase/test-ignorable.c": {},
  "libunistring/libunistring-0.9.10/tests/unicase/test-is-cased.h": {
    "test_ascii": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static void\ntest_ascii (int (*my_is) (const UNIT *, size_t, const char *, bool *))\n{\n  /* Test cases from Unicode 5.0, chapter 3.  */\n  {\n    static const UNIT input[] = { 'A', 'B', 'C' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const UNIT input[] = { 'a', 'b', 'c' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const UNIT input[] = { 'a', 'B', 'c' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const UNIT input[] = { 'a', 'B', 'c', '1', '2', '3' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const UNIT input[] = { '1', '2', '3' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == false);\n  }\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-is-casefolded.h": {
    "test_ascii": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "static void\ntest_ascii (int (*my_is) (const UNIT *, size_t, const char *, bool *))\n{\n  {\n    static const UNIT input[] = { 'J', 'O', 'H', 'N', ' ', 'S', 'M', 'I', 'T', 'H' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == false);\n  }\n  {\n    static const UNIT input[] = { 'J', 'o', 'h', 'n', ' ', 'S', 'm', 'i', 't', 'h' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == false);\n  }\n  {\n    static const UNIT input[] = { 'j', 'o', 'h', 'n', ' ', 's', 'm', 'i', 't', 'h' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-is-lowercase.h": {
    "test_ascii": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "static void\ntest_ascii (int (*my_is) (const UNIT *, size_t, const char *, bool *))\n{\n  /* Test cases from Unicode 5.0, chapter 3.  */\n  {\n    static const UNIT input[] = { 'a' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const UNIT input[] = { 'J', 'O', 'H', 'N', ' ', 'S', 'M', 'I', 'T', 'H' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == false);\n  }\n  {\n    static const UNIT input[] = { 'J', 'o', 'h', 'n', ' ', 'S', 'm', 'i', 't', 'h' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == false);\n  }\n  {\n    static const UNIT input[] = { 'j', 'o', 'h', 'n', ' ', 's', 'm', 'i', 't', 'h' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const UNIT input[] = { 'a', '2' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const UNIT input[] = { '3' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n\n  /* Test cases from Unicode 5.1.0.  */\n  {\n    static const UNIT input[] = { 'H', 'H' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == false);\n  }\n  {\n    static const UNIT input[] = { 'h', 'h' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const UNIT input[] = { 'H', 'h' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == false);\n  }\n  {\n    static const UNIT input[] = { 'h', 'H' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == false);\n  }\n}",
      "lines": 77,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-is-titlecase.h": {
    "test_ascii": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "static void\ntest_ascii (int (*my_is) (const UNIT *, size_t, const char *, bool *))\n{\n  /* Test cases from Unicode 5.0, chapter 3.  */\n  {\n    static const UNIT input[] = { 'A' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const UNIT input[] = { 'J', 'O', 'H', 'N', ' ', 'S', 'M', 'I', 'T', 'H' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == false);\n  }\n  {\n    static const UNIT input[] = { 'J', 'o', 'h', 'n', ' ', 'S', 'm', 'i', 't', 'h' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const UNIT input[] = { 'j', 'o', 'h', 'n', ' ', 's', 'm', 'i', 't', 'h' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == false);\n  }\n  {\n    static const UNIT input[] = { 'A', '2' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const UNIT input[] = { '3' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n\n  /* Test cases from Unicode 5.1.0.  */\n  {\n    static const UNIT input[] = { 'H', 'H' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == false);\n  }\n  {\n    static const UNIT input[] = { 'h', 'h' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == false);\n  }\n  {\n    static const UNIT input[] = { 'H', 'h' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const UNIT input[] = { 'h', 'H' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == false);\n  }\n}",
      "lines": 77,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-is-uppercase.h": {
    "test_ascii": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "static void\ntest_ascii (int (*my_is) (const UNIT *, size_t, const char *, bool *))\n{\n  /* Test cases from Unicode 5.0, chapter 3.  */\n  {\n    static const UNIT input[] = { 'A' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const UNIT input[] = { 'J', 'O', 'H', 'N', ' ', 'S', 'M', 'I', 'T', 'H' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const UNIT input[] = { 'J', 'o', 'h', 'n', ' ', 'S', 'm', 'i', 't', 'h' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == false);\n  }\n  {\n    static const UNIT input[] = { 'j', 'o', 'h', 'n', ' ', 's', 'm', 'i', 't', 'h' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == false);\n  }\n  {\n    static const UNIT input[] = { 'A', '2' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const UNIT input[] = { '3' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n\n  /* Test cases from Unicode 5.1.0.  */\n  {\n    static const UNIT input[] = { 'H', 'H' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const UNIT input[] = { 'h', 'h' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == false);\n  }\n  {\n    static const UNIT input[] = { 'H', 'h' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == false);\n  }\n  {\n    static const UNIT input[] = { 'h', 'H' };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == false);\n  }\n}",
      "lines": 77,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-locale-language.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  const char *expected;\n  const char *language;\n\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  expected = argv[1];\n\n  language = uc_locale_language ();\n  ASSERT (strcmp (language, expected) == 0);\n\n  return 0;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-mapping-part1.h": {},
  "libunistring/libunistring-0.9.10/tests/unicase/test-mapping-part2.h": {
    "main": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int\nmain ()\n{\n  unsigned int c;\n  size_t i;\n\n  c = 0;\n  for (i = 0; i < SIZEOF (mapping); i++)\n    {\n      for (; c < mapping[i].ch; c++)\n        ASSERT (MAP (c) == c);\n      ASSERT (MAP (c) == mapping[i].value);\n      c++;\n    }\n  for (; c < 0x110000; c++)\n    ASSERT (MAP (c) == c);\n\n  return 0;\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-predicate-part1.h": {},
  "libunistring/libunistring-0.9.10/tests/unicase/test-predicate-part2.h": {
    "main": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int\nmain ()\n{\n  unsigned int c;\n  size_t i;\n\n  c = 0;\n  for (i = 0; i < SIZEOF (set); i++)\n    {\n      for (; c < set[i].start; c++)\n        ASSERT (!PREDICATE (c));\n      for (; c <= set[i].end; c++)\n        ASSERT (PREDICATE (c));\n    }\n  for (; c < 0x110000; c++)\n    ASSERT (!PREDICATE (c));\n\n  return 0;\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u16-casecmp.c": {
    "test_nonascii": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        311,
        1
      ],
      "content": "static void\ntest_nonascii (int (*my_casecmp) (const uint16_t *, size_t, const uint16_t *, size_t, const char *, uninorm_t, int *))\n{\n  /* Normalization effects.  */\n  {\n    static const uint16_t input1[] = { 'H', 0x00F6, 'h', 'l', 'e' };\n    static const uint16_t input2[] = { 'H', 'O', 0x0308, 'h', 'L', 'e' };\n    static const uint16_t input3[] = { 'H', 0x00F6, 'h', 'l', 'e', 'n' };\n    static const uint16_t input4[] = { 'H', 'O', 0x0308, 'h', 'L', 'e', 'n' };\n    static const uint16_t input5[] = { 'H', 'u', 'r', 'z' };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input2, SIZEOF (input2), input1, SIZEOF (input1), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input3, SIZEOF (input3), input4, SIZEOF (input4), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input4, SIZEOF (input4), input3, SIZEOF (input3), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input2, SIZEOF (input2), input3, SIZEOF (input3), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input4, SIZEOF (input4), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input5, SIZEOF (input5), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_casecmp (input2, SIZEOF (input2), input5, SIZEOF (input5), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n  }\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS */\n    static const uint16_t input1[] = { 0x00C4 };\n    static const uint16_t input2[] = { 0x0041, 0x0308 };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON */\n    static const uint16_t input1[] = { 0x01DE };\n    static const uint16_t input2[] = { 0x0041, 0x0308, 0x0304 };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* GREEK DIALYTIKA AND PERISPOMENI */\n    static const uint16_t input1[] = { 0x1FC1 };\n    static const uint16_t input2[] = { 0x00A8, 0x0342 };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* HANGUL SYLLABLE GEUL */\n    static const uint16_t input1[] = { 0xAE00 };\n    static const uint16_t input2[] = { 0xADF8, 0x11AF };\n    static const uint16_t input3[] = { 0x1100, 0x1173, 0x11AF };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input3, SIZEOF (input3), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* HANGUL SYLLABLE GEU */\n    static const uint16_t input1[] = { 0xADF8 };\n    static const uint16_t input2[] = { 0x1100, 0x1173 };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint16_t input1[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    static const uint16_t input2[] =\n      { 'g', 'r', 0x00FC, 0x0073, 0x0073, ' ', 'g', 'o', 't', 't', '.', ' ',\n        0x0437, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    static const uint16_t input3[] =\n      { 'G', 'R', 0x00DC, 0x0053, 0x0053, ' ', 'G', 'O', 'T', 'T', '.', ' ',\n        0x0417, 0x0414, 0x0420, 0x0410, 0x0412, 0x0421, 0x0422, 0x0412, 0x0423,\n        0x0419, 0x0422, 0x0415, '!', ' ',\n        'X', '=', '(', '-', 'B', 0x00B1, 'S', 'Q', 'R', 'T', '(', 'B', 0x00B2,\n        '-', '4', 'A', 'C', ')', ')', '/', '(', '2', 'A', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input3, SIZEOF (input3), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input3, SIZEOF (input3), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input2, SIZEOF (input2), input3, SIZEOF (input3), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input2, SIZEOF (input2), input3, SIZEOF (input3), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n\n  /* Case mapping can increase the number of Unicode characters.  */\n  { /* LATIN SMALL LETTER N PRECEDED BY APOSTROPHE */\n    static const uint16_t input1[] = { 0x0149 };\n    static const uint16_t input2[] = { 0x02BC, 0x006E };\n    static const uint16_t input3[] = { 0x02BC, 0x004E };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input3, SIZEOF (input3), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input3, SIZEOF (input3), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS */\n    static const uint16_t input1[] = { 0x0390 };\n    static const uint16_t input2[] = { 0x03B9, 0x0308, 0x0301 };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n\n  /* Turkish letters i \u00c4\u00b0 \u00c4\u00b1 I */\n  { /* LATIN CAPITAL LETTER I */\n    static const uint16_t input[]         = { 0x0049 };\n    static const uint16_t casefolded[]    = { 0x0069 };\n    static const uint16_t casefolded_tr[] = { 0x0131 };\n    int cmp;\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded_tr, SIZEOF (casefolded_tr), \"tr\", NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* LATIN SMALL LETTER I */\n    static const uint16_t input[]         = { 0x0069 };\n    static const uint16_t casefolded[]    = { 0x0049 };\n    static const uint16_t casefolded_tr[] = { 0x0130 };\n    int cmp;\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded_tr, SIZEOF (casefolded_tr), \"tr\", NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* LATIN CAPITAL LETTER I WITH DOT ABOVE */\n    static const uint16_t input[]         = { 0x0130 };\n    static const uint16_t casefolded[]    = { 0x0069, 0x0307 };\n    static const uint16_t casefolded_tr[] = { 0x0069 };\n    int cmp;\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded_tr, SIZEOF (casefolded_tr), \"tr\", NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* LATIN SMALL LETTER DOTLESS I */\n    static const uint16_t input[]      = { 0x0131 };\n    static const uint16_t casefolded[] = { 0x0049 };\n    int cmp;\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 1);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), \"tr\", NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* \"topkap\u00c4\u00b1\" */\n    static const uint16_t input[] =\n      { 0x0054, 0x004F, 0x0050, 0x004B, 0x0041, 0x0050, 0x0049 };\n    static const uint16_t casefolded[] =\n      { 0x0074, 0x006F, 0x0070, 0x006B, 0x0061, 0x0070, 0x0131 };\n    int cmp;\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), \"tr\", NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n\n  /* Uppercasing can increase the number of Unicode characters.  */\n  { /* \"hei\u00c3\u009f\" */\n    static const uint16_t input1[] = { 0x0068, 0x0065, 0x0069, 0x00DF };\n    static const uint16_t input2[] = { 0x0068, 0x0065, 0x0069, 0x0073, 0x0073 };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n\n  /* Case mappings for some characters can depend on the surrounding characters.  */\n  { /* \"\u00cf\u0080\u00ce\u00b5\u00cf\u0081\u00ce\u00b9\u00cf\u0083\u00cf\u0083\u00cf\u008c\u00cf\u0084\u00ce\u00b5\u00cf\u0081\u00ce\u00b5\u00cf\u0082 \u00cf\u0080\u00ce\u00bb\u00ce\u00b7\u00cf\u0081\u00ce\u00bf\u00cf\u0086\u00ce\u00bf\u00cf\u0081\u00ce\u00af\u00ce\u00b5\u00cf\u0082\" */\n    static const uint16_t input1[] =\n      {\n        0x03C0, 0x03B5, 0x03C1, 0x03B9, 0x03C3, 0x03C3, 0x03CC, 0x03C4,\n        0x03B5, 0x03C1, 0x03B5, 0x03C2, 0x0020, 0x03C0, 0x03BB, 0x03B7,\n        0x03C1, 0x03BF, 0x03C6, 0x03BF, 0x03C1, 0x03AF, 0x03B5, 0x03C2\n      };\n    static const uint16_t input2[] =\n      {\n        0x03C0, 0x03B5, 0x03C1, 0x03B9, 0x03C3, 0x03C3, 0x03CC, 0x03C4,\n        0x03B5, 0x03C1, 0x03B5, 0x03C3, 0x0020, 0x03C0, 0x03BB, 0x03B7,\n        0x03C1, 0x03BF, 0x03C6, 0x03BF, 0x03C1, 0x03AF, 0x03B5, 0x03C3\n      };\n    static const uint16_t input3[] =\n      {\n        0x03A0, 0x0395, 0x03A1, 0x0399, 0x03A3, 0x03A3, 0x038C, 0x03A4,\n        0x0395, 0x03A1, 0x0395, 0x03A3, 0x0020, 0x03A0, 0x039B, 0x0397,\n        0x03A1, 0x039F, 0x03A6, 0x039F, 0x03A1, 0x038A, 0x0395, 0x03A3\n      };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input3, SIZEOF (input3), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input2, SIZEOF (input2), input3, SIZEOF (input3), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n\n  /* Case mapping can require subsequent normalization.  */\n  { /* LATIN SMALL LETTER J WITH CARON, COMBINING DOT BELOW */\n    static const uint16_t input[]                 = { 0x01F0, 0x0323 };\n    static const uint16_t casefolded[]            = { 0x006A, 0x030C, 0x0323 };\n    static const uint16_t casefolded_decomposed[] = { 0x006A, 0x0323, 0x030C };\n    int cmp;\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded_decomposed, SIZEOF (casefolded_decomposed), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp != 0);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded_decomposed, SIZEOF (casefolded_decomposed), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n}",
      "lines": 283,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        313,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "int\nmain ()\n{\n  test_ascii (u16_casecmp, UNINORM_NFD);\n  test_nonascii (u16_casecmp);\n\n  return 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u16-casecoll.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nmain ()\n{\n  /* In the \"C\" locale, strcoll is equivalent to strcmp, therefore u8_casecoll\n     on ASCII strings should behave like strcasecmp.  */\n  test_ascii (u16_casecoll, UNINORM_NFC);\n\n  return 0;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u16-casefold.c": {
    "check": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static int\ncheck (const uint16_t *input, size_t input_length,\n       const char *iso639_language, uninorm_t nf,\n       const uint16_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint16_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u16_casefold (input, input_length, iso639_language, nf, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u16_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint16_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint16_t *) malloc (length * sizeof (uint16_t));\n      result = u16_casefold (input, input_length, iso639_language, nf, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u16_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint16_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint16_t *) malloc (length * sizeof (uint16_t));\n    result = u16_casefold (input, input_length, iso639_language, nf, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u16_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        200,
        1
      ],
      "content": "int\nmain ()\n{\n  { /* Empty string.  */\n    ASSERT (check (NULL, 0, NULL, NULL, NULL, 0) == 0);\n    ASSERT (check (NULL, 0, NULL, UNINORM_NFC, NULL, 0) == 0);\n  }\n\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint16_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    static const uint16_t casefolded[] =\n      { 'g', 'r', 0x00FC, 0x0073, 0x0073, ' ', 'g', 'o', 't', 't', '.', ' ',\n        0x0437, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n  }\n\n  /* Case mapping can increase the number of Unicode characters.  */\n  { /* LATIN SMALL LETTER N PRECEDED BY APOSTROPHE */\n    static const uint16_t input[]      = { 0x0149 };\n    static const uint16_t casefolded[] = { 0x02BC, 0x006E };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n  }\n  { /* GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS */\n    static const uint16_t input[]      = { 0x0390 };\n    static const uint16_t casefolded[] = { 0x03B9, 0x0308, 0x0301 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n  }\n\n  /* Turkish letters i \u00c4\u00b0 \u00c4\u00b1 I */\n  { /* LATIN CAPITAL LETTER I */\n    static const uint16_t input[]         = { 0x0049 };\n    static const uint16_t casefolded[]    = { 0x0069 };\n    static const uint16_t casefolded_tr[] = { 0x0131 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casefolded_tr, SIZEOF (casefolded_tr)) == 0);\n  }\n  { /* LATIN SMALL LETTER I */\n    static const uint16_t input[]      = { 0x0069 };\n    static const uint16_t casefolded[] = { 0x0069 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casefolded, SIZEOF (casefolded)) == 0);\n  }\n  { /* LATIN CAPITAL LETTER I WITH DOT ABOVE */\n    static const uint16_t input[]         = { 0x0130 };\n    static const uint16_t casefolded[]    = { 0x0069, 0x0307 };\n    static const uint16_t casefolded_tr[] = { 0x0069 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casefolded_tr, SIZEOF (casefolded_tr)) == 0);\n  }\n  { /* LATIN SMALL LETTER DOTLESS I */\n    static const uint16_t input[]      = { 0x0131 };\n    static const uint16_t casefolded[] = { 0x0131 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casefolded, SIZEOF (casefolded)) == 0);\n  }\n  { /* \"topkap\u00c4\u00b1\" */\n    static const uint16_t input[] =\n      { 0x0074, 0x006F, 0x0070, 0x006B, 0x0061, 0x0070, 0x0131 };\n    static const uint16_t casefolded[] =\n      { 0x0074, 0x006F, 0x0070, 0x006B, 0x0061, 0x0070, 0x0131 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casefolded, SIZEOF (casefolded)) == 0);\n  }\n\n  /* Uppercasing can increase the number of Unicode characters.  */\n  { /* \"hei\u00c3\u009f\" */\n    static const uint16_t input[]      = { 0x0068, 0x0065, 0x0069, 0x00DF };\n    static const uint16_t casefolded[] = { 0x0068, 0x0065, 0x0069, 0x0073, 0x0073 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n  }\n\n  /* Case mappings for some characters can depend on the surrounding characters.  */\n  { /* \"\u00cf\u0080\u00ce\u00b5\u00cf\u0081\u00ce\u00b9\u00cf\u0083\u00cf\u0083\u00cf\u008c\u00cf\u0084\u00ce\u00b5\u00cf\u0081\u00ce\u00b5\u00cf\u0082 \u00cf\u0080\u00ce\u00bb\u00ce\u00b7\u00cf\u0081\u00ce\u00bf\u00cf\u0086\u00ce\u00bf\u00cf\u0081\u00ce\u00af\u00ce\u00b5\u00cf\u0082\" */\n    static const uint16_t input[] =\n      {\n        0x03C0, 0x03B5, 0x03C1, 0x03B9, 0x03C3, 0x03C3, 0x03CC, 0x03C4,\n        0x03B5, 0x03C1, 0x03B5, 0x03C2, 0x0020, 0x03C0, 0x03BB, 0x03B7,\n        0x03C1, 0x03BF, 0x03C6, 0x03BF, 0x03C1, 0x03AF, 0x03B5, 0x03C2\n      };\n    static const uint16_t casefolded[] =\n      {\n        0x03C0, 0x03B5, 0x03C1, 0x03B9, 0x03C3, 0x03C3, 0x03CC, 0x03C4,\n        0x03B5, 0x03C1, 0x03B5, 0x03C3, 0x0020, 0x03C0, 0x03BB, 0x03B7,\n        0x03C1, 0x03BF, 0x03C6, 0x03BF, 0x03C1, 0x03AF, 0x03B5, 0x03C3\n      };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n  }\n\n  /* Case mapping can require subsequent normalization.  */\n  { /* LATIN SMALL LETTER J WITH CARON, COMBINING DOT BELOW */\n    static const uint16_t input[]                 = { 0x01F0, 0x0323 };\n    static const uint16_t casefolded[]            = { 0x006A, 0x030C, 0x0323 };\n    static const uint16_t casefolded_decomposed[] = { 0x006A, 0x0323, 0x030C };\n    static const uint16_t casefolded_normalized[] = { 0x01F0, 0x0323 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL,        casefolded, SIZEOF (casefolded)) == 0);\n    ASSERT (check (input, SIZEOF (input), NULL, UNINORM_NFD, casefolded_decomposed, SIZEOF (casefolded_decomposed)) == 0);\n    ASSERT (check (input, SIZEOF (input), NULL, UNINORM_NFC, casefolded_normalized, SIZEOF (casefolded_normalized)) == 0);\n  }\n\n  return 0;\n}",
      "lines": 114,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u16-is-cased.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "int\nmain ()\n{\n  test_ascii (u16_is_cased);\n\n  return 0;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u16-is-casefolded.c": {
    "test_nonascii": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "static void\ntest_nonascii (int (*my_is) (const uint16_t *, size_t, const char *, bool *))\n{\n  /* Test cases from Unicode 5.1.0.  */\n  {\n    static const uint16_t input[] = { 0x00DF };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == false);\n  }\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nmain ()\n{\n  test_ascii (u16_is_casefolded);\n  test_nonascii (u16_is_casefolded);\n\n  return 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u16-is-lowercase.c": {
    "test_nonascii": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static void\ntest_nonascii (int (*my_is) (const uint16_t *, size_t, const char *, bool *))\n{\n  /* Test cases from Unicode 5.1.0.  */\n  {\n    static const uint16_t input[] = { 0x24D7 };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const uint16_t input[] = { 0x24BD };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == false);\n  }\n  {\n    static const uint16_t input[] = { 0x02B0 };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const uint16_t input[] = { 0x1D34 };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const uint16_t input[] = { 0x02BD };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nmain ()\n{\n  test_ascii (u16_is_lowercase);\n  test_nonascii (u16_is_lowercase);\n\n  return 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u16-is-titlecase.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "int\nmain ()\n{\n  test_ascii (u16_is_titlecase);\n\n  return 0;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u16-is-uppercase.c": {
    "test_nonascii": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static void\ntest_nonascii (int (*my_is) (const uint16_t *, size_t, const char *, bool *))\n{\n  /* Test cases from Unicode 5.1.0.  */\n  {\n    static const uint16_t input[] = { 0x24D7 };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == false);\n  }\n  {\n    static const uint16_t input[] = { 0x24BD };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const uint16_t input[] = { 0x02B0 };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const uint16_t input[] = { 0x1D34 };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const uint16_t input[] = { 0x02BD };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nmain ()\n{\n  test_ascii (u16_is_uppercase);\n  test_nonascii (u16_is_uppercase);\n\n  return 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u16-tolower.c": {
    "check": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static int\ncheck (const uint16_t *input, size_t input_length,\n       const char *iso639_language, uninorm_t nf,\n       const uint16_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint16_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u16_tolower (input, input_length, iso639_language, nf, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u16_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint16_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint16_t *) malloc (length * sizeof (uint16_t));\n      result = u16_tolower (input, input_length, iso639_language, nf, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u16_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint16_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint16_t *) malloc (length * sizeof (uint16_t));\n    result = u16_tolower (input, input_length, iso639_language, nf, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u16_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "int\nmain ()\n{\n  { /* Empty string.  */\n    ASSERT (check (NULL, 0, NULL, NULL, NULL, 0) == 0);\n    ASSERT (check (NULL, 0, NULL, UNINORM_NFC, NULL, 0) == 0);\n  }\n\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint16_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    static const uint16_t casemapped[] =\n      { 'g', 'r', 0x00FC, 0x00DF, ' ', 'g', 'o', 't', 't', '.', ' ',\n        0x0437, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Turkish letters i \u00c4\u00b0 \u00c4\u00b1 I */\n  { /* LATIN CAPITAL LETTER I */\n    static const uint16_t input[]         = { 0x0049 };\n    static const uint16_t casemapped[]    = { 0x0069 };\n    static const uint16_t casemapped_tr[] = { 0x0131 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped_tr, SIZEOF (casemapped_tr)) == 0);\n  }\n  { /* LATIN SMALL LETTER I */\n    static const uint16_t input[]      = { 0x0069 };\n    static const uint16_t casemapped[] = { 0x0069 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* LATIN CAPITAL LETTER I WITH DOT ABOVE */\n    static const uint16_t input[]         = { 0x0130 };\n    static const uint16_t casemapped[]    = { 0x0069, 0x0307 };\n    static const uint16_t casemapped_tr[] = { 0x0069 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped_tr, SIZEOF (casemapped_tr)) == 0);\n  }\n  { /* LATIN SMALL LETTER DOTLESS I */\n    static const uint16_t input[]      = { 0x0131 };\n    static const uint16_t casemapped[] = { 0x0131 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"TOPKAPI\" */\n    static const uint16_t input[] =\n      { 0x0054, 0x004F, 0x0050, 0x004B, 0x0041, 0x0050, 0x0049 };\n    static const uint16_t casemapped[] =\n      { 0x0074, 0x006F, 0x0070, 0x006B, 0x0061, 0x0070, 0x0131 };\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Uppercasing can increase the number of Unicode characters.  */\n  { /* \"HEI\u00c3\u009f\" */\n    static const uint16_t input[]      = { 0x0048, 0x0045, 0x0049, 0x00DF };\n    static const uint16_t casemapped[] = { 0x0068, 0x0065, 0x0069, 0x00DF };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Case mappings for some characters can depend on the surrounding characters.  */\n  { /* \"\u00ce\u00a0\u00ce\u0095\u00ce\u00a1\u00ce\u0099\u00ce\u00a3\u00ce\u00a3\u00ce\u008c\u00ce\u00a4\u00ce\u0095\u00ce\u00a1\u00ce\u0095\u00ce\u00a3 \u00ce\u00a0\u00ce\u009b\u00ce\u0097\u00ce\u00a1\u00ce\u009f\u00ce\u00a6\u00ce\u009f\u00ce\u00a1\u00ce\u008a\u00ce\u0095\u00ce\u00a3\" */\n    static const uint16_t input[] =\n      {\n        0x03A0, 0x0395, 0x03A1, 0x0399, 0x03A3, 0x03A3, 0x038C, 0x03A4,\n        0x0395, 0x03A1, 0x0395, 0x03A3, 0x0020, 0x03A0, 0x039B, 0x0397,\n        0x03A1, 0x039F, 0x03A6, 0x039F, 0x03A1, 0x038A, 0x0395, 0x03A3\n      };\n    static const uint16_t casemapped[] =\n      {\n        0x03C0, 0x03B5, 0x03C1, 0x03B9, 0x03C3, 0x03C3, 0x03CC, 0x03C4,\n        0x03B5, 0x03C1, 0x03B5, 0x03C2, 0x0020, 0x03C0, 0x03BB, 0x03B7,\n        0x03C1, 0x03BF, 0x03C6, 0x03BF, 0x03C1, 0x03AF, 0x03B5, 0x03C2\n      };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"\u00ce\u00a3\" -> \"\u00cf\u0083\" */\n    static const uint16_t input[] =      { 0x03A3 };\n    static const uint16_t casemapped[] = { 0x03C3 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"\u00ce\u0091\u00ce\u00a3\" -> \"\u00ce\u00b1\u00cf\u0082\" */\n    static const uint16_t input[] =      { 0x0391, 0x03A3 };\n    static const uint16_t casemapped[] = { 0x03B1, 0x03C2 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  /* It's a final sigma only if not followed by a case-ignorable sequence and\n     then a cased letter.  Note that U+0345 and U+037A are simultaneously\n     case-ignorable and cased (which is a bit paradoxical).  */\n  { /* \"\u00ce\u0091\u00ce\u00a3\u00ce\u0091\" -> \"\u00ce\u00b1\u00cf\u0083\u00ce\u00b1\" */\n    static const uint16_t input[] =      { 0x0391, 0x03A3, 0x0391 };\n    static const uint16_t casemapped[] = { 0x03B1, 0x03C3, 0x03B1 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"\u00ce\u0091\u00ce\u00a3:\" -> \"\u00ce\u00b1\u00cf\u0082:\" */\n    static const uint16_t input[] =      { 0x0391, 0x03A3, 0x003A };\n    static const uint16_t casemapped[] = { 0x03B1, 0x03C2, 0x003A };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"\u00ce\u0091\u00ce\u00a3:\u00ce\u0091\" -> \"\u00ce\u00b1\u00cf\u0083:\u00ce\u00b1\" */\n    static const uint16_t input[] =      { 0x0391, 0x03A3, 0x003A, 0x0391 };\n    static const uint16_t casemapped[] = { 0x03B1, 0x03C3, 0x003A, 0x03B1 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"\u00ce\u0091\u00ce\u00a3:\u00cd\u00ba\" -> \"\u00ce\u00b1\u00cf\u0083:\u00cd\u00ba\" */\n    static const uint16_t input[] =      { 0x0391, 0x03A3, 0x003A, 0x037A };\n    static const uint16_t casemapped[] = { 0x03B1, 0x03C3, 0x003A, 0x037A };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"\u00ce\u0091\u00ce\u00a3:\u00cd\u00ba \" -> \"\u00ce\u00b1\u00cf\u0083:\u00cd\u00ba \" */\n    static const uint16_t input[] =      { 0x0391, 0x03A3, 0x003A, 0x037A, 0x0020 };\n    static const uint16_t casemapped[] = { 0x03B1, 0x03C3, 0x003A, 0x037A, 0x0020 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  /* It's a final sigma only if preceded by a case-ignorable sequence and\n     a cased letter before it.  Note that U+0345 and U+037A are simultaneously\n     case-ignorable and cased (which is a bit paradoxical).  */\n  { /* \":\u00ce\u00a3\" -> \":\u00cf\u0083\" */\n    static const uint16_t input[] =      { 0x003A, 0x03A3 };\n    static const uint16_t casemapped[] = { 0x003A, 0x03C3 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"\u00ce\u0091:\u00ce\u00a3\" -> \"\u00ce\u00b1:\u00cf\u0082\" */\n    static const uint16_t input[] =      { 0x0391, 0x003A, 0x03A3 };\n    static const uint16_t casemapped[] = { 0x03B1, 0x003A, 0x03C2 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"\u00cd\u00ba:\u00ce\u00a3\" -> \"\u00cd\u00ba:\u00cf\u0082\" */\n    static const uint16_t input[] =      { 0x037A, 0x003A, 0x03A3 };\n    static const uint16_t casemapped[] = { 0x037A, 0x003A, 0x03C2 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \" \u00cd\u00ba:\u00ce\u00a3\" -> \" \u00cd\u00ba:\u00cf\u0082\" */\n    static const uint16_t input[] =      { 0x0020, 0x037A, 0x003A, 0x03A3 };\n    static const uint16_t casemapped[] = { 0x0020, 0x037A, 0x003A, 0x03C2 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  return 0;\n}",
      "lines": 151,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u16-totitle.c": {
    "check": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static int\ncheck (const uint16_t *input, size_t input_length,\n       const char *iso639_language, uninorm_t nf,\n       const uint16_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint16_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u16_totitle (input, input_length, iso639_language, nf, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u16_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint16_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint16_t *) malloc (length * sizeof (uint16_t));\n      result = u16_totitle (input, input_length, iso639_language, nf, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u16_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint16_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint16_t *) malloc (length * sizeof (uint16_t));\n    result = u16_totitle (input, input_length, iso639_language, nf, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u16_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "int\nmain ()\n{\n  { /* Empty string.  */\n    ASSERT (check (NULL, 0, NULL, NULL, NULL, 0) == 0);\n    ASSERT (check (NULL, 0, NULL, UNINORM_NFC, NULL, 0) == 0);\n  }\n\n  /* Simple string.  */\n  { /* \"GR\u00c3\u009c\u00c3\u009f GOTT. \u00d0\u0097\u00d0\u0094\u00d0\u00a0\u00d0\u0090\u00d0\u0092\u00d0\u00a1\u00d0\u00a2\u00d0\u0092\u00d0\u00a3\u00d0\u0099\u00d0\u00a2\u00d0\u0095! X=(-B\u00c2\u00b1SQRT(B\u00c2\u00b2-4AC))/(2A)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint16_t input[] =\n      { 'G', 'R', 0x00DC, 0x00DF, ' ', 'G', 'O', 'T', 'T', '.', ' ',\n        0x0417, 0x0414, 0x0420, 0x0410, 0x0412, 0x0421, 0x0422, 0x0412, 0x0423,\n        0x0419, 0x0422, 0x0415, '!', ' ',\n        'X', '=', '(', '-', 'B', 0x00B1, 'S', 'Q', 'R', 'T', '(', 'B', 0x00B2,\n        '-', '4', 'A', 'C', ')', ')', '/', '(', '2', 'A', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    static const uint16_t casemapped[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'X', '=', '(', '-', 'B', 0x00B1, 'S', 'q', 'r', 't', '(', 'B', 0x00B2,\n        '-', '4', 'A', 'c', ')', ')', '/', '(', '2', 'A', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Case mapping can increase the number of Unicode characters.  */\n  { /* LATIN SMALL LETTER N PRECEDED BY APOSTROPHE */\n    static const uint16_t input[]      = { 0x0149 };\n    static const uint16_t casemapped[] = { 0x02BC, 0x004E };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS */\n    static const uint16_t input[]      = { 0x0390 };\n    static const uint16_t casemapped[] = { 0x0399, 0x0308, 0x0301 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Turkish letters i \u00c4\u00b0 \u00c4\u00b1 I */\n  { /* LATIN CAPITAL LETTER I */\n    static const uint16_t input[]      = { 0x0049 };\n    static const uint16_t casemapped[] = { 0x0049 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* LATIN SMALL LETTER I */\n    static const uint16_t input[]         = { 0x0069 };\n    static const uint16_t casemapped[]    = { 0x0049 };\n    static const uint16_t casemapped_tr[] = { 0x0130 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped_tr, SIZEOF (casemapped_tr)) == 0);\n  }\n  { /* LATIN CAPITAL LETTER I WITH DOT ABOVE */\n    static const uint16_t input[]      = { 0x0130 };\n    static const uint16_t casemapped[] = { 0x0130 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* LATIN SMALL LETTER DOTLESS I */\n    static const uint16_t input[]      = { 0x0131 };\n    static const uint16_t casemapped[] = { 0x0049 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"topkap\u00c4\u00b1\" */\n    static const uint16_t input[] =\n      { 0x0074, 0x006F, 0x0070, 0x006B, 0x0061, 0x0070, 0x0131 };\n    static const uint16_t casemapped[] =\n      { 0x0054, 0x006F, 0x0070, 0x006B, 0x0061, 0x0070, 0x0131 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Uppercasing can increase the number of Unicode characters.  */\n  { /* \"hei\u00c3\u009f\" */\n    static const uint16_t input[]      = { 0x0068, 0x0065, 0x0069, 0x00DF };\n    static const uint16_t casemapped[] = { 0x0048, 0x0065, 0x0069, 0x00DF };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Case mappings for some characters can depend on the surrounding characters.  */\n  { /* \"\u00cf\u0080\u00ce\u00b5\u00cf\u0081\u00ce\u00b9\u00cf\u0083\u00cf\u0083\u00cf\u008c\u00cf\u0084\u00ce\u00b5\u00cf\u0081\u00ce\u00b5\u00cf\u0082 \u00cf\u0080\u00ce\u00bb\u00ce\u00b7\u00cf\u0081\u00ce\u00bf\u00cf\u0086\u00ce\u00bf\u00cf\u0081\u00ce\u00af\u00ce\u00b5\u00cf\u0082\" */\n    static const uint16_t input[] =\n      {\n        0x03C0, 0x03B5, 0x03C1, 0x03B9, 0x03C3, 0x03C3, 0x03CC, 0x03C4,\n        0x03B5, 0x03C1, 0x03B5, 0x03C2, 0x0020, 0x03C0, 0x03BB, 0x03B7,\n        0x03C1, 0x03BF, 0x03C6, 0x03BF, 0x03C1, 0x03AF, 0x03B5, 0x03C2\n      };\n    static const uint16_t casemapped[] =\n      {\n        0x03A0, 0x03B5, 0x03C1, 0x03B9, 0x03C3, 0x03C3, 0x03CC, 0x03C4,\n        0x03B5, 0x03C1, 0x03B5, 0x03C2, 0x0020, 0x03A0, 0x03BB, 0x03B7,\n        0x03C1, 0x03BF, 0x03C6, 0x03BF, 0x03C1, 0x03AF, 0x03B5, 0x03C2\n      };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Case mapping can require subsequent normalization.  */\n  { /* LATIN SMALL LETTER J WITH CARON, COMBINING DOT BELOW */\n    static const uint16_t input[]                 = { 0x01F0, 0x0323 };\n    static const uint16_t casemapped[]            = { 0x004A, 0x030C, 0x0323 };\n    static const uint16_t casemapped_normalized[] = { 0x004A, 0x0323, 0x030C };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL,        casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), NULL, UNINORM_NFC, casemapped_normalized, SIZEOF (casemapped_normalized)) == 0);\n  }\n\n  return 0;\n}",
      "lines": 111,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u16-toupper.c": {
    "check": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static int\ncheck (const uint16_t *input, size_t input_length,\n       const char *iso639_language, uninorm_t nf,\n       const uint16_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint16_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u16_toupper (input, input_length, iso639_language, nf, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u16_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint16_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint16_t *) malloc (length * sizeof (uint16_t));\n      result = u16_toupper (input, input_length, iso639_language, nf, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u16_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint16_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint16_t *) malloc (length * sizeof (uint16_t));\n    result = u16_toupper (input, input_length, iso639_language, nf, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u16_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "int\nmain ()\n{\n  { /* Empty string.  */\n    ASSERT (check (NULL, 0, NULL, NULL, NULL, 0) == 0);\n    ASSERT (check (NULL, 0, NULL, UNINORM_NFC, NULL, 0) == 0);\n  }\n\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint16_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    static const uint16_t casemapped[] =\n      { 'G', 'R', 0x00DC, 0x0053, 0x0053, ' ', 'G', 'O', 'T', 'T', '.', ' ',\n        0x0417, 0x0414, 0x0420, 0x0410, 0x0412, 0x0421, 0x0422, 0x0412, 0x0423,\n        0x0419, 0x0422, 0x0415, '!', ' ',\n        'X', '=', '(', '-', 'B', 0x00B1, 'S', 'Q', 'R', 'T', '(', 'B', 0x00B2,\n        '-', '4', 'A', 'C', ')', ')', '/', '(', '2', 'A', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Case mapping can increase the number of Unicode characters.  */\n  { /* LATIN SMALL LETTER N PRECEDED BY APOSTROPHE */\n    static const uint16_t input[]      = { 0x0149 };\n    static const uint16_t casemapped[] = { 0x02BC, 0x004E };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS */\n    static const uint16_t input[]      = { 0x0390 };\n    static const uint16_t casemapped[] = { 0x0399, 0x0308, 0x0301 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Turkish letters i \u00c4\u00b0 \u00c4\u00b1 I */\n  { /* LATIN CAPITAL LETTER I */\n    static const uint16_t input[]      = { 0x0049 };\n    static const uint16_t casemapped[] = { 0x0049 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* LATIN SMALL LETTER I */\n    static const uint16_t input[]         = { 0x0069 };\n    static const uint16_t casemapped[]    = { 0x0049 };\n    static const uint16_t casemapped_tr[] = { 0x0130 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped_tr, SIZEOF (casemapped_tr)) == 0);\n  }\n  { /* LATIN CAPITAL LETTER I WITH DOT ABOVE */\n    static const uint16_t input[]      = { 0x0130 };\n    static const uint16_t casemapped[] = { 0x0130 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* LATIN SMALL LETTER DOTLESS I */\n    static const uint16_t input[]      = { 0x0131 };\n    static const uint16_t casemapped[] = { 0x0049 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"topkap\u00c4\u00b1\" */\n    static const uint16_t input[] =\n      { 0x0074, 0x006F, 0x0070, 0x006B, 0x0061, 0x0070, 0x0131 };\n    static const uint16_t casemapped[] =\n      { 0x0054, 0x004F, 0x0050, 0x004B, 0x0041, 0x0050, 0x0049 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Uppercasing can increase the number of Unicode characters.  */\n  { /* \"hei\u00c3\u009f\" */\n    static const uint16_t input[]      = { 0x0068, 0x0065, 0x0069, 0x00DF };\n    static const uint16_t casemapped[] = { 0x0048, 0x0045, 0x0049, 0x0053, 0x0053 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Case mappings for some characters can depend on the surrounding characters.  */\n  { /* \"\u00cf\u0080\u00ce\u00b5\u00cf\u0081\u00ce\u00b9\u00cf\u0083\u00cf\u0083\u00cf\u008c\u00cf\u0084\u00ce\u00b5\u00cf\u0081\u00ce\u00b5\u00cf\u0082 \u00cf\u0080\u00ce\u00bb\u00ce\u00b7\u00cf\u0081\u00ce\u00bf\u00cf\u0086\u00ce\u00bf\u00cf\u0081\u00ce\u00af\u00ce\u00b5\u00cf\u0082\" */\n    static const uint16_t input[] =\n      {\n        0x03C0, 0x03B5, 0x03C1, 0x03B9, 0x03C3, 0x03C3, 0x03CC, 0x03C4,\n        0x03B5, 0x03C1, 0x03B5, 0x03C2, 0x0020, 0x03C0, 0x03BB, 0x03B7,\n        0x03C1, 0x03BF, 0x03C6, 0x03BF, 0x03C1, 0x03AF, 0x03B5, 0x03C2\n      };\n    static const uint16_t casemapped[] =\n      {\n        0x03A0, 0x0395, 0x03A1, 0x0399, 0x03A3, 0x03A3, 0x038C, 0x03A4,\n        0x0395, 0x03A1, 0x0395, 0x03A3, 0x0020, 0x03A0, 0x039B, 0x0397,\n        0x03A1, 0x039F, 0x03A6, 0x039F, 0x03A1, 0x038A, 0x0395, 0x03A3\n      };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Case mapping can require subsequent normalization.  */\n  { /* LATIN SMALL LETTER J WITH CARON, COMBINING DOT BELOW */\n    static const uint16_t input[]                 = { 0x01F0, 0x0323 };\n    static const uint16_t casemapped[]            = { 0x004A, 0x030C, 0x0323 };\n    static const uint16_t casemapped_normalized[] = { 0x004A, 0x0323, 0x030C };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL,        casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), NULL, UNINORM_NFC, casemapped_normalized, SIZEOF (casemapped_normalized)) == 0);\n  }\n\n  return 0;\n}",
      "lines": 111,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u32-casecmp.c": {
    "test_nonascii": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        311,
        1
      ],
      "content": "static void\ntest_nonascii (int (*my_casecmp) (const uint32_t *, size_t, const uint32_t *, size_t, const char *, uninorm_t, int *))\n{\n  /* Normalization effects.  */\n  {\n    static const uint32_t input1[] = { 'H', 0x00F6, 'h', 'l', 'e' };\n    static const uint32_t input2[] = { 'H', 'O', 0x0308, 'h', 'L', 'e' };\n    static const uint32_t input3[] = { 'H', 0x00F6, 'h', 'l', 'e', 'n' };\n    static const uint32_t input4[] = { 'H', 'O', 0x0308, 'h', 'L', 'e', 'n' };\n    static const uint32_t input5[] = { 'H', 'u', 'r', 'z' };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input2, SIZEOF (input2), input1, SIZEOF (input1), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input3, SIZEOF (input3), input4, SIZEOF (input4), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input4, SIZEOF (input4), input3, SIZEOF (input3), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input2, SIZEOF (input2), input3, SIZEOF (input3), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input4, SIZEOF (input4), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input5, SIZEOF (input5), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_casecmp (input2, SIZEOF (input2), input5, SIZEOF (input5), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n  }\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS */\n    static const uint32_t input1[] = { 0x00C4 };\n    static const uint32_t input2[] = { 0x0041, 0x0308 };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON */\n    static const uint32_t input1[] = { 0x01DE };\n    static const uint32_t input2[] = { 0x0041, 0x0308, 0x0304 };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* GREEK DIALYTIKA AND PERISPOMENI */\n    static const uint32_t input1[] = { 0x1FC1 };\n    static const uint32_t input2[] = { 0x00A8, 0x0342 };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* HANGUL SYLLABLE GEUL */\n    static const uint32_t input1[] = { 0xAE00 };\n    static const uint32_t input2[] = { 0xADF8, 0x11AF };\n    static const uint32_t input3[] = { 0x1100, 0x1173, 0x11AF };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input3, SIZEOF (input3), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* HANGUL SYLLABLE GEU */\n    static const uint32_t input1[] = { 0xADF8 };\n    static const uint32_t input2[] = { 0x1100, 0x1173 };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint32_t input1[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    static const uint32_t input2[] =\n      { 'g', 'r', 0x00FC, 0x0073, 0x0073, ' ', 'g', 'o', 't', 't', '.', ' ',\n        0x0437, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    static const uint32_t input3[] =\n      { 'G', 'R', 0x00DC, 0x0053, 0x0053, ' ', 'G', 'O', 'T', 'T', '.', ' ',\n        0x0417, 0x0414, 0x0420, 0x0410, 0x0412, 0x0421, 0x0422, 0x0412, 0x0423,\n        0x0419, 0x0422, 0x0415, '!', ' ',\n        'X', '=', '(', '-', 'B', 0x00B1, 'S', 'Q', 'R', 'T', '(', 'B', 0x00B2,\n        '-', '4', 'A', 'C', ')', ')', '/', '(', '2', 'A', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input3, SIZEOF (input3), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input3, SIZEOF (input3), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input2, SIZEOF (input2), input3, SIZEOF (input3), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input2, SIZEOF (input2), input3, SIZEOF (input3), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n\n  /* Case mapping can increase the number of Unicode characters.  */\n  { /* LATIN SMALL LETTER N PRECEDED BY APOSTROPHE */\n    static const uint32_t input1[] = { 0x0149 };\n    static const uint32_t input2[] = { 0x02BC, 0x006E };\n    static const uint32_t input3[] = { 0x02BC, 0x004E };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input3, SIZEOF (input3), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input3, SIZEOF (input3), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS */\n    static const uint32_t input1[] = { 0x0390 };\n    static const uint32_t input2[] = { 0x03B9, 0x0308, 0x0301 };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n\n  /* Turkish letters i \u00c4\u00b0 \u00c4\u00b1 I */\n  { /* LATIN CAPITAL LETTER I */\n    static const uint32_t input[]         = { 0x0049 };\n    static const uint32_t casefolded[]    = { 0x0069 };\n    static const uint32_t casefolded_tr[] = { 0x0131 };\n    int cmp;\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded_tr, SIZEOF (casefolded_tr), \"tr\", NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* LATIN SMALL LETTER I */\n    static const uint32_t input[]         = { 0x0069 };\n    static const uint32_t casefolded[]    = { 0x0049 };\n    static const uint32_t casefolded_tr[] = { 0x0130 };\n    int cmp;\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded_tr, SIZEOF (casefolded_tr), \"tr\", NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* LATIN CAPITAL LETTER I WITH DOT ABOVE */\n    static const uint32_t input[]         = { 0x0130 };\n    static const uint32_t casefolded[]    = { 0x0069, 0x0307 };\n    static const uint32_t casefolded_tr[] = { 0x0069 };\n    int cmp;\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded_tr, SIZEOF (casefolded_tr), \"tr\", NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* LATIN SMALL LETTER DOTLESS I */\n    static const uint32_t input[]      = { 0x0131 };\n    static const uint32_t casefolded[] = { 0x0049 };\n    int cmp;\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 1);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), \"tr\", NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* \"topkap\u00c4\u00b1\" */\n    static const uint32_t input[] =\n      { 0x0054, 0x004F, 0x0050, 0x004B, 0x0041, 0x0050, 0x0049 };\n    static const uint32_t casefolded[] =\n      { 0x0074, 0x006F, 0x0070, 0x006B, 0x0061, 0x0070, 0x0131 };\n    int cmp;\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), \"tr\", NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n\n  /* Uppercasing can increase the number of Unicode characters.  */\n  { /* \"hei\u00c3\u009f\" */\n    static const uint32_t input1[] = { 0x0068, 0x0065, 0x0069, 0x00DF };\n    static const uint32_t input2[] = { 0x0068, 0x0065, 0x0069, 0x0073, 0x0073 };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n\n  /* Case mappings for some characters can depend on the surrounding characters.  */\n  { /* \"\u00cf\u0080\u00ce\u00b5\u00cf\u0081\u00ce\u00b9\u00cf\u0083\u00cf\u0083\u00cf\u008c\u00cf\u0084\u00ce\u00b5\u00cf\u0081\u00ce\u00b5\u00cf\u0082 \u00cf\u0080\u00ce\u00bb\u00ce\u00b7\u00cf\u0081\u00ce\u00bf\u00cf\u0086\u00ce\u00bf\u00cf\u0081\u00ce\u00af\u00ce\u00b5\u00cf\u0082\" */\n    static const uint32_t input1[] =\n      {\n        0x03C0, 0x03B5, 0x03C1, 0x03B9, 0x03C3, 0x03C3, 0x03CC, 0x03C4,\n        0x03B5, 0x03C1, 0x03B5, 0x03C2, 0x0020, 0x03C0, 0x03BB, 0x03B7,\n        0x03C1, 0x03BF, 0x03C6, 0x03BF, 0x03C1, 0x03AF, 0x03B5, 0x03C2\n      };\n    static const uint32_t input2[] =\n      {\n        0x03C0, 0x03B5, 0x03C1, 0x03B9, 0x03C3, 0x03C3, 0x03CC, 0x03C4,\n        0x03B5, 0x03C1, 0x03B5, 0x03C3, 0x0020, 0x03C0, 0x03BB, 0x03B7,\n        0x03C1, 0x03BF, 0x03C6, 0x03BF, 0x03C1, 0x03AF, 0x03B5, 0x03C3\n      };\n    static const uint32_t input3[] =\n      {\n        0x03A0, 0x0395, 0x03A1, 0x0399, 0x03A3, 0x03A3, 0x038C, 0x03A4,\n        0x0395, 0x03A1, 0x0395, 0x03A3, 0x0020, 0x03A0, 0x039B, 0x0397,\n        0x03A1, 0x039F, 0x03A6, 0x039F, 0x03A1, 0x038A, 0x0395, 0x03A3\n      };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input3, SIZEOF (input3), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input2, SIZEOF (input2), input3, SIZEOF (input3), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n\n  /* Case mapping can require subsequent normalization.  */\n  { /* LATIN SMALL LETTER J WITH CARON, COMBINING DOT BELOW */\n    static const uint32_t input[]                 = { 0x01F0, 0x0323 };\n    static const uint32_t casefolded[]            = { 0x006A, 0x030C, 0x0323 };\n    static const uint32_t casefolded_decomposed[] = { 0x006A, 0x0323, 0x030C };\n    int cmp;\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded_decomposed, SIZEOF (casefolded_decomposed), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp != 0);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded_decomposed, SIZEOF (casefolded_decomposed), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n}",
      "lines": 283,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        313,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "int\nmain ()\n{\n  test_ascii (u32_casecmp, UNINORM_NFD);\n  test_nonascii (u32_casecmp);\n\n  return 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u32-casecoll.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nmain ()\n{\n  /* In the \"C\" locale, strcoll is equivalent to strcmp, therefore u8_casecoll\n     on ASCII strings should behave like strcasecmp.  */\n  test_ascii (u32_casecoll, UNINORM_NFC);\n\n  return 0;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u32-casefold.c": {
    "check": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static int\ncheck (const uint32_t *input, size_t input_length,\n       const char *iso639_language, uninorm_t nf,\n       const uint32_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint32_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u32_casefold (input, input_length, iso639_language, nf, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u32_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint32_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint32_t *) malloc (length * sizeof (uint32_t));\n      result = u32_casefold (input, input_length, iso639_language, nf, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u32_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint32_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint32_t *) malloc (length * sizeof (uint32_t));\n    result = u32_casefold (input, input_length, iso639_language, nf, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u32_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        200,
        1
      ],
      "content": "int\nmain ()\n{\n  { /* Empty string.  */\n    ASSERT (check (NULL, 0, NULL, NULL, NULL, 0) == 0);\n    ASSERT (check (NULL, 0, NULL, UNINORM_NFC, NULL, 0) == 0);\n  }\n\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint32_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    static const uint32_t casefolded[] =\n      { 'g', 'r', 0x00FC, 0x0073, 0x0073, ' ', 'g', 'o', 't', 't', '.', ' ',\n        0x0437, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n  }\n\n  /* Case mapping can increase the number of Unicode characters.  */\n  { /* LATIN SMALL LETTER N PRECEDED BY APOSTROPHE */\n    static const uint32_t input[]      = { 0x0149 };\n    static const uint32_t casefolded[] = { 0x02BC, 0x006E };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n  }\n  { /* GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS */\n    static const uint32_t input[]      = { 0x0390 };\n    static const uint32_t casefolded[] = { 0x03B9, 0x0308, 0x0301 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n  }\n\n  /* Turkish letters i \u00c4\u00b0 \u00c4\u00b1 I */\n  { /* LATIN CAPITAL LETTER I */\n    static const uint32_t input[]         = { 0x0049 };\n    static const uint32_t casefolded[]    = { 0x0069 };\n    static const uint32_t casefolded_tr[] = { 0x0131 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casefolded_tr, SIZEOF (casefolded_tr)) == 0);\n  }\n  { /* LATIN SMALL LETTER I */\n    static const uint32_t input[]      = { 0x0069 };\n    static const uint32_t casefolded[] = { 0x0069 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casefolded, SIZEOF (casefolded)) == 0);\n  }\n  { /* LATIN CAPITAL LETTER I WITH DOT ABOVE */\n    static const uint32_t input[]         = { 0x0130 };\n    static const uint32_t casefolded[]    = { 0x0069, 0x0307 };\n    static const uint32_t casefolded_tr[] = { 0x0069 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casefolded_tr, SIZEOF (casefolded_tr)) == 0);\n  }\n  { /* LATIN SMALL LETTER DOTLESS I */\n    static const uint32_t input[]      = { 0x0131 };\n    static const uint32_t casefolded[] = { 0x0131 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casefolded, SIZEOF (casefolded)) == 0);\n  }\n  { /* \"topkap\u00c4\u00b1\" */\n    static const uint32_t input[] =\n      { 0x0074, 0x006F, 0x0070, 0x006B, 0x0061, 0x0070, 0x0131 };\n    static const uint32_t casefolded[] =\n      { 0x0074, 0x006F, 0x0070, 0x006B, 0x0061, 0x0070, 0x0131 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casefolded, SIZEOF (casefolded)) == 0);\n  }\n\n  /* Uppercasing can increase the number of Unicode characters.  */\n  { /* \"hei\u00c3\u009f\" */\n    static const uint32_t input[]      = { 0x0068, 0x0065, 0x0069, 0x00DF };\n    static const uint32_t casefolded[] = { 0x0068, 0x0065, 0x0069, 0x0073, 0x0073 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n  }\n\n  /* Case mappings for some characters can depend on the surrounding characters.  */\n  { /* \"\u00cf\u0080\u00ce\u00b5\u00cf\u0081\u00ce\u00b9\u00cf\u0083\u00cf\u0083\u00cf\u008c\u00cf\u0084\u00ce\u00b5\u00cf\u0081\u00ce\u00b5\u00cf\u0082 \u00cf\u0080\u00ce\u00bb\u00ce\u00b7\u00cf\u0081\u00ce\u00bf\u00cf\u0086\u00ce\u00bf\u00cf\u0081\u00ce\u00af\u00ce\u00b5\u00cf\u0082\" */\n    static const uint32_t input[] =\n      {\n        0x03C0, 0x03B5, 0x03C1, 0x03B9, 0x03C3, 0x03C3, 0x03CC, 0x03C4,\n        0x03B5, 0x03C1, 0x03B5, 0x03C2, 0x0020, 0x03C0, 0x03BB, 0x03B7,\n        0x03C1, 0x03BF, 0x03C6, 0x03BF, 0x03C1, 0x03AF, 0x03B5, 0x03C2\n      };\n    static const uint32_t casefolded[] =\n      {\n        0x03C0, 0x03B5, 0x03C1, 0x03B9, 0x03C3, 0x03C3, 0x03CC, 0x03C4,\n        0x03B5, 0x03C1, 0x03B5, 0x03C3, 0x0020, 0x03C0, 0x03BB, 0x03B7,\n        0x03C1, 0x03BF, 0x03C6, 0x03BF, 0x03C1, 0x03AF, 0x03B5, 0x03C3\n      };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n  }\n\n  /* Case mapping can require subsequent normalization.  */\n  { /* LATIN SMALL LETTER J WITH CARON, COMBINING DOT BELOW */\n    static const uint32_t input[]                 = { 0x01F0, 0x0323 };\n    static const uint32_t casefolded[]            = { 0x006A, 0x030C, 0x0323 };\n    static const uint32_t casefolded_decomposed[] = { 0x006A, 0x0323, 0x030C };\n    static const uint32_t casefolded_normalized[] = { 0x01F0, 0x0323 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL,        casefolded, SIZEOF (casefolded)) == 0);\n    ASSERT (check (input, SIZEOF (input), NULL, UNINORM_NFD, casefolded_decomposed, SIZEOF (casefolded_decomposed)) == 0);\n    ASSERT (check (input, SIZEOF (input), NULL, UNINORM_NFC, casefolded_normalized, SIZEOF (casefolded_normalized)) == 0);\n  }\n\n  return 0;\n}",
      "lines": 114,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u32-is-cased.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "int\nmain ()\n{\n  test_ascii (u32_is_cased);\n\n  return 0;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u32-is-casefolded.c": {
    "test_nonascii": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "static void\ntest_nonascii (int (*my_is) (const uint32_t *, size_t, const char *, bool *))\n{\n  /* Test cases from Unicode 5.1.0.  */\n  {\n    static const uint32_t input[] = { 0x00DF };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == false);\n  }\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nmain ()\n{\n  test_ascii (u32_is_casefolded);\n  test_nonascii (u32_is_casefolded);\n\n  return 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u32-is-lowercase.c": {
    "test_nonascii": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static void\ntest_nonascii (int (*my_is) (const uint32_t *, size_t, const char *, bool *))\n{\n  /* Test cases from Unicode 5.1.0.  */\n  {\n    static const uint32_t input[] = { 0x24D7 };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const uint32_t input[] = { 0x24BD };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == false);\n  }\n  {\n    static const uint32_t input[] = { 0x02B0 };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const uint32_t input[] = { 0x1D34 };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const uint32_t input[] = { 0x02BD };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nmain ()\n{\n  test_ascii (u32_is_lowercase);\n  test_nonascii (u32_is_lowercase);\n\n  return 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u32-is-titlecase.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "int\nmain ()\n{\n  test_ascii (u32_is_titlecase);\n\n  return 0;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u32-is-uppercase.c": {
    "test_nonascii": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static void\ntest_nonascii (int (*my_is) (const uint32_t *, size_t, const char *, bool *))\n{\n  /* Test cases from Unicode 5.1.0.  */\n  {\n    static const uint32_t input[] = { 0x24D7 };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == false);\n  }\n  {\n    static const uint32_t input[] = { 0x24BD };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const uint32_t input[] = { 0x02B0 };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const uint32_t input[] = { 0x1D34 };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const uint32_t input[] = { 0x02BD };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nmain ()\n{\n  test_ascii (u32_is_uppercase);\n  test_nonascii (u32_is_uppercase);\n\n  return 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u32-tolower.c": {
    "check": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static int\ncheck (const uint32_t *input, size_t input_length,\n       const char *iso639_language, uninorm_t nf,\n       const uint32_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint32_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u32_tolower (input, input_length, iso639_language, nf, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u32_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint32_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint32_t *) malloc (length * sizeof (uint32_t));\n      result = u32_tolower (input, input_length, iso639_language, nf, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u32_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint32_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint32_t *) malloc (length * sizeof (uint32_t));\n    result = u32_tolower (input, input_length, iso639_language, nf, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u32_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "int\nmain ()\n{\n  { /* Empty string.  */\n    ASSERT (check (NULL, 0, NULL, NULL, NULL, 0) == 0);\n    ASSERT (check (NULL, 0, NULL, UNINORM_NFC, NULL, 0) == 0);\n  }\n\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint32_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    static const uint32_t casemapped[] =\n      { 'g', 'r', 0x00FC, 0x00DF, ' ', 'g', 'o', 't', 't', '.', ' ',\n        0x0437, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Turkish letters i \u00c4\u00b0 \u00c4\u00b1 I */\n  { /* LATIN CAPITAL LETTER I */\n    static const uint32_t input[]         = { 0x0049 };\n    static const uint32_t casemapped[]    = { 0x0069 };\n    static const uint32_t casemapped_tr[] = { 0x0131 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped_tr, SIZEOF (casemapped_tr)) == 0);\n  }\n  { /* LATIN SMALL LETTER I */\n    static const uint32_t input[]      = { 0x0069 };\n    static const uint32_t casemapped[] = { 0x0069 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* LATIN CAPITAL LETTER I WITH DOT ABOVE */\n    static const uint32_t input[]         = { 0x0130 };\n    static const uint32_t casemapped[]    = { 0x0069, 0x0307 };\n    static const uint32_t casemapped_tr[] = { 0x0069 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped_tr, SIZEOF (casemapped_tr)) == 0);\n  }\n  { /* LATIN SMALL LETTER DOTLESS I */\n    static const uint32_t input[]      = { 0x0131 };\n    static const uint32_t casemapped[] = { 0x0131 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"TOPKAPI\" */\n    static const uint32_t input[] =\n      { 0x0054, 0x004F, 0x0050, 0x004B, 0x0041, 0x0050, 0x0049 };\n    static const uint32_t casemapped[] =\n      { 0x0074, 0x006F, 0x0070, 0x006B, 0x0061, 0x0070, 0x0131 };\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Uppercasing can increase the number of Unicode characters.  */\n  { /* \"HEI\u00c3\u009f\" */\n    static const uint32_t input[]      = { 0x0048, 0x0045, 0x0049, 0x00DF };\n    static const uint32_t casemapped[] = { 0x0068, 0x0065, 0x0069, 0x00DF };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Case mappings for some characters can depend on the surrounding characters.  */\n  { /* \"\u00ce\u00a0\u00ce\u0095\u00ce\u00a1\u00ce\u0099\u00ce\u00a3\u00ce\u00a3\u00ce\u008c\u00ce\u00a4\u00ce\u0095\u00ce\u00a1\u00ce\u0095\u00ce\u00a3 \u00ce\u00a0\u00ce\u009b\u00ce\u0097\u00ce\u00a1\u00ce\u009f\u00ce\u00a6\u00ce\u009f\u00ce\u00a1\u00ce\u008a\u00ce\u0095\u00ce\u00a3\" */\n    static const uint32_t input[] =\n      {\n        0x03A0, 0x0395, 0x03A1, 0x0399, 0x03A3, 0x03A3, 0x038C, 0x03A4,\n        0x0395, 0x03A1, 0x0395, 0x03A3, 0x0020, 0x03A0, 0x039B, 0x0397,\n        0x03A1, 0x039F, 0x03A6, 0x039F, 0x03A1, 0x038A, 0x0395, 0x03A3\n      };\n    static const uint32_t casemapped[] =\n      {\n        0x03C0, 0x03B5, 0x03C1, 0x03B9, 0x03C3, 0x03C3, 0x03CC, 0x03C4,\n        0x03B5, 0x03C1, 0x03B5, 0x03C2, 0x0020, 0x03C0, 0x03BB, 0x03B7,\n        0x03C1, 0x03BF, 0x03C6, 0x03BF, 0x03C1, 0x03AF, 0x03B5, 0x03C2\n      };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"\u00ce\u00a3\" -> \"\u00cf\u0083\" */\n    static const uint32_t input[] =      { 0x03A3 };\n    static const uint32_t casemapped[] = { 0x03C3 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"\u00ce\u0091\u00ce\u00a3\" -> \"\u00ce\u00b1\u00cf\u0082\" */\n    static const uint32_t input[] =      { 0x0391, 0x03A3 };\n    static const uint32_t casemapped[] = { 0x03B1, 0x03C2 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  /* It's a final sigma only if not followed by a case-ignorable sequence and\n     then a cased letter.  Note that U+0345 and U+037A are simultaneously\n     case-ignorable and cased (which is a bit paradoxical).  */\n  { /* \"\u00ce\u0091\u00ce\u00a3\u00ce\u0091\" -> \"\u00ce\u00b1\u00cf\u0083\u00ce\u00b1\" */\n    static const uint32_t input[] =      { 0x0391, 0x03A3, 0x0391 };\n    static const uint32_t casemapped[] = { 0x03B1, 0x03C3, 0x03B1 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"\u00ce\u0091\u00ce\u00a3:\" -> \"\u00ce\u00b1\u00cf\u0082:\" */\n    static const uint32_t input[] =      { 0x0391, 0x03A3, 0x003A };\n    static const uint32_t casemapped[] = { 0x03B1, 0x03C2, 0x003A };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"\u00ce\u0091\u00ce\u00a3:\u00ce\u0091\" -> \"\u00ce\u00b1\u00cf\u0083:\u00ce\u00b1\" */\n    static const uint32_t input[] =      { 0x0391, 0x03A3, 0x003A, 0x0391 };\n    static const uint32_t casemapped[] = { 0x03B1, 0x03C3, 0x003A, 0x03B1 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"\u00ce\u0091\u00ce\u00a3:\u00cd\u00ba\" -> \"\u00ce\u00b1\u00cf\u0083:\u00cd\u00ba\" */\n    static const uint32_t input[] =      { 0x0391, 0x03A3, 0x003A, 0x037A };\n    static const uint32_t casemapped[] = { 0x03B1, 0x03C3, 0x003A, 0x037A };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"\u00ce\u0091\u00ce\u00a3:\u00cd\u00ba \" -> \"\u00ce\u00b1\u00cf\u0083:\u00cd\u00ba \" */\n    static const uint32_t input[] =      { 0x0391, 0x03A3, 0x003A, 0x037A, 0x0020 };\n    static const uint32_t casemapped[] = { 0x03B1, 0x03C3, 0x003A, 0x037A, 0x0020 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  /* It's a final sigma only if preceded by a case-ignorable sequence and\n     a cased letter before it.  Note that U+0345 and U+037A are simultaneously\n     case-ignorable and cased (which is a bit paradoxical).  */\n  { /* \":\u00ce\u00a3\" -> \":\u00cf\u0083\" */\n    static const uint32_t input[] =      { 0x003A, 0x03A3 };\n    static const uint32_t casemapped[] = { 0x003A, 0x03C3 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"\u00ce\u0091:\u00ce\u00a3\" -> \"\u00ce\u00b1:\u00cf\u0082\" */\n    static const uint32_t input[] =      { 0x0391, 0x003A, 0x03A3 };\n    static const uint32_t casemapped[] = { 0x03B1, 0x003A, 0x03C2 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"\u00cd\u00ba:\u00ce\u00a3\" -> \"\u00cd\u00ba:\u00cf\u0082\" */\n    static const uint32_t input[] =      { 0x037A, 0x003A, 0x03A3 };\n    static const uint32_t casemapped[] = { 0x037A, 0x003A, 0x03C2 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \" \u00cd\u00ba:\u00ce\u00a3\" -> \" \u00cd\u00ba:\u00cf\u0082\" */\n    static const uint32_t input[] =      { 0x0020, 0x037A, 0x003A, 0x03A3 };\n    static const uint32_t casemapped[] = { 0x0020, 0x037A, 0x003A, 0x03C2 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  return 0;\n}",
      "lines": 151,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u32-totitle.c": {
    "check": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static int\ncheck (const uint32_t *input, size_t input_length,\n       const char *iso639_language, uninorm_t nf,\n       const uint32_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint32_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u32_totitle (input, input_length, iso639_language, nf, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u32_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint32_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint32_t *) malloc (length * sizeof (uint32_t));\n      result = u32_totitle (input, input_length, iso639_language, nf, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u32_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint32_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint32_t *) malloc (length * sizeof (uint32_t));\n    result = u32_totitle (input, input_length, iso639_language, nf, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u32_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "int\nmain ()\n{\n  { /* Empty string.  */\n    ASSERT (check (NULL, 0, NULL, NULL, NULL, 0) == 0);\n    ASSERT (check (NULL, 0, NULL, UNINORM_NFC, NULL, 0) == 0);\n  }\n\n  /* Simple string.  */\n  { /* \"GR\u00c3\u009c\u00c3\u009f GOTT. \u00d0\u0097\u00d0\u0094\u00d0\u00a0\u00d0\u0090\u00d0\u0092\u00d0\u00a1\u00d0\u00a2\u00d0\u0092\u00d0\u00a3\u00d0\u0099\u00d0\u00a2\u00d0\u0095! X=(-B\u00c2\u00b1SQRT(B\u00c2\u00b2-4AC))/(2A)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint32_t input[] =\n      { 'G', 'R', 0x00DC, 0x00DF, ' ', 'G', 'O', 'T', 'T', '.', ' ',\n        0x0417, 0x0414, 0x0420, 0x0410, 0x0412, 0x0421, 0x0422, 0x0412, 0x0423,\n        0x0419, 0x0422, 0x0415, '!', ' ',\n        'X', '=', '(', '-', 'B', 0x00B1, 'S', 'Q', 'R', 'T', '(', 'B', 0x00B2,\n        '-', '4', 'A', 'C', ')', ')', '/', '(', '2', 'A', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    static const uint32_t casemapped[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'X', '=', '(', '-', 'B', 0x00B1, 'S', 'q', 'r', 't', '(', 'B', 0x00B2,\n        '-', '4', 'A', 'c', ')', ')', '/', '(', '2', 'A', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Case mapping can increase the number of Unicode characters.  */\n  { /* LATIN SMALL LETTER N PRECEDED BY APOSTROPHE */\n    static const uint32_t input[]      = { 0x0149 };\n    static const uint32_t casemapped[] = { 0x02BC, 0x004E };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS */\n    static const uint32_t input[]      = { 0x0390 };\n    static const uint32_t casemapped[] = { 0x0399, 0x0308, 0x0301 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Turkish letters i \u00c4\u00b0 \u00c4\u00b1 I */\n  { /* LATIN CAPITAL LETTER I */\n    static const uint32_t input[]      = { 0x0049 };\n    static const uint32_t casemapped[] = { 0x0049 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* LATIN SMALL LETTER I */\n    static const uint32_t input[]         = { 0x0069 };\n    static const uint32_t casemapped[]    = { 0x0049 };\n    static const uint32_t casemapped_tr[] = { 0x0130 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped_tr, SIZEOF (casemapped_tr)) == 0);\n  }\n  { /* LATIN CAPITAL LETTER I WITH DOT ABOVE */\n    static const uint32_t input[]      = { 0x0130 };\n    static const uint32_t casemapped[] = { 0x0130 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* LATIN SMALL LETTER DOTLESS I */\n    static const uint32_t input[]      = { 0x0131 };\n    static const uint32_t casemapped[] = { 0x0049 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"topkap\u00c4\u00b1\" */\n    static const uint32_t input[] =\n      { 0x0074, 0x006F, 0x0070, 0x006B, 0x0061, 0x0070, 0x0131 };\n    static const uint32_t casemapped[] =\n      { 0x0054, 0x006F, 0x0070, 0x006B, 0x0061, 0x0070, 0x0131 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Uppercasing can increase the number of Unicode characters.  */\n  { /* \"hei\u00c3\u009f\" */\n    static const uint32_t input[]      = { 0x0068, 0x0065, 0x0069, 0x00DF };\n    static const uint32_t casemapped[] = { 0x0048, 0x0065, 0x0069, 0x00DF };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Case mappings for some characters can depend on the surrounding characters.  */\n  { /* \"\u00cf\u0080\u00ce\u00b5\u00cf\u0081\u00ce\u00b9\u00cf\u0083\u00cf\u0083\u00cf\u008c\u00cf\u0084\u00ce\u00b5\u00cf\u0081\u00ce\u00b5\u00cf\u0082 \u00cf\u0080\u00ce\u00bb\u00ce\u00b7\u00cf\u0081\u00ce\u00bf\u00cf\u0086\u00ce\u00bf\u00cf\u0081\u00ce\u00af\u00ce\u00b5\u00cf\u0082\" */\n    static const uint32_t input[] =\n      {\n        0x03C0, 0x03B5, 0x03C1, 0x03B9, 0x03C3, 0x03C3, 0x03CC, 0x03C4,\n        0x03B5, 0x03C1, 0x03B5, 0x03C2, 0x0020, 0x03C0, 0x03BB, 0x03B7,\n        0x03C1, 0x03BF, 0x03C6, 0x03BF, 0x03C1, 0x03AF, 0x03B5, 0x03C2\n      };\n    static const uint32_t casemapped[] =\n      {\n        0x03A0, 0x03B5, 0x03C1, 0x03B9, 0x03C3, 0x03C3, 0x03CC, 0x03C4,\n        0x03B5, 0x03C1, 0x03B5, 0x03C2, 0x0020, 0x03A0, 0x03BB, 0x03B7,\n        0x03C1, 0x03BF, 0x03C6, 0x03BF, 0x03C1, 0x03AF, 0x03B5, 0x03C2\n      };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Case mapping can require subsequent normalization.  */\n  { /* LATIN SMALL LETTER J WITH CARON, COMBINING DOT BELOW */\n    static const uint32_t input[]                 = { 0x01F0, 0x0323 };\n    static const uint32_t casemapped[]            = { 0x004A, 0x030C, 0x0323 };\n    static const uint32_t casemapped_normalized[] = { 0x004A, 0x0323, 0x030C };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL,        casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), NULL, UNINORM_NFC, casemapped_normalized, SIZEOF (casemapped_normalized)) == 0);\n  }\n\n  return 0;\n}",
      "lines": 111,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u32-toupper.c": {
    "check": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static int\ncheck (const uint32_t *input, size_t input_length,\n       const char *iso639_language, uninorm_t nf,\n       const uint32_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint32_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u32_toupper (input, input_length, iso639_language, nf, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u32_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint32_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint32_t *) malloc (length * sizeof (uint32_t));\n      result = u32_toupper (input, input_length, iso639_language, nf, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u32_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint32_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint32_t *) malloc (length * sizeof (uint32_t));\n    result = u32_toupper (input, input_length, iso639_language, nf, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u32_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "int\nmain ()\n{\n  { /* Empty string.  */\n    ASSERT (check (NULL, 0, NULL, NULL, NULL, 0) == 0);\n    ASSERT (check (NULL, 0, NULL, UNINORM_NFC, NULL, 0) == 0);\n  }\n\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint32_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    static const uint32_t casemapped[] =\n      { 'G', 'R', 0x00DC, 0x0053, 0x0053, ' ', 'G', 'O', 'T', 'T', '.', ' ',\n        0x0417, 0x0414, 0x0420, 0x0410, 0x0412, 0x0421, 0x0422, 0x0412, 0x0423,\n        0x0419, 0x0422, 0x0415, '!', ' ',\n        'X', '=', '(', '-', 'B', 0x00B1, 'S', 'Q', 'R', 'T', '(', 'B', 0x00B2,\n        '-', '4', 'A', 'C', ')', ')', '/', '(', '2', 'A', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Case mapping can increase the number of Unicode characters.  */\n  { /* LATIN SMALL LETTER N PRECEDED BY APOSTROPHE */\n    static const uint32_t input[]      = { 0x0149 };\n    static const uint32_t casemapped[] = { 0x02BC, 0x004E };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS */\n    static const uint32_t input[]      = { 0x0390 };\n    static const uint32_t casemapped[] = { 0x0399, 0x0308, 0x0301 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Turkish letters i \u00c4\u00b0 \u00c4\u00b1 I */\n  { /* LATIN CAPITAL LETTER I */\n    static const uint32_t input[]      = { 0x0049 };\n    static const uint32_t casemapped[] = { 0x0049 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* LATIN SMALL LETTER I */\n    static const uint32_t input[]         = { 0x0069 };\n    static const uint32_t casemapped[]    = { 0x0049 };\n    static const uint32_t casemapped_tr[] = { 0x0130 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped_tr, SIZEOF (casemapped_tr)) == 0);\n  }\n  { /* LATIN CAPITAL LETTER I WITH DOT ABOVE */\n    static const uint32_t input[]      = { 0x0130 };\n    static const uint32_t casemapped[] = { 0x0130 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* LATIN SMALL LETTER DOTLESS I */\n    static const uint32_t input[]      = { 0x0131 };\n    static const uint32_t casemapped[] = { 0x0049 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"topkap\u00c4\u00b1\" */\n    static const uint32_t input[] =\n      { 0x0074, 0x006F, 0x0070, 0x006B, 0x0061, 0x0070, 0x0131 };\n    static const uint32_t casemapped[] =\n      { 0x0054, 0x004F, 0x0050, 0x004B, 0x0041, 0x0050, 0x0049 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Uppercasing can increase the number of Unicode characters.  */\n  { /* \"hei\u00c3\u009f\" */\n    static const uint32_t input[]      = { 0x0068, 0x0065, 0x0069, 0x00DF };\n    static const uint32_t casemapped[] = { 0x0048, 0x0045, 0x0049, 0x0053, 0x0053 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Case mappings for some characters can depend on the surrounding characters.  */\n  { /* \"\u00cf\u0080\u00ce\u00b5\u00cf\u0081\u00ce\u00b9\u00cf\u0083\u00cf\u0083\u00cf\u008c\u00cf\u0084\u00ce\u00b5\u00cf\u0081\u00ce\u00b5\u00cf\u0082 \u00cf\u0080\u00ce\u00bb\u00ce\u00b7\u00cf\u0081\u00ce\u00bf\u00cf\u0086\u00ce\u00bf\u00cf\u0081\u00ce\u00af\u00ce\u00b5\u00cf\u0082\" */\n    static const uint32_t input[] =\n      {\n        0x03C0, 0x03B5, 0x03C1, 0x03B9, 0x03C3, 0x03C3, 0x03CC, 0x03C4,\n        0x03B5, 0x03C1, 0x03B5, 0x03C2, 0x0020, 0x03C0, 0x03BB, 0x03B7,\n        0x03C1, 0x03BF, 0x03C6, 0x03BF, 0x03C1, 0x03AF, 0x03B5, 0x03C2\n      };\n    static const uint32_t casemapped[] =\n      {\n        0x03A0, 0x0395, 0x03A1, 0x0399, 0x03A3, 0x03A3, 0x038C, 0x03A4,\n        0x0395, 0x03A1, 0x0395, 0x03A3, 0x0020, 0x03A0, 0x039B, 0x0397,\n        0x03A1, 0x039F, 0x03A6, 0x039F, 0x03A1, 0x038A, 0x0395, 0x03A3\n      };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Case mapping can require subsequent normalization.  */\n  { /* LATIN SMALL LETTER J WITH CARON, COMBINING DOT BELOW */\n    static const uint32_t input[]                 = { 0x01F0, 0x0323 };\n    static const uint32_t casemapped[]            = { 0x004A, 0x030C, 0x0323 };\n    static const uint32_t casemapped_normalized[] = { 0x004A, 0x0323, 0x030C };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL,        casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), NULL, UNINORM_NFC, casemapped_normalized, SIZEOF (casemapped_normalized)) == 0);\n  }\n\n  return 0;\n}",
      "lines": 111,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u8-casecmp.c": {
    "test_nonascii": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "static void\ntest_nonascii (int (*my_casecmp) (const uint8_t *, size_t, const uint8_t *, size_t, const char *, uninorm_t, int *))\n{\n  /* Normalization effects.  */\n  {\n    static const uint8_t input1[] = { 'H', 0xC3, 0xB6, 'h', 'l', 'e' };\n    static const uint8_t input2[] = { 'H', 'O', 0xCC, 0x88, 'h', 'L', 'e' };\n    static const uint8_t input3[] = { 'H', 0xC3, 0xB6, 'h', 'l', 'e', 'n' };\n    static const uint8_t input4[] = { 'H', 'O', 0xCC, 0x88, 'h', 'L', 'e', 'n' };\n    static const uint8_t input5[] = { 'H', 'u', 'r', 'z' };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input2, SIZEOF (input2), input1, SIZEOF (input1), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input3, SIZEOF (input3), input4, SIZEOF (input4), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input4, SIZEOF (input4), input3, SIZEOF (input3), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input2, SIZEOF (input2), input3, SIZEOF (input3), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input4, SIZEOF (input4), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input5, SIZEOF (input5), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_casecmp (input2, SIZEOF (input2), input5, SIZEOF (input5), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n  }\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS */\n    static const uint8_t input1[] = { 0xC3, 0x84 };\n    static const uint8_t input2[] = { 0x41, 0xCC, 0x88 };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON */\n    static const uint8_t input1[] = { 0xC7, 0x9E };\n    static const uint8_t input2[] = { 0x41, 0xCC, 0x88, 0xCC, 0x84 };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* GREEK DIALYTIKA AND PERISPOMENI */\n    static const uint8_t input1[] = { 0xE1, 0xBF, 0x81 };\n    static const uint8_t input2[] = { 0xC2, 0xA8, 0xCD, 0x82 };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* HANGUL SYLLABLE GEUL */\n    static const uint8_t input1[] = { 0xEA, 0xB8, 0x80 };\n    static const uint8_t input2[] = { 0xEA, 0xB7, 0xB8, 0xE1, 0x86, 0xAF };\n    static const uint8_t input3[] = { 0xE1, 0x84, 0x80, 0xE1, 0x85, 0xB3, 0xE1, 0x86, 0xAF };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input3, SIZEOF (input3), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* HANGUL SYLLABLE GEU */\n    static const uint8_t input1[] = { 0xEA, 0xB7, 0xB8 };\n    static const uint8_t input2[] = { 0xE1, 0x84, 0x80, 0xE1, 0x85, 0xB3 };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint8_t input1[] =\n      { 'G', 'r', 0xC3, 0xBC, 0xC3, 0x9F, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0xD0, 0x97, 0xD0, 0xB4, 0xD1, 0x80, 0xD0, 0xB0, 0xD0, 0xB2, 0xD1, 0x81,\n        0xD1, 0x82, 0xD0, 0xB2, 0xD1, 0x83, 0xD0, 0xB9, 0xD1, 0x82, 0xD0, 0xB5,\n        '!', ' ', 'x', '=', '(', '-', 'b', 0xC2, 0xB1, 's', 'q', 'r', 't', '(',\n        'b', 0xC2, 0xB2, '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')',\n        ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC, 0xE8, 0xAA, 0x9E, ',',\n        0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xED, 0x95, 0x9C, 0xEA, 0xB8, 0x80, '\\n'\n      };\n    static const uint8_t input2[] =\n      { 'g', 'r', 0xC3, 0xBC, 0x73, 0x73, ' ', 'g', 'o', 't', 't', '.', ' ',\n        0xD0, 0xB7, 0xD0, 0xB4, 0xD1, 0x80, 0xD0, 0xB0, 0xD0, 0xB2, 0xD1, 0x81,\n        0xD1, 0x82, 0xD0, 0xB2, 0xD1, 0x83, 0xD0, 0xB9, 0xD1, 0x82, 0xD0, 0xB5,\n        '!', ' ', 'x', '=', '(', '-', 'b', 0xC2, 0xB1, 's', 'q', 'r', 't', '(',\n        'b', 0xC2, 0xB2, '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')',\n        ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC, 0xE8, 0xAA, 0x9E, ',',\n        0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xED, 0x95, 0x9C, 0xEA, 0xB8, 0x80, '\\n'\n      };\n    static const uint8_t input3[] =\n      { 'G', 'R', 0xC3, 0x9C, 0x53, 0x53, ' ', 'G', 'O', 'T', 'T', '.', ' ',\n        0xD0, 0x97, 0xD0, 0x94, 0xD0, 0xA0, 0xD0, 0x90, 0xD0, 0x92, 0xD0, 0xA1,\n        0xD0, 0xA2, 0xD0, 0x92, 0xD0, 0xA3, 0xD0, 0x99, 0xD0, 0xA2, 0xD0, 0x95,\n        '!', ' ', 'X', '=', '(', '-', 'B', 0xC2, 0xB1, 'S', 'Q', 'R', 'T', '(',\n        'B', 0xC2, 0xB2, '-', '4', 'A', 'C', ')', ')', '/', '(', '2', 'A', ')',\n        ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC, 0xE8, 0xAA, 0x9E, ',',\n        0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xED, 0x95, 0x9C, 0xEA, 0xB8, 0x80, '\\n'\n      };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input3, SIZEOF (input3), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input3, SIZEOF (input3), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input2, SIZEOF (input2), input3, SIZEOF (input3), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input2, SIZEOF (input2), input3, SIZEOF (input3), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n\n  /* Case mapping can increase the number of Unicode characters.  */\n  { /* LATIN SMALL LETTER N PRECEDED BY APOSTROPHE */\n    static const uint8_t input1[] = { 0xC5, 0x89 };\n    static const uint8_t input2[] = { 0xCA, 0xBC, 0x6E };\n    static const uint8_t input3[] = { 0xCA, 0xBC, 0x4E };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input3, SIZEOF (input3), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input3, SIZEOF (input3), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS */\n    static const uint8_t input1[] = { 0xCE, 0x90 };\n    static const uint8_t input2[] = { 0xCE, 0xB9, 0xCC, 0x88, 0xCC, 0x81 };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n\n  /* Turkish letters i \u00c4\u00b0 \u00c4\u00b1 I */\n  { /* LATIN CAPITAL LETTER I */\n    static const uint8_t input[]         = { 0x49 };\n    static const uint8_t casefolded[]    = { 0x69 };\n    static const uint8_t casefolded_tr[] = { 0xC4, 0xB1 };\n    int cmp;\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded_tr, SIZEOF (casefolded_tr), \"tr\", NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* LATIN SMALL LETTER I */\n    static const uint8_t input[]         = { 0x69 };\n    static const uint8_t casefolded[]    = { 0x49 };\n    static const uint8_t casefolded_tr[] = { 0xC4, 0xB0 };\n    int cmp;\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded_tr, SIZEOF (casefolded_tr), \"tr\", NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* LATIN CAPITAL LETTER I WITH DOT ABOVE */\n    static const uint8_t input[]         = { 0xC4, 0xB0 };\n    static const uint8_t casefolded[]    = { 0x69, 0xCC, 0x87 };\n    static const uint8_t casefolded_tr[] = { 0x69 };\n    int cmp;\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded_tr, SIZEOF (casefolded_tr), \"tr\", NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* LATIN SMALL LETTER DOTLESS I */\n    static const uint8_t input[]      = { 0xC4, 0xB1 };\n    static const uint8_t casefolded[] = { 0x49 };\n    int cmp;\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 1);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), \"tr\", NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* \"topkap\u00c4\u00b1\" */\n    static const uint8_t input[] =\n      { 0x54, 0x4F, 0x50, 0x4B, 0x41, 0x50, 0x49 };\n    static const uint8_t casefolded[] =\n      { 0x74, 0x6F, 0x70, 0x6B, 0x61, 0x70, 0xC4, 0xB1 };\n    int cmp;\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), \"tr\", NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n\n  /* Uppercasing can increase the number of Unicode characters.  */\n  { /* \"hei\u00c3\u009f\" */\n    static const uint8_t input1[] = { 0x68, 0x65, 0x69, 0xC3, 0x9F };\n    static const uint8_t input2[] = { 0x68, 0x65, 0x69, 0x73, 0x73 };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n\n  /* Case mappings for some characters can depend on the surrounding characters.  */\n  { /* \"\u00cf\u0080\u00ce\u00b5\u00cf\u0081\u00ce\u00b9\u00cf\u0083\u00cf\u0083\u00cf\u008c\u00cf\u0084\u00ce\u00b5\u00cf\u0081\u00ce\u00b5\u00cf\u0082 \u00cf\u0080\u00ce\u00bb\u00ce\u00b7\u00cf\u0081\u00ce\u00bf\u00cf\u0086\u00ce\u00bf\u00cf\u0081\u00ce\u00af\u00ce\u00b5\u00cf\u0082\" */\n    static const uint8_t input1[] =\n      {\n        0xCF, 0x80, 0xCE, 0xB5, 0xCF, 0x81, 0xCE, 0xB9, 0xCF, 0x83, 0xCF, 0x83,\n        0xCF, 0x8C, 0xCF, 0x84, 0xCE, 0xB5, 0xCF, 0x81, 0xCE, 0xB5, 0xCF, 0x82,\n        ' ', 0xCF, 0x80, 0xCE, 0xBB, 0xCE, 0xB7, 0xCF, 0x81, 0xCE, 0xBF,\n        0xCF, 0x86, 0xCE, 0xBF, 0xCF, 0x81, 0xCE, 0xAF, 0xCE, 0xB5, 0xCF, 0x82\n      };\n    static const uint8_t input2[] =\n      {\n        0xCF, 0x80, 0xCE, 0xB5, 0xCF, 0x81, 0xCE, 0xB9, 0xCF, 0x83, 0xCF, 0x83,\n        0xCF, 0x8C, 0xCF, 0x84, 0xCE, 0xB5, 0xCF, 0x81, 0xCE, 0xB5, 0xCF, 0x83,\n        ' ', 0xCF, 0x80, 0xCE, 0xBB, 0xCE, 0xB7, 0xCF, 0x81, 0xCE, 0xBF,\n        0xCF, 0x86, 0xCE, 0xBF, 0xCF, 0x81, 0xCE, 0xAF, 0xCE, 0xB5, 0xCF, 0x83\n      };\n    static const uint8_t input3[] =\n      {\n        0xCE, 0xA0, 0xCE, 0x95, 0xCE, 0xA1, 0xCE, 0x99, 0xCE, 0xA3, 0xCE, 0xA3,\n        0xCE, 0x8C, 0xCE, 0xA4, 0xCE, 0x95, 0xCE, 0xA1, 0xCE, 0x95, 0xCE, 0xA3,\n        ' ', 0xCE, 0xA0, 0xCE, 0x9B, 0xCE, 0x97, 0xCE, 0xA1, 0xCE, 0x9F,\n        0xCE, 0xA6, 0xCE, 0x9F, 0xCE, 0xA1, 0xCE, 0x8A, 0xCE, 0x95, 0xCE, 0xA3\n      };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input3, SIZEOF (input3), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input2, SIZEOF (input2), input3, SIZEOF (input3), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n\n  /* Case mapping can require subsequent normalization.  */\n  { /* LATIN SMALL LETTER J WITH CARON, COMBINING DOT BELOW */\n    static const uint8_t input[]                 = { 0xC7, 0xB0, 0xCC, 0xA3 };\n    static const uint8_t casefolded[]            = { 0x6A, 0xCC, 0x8C, 0xCC, 0xA3 };\n    static const uint8_t casefolded_decomposed[] = { 0x6A, 0xCC, 0xA3, 0xCC, 0x8C };\n    int cmp;\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded_decomposed, SIZEOF (casefolded_decomposed), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp != 0);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded_decomposed, SIZEOF (casefolded_decomposed), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n}",
      "lines": 292,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        322,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "int\nmain ()\n{\n  test_ascii (u8_casecmp, UNINORM_NFD);\n  test_nonascii (u8_casecmp);\n\n  return 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u8-casecoll.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nmain ()\n{\n  /* In the \"C\" locale, strcoll is equivalent to strcmp, therefore u8_casecoll\n     on ASCII strings should behave like strcasecmp.  */\n  test_ascii (u8_casecoll, UNINORM_NFC);\n\n  return 0;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u8-casefold.c": {
    "check": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static int\ncheck (const uint8_t *input, size_t input_length,\n       const char *iso639_language, uninorm_t nf,\n       const uint8_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint8_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u8_casefold (input, input_length, iso639_language, nf, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u8_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint8_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint8_t *) malloc (length * sizeof (uint8_t));\n      result = u8_casefold (input, input_length, iso639_language, nf, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u8_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint8_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint8_t *) malloc (length * sizeof (uint8_t));\n    result = u8_casefold (input, input_length, iso639_language, nf, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u8_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "int\nmain ()\n{\n  { /* Empty string.  */\n    ASSERT (check (NULL, 0, NULL, NULL, NULL, 0) == 0);\n    ASSERT (check (NULL, 0, NULL, UNINORM_NFC, NULL, 0) == 0);\n  }\n\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint8_t input[] =\n      { 'G', 'r', 0xC3, 0xBC, 0xC3, 0x9F, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0xD0, 0x97, 0xD0, 0xB4, 0xD1, 0x80, 0xD0, 0xB0, 0xD0, 0xB2, 0xD1, 0x81,\n        0xD1, 0x82, 0xD0, 0xB2, 0xD1, 0x83, 0xD0, 0xB9, 0xD1, 0x82, 0xD0, 0xB5,\n        '!', ' ', 'x', '=', '(', '-', 'b', 0xC2, 0xB1, 's', 'q', 'r', 't', '(',\n        'b', 0xC2, 0xB2, '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')',\n        ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC, 0xE8, 0xAA, 0x9E, ',',\n        0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xED, 0x95, 0x9C, 0xEA, 0xB8, 0x80, '\\n'\n      };\n    static const uint8_t casefolded[] =\n      { 'g', 'r', 0xC3, 0xBC, 0x73, 0x73, ' ', 'g', 'o', 't', 't', '.', ' ',\n        0xD0, 0xB7, 0xD0, 0xB4, 0xD1, 0x80, 0xD0, 0xB0, 0xD0, 0xB2, 0xD1, 0x81,\n        0xD1, 0x82, 0xD0, 0xB2, 0xD1, 0x83, 0xD0, 0xB9, 0xD1, 0x82, 0xD0, 0xB5,\n        '!', ' ', 'x', '=', '(', '-', 'b', 0xC2, 0xB1, 's', 'q', 'r', 't', '(',\n        'b', 0xC2, 0xB2, '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')',\n        ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC, 0xE8, 0xAA, 0x9E, ',',\n        0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xED, 0x95, 0x9C, 0xEA, 0xB8, 0x80, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n  }\n\n  /* Case mapping can increase the number of Unicode characters.  */\n  { /* LATIN SMALL LETTER N PRECEDED BY APOSTROPHE */\n    static const uint8_t input[]      = { 0xC5, 0x89 };\n    static const uint8_t casefolded[] = { 0xCA, 0xBC, 0x6E };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n  }\n  { /* GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS */\n    static const uint8_t input[]      = { 0xCE, 0x90 };\n    static const uint8_t casefolded[] = { 0xCE, 0xB9, 0xCC, 0x88, 0xCC, 0x81 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n  }\n\n  /* Turkish letters i \u00c4\u00b0 \u00c4\u00b1 I */\n  { /* LATIN CAPITAL LETTER I */\n    static const uint8_t input[]         = { 0x49 };\n    static const uint8_t casefolded[]    = { 0x69 };\n    static const uint8_t casefolded_tr[] = { 0xC4, 0xB1 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casefolded_tr, SIZEOF (casefolded_tr)) == 0);\n  }\n  { /* LATIN SMALL LETTER I */\n    static const uint8_t input[]      = { 0x69 };\n    static const uint8_t casefolded[] = { 0x69 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casefolded, SIZEOF (casefolded)) == 0);\n  }\n  { /* LATIN CAPITAL LETTER I WITH DOT ABOVE */\n    static const uint8_t input[]         = { 0xC4, 0xB0 };\n    static const uint8_t casefolded[]    = { 0x69, 0xCC, 0x87 };\n    static const uint8_t casefolded_tr[] = { 0x69 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casefolded_tr, SIZEOF (casefolded_tr)) == 0);\n  }\n  { /* LATIN SMALL LETTER DOTLESS I */\n    static const uint8_t input[]      = { 0xC4, 0xB1 };\n    static const uint8_t casefolded[] = { 0xC4, 0xB1 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casefolded, SIZEOF (casefolded)) == 0);\n  }\n  { /* \"topkap\u00c4\u00b1\" */\n    static const uint8_t input[] =\n      { 0x74, 0x6F, 0x70, 0x6B, 0x61, 0x70, 0xC4, 0xB1 };\n    static const uint8_t casefolded[] =\n      { 0x74, 0x6F, 0x70, 0x6B, 0x61, 0x70, 0xC4, 0xB1 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casefolded, SIZEOF (casefolded)) == 0);\n  }\n\n  /* Uppercasing can increase the number of Unicode characters.  */\n  { /* \"hei\u00c3\u009f\" */\n    static const uint8_t input[]      = { 0x68, 0x65, 0x69, 0xC3, 0x9F };\n    static const uint8_t casefolded[] = { 0x68, 0x65, 0x69, 0x73, 0x73 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n  }\n\n  /* Case mappings for some characters can depend on the surrounding characters.  */\n  { /* \"\u00cf\u0080\u00ce\u00b5\u00cf\u0081\u00ce\u00b9\u00cf\u0083\u00cf\u0083\u00cf\u008c\u00cf\u0084\u00ce\u00b5\u00cf\u0081\u00ce\u00b5\u00cf\u0082 \u00cf\u0080\u00ce\u00bb\u00ce\u00b7\u00cf\u0081\u00ce\u00bf\u00cf\u0086\u00ce\u00bf\u00cf\u0081\u00ce\u00af\u00ce\u00b5\u00cf\u0082\" */\n    static const uint8_t input[] =\n      {\n        0xCF, 0x80, 0xCE, 0xB5, 0xCF, 0x81, 0xCE, 0xB9, 0xCF, 0x83, 0xCF, 0x83,\n        0xCF, 0x8C, 0xCF, 0x84, 0xCE, 0xB5, 0xCF, 0x81, 0xCE, 0xB5, 0xCF, 0x82,\n        ' ', 0xCF, 0x80, 0xCE, 0xBB, 0xCE, 0xB7, 0xCF, 0x81, 0xCE, 0xBF,\n        0xCF, 0x86, 0xCE, 0xBF, 0xCF, 0x81, 0xCE, 0xAF, 0xCE, 0xB5, 0xCF, 0x82\n      };\n    static const uint8_t casefolded[] =\n      {\n        0xCF, 0x80, 0xCE, 0xB5, 0xCF, 0x81, 0xCE, 0xB9, 0xCF, 0x83, 0xCF, 0x83,\n        0xCF, 0x8C, 0xCF, 0x84, 0xCE, 0xB5, 0xCF, 0x81, 0xCE, 0xB5, 0xCF, 0x83,\n        ' ', 0xCF, 0x80, 0xCE, 0xBB, 0xCE, 0xB7, 0xCF, 0x81, 0xCE, 0xBF,\n        0xCF, 0x86, 0xCE, 0xBF, 0xCF, 0x81, 0xCE, 0xAF, 0xCE, 0xB5, 0xCF, 0x83\n      };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casefolded, SIZEOF (casefolded)) == 0);\n  }\n\n  /* Case mapping can require subsequent normalization.  */\n  { /* LATIN SMALL LETTER J WITH CARON, COMBINING DOT BELOW */\n    static const uint8_t input[]                 = { 0xC7, 0xB0, 0xCC, 0xA3 };\n    static const uint8_t casefolded[]            = { 0x6A, 0xCC, 0x8C, 0xCC, 0xA3 };\n    static const uint8_t casefolded_decomposed[] = { 0x6A, 0xCC, 0xA3, 0xCC, 0x8C };\n    static const uint8_t casefolded_normalized[] = { 0xC7, 0xB0, 0xCC, 0xA3 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL,        casefolded, SIZEOF (casefolded)) == 0);\n    ASSERT (check (input, SIZEOF (input), NULL, UNINORM_NFD, casefolded_decomposed, SIZEOF (casefolded_decomposed)) == 0);\n    ASSERT (check (input, SIZEOF (input), NULL, UNINORM_NFC, casefolded_normalized, SIZEOF (casefolded_normalized)) == 0);\n  }\n\n  return 0;\n}",
      "lines": 120,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u8-is-cased.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "int\nmain ()\n{\n  test_ascii (u8_is_cased);\n\n  return 0;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u8-is-casefolded.c": {
    "test_nonascii": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "static void\ntest_nonascii (int (*my_is) (const uint8_t *, size_t, const char *, bool *))\n{\n  /* Test cases from Unicode 5.1.0.  */\n  {\n    static const uint8_t input[] = { 0xC3, 0x9F };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == false);\n  }\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nmain ()\n{\n  test_ascii (u8_is_casefolded);\n  test_nonascii (u8_is_casefolded);\n\n  return 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u8-is-lowercase.c": {
    "test_nonascii": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static void\ntest_nonascii (int (*my_is) (const uint8_t *, size_t, const char *, bool *))\n{\n  /* Test cases from Unicode 5.1.0.  */\n  {\n    static const uint8_t input[] = { 0xE2, 0x93, 0x97 };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const uint8_t input[] = { 0xE2, 0x92, 0xBD };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == false);\n  }\n  {\n    static const uint8_t input[] = { 0xCA, 0xB0 };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const uint8_t input[] = { 0xE1, 0x80, 0xB4 };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const uint8_t input[] = { 0xCA, 0xBD };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nmain ()\n{\n  test_ascii (u8_is_lowercase);\n  test_nonascii (u8_is_lowercase);\n\n  return 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u8-is-titlecase.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "int\nmain ()\n{\n  test_ascii (u8_is_titlecase);\n\n  return 0;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u8-is-uppercase.c": {
    "test_nonascii": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static void\ntest_nonascii (int (*my_is) (const uint8_t *, size_t, const char *, bool *))\n{\n  /* Test cases from Unicode 5.1.0.  */\n  {\n    static const uint8_t input[] = { 0xE2, 0x93, 0x97 };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == false);\n  }\n  {\n    static const uint8_t input[] = { 0xE2, 0x92, 0xBD };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const uint8_t input[] = { 0xCA, 0xB0 };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const uint8_t input[] = { 0xE1, 0x80, 0xB4 };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n  {\n    static const uint8_t input[] = { 0xCA, 0xBD };\n    bool result;\n\n    ASSERT (my_is (input, SIZEOF (input), NULL, &result) == 0);\n    ASSERT (result == true);\n  }\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nmain ()\n{\n  test_ascii (u8_is_uppercase);\n  test_nonascii (u8_is_uppercase);\n\n  return 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u8-tolower.c": {
    "check": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static int\ncheck (const uint8_t *input, size_t input_length,\n       const char *iso639_language, uninorm_t nf,\n       const uint8_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint8_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u8_tolower (input, input_length, iso639_language, nf, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u8_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint8_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint8_t *) malloc (length * sizeof (uint8_t));\n      result = u8_tolower (input, input_length, iso639_language, nf, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u8_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint8_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint8_t *) malloc (length * sizeof (uint8_t));\n    result = u8_tolower (input, input_length, iso639_language, nf, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u8_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "int\nmain ()\n{\n  { /* Empty string.  */\n    ASSERT (check (NULL, 0, NULL, NULL, NULL, 0) == 0);\n    ASSERT (check (NULL, 0, NULL, UNINORM_NFC, NULL, 0) == 0);\n  }\n\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint8_t input[] =\n      { 'G', 'r', 0xC3, 0xBC, 0xC3, 0x9F, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0xD0, 0x97, 0xD0, 0xB4, 0xD1, 0x80, 0xD0, 0xB0, 0xD0, 0xB2, 0xD1, 0x81,\n        0xD1, 0x82, 0xD0, 0xB2, 0xD1, 0x83, 0xD0, 0xB9, 0xD1, 0x82, 0xD0, 0xB5,\n        '!', ' ', 'x', '=', '(', '-', 'b', 0xC2, 0xB1, 's', 'q', 'r', 't', '(',\n        'b', 0xC2, 0xB2, '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')',\n        ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC, 0xE8, 0xAA, 0x9E, ',',\n        0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xED, 0x95, 0x9C, 0xEA, 0xB8, 0x80, '\\n'\n      };\n    static const uint8_t casemapped[] =\n      { 'g', 'r', 0xC3, 0xBC, 0xC3, 0x9F, ' ', 'g', 'o', 't', 't', '.', ' ',\n        0xD0, 0xB7, 0xD0, 0xB4, 0xD1, 0x80, 0xD0, 0xB0, 0xD0, 0xB2, 0xD1, 0x81,\n        0xD1, 0x82, 0xD0, 0xB2, 0xD1, 0x83, 0xD0, 0xB9, 0xD1, 0x82, 0xD0, 0xB5,\n        '!', ' ', 'x', '=', '(', '-', 'b', 0xC2, 0xB1, 's', 'q', 'r', 't', '(',\n        'b', 0xC2, 0xB2, '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')',\n        ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC, 0xE8, 0xAA, 0x9E, ',',\n        0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xED, 0x95, 0x9C, 0xEA, 0xB8, 0x80, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Turkish letters i \u00c4\u00b0 \u00c4\u00b1 I */\n  { /* LATIN CAPITAL LETTER I */\n    static const uint8_t input[]         = { 0x49 };\n    static const uint8_t casemapped[]    = { 0x69 };\n    static const uint8_t casemapped_tr[] = { 0xC4, 0xB1 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped_tr, SIZEOF (casemapped_tr)) == 0);\n  }\n  { /* LATIN SMALL LETTER I */\n    static const uint8_t input[]      = { 0x69 };\n    static const uint8_t casemapped[] = { 0x69 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* LATIN CAPITAL LETTER I WITH DOT ABOVE */\n    static const uint8_t input[]         = { 0xC4, 0xB0 };\n    static const uint8_t casemapped[]    = { 0x69, 0xCC, 0x87 };\n    static const uint8_t casemapped_tr[] = { 0x69 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped_tr, SIZEOF (casemapped_tr)) == 0);\n  }\n  { /* LATIN SMALL LETTER DOTLESS I */\n    static const uint8_t input[]      = { 0xC4, 0xB1};\n    static const uint8_t casemapped[] = { 0xC4, 0xB1 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"TOPKAPI\" */\n    static const uint8_t input[] =\n      { 0x54, 0x4F, 0x50, 0x4B, 0x41, 0x50, 0x49 };\n    static const uint8_t casemapped[] =\n      { 0x74, 0x6F, 0x70, 0x6B, 0x61, 0x70, 0xC4, 0xB1 };\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Uppercasing can increase the number of Unicode characters.  */\n  { /* \"HEI\u00c3\u009f\" */\n    static const uint8_t input[]      = { 0x48, 0x45, 0x49, 0xC3, 0x9F };\n    static const uint8_t casemapped[] = { 0x68, 0x65, 0x69, 0xC3, 0x9F };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Case mappings for some characters can depend on the surrounding characters.  */\n  { /* \"\u00ce\u00a0\u00ce\u0095\u00ce\u00a1\u00ce\u0099\u00ce\u00a3\u00ce\u00a3\u00ce\u008c\u00ce\u00a4\u00ce\u0095\u00ce\u00a1\u00ce\u0095\u00ce\u00a3 \u00ce\u00a0\u00ce\u009b\u00ce\u0097\u00ce\u00a1\u00ce\u009f\u00ce\u00a6\u00ce\u009f\u00ce\u00a1\u00ce\u008a\u00ce\u0095\u00ce\u00a3\" */\n    static const uint8_t input[] =\n      {\n        0xCE, 0xA0, 0xCE, 0x95, 0xCE, 0xA1, 0xCE, 0x99, 0xCE, 0xA3, 0xCE, 0xA3,\n        0xCE, 0x8C, 0xCE, 0xA4, 0xCE, 0x95, 0xCE, 0xA1, 0xCE, 0x95, 0xCE, 0xA3,\n        ' ', 0xCE, 0xA0, 0xCE, 0x9B, 0xCE, 0x97, 0xCE, 0xA1, 0xCE, 0x9F,\n        0xCE, 0xA6, 0xCE, 0x9F, 0xCE, 0xA1, 0xCE, 0x8A, 0xCE, 0x95, 0xCE, 0xA3\n      };\n    static const uint8_t casemapped[] =\n      {\n        0xCF, 0x80, 0xCE, 0xB5, 0xCF, 0x81, 0xCE, 0xB9, 0xCF, 0x83, 0xCF, 0x83,\n        0xCF, 0x8C, 0xCF, 0x84, 0xCE, 0xB5, 0xCF, 0x81, 0xCE, 0xB5, 0xCF, 0x82,\n        ' ', 0xCF, 0x80, 0xCE, 0xBB, 0xCE, 0xB7, 0xCF, 0x81, 0xCE, 0xBF,\n        0xCF, 0x86, 0xCE, 0xBF, 0xCF, 0x81, 0xCE, 0xAF, 0xCE, 0xB5, 0xCF, 0x82\n      };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"\u00ce\u00a3\" -> \"\u00cf\u0083\" */\n    static const uint8_t input[] =      { 0xCE, 0xA3 };\n    static const uint8_t casemapped[] = { 0xCF, 0x83 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"\u00ce\u0091\u00ce\u00a3\" -> \"\u00ce\u00b1\u00cf\u0082\" */\n    static const uint8_t input[] =      { 0xCE, 0x91, 0xCE, 0xA3 };\n    static const uint8_t casemapped[] = { 0xCE, 0xB1, 0xCF, 0x82 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  /* It's a final sigma only if not followed by a case-ignorable sequence and\n     then a cased letter.  Note that U+0345 and U+037A are simultaneously\n     case-ignorable and cased (which is a bit paradoxical).  */\n  { /* \"\u00ce\u0091\u00ce\u00a3\u00ce\u0091\" -> \"\u00ce\u00b1\u00cf\u0083\u00ce\u00b1\" */\n    static const uint8_t input[] =      { 0xCE, 0x91, 0xCE, 0xA3, 0xCE, 0x91 };\n    static const uint8_t casemapped[] = { 0xCE, 0xB1, 0xCF, 0x83, 0xCE, 0xB1 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"\u00ce\u0091\u00ce\u00a3:\" -> \"\u00ce\u00b1\u00cf\u0082:\" */\n    static const uint8_t input[] =      { 0xCE, 0x91, 0xCE, 0xA3, 0x3A };\n    static const uint8_t casemapped[] = { 0xCE, 0xB1, 0xCF, 0x82, 0x3A };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"\u00ce\u0091\u00ce\u00a3:\u00ce\u0091\" -> \"\u00ce\u00b1\u00cf\u0083:\u00ce\u00b1\" */\n    static const uint8_t input[] =      { 0xCE, 0x91, 0xCE, 0xA3, 0x3A, 0xCE, 0x91 };\n    static const uint8_t casemapped[] = { 0xCE, 0xB1, 0xCF, 0x83, 0x3A, 0xCE, 0xB1 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"\u00ce\u0091\u00ce\u00a3:\u00cd\u00ba\" -> \"\u00ce\u00b1\u00cf\u0083:\u00cd\u00ba\" */\n    static const uint8_t input[] =      { 0xCE, 0x91, 0xCE, 0xA3, 0x3A, 0xCD, 0xBA };\n    static const uint8_t casemapped[] = { 0xCE, 0xB1, 0xCF, 0x83, 0x3A, 0xCD, 0xBA };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"\u00ce\u0091\u00ce\u00a3:\u00cd\u00ba \" -> \"\u00ce\u00b1\u00cf\u0083:\u00cd\u00ba \" */\n    static const uint8_t input[] =      { 0xCE, 0x91, 0xCE, 0xA3, 0x3A, 0xCD, 0xBA, 0x20 };\n    static const uint8_t casemapped[] = { 0xCE, 0xB1, 0xCF, 0x83, 0x3A, 0xCD, 0xBA, 0x20 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  /* It's a final sigma only if preceded by a case-ignorable sequence and\n     a cased letter before it.  Note that U+0345 and U+037A are simultaneously\n     case-ignorable and cased (which is a bit paradoxical).  */\n  { /* \":\u00ce\u00a3\" -> \":\u00cf\u0083\" */\n    static const uint8_t input[] =      { 0x3A, 0xCE, 0xA3 };\n    static const uint8_t casemapped[] = { 0x3A, 0xCF, 0x83 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"\u00ce\u0091:\u00ce\u00a3\" -> \"\u00ce\u00b1:\u00cf\u0082\" */\n    static const uint8_t input[] =      { 0xCE, 0x91, 0x3A, 0xCE, 0xA3 };\n    static const uint8_t casemapped[] = { 0xCE, 0xB1, 0x3A, 0xCF, 0x82 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"\u00cd\u00ba:\u00ce\u00a3\" -> \"\u00cd\u00ba:\u00cf\u0082\" */\n    static const uint8_t input[] =      { 0xCD, 0xBA, 0x3A, 0xCE, 0xA3 };\n    static const uint8_t casemapped[] = { 0xCD, 0xBA, 0x3A, 0xCF, 0x82 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \" \u00cd\u00ba:\u00ce\u00a3\" -> \" \u00cd\u00ba:\u00cf\u0082\" */\n    static const uint8_t input[] =      { 0x20, 0xCD, 0xBA, 0x3A, 0xCE, 0xA3 };\n    static const uint8_t casemapped[] = { 0x20, 0xCD, 0xBA, 0x3A, 0xCF, 0x82 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  return 0;\n}",
      "lines": 157,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u8-totitle.c": {
    "check": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static int\ncheck (const uint8_t *input, size_t input_length,\n       const char *iso639_language, uninorm_t nf,\n       const uint8_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint8_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u8_totitle (input, input_length, iso639_language, nf, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u8_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint8_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint8_t *) malloc (length * sizeof (uint8_t));\n      result = u8_totitle (input, input_length, iso639_language, nf, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u8_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint8_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint8_t *) malloc (length * sizeof (uint8_t));\n    result = u8_totitle (input, input_length, iso639_language, nf, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u8_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "int\nmain ()\n{\n  { /* Empty string.  */\n    ASSERT (check (NULL, 0, NULL, NULL, NULL, 0) == 0);\n    ASSERT (check (NULL, 0, NULL, UNINORM_NFC, NULL, 0) == 0);\n  }\n\n  /* Simple string.  */\n  { /* \"GR\u00c3\u009c\u00c3\u009f GOTT. \u00d0\u0097\u00d0\u0094\u00d0\u00a0\u00d0\u0090\u00d0\u0092\u00d0\u00a1\u00d0\u00a2\u00d0\u0092\u00d0\u00a3\u00d0\u0099\u00d0\u00a2\u00d0\u0095! X=(-B\u00c2\u00b1SQRT(B\u00c2\u00b2-4AC))/(2A)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint8_t input[] =\n      { 'G', 'R', 0xC3, 0x9C, 0xC3, 0x9F, ' ', 'G', 'O', 'T', 'T', '.', ' ',\n        0xD0, 0x97, 0xD0, 0x94, 0xD0, 0xA0, 0xD0, 0x90, 0xD0, 0x92, 0xD0, 0xA1,\n        0xD0, 0xA2, 0xD0, 0x92, 0xD0, 0xA3, 0xD0, 0x99, 0xD0, 0xA2, 0xD0, 0x95,\n        '!', ' ', 'X', '=', '(', '-', 'B', 0xC2, 0xB1, 'S', 'Q', 'R', 'T', '(',\n        'B', 0xC2, 0xB2, '-', '4', 'A', 'C', ')', ')', '/', '(', '2', 'A', ')',\n        ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC, 0xE8, 0xAA, 0x9E, ',',\n        0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xED, 0x95, 0x9C, 0xEA, 0xB8, 0x80, '\\n'\n      };\n    static const uint8_t casemapped[] =\n      { 'G', 'r', 0xC3, 0xBC, 0xC3, 0x9F, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0xD0, 0x97, 0xD0, 0xB4, 0xD1, 0x80, 0xD0, 0xB0, 0xD0, 0xB2, 0xD1, 0x81,\n        0xD1, 0x82, 0xD0, 0xB2, 0xD1, 0x83, 0xD0, 0xB9, 0xD1, 0x82, 0xD0, 0xB5,\n        '!', ' ', 'X', '=', '(', '-', 'B', 0xC2, 0xB1, 'S', 'q', 'r', 't', '(',\n        'B', 0xC2, 0xB2, '-', '4', 'A', 'c', ')', ')', '/', '(', '2', 'A', ')',\n        ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC, 0xE8, 0xAA, 0x9E, ',',\n        0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xED, 0x95, 0x9C, 0xEA, 0xB8, 0x80, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Case mapping can increase the number of Unicode characters.  */\n  { /* LATIN SMALL LETTER N PRECEDED BY APOSTROPHE */\n    static const uint8_t input[]      = { 0xC5, 0x89 };\n    static const uint8_t casemapped[] = { 0xCA, 0xBC, 0x4E };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS */\n    static const uint8_t input[]      = { 0xCE, 0x90 };\n    static const uint8_t casemapped[] = { 0xCE, 0x99, 0xCC, 0x88, 0xCC, 0x81 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Turkish letters i \u00c4\u00b0 \u00c4\u00b1 I */\n  { /* LATIN CAPITAL LETTER I */\n    static const uint8_t input[]      = { 0x49 };\n    static const uint8_t casemapped[] = { 0x49 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* LATIN SMALL LETTER I */\n    static const uint8_t input[]         = { 0x69 };\n    static const uint8_t casemapped[]    = { 0x49 };\n    static const uint8_t casemapped_tr[] = { 0xC4, 0xB0 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped_tr, SIZEOF (casemapped_tr)) == 0);\n  }\n  { /* LATIN CAPITAL LETTER I WITH DOT ABOVE */\n    static const uint8_t input[]      = { 0xC4, 0xB0 };\n    static const uint8_t casemapped[] = { 0xC4, 0xB0 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* LATIN SMALL LETTER DOTLESS I */\n    static const uint8_t input[]      = { 0xC4, 0xB1 };\n    static const uint8_t casemapped[] = { 0x49 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"topkap\u00c4\u00b1\" */\n    static const uint8_t input[] =\n      { 0x74, 0x6F, 0x70, 0x6B, 0x61, 0x70, 0xC4, 0xB1 };\n    static const uint8_t casemapped[] =\n      { 0x54, 0x6F, 0x70, 0x6B, 0x61, 0x70, 0xC4, 0xB1 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Uppercasing can increase the number of Unicode characters.  */\n  { /* \"hei\u00c3\u009f\" */\n    static const uint8_t input[]      = { 0x68, 0x65, 0x69, 0xC3, 0x9F };\n    static const uint8_t casemapped[] = { 0x48, 0x65, 0x69, 0xC3, 0x9F };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Case mappings for some characters can depend on the surrounding characters.  */\n  { /* \"\u00cf\u0080\u00ce\u00b5\u00cf\u0081\u00ce\u00b9\u00cf\u0083\u00cf\u0083\u00cf\u008c\u00cf\u0084\u00ce\u00b5\u00cf\u0081\u00ce\u00b5\u00cf\u0082 \u00cf\u0080\u00ce\u00bb\u00ce\u00b7\u00cf\u0081\u00ce\u00bf\u00cf\u0086\u00ce\u00bf\u00cf\u0081\u00ce\u00af\u00ce\u00b5\u00cf\u0082\" */\n    static const uint8_t input[] =\n      {\n        0xCF, 0x80, 0xCE, 0xB5, 0xCF, 0x81, 0xCE, 0xB9, 0xCF, 0x83, 0xCF, 0x83,\n        0xCF, 0x8C, 0xCF, 0x84, 0xCE, 0xB5, 0xCF, 0x81, 0xCE, 0xB5, 0xCF, 0x82,\n        ' ', 0xCF, 0x80, 0xCE, 0xBB, 0xCE, 0xB7, 0xCF, 0x81, 0xCE, 0xBF,\n        0xCF, 0x86, 0xCE, 0xBF, 0xCF, 0x81, 0xCE, 0xAF, 0xCE, 0xB5, 0xCF, 0x82\n      };\n    static const uint8_t casemapped[] =\n      {\n        0xCE, 0xA0, 0xCE, 0xB5, 0xCF, 0x81, 0xCE, 0xB9, 0xCF, 0x83, 0xCF, 0x83,\n        0xCF, 0x8C, 0xCF, 0x84, 0xCE, 0xB5, 0xCF, 0x81, 0xCE, 0xB5, 0xCF, 0x82,\n        ' ', 0xCE, 0xA0, 0xCE, 0xBB, 0xCE, 0xB7, 0xCF, 0x81, 0xCE, 0xBF,\n        0xCF, 0x86, 0xCE, 0xBF, 0xCF, 0x81, 0xCE, 0xAF, 0xCE, 0xB5, 0xCF, 0x82\n      };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Case mapping can require subsequent normalization.  */\n  { /* LATIN SMALL LETTER J WITH CARON, COMBINING DOT BELOW */\n    static const uint8_t input[]                 = { 0xC7, 0xB0, 0xCC, 0xA3 };\n    static const uint8_t casemapped[]            = { 0x4A, 0xCC, 0x8C, 0xCC, 0xA3 };\n    static const uint8_t casemapped_normalized[] = { 0x4A, 0xCC, 0xA3, 0xCC, 0x8C };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL,        casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), NULL, UNINORM_NFC, casemapped_normalized, SIZEOF (casemapped_normalized)) == 0);\n  }\n\n  return 0;\n}",
      "lines": 117,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-u8-toupper.c": {
    "check": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static int\ncheck (const uint8_t *input, size_t input_length,\n       const char *iso639_language, uninorm_t nf,\n       const uint8_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint8_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u8_toupper (input, input_length, iso639_language, nf, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u8_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint8_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint8_t *) malloc (length * sizeof (uint8_t));\n      result = u8_toupper (input, input_length, iso639_language, nf, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u8_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint8_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint8_t *) malloc (length * sizeof (uint8_t));\n    result = u8_toupper (input, input_length, iso639_language, nf, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u8_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "int\nmain ()\n{\n  { /* Empty string.  */\n    ASSERT (check (NULL, 0, NULL, NULL, NULL, 0) == 0);\n    ASSERT (check (NULL, 0, NULL, UNINORM_NFC, NULL, 0) == 0);\n  }\n\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint8_t input[] =\n      { 'G', 'r', 0xC3, 0xBC, 0xC3, 0x9F, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0xD0, 0x97, 0xD0, 0xB4, 0xD1, 0x80, 0xD0, 0xB0, 0xD0, 0xB2, 0xD1, 0x81,\n        0xD1, 0x82, 0xD0, 0xB2, 0xD1, 0x83, 0xD0, 0xB9, 0xD1, 0x82, 0xD0, 0xB5,\n        '!', ' ', 'x', '=', '(', '-', 'b', 0xC2, 0xB1, 's', 'q', 'r', 't', '(',\n        'b', 0xC2, 0xB2, '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')',\n        ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC, 0xE8, 0xAA, 0x9E, ',',\n        0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xED, 0x95, 0x9C, 0xEA, 0xB8, 0x80, '\\n'\n      };\n    static const uint8_t casemapped[] =\n      { 'G', 'R', 0xC3, 0x9C, 0x53, 0x53, ' ', 'G', 'O', 'T', 'T', '.', ' ',\n        0xD0, 0x97, 0xD0, 0x94, 0xD0, 0xA0, 0xD0, 0x90, 0xD0, 0x92, 0xD0, 0xA1,\n        0xD0, 0xA2, 0xD0, 0x92, 0xD0, 0xA3, 0xD0, 0x99, 0xD0, 0xA2, 0xD0, 0x95,\n        '!', ' ', 'X', '=', '(', '-', 'B', 0xC2, 0xB1, 'S', 'Q', 'R', 'T', '(',\n        'B', 0xC2, 0xB2, '-', '4', 'A', 'C', ')', ')', '/', '(', '2', 'A', ')',\n        ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC, 0xE8, 0xAA, 0x9E, ',',\n        0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xED, 0x95, 0x9C, 0xEA, 0xB8, 0x80, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Case mapping can increase the number of Unicode characters.  */\n  { /* LATIN SMALL LETTER N PRECEDED BY APOSTROPHE */\n    static const uint8_t input[]      = { 0xC5, 0x89 };\n    static const uint8_t casemapped[] = { 0xCA, 0xBC, 0x4E };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS */\n    static const uint8_t input[]      = { 0xCE, 0x90 };\n    static const uint8_t casemapped[] = { 0xCE, 0x99, 0xCC, 0x88, 0xCC, 0x81 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Turkish letters i \u00c4\u00b0 \u00c4\u00b1 I */\n  { /* LATIN CAPITAL LETTER I */\n    static const uint8_t input[]      = { 0x49 };\n    static const uint8_t casemapped[] = { 0x49 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* LATIN SMALL LETTER I */\n    static const uint8_t input[]         = { 0x69 };\n    static const uint8_t casemapped[]    = { 0x49 };\n    static const uint8_t casemapped_tr[] = { 0xC4, 0xB0 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped_tr, SIZEOF (casemapped_tr)) == 0);\n  }\n  { /* LATIN CAPITAL LETTER I WITH DOT ABOVE */\n    static const uint8_t input[]      = { 0xC4, 0xB0 };\n    static const uint8_t casemapped[] = { 0xC4, 0xB0 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* LATIN SMALL LETTER DOTLESS I */\n    static const uint8_t input[]      = { 0xC4, 0xB1 };\n    static const uint8_t casemapped[] = { 0x49 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n  { /* \"topkap\u00c4\u00b1\" */\n    static const uint8_t input[] =\n      { 0x74, 0x6F, 0x70, 0x6B, 0x61, 0x70, 0xC4, 0xB1 };\n    static const uint8_t casemapped[] =\n      { 0x54, 0x4F, 0x50, 0x4B, 0x41, 0x50, 0x49 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), \"tr\", NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Uppercasing can increase the number of Unicode characters.  */\n  { /* \"hei\u00c3\u009f\" */\n    static const uint8_t input[]      = { 0x68, 0x65, 0x69, 0xC3, 0x9F };\n    static const uint8_t casemapped[] = { 0x48, 0x45, 0x49, 0x53, 0x53 };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Case mappings for some characters can depend on the surrounding characters.  */\n  { /* \"\u00cf\u0080\u00ce\u00b5\u00cf\u0081\u00ce\u00b9\u00cf\u0083\u00cf\u0083\u00cf\u008c\u00cf\u0084\u00ce\u00b5\u00cf\u0081\u00ce\u00b5\u00cf\u0082 \u00cf\u0080\u00ce\u00bb\u00ce\u00b7\u00cf\u0081\u00ce\u00bf\u00cf\u0086\u00ce\u00bf\u00cf\u0081\u00ce\u00af\u00ce\u00b5\u00cf\u0082\" */\n    static const uint8_t input[] =\n      {\n        0xCF, 0x80, 0xCE, 0xB5, 0xCF, 0x81, 0xCE, 0xB9, 0xCF, 0x83, 0xCF, 0x83,\n        0xCF, 0x8C, 0xCF, 0x84, 0xCE, 0xB5, 0xCF, 0x81, 0xCE, 0xB5, 0xCF, 0x82,\n        ' ', 0xCF, 0x80, 0xCE, 0xBB, 0xCE, 0xB7, 0xCF, 0x81, 0xCE, 0xBF,\n        0xCF, 0x86, 0xCE, 0xBF, 0xCF, 0x81, 0xCE, 0xAF, 0xCE, 0xB5, 0xCF, 0x82\n      };\n    static const uint8_t casemapped[] =\n      {\n        0xCE, 0xA0, 0xCE, 0x95, 0xCE, 0xA1, 0xCE, 0x99, 0xCE, 0xA3, 0xCE, 0xA3,\n        0xCE, 0x8C, 0xCE, 0xA4, 0xCE, 0x95, 0xCE, 0xA1, 0xCE, 0x95, 0xCE, 0xA3,\n        ' ', 0xCE, 0xA0, 0xCE, 0x9B, 0xCE, 0x97, 0xCE, 0xA1, 0xCE, 0x9F,\n        0xCE, 0xA6, 0xCE, 0x9F, 0xCE, 0xA1, 0xCE, 0x8A, 0xCE, 0x95, 0xCE, 0xA3\n      };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL, casemapped, SIZEOF (casemapped)) == 0);\n  }\n\n  /* Case mapping can require subsequent normalization.  */\n  { /* LATIN SMALL LETTER J WITH CARON, COMBINING DOT BELOW */\n    static const uint8_t input[]                 = { 0xC7, 0xB0, 0xCC, 0xA3 };\n    static const uint8_t casemapped[]            = { 0x4A, 0xCC, 0x8C, 0xCC, 0xA3 };\n    static const uint8_t casemapped_normalized[] = { 0x4A, 0xCC, 0xA3, 0xCC, 0x8C };\n    ASSERT (check (input, SIZEOF (input), NULL, NULL,        casemapped, SIZEOF (casemapped)) == 0);\n    ASSERT (check (input, SIZEOF (input), NULL, UNINORM_NFC, casemapped_normalized, SIZEOF (casemapped_normalized)) == 0);\n  }\n\n  return 0;\n}",
      "lines": 117,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-uc_tolower.c": {},
  "libunistring/libunistring-0.9.10/tests/unicase/test-uc_totitle.c": {},
  "libunistring/libunistring-0.9.10/tests/unicase/test-uc_toupper.c": {},
  "libunistring/libunistring-0.9.10/tests/unicase/test-ulc-casecmp.c": {
    "test_iso_8859_1": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static void\ntest_iso_8859_1 (int (*my_casecmp) (const char *, size_t, const char *, size_t, const char *, uninorm_t, int *))\n{\n  {\n    static const char input1[] = { 'H', 0xF6, 'h', 'l', 'e' };\n    static const char input2[] = { 'H', 0xD6, 'h', 'L', 'e' };\n    static const char input3[] = { 'H', 0xF6, 'h', 'l', 'e', 'n' };\n    static const char input4[] = { 'H', 0xD6, 'h', 'L', 'e', 'n' };\n    static const char input5[] = { 'H', 'u', 'r', 'z' };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input2, SIZEOF (input2), input1, SIZEOF (input1), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input3, SIZEOF (input3), input4, SIZEOF (input4), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input4, SIZEOF (input4), input3, SIZEOF (input3), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input2, SIZEOF (input2), input3, SIZEOF (input3), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input4, SIZEOF (input4), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input5, SIZEOF (input5), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_casecmp (input2, SIZEOF (input2), input5, SIZEOF (input5), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n  }\n\n  /* Uppercasing can increase the number of Unicode characters.  */\n  { /* \"hei\u00c3\u009f\" */\n    static const char input1[] = { 0x68, 0x65, 0x69, 0xDF };\n    static const char input2[] = { 0x68, 0x65, 0x69, 0x73, 0x73 };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n}",
      "lines": 46,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_utf_8": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        367,
        1
      ],
      "content": "static void\ntest_utf_8 (int (*my_casecmp) (const char *, size_t, const char *, size_t, const char *, uninorm_t, int *))\n{\n  /* Normalization effects.  */\n  {\n    static const char input1[] = { 'H', 0xC3, 0xB6, 'h', 'l', 'e' };\n    static const char input2[] = { 'H', 'O', 0xCC, 0x88, 'h', 'L', 'e' };\n    static const char input3[] = { 'H', 0xC3, 0xB6, 'h', 'l', 'e', 'n' };\n    static const char input4[] = { 'H', 'O', 0xCC, 0x88, 'h', 'L', 'e', 'n' };\n    static const char input5[] = { 'H', 'u', 'r', 'z' };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input2, SIZEOF (input2), input1, SIZEOF (input1), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input3, SIZEOF (input3), input4, SIZEOF (input4), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input4, SIZEOF (input4), input3, SIZEOF (input3), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input2, SIZEOF (input2), input3, SIZEOF (input3), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input4, SIZEOF (input4), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input5, SIZEOF (input5), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_casecmp (input2, SIZEOF (input2), input5, SIZEOF (input5), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n  }\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS */\n    static const char input1[] = { 0xC3, 0x84 };\n    static const char input2[] = { 0x41, 0xCC, 0x88 };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON */\n    static const char input1[] = { 0xC7, 0x9E };\n    static const char input2[] = { 0x41, 0xCC, 0x88, 0xCC, 0x84 };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* GREEK DIALYTIKA AND PERISPOMENI */\n    static const char input1[] = { 0xE1, 0xBF, 0x81 };\n    static const char input2[] = { 0xC2, 0xA8, 0xCD, 0x82 };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* HANGUL SYLLABLE GEUL */\n    static const char input1[] = { 0xEA, 0xB8, 0x80 };\n    static const char input2[] = { 0xEA, 0xB7, 0xB8, 0xE1, 0x86, 0xAF };\n    static const char input3[] = { 0xE1, 0x84, 0x80, 0xE1, 0x85, 0xB3, 0xE1, 0x86, 0xAF };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input3, SIZEOF (input3), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* HANGUL SYLLABLE GEU */\n    static const char input1[] = { 0xEA, 0xB7, 0xB8 };\n    static const char input2[] = { 0xE1, 0x84, 0x80, 0xE1, 0x85, 0xB3 };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const char input1[] =\n      { 'G', 'r', 0xC3, 0xBC, 0xC3, 0x9F, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0xD0, 0x97, 0xD0, 0xB4, 0xD1, 0x80, 0xD0, 0xB0, 0xD0, 0xB2, 0xD1, 0x81,\n        0xD1, 0x82, 0xD0, 0xB2, 0xD1, 0x83, 0xD0, 0xB9, 0xD1, 0x82, 0xD0, 0xB5,\n        '!', ' ', 'x', '=', '(', '-', 'b', 0xC2, 0xB1, 's', 'q', 'r', 't', '(',\n        'b', 0xC2, 0xB2, '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')',\n        ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC, 0xE8, 0xAA, 0x9E, ',',\n        0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xED, 0x95, 0x9C, 0xEA, 0xB8, 0x80, '\\n'\n      };\n    static const char input2[] =\n      { 'g', 'r', 0xC3, 0xBC, 0x73, 0x73, ' ', 'g', 'o', 't', 't', '.', ' ',\n        0xD0, 0xB7, 0xD0, 0xB4, 0xD1, 0x80, 0xD0, 0xB0, 0xD0, 0xB2, 0xD1, 0x81,\n        0xD1, 0x82, 0xD0, 0xB2, 0xD1, 0x83, 0xD0, 0xB9, 0xD1, 0x82, 0xD0, 0xB5,\n        '!', ' ', 'x', '=', '(', '-', 'b', 0xC2, 0xB1, 's', 'q', 'r', 't', '(',\n        'b', 0xC2, 0xB2, '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')',\n        ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC, 0xE8, 0xAA, 0x9E, ',',\n        0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xED, 0x95, 0x9C, 0xEA, 0xB8, 0x80, '\\n'\n      };\n    static const char input3[] =\n      { 'G', 'R', 0xC3, 0x9C, 0x53, 0x53, ' ', 'G', 'O', 'T', 'T', '.', ' ',\n        0xD0, 0x97, 0xD0, 0x94, 0xD0, 0xA0, 0xD0, 0x90, 0xD0, 0x92, 0xD0, 0xA1,\n        0xD0, 0xA2, 0xD0, 0x92, 0xD0, 0xA3, 0xD0, 0x99, 0xD0, 0xA2, 0xD0, 0x95,\n        '!', ' ', 'X', '=', '(', '-', 'B', 0xC2, 0xB1, 'S', 'Q', 'R', 'T', '(',\n        'B', 0xC2, 0xB2, '-', '4', 'A', 'C', ')', ')', '/', '(', '2', 'A', ')',\n        ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC, 0xE8, 0xAA, 0x9E, ',',\n        0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xED, 0x95, 0x9C, 0xEA, 0xB8, 0x80, '\\n'\n      };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input3, SIZEOF (input3), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input3, SIZEOF (input3), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input2, SIZEOF (input2), input3, SIZEOF (input3), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input2, SIZEOF (input2), input3, SIZEOF (input3), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n\n  /* Case mapping can increase the number of Unicode characters.  */\n  { /* LATIN SMALL LETTER N PRECEDED BY APOSTROPHE */\n    static const char input1[] = { 0xC5, 0x89 };\n    static const char input2[] = { 0xCA, 0xBC, 0x6E };\n    static const char input3[] = { 0xCA, 0xBC, 0x4E };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input3, SIZEOF (input3), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input3, SIZEOF (input3), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS */\n    static const char input1[] = { 0xCE, 0x90 };\n    static const char input2[] = { 0xCE, 0xB9, 0xCC, 0x88, 0xCC, 0x81 };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n\n  /* Turkish letters i \u00c4\u00b0 \u00c4\u00b1 I */\n  { /* LATIN CAPITAL LETTER I */\n    static const char input[]         = { 0x49 };\n    static const char casefolded[]    = { 0x69 };\n    static const char casefolded_tr[] = { 0xC4, 0xB1 };\n    int cmp;\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded_tr, SIZEOF (casefolded_tr), \"tr\", NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* LATIN SMALL LETTER I */\n    static const char input[]         = { 0x69 };\n    static const char casefolded[]    = { 0x49 };\n    static const char casefolded_tr[] = { 0xC4, 0xB0 };\n    int cmp;\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded_tr, SIZEOF (casefolded_tr), \"tr\", NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* LATIN CAPITAL LETTER I WITH DOT ABOVE */\n    static const char input[]         = { 0xC4, 0xB0 };\n    static const char casefolded[]    = { 0x69, 0xCC, 0x87 };\n    static const char casefolded_tr[] = { 0x69 };\n    int cmp;\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded_tr, SIZEOF (casefolded_tr), \"tr\", NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* LATIN SMALL LETTER DOTLESS I */\n    static const char input[]      = { 0xC4, 0xB1 };\n    static const char casefolded[] = { 0x49 };\n    int cmp;\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 1);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), \"tr\", NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* \"topkap\u00c4\u00b1\" */\n    static const char input[] =\n      { 0x54, 0x4F, 0x50, 0x4B, 0x41, 0x50, 0x49 };\n    static const char casefolded[] =\n      { 0x74, 0x6F, 0x70, 0x6B, 0x61, 0x70, 0xC4, 0xB1 };\n    int cmp;\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), \"tr\", NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n\n  /* Uppercasing can increase the number of Unicode characters.  */\n  { /* \"hei\u00c3\u009f\" */\n    static const char input1[] = { 0x68, 0x65, 0x69, 0xC3, 0x9F };\n    static const char input2[] = { 0x68, 0x65, 0x69, 0x73, 0x73 };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n\n  /* Case mappings for some characters can depend on the surrounding characters.  */\n  { /* \"\u00cf\u0080\u00ce\u00b5\u00cf\u0081\u00ce\u00b9\u00cf\u0083\u00cf\u0083\u00cf\u008c\u00cf\u0084\u00ce\u00b5\u00cf\u0081\u00ce\u00b5\u00cf\u0082 \u00cf\u0080\u00ce\u00bb\u00ce\u00b7\u00cf\u0081\u00ce\u00bf\u00cf\u0086\u00ce\u00bf\u00cf\u0081\u00ce\u00af\u00ce\u00b5\u00cf\u0082\" */\n    static const char input1[] =\n      {\n        0xCF, 0x80, 0xCE, 0xB5, 0xCF, 0x81, 0xCE, 0xB9, 0xCF, 0x83, 0xCF, 0x83,\n        0xCF, 0x8C, 0xCF, 0x84, 0xCE, 0xB5, 0xCF, 0x81, 0xCE, 0xB5, 0xCF, 0x82,\n        ' ', 0xCF, 0x80, 0xCE, 0xBB, 0xCE, 0xB7, 0xCF, 0x81, 0xCE, 0xBF,\n        0xCF, 0x86, 0xCE, 0xBF, 0xCF, 0x81, 0xCE, 0xAF, 0xCE, 0xB5, 0xCF, 0x82\n      };\n    static const char input2[] =\n      {\n        0xCF, 0x80, 0xCE, 0xB5, 0xCF, 0x81, 0xCE, 0xB9, 0xCF, 0x83, 0xCF, 0x83,\n        0xCF, 0x8C, 0xCF, 0x84, 0xCE, 0xB5, 0xCF, 0x81, 0xCE, 0xB5, 0xCF, 0x83,\n        ' ', 0xCF, 0x80, 0xCE, 0xBB, 0xCE, 0xB7, 0xCF, 0x81, 0xCE, 0xBF,\n        0xCF, 0x86, 0xCE, 0xBF, 0xCF, 0x81, 0xCE, 0xAF, 0xCE, 0xB5, 0xCF, 0x83\n      };\n    static const char input3[] =\n      {\n        0xCE, 0xA0, 0xCE, 0x95, 0xCE, 0xA1, 0xCE, 0x99, 0xCE, 0xA3, 0xCE, 0xA3,\n        0xCE, 0x8C, 0xCE, 0xA4, 0xCE, 0x95, 0xCE, 0xA1, 0xCE, 0x95, 0xCE, 0xA3,\n        ' ', 0xCE, 0xA0, 0xCE, 0x9B, 0xCE, 0x97, 0xCE, 0xA1, 0xCE, 0x9F,\n        0xCE, 0xA6, 0xCE, 0x9F, 0xCE, 0xA1, 0xCE, 0x8A, 0xCE, 0x95, 0xCE, 0xA3\n      };\n    int cmp;\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input2, SIZEOF (input2), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input1, SIZEOF (input1), input3, SIZEOF (input3), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input2, SIZEOF (input2), input3, SIZEOF (input3), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n\n  /* Case mapping can require subsequent normalization.  */\n  { /* LATIN SMALL LETTER J WITH CARON, COMBINING DOT BELOW */\n    static const char input[]                 = { 0xC7, 0xB0, 0xCC, 0xA3 };\n    static const char casefolded[]            = { 0x6A, 0xCC, 0x8C, 0xCC, 0xA3 };\n    static const char casefolded_decomposed[] = { 0x6A, 0xCC, 0xA3, 0xCC, 0x8C };\n    int cmp;\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded_decomposed, SIZEOF (casefolded_decomposed), NULL, NULL, &cmp) == 0);\n    ASSERT (cmp != 0);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded, SIZEOF (casefolded), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_casecmp (input, SIZEOF (input), casefolded_decomposed, SIZEOF (casefolded_decomposed), NULL, UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n}",
      "lines": 292,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        369,
        0
      ],
      "end_point": [
        393,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  test_ascii (ulc_casecmp, UNINORM_NFD);\n\n  if (argc > 1)\n    switch (argv[1][0])\n      {\n      case '1':\n        /* Locale encoding is ISO-8859-1 or ISO-8859-15.  */\n        test_iso_8859_1 (ulc_casecmp);\n        return 0;\n\n      case '2':\n        /* Locale encoding is UTF-8.  */\n        test_utf_8 (ulc_casecmp);\n        return 0;\n      }\n\n  return 1;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unicase/test-ulc-casecoll.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "int\nmain ()\n{\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  /* In the \"C\" locale, strcoll is equivalent to strcmp, therefore u8_casecoll\n     on ASCII strings should behave like strcasecmp.  */\n  test_ascii (ulc_casecoll, UNINORM_NFC);\n\n  return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uniconv/test-u16-conv-from-enc.c": {
    "new_offsets": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "static size_t *\nnew_offsets (size_t n)\n{\n  size_t *offsets = (size_t *) malloc ((n + 1) * sizeof (size_t));\n  offsets[n] = MAGIC;\n  return offsets;\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "size_t",
        "*\nnew_offsets (size_t n)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "int\nmain ()\n{\n  static enum iconv_ilseq_handler handlers[] =\n    { iconveh_error, iconveh_question_mark, iconveh_escape_sequence };\n  size_t h;\n  size_t o;\n  size_t i;\n\n#if HAVE_ICONV\n  /* Assume that iconv() supports at least the encodings ASCII, ISO-8859-1,\n     ISO-8859-2, and UTF-8.  */\n\n  /* Test conversion from ISO-8859-1 to UTF-16 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      static const uint16_t expected[] = /* \u00c3\u0084rger mit b\u00c3\u00b6sen B\u00c3\u00bcbchen ohne Augenma\u00c3\u009f */\n        {\n          0xC4, 'r', 'g', 'e', 'r', ' ', 'm', 'i', 't', ' ', 'b', 0xF6, 's',\n          'e', 'n', ' ', 'B', 0xFC, 'b', 'c', 'h', 'e', 'n', ' ', 'o', 'h',\n          'n', 'e', ' ', 'A', 'u', 'g', 'e', 'n', 'm', 'a', 0xDF\n        };\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n          size_t length;\n          uint16_t *result = u16_conv_from_encoding (\"ISO-8859-1\", handler,\n                                                     input, strlen (input),\n                                                     offsets,\n                                                     NULL, &length);\n          ASSERT (result != NULL);\n          ASSERT (length == SIZEOF (expected));\n          ASSERT (u16_cmp (result, expected, SIZEOF (expected)) == 0);\n          if (o)\n            {\n              for (i = 0; i < 37; i++)\n                ASSERT (offsets[i] == i);\n              ASSERT (offsets[37] == MAGIC);\n              free (offsets);\n            }\n          free (result);\n        }\n    }\n\n  /* Test conversion from ISO-8859-2 to UTF-16 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"Rafa\\263 Maszkowski\"; /* Rafa\u00c5\u0082 Maszkowski */\n      static const uint16_t expected[] =\n        {\n          'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z', 'k', 'o', 'w',\n          's', 'k', 'i'\n        };\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n          size_t length;\n          uint16_t *result = u16_conv_from_encoding (\"ISO-8859-2\", handler,\n                                                     input, strlen (input),\n                                                     offsets,\n                                                     NULL, &length);\n          ASSERT (result != NULL);\n          ASSERT (length == SIZEOF (expected));\n          ASSERT (u16_cmp (result, expected, SIZEOF (expected)) == 0);\n          if (o)\n            {\n              for (i = 0; i < 16; i++)\n                ASSERT (offsets[i] == i);\n              ASSERT (offsets[16] == MAGIC);\n              free (offsets);\n            }\n          free (result);\n        }\n    }\n\n  /* autodetect_jp is only supported when iconv() support ISO-2022-JP-2.  */\n# if defined _LIBICONV_VERSION || !(defined _AIX || defined __sgi || defined __hpux || defined __osf__ || defined __sun)\n  if (iconv_supports_encoding (\"ISO-2022-JP-2\"))\n    {\n      /* Test conversions from autodetect_jp to UTF-16.  */\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"\\244\\263\\244\\363\\244\\313\\244\\301\\244\\317\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af in EUC-JP */\n          static const uint16_t expected[] = /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af */\n            {\n              0x3053, 0x3093, 0x306B, 0x3061, 0x306F\n            };\n          for (o = 0; o < 2; o++)\n            {\n              size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n              size_t length;\n              uint16_t *result = u16_conv_from_encoding (\"autodetect_jp\", handler,\n                                                         input, strlen (input),\n                                                         offsets,\n                                                         NULL, &length);\n              ASSERT (result != NULL);\n              ASSERT (length == SIZEOF (expected));\n              ASSERT (u16_cmp (result, expected, SIZEOF (expected)) == 0);\n              if (o)\n                {\n                  for (i = 0; i < 10; i++)\n                    ASSERT (offsets[i] == ((i % 2) == 0 ? i / 2 : (size_t)(-1)));\n                  ASSERT (offsets[10] == MAGIC);\n                  free (offsets);\n                }\n              free (result);\n            }\n        }\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"\\202\\261\\202\\361\\202\\311\\202\\277\\202\\315\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af in Shift_JIS */\n          static const uint16_t expected[] = /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af */\n            {\n              0x3053, 0x3093, 0x306B, 0x3061, 0x306F\n            };\n          for (o = 0; o < 2; o++)\n            {\n              size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n              size_t length;\n              uint16_t *result = u16_conv_from_encoding (\"autodetect_jp\", handler,\n                                                         input, strlen (input),\n                                                         offsets,\n                                                         NULL, &length);\n              ASSERT (result != NULL);\n              ASSERT (length == SIZEOF (expected));\n              ASSERT (u16_cmp (result, expected, SIZEOF (expected)) == 0);\n              if (o)\n                {\n                  for (i = 0; i < 10; i++)\n                    ASSERT (offsets[i] == ((i % 2) == 0 ? i / 2 : (size_t)(-1)));\n                  ASSERT (offsets[10] == MAGIC);\n                  free (offsets);\n                }\n              free (result);\n            }\n        }\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"\\033$B$3$s$K$A$O\\033(B\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af in ISO-2022-JP-2 */\n          static const uint16_t expected[] = /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af */\n            {\n              0x3053, 0x3093, 0x306B, 0x3061, 0x306F\n            };\n          for (o = 0; o < 2; o++)\n            {\n              size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n              size_t length;\n              uint16_t *result = u16_conv_from_encoding (\"autodetect_jp\", handler,\n                                                         input, strlen (input),\n                                                         offsets,\n                                                         NULL, &length);\n              ASSERT (result != NULL);\n              ASSERT (length == SIZEOF (expected));\n              ASSERT (u16_cmp (result, expected, SIZEOF (expected)) == 0);\n              if (o)\n                {\n                  for (i = 0; i < 16; i++)\n                    ASSERT (offsets[i] == (i == 0 ? 0 :\n                                           i == 5 ? 1 :\n                                           i == 7 ? 2 :\n                                           i == 9 ? 3 :\n                                           i == 11 ? 4 :\n                                           i == 13 ? 5 :\n                                           (size_t)(-1)));\n                  ASSERT (offsets[16] == MAGIC);\n                  free (offsets);\n                }\n              free (result);\n            }\n        }\n    }\n# endif\n\n#endif\n\n  return 0;\n}",
      "lines": 183,
      "depth": 27,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uniconv/test-u16-conv-to-enc.c": {
    "new_offsets": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static size_t *\nnew_offsets (size_t n)\n{\n  size_t *offsets = (size_t *) malloc ((n + 1) * sizeof (size_t));\n  offsets[n] = MAGIC;\n  return offsets;\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "size_t",
        "*\nnew_offsets (size_t n)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "int\nmain ()\n{\n  static enum iconv_ilseq_handler handlers[] =\n    { iconveh_error, iconveh_question_mark, iconveh_escape_sequence };\n  size_t h;\n  size_t o;\n  size_t i;\n\n#if HAVE_ICONV\n  /* Assume that iconv() supports at least the encodings ASCII, ISO-8859-1,\n     ISO-8859-2, and UTF-8.  */\n\n  /* Test conversion from UTF-16 to ISO-8859-1 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const uint16_t input[] = /* \u00c3\u0084rger mit b\u00c3\u00b6sen B\u00c3\u00bcbchen ohne Augenma\u00c3\u009f */\n        {\n          0xC4, 'r', 'g', 'e', 'r', ' ', 'm', 'i', 't', ' ', 'b', 0xF6, 's',\n          'e', 'n', ' ', 'B', 0xFC, 'b', 'c', 'h', 'e', 'n', ' ', 'o', 'h',\n          'n', 'e', ' ', 'A', 'u', 'g', 'e', 'n', 'm', 'a', 0xDF\n        };\n      static const char expected[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (SIZEOF (input)) : NULL);\n          size_t length;\n          char *result = u16_conv_to_encoding (\"ISO-8859-1\", handler,\n                                               input, SIZEOF (input),\n                                               offsets,\n                                               NULL, &length);\n          ASSERT (result != NULL);\n          ASSERT (length == strlen (expected));\n          ASSERT (memcmp (result, expected, length) == 0);\n          if (o)\n            {\n              for (i = 0; i < 37; i++)\n                ASSERT (offsets[i] == i);\n              ASSERT (offsets[37] == MAGIC);\n              free (offsets);\n            }\n          free (result);\n        }\n    }\n\n  /* Test conversion from UTF-16 to ISO-8859-1 with EILSEQ.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const uint16_t input[] = /* Rafa\u00c5\u0082 Maszkowski */\n        {\n          'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z', 'k', 'o', 'w',\n          's', 'k', 'i'\n        };\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (SIZEOF (input)) : NULL);\n          size_t length = 0xdead;\n          char *result = u16_conv_to_encoding (\"ISO-8859-1\", handler,\n                                               input, SIZEOF (input),\n                                               offsets,\n                                               NULL, &length);\n          switch (handler)\n            {\n            case iconveh_error:\n              ASSERT (result == NULL);\n              ASSERT (errno == EILSEQ);\n              ASSERT (length == 0xdead);\n              break;\n            case iconveh_question_mark:\n              {\n                static const char expected[] = \"Rafa? Maszkowski\";\n                static const char expected_translit[] = \"Rafal Maszkowski\";\n                ASSERT (result != NULL);\n                ASSERT (length == strlen (expected));\n                ASSERT (memcmp (result, expected, length) == 0\n                        || memcmp (result, expected_translit, length) == 0);\n                if (o)\n                  {\n                    for (i = 0; i < 16; i++)\n                      ASSERT (offsets[i] == i);\n                    ASSERT (offsets[16] == MAGIC);\n                    free (offsets);\n                  }\n                free (result);\n              }\n              break;\n            case iconveh_escape_sequence:\n              {\n                static const char expected[] = \"Rafa\\\\u0142 Maszkowski\";\n                ASSERT (result != NULL);\n                ASSERT (length == strlen (expected));\n                ASSERT (memcmp (result, expected, length) == 0);\n                if (o)\n                  {\n                    for (i = 0; i < 16; i++)\n                      ASSERT (offsets[i] == (i < 5 ? i : i + 5));\n                    ASSERT (offsets[16] == MAGIC);\n                    free (offsets);\n                  }\n                free (result);\n              }\n              break;\n            }\n        }\n    }\n\n  /* Test conversion from UTF-16 to ISO-8859-1 with EINVAL.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const uint16_t input[] = { 0xD845 };\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (SIZEOF (input)) : NULL);\n          size_t length;\n          char *result = u16_conv_to_encoding (\"ISO-8859-1\", handler,\n                                               input, SIZEOF (input),\n                                               offsets,\n                                               NULL, &length);\n          ASSERT (result != NULL);\n          ASSERT (length == strlen (\"\"));\n          if (o)\n            {\n              ASSERT (offsets[0] == 0);\n              ASSERT (offsets[1] == MAGIC);\n              free (offsets);\n            }\n          free (result);\n        }\n    }\n\n#endif\n\n  return 0;\n}",
      "lines": 137,
      "depth": 22,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uniconv/test-u16-strconv-from-enc.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "int\nmain ()\n{\n  static enum iconv_ilseq_handler handlers[] =\n    { iconveh_error, iconveh_question_mark, iconveh_escape_sequence };\n  size_t h;\n\n#if HAVE_ICONV\n  /* Assume that iconv() supports at least the encodings ASCII, ISO-8859-1,\n     ISO-8859-2, and UTF-8.  */\n\n  /* Test conversion from ISO-8859-1 to UTF-16 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      static const uint16_t expected[] = /* \u00c3\u0084rger mit b\u00c3\u00b6sen B\u00c3\u00bcbchen ohne Augenma\u00c3\u009f */\n        {\n          0xC4, 'r', 'g', 'e', 'r', ' ', 'm', 'i', 't', ' ', 'b', 0xF6, 's',\n          'e', 'n', ' ', 'B', 0xFC, 'b', 'c', 'h', 'e', 'n', ' ', 'o', 'h',\n          'n', 'e', ' ', 'A', 'u', 'g', 'e', 'n', 'm', 'a', 0xDF, 0\n        };\n      uint16_t *result = u16_strconv_from_encoding (input, \"ISO-8859-1\", handler);\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      free (result);\n    }\n\n  /* Test conversion from ISO-8859-2 to UTF-16 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"Rafa\\263 Maszkowski\"; /* Rafa\u00c5\u0082 Maszkowski */\n      static const uint16_t expected[] =\n        {\n          'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z', 'k', 'o', 'w',\n          's', 'k', 'i', 0\n        };\n      uint16_t *result = u16_strconv_from_encoding (input, \"ISO-8859-2\", handler);\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      free (result);\n    }\n\n  /* autodetect_jp is only supported when iconv() support ISO-2022-JP-2.  */\n# if defined _LIBICONV_VERSION || !(defined _AIX || defined __sgi || defined __hpux || defined __osf__ || defined __sun)\n  if (iconv_supports_encoding (\"ISO-2022-JP-2\"))\n    {\n      /* Test conversions from autodetect_jp to UTF-16.  */\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"\\244\\263\\244\\363\\244\\313\\244\\301\\244\\317\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af in EUC-JP */\n          static const uint16_t expected[] = /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af */\n            {\n              0x3053, 0x3093, 0x306B, 0x3061, 0x306F, 0\n            };\n          uint16_t *result = u16_strconv_from_encoding (input, \"autodetect_jp\", handler);\n          ASSERT (result != NULL);\n          ASSERT (u16_strcmp (result, expected) == 0);\n          free (result);\n        }\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"\\202\\261\\202\\361\\202\\311\\202\\277\\202\\315\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af in Shift_JIS */\n          static const uint16_t expected[] = /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af */\n            {\n              0x3053, 0x3093, 0x306B, 0x3061, 0x306F, 0\n            };\n          uint16_t *result = u16_strconv_from_encoding (input, \"autodetect_jp\", handler);\n          ASSERT (result != NULL);\n          ASSERT (u16_strcmp (result, expected) == 0);\n          free (result);\n        }\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"\\033$B$3$s$K$A$O\\033(B\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af in ISO-2022-JP-2 */\n          static const uint16_t expected[] = /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af */\n            {\n              0x3053, 0x3093, 0x306B, 0x3061, 0x306F, 0\n            };\n          uint16_t *result = u16_strconv_from_encoding (input, \"autodetect_jp\", handler);\n          ASSERT (result != NULL);\n          ASSERT (u16_strcmp (result, expected) == 0);\n          free (result);\n        }\n    }\n# endif\n\n#endif\n\n  return 0;\n}",
      "lines": 95,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uniconv/test-u16-strconv-to-enc.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "int\nmain ()\n{\n  static enum iconv_ilseq_handler handlers[] =\n    { iconveh_error, iconveh_question_mark, iconveh_escape_sequence };\n  size_t h;\n\n#if HAVE_ICONV\n  /* Assume that iconv() supports at least the encodings ASCII, ISO-8859-1,\n     ISO-8859-2, and UTF-8.  */\n\n  /* Test conversion from UTF-16 to ISO-8859-1 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const uint16_t input[] = /* \u00c3\u0084rger mit b\u00c3\u00b6sen B\u00c3\u00bcbchen ohne Augenma\u00c3\u009f */\n        {\n          0xC4, 'r', 'g', 'e', 'r', ' ', 'm', 'i', 't', ' ', 'b', 0xF6, 's',\n          'e', 'n', ' ', 'B', 0xFC, 'b', 'c', 'h', 'e', 'n', ' ', 'o', 'h',\n          'n', 'e', ' ', 'A', 'u', 'g', 'e', 'n', 'm', 'a', 0xDF, 0\n        };\n      static const char expected[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      char *result = u16_strconv_to_encoding (input, \"ISO-8859-1\", handler);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, expected) == 0);\n      free (result);\n    }\n\n  /* Test conversion from UTF-16 to ISO-8859-1 with EILSEQ.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const uint16_t input[] = /* Rafa\u00c5\u0082 Maszkowski */\n        {\n          'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z', 'k', 'o', 'w',\n          's', 'k', 'i', 0\n        };\n      char *result = u16_strconv_to_encoding (input, \"ISO-8859-1\", handler);\n      switch (handler)\n        {\n        case iconveh_error:\n          ASSERT (result == NULL && errno == EILSEQ);\n          break;\n        case iconveh_question_mark:\n          {\n            static const char expected[] = \"Rafa? Maszkowski\";\n            static const char expected_translit[] = \"Rafal Maszkowski\";\n            ASSERT (result != NULL);\n            ASSERT (strcmp (result, expected) == 0\n                    || strcmp (result, expected_translit) == 0);\n            free (result);\n          }\n          break;\n        case iconveh_escape_sequence:\n          {\n            static const char expected[] = \"Rafa\\\\u0142 Maszkowski\";\n            ASSERT (result != NULL);\n            ASSERT (strcmp (result, expected) == 0);\n            free (result);\n          }\n          break;\n        }\n    }\n\n# if 0\n  /* Test conversion from UTF-16 to ISO-8859-1 with EINVAL.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const uint16_t input[] = { 0xD845, 0 };\n      char *result = u16_strconv_to_encoding (input, \"ISO-8859-1\", handler);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"\") == 0);\n      free (result);\n    }\n# endif\n\n#endif\n\n  return 0;\n}",
      "lines": 81,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uniconv/test-u32-conv-from-enc.c": {
    "new_offsets": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "static size_t *\nnew_offsets (size_t n)\n{\n  size_t *offsets = (size_t *) malloc ((n + 1) * sizeof (size_t));\n  offsets[n] = MAGIC;\n  return offsets;\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "size_t",
        "*\nnew_offsets (size_t n)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "int\nmain ()\n{\n  static enum iconv_ilseq_handler handlers[] =\n    { iconveh_error, iconveh_question_mark, iconveh_escape_sequence };\n  size_t h;\n  size_t o;\n  size_t i;\n\n#if HAVE_ICONV\n  /* Assume that iconv() supports at least the encodings ASCII, ISO-8859-1,\n     ISO-8859-2, and UTF-8.  */\n\n  /* Test conversion from ISO-8859-1 to UTF-16 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      static const uint32_t expected[] = /* \u00c3\u0084rger mit b\u00c3\u00b6sen B\u00c3\u00bcbchen ohne Augenma\u00c3\u009f */\n        {\n          0xC4, 'r', 'g', 'e', 'r', ' ', 'm', 'i', 't', ' ', 'b', 0xF6, 's',\n          'e', 'n', ' ', 'B', 0xFC, 'b', 'c', 'h', 'e', 'n', ' ', 'o', 'h',\n          'n', 'e', ' ', 'A', 'u', 'g', 'e', 'n', 'm', 'a', 0xDF\n        };\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n          size_t length;\n          uint32_t *result = u32_conv_from_encoding (\"ISO-8859-1\", handler,\n                                                     input, strlen (input),\n                                                     offsets,\n                                                     NULL, &length);\n          ASSERT (result != NULL);\n          ASSERT (length == SIZEOF (expected));\n          ASSERT (u32_cmp (result, expected, SIZEOF (expected)) == 0);\n          if (o)\n            {\n              for (i = 0; i < 37; i++)\n                ASSERT (offsets[i] == i);\n              ASSERT (offsets[37] == MAGIC);\n              free (offsets);\n            }\n          free (result);\n        }\n    }\n\n  /* Test conversion from ISO-8859-2 to UTF-16 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"Rafa\\263 Maszkowski\"; /* Rafa\u00c5\u0082 Maszkowski */\n      static const uint32_t expected[] =\n        {\n          'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z', 'k', 'o', 'w',\n          's', 'k', 'i'\n        };\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n          size_t length;\n          uint32_t *result = u32_conv_from_encoding (\"ISO-8859-2\", handler,\n                                                     input, strlen (input),\n                                                     offsets,\n                                                     NULL, &length);\n          ASSERT (result != NULL);\n          ASSERT (length == SIZEOF (expected));\n          ASSERT (u32_cmp (result, expected, SIZEOF (expected)) == 0);\n          if (o)\n            {\n              for (i = 0; i < 16; i++)\n                ASSERT (offsets[i] == i);\n              ASSERT (offsets[16] == MAGIC);\n              free (offsets);\n            }\n          free (result);\n        }\n    }\n\n  /* autodetect_jp is only supported when iconv() support ISO-2022-JP-2.  */\n# if defined _LIBICONV_VERSION || !(defined _AIX || defined __sgi || defined __hpux || defined __osf__ || defined __sun)\n  if (iconv_supports_encoding (\"ISO-2022-JP-2\"))\n    {\n      /* Test conversions from autodetect_jp to UTF-16.  */\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"\\244\\263\\244\\363\\244\\313\\244\\301\\244\\317\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af in EUC-JP */\n          static const uint32_t expected[] = /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af */\n            {\n              0x3053, 0x3093, 0x306B, 0x3061, 0x306F\n            };\n          for (o = 0; o < 2; o++)\n            {\n              size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n              size_t length;\n              uint32_t *result = u32_conv_from_encoding (\"autodetect_jp\", handler,\n                                                         input, strlen (input),\n                                                         offsets,\n                                                         NULL, &length);\n              ASSERT (result != NULL);\n              ASSERT (length == SIZEOF (expected));\n              ASSERT (u32_cmp (result, expected, SIZEOF (expected)) == 0);\n              if (o)\n                {\n                  for (i = 0; i < 10; i++)\n                    ASSERT (offsets[i] == ((i % 2) == 0 ? i / 2 : (size_t)(-1)));\n                  ASSERT (offsets[10] == MAGIC);\n                  free (offsets);\n                }\n              free (result);\n            }\n        }\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"\\202\\261\\202\\361\\202\\311\\202\\277\\202\\315\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af in Shift_JIS */\n          static const uint32_t expected[] = /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af */\n            {\n              0x3053, 0x3093, 0x306B, 0x3061, 0x306F\n            };\n          for (o = 0; o < 2; o++)\n            {\n              size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n              size_t length;\n              uint32_t *result = u32_conv_from_encoding (\"autodetect_jp\", handler,\n                                                         input, strlen (input),\n                                                         offsets,\n                                                         NULL, &length);\n              ASSERT (result != NULL);\n              ASSERT (length == SIZEOF (expected));\n              ASSERT (u32_cmp (result, expected, SIZEOF (expected)) == 0);\n              if (o)\n                {\n                  for (i = 0; i < 10; i++)\n                    ASSERT (offsets[i] == ((i % 2) == 0 ? i / 2 : (size_t)(-1)));\n                  ASSERT (offsets[10] == MAGIC);\n                  free (offsets);\n                }\n              free (result);\n            }\n        }\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"\\033$B$3$s$K$A$O\\033(B\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af in ISO-2022-JP-2 */\n          static const uint32_t expected[] = /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af */\n            {\n              0x3053, 0x3093, 0x306B, 0x3061, 0x306F\n            };\n          for (o = 0; o < 2; o++)\n            {\n              size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n              size_t length;\n              uint32_t *result = u32_conv_from_encoding (\"autodetect_jp\", handler,\n                                                         input, strlen (input),\n                                                         offsets,\n                                                         NULL, &length);\n              ASSERT (result != NULL);\n              ASSERT (length == SIZEOF (expected));\n              ASSERT (u32_cmp (result, expected, SIZEOF (expected)) == 0);\n              if (o)\n                {\n                  for (i = 0; i < 16; i++)\n                    ASSERT (offsets[i] == (i == 0 ? 0 :\n                                           i == 5 ? 1 :\n                                           i == 7 ? 2 :\n                                           i == 9 ? 3 :\n                                           i == 11 ? 4 :\n                                           i == 13 ? 5 :\n                                           (size_t)(-1)));\n                  ASSERT (offsets[16] == MAGIC);\n                  free (offsets);\n                }\n              free (result);\n            }\n        }\n    }\n# endif\n\n#endif\n\n  return 0;\n}",
      "lines": 183,
      "depth": 27,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uniconv/test-u32-conv-to-enc.c": {
    "new_offsets": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static size_t *\nnew_offsets (size_t n)\n{\n  size_t *offsets = (size_t *) malloc ((n + 1) * sizeof (size_t));\n  offsets[n] = MAGIC;\n  return offsets;\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "size_t",
        "*\nnew_offsets (size_t n)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "int\nmain ()\n{\n  static enum iconv_ilseq_handler handlers[] =\n    { iconveh_error, iconveh_question_mark, iconveh_escape_sequence };\n  size_t h;\n  size_t o;\n  size_t i;\n\n#if HAVE_ICONV\n  /* Assume that iconv() supports at least the encodings ASCII, ISO-8859-1,\n     ISO-8859-2, and UTF-8.  */\n\n  /* Test conversion from UTF-32 to ISO-8859-1 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const uint32_t input[] = /* \u00c3\u0084rger mit b\u00c3\u00b6sen B\u00c3\u00bcbchen ohne Augenma\u00c3\u009f */\n        {\n          0xC4, 'r', 'g', 'e', 'r', ' ', 'm', 'i', 't', ' ', 'b', 0xF6, 's',\n          'e', 'n', ' ', 'B', 0xFC, 'b', 'c', 'h', 'e', 'n', ' ', 'o', 'h',\n          'n', 'e', ' ', 'A', 'u', 'g', 'e', 'n', 'm', 'a', 0xDF\n        };\n      static const char expected[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (SIZEOF (input)) : NULL);\n          size_t length;\n          char *result = u32_conv_to_encoding (\"ISO-8859-1\", handler,\n                                               input, SIZEOF (input),\n                                               offsets,\n                                               NULL, &length);\n          ASSERT (result != NULL);\n          ASSERT (length == strlen (expected));\n          ASSERT (memcmp (result, expected, length) == 0);\n          if (o)\n            {\n              for (i = 0; i < 37; i++)\n                ASSERT (offsets[i] == i);\n              ASSERT (offsets[37] == MAGIC);\n              free (offsets);\n            }\n          free (result);\n        }\n    }\n\n  /* Test conversion from UTF-32 to ISO-8859-1 with EILSEQ.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const uint32_t input[] = /* Rafa\u00c5\u0082 Maszkowski */\n        {\n          'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z', 'k', 'o', 'w',\n          's', 'k', 'i'\n        };\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (SIZEOF (input)) : NULL);\n          size_t length = 0xdead;\n          char *result = u32_conv_to_encoding (\"ISO-8859-1\", handler,\n                                               input, SIZEOF (input),\n                                               offsets,\n                                               NULL, &length);\n          switch (handler)\n            {\n            case iconveh_error:\n              ASSERT (result == NULL);\n              ASSERT (errno == EILSEQ);\n              ASSERT (length == 0xdead);\n              break;\n            case iconveh_question_mark:\n              {\n                static const char expected[] = \"Rafa? Maszkowski\";\n                static const char expected_translit[] = \"Rafal Maszkowski\";\n                ASSERT (result != NULL);\n                ASSERT (length == strlen (expected));\n                ASSERT (memcmp (result, expected, length) == 0\n                        || memcmp (result, expected_translit, length) == 0);\n                if (o)\n                  {\n                    for (i = 0; i < 16; i++)\n                      ASSERT (offsets[i] == i);\n                    ASSERT (offsets[16] == MAGIC);\n                    free (offsets);\n                  }\n                free (result);\n              }\n              break;\n            case iconveh_escape_sequence:\n              {\n                static const char expected[] = \"Rafa\\\\u0142 Maszkowski\";\n                ASSERT (result != NULL);\n                ASSERT (length == strlen (expected));\n                ASSERT (memcmp (result, expected, length) == 0);\n                if (o)\n                  {\n                    for (i = 0; i < 16; i++)\n                      ASSERT (offsets[i] == (i < 5 ? i : i + 5));\n                    ASSERT (offsets[16] == MAGIC);\n                    free (offsets);\n                  }\n                free (result);\n              }\n              break;\n            }\n        }\n    }\n\n#endif\n\n  return 0;\n}",
      "lines": 112,
      "depth": 22,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uniconv/test-u32-strconv-from-enc.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "int\nmain ()\n{\n  static enum iconv_ilseq_handler handlers[] =\n    { iconveh_error, iconveh_question_mark, iconveh_escape_sequence };\n  size_t h;\n\n#if HAVE_ICONV\n  /* Assume that iconv() supports at least the encodings ASCII, ISO-8859-1,\n     ISO-8859-2, and UTF-8.  */\n\n  /* Test conversion from ISO-8859-1 to UTF-16 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      static const uint32_t expected[] = /* \u00c3\u0084rger mit b\u00c3\u00b6sen B\u00c3\u00bcbchen ohne Augenma\u00c3\u009f */\n        {\n          0xC4, 'r', 'g', 'e', 'r', ' ', 'm', 'i', 't', ' ', 'b', 0xF6, 's',\n          'e', 'n', ' ', 'B', 0xFC, 'b', 'c', 'h', 'e', 'n', ' ', 'o', 'h',\n          'n', 'e', ' ', 'A', 'u', 'g', 'e', 'n', 'm', 'a', 0xDF, 0\n        };\n      uint32_t *result = u32_strconv_from_encoding (input, \"ISO-8859-1\", handler);\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      free (result);\n    }\n\n  /* Test conversion from ISO-8859-2 to UTF-16 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"Rafa\\263 Maszkowski\"; /* Rafa\u00c5\u0082 Maszkowski */\n      static const uint32_t expected[] =\n        {\n          'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z', 'k', 'o', 'w',\n          's', 'k', 'i', 0\n        };\n      uint32_t *result = u32_strconv_from_encoding (input, \"ISO-8859-2\", handler);\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      free (result);\n    }\n\n  /* autodetect_jp is only supported when iconv() support ISO-2022-JP-2.  */\n# if defined _LIBICONV_VERSION || !(defined _AIX || defined __sgi || defined __hpux || defined __osf__ || defined __sun)\n  if (iconv_supports_encoding (\"ISO-2022-JP-2\"))\n    {\n      /* Test conversions from autodetect_jp to UTF-16.  */\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"\\244\\263\\244\\363\\244\\313\\244\\301\\244\\317\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af in EUC-JP */\n          static const uint32_t expected[] = /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af */\n            {\n              0x3053, 0x3093, 0x306B, 0x3061, 0x306F, 0\n            };\n          uint32_t *result = u32_strconv_from_encoding (input, \"autodetect_jp\", handler);\n          ASSERT (result != NULL);\n          ASSERT (u32_strcmp (result, expected) == 0);\n          free (result);\n        }\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"\\202\\261\\202\\361\\202\\311\\202\\277\\202\\315\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af in Shift_JIS */\n          static const uint32_t expected[] = /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af */\n            {\n              0x3053, 0x3093, 0x306B, 0x3061, 0x306F, 0\n            };\n          uint32_t *result = u32_strconv_from_encoding (input, \"autodetect_jp\", handler);\n          ASSERT (result != NULL);\n          ASSERT (u32_strcmp (result, expected) == 0);\n          free (result);\n        }\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"\\033$B$3$s$K$A$O\\033(B\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af in ISO-2022-JP-2 */\n          static const uint32_t expected[] = /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af */\n            {\n              0x3053, 0x3093, 0x306B, 0x3061, 0x306F, 0\n            };\n          uint32_t *result = u32_strconv_from_encoding (input, \"autodetect_jp\", handler);\n          ASSERT (result != NULL);\n          ASSERT (u32_strcmp (result, expected) == 0);\n          free (result);\n        }\n    }\n# endif\n\n#endif\n\n  return 0;\n}",
      "lines": 95,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uniconv/test-u32-strconv-to-enc.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "int\nmain ()\n{\n  static enum iconv_ilseq_handler handlers[] =\n    { iconveh_error, iconveh_question_mark, iconveh_escape_sequence };\n  size_t h;\n\n#if HAVE_ICONV\n  /* Assume that iconv() supports at least the encodings ASCII, ISO-8859-1,\n     ISO-8859-2, and UTF-8.  */\n\n  /* Test conversion from UTF-32 to ISO-8859-1 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const uint32_t input[] = /* \u00c3\u0084rger mit b\u00c3\u00b6sen B\u00c3\u00bcbchen ohne Augenma\u00c3\u009f */\n        {\n          0xC4, 'r', 'g', 'e', 'r', ' ', 'm', 'i', 't', ' ', 'b', 0xF6, 's',\n          'e', 'n', ' ', 'B', 0xFC, 'b', 'c', 'h', 'e', 'n', ' ', 'o', 'h',\n          'n', 'e', ' ', 'A', 'u', 'g', 'e', 'n', 'm', 'a', 0xDF, 0\n        };\n      static const char expected[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      char *result = u32_strconv_to_encoding (input, \"ISO-8859-1\", handler);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, expected) == 0);\n      free (result);\n    }\n\n  /* Test conversion from UTF-32 to ISO-8859-1 with EILSEQ.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const uint32_t input[] = /* Rafa\u00c5\u0082 Maszkowski */\n        {\n          'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z', 'k', 'o', 'w',\n          's', 'k', 'i', 0\n        };\n      char *result = u32_strconv_to_encoding (input, \"ISO-8859-1\", handler);\n      switch (handler)\n        {\n        case iconveh_error:\n          ASSERT (result == NULL && errno == EILSEQ);\n          break;\n        case iconveh_question_mark:\n          {\n            static const char expected[] = \"Rafa? Maszkowski\";\n            static const char expected_translit[] = \"Rafal Maszkowski\";\n            ASSERT (result != NULL);\n            ASSERT (strcmp (result, expected) == 0\n                    || strcmp (result, expected_translit) == 0);\n            free (result);\n          }\n          break;\n        case iconveh_escape_sequence:\n          {\n            static const char expected[] = \"Rafa\\\\u0142 Maszkowski\";\n            ASSERT (result != NULL);\n            ASSERT (strcmp (result, expected) == 0);\n            free (result);\n          }\n          break;\n        }\n    }\n\n#endif\n\n  return 0;\n}",
      "lines": 68,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uniconv/test-u8-conv-from-enc.c": {
    "new_offsets": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "static size_t *\nnew_offsets (size_t n)\n{\n  size_t *offsets = (size_t *) malloc ((n + 1) * sizeof (size_t));\n  offsets[n] = MAGIC;\n  return offsets;\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "size_t",
        "*\nnew_offsets (size_t n)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        208,
        1
      ],
      "content": "int\nmain ()\n{\n  static enum iconv_ilseq_handler handlers[] =\n    { iconveh_error, iconveh_question_mark, iconveh_escape_sequence };\n  size_t h;\n  size_t o;\n  size_t i;\n\n#if HAVE_ICONV\n  /* Assume that iconv() supports at least the encodings ASCII, ISO-8859-1,\n     ISO-8859-2, and UTF-8.  */\n\n  /* Test conversion from ISO-8859-1 to UTF-8 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      static const uint8_t expected[] = \"\\303\\204rger mit b\\303\\266sen B\\303\\274bchen ohne Augenma\\303\\237\";\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n          size_t length;\n          uint8_t *result = u8_conv_from_encoding (\"ISO-8859-1\", handler,\n                                                   input, strlen (input),\n                                                   offsets,\n                                                   NULL, &length);\n          ASSERT (result != NULL);\n          ASSERT (length == u8_strlen (expected));\n          ASSERT (u8_cmp (result, expected, u8_strlen (expected)) == 0);\n          if (o)\n            {\n              for (i = 0; i < 37; i++)\n                ASSERT (offsets[i] == (i < 1 ? i :\n                                       i < 12 ? i + 1 :\n                                       i < 18 ? i + 2 :\n                                       i + 3));\n              ASSERT (offsets[37] == MAGIC);\n              free (offsets);\n            }\n          free (result);\n        }\n    }\n\n  /* Test conversion from ISO-8859-2 to UTF-8 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"Rafa\\263 Maszkowski\"; /* Rafa\u00c5\u0082 Maszkowski */\n      static const uint8_t expected[] = \"Rafa\\305\\202 Maszkowski\";\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n          size_t length;\n          uint8_t *result = u8_conv_from_encoding (\"ISO-8859-2\", handler,\n                                                   input, strlen (input),\n                                                   offsets,\n                                                   NULL, &length);\n          ASSERT (result != NULL);\n          ASSERT (length == u8_strlen (expected));\n          ASSERT (u8_cmp (result, expected, u8_strlen (expected)) == 0);\n          if (o)\n            {\n              for (i = 0; i < 16; i++)\n                ASSERT (offsets[i] == (i < 5 ? i :\n                                       i + 1));\n              ASSERT (offsets[16] == MAGIC);\n              free (offsets);\n            }\n          free (result);\n        }\n    }\n\n  /* autodetect_jp is only supported when iconv() support ISO-2022-JP-2.  */\n# if defined _LIBICONV_VERSION || !(defined _AIX || defined __sgi || defined __hpux || defined __osf__ || defined __sun)\n  if (iconv_supports_encoding (\"ISO-2022-JP-2\"))\n    {\n      /* Test conversions from autodetect_jp to UTF-8.  */\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"\\244\\263\\244\\363\\244\\313\\244\\301\\244\\317\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af in EUC-JP */\n          static const uint8_t expected[] = \"\\343\\201\\223\\343\\202\\223\\343\\201\\253\\343\\201\\241\\343\\201\\257\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af */\n          for (o = 0; o < 2; o++)\n            {\n              size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n              size_t length;\n              uint8_t *result = u8_conv_from_encoding (\"autodetect_jp\", handler,\n                                                       input, strlen (input),\n                                                       offsets,\n                                                       NULL, &length);\n              ASSERT (result != NULL);\n              ASSERT (length == u8_strlen (expected));\n              ASSERT (u8_cmp (result, expected, u8_strlen (expected)) == 0);\n              if (o)\n                {\n                  for (i = 0; i < 10; i++)\n                    ASSERT (offsets[i] == ((i % 2) == 0 ? (i / 2) * 3 : (size_t)(-1)));\n                  ASSERT (offsets[10] == MAGIC);\n                  free (offsets);\n                }\n              free (result);\n            }\n        }\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"\\202\\261\\202\\361\\202\\311\\202\\277\\202\\315\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af in Shift_JIS */\n          static const uint8_t expected[] = \"\\343\\201\\223\\343\\202\\223\\343\\201\\253\\343\\201\\241\\343\\201\\257\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af */\n          for (o = 0; o < 2; o++)\n            {\n              size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n              size_t length;\n              uint8_t *result = u8_conv_from_encoding (\"autodetect_jp\", handler,\n                                                       input, strlen (input),\n                                                       offsets,\n                                                       NULL, &length);\n              ASSERT (result != NULL);\n              ASSERT (length == u8_strlen (expected));\n              ASSERT (u8_cmp (result, expected, u8_strlen (expected)) == 0);\n              if (o)\n                {\n                  for (i = 0; i < 10; i++)\n                    ASSERT (offsets[i] == ((i % 2) == 0 ? (i / 2) * 3 : (size_t)(-1)));\n                  ASSERT (offsets[10] == MAGIC);\n                  free (offsets);\n                }\n              free (result);\n            }\n        }\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"\\033$B$3$s$K$A$O\\033(B\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af in ISO-2022-JP-2 */\n          static const uint8_t expected[] = \"\\343\\201\\223\\343\\202\\223\\343\\201\\253\\343\\201\\241\\343\\201\\257\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af */\n          for (o = 0; o < 2; o++)\n            {\n              size_t *offsets = (o ? new_offsets (strlen (input)) : NULL);\n              size_t length;\n              uint8_t *result = u8_conv_from_encoding (\"autodetect_jp\", handler,\n                                                       input, strlen (input),\n                                                       offsets,\n                                                       NULL, &length);\n              ASSERT (result != NULL);\n              ASSERT (length == u8_strlen (expected));\n              ASSERT (u8_cmp (result, expected, u8_strlen (expected)) == 0);\n              if (o)\n                {\n                  for (i = 0; i < 16; i++)\n                    ASSERT (offsets[i] == (i == 0 ? 0 :\n                                           i == 5 ? 3 :\n                                           i == 7 ? 6 :\n                                           i == 9 ? 9 :\n                                           i == 11 ? 12 :\n                                           i == 13 ? 15 :\n                                           (size_t)(-1)));\n                  ASSERT (offsets[16] == MAGIC);\n                  free (offsets);\n                }\n              free (result);\n            }\n        }\n    }\n# endif\n\n#endif\n\n  return 0;\n}",
      "lines": 169,
      "depth": 27,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uniconv/test-u8-conv-to-enc.c": {
    "new_offsets": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "static size_t *\nnew_offsets (size_t n)\n{\n  size_t *offsets = (size_t *) malloc ((n + 1) * sizeof (size_t));\n  offsets[n] = MAGIC;\n  return offsets;\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "size_t",
        "*\nnew_offsets (size_t n)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "int\nmain ()\n{\n  static enum iconv_ilseq_handler handlers[] =\n    { iconveh_error, iconveh_question_mark, iconveh_escape_sequence };\n  size_t h;\n  size_t o;\n  size_t i;\n\n#if HAVE_ICONV\n  /* Assume that iconv() supports at least the encodings ASCII, ISO-8859-1,\n     ISO-8859-2, and UTF-8.  */\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const uint8_t input[] = \"\\303\\204rger mit b\\303\\266sen B\\303\\274bchen ohne Augenma\\303\\237\";\n      static const char expected[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (u8_strlen (input)) : NULL);\n          size_t length;\n          char *result = u8_conv_to_encoding (\"ISO-8859-1\", handler,\n                                              input, u8_strlen (input),\n                                              offsets,\n                                              NULL, &length);\n          ASSERT (result != NULL);\n          ASSERT (length == strlen (expected));\n          ASSERT (memcmp (result, expected, length) == 0);\n          if (o)\n            {\n              for (i = 0; i < 41; i++)\n                ASSERT (offsets[i] == (i < 1 ? i :\n                                       i == 1 ? (size_t)(-1) :\n                                       i < 13 ? i - 1 :\n                                       i == 13 ? (size_t)(-1) :\n                                       i < 20 ? i - 2 :\n                                       i == 20 ? (size_t)(-1) :\n                                       i < 40 ? i - 3 :\n                                       i == 40 ? (size_t)(-1) :\n                                       i - 4));\n              ASSERT (offsets[41] == MAGIC);\n              free (offsets);\n            }\n          free (result);\n        }\n    }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with EILSEQ.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const uint8_t input[] = \"Rafa\\305\\202 Maszkowski\"; /* Rafa\u00c5\u0082 Maszkowski */\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (u8_strlen (input)) : NULL);\n          size_t length = 0xdead;\n          char *result = u8_conv_to_encoding (\"ISO-8859-1\", handler,\n                                              input, u8_strlen (input),\n                                              offsets,\n                                              NULL, &length);\n          switch (handler)\n            {\n            case iconveh_error:\n              ASSERT (result == NULL);\n              ASSERT (errno == EILSEQ);\n              ASSERT (length == 0xdead);\n              break;\n            case iconveh_question_mark:\n              {\n                static const char expected[] = \"Rafa? Maszkowski\";\n                static const char expected_translit[] = \"Rafal Maszkowski\";\n                ASSERT (result != NULL);\n                ASSERT (length == strlen (expected));\n                ASSERT (memcmp (result, expected, length) == 0\n                        || memcmp (result, expected_translit, length) == 0);\n                if (o)\n                  {\n                    for (i = 0; i < 17; i++)\n                      ASSERT (offsets[i] == (i < 5 ? i :\n                                             i == 5 ? (size_t)(-1) :\n                                             i - 1));\n                    ASSERT (offsets[17] == MAGIC);\n                    free (offsets);\n                  }\n                free (result);\n              }\n              break;\n            case iconveh_escape_sequence:\n              {\n                static const char expected[] = \"Rafa\\\\u0142 Maszkowski\";\n                ASSERT (result != NULL);\n                ASSERT (length == strlen (expected));\n                ASSERT (memcmp (result, expected, length) == 0);\n                if (o)\n                  {\n                    for (i = 0; i < 17; i++)\n                      ASSERT (offsets[i] == (i < 5 ? i :\n                                             i == 5 ? (size_t)(-1) :\n                                             i + 4));\n                    ASSERT (offsets[17] == MAGIC);\n                    free (offsets);\n                  }\n                free (result);\n              }\n              break;\n            }\n        }\n    }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with EINVAL.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const uint8_t input[] = \"\\342\";\n      for (o = 0; o < 2; o++)\n        {\n          size_t *offsets = (o ? new_offsets (u8_strlen (input)) : NULL);\n          size_t length;\n          char *result = u8_conv_to_encoding (\"ISO-8859-1\", handler,\n                                              input, u8_strlen (input),\n                                              offsets,\n                                              NULL, &length);\n          ASSERT (result != NULL);\n          ASSERT (length == strlen (\"\"));\n          if (o)\n            {\n              ASSERT (offsets[0] == 0);\n              ASSERT (offsets[1] == MAGIC);\n              free (offsets);\n            }\n          free (result);\n        }\n    }\n\n#endif\n\n  return 0;\n}",
      "lines": 140,
      "depth": 26,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uniconv/test-u8-strconv-from-enc.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "int\nmain ()\n{\n  static enum iconv_ilseq_handler handlers[] =\n    { iconveh_error, iconveh_question_mark, iconveh_escape_sequence };\n  size_t h;\n\n#if HAVE_ICONV\n  /* Assume that iconv() supports at least the encodings ASCII, ISO-8859-1,\n     ISO-8859-2, and UTF-8.  */\n\n  /* Test conversion from ISO-8859-1 to UTF-8 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      static const uint8_t expected[] = \"\\303\\204rger mit b\\303\\266sen B\\303\\274bchen ohne Augenma\\303\\237\";\n      uint8_t *result = u8_strconv_from_encoding (input, \"ISO-8859-1\", handler);\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      free (result);\n    }\n\n  /* Test conversion from ISO-8859-2 to UTF-8 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const char input[] = \"Rafa\\263 Maszkowski\"; /* Rafa\u00c5\u0082 Maszkowski */\n      static const uint8_t expected[] = \"Rafa\\305\\202 Maszkowski\";\n      uint8_t *result = u8_strconv_from_encoding (input, \"ISO-8859-2\", handler);\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      free (result);\n    }\n\n  /* autodetect_jp is only supported when iconv() support ISO-2022-JP-2.  */\n# if defined _LIBICONV_VERSION || !(defined _AIX || defined __sgi || defined __hpux || defined __osf__ || defined __sun)\n  if (iconv_supports_encoding (\"ISO-2022-JP-2\"))\n    {\n      /* Test conversions from autodetect_jp to UTF-8.  */\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"\\244\\263\\244\\363\\244\\313\\244\\301\\244\\317\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af in EUC-JP */\n          static const uint8_t expected[] = \"\\343\\201\\223\\343\\202\\223\\343\\201\\253\\343\\201\\241\\343\\201\\257\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af */\n          uint8_t *result = u8_strconv_from_encoding (input, \"autodetect_jp\", handler);\n          ASSERT (result != NULL);\n          ASSERT (u8_strcmp (result, expected) == 0);\n          free (result);\n        }\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"\\202\\261\\202\\361\\202\\311\\202\\277\\202\\315\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af in Shift_JIS */\n          static const uint8_t expected[] = \"\\343\\201\\223\\343\\202\\223\\343\\201\\253\\343\\201\\241\\343\\201\\257\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af */\n          uint8_t *result = u8_strconv_from_encoding (input, \"autodetect_jp\", handler);\n          ASSERT (result != NULL);\n          ASSERT (u8_strcmp (result, expected) == 0);\n          free (result);\n        }\n      for (h = 0; h < SIZEOF (handlers); h++)\n        {\n          enum iconv_ilseq_handler handler = handlers[h];\n          static const char input[] = \"\\033$B$3$s$K$A$O\\033(B\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af in ISO-2022-JP-2 */\n          static const uint8_t expected[] = \"\\343\\201\\223\\343\\202\\223\\343\\201\\253\\343\\201\\241\\343\\201\\257\"; /* \u00e3\u0081\u0093\u00e3\u0082\u0093\u00e3\u0081\u00ab\u00e3\u0081\u00a1\u00e3\u0081\u00af */\n          uint8_t *result = u8_strconv_from_encoding (input, \"autodetect_jp\", handler);\n          ASSERT (result != NULL);\n          ASSERT (u8_strcmp (result, expected) == 0);\n          free (result);\n        }\n    }\n# endif\n\n#endif\n\n  return 0;\n}",
      "lines": 77,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uniconv/test-u8-strconv-to-enc.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "int\nmain ()\n{\n  static enum iconv_ilseq_handler handlers[] =\n    { iconveh_error, iconveh_question_mark, iconveh_escape_sequence };\n  size_t h;\n\n#if HAVE_ICONV\n  /* Assume that iconv() supports at least the encodings ASCII, ISO-8859-1,\n     ISO-8859-2, and UTF-8.  */\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with no errors.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const uint8_t input[] = \"\\303\\204rger mit b\\303\\266sen B\\303\\274bchen ohne Augenma\\303\\237\";\n      static const char expected[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n      char *result = u8_strconv_to_encoding (input, \"ISO-8859-1\", handler);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, expected) == 0);\n      free (result);\n    }\n\n  /* Test conversion from UTF-8 to ISO-8859-1 with EILSEQ.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const uint8_t input[] = \"Rafa\\305\\202 Maszkowski\"; /* Rafa\u00c5\u0082 Maszkowski */\n      char *result = u8_strconv_to_encoding (input, \"ISO-8859-1\", handler);\n      switch (handler)\n        {\n        case iconveh_error:\n          ASSERT (result == NULL && errno == EILSEQ);\n          break;\n        case iconveh_question_mark:\n          {\n            static const char expected[] = \"Rafa? Maszkowski\";\n            static const char expected_translit[] = \"Rafal Maszkowski\";\n            ASSERT (result != NULL);\n            ASSERT (strcmp (result, expected) == 0\n                    || strcmp (result, expected_translit) == 0);\n            free (result);\n          }\n          break;\n        case iconveh_escape_sequence:\n          {\n            static const char expected[] = \"Rafa\\\\u0142 Maszkowski\";\n            ASSERT (result != NULL);\n            ASSERT (strcmp (result, expected) == 0);\n            free (result);\n          }\n          break;\n        }\n    }\n\n# if 0\n  /* Test conversion from UTF-8 to ISO-8859-1 with EINVAL.  */\n  for (h = 0; h < SIZEOF (handlers); h++)\n    {\n      enum iconv_ilseq_handler handler = handlers[h];\n      static const uint8_t input[] = \"\\342\";\n      char *result = u8_strconv_to_encoding (input, \"ISO-8859-1\", handler);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"\") == 0);\n      free (result);\n    }\n# endif\n\n#endif\n\n  return 0;\n}",
      "lines": 72,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-bidi_byname.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "int\nmain ()\n{\n  ASSERT (uc_bidi_class_byname (\"L\") == UC_BIDI_L);\n  ASSERT (uc_bidi_class_byname (\"LRE\") == UC_BIDI_LRE);\n  ASSERT (uc_bidi_class_byname (\"LRO\") == UC_BIDI_LRO);\n  ASSERT (uc_bidi_class_byname (\"R\") == UC_BIDI_R);\n  ASSERT (uc_bidi_class_byname (\"AL\") == UC_BIDI_AL);\n  ASSERT (uc_bidi_class_byname (\"RLE\") == UC_BIDI_RLE);\n  ASSERT (uc_bidi_class_byname (\"RLO\") == UC_BIDI_RLO);\n  ASSERT (uc_bidi_class_byname (\"PDF\") == UC_BIDI_PDF);\n  ASSERT (uc_bidi_class_byname (\"EN\") == UC_BIDI_EN);\n  ASSERT (uc_bidi_class_byname (\"ES\") == UC_BIDI_ES);\n  ASSERT (uc_bidi_class_byname (\"ET\") == UC_BIDI_ET);\n  ASSERT (uc_bidi_class_byname (\"AN\") == UC_BIDI_AN);\n  ASSERT (uc_bidi_class_byname (\"CS\") == UC_BIDI_CS);\n  ASSERT (uc_bidi_class_byname (\"NSM\") == UC_BIDI_NSM);\n  ASSERT (uc_bidi_class_byname (\"BN\") == UC_BIDI_BN);\n  ASSERT (uc_bidi_class_byname (\"B\") == UC_BIDI_B);\n  ASSERT (uc_bidi_class_byname (\"S\") == UC_BIDI_S);\n  ASSERT (uc_bidi_class_byname (\"WS\") == UC_BIDI_WS);\n  ASSERT (uc_bidi_class_byname (\"ON\") == UC_BIDI_ON);\n\n  ASSERT (uc_bidi_class_byname (\"ARABIC LETTER\") == UC_BIDI_AL);\n  ASSERT (uc_bidi_class_byname (\"Arabic Letter\") == UC_BIDI_AL);\n  ASSERT (uc_bidi_class_byname (\"Arabic_Letter\") == UC_BIDI_AL);\n  ASSERT (uc_bidi_class_byname (\"ArabicLetter\") == UC_BIDI_AL);\n  ASSERT (uc_bidi_class_byname (\"ARABIC NUMBER\") == UC_BIDI_AN);\n  ASSERT (uc_bidi_class_byname (\"Arabic Number\") == UC_BIDI_AN);\n  ASSERT (uc_bidi_class_byname (\"Arabic_Number\") == UC_BIDI_AN);\n  ASSERT (uc_bidi_class_byname (\"ArabicNumber\") == UC_BIDI_AN);\n  ASSERT (uc_bidi_class_byname (\"PARAGRAPH SEPARATOR\") == UC_BIDI_B);\n  ASSERT (uc_bidi_class_byname (\"Paragraph Separator\") == UC_BIDI_B);\n  ASSERT (uc_bidi_class_byname (\"Paragraph_Separator\") == UC_BIDI_B);\n  ASSERT (uc_bidi_class_byname (\"ParagraphSeparator\") == UC_BIDI_B);\n  ASSERT (uc_bidi_class_byname (\"BOUNDARY NEUTRAL\") == UC_BIDI_BN);\n  ASSERT (uc_bidi_class_byname (\"Boundary Neutral\") == UC_BIDI_BN);\n  ASSERT (uc_bidi_class_byname (\"Boundary_Neutral\") == UC_BIDI_BN);\n  ASSERT (uc_bidi_class_byname (\"BoundaryNeutral\") == UC_BIDI_BN);\n  ASSERT (uc_bidi_class_byname (\"COMMON SEPARATOR\") == UC_BIDI_CS);\n  ASSERT (uc_bidi_class_byname (\"Common Separator\") == UC_BIDI_CS);\n  ASSERT (uc_bidi_class_byname (\"Common_Separator\") == UC_BIDI_CS);\n  ASSERT (uc_bidi_class_byname (\"CommonSeparator\") == UC_BIDI_CS);\n  ASSERT (uc_bidi_class_byname (\"EUROPEAN NUMBER\") == UC_BIDI_EN);\n  ASSERT (uc_bidi_class_byname (\"European Number\") == UC_BIDI_EN);\n  ASSERT (uc_bidi_class_byname (\"European_Number\") == UC_BIDI_EN);\n  ASSERT (uc_bidi_class_byname (\"EuropeanNumber\") == UC_BIDI_EN);\n  ASSERT (uc_bidi_class_byname (\"EUROPEAN SEPARATOR\") == UC_BIDI_ES);\n  ASSERT (uc_bidi_class_byname (\"European Separator\") == UC_BIDI_ES);\n  ASSERT (uc_bidi_class_byname (\"European_Separator\") == UC_BIDI_ES);\n  ASSERT (uc_bidi_class_byname (\"EuropeanSeparator\") == UC_BIDI_ES);\n  ASSERT (uc_bidi_class_byname (\"EUROPEAN TERMINATOR\") == UC_BIDI_ET);\n  ASSERT (uc_bidi_class_byname (\"European Terminator\") == UC_BIDI_ET);\n  ASSERT (uc_bidi_class_byname (\"European_Terminator\") == UC_BIDI_ET);\n  ASSERT (uc_bidi_class_byname (\"EuropeanTerminator\") == UC_BIDI_ET);\n  ASSERT (uc_bidi_class_byname (\"LEFT TO RIGHT\") == UC_BIDI_L);\n  ASSERT (uc_bidi_class_byname (\"Left To Right\") == UC_BIDI_L);\n  ASSERT (uc_bidi_class_byname (\"Left_To_Right\") == UC_BIDI_L);\n  ASSERT (uc_bidi_class_byname (\"LeftToRight\") == UC_BIDI_L);\n  ASSERT (uc_bidi_class_byname (\"LEFT TO RIGHT EMBEDDING\") == UC_BIDI_LRE);\n  ASSERT (uc_bidi_class_byname (\"Left To Right Embedding\") == UC_BIDI_LRE);\n  ASSERT (uc_bidi_class_byname (\"Left_To_Right_Embedding\") == UC_BIDI_LRE);\n  ASSERT (uc_bidi_class_byname (\"LeftToRightEmbedding\") == UC_BIDI_LRE);\n  ASSERT (uc_bidi_class_byname (\"LEFT TO RIGHT OVERRIDE\") == UC_BIDI_LRO);\n  ASSERT (uc_bidi_class_byname (\"Left To Right Override\") == UC_BIDI_LRO);\n  ASSERT (uc_bidi_class_byname (\"Left_To_Right_Override\") == UC_BIDI_LRO);\n  ASSERT (uc_bidi_class_byname (\"LeftToRightOverride\") == UC_BIDI_LRO);\n  ASSERT (uc_bidi_class_byname (\"NONSPACING MARK\") == UC_BIDI_NSM);\n  ASSERT (uc_bidi_class_byname (\"Nonspacing Mark\") == UC_BIDI_NSM);\n  ASSERT (uc_bidi_class_byname (\"Nonspacing_Mark\") == UC_BIDI_NSM);\n  ASSERT (uc_bidi_class_byname (\"NonspacingMark\") == UC_BIDI_NSM);\n  ASSERT (uc_bidi_class_byname (\"OTHER NEUTRAL\") == UC_BIDI_ON);\n  ASSERT (uc_bidi_class_byname (\"Other Neutral\") == UC_BIDI_ON);\n  ASSERT (uc_bidi_class_byname (\"Other_Neutral\") == UC_BIDI_ON);\n  ASSERT (uc_bidi_class_byname (\"OtherNeutral\") == UC_BIDI_ON);\n  ASSERT (uc_bidi_class_byname (\"POP DIRECTIONAL FORMAT\") == UC_BIDI_PDF);\n  ASSERT (uc_bidi_class_byname (\"Pop Directional Format\") == UC_BIDI_PDF);\n  ASSERT (uc_bidi_class_byname (\"Pop_Directional_Format\") == UC_BIDI_PDF);\n  ASSERT (uc_bidi_class_byname (\"PopDirectionalFormat\") == UC_BIDI_PDF);\n  ASSERT (uc_bidi_class_byname (\"RIGHT TO LEFT\") == UC_BIDI_R);\n  ASSERT (uc_bidi_class_byname (\"Right To Left\") == UC_BIDI_R);\n  ASSERT (uc_bidi_class_byname (\"Right_To_Left\") == UC_BIDI_R);\n  ASSERT (uc_bidi_class_byname (\"RightToLeft\") == UC_BIDI_R);\n  ASSERT (uc_bidi_class_byname (\"RIGHT TO LEFT EMBEDDING\") == UC_BIDI_RLE);\n  ASSERT (uc_bidi_class_byname (\"Right To Left Embedding\") == UC_BIDI_RLE);\n  ASSERT (uc_bidi_class_byname (\"Right_To_Left_Embedding\") == UC_BIDI_RLE);\n  ASSERT (uc_bidi_class_byname (\"RightToLeftEmbedding\") == UC_BIDI_RLE);\n  ASSERT (uc_bidi_class_byname (\"RIGHT TO LEFT OVERRIDE\") == UC_BIDI_RLO);\n  ASSERT (uc_bidi_class_byname (\"Right To Left Override\") == UC_BIDI_RLO);\n  ASSERT (uc_bidi_class_byname (\"Right_To_Left_Override\") == UC_BIDI_RLO);\n  ASSERT (uc_bidi_class_byname (\"RightToLeftOverride\") == UC_BIDI_RLO);\n  ASSERT (uc_bidi_class_byname (\"SEGMENT SEPARATOR\") == UC_BIDI_S);\n  ASSERT (uc_bidi_class_byname (\"Segment Separator\") == UC_BIDI_S);\n  ASSERT (uc_bidi_class_byname (\"Segment_Separator\") == UC_BIDI_S);\n  ASSERT (uc_bidi_class_byname (\"SegmentSeparator\") == UC_BIDI_S);\n  ASSERT (uc_bidi_class_byname (\"WHITE SPACE\") == UC_BIDI_WS);\n  ASSERT (uc_bidi_class_byname (\"White Space\") == UC_BIDI_WS);\n  ASSERT (uc_bidi_class_byname (\"White_Space\") == UC_BIDI_WS);\n  ASSERT (uc_bidi_class_byname (\"WhiteSpace\") == UC_BIDI_WS);\n\n  ASSERT (uc_bidi_class_byname (\"X\") < 0);\n  ASSERT (uc_bidi_class_byname (\"\") < 0);\n\n  return 0;\n}",
      "lines": 105,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-bidi_longname.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nmain ()\n{\n  ASSERT (strcmp (uc_bidi_class_long_name (UC_BIDI_AL), \"Arabic Letter\") == 0);\n  ASSERT (strcmp (uc_bidi_class_long_name (UC_BIDI_AN), \"Arabic Number\") == 0);\n  ASSERT (strcmp (uc_bidi_class_long_name (UC_BIDI_B), \"Paragraph Separator\") == 0);\n  ASSERT (strcmp (uc_bidi_class_long_name (UC_BIDI_BN), \"Boundary Neutral\") == 0);\n  ASSERT (strcmp (uc_bidi_class_long_name (UC_BIDI_CS), \"Common Separator\") == 0);\n  ASSERT (strcmp (uc_bidi_class_long_name (UC_BIDI_EN), \"European Number\") == 0);\n  ASSERT (strcmp (uc_bidi_class_long_name (UC_BIDI_ES), \"European Separator\") == 0);\n  ASSERT (strcmp (uc_bidi_class_long_name (UC_BIDI_ET), \"European Terminator\") == 0);\n  ASSERT (strcmp (uc_bidi_class_long_name (UC_BIDI_L), \"Left To Right\") == 0);\n  ASSERT (strcmp (uc_bidi_class_long_name (UC_BIDI_LRE), \"Left To Right Embedding\") == 0);\n  ASSERT (strcmp (uc_bidi_class_long_name (UC_BIDI_LRO), \"Left To Right Override\") == 0);\n  ASSERT (strcmp (uc_bidi_class_long_name (UC_BIDI_NSM), \"Nonspacing Mark\") == 0);\n  ASSERT (strcmp (uc_bidi_class_long_name (UC_BIDI_ON), \"Other Neutral\") == 0);\n  ASSERT (strcmp (uc_bidi_class_long_name (UC_BIDI_PDF), \"Pop Directional Format\") == 0);\n  ASSERT (strcmp (uc_bidi_class_long_name (UC_BIDI_R), \"Right To Left\") == 0);\n  ASSERT (strcmp (uc_bidi_class_long_name (UC_BIDI_RLE), \"Right To Left Embedding\") == 0);\n  ASSERT (strcmp (uc_bidi_class_long_name (UC_BIDI_RLO), \"Right To Left Override\") == 0);\n  ASSERT (strcmp (uc_bidi_class_long_name (UC_BIDI_S), \"Segment Separator\") == 0);\n  ASSERT (strcmp (uc_bidi_class_long_name (UC_BIDI_WS), \"White Space\") == 0);\n  ASSERT (uc_bidi_class_long_name (-1) == NULL);\n\n  return 0;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-bidi_name.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "int\nmain ()\n{\n  ASSERT (strcmp (uc_bidi_class_name (UC_BIDI_NSM), \"NSM\") == 0);\n  ASSERT (uc_bidi_class_name (-1) == NULL);\n\n  return 0;\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-bidi_of.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nmain ()\n{\n  ASSERT (uc_bidi_class ('x') == UC_BIDI_L);\n  ASSERT (uc_bidi_class (0x05D7) == UC_BIDI_R);\n  ASSERT (uc_bidi_class ('7') == UC_BIDI_EN);\n\n  return 0;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-bidi_test.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "int\nmain ()\n{\n  ASSERT (uc_is_bidi_class ('x', UC_BIDI_L));\n  ASSERT (!uc_is_bidi_class ('x', UC_BIDI_R));\n  ASSERT (!uc_is_bidi_class ('x', UC_BIDI_EN));\n\n  ASSERT (uc_is_bidi_class (0x05D7, UC_BIDI_R));\n  ASSERT (!uc_is_bidi_class (0x05D7, UC_BIDI_L));\n  ASSERT (!uc_is_bidi_class (0x05D7, UC_BIDI_EN));\n\n  ASSERT (uc_is_bidi_class ('7', UC_BIDI_EN));\n  ASSERT (!uc_is_bidi_class ('7', UC_BIDI_L));\n  ASSERT (!uc_is_bidi_class ('7', UC_BIDI_R));\n\n  {\n    unsigned int c;\n\n    for (c = 0; c < 0x110000; c++)\n      ASSERT (uc_is_bidi_class (c, uc_bidi_class (c)));\n  }\n\n  return 0;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-block_list.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nmain ()\n{\n  const uc_block_t *blocks;\n  size_t nblocks;\n\n  uc_all_blocks (&blocks, &nblocks);\n\n  {\n    const uc_block_t *latin_block = NULL;\n    const uc_block_t *hebrew_block = NULL;\n    size_t i;\n\n    for (i = 0; i < nblocks; i++)\n      {\n        if (strcmp (blocks[i].name, \"Latin\") == 0)\n          latin_block = &blocks[i];\n        if (strcmp (blocks[i].name, \"Hebrew\") == 0)\n          hebrew_block = &blocks[i];\n      }\n    ASSERT (latin_block == NULL);\n    ASSERT (hebrew_block != NULL);\n  }\n\n  return 0;\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-block_of.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "int\nmain ()\n{\n  ASSERT (strcmp (uc_block ('x')->name, \"Basic Latin\") == 0);\n  ASSERT (strcmp (uc_block (0x20AC)->name, \"Currency Symbols\") == 0);\n\n  {\n    unsigned int c;\n\n    for (c = 0; c < 0x110000; c++)\n      {\n        const uc_block_t *block = uc_block (c);\n        ASSERT (block == NULL || uc_is_block (c, block));\n      }\n  }\n\n  {\n    const uc_block_t *blocks;\n    size_t nblocks;\n    size_t i;\n\n    uc_all_blocks (&blocks, &nblocks);\n\n    for (i = 0; i < nblocks; i++)\n      {\n        if (strcmp (blocks[i].name, \"Hebrew\") == 0)\n          {\n            ASSERT (uc_block (0x05DE) == &blocks[i]);\n            ASSERT (uc_is_block (0x05DE, &blocks[i]));\n          }\n      }\n\n    for (i = 0; i < nblocks; i++)\n      {\n        unsigned int c;\n\n        for (c = blocks[i].start; c <= blocks[i].end; c++)\n          ASSERT (uc_block (c) == &blocks[i]);\n      }\n  }\n\n  return 0;\n}",
      "lines": 43,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-block_test.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "int\nmain ()\n{\n  uc_block_t b;\n\n  b.start = 0x20000;\n  b.end = 0x2A6D6;\n  b.name = \"CJK Supplemental Area\";\n\n  ASSERT (!uc_is_block (0x5678, &b));\n  ASSERT (!uc_is_block (0x1FFFF, &b));\n  ASSERT (uc_is_block (0x20000, &b));\n  ASSERT (uc_is_block (0x25678, &b));\n  ASSERT (uc_is_block (0x2A6D6, &b));\n  ASSERT (!uc_is_block (0x2A6D7, &b));\n\n  return 0;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_and.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nmain ()\n{\n  uc_general_category_t ct =\n    uc_general_category_and (\n      uc_general_category_or (UC_LETTER, UC_DECIMAL_DIGIT_NUMBER),\n      uc_general_category_or (UC_UPPERCASE_LETTER, UC_NUMBER));\n\n  ASSERT (uc_is_general_category ('A', ct));\n  ASSERT (!uc_is_general_category ('a', ct));\n  ASSERT (uc_is_general_category ('7', ct));\n  ASSERT (!uc_is_general_category (0x00B2, ct));\n\n  return 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_and_not.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nmain ()\n{\n  uc_general_category_t ct =\n    uc_general_category_and_not (\n      uc_general_category_or (UC_LETTER, UC_NUMBER),\n      uc_general_category_or (UC_UPPERCASE_LETTER, UC_DECIMAL_DIGIT_NUMBER));\n\n  ASSERT (!uc_is_general_category ('A', ct));\n  ASSERT (uc_is_general_category ('a', ct));\n  ASSERT (!uc_is_general_category ('7', ct));\n  ASSERT (uc_is_general_category (0x00B2, ct));\n\n  return 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_byname.c": {
    "category_equals": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "static bool\ncategory_equals (uc_general_category_t category1,\n                 uc_general_category_t category2)\n{\n  return (category1.bitmask == category2.bitmask\n          && category1.generic == category2.generic\n          && (category1.generic\n              ? category1.lookup.lookup_fn == category2.lookup.lookup_fn\n              : category1.lookup.table == category2.lookup.table));\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "main": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        230,
        1
      ],
      "content": "int\nmain ()\n{\n  ASSERT (category_equals (uc_general_category_byname (\"L\"), UC_CATEGORY_L));\n  ASSERT (category_equals (uc_general_category_byname (\"LC\"), UC_CATEGORY_LC));\n  ASSERT (category_equals (uc_general_category_byname (\"Lu\"), UC_CATEGORY_Lu));\n  ASSERT (category_equals (uc_general_category_byname (\"Ll\"), UC_CATEGORY_Ll));\n  ASSERT (category_equals (uc_general_category_byname (\"Lt\"), UC_CATEGORY_Lt));\n  ASSERT (category_equals (uc_general_category_byname (\"Lm\"), UC_CATEGORY_Lm));\n  ASSERT (category_equals (uc_general_category_byname (\"Lo\"), UC_CATEGORY_Lo));\n  ASSERT (category_equals (uc_general_category_byname (\"M\"), UC_CATEGORY_M));\n  ASSERT (category_equals (uc_general_category_byname (\"Mn\"), UC_CATEGORY_Mn));\n  ASSERT (category_equals (uc_general_category_byname (\"Mc\"), UC_CATEGORY_Mc));\n  ASSERT (category_equals (uc_general_category_byname (\"Me\"), UC_CATEGORY_Me));\n  ASSERT (category_equals (uc_general_category_byname (\"N\"), UC_CATEGORY_N));\n  ASSERT (category_equals (uc_general_category_byname (\"Nd\"), UC_CATEGORY_Nd));\n  ASSERT (category_equals (uc_general_category_byname (\"Nl\"), UC_CATEGORY_Nl));\n  ASSERT (category_equals (uc_general_category_byname (\"No\"), UC_CATEGORY_No));\n  ASSERT (category_equals (uc_general_category_byname (\"P\"), UC_CATEGORY_P));\n  ASSERT (category_equals (uc_general_category_byname (\"Pc\"), UC_CATEGORY_Pc));\n  ASSERT (category_equals (uc_general_category_byname (\"Pd\"), UC_CATEGORY_Pd));\n  ASSERT (category_equals (uc_general_category_byname (\"Ps\"), UC_CATEGORY_Ps));\n  ASSERT (category_equals (uc_general_category_byname (\"Pe\"), UC_CATEGORY_Pe));\n  ASSERT (category_equals (uc_general_category_byname (\"Pi\"), UC_CATEGORY_Pi));\n  ASSERT (category_equals (uc_general_category_byname (\"Pf\"), UC_CATEGORY_Pf));\n  ASSERT (category_equals (uc_general_category_byname (\"Po\"), UC_CATEGORY_Po));\n  ASSERT (category_equals (uc_general_category_byname (\"S\"), UC_CATEGORY_S));\n  ASSERT (category_equals (uc_general_category_byname (\"Sm\"), UC_CATEGORY_Sm));\n  ASSERT (category_equals (uc_general_category_byname (\"Sc\"), UC_CATEGORY_Sc));\n  ASSERT (category_equals (uc_general_category_byname (\"Sk\"), UC_CATEGORY_Sk));\n  ASSERT (category_equals (uc_general_category_byname (\"So\"), UC_CATEGORY_So));\n  ASSERT (category_equals (uc_general_category_byname (\"Z\"), UC_CATEGORY_Z));\n  ASSERT (category_equals (uc_general_category_byname (\"Zs\"), UC_CATEGORY_Zs));\n  ASSERT (category_equals (uc_general_category_byname (\"Zl\"), UC_CATEGORY_Zl));\n  ASSERT (category_equals (uc_general_category_byname (\"Zp\"), UC_CATEGORY_Zp));\n  ASSERT (category_equals (uc_general_category_byname (\"C\"), UC_CATEGORY_C));\n  ASSERT (category_equals (uc_general_category_byname (\"Cc\"), UC_CATEGORY_Cc));\n  ASSERT (category_equals (uc_general_category_byname (\"Cf\"), UC_CATEGORY_Cf));\n  ASSERT (category_equals (uc_general_category_byname (\"Cs\"), UC_CATEGORY_Cs));\n  ASSERT (category_equals (uc_general_category_byname (\"Co\"), UC_CATEGORY_Co));\n  ASSERT (category_equals (uc_general_category_byname (\"Cn\"), UC_CATEGORY_Cn));\n\n  ASSERT (category_equals (uc_general_category_byname (\"LETTER\"), UC_CATEGORY_L));\n  ASSERT (category_equals (uc_general_category_byname (\"Letter\"), UC_CATEGORY_L));\n  ASSERT (category_equals (uc_general_category_byname (\"CASED LETTER\"), UC_CATEGORY_LC));\n  ASSERT (category_equals (uc_general_category_byname (\"Cased Letter\"), UC_CATEGORY_LC));\n  ASSERT (category_equals (uc_general_category_byname (\"Cased_Letter\"), UC_CATEGORY_LC));\n  ASSERT (category_equals (uc_general_category_byname (\"CasedLetter\"), UC_CATEGORY_LC));\n  ASSERT (category_equals (uc_general_category_byname (\"UPPERCASE LETTER\"), UC_CATEGORY_Lu));\n  ASSERT (category_equals (uc_general_category_byname (\"Uppercase Letter\"), UC_CATEGORY_Lu));\n  ASSERT (category_equals (uc_general_category_byname (\"Uppercase_Letter\"), UC_CATEGORY_Lu));\n  ASSERT (category_equals (uc_general_category_byname (\"UppercaseLetter\"), UC_CATEGORY_Lu));\n  ASSERT (category_equals (uc_general_category_byname (\"LOWERCASE LETTER\"), UC_CATEGORY_Ll));\n  ASSERT (category_equals (uc_general_category_byname (\"Lowercase Letter\"), UC_CATEGORY_Ll));\n  ASSERT (category_equals (uc_general_category_byname (\"Lowercase_Letter\"), UC_CATEGORY_Ll));\n  ASSERT (category_equals (uc_general_category_byname (\"LowercaseLetter\"), UC_CATEGORY_Ll));\n  ASSERT (category_equals (uc_general_category_byname (\"TITLECASE LETTER\"), UC_CATEGORY_Lt));\n  ASSERT (category_equals (uc_general_category_byname (\"Titlecase Letter\"), UC_CATEGORY_Lt));\n  ASSERT (category_equals (uc_general_category_byname (\"Titlecase_Letter\"), UC_CATEGORY_Lt));\n  ASSERT (category_equals (uc_general_category_byname (\"TitlecaseLetter\"), UC_CATEGORY_Lt));\n  ASSERT (category_equals (uc_general_category_byname (\"MODIFIER LETTER\"), UC_CATEGORY_Lm));\n  ASSERT (category_equals (uc_general_category_byname (\"Modifier Letter\"), UC_CATEGORY_Lm));\n  ASSERT (category_equals (uc_general_category_byname (\"Modifier_Letter\"), UC_CATEGORY_Lm));\n  ASSERT (category_equals (uc_general_category_byname (\"ModifierLetter\"), UC_CATEGORY_Lm));\n  ASSERT (category_equals (uc_general_category_byname (\"OTHER LETTER\"), UC_CATEGORY_Lo));\n  ASSERT (category_equals (uc_general_category_byname (\"Other Letter\"), UC_CATEGORY_Lo));\n  ASSERT (category_equals (uc_general_category_byname (\"Other_Letter\"), UC_CATEGORY_Lo));\n  ASSERT (category_equals (uc_general_category_byname (\"OtherLetter\"), UC_CATEGORY_Lo));\n  ASSERT (category_equals (uc_general_category_byname (\"MARK\"), UC_CATEGORY_M));\n  ASSERT (category_equals (uc_general_category_byname (\"Mark\"), UC_CATEGORY_M));\n  ASSERT (category_equals (uc_general_category_byname (\"NONSPACING MARK\"), UC_CATEGORY_Mn));\n  ASSERT (category_equals (uc_general_category_byname (\"Nonspacing Mark\"), UC_CATEGORY_Mn));\n  ASSERT (category_equals (uc_general_category_byname (\"Nonspacing_Mark\"), UC_CATEGORY_Mn));\n  ASSERT (category_equals (uc_general_category_byname (\"NonspacingMark\"), UC_CATEGORY_Mn));\n  ASSERT (category_equals (uc_general_category_byname (\"SPACING MARK\"), UC_CATEGORY_Mc));\n  ASSERT (category_equals (uc_general_category_byname (\"Spacing Mark\"), UC_CATEGORY_Mc));\n  ASSERT (category_equals (uc_general_category_byname (\"Spacing_Mark\"), UC_CATEGORY_Mc));\n  ASSERT (category_equals (uc_general_category_byname (\"SpacingMark\"), UC_CATEGORY_Mc));\n  ASSERT (category_equals (uc_general_category_byname (\"ENCLOSING MARK\"), UC_CATEGORY_Me));\n  ASSERT (category_equals (uc_general_category_byname (\"Enclosing Mark\"), UC_CATEGORY_Me));\n  ASSERT (category_equals (uc_general_category_byname (\"Enclosing_Mark\"), UC_CATEGORY_Me));\n  ASSERT (category_equals (uc_general_category_byname (\"EnclosingMark\"), UC_CATEGORY_Me));\n  ASSERT (category_equals (uc_general_category_byname (\"NUMBER\"), UC_CATEGORY_N));\n  ASSERT (category_equals (uc_general_category_byname (\"Number\"), UC_CATEGORY_N));\n  ASSERT (category_equals (uc_general_category_byname (\"DECIMAL NUMBER\"), UC_CATEGORY_Nd));\n  ASSERT (category_equals (uc_general_category_byname (\"Decimal Number\"), UC_CATEGORY_Nd));\n  ASSERT (category_equals (uc_general_category_byname (\"Decimal_Number\"), UC_CATEGORY_Nd));\n  ASSERT (category_equals (uc_general_category_byname (\"DecimalNumber\"), UC_CATEGORY_Nd));\n  ASSERT (category_equals (uc_general_category_byname (\"LETTER NUMBER\"), UC_CATEGORY_Nl));\n  ASSERT (category_equals (uc_general_category_byname (\"Letter Number\"), UC_CATEGORY_Nl));\n  ASSERT (category_equals (uc_general_category_byname (\"Letter_Number\"), UC_CATEGORY_Nl));\n  ASSERT (category_equals (uc_general_category_byname (\"LetterNumber\"), UC_CATEGORY_Nl));\n  ASSERT (category_equals (uc_general_category_byname (\"OTHER NUMBER\"), UC_CATEGORY_No));\n  ASSERT (category_equals (uc_general_category_byname (\"Other Number\"), UC_CATEGORY_No));\n  ASSERT (category_equals (uc_general_category_byname (\"Other_Number\"), UC_CATEGORY_No));\n  ASSERT (category_equals (uc_general_category_byname (\"OtherNumber\"), UC_CATEGORY_No));\n  ASSERT (category_equals (uc_general_category_byname (\"PUNCTUATION\"), UC_CATEGORY_P));\n  ASSERT (category_equals (uc_general_category_byname (\"Punctuation\"), UC_CATEGORY_P));\n  ASSERT (category_equals (uc_general_category_byname (\"CONNECTOR PUNCTUATION\"), UC_CATEGORY_Pc));\n  ASSERT (category_equals (uc_general_category_byname (\"Connector Punctuation\"), UC_CATEGORY_Pc));\n  ASSERT (category_equals (uc_general_category_byname (\"Connector_Punctuation\"), UC_CATEGORY_Pc));\n  ASSERT (category_equals (uc_general_category_byname (\"ConnectorPunctuation\"), UC_CATEGORY_Pc));\n  ASSERT (category_equals (uc_general_category_byname (\"DASH PUNCTUATION\"), UC_CATEGORY_Pd));\n  ASSERT (category_equals (uc_general_category_byname (\"Dash Punctuation\"), UC_CATEGORY_Pd));\n  ASSERT (category_equals (uc_general_category_byname (\"Dash_Punctuation\"), UC_CATEGORY_Pd));\n  ASSERT (category_equals (uc_general_category_byname (\"DashPunctuation\"), UC_CATEGORY_Pd));\n  ASSERT (category_equals (uc_general_category_byname (\"OPEN PUNCTUATION\"), UC_CATEGORY_Ps));\n  ASSERT (category_equals (uc_general_category_byname (\"Open Punctuation\"), UC_CATEGORY_Ps));\n  ASSERT (category_equals (uc_general_category_byname (\"Open_Punctuation\"), UC_CATEGORY_Ps));\n  ASSERT (category_equals (uc_general_category_byname (\"OpenPunctuation\"), UC_CATEGORY_Ps));\n  ASSERT (category_equals (uc_general_category_byname (\"CLOSE PUNCTUATION\"), UC_CATEGORY_Pe));\n  ASSERT (category_equals (uc_general_category_byname (\"Close Punctuation\"), UC_CATEGORY_Pe));\n  ASSERT (category_equals (uc_general_category_byname (\"Close_Punctuation\"), UC_CATEGORY_Pe));\n  ASSERT (category_equals (uc_general_category_byname (\"ClosePunctuation\"), UC_CATEGORY_Pe));\n  ASSERT (category_equals (uc_general_category_byname (\"INITIAL PUNCTUATION\"), UC_CATEGORY_Pi));\n  ASSERT (category_equals (uc_general_category_byname (\"Initial Punctuation\"), UC_CATEGORY_Pi));\n  ASSERT (category_equals (uc_general_category_byname (\"Initial_Punctuation\"), UC_CATEGORY_Pi));\n  ASSERT (category_equals (uc_general_category_byname (\"InitialPunctuation\"), UC_CATEGORY_Pi));\n  ASSERT (category_equals (uc_general_category_byname (\"FINAL PUNCTUATION\"), UC_CATEGORY_Pf));\n  ASSERT (category_equals (uc_general_category_byname (\"Final Punctuation\"), UC_CATEGORY_Pf));\n  ASSERT (category_equals (uc_general_category_byname (\"Final_Punctuation\"), UC_CATEGORY_Pf));\n  ASSERT (category_equals (uc_general_category_byname (\"FinalPunctuation\"), UC_CATEGORY_Pf));\n  ASSERT (category_equals (uc_general_category_byname (\"OTHER PUNCTUATION\"), UC_CATEGORY_Po));\n  ASSERT (category_equals (uc_general_category_byname (\"Other Punctuation\"), UC_CATEGORY_Po));\n  ASSERT (category_equals (uc_general_category_byname (\"Other_Punctuation\"), UC_CATEGORY_Po));\n  ASSERT (category_equals (uc_general_category_byname (\"OtherPunctuation\"), UC_CATEGORY_Po));\n  ASSERT (category_equals (uc_general_category_byname (\"SYMBOL\"), UC_CATEGORY_S));\n  ASSERT (category_equals (uc_general_category_byname (\"Symbol\"), UC_CATEGORY_S));\n  ASSERT (category_equals (uc_general_category_byname (\"MATH SYMBOL\"), UC_CATEGORY_Sm));\n  ASSERT (category_equals (uc_general_category_byname (\"Math Symbol\"), UC_CATEGORY_Sm));\n  ASSERT (category_equals (uc_general_category_byname (\"Math_Symbol\"), UC_CATEGORY_Sm));\n  ASSERT (category_equals (uc_general_category_byname (\"MathSymbol\"), UC_CATEGORY_Sm));\n  ASSERT (category_equals (uc_general_category_byname (\"CURRENCY SYMBOL\"), UC_CATEGORY_Sc));\n  ASSERT (category_equals (uc_general_category_byname (\"Currency Symbol\"), UC_CATEGORY_Sc));\n  ASSERT (category_equals (uc_general_category_byname (\"Currency_Symbol\"), UC_CATEGORY_Sc));\n  ASSERT (category_equals (uc_general_category_byname (\"CurrencySymbol\"), UC_CATEGORY_Sc));\n  ASSERT (category_equals (uc_general_category_byname (\"MODIFIER SYMBOL\"), UC_CATEGORY_Sk));\n  ASSERT (category_equals (uc_general_category_byname (\"Modifier Symbol\"), UC_CATEGORY_Sk));\n  ASSERT (category_equals (uc_general_category_byname (\"Modifier_Symbol\"), UC_CATEGORY_Sk));\n  ASSERT (category_equals (uc_general_category_byname (\"ModifierSymbol\"), UC_CATEGORY_Sk));\n  ASSERT (category_equals (uc_general_category_byname (\"OTHER SYMBOL\"), UC_CATEGORY_So));\n  ASSERT (category_equals (uc_general_category_byname (\"Other Symbol\"), UC_CATEGORY_So));\n  ASSERT (category_equals (uc_general_category_byname (\"Other_Symbol\"), UC_CATEGORY_So));\n  ASSERT (category_equals (uc_general_category_byname (\"OtherSymbol\"), UC_CATEGORY_So));\n  ASSERT (category_equals (uc_general_category_byname (\"SEPARATOR\"), UC_CATEGORY_Z));\n  ASSERT (category_equals (uc_general_category_byname (\"Separator\"), UC_CATEGORY_Z));\n  ASSERT (category_equals (uc_general_category_byname (\"SPACE SEPARATOR\"), UC_CATEGORY_Zs));\n  ASSERT (category_equals (uc_general_category_byname (\"Space Separator\"), UC_CATEGORY_Zs));\n  ASSERT (category_equals (uc_general_category_byname (\"Space_Separator\"), UC_CATEGORY_Zs));\n  ASSERT (category_equals (uc_general_category_byname (\"SpaceSeparator\"), UC_CATEGORY_Zs));\n  ASSERT (category_equals (uc_general_category_byname (\"LINE SEPARATOR\"), UC_CATEGORY_Zl));\n  ASSERT (category_equals (uc_general_category_byname (\"Line Separator\"), UC_CATEGORY_Zl));\n  ASSERT (category_equals (uc_general_category_byname (\"Line_Separator\"), UC_CATEGORY_Zl));\n  ASSERT (category_equals (uc_general_category_byname (\"LineSeparator\"), UC_CATEGORY_Zl));\n  ASSERT (category_equals (uc_general_category_byname (\"PARAGRAPH SEPARATOR\"), UC_CATEGORY_Zp));\n  ASSERT (category_equals (uc_general_category_byname (\"Paragraph Separator\"), UC_CATEGORY_Zp));\n  ASSERT (category_equals (uc_general_category_byname (\"Paragraph_Separator\"), UC_CATEGORY_Zp));\n  ASSERT (category_equals (uc_general_category_byname (\"ParagraphSeparator\"), UC_CATEGORY_Zp));\n  ASSERT (category_equals (uc_general_category_byname (\"OTHER\"), UC_CATEGORY_C));\n  ASSERT (category_equals (uc_general_category_byname (\"Other\"), UC_CATEGORY_C));\n  ASSERT (category_equals (uc_general_category_byname (\"CONTROL\"), UC_CATEGORY_Cc));\n  ASSERT (category_equals (uc_general_category_byname (\"Control\"), UC_CATEGORY_Cc));\n  ASSERT (category_equals (uc_general_category_byname (\"FORMAT\"), UC_CATEGORY_Cf));\n  ASSERT (category_equals (uc_general_category_byname (\"Format\"), UC_CATEGORY_Cf));\n  ASSERT (category_equals (uc_general_category_byname (\"SURROGATE\"), UC_CATEGORY_Cs));\n  ASSERT (category_equals (uc_general_category_byname (\"Surrogate\"), UC_CATEGORY_Cs));\n  ASSERT (category_equals (uc_general_category_byname (\"PRIVATE USE\"), UC_CATEGORY_Co));\n  ASSERT (category_equals (uc_general_category_byname (\"Private Use\"), UC_CATEGORY_Co));\n  ASSERT (category_equals (uc_general_category_byname (\"Private_Use\"), UC_CATEGORY_Co));\n  ASSERT (category_equals (uc_general_category_byname (\"PrivateUse\"), UC_CATEGORY_Co));\n  ASSERT (category_equals (uc_general_category_byname (\"UNASSIGNED\"), UC_CATEGORY_Cn));\n  ASSERT (category_equals (uc_general_category_byname (\"Unassigned\"), UC_CATEGORY_Cn));\n\n  uc_general_category_byname (\"Nl\");\n\n  {\n    uc_general_category_t ct = uc_general_category_byname (\"Nd\");\n    unsigned int c;\n\n    for (c = 0x30; c <= 0x39; c++)\n      ASSERT (uc_is_general_category (c, ct));\n    for (c = 0x40; c < 0x80; c++)\n      ASSERT (!uc_is_general_category (c, ct));\n  }\n\n  {\n    uc_general_category_t ct = uc_general_category_byname (\"Foo\");\n    unsigned int c;\n\n    for (c = 0; c < 0x110000; c++)\n      ASSERT (!uc_is_general_category (c, ct));\n  }\n\n  return 0;\n}",
      "lines": 195,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_C.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_Cc.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_Cf.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_Cn.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_Co.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_Cs.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_L.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_LC.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_Ll.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_Lm.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_Lo.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_longname.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nmain ()\n{\n  ASSERT (strcmp (uc_general_category_long_name (UC_CATEGORY_Z), \"Separator\") == 0);\n  ASSERT (strcmp (uc_general_category_long_name (UC_CATEGORY_Nl), \"Letter Number\") == 0);\n  ASSERT (uc_general_category_long_name (uc_general_category_or (UC_CATEGORY_Z, UC_CATEGORY_Nl)) == NULL);\n\n  return 0;\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_Lt.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_Lu.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_M.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_Mc.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_Me.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_Mn.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_N.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_name.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nmain ()\n{\n  ASSERT (strcmp (uc_general_category_name (UC_CATEGORY_Z), \"Z\") == 0);\n  ASSERT (strcmp (uc_general_category_name (UC_CATEGORY_Nl), \"Nl\") == 0);\n  ASSERT (uc_general_category_name (uc_general_category_or (UC_CATEGORY_Z, UC_CATEGORY_Nl)) == NULL);\n\n  return 0;\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_Nd.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_Nl.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_No.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_none.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "int\nmain ()\n{\n  uc_general_category_t ct = _UC_CATEGORY_NONE;\n  unsigned int c;\n\n  for (c = 0; c < 0x110000; c++)\n    ASSERT (!uc_is_general_category (c, ct));\n\n  return 0;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_of.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int\nmain ()\n{\n  {\n    unsigned int c;\n    for (c = 0; c < 0x110000; c++)\n      ASSERT (uc_is_general_category (c, uc_general_category (c)));\n  }\n\n  {\n    uc_general_category_t decimal_digits = uc_general_category ('7');\n    unsigned int c;\n\n    for (c = 0x30; c <= 0x39; c++)\n      ASSERT (uc_is_general_category (c, decimal_digits));\n    for (c = 0x40; c < 0x80; c++)\n      ASSERT (!uc_is_general_category (c, decimal_digits));\n  }\n\n  {\n    uc_general_category_t lowercase_letters = uc_general_category ('x');\n    unsigned int c;\n\n    for (c = 0x41; c <= 0x5A; c++)\n      ASSERT (!uc_is_general_category (c, lowercase_letters));\n    for (c = 0x61; c <= 0x7A; c++)\n      ASSERT (uc_is_general_category (c, lowercase_letters));\n  }\n\n  return 0;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_or.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "int\nmain ()\n{\n  uc_general_category_t ct =\n    uc_general_category_or (UC_LETTER, UC_NUMBER);\n\n  ASSERT (uc_is_general_category ('a', ct));\n  ASSERT (uc_is_general_category ('7', ct));\n  ASSERT (!uc_is_general_category ('$', ct));\n\n  return 0;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_P.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_Pc.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_Pd.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_Pe.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_Pf.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_Pi.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_Po.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_Ps.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_S.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_Sc.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_Sk.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_Sm.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_So.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_test_withtable.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "int\nmain ()\n{\n  uint32_t ctmask =\n    (UC_CATEGORY_MASK_L | UC_CATEGORY_MASK_N)\n    & ~(UC_CATEGORY_MASK_Lu | UC_CATEGORY_MASK_Nd);\n\n  ASSERT (!uc_is_general_category_withtable ('A', ctmask));\n  ASSERT (uc_is_general_category_withtable ('a', ctmask));\n  ASSERT (!uc_is_general_category_withtable ('7', ctmask));\n  ASSERT (uc_is_general_category_withtable (0x00B2, ctmask));\n\n  return 0;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_Z.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_Zl.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_Zp.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-categ_Zs.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-combiningclass.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "int\nmain ()\n{\n  ASSERT (uc_combining_class ('x') == UC_CCC_NR);\n  ASSERT (uc_combining_class (0x0300) == UC_CCC_A);\n  ASSERT (uc_combining_class (0x0319) == UC_CCC_B);\n  ASSERT (uc_combining_class (0x0327) == UC_CCC_ATB);\n  ASSERT (uc_combining_class (0x093C) == UC_CCC_NK);\n\n  return 0;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-combiningclass_byname.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "int\nmain ()\n{\n  ASSERT (uc_combining_class_byname (\"NR\") == UC_CCC_NR);\n  ASSERT (uc_combining_class_byname (\"OV\") == UC_CCC_OV);\n  ASSERT (uc_combining_class_byname (\"NK\") == UC_CCC_NK);\n  ASSERT (uc_combining_class_byname (\"KV\") == UC_CCC_KV);\n  ASSERT (uc_combining_class_byname (\"VR\") == UC_CCC_VR);\n  ASSERT (uc_combining_class_byname (\"ATBL\") == UC_CCC_ATBL);\n  ASSERT (uc_combining_class_byname (\"ATB\") == UC_CCC_ATB);\n  ASSERT (uc_combining_class_byname (\"ATA\") == UC_CCC_ATA);\n  ASSERT (uc_combining_class_byname (\"ATAR\") == UC_CCC_ATAR);\n  ASSERT (uc_combining_class_byname (\"BL\") == UC_CCC_BL);\n  ASSERT (uc_combining_class_byname (\"B\") == UC_CCC_B);\n  ASSERT (uc_combining_class_byname (\"BR\") == UC_CCC_BR);\n  ASSERT (uc_combining_class_byname (\"L\") == UC_CCC_L);\n  ASSERT (uc_combining_class_byname (\"R\") == UC_CCC_R);\n  ASSERT (uc_combining_class_byname (\"AL\") == UC_CCC_AL);\n  ASSERT (uc_combining_class_byname (\"A\") == UC_CCC_A);\n  ASSERT (uc_combining_class_byname (\"AR\") == UC_CCC_AR);\n  ASSERT (uc_combining_class_byname (\"DB\") == UC_CCC_DB);\n  ASSERT (uc_combining_class_byname (\"DA\") == UC_CCC_DA);\n  ASSERT (uc_combining_class_byname (\"IS\") == UC_CCC_IS);\n\n  ASSERT (uc_combining_class_byname (\"NOT REORDERED\") == UC_CCC_NR);\n  ASSERT (uc_combining_class_byname (\"Not Reordered\") == UC_CCC_NR);\n  ASSERT (uc_combining_class_byname (\"Not_Reordered\") == UC_CCC_NR);\n  ASSERT (uc_combining_class_byname (\"NotReordered\") == UC_CCC_NR);\n  ASSERT (uc_combining_class_byname (\"OVERLAY\") == UC_CCC_OV);\n  ASSERT (uc_combining_class_byname (\"Overlay\") == UC_CCC_OV);\n  ASSERT (uc_combining_class_byname (\"NUKTA\") == UC_CCC_NK);\n  ASSERT (uc_combining_class_byname (\"Nukta\") == UC_CCC_NK);\n  ASSERT (uc_combining_class_byname (\"KANA VOICING\") == UC_CCC_KV);\n  ASSERT (uc_combining_class_byname (\"Kana Voicing\") == UC_CCC_KV);\n  ASSERT (uc_combining_class_byname (\"Kana_Voicing\") == UC_CCC_KV);\n  ASSERT (uc_combining_class_byname (\"KanaVoicing\") == UC_CCC_KV);\n  ASSERT (uc_combining_class_byname (\"VIRAMA\") == UC_CCC_VR);\n  ASSERT (uc_combining_class_byname (\"Virama\") == UC_CCC_VR);\n  ASSERT (uc_combining_class_byname (\"ATTACHED BELOW LEFT\") == UC_CCC_ATBL);\n  ASSERT (uc_combining_class_byname (\"Attached Below Left\") == UC_CCC_ATBL);\n  ASSERT (uc_combining_class_byname (\"Attached_Below_Left\") == UC_CCC_ATBL);\n  ASSERT (uc_combining_class_byname (\"AttachedBelowLeft\") == UC_CCC_ATBL);\n  ASSERT (uc_combining_class_byname (\"ATTACHED BELOW\") == UC_CCC_ATB);\n  ASSERT (uc_combining_class_byname (\"Attached Below\") == UC_CCC_ATB);\n  ASSERT (uc_combining_class_byname (\"Attached_Below\") == UC_CCC_ATB);\n  ASSERT (uc_combining_class_byname (\"AttachedBelow\") == UC_CCC_ATB);\n  ASSERT (uc_combining_class_byname (\"ATTACHED ABOVE\") == UC_CCC_ATA);\n  ASSERT (uc_combining_class_byname (\"Attached Above\") == UC_CCC_ATA);\n  ASSERT (uc_combining_class_byname (\"Attached_Above\") == UC_CCC_ATA);\n  ASSERT (uc_combining_class_byname (\"AttachedAbove\") == UC_CCC_ATA);\n  ASSERT (uc_combining_class_byname (\"ATTACHED ABOVE RIGHT\") == UC_CCC_ATAR);\n  ASSERT (uc_combining_class_byname (\"Attached Above Right\") == UC_CCC_ATAR);\n  ASSERT (uc_combining_class_byname (\"Attached_Above_Right\") == UC_CCC_ATAR);\n  ASSERT (uc_combining_class_byname (\"AttachedAboveRight\") == UC_CCC_ATAR);\n  ASSERT (uc_combining_class_byname (\"BELOW LEFT\") == UC_CCC_BL);\n  ASSERT (uc_combining_class_byname (\"Below Left\") == UC_CCC_BL);\n  ASSERT (uc_combining_class_byname (\"Below_Left\") == UC_CCC_BL);\n  ASSERT (uc_combining_class_byname (\"BelowLeft\") == UC_CCC_BL);\n  ASSERT (uc_combining_class_byname (\"BELOW\") == UC_CCC_B);\n  ASSERT (uc_combining_class_byname (\"Below\") == UC_CCC_B);\n  ASSERT (uc_combining_class_byname (\"BELOW RIGHT\") == UC_CCC_BR);\n  ASSERT (uc_combining_class_byname (\"Below Right\") == UC_CCC_BR);\n  ASSERT (uc_combining_class_byname (\"Below_Right\") == UC_CCC_BR);\n  ASSERT (uc_combining_class_byname (\"BelowRight\") == UC_CCC_BR);\n  ASSERT (uc_combining_class_byname (\"LEFT\") == UC_CCC_L);\n  ASSERT (uc_combining_class_byname (\"Left\") == UC_CCC_L);\n  ASSERT (uc_combining_class_byname (\"RIGHT\") == UC_CCC_R);\n  ASSERT (uc_combining_class_byname (\"Right\") == UC_CCC_R);\n  ASSERT (uc_combining_class_byname (\"ABOVE LEFT\") == UC_CCC_AL);\n  ASSERT (uc_combining_class_byname (\"Above Left\") == UC_CCC_AL);\n  ASSERT (uc_combining_class_byname (\"Above_Left\") == UC_CCC_AL);\n  ASSERT (uc_combining_class_byname (\"AboveLeft\") == UC_CCC_AL);\n  ASSERT (uc_combining_class_byname (\"ABOVE\") == UC_CCC_A);\n  ASSERT (uc_combining_class_byname (\"ABOVE RIGHT\") == UC_CCC_AR);\n  ASSERT (uc_combining_class_byname (\"Above Right\") == UC_CCC_AR);\n  ASSERT (uc_combining_class_byname (\"Above_Right\") == UC_CCC_AR);\n  ASSERT (uc_combining_class_byname (\"AboveRight\") == UC_CCC_AR);\n  ASSERT (uc_combining_class_byname (\"DOUBLE BELOW\") == UC_CCC_DB);\n  ASSERT (uc_combining_class_byname (\"Double Below\") == UC_CCC_DB);\n  ASSERT (uc_combining_class_byname (\"Double_Below\") == UC_CCC_DB);\n  ASSERT (uc_combining_class_byname (\"DoubleBelow\") == UC_CCC_DB);\n  ASSERT (uc_combining_class_byname (\"DOUBLE ABOVE\") == UC_CCC_DA);\n  ASSERT (uc_combining_class_byname (\"Double Above\") == UC_CCC_DA);\n  ASSERT (uc_combining_class_byname (\"Double_Above\") == UC_CCC_DA);\n  ASSERT (uc_combining_class_byname (\"DoubleAbove\") == UC_CCC_DA);\n  ASSERT (uc_combining_class_byname (\"IOTA SUBSCRIPT\") == UC_CCC_IS);\n  ASSERT (uc_combining_class_byname (\"Iota Subscript\") == UC_CCC_IS);\n  ASSERT (uc_combining_class_byname (\"Iota_Subscript\") == UC_CCC_IS);\n  ASSERT (uc_combining_class_byname (\"IotaSubscript\") == UC_CCC_IS);\n\n  return 0;\n}",
      "lines": 92,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-combiningclass_longname.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "int\nmain ()\n{\n  ASSERT (strcmp (uc_combining_class_long_name (UC_CCC_NR), \"Not Reordered\") == 0);\n  ASSERT (strcmp (uc_combining_class_long_name (UC_CCC_OV), \"Overlay\") == 0);\n  ASSERT (strcmp (uc_combining_class_long_name (UC_CCC_NK), \"Nukta\") == 0);\n  ASSERT (strcmp (uc_combining_class_long_name (UC_CCC_KV), \"Kana Voicing\") == 0);\n  ASSERT (strcmp (uc_combining_class_long_name (UC_CCC_VR), \"Virama\") == 0);\n  ASSERT (strcmp (uc_combining_class_long_name (UC_CCC_ATBL), \"Attached Below Left\") == 0);\n  ASSERT (strcmp (uc_combining_class_long_name (UC_CCC_ATB), \"Attached Below\") == 0);\n  ASSERT (strcmp (uc_combining_class_long_name (UC_CCC_ATA), \"Attached Above\") == 0);\n  ASSERT (strcmp (uc_combining_class_long_name (UC_CCC_ATAR), \"Attached Above Right\") == 0);\n  ASSERT (strcmp (uc_combining_class_long_name (UC_CCC_BL), \"Below Left\") == 0);\n  ASSERT (strcmp (uc_combining_class_long_name (UC_CCC_B), \"Below\") == 0);\n  ASSERT (strcmp (uc_combining_class_long_name (UC_CCC_BR), \"Below Right\") == 0);\n  ASSERT (strcmp (uc_combining_class_long_name (UC_CCC_L), \"Left\") == 0);\n  ASSERT (strcmp (uc_combining_class_long_name (UC_CCC_R), \"Right\") == 0);\n  ASSERT (strcmp (uc_combining_class_long_name (UC_CCC_AL), \"Above Left\") == 0);\n  ASSERT (strcmp (uc_combining_class_long_name (UC_CCC_A), \"Above\") == 0);\n  ASSERT (strcmp (uc_combining_class_long_name (UC_CCC_AR), \"Above Right\") == 0);\n  ASSERT (strcmp (uc_combining_class_long_name (UC_CCC_DB), \"Double Below\") == 0);\n  ASSERT (strcmp (uc_combining_class_long_name (UC_CCC_DA), \"Double Above\") == 0);\n  ASSERT (strcmp (uc_combining_class_long_name (UC_CCC_IS), \"Iota Subscript\") == 0);\n  ASSERT (uc_combining_class_long_name (-5) == NULL);\n  ASSERT (uc_combining_class_long_name (163) == NULL);\n  ASSERT (uc_combining_class_long_name (255) == NULL);\n\n  return 0;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-combiningclass_name.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "int\nmain ()\n{\n  ASSERT (strcmp (uc_combining_class_name (UC_CCC_NR), \"NR\") == 0);\n  ASSERT (strcmp (uc_combining_class_name (UC_CCC_OV), \"OV\") == 0);\n  ASSERT (strcmp (uc_combining_class_name (UC_CCC_NK), \"NK\") == 0);\n  ASSERT (strcmp (uc_combining_class_name (UC_CCC_KV), \"KV\") == 0);\n  ASSERT (strcmp (uc_combining_class_name (UC_CCC_VR), \"VR\") == 0);\n  ASSERT (strcmp (uc_combining_class_name (UC_CCC_ATBL), \"ATBL\") == 0);\n  ASSERT (strcmp (uc_combining_class_name (UC_CCC_ATB), \"ATB\") == 0);\n  ASSERT (strcmp (uc_combining_class_name (UC_CCC_ATA), \"ATA\") == 0);\n  ASSERT (strcmp (uc_combining_class_name (UC_CCC_ATAR), \"ATAR\") == 0);\n  ASSERT (strcmp (uc_combining_class_name (UC_CCC_BL), \"BL\") == 0);\n  ASSERT (strcmp (uc_combining_class_name (UC_CCC_B), \"B\") == 0);\n  ASSERT (strcmp (uc_combining_class_name (UC_CCC_BR), \"BR\") == 0);\n  ASSERT (strcmp (uc_combining_class_name (UC_CCC_L), \"L\") == 0);\n  ASSERT (strcmp (uc_combining_class_name (UC_CCC_R), \"R\") == 0);\n  ASSERT (strcmp (uc_combining_class_name (UC_CCC_AL), \"AL\") == 0);\n  ASSERT (strcmp (uc_combining_class_name (UC_CCC_A), \"A\") == 0);\n  ASSERT (strcmp (uc_combining_class_name (UC_CCC_AR), \"AR\") == 0);\n  ASSERT (strcmp (uc_combining_class_name (UC_CCC_DB), \"DB\") == 0);\n  ASSERT (strcmp (uc_combining_class_name (UC_CCC_DA), \"DA\") == 0);\n  ASSERT (strcmp (uc_combining_class_name (UC_CCC_IS), \"IS\") == 0);\n  ASSERT (uc_combining_class_name (-5) == NULL);\n  ASSERT (uc_combining_class_name (163) == NULL);\n  ASSERT (uc_combining_class_name (255) == NULL);\n\n  return 0;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-ctype_alnum.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-ctype_alpha.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-ctype_blank.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-ctype_cntrl.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-ctype_digit.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-ctype_graph.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-ctype_lower.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-ctype_print.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-ctype_punct.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-ctype_space.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-ctype_upper.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-ctype_xdigit.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-decdigit.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nmain ()\n{\n  unsigned int c;\n  size_t i;\n\n  c = 0;\n  for (i = 0; i < SIZEOF (mapping); i++)\n    {\n      for (; c < mapping[i].ch; c++)\n        ASSERT (uc_decimal_value (c) == -1);\n      /* Here c = mapping[i].ch.  */\n      ASSERT (uc_decimal_value (c) == mapping[i].value);\n      c++;\n    }\n  for (; c < 0x110000; c++)\n    ASSERT (uc_decimal_value (c) == -1);\n\n  return 0;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-decdigit.h": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-digit.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nmain ()\n{\n  unsigned int c;\n  size_t i;\n\n  c = 0;\n  for (i = 0; i < SIZEOF (mapping); i++)\n    {\n      for (; c < mapping[i].ch; c++)\n        ASSERT (uc_digit_value (c) == -1);\n      /* Here c = mapping[i].ch.  */\n      ASSERT (uc_digit_value (c) == mapping[i].value);\n      c++;\n    }\n  for (; c < 0x110000; c++)\n    ASSERT (uc_digit_value (c) == -1);\n\n  return 0;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-digit.h": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-joininggroup_byname.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "int\nmain ()\n{\n  ASSERT (uc_joining_group_byname (\"NO JOINING GROUP\") == UC_JOINING_GROUP_NONE);\n  ASSERT (uc_joining_group_byname (\"No Joining Group\") == UC_JOINING_GROUP_NONE);\n  ASSERT (uc_joining_group_byname (\"No_Joining_Group\") == UC_JOINING_GROUP_NONE);\n  ASSERT (uc_joining_group_byname (\"NoJoiningGroup\") == UC_JOINING_GROUP_NONE);\n  ASSERT (uc_joining_group_byname (\"AIN\") == UC_JOINING_GROUP_AIN);\n  ASSERT (uc_joining_group_byname (\"Ain\") == UC_JOINING_GROUP_AIN);\n  ASSERT (uc_joining_group_byname (\"ALAPH\") == UC_JOINING_GROUP_ALAPH);\n  ASSERT (uc_joining_group_byname (\"Alaph\") == UC_JOINING_GROUP_ALAPH);\n  ASSERT (uc_joining_group_byname (\"ALEF\") == UC_JOINING_GROUP_ALEF);\n  ASSERT (uc_joining_group_byname (\"Alef\") == UC_JOINING_GROUP_ALEF);\n  ASSERT (uc_joining_group_byname (\"BEH\") == UC_JOINING_GROUP_BEH);\n  ASSERT (uc_joining_group_byname (\"Beh\") == UC_JOINING_GROUP_BEH);\n  ASSERT (uc_joining_group_byname (\"BETH\") == UC_JOINING_GROUP_BETH);\n  ASSERT (uc_joining_group_byname (\"Beth\") == UC_JOINING_GROUP_BETH);\n  ASSERT (uc_joining_group_byname (\"BURUSHASKI YEH BARREE\") == UC_JOINING_GROUP_BURUSHASKI_YEH_BARREE);\n  ASSERT (uc_joining_group_byname (\"Burushaski Yeh Barree\") == UC_JOINING_GROUP_BURUSHASKI_YEH_BARREE);\n  ASSERT (uc_joining_group_byname (\"Burushaski_Yeh_Barree\") == UC_JOINING_GROUP_BURUSHASKI_YEH_BARREE);\n  ASSERT (uc_joining_group_byname (\"BurushaskiYehBarree\") == UC_JOINING_GROUP_BURUSHASKI_YEH_BARREE);\n  ASSERT (uc_joining_group_byname (\"DAL\") == UC_JOINING_GROUP_DAL);\n  ASSERT (uc_joining_group_byname (\"Dal\") == UC_JOINING_GROUP_DAL);\n  ASSERT (uc_joining_group_byname (\"DALATH RISH\") == UC_JOINING_GROUP_DALATH_RISH);\n  ASSERT (uc_joining_group_byname (\"Dalath Rish\") == UC_JOINING_GROUP_DALATH_RISH);\n  ASSERT (uc_joining_group_byname (\"Dalath_Rish\") == UC_JOINING_GROUP_DALATH_RISH);\n  ASSERT (uc_joining_group_byname (\"DalathRish\") == UC_JOINING_GROUP_DALATH_RISH);\n  ASSERT (uc_joining_group_byname (\"E\") == UC_JOINING_GROUP_E);\n  ASSERT (uc_joining_group_byname (\"FARSI YEH\") == UC_JOINING_GROUP_FARSI_YEH);\n  ASSERT (uc_joining_group_byname (\"Farsi Yeh\") == UC_JOINING_GROUP_FARSI_YEH);\n  ASSERT (uc_joining_group_byname (\"Farsi_Yeh\") == UC_JOINING_GROUP_FARSI_YEH);\n  ASSERT (uc_joining_group_byname (\"FarsiYeh\") == UC_JOINING_GROUP_FARSI_YEH);\n  ASSERT (uc_joining_group_byname (\"FE\") == UC_JOINING_GROUP_FE);\n  ASSERT (uc_joining_group_byname (\"Fe\") == UC_JOINING_GROUP_FE);\n  ASSERT (uc_joining_group_byname (\"FEH\") == UC_JOINING_GROUP_FEH);\n  ASSERT (uc_joining_group_byname (\"Feh\") == UC_JOINING_GROUP_FEH);\n  ASSERT (uc_joining_group_byname (\"FINAL SEMKATH\") == UC_JOINING_GROUP_FINAL_SEMKATH);\n  ASSERT (uc_joining_group_byname (\"Final Semkath\") == UC_JOINING_GROUP_FINAL_SEMKATH);\n  ASSERT (uc_joining_group_byname (\"Final_Semkath\") == UC_JOINING_GROUP_FINAL_SEMKATH);\n  ASSERT (uc_joining_group_byname (\"FinalSemkath\") == UC_JOINING_GROUP_FINAL_SEMKATH);\n  ASSERT (uc_joining_group_byname (\"GAF\") == UC_JOINING_GROUP_GAF);\n  ASSERT (uc_joining_group_byname (\"Gaf\") == UC_JOINING_GROUP_GAF);\n  ASSERT (uc_joining_group_byname (\"GAMAL\") == UC_JOINING_GROUP_GAMAL);\n  ASSERT (uc_joining_group_byname (\"Gamal\") == UC_JOINING_GROUP_GAMAL);\n  ASSERT (uc_joining_group_byname (\"HAH\") == UC_JOINING_GROUP_HAH);\n  ASSERT (uc_joining_group_byname (\"Hah\") == UC_JOINING_GROUP_HAH);\n  ASSERT (uc_joining_group_byname (\"HE\") == UC_JOINING_GROUP_HE);\n  ASSERT (uc_joining_group_byname (\"He\") == UC_JOINING_GROUP_HE);\n  ASSERT (uc_joining_group_byname (\"HEH\") == UC_JOINING_GROUP_HEH);\n  ASSERT (uc_joining_group_byname (\"Heh\") == UC_JOINING_GROUP_HEH);\n  ASSERT (uc_joining_group_byname (\"HEH GOAL\") == UC_JOINING_GROUP_HEH_GOAL);\n  ASSERT (uc_joining_group_byname (\"Heh Goal\") == UC_JOINING_GROUP_HEH_GOAL);\n  ASSERT (uc_joining_group_byname (\"Heh_Goal\") == UC_JOINING_GROUP_HEH_GOAL);\n  ASSERT (uc_joining_group_byname (\"HehGoal\") == UC_JOINING_GROUP_HEH_GOAL);\n  ASSERT (uc_joining_group_byname (\"HETH\") == UC_JOINING_GROUP_HETH);\n  ASSERT (uc_joining_group_byname (\"Heth\") == UC_JOINING_GROUP_HETH);\n  ASSERT (uc_joining_group_byname (\"KAF\") == UC_JOINING_GROUP_KAF);\n  ASSERT (uc_joining_group_byname (\"Kaf\") == UC_JOINING_GROUP_KAF);\n  ASSERT (uc_joining_group_byname (\"KAPH\") == UC_JOINING_GROUP_KAPH);\n  ASSERT (uc_joining_group_byname (\"Kaph\") == UC_JOINING_GROUP_KAPH);\n  ASSERT (uc_joining_group_byname (\"KHAPH\") == UC_JOINING_GROUP_KHAPH);\n  ASSERT (uc_joining_group_byname (\"Khaph\") == UC_JOINING_GROUP_KHAPH);\n  ASSERT (uc_joining_group_byname (\"KNOTTED HEH\") == UC_JOINING_GROUP_KNOTTED_HEH);\n  ASSERT (uc_joining_group_byname (\"Knotted Heh\") == UC_JOINING_GROUP_KNOTTED_HEH);\n  ASSERT (uc_joining_group_byname (\"Knotted_Heh\") == UC_JOINING_GROUP_KNOTTED_HEH);\n  ASSERT (uc_joining_group_byname (\"KnottedHeh\") == UC_JOINING_GROUP_KNOTTED_HEH);\n  ASSERT (uc_joining_group_byname (\"LAM\") == UC_JOINING_GROUP_LAM);\n  ASSERT (uc_joining_group_byname (\"Lam\") == UC_JOINING_GROUP_LAM);\n  ASSERT (uc_joining_group_byname (\"LAMADH\") == UC_JOINING_GROUP_LAMADH);\n  ASSERT (uc_joining_group_byname (\"Lamadh\") == UC_JOINING_GROUP_LAMADH);\n  ASSERT (uc_joining_group_byname (\"MEEM\") == UC_JOINING_GROUP_MEEM);\n  ASSERT (uc_joining_group_byname (\"Meem\") == UC_JOINING_GROUP_MEEM);\n  ASSERT (uc_joining_group_byname (\"MIM\") == UC_JOINING_GROUP_MIM);\n  ASSERT (uc_joining_group_byname (\"Mim\") == UC_JOINING_GROUP_MIM);\n  ASSERT (uc_joining_group_byname (\"NOON\") == UC_JOINING_GROUP_NOON);\n  ASSERT (uc_joining_group_byname (\"Noon\") == UC_JOINING_GROUP_NOON);\n  ASSERT (uc_joining_group_byname (\"NUN\") == UC_JOINING_GROUP_NUN);\n  ASSERT (uc_joining_group_byname (\"Nun\") == UC_JOINING_GROUP_NUN);\n  ASSERT (uc_joining_group_byname (\"NYA\") == UC_JOINING_GROUP_NYA);\n  ASSERT (uc_joining_group_byname (\"Nya\") == UC_JOINING_GROUP_NYA);\n  ASSERT (uc_joining_group_byname (\"PE\") == UC_JOINING_GROUP_PE);\n  ASSERT (uc_joining_group_byname (\"Pe\") == UC_JOINING_GROUP_PE);\n  ASSERT (uc_joining_group_byname (\"QAF\") == UC_JOINING_GROUP_QAF);\n  ASSERT (uc_joining_group_byname (\"Qaf\") == UC_JOINING_GROUP_QAF);\n  ASSERT (uc_joining_group_byname (\"QAPH\") == UC_JOINING_GROUP_QAPH);\n  ASSERT (uc_joining_group_byname (\"Qaph\") == UC_JOINING_GROUP_QAPH);\n  ASSERT (uc_joining_group_byname (\"REH\") == UC_JOINING_GROUP_REH);\n  ASSERT (uc_joining_group_byname (\"Reh\") == UC_JOINING_GROUP_REH);\n  ASSERT (uc_joining_group_byname (\"REVERSED PE\") == UC_JOINING_GROUP_REVERSED_PE);\n  ASSERT (uc_joining_group_byname (\"Reversed Pe\") == UC_JOINING_GROUP_REVERSED_PE);\n  ASSERT (uc_joining_group_byname (\"Reversed_Pe\") == UC_JOINING_GROUP_REVERSED_PE);\n  ASSERT (uc_joining_group_byname (\"ReversedPe\") == UC_JOINING_GROUP_REVERSED_PE);\n  ASSERT (uc_joining_group_byname (\"SAD\") == UC_JOINING_GROUP_SAD);\n  ASSERT (uc_joining_group_byname (\"Sad\") == UC_JOINING_GROUP_SAD);\n  ASSERT (uc_joining_group_byname (\"SADHE\") == UC_JOINING_GROUP_SADHE);\n  ASSERT (uc_joining_group_byname (\"Sadhe\") == UC_JOINING_GROUP_SADHE);\n  ASSERT (uc_joining_group_byname (\"SEEN\") == UC_JOINING_GROUP_SEEN);\n  ASSERT (uc_joining_group_byname (\"Seen\") == UC_JOINING_GROUP_SEEN);\n  ASSERT (uc_joining_group_byname (\"SEMKATH\") == UC_JOINING_GROUP_SEMKATH);\n  ASSERT (uc_joining_group_byname (\"Semkath\") == UC_JOINING_GROUP_SEMKATH);\n  ASSERT (uc_joining_group_byname (\"SHIN\") == UC_JOINING_GROUP_SHIN);\n  ASSERT (uc_joining_group_byname (\"Shin\") == UC_JOINING_GROUP_SHIN);\n  ASSERT (uc_joining_group_byname (\"SWASH KAF\") == UC_JOINING_GROUP_SWASH_KAF);\n  ASSERT (uc_joining_group_byname (\"Swash Kaf\") == UC_JOINING_GROUP_SWASH_KAF);\n  ASSERT (uc_joining_group_byname (\"Swash_Kaf\") == UC_JOINING_GROUP_SWASH_KAF);\n  ASSERT (uc_joining_group_byname (\"SwashKaf\") == UC_JOINING_GROUP_SWASH_KAF);\n  ASSERT (uc_joining_group_byname (\"SYRIAC WAW\") == UC_JOINING_GROUP_SYRIAC_WAW);\n  ASSERT (uc_joining_group_byname (\"Syriac Waw\") == UC_JOINING_GROUP_SYRIAC_WAW);\n  ASSERT (uc_joining_group_byname (\"Syriac_Waw\") == UC_JOINING_GROUP_SYRIAC_WAW);\n  ASSERT (uc_joining_group_byname (\"SyriacWaw\") == UC_JOINING_GROUP_SYRIAC_WAW);\n  ASSERT (uc_joining_group_byname (\"TAH\") == UC_JOINING_GROUP_TAH);\n  ASSERT (uc_joining_group_byname (\"Tah\") == UC_JOINING_GROUP_TAH);\n  ASSERT (uc_joining_group_byname (\"TAW\") == UC_JOINING_GROUP_TAW);\n  ASSERT (uc_joining_group_byname (\"Taw\") == UC_JOINING_GROUP_TAW);\n  ASSERT (uc_joining_group_byname (\"TEH MARBUTA\") == UC_JOINING_GROUP_TEH_MARBUTA);\n  ASSERT (uc_joining_group_byname (\"Teh Marbuta\") == UC_JOINING_GROUP_TEH_MARBUTA);\n  ASSERT (uc_joining_group_byname (\"Teh_Marbuta\") == UC_JOINING_GROUP_TEH_MARBUTA);\n  ASSERT (uc_joining_group_byname (\"TehMarbuta\") == UC_JOINING_GROUP_TEH_MARBUTA);\n  ASSERT (uc_joining_group_byname (\"TEH MARBUTA GOAL\") == UC_JOINING_GROUP_TEH_MARBUTA_GOAL);\n  ASSERT (uc_joining_group_byname (\"Teh Marbuta Goal\") == UC_JOINING_GROUP_TEH_MARBUTA_GOAL);\n  ASSERT (uc_joining_group_byname (\"Teh_Marbuta_Goal\") == UC_JOINING_GROUP_TEH_MARBUTA_GOAL);\n  ASSERT (uc_joining_group_byname (\"TehMarbutaGoal\") == UC_JOINING_GROUP_TEH_MARBUTA_GOAL);\n  ASSERT (uc_joining_group_byname (\"TETH\") == UC_JOINING_GROUP_TETH);\n  ASSERT (uc_joining_group_byname (\"Teth\") == UC_JOINING_GROUP_TETH);\n  ASSERT (uc_joining_group_byname (\"WAW\") == UC_JOINING_GROUP_WAW);\n  ASSERT (uc_joining_group_byname (\"Waw\") == UC_JOINING_GROUP_WAW);\n  ASSERT (uc_joining_group_byname (\"YEH\") == UC_JOINING_GROUP_YEH);\n  ASSERT (uc_joining_group_byname (\"Yeh\") == UC_JOINING_GROUP_YEH);\n  ASSERT (uc_joining_group_byname (\"YEH BARREE\") == UC_JOINING_GROUP_YEH_BARREE);\n  ASSERT (uc_joining_group_byname (\"Yeh Barree\") == UC_JOINING_GROUP_YEH_BARREE);\n  ASSERT (uc_joining_group_byname (\"Yeh_Barree\") == UC_JOINING_GROUP_YEH_BARREE);\n  ASSERT (uc_joining_group_byname (\"YehBarree\") == UC_JOINING_GROUP_YEH_BARREE);\n  ASSERT (uc_joining_group_byname (\"YEH WITH TAIL\") == UC_JOINING_GROUP_YEH_WITH_TAIL);\n  ASSERT (uc_joining_group_byname (\"Yeh with tail\") == UC_JOINING_GROUP_YEH_WITH_TAIL);\n  ASSERT (uc_joining_group_byname (\"Yeh_with_tail\") == UC_JOINING_GROUP_YEH_WITH_TAIL);\n  ASSERT (uc_joining_group_byname (\"YehWithTail\") == UC_JOINING_GROUP_YEH_WITH_TAIL);\n  ASSERT (uc_joining_group_byname (\"YUDH\") == UC_JOINING_GROUP_YUDH);\n  ASSERT (uc_joining_group_byname (\"Yudh\") == UC_JOINING_GROUP_YUDH);\n  ASSERT (uc_joining_group_byname (\"YUDH HE\") == UC_JOINING_GROUP_YUDH_HE);\n  ASSERT (uc_joining_group_byname (\"Yudh He\") == UC_JOINING_GROUP_YUDH_HE);\n  ASSERT (uc_joining_group_byname (\"Yudh_He\") == UC_JOINING_GROUP_YUDH_HE);\n  ASSERT (uc_joining_group_byname (\"YudhHe\") == UC_JOINING_GROUP_YUDH_HE);\n  ASSERT (uc_joining_group_byname (\"ZAIN\") == UC_JOINING_GROUP_ZAIN);\n  ASSERT (uc_joining_group_byname (\"Zain\") == UC_JOINING_GROUP_ZAIN);\n  ASSERT (uc_joining_group_byname (\"ZHAIN\") == UC_JOINING_GROUP_ZHAIN);\n  ASSERT (uc_joining_group_byname (\"Zhain\") == UC_JOINING_GROUP_ZHAIN);\n  ASSERT (uc_joining_group_byname (\"SEEN WITH 3 DOTS BELOW AND 3 DOTS ABOVE\") < 0);\n  ASSERT (uc_joining_group_byname (\"X\") < 0);\n  ASSERT (uc_joining_group_byname (\"\") < 0);\n\n  return 0;\n}",
      "lines": 152,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-joininggroup_name.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "int\nmain ()\n{\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_NONE),                  \"No Joining Group\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_AIN),                   \"Ain\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_ALAPH),                 \"Alaph\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_ALEF),                  \"Alef\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_BEH),                   \"Beh\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_BETH),                  \"Beth\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_BURUSHASKI_YEH_BARREE), \"Burushaski Yeh Barree\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_DAL),                   \"Dal\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_DALATH_RISH),           \"Dalath Rish\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_E),                     \"E\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_FARSI_YEH),             \"Farsi Yeh\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_FE),                    \"Fe\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_FEH),                   \"Feh\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_FINAL_SEMKATH),         \"Final Semkath\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_GAF),                   \"Gaf\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_GAMAL),                 \"Gamal\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_HAH),                   \"Hah\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_HE),                    \"He\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_HEH),                   \"Heh\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_HEH_GOAL),              \"Heh Goal\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_HETH),                  \"Heth\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_KAF),                   \"Kaf\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_KAPH),                  \"Kaph\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_KHAPH),                 \"Khaph\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_KNOTTED_HEH),           \"Knotted Heh\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_LAM),                   \"Lam\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_LAMADH),                \"Lamadh\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_MEEM),                  \"Meem\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_MIM),                   \"Mim\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_NOON),                  \"Noon\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_NUN),                   \"Nun\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_NYA),                   \"Nya\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_PE),                    \"Pe\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_QAF),                   \"Qaf\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_QAPH),                  \"Qaph\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_REH),                   \"Reh\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_REVERSED_PE),           \"Reversed Pe\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_SAD),                   \"Sad\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_SADHE),                 \"Sadhe\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_SEEN),                  \"Seen\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_SEMKATH),               \"Semkath\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_SHIN),                  \"Shin\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_SWASH_KAF),             \"Swash Kaf\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_SYRIAC_WAW),            \"Syriac Waw\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_TAH),                   \"Tah\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_TAW),                   \"Taw\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_TEH_MARBUTA),           \"Teh Marbuta\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_TEH_MARBUTA_GOAL),      \"Teh Marbuta Goal\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_TETH),                  \"Teth\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_WAW),                   \"Waw\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_YEH),                   \"Yeh\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_YEH_BARREE),            \"Yeh Barree\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_YEH_WITH_TAIL),         \"Yeh With Tail\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_YUDH),                  \"Yudh\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_YUDH_HE),               \"Yudh He\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_ZAIN),                  \"Zain\") == 0);\n  ASSERT (strcmp (uc_joining_group_name (UC_JOINING_GROUP_ZHAIN),                 \"Zhain\") == 0);\n  ASSERT (uc_joining_group_name (-1) == NULL);\n\n  return 0;\n}",
      "lines": 64,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-joininggroup_of.c": {
    "main": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\nmain ()\n{\n  unsigned int c;\n  size_t i;\n\n  c = 0;\n  for (i = 0; i < SIZEOF (mapping); i++)\n    {\n      for (; c < mapping[i].ch; c++)\n        ASSERT (uc_joining_group (c) == UC_JOINING_GROUP_NONE);\n      ASSERT (uc_joining_group (c) == mapping[i].value);\n      c++;\n    }\n  for (; c < 0x110000; c++)\n    ASSERT (uc_joining_group (c) == UC_JOINING_GROUP_NONE);\n\n  return 0;\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-joininggroup_of.h": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-joiningtype_byname.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "int\nmain ()\n{\n  ASSERT (uc_joining_type_byname (\"U\") == UC_JOINING_TYPE_U);\n  ASSERT (uc_joining_type_byname (\"T\") == UC_JOINING_TYPE_T);\n  ASSERT (uc_joining_type_byname (\"C\") == UC_JOINING_TYPE_C);\n  ASSERT (uc_joining_type_byname (\"L\") == UC_JOINING_TYPE_L);\n  ASSERT (uc_joining_type_byname (\"R\") == UC_JOINING_TYPE_R);\n  ASSERT (uc_joining_type_byname (\"D\") == UC_JOINING_TYPE_D);\n\n  ASSERT (uc_joining_type_byname (\"JOIN CAUSING\") == UC_JOINING_TYPE_C);\n  ASSERT (uc_joining_type_byname (\"Join Causing\") == UC_JOINING_TYPE_C);\n  ASSERT (uc_joining_type_byname (\"Join_Causing\") == UC_JOINING_TYPE_C);\n  ASSERT (uc_joining_type_byname (\"JoinCausing\") == UC_JOINING_TYPE_C);\n  ASSERT (uc_joining_type_byname (\"DUAL JOINING\") == UC_JOINING_TYPE_D);\n  ASSERT (uc_joining_type_byname (\"Dual Joining\") == UC_JOINING_TYPE_D);\n  ASSERT (uc_joining_type_byname (\"Dual_Joining\") == UC_JOINING_TYPE_D);\n  ASSERT (uc_joining_type_byname (\"DualJoining\") == UC_JOINING_TYPE_D);\n  ASSERT (uc_joining_type_byname (\"LEFT JOINING\") == UC_JOINING_TYPE_L);\n  ASSERT (uc_joining_type_byname (\"Left Joining\") == UC_JOINING_TYPE_L);\n  ASSERT (uc_joining_type_byname (\"Left_Joining\") == UC_JOINING_TYPE_L);\n  ASSERT (uc_joining_type_byname (\"LeftJoining\") == UC_JOINING_TYPE_L);\n  ASSERT (uc_joining_type_byname (\"RIGHT JOINING\") == UC_JOINING_TYPE_R);\n  ASSERT (uc_joining_type_byname (\"Right Joining\") == UC_JOINING_TYPE_R);\n  ASSERT (uc_joining_type_byname (\"Right_Joining\") == UC_JOINING_TYPE_R);\n  ASSERT (uc_joining_type_byname (\"RightJoining\") == UC_JOINING_TYPE_R);\n  ASSERT (uc_joining_type_byname (\"TRANSPARENT\") == UC_JOINING_TYPE_T);\n  ASSERT (uc_joining_type_byname (\"Transparent\") == UC_JOINING_TYPE_T);\n  ASSERT (uc_joining_type_byname (\"NON JOINING\") == UC_JOINING_TYPE_U);\n  ASSERT (uc_joining_type_byname (\"Non Joining\") == UC_JOINING_TYPE_U);\n  ASSERT (uc_joining_type_byname (\"Non_Joining\") == UC_JOINING_TYPE_U);\n  ASSERT (uc_joining_type_byname (\"NonJoining\") == UC_JOINING_TYPE_U);\n\n  ASSERT (uc_joining_type_byname (\"X\") < 0);\n  ASSERT (uc_joining_type_byname (\"\") < 0);\n\n  return 0;\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-joiningtype_longname.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nmain ()\n{\n  ASSERT (strcmp (uc_joining_type_long_name (UC_JOINING_TYPE_U), \"Non Joining\") == 0);\n  ASSERT (strcmp (uc_joining_type_long_name (UC_JOINING_TYPE_T), \"Transparent\") == 0);\n  ASSERT (strcmp (uc_joining_type_long_name (UC_JOINING_TYPE_C), \"Join Causing\") == 0);\n  ASSERT (strcmp (uc_joining_type_long_name (UC_JOINING_TYPE_L), \"Left Joining\") == 0);\n  ASSERT (strcmp (uc_joining_type_long_name (UC_JOINING_TYPE_R), \"Right Joining\") == 0);\n  ASSERT (strcmp (uc_joining_type_long_name (UC_JOINING_TYPE_D), \"Dual Joining\") == 0);\n  ASSERT (uc_joining_type_long_name (-1) == NULL);\n\n  return 0;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-joiningtype_name.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nmain ()\n{\n  ASSERT (strcmp (uc_joining_type_name (UC_JOINING_TYPE_U), \"U\") == 0);\n  ASSERT (strcmp (uc_joining_type_name (UC_JOINING_TYPE_T), \"T\") == 0);\n  ASSERT (strcmp (uc_joining_type_name (UC_JOINING_TYPE_C), \"C\") == 0);\n  ASSERT (strcmp (uc_joining_type_name (UC_JOINING_TYPE_L), \"L\") == 0);\n  ASSERT (strcmp (uc_joining_type_name (UC_JOINING_TYPE_R), \"R\") == 0);\n  ASSERT (strcmp (uc_joining_type_name (UC_JOINING_TYPE_D), \"D\") == 0);\n  ASSERT (uc_joining_type_name (-1) == NULL);\n\n  return 0;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-joiningtype_of.c": {
    "main": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\nmain ()\n{\n  unsigned int c;\n  size_t i;\n\n  c = 0;\n  for (i = 0; i < SIZEOF (mapping); i++)\n    {\n      for (; c < mapping[i].ch; c++)\n        ASSERT (uc_joining_type (c) == UC_JOINING_TYPE_U\n                || uc_joining_type (c) == UC_JOINING_TYPE_T);\n      ASSERT (uc_joining_type (c) == mapping[i].value);\n      c++;\n    }\n  for (; c < 0x110000; c++)\n    ASSERT (uc_joining_type (c) == UC_JOINING_TYPE_U\n            || uc_joining_type (c) == UC_JOINING_TYPE_T);\n\n  /* Test distinction between U and T.  */\n  ASSERT (uc_joining_type (0x060C) == UC_JOINING_TYPE_U);\n  ASSERT (uc_joining_type (0x060D) == UC_JOINING_TYPE_U);\n  ASSERT (uc_joining_type (0x060E) == UC_JOINING_TYPE_U);\n  ASSERT (uc_joining_type (0x060F) == UC_JOINING_TYPE_U);\n  ASSERT (uc_joining_type (0x0610) == UC_JOINING_TYPE_T);\n  ASSERT (uc_joining_type (0x0611) == UC_JOINING_TYPE_T);\n  ASSERT (uc_joining_type (0x0612) == UC_JOINING_TYPE_T);\n  ASSERT (uc_joining_type (0x0613) == UC_JOINING_TYPE_T);\n  ASSERT (uc_joining_type (0x0614) == UC_JOINING_TYPE_T);\n\n  return 0;\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-joiningtype_of.h": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-mirror.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\nmain ()\n{\n  ucs4_t mirrored;\n\n  ASSERT (uc_mirror_char ('(', &mirrored) && mirrored == ')');\n  ASSERT (uc_mirror_char (')', &mirrored) && mirrored == '(');\n  ASSERT (uc_mirror_char ('<', &mirrored) && mirrored == '>');\n  ASSERT (uc_mirror_char ('>', &mirrored) && mirrored == '<');\n  ASSERT (uc_mirror_char ('[', &mirrored) && mirrored == ']');\n  ASSERT (uc_mirror_char (']', &mirrored) && mirrored == '[');\n  ASSERT (uc_mirror_char ('{', &mirrored) && mirrored == '}');\n  ASSERT (uc_mirror_char ('}', &mirrored) && mirrored == '{');\n  ASSERT (!uc_mirror_char ('X', &mirrored));\n\n  return 0;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-numeric.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "int\nmain ()\n{\n  unsigned int c;\n  uc_fraction_t value;\n  size_t i;\n\n  c = 0;\n  for (i = 0; i < SIZEOF (mapping); i++)\n    {\n      for (; c < mapping[i].ch; c++)\n        {\n          value = uc_numeric_value (c);\n          ASSERT (value.numerator == 0 && value.denominator == 0);\n        }\n      /* Here c = mapping[i].ch.  */\n      value = uc_numeric_value (c);\n      ASSERT (value.numerator == mapping[i].numerator\n              && value.denominator == mapping[i].denominator);\n      c++;\n    }\n  for (; c < 0x110000; c++)\n    {\n      value = uc_numeric_value (c);\n      ASSERT (value.numerator == 0 && value.denominator == 0);\n    }\n\n  return 0;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-numeric.h": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-predicate-part1.h": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-predicate-part2.h": {
    "main": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int\nmain ()\n{\n  unsigned int c;\n  size_t i;\n\n  c = 0;\n  for (i = 0; i < SIZEOF (set); i++)\n    {\n      for (; c < set[i].start; c++)\n        ASSERT (!PREDICATE (c));\n      for (; c <= set[i].end; c++)\n        ASSERT (PREDICATE (c));\n    }\n  for (; c < 0x110000; c++)\n    ASSERT (!PREDICATE (c));\n\n  return 0;\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_alphabetic.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_ascii_hex_digit.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_bidi_arabic_digit.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_bidi_arabic_right_to_left.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_bidi_block_separator.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_bidi_boundary_neutral.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_bidi_common_separator.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_bidi_control.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_bidi_embedding_or_override.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_bidi_european_digit.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_bidi_eur_num_separator.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_bidi_eur_num_terminator.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_bidi_hebrew_right_to_left.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_bidi_left_to_right.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_bidi_non_spacing_mark.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_bidi_other_neutral.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_bidi_pdf.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_bidi_segment_separator.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_bidi_whitespace.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_byname.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "int\nmain ()\n{\n  {\n    uc_property_t pr = uc_property_byname (\"composite\");\n    unsigned int c;\n\n    for (c = 0; c < 0x110000; c++)\n      ASSERT (uc_is_property (c, pr) == uc_is_property_composite (c));\n  }\n\n  {\n    uc_property_t pr = uc_property_byname (\"foobar\");\n    ASSERT (! uc_property_is_valid (pr));\n  }\n\n  return 0;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_cased.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_case_ignorable.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_changes_when_casefolded.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_changes_when_casemapped.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_changes_when_lowercased.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_changes_when_titlecased.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_changes_when_uppercased.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_combining.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_composite.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_currency_symbol.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_dash.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_decimal_digit.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_default_ignorable_code_point.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_deprecated.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_diacritic.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_extender.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_format_control.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_grapheme_base.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_grapheme_extend.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_grapheme_link.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_hex_digit.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_hyphen.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_ideographic.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_ids_binary_operator.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_ids_trinary_operator.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_id_continue.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_id_start.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_ignorable_control.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_iso_control.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_join_control.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_left_of_pair.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_line_separator.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_logical_order_exception.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_lowercase.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_math.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_non_break.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_not_a_character.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_numeric.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_other_alphabetic.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_other_default_ignorable_code_point.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_other_grapheme_extend.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_other_id_continue.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_other_id_start.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_other_lowercase.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_other_math.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_other_uppercase.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_paired_punctuation.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_paragraph_separator.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_pattern_syntax.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_pattern_white_space.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_private_use.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_punctuation.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_quotation_mark.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_radical.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_sentence_terminal.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_soft_dotted.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_space.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_terminal_punctuation.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_test.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "int\nmain ()\n{\n  uc_property_t pr = UC_PROPERTY_COMPOSITE;\n  unsigned int c;\n\n  for (c = 0; c < 0x110000; c++)\n    ASSERT (uc_is_property (c, pr) == uc_is_property_composite (c));\n\n  return 0;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_titlecase.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_unassigned_code_value.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_unified_ideograph.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_uppercase.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_variation_selector.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_white_space.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_xid_continue.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_xid_start.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-pr_zero_width.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-scripts.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Test the uc_script function.  */\n  ASSERT (strcmp (uc_script ('A')->name, \"Latin\") == 0);\n  ASSERT (strcmp (uc_script ('%')->name, \"Common\") == 0);\n  ASSERT (uc_script (0xE0000) == NULL);\n\n  /* Test the uc_script_byname function.  */\n  ASSERT (strcmp (uc_script_byname (\"Armenian\")->name, \"Armenian\") == 0);\n  ASSERT (uc_script_byname (\"Pekinese\") == NULL);\n\n  /* Test the uc_is_script function.  */\n  ASSERT (uc_is_script ('A', uc_script_byname (\"Latin\")));\n  ASSERT (!uc_is_script ('A', uc_script_byname (\"Common\")));\n  ASSERT (!uc_is_script (0x05DA, uc_script_byname (\"Latin\")));\n  ASSERT (uc_is_script (0x05DA, uc_script_byname (\"Hebrew\")));\n\n  {\n    unsigned int c;\n\n    for (c = 0; c < 0x110000; c++)\n      {\n        const uc_script_t *script = uc_script (c);\n        if (script != NULL)\n          ASSERT (uc_is_script (c, script));\n      }\n  }\n\n  /* Test the uc_all_scripts function.  */\n  {\n    const uc_script_t *scripts;\n    size_t nscripts;\n    size_t i;\n    bool found;\n\n    uc_all_scripts (&scripts, &nscripts);\n\n    found = false;\n    for (i = 0; i < nscripts; i++)\n      {\n        ASSERT (scripts[i].name != NULL);\n        if (strcmp (scripts[i].name, \"Hebrew\") == 0)\n          found = true;\n      }\n    ASSERT (found);\n  }\n\n  return 0;\n}",
      "lines": 50,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-sy_c_ident.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "int\nmain ()\n{\n  ASSERT (uc_c_ident_category ('0') == UC_IDENTIFIER_VALID);\n  ASSERT (uc_c_ident_category ('X') == UC_IDENTIFIER_START);\n  ASSERT (uc_c_ident_category ('+') == UC_IDENTIFIER_INVALID);\n  ASSERT (uc_c_ident_category (0x00B2) == UC_IDENTIFIER_INVALID);\n  ASSERT (uc_c_ident_category (0x05DA) == UC_IDENTIFIER_START);\n\n  ASSERT (uc_c_ident_category (0x001B) == UC_IDENTIFIER_INVALID);\n  ASSERT (uc_c_ident_category (0xE0001) == UC_IDENTIFIER_INVALID);\n\n  return 0;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-sy_c_whitespace.c": {},
  "libunistring/libunistring-0.9.10/tests/unictype/test-sy_java_ident.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "int\nmain ()\n{\n  ASSERT (uc_java_ident_category ('0') == UC_IDENTIFIER_VALID);\n  ASSERT (uc_java_ident_category ('X') == UC_IDENTIFIER_START);\n  ASSERT (uc_java_ident_category ('+') == UC_IDENTIFIER_INVALID);\n  ASSERT (uc_java_ident_category (0x00B2) == UC_IDENTIFIER_INVALID);\n  ASSERT (uc_java_ident_category (0x05DA) == UC_IDENTIFIER_START);\n\n  ASSERT (uc_java_ident_category (0x001B) == UC_IDENTIFIER_IGNORABLE);\n  ASSERT (uc_java_ident_category (0xE0001) == UC_IDENTIFIER_IGNORABLE);\n\n  return 0;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unictype/test-sy_java_whitespace.c": {},
  "libunistring/libunistring-0.9.10/tests/unigbrk/test-u16-grapheme-breaks.c": {
    "test_u16_grapheme_breaks": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static void\ntest_u16_grapheme_breaks (const char *expected, ...)\n{\n  size_t n = strlen (expected);\n  uint16_t s[16];\n  va_list args;\n  char breaks[16];\n  size_t i;\n\n  ASSERT (n <= 16);\n\n  memset (breaks, 0xcc, n);\n\n  va_start (args, expected);\n  for (i = 0; i < n; i++)\n    {\n      int unit = va_arg (args, int);\n      ASSERT (unit >= 0);\n      s[i] = unit;\n    }\n  ASSERT (va_arg (args, int) == -1);\n  va_end (args);\n\n  u16_grapheme_breaks (s, n, breaks);\n  for (i = 0; i < n; i++)\n    if (breaks[i] != (expected[i] == '#'))\n      {\n        size_t j;\n\n        fprintf (stderr, \"wrong grapheme breaks:\\n\");\n\n        fprintf (stderr, \"   input:\");\n        for (j = 0; j < n; j++)\n          fprintf (stderr, \" %02x\", s[j]);\n        putc ('\\n', stderr);\n\n        fprintf (stderr, \"expected:\");\n        for (j = 0; j < n; j++)\n          fprintf (stderr, \"  %d\", expected[j] == '#');\n        putc ('\\n', stderr);\n\n        fprintf (stderr, \"  actual:\");\n        for (j = 0; j < n; j++)\n          fprintf (stderr, \"  %d\", breaks[j]);\n        putc ('\\n', stderr);\n\n        abort ();\n      }\n}",
      "lines": 49,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Standalone 1-unit graphemes.  */\n  test_u16_grapheme_breaks (\"#\", 'a', -1);\n  test_u16_grapheme_breaks (\"##\", 'a', 'b', -1);\n  test_u16_grapheme_breaks (\"###\", 'a', 'b', 'c', -1);\n\n#define HIRAGANA_A 0x3042       /* \u00e3\u0081\u0082: Hiragana letter 'a'. */\n  test_u16_grapheme_breaks (\"#\", HIRAGANA_A, -1);\n  test_u16_grapheme_breaks (\"##\", HIRAGANA_A, 'x', -1);\n  test_u16_grapheme_breaks (\"##\", HIRAGANA_A, HIRAGANA_A, -1);\n\n  /* Combining accents. */\n#define GRAVE 0x0300            /* Combining grave accent. */\n#define ACUTE 0x0301            /* Combining acute accent. */\n  test_u16_grapheme_breaks (\"#_\", 'e', ACUTE, -1);\n  test_u16_grapheme_breaks (\"#__\", 'e', ACUTE, GRAVE, -1);\n  test_u16_grapheme_breaks (\"#_#\", 'e', ACUTE, 'x', -1);\n  test_u16_grapheme_breaks (\"#_#_\", 'e', ACUTE, 'e', GRAVE, -1);\n\n  return 0;\n}",
      "lines": 23,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unigbrk/test-u16-grapheme-next.c": {
    "test_u16_grapheme_next": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static void\ntest_u16_grapheme_next (size_t len, ...)\n{\n  const uint16_t *next;\n  uint16_t s[16];\n  va_list args;\n  size_t n;\n\n  va_start (args, len);\n  n = 0;\n  for (;;)\n    {\n      int unit = va_arg (args, int);\n      if (unit == -1)\n        break;\n      else if (n >= sizeof s / sizeof *s)\n        abort ();\n\n      s[n++] = unit;\n    }\n  va_end (args);\n\n  next = u16_grapheme_next (s, s + n);\n  if (next != s + len)\n    {\n      size_t i;\n\n      if (next == NULL)\n        fputs (\"u16_grapheme_next returned NULL\", stderr);\n      else\n        fprintf (stderr, \"u16_grapheme_next skipped %zu units\", next - s);\n      fprintf (stderr, \", expected %zu:\\n\", len);\n      for (i = 0; i < n; i++)\n        fprintf (stderr, \" %04x\", s[i]);\n      putc ('\\n', stderr);\n      abort ();\n    }\n}",
      "lines": 38,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "int\nmain (void)\n{\n  static const uint16_t s[] = { 'a', 'b', 'c' };\n\n  /* Empty string. */\n  ASSERT (u16_grapheme_next (NULL, NULL) == NULL);\n  ASSERT (u16_grapheme_next (s, s) == NULL);\n\n  /* Standalone 1-unit graphemes.  */\n  test_u16_grapheme_next (1, 'a', -1);\n  test_u16_grapheme_next (1, 'a', 'b', -1);\n  test_u16_grapheme_next (1, 'a', 'b', 'c', -1);\n\n  /* Multi-unit, single code point graphemes. */\n#define HIRAGANA_A 0x3042       /* \u00e3\u0081\u0082: Hiragana letter 'a'. */\n  test_u16_grapheme_next (1, HIRAGANA_A, -1);\n  test_u16_grapheme_next (1, HIRAGANA_A, 'x', -1);\n  test_u16_grapheme_next (1, HIRAGANA_A, HIRAGANA_A, -1);\n\n  /* Combining accents. */\n#define GRAVE 0x0300            /* Combining grave accent. */\n#define ACUTE 0x0301            /* Combining acute accent. */\n  test_u16_grapheme_next (2, 'e', ACUTE, -1);\n  test_u16_grapheme_next (3, 'e', ACUTE, GRAVE, -1);\n  test_u16_grapheme_next (2, 'e', ACUTE, 'x', -1);\n  test_u16_grapheme_next (2, 'e', ACUTE, 'e', ACUTE, -1);\n\n  /* Surrogate pairs. */\n  test_u16_grapheme_next (2, 0xd83d, 0xde10, -1); /* \u00f0\u009f\u0098\u0090: neutral face. */\n  test_u16_grapheme_next (3, 0xd83d, 0xde10, GRAVE, -1);\n\n  return 0;\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unigbrk/test-u16-grapheme-prev.c": {
    "test_u16_grapheme_prev": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static void\ntest_u16_grapheme_prev (size_t len, ...)\n{\n  const uint16_t *prev;\n  const uint16_t *end;\n  uint16_t s[16];\n  va_list args;\n  size_t n;\n\n  va_start (args, len);\n  n = 0;\n  for (;;)\n    {\n      int unit = va_arg (args, int);\n      if (unit == -1)\n        break;\n      else if (n >= sizeof s / sizeof *s)\n        abort ();\n\n      s[n++] = unit;\n    }\n  va_end (args);\n\n  end = s + n;\n  prev = u16_grapheme_prev (end, s);\n  if (prev != end - len)\n    {\n      size_t i;\n\n      if (prev == NULL)\n        fputs (\"u16_grapheme_prev returned NULL\", stderr);\n      else\n        fprintf (stderr, \"u16_grapheme_prev skipped %zu units\", end - prev);\n      fprintf (stderr, \", expected %zu:\\n\", len);\n      for (i = 0; i < n; i++)\n        fprintf (stderr, \" %04x\", s[i]);\n      putc ('\\n', stderr);\n      abort ();\n    }\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "int\nmain (void)\n{\n  static const uint16_t s[] = { 'a', 'b', 'c' };\n\n  /* Empty string. */\n  ASSERT (u16_grapheme_prev (NULL, NULL) == NULL);\n  ASSERT (u16_grapheme_prev (s, s) == NULL);\n\n  /* Standalone 1-unit graphemes.  */\n  test_u16_grapheme_prev (1, 'a', -1);\n  test_u16_grapheme_prev (1, 'a', 'b', -1);\n  test_u16_grapheme_prev (1, 'a', 'b', 'c', -1);\n\n  /* Multi-unit, single code point graphemes. */\n#define HIRAGANA_A 0x3042       /* \u00e3\u0081\u0082: Hiragana letter 'a'. */\n  test_u16_grapheme_prev (1, HIRAGANA_A, -1);\n  test_u16_grapheme_prev (1, HIRAGANA_A, 'x', -1);\n  test_u16_grapheme_prev (1, HIRAGANA_A, HIRAGANA_A, -1);\n\n  /* Combining accents. */\n#define GRAVE 0x0300            /* Combining grave accent. */\n#define ACUTE 0x0301            /* Combining acute accent. */\n  test_u16_grapheme_prev (2, 'e', ACUTE, -1);\n  test_u16_grapheme_prev (3, 'e', ACUTE, GRAVE, -1);\n  test_u16_grapheme_prev (1, 'e', ACUTE, 'x', -1);\n  test_u16_grapheme_prev (2, 'e', ACUTE, 'e', ACUTE, -1);\n\n  /* Surrogate pairs. */\n  test_u16_grapheme_prev (2, 0xd83d, 0xde10, -1); /* \u00f0\u009f\u0098\u0090: neutral face. */\n  test_u16_grapheme_prev (3, 0xd83d, 0xde10, GRAVE, -1);\n\n  return 0;\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unigbrk/test-u32-grapheme-breaks.c": {
    "test_u32_grapheme_breaks": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static void\ntest_u32_grapheme_breaks (const char *expected, ...)\n{\n  size_t n = strlen (expected);\n  uint32_t s[16];\n  va_list args;\n  char breaks[16];\n  size_t i;\n\n  ASSERT (n <= 16);\n\n  memset (breaks, 0xcc, n);\n\n  va_start (args, expected);\n  for (i = 0; i < n; i++)\n    {\n      int unit = va_arg (args, int);\n      ASSERT (unit >= 0);\n      s[i] = unit;\n    }\n  ASSERT (va_arg (args, int) == -1);\n  va_end (args);\n\n  u32_grapheme_breaks (s, n, breaks);\n  for (i = 0; i < n; i++)\n    if (breaks[i] != (expected[i] == '#'))\n      {\n        size_t j;\n\n        fprintf (stderr, \"wrong grapheme breaks:\\n\");\n\n        fprintf (stderr, \"   input:\");\n        for (j = 0; j < n; j++)\n          fprintf (stderr, \" %02x\", s[j]);\n        putc ('\\n', stderr);\n\n        fprintf (stderr, \"expected:\");\n        for (j = 0; j < n; j++)\n          fprintf (stderr, \"  %d\", expected[j] == '#');\n        putc ('\\n', stderr);\n\n        fprintf (stderr, \"  actual:\");\n        for (j = 0; j < n; j++)\n          fprintf (stderr, \"  %d\", breaks[j]);\n        putc ('\\n', stderr);\n\n        abort ();\n      }\n}",
      "lines": 49,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Standalone 1-unit graphemes.  */\n  test_u32_grapheme_breaks (\"#\", 'a', -1);\n  test_u32_grapheme_breaks (\"##\", 'a', 'b', -1);\n  test_u32_grapheme_breaks (\"###\", 'a', 'b', 'c', -1);\n\n#define HIRAGANA_A 0x3042       /* \u00e3\u0081\u0082: Hiragana letter 'a'. */\n  test_u32_grapheme_breaks (\"#\", HIRAGANA_A, -1);\n  test_u32_grapheme_breaks (\"##\", HIRAGANA_A, 'x', -1);\n  test_u32_grapheme_breaks (\"##\", HIRAGANA_A, HIRAGANA_A, -1);\n\n  /* Combining accents. */\n#define GRAVE 0x0300            /* Combining grave accent. */\n#define ACUTE 0x0301            /* Combining acute accent. */\n  test_u32_grapheme_breaks (\"#_\", 'e', ACUTE, -1);\n  test_u32_grapheme_breaks (\"#__\", 'e', ACUTE, GRAVE, -1);\n  test_u32_grapheme_breaks (\"#_#\", 'e', ACUTE, 'x', -1);\n  test_u32_grapheme_breaks (\"#_#_\", 'e', ACUTE, 'e', GRAVE, -1);\n\n  return 0;\n}",
      "lines": 23,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unigbrk/test-u32-grapheme-next.c": {
    "test_u32_grapheme_next": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static void\ntest_u32_grapheme_next (size_t len, ...)\n{\n  const uint32_t *next;\n  uint32_t s[32];\n  va_list args;\n  size_t n;\n\n  va_start (args, len);\n  n = 0;\n  for (;;)\n    {\n      int unit = va_arg (args, int);\n      if (unit == -1)\n        break;\n      else if (n >= sizeof s / sizeof *s)\n        abort ();\n\n      s[n++] = unit;\n    }\n  va_end (args);\n\n  next = u32_grapheme_next (s, s + n);\n  if (next != s + len)\n    {\n      size_t i;\n\n      if (next == NULL)\n        fputs (\"u32_grapheme_next returned NULL\", stderr);\n      else\n        fprintf (stderr, \"u32_grapheme_next skipped %zu units\", next - s);\n      fprintf (stderr, \", expected %zu:\\n\", len);\n      for (i = 0; i < n; i++)\n        fprintf (stderr, \" %04x\", s[i]);\n      putc ('\\n', stderr);\n      abort ();\n    }\n}",
      "lines": 38,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "int\nmain (void)\n{\n  static const uint32_t s[] = { 'a', 'b', 'c' };\n\n  /* Empty string. */\n  ASSERT (u32_grapheme_next (NULL, NULL) == NULL);\n  ASSERT (u32_grapheme_next (s, s) == NULL);\n\n  /* Standalone 1-unit graphemes.  */\n  test_u32_grapheme_next (1, 'a', -1);\n  test_u32_grapheme_next (1, 'a', 'b', -1);\n  test_u32_grapheme_next (1, 'a', 'b', 'c', -1);\n\n  /* Multi-unit, single code point graphemes. */\n#define HIRAGANA_A 0x3042       /* \u00e3\u0081\u0082: Hiragana letter 'a'. */\n  test_u32_grapheme_next (1, HIRAGANA_A, -1);\n  test_u32_grapheme_next (1, HIRAGANA_A, 'x', -1);\n  test_u32_grapheme_next (1, HIRAGANA_A, HIRAGANA_A, -1);\n\n  /* Combining accents. */\n#define GRAVE 0x0300            /* Combining grave accent. */\n#define ACUTE 0x0301            /* Combining acute accent. */\n  test_u32_grapheme_next (2, 'e', ACUTE, -1);\n  test_u32_grapheme_next (3, 'e', ACUTE, GRAVE, -1);\n  test_u32_grapheme_next (2, 'e', ACUTE, 'x', -1);\n  test_u32_grapheme_next (2, 'e', ACUTE, 'e', ACUTE, -1);\n\n  /* Outside BMP. */\n#define NEUTRAL_FACE 0x1f610    /* \u00f0\u009f\u0098\u0090: neutral face. */\n  test_u32_grapheme_next (1, NEUTRAL_FACE, -1);\n  test_u32_grapheme_next (2, NEUTRAL_FACE, GRAVE, -1);\n\n  return 0;\n}",
      "lines": 35,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unigbrk/test-u32-grapheme-prev.c": {
    "test_u32_grapheme_prev": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static void\ntest_u32_grapheme_prev (size_t len, ...)\n{\n  const uint32_t *prev;\n  const uint32_t *end;\n  uint32_t s[16];\n  va_list args;\n  size_t n;\n\n  va_start (args, len);\n  n = 0;\n  for (;;)\n    {\n      int unit = va_arg (args, int);\n      if (unit == -1)\n        break;\n      else if (n >= sizeof s / sizeof *s)\n        abort ();\n\n      s[n++] = unit;\n    }\n  va_end (args);\n\n  end = s + n;\n  prev = u32_grapheme_prev (end, s);\n  if (prev != end - len)\n    {\n      size_t i;\n\n      if (prev == NULL)\n        fputs (\"u32_grapheme_prev returned NULL\", stderr);\n      else\n        fprintf (stderr, \"u32_grapheme_prev skipped %zu units\", end - prev);\n      fprintf (stderr, \", expected %zu:\\n\", len);\n      for (i = 0; i < n; i++)\n        fprintf (stderr, \" %04x\", s[i]);\n      putc ('\\n', stderr);\n      abort ();\n    }\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "int\nmain (void)\n{\n  static const uint32_t s[] = { 'a', 'b', 'c' };\n\n  /* Empty string. */\n  ASSERT (u32_grapheme_prev (NULL, NULL) == NULL);\n  ASSERT (u32_grapheme_prev (s, s) == NULL);\n\n  /* Standalone 1-unit graphemes.  */\n  test_u32_grapheme_prev (1, 'a', -1);\n  test_u32_grapheme_prev (1, 'a', 'b', -1);\n  test_u32_grapheme_prev (1, 'a', 'b', 'c', -1);\n\n  /* Multi-unit, single code point graphemes. */\n#define HIRAGANA_A 0x3042       /* \u00e3\u0081\u0082: Hiragana letter 'a'. */\n  test_u32_grapheme_prev (1, HIRAGANA_A, -1);\n  test_u32_grapheme_prev (1, HIRAGANA_A, 'x', -1);\n  test_u32_grapheme_prev (1, HIRAGANA_A, HIRAGANA_A, -1);\n\n  /* Combining accents. */\n#define GRAVE 0x0300            /* Combining grave accent. */\n#define ACUTE 0x0301            /* Combining acute accent. */\n  test_u32_grapheme_prev (2, 'e', ACUTE, -1);\n  test_u32_grapheme_prev (3, 'e', ACUTE, GRAVE, -1);\n  test_u32_grapheme_prev (1, 'e', ACUTE, 'x', -1);\n  test_u32_grapheme_prev (2, 'e', ACUTE, 'e', ACUTE, -1);\n\n  /* Outside BMP. */\n#define NEUTRAL_FACE 0x1f610    /* \u00f0\u009f\u0098\u0090: neutral face. */\n  test_u32_grapheme_prev (1, NEUTRAL_FACE, -1);\n  test_u32_grapheme_prev (2, NEUTRAL_FACE, GRAVE, -1);\n\n  return 0;\n}",
      "lines": 35,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unigbrk/test-u8-grapheme-breaks.c": {
    "test_u8_grapheme_breaks": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "static void\ntest_u8_grapheme_breaks (const char *input, const char *expected)\n{\n  const uint8_t *s = (const uint8_t *) input;\n  size_t n = strlen (expected);\n  char *breaks;\n  size_t i;\n\n  breaks = malloc (n);\n  if (!breaks)\n    abort ();\n  memset (breaks, 0xcc, n);\n\n  u8_grapheme_breaks (s, n, breaks);\n  for (i = 0; i < n; i++)\n    if (breaks[i] != (expected[i] == '#'))\n      {\n        size_t j;\n\n        fprintf (stderr, \"wrong grapheme breaks:\\n\");\n\n        fprintf (stderr, \"   input:\");\n        for (j = 0; j < n; j++)\n          fprintf (stderr, \" %02x\", s[j]);\n        putc ('\\n', stderr);\n\n        fprintf (stderr, \"expected:\");\n        for (j = 0; j < n; j++)\n          fprintf (stderr, \"  %d\", expected[j] == '#');\n        putc ('\\n', stderr);\n\n        fprintf (stderr, \"  actual:\");\n        for (j = 0; j < n; j++)\n          fprintf (stderr, \"  %d\", breaks[j]);\n        putc ('\\n', stderr);\n\n        abort ();\n      }\n\n  free (breaks);\n}",
      "lines": 41,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Standalone 1-unit graphemes.  */\n  test_u8_grapheme_breaks (\"a\", \"#\");\n  test_u8_grapheme_breaks (\"ab\", \"##\");\n  test_u8_grapheme_breaks (\"abc\", \"###\");\n\n  /* Multi-unit, single code point graphemes. */\n#define HIRAGANA_A \"\\343\\201\\202\" /* \u00e3\u0081\u0082: Hiragana letter 'a'. */\n  test_u8_grapheme_breaks (HIRAGANA_A, \"#__\");\n  test_u8_grapheme_breaks (HIRAGANA_A\"x\", \"#__#\");\n  test_u8_grapheme_breaks (HIRAGANA_A HIRAGANA_A, \"#__#__\");\n\n  /* Combining accents. */\n#define GRAVE \"\\314\\200\"        /* Combining grave accent. */\n#define ACUTE \"\\314\\201\"        /* Combining acute accent. */\n  test_u8_grapheme_breaks (\"e\"ACUTE, \"#__\");\n  test_u8_grapheme_breaks (\"e\"ACUTE GRAVE, \"#____\");\n  test_u8_grapheme_breaks (\"e\"ACUTE\"x\", \"#__#\");\n  test_u8_grapheme_breaks (\"e\"ACUTE \"e\"ACUTE, \"#__#__\");\n\n  return 0;\n}",
      "lines": 24,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unigbrk/test-u8-grapheme-next.c": {
    "test_u8_grapheme_next": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "static void\ntest_u8_grapheme_next (const char *input, size_t n, size_t len)\n{\n  const uint8_t *s = (const uint8_t *) input;\n  const uint8_t *next = u8_grapheme_next (s, s + n);\n  if (next != s + len)\n    {\n      size_t i;\n\n      if (next == NULL)\n        fputs (\"u8_grapheme_next returned NULL\", stderr);\n      else\n        fprintf (stderr, \"u8_grapheme_next skipped %zu bytes\", next - s);\n      fprintf (stderr, \", expected %zu:\\n\", len);\n      for (i = 0; i < n; i++)\n        fprintf (stderr, \" %02x\", s[i]);\n      putc ('\\n', stderr);\n      abort ();\n    }\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int\nmain (void)\n{\n  static const uint8_t s[] = \"abc\";\n\n  /* Empty string. */\n  ASSERT (u8_grapheme_next (NULL, NULL) == NULL);\n  ASSERT (u8_grapheme_next (s, s) == NULL);\n\n  /* Standalone 1-unit graphemes.  */\n  test_u8_grapheme_next (\"a\", 1, 1);\n  test_u8_grapheme_next (\"ab\", 2, 1);\n  test_u8_grapheme_next (\"abc\", 3, 1);\n\n  /* Multi-unit, single code point graphemes. */\n#define HIRAGANA_A \"\\343\\201\\202\" /* \u00e3\u0081\u0082: Hiragana letter 'a'. */\n  test_u8_grapheme_next (HIRAGANA_A, 3, 3);\n  test_u8_grapheme_next (HIRAGANA_A\"x\", 4, 3);\n  test_u8_grapheme_next (HIRAGANA_A HIRAGANA_A, 6, 3);\n\n  /* Combining accents. */\n#define GRAVE \"\\314\\200\"        /* Combining grave accent. */\n#define ACUTE \"\\314\\201\"        /* Combining acute accent. */\n  test_u8_grapheme_next (\"e\"ACUTE, 3, 3);\n  test_u8_grapheme_next (\"e\"ACUTE GRAVE, 5, 5);\n  test_u8_grapheme_next (\"e\"ACUTE\"x\", 4, 3);\n  test_u8_grapheme_next (\"e\"ACUTE \"e\"ACUTE, 6, 3);\n\n  return 0;\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unigbrk/test-u8-grapheme-prev.c": {
    "test_u8_grapheme_prev": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "static void\ntest_u8_grapheme_prev (const char *input, size_t n, size_t len)\n{\n  const uint8_t *s = (const uint8_t *) input;\n  const uint8_t *end = s + n;\n  const uint8_t *prev = u8_grapheme_prev (end, s);\n  if (prev != end - len)\n    {\n      size_t i;\n\n      if (prev == NULL)\n        fputs (\"u8_grapheme_prev returned NULL\", stderr);\n      else\n        fprintf (stderr, \"u8_grapheme_prev skipped %zu bytes\", end - prev);\n      fprintf (stderr, \", expected %zu:\\n\", len);\n      for (i = 0; i < n; i++)\n        fprintf (stderr, \" %02x\", s[i]);\n      putc ('\\n', stderr);\n      abort ();\n    }\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "int\nmain (void)\n{\n  static const uint8_t s[] = \"abc\";\n\n  /* Empty string. */\n  ASSERT (u8_grapheme_prev (NULL, NULL) == NULL);\n  ASSERT (u8_grapheme_prev (s, s) == NULL);\n\n  /* Standalone 1-unit graphemes.  */\n  test_u8_grapheme_prev (\"a\", 1, 1);\n  test_u8_grapheme_prev (\"ab\", 2, 1);\n  test_u8_grapheme_prev (\"abc\", 3, 1);\n\n  /* Multi-unit, single code point graphemes. */\n#define HIRAGANA_A \"\\343\\201\\202\" /* \u00e3\u0081\u0082: Hiragana letter 'a'. */\n  test_u8_grapheme_prev (HIRAGANA_A, 3, 3);\n  test_u8_grapheme_prev (HIRAGANA_A\"x\", 4, 1);\n  test_u8_grapheme_prev (HIRAGANA_A HIRAGANA_A, 6, 3);\n\n  /* Combining accents. */\n#define GRAVE \"\\314\\200\"        /* Combining grave accent. */\n#define ACUTE \"\\314\\201\"        /* Combining acute accent. */\n  test_u8_grapheme_prev (\"e\"ACUTE, 3, 3);\n  test_u8_grapheme_prev (\"e\"ACUTE GRAVE, 5, 5);\n  test_u8_grapheme_prev (\"e\"ACUTE\"x\", 4, 1);\n  test_u8_grapheme_prev (\"e\"ACUTE \"e\"ACUTE, 6, 3);\n\n  return 0;\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unigbrk/test-uc-gbrk-prop.c": {
    "graphemebreakproperty_to_string": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "const char *\ngraphemebreakproperty_to_string (int gbp)\n{\n  switch (gbp)\n    {\n#define CASE(VALUE) case GBP_##VALUE: return #VALUE;\n      CASE(OTHER)\n      CASE(CR)\n      CASE(LF)\n      CASE(CONTROL)\n      CASE(EXTEND)\n      CASE(PREPEND)\n      CASE(SPACINGMARK)\n      CASE(L)\n      CASE(V)\n      CASE(T)\n      CASE(LV)\n      CASE(LVT)\n      CASE(RI)\n      CASE(ZWJ)\n      CASE(EB)\n      CASE(EM)\n      CASE(GAZ)\n      CASE(EBG)\n    }\n  abort ();\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngraphemebreakproperty_to_string (int gbp)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "int\nmain (void)\n{\n  const struct uc_gbrk_prop_range *r;\n  ucs4_t uc;\n\n  uc = 0;\n  for (r = set; r < set + SIZEOF (set); r++)\n    {\n      for (; uc < r->end; uc++)\n        {\n          int retval = uc_graphemeclusterbreak_property (uc);\n          if (retval != r->gbp)\n            {\n              fprintf (stderr, \"uc_graphemeclusterbreak_property(%#x) \"\n                       \"yielded %s but should have been %s\\n\",\n                       uc, graphemebreakproperty_to_string (retval),\n                       graphemebreakproperty_to_string (r->gbp));\n              fflush (stderr);\n              abort ();\n            }\n        }\n    }\n  ASSERT (uc == 0x110000);\n\n  return 0;\n}",
      "lines": 27,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unigbrk/test-uc-gbrk-prop.h": {},
  "libunistring/libunistring-0.9.10/tests/unigbrk/test-uc-grapheme-breaks.c": {
    "graphemebreakproperty_to_string": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static const char *\ngraphemebreakproperty_to_string (int gbp)\n{\n  printf (\"%d\\n\", gbp);\n  switch (gbp)\n    {\n#define CASE(VALUE) case GBP_##VALUE: return #VALUE;\n      CASE(OTHER)\n      CASE(CR)\n      CASE(LF)\n      CASE(CONTROL)\n      CASE(EXTEND)\n      CASE(PREPEND)\n      CASE(SPACINGMARK)\n      CASE(L)\n      CASE(V)\n      CASE(T)\n      CASE(LV)\n      CASE(LVT)\n      CASE(RI)\n      CASE(ZWJ)\n      CASE(EB)\n      CASE(EM)\n      CASE(GAZ)\n      CASE(EBG)\n    }\n  abort ();\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ngraphemebreakproperty_to_string (int gbp)",
        "*"
      ]
    },
    "test_uc_grapheme_breaks": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "static void\ntest_uc_grapheme_breaks (const char *expected, ucs4_t *s, size_t n,\n                          const char *filename, int lineno)\n{\n  char breaks[16];\n  size_t i;\n\n  ASSERT (n <= 16);\n\n  uc_grapheme_breaks (s, n, breaks);\n  for (i = 0; i < n; i++)\n    if (breaks[i] != (expected[i] == '#'))\n      {\n        size_t j;\n\n        fprintf (stderr, \"wrong grapheme breaks:\\n\");\n\n        fprintf (stderr, \"   input:\");\n        for (j = 0; j < n; j++)\n          fprintf (stderr, \" %02x\", s[j]);\n        putc ('\\n', stderr);\n\n        fprintf (stderr, \"expected:\");\n        for (j = 0; j < n; j++)\n          fprintf (stderr, \"  %d\", expected[j] == '#');\n        putc ('\\n', stderr);\n\n        fprintf (stderr, \"  actual:\");\n        for (j = 0; j < n; j++)\n          fprintf (stderr, \"  %d\", breaks[j]);\n        putc ('\\n', stderr);\n\n        abort ();\n      }\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  const char *filename;\n  char line[1024];\n  int exit_code;\n  FILE *stream;\n  int lineno;\n\n  if (argc != 2)\n    {\n      fprintf (stderr, \"usage: %s FILENAME\\n\"\n               \"where FILENAME is the location of the GraphemeBreakTest.txt\\n\"\n               \"test file.\\n\", argv[0]);\n      exit (1);\n    }\n\n  filename = argv[1];\n  stream = fopen (filename, \"r\");\n  if (stream == NULL)\n    {\n      fprintf (stderr, \"error during fopen of '%s'\\n\", filename);\n      exit (1);\n    }\n\n  exit_code = 0;\n  lineno = 0;\n  while (fgets (line, sizeof line, stream))\n    {\n      char *comment;\n      const char *p;\n      ucs4_t s[16];\n      char breaks[16];\n      size_t i = 0;\n\n      lineno++;\n\n      comment = strchr (line, '#');\n      if (comment != NULL)\n        *comment = '\\0';\n      if (line[strspn (line, \" \\t\\r\\n\")] == '\\0')\n        continue;\n\n      s[0] = 0;\n      p = line;\n      do\n        {\n          ucs4_t next;\n\n          p += strspn (p, \" \\t\\r\\n\");\n          if (!strncmp (p, \"\\303\\267\" /* \u00c3\u00b7 */, 2))\n            {\n              breaks[i] = '#';\n              p += 2;\n            }\n          else if (!strncmp (p, \"\\303\\227\" /* \u00c3\u0097 */, 2))\n            {\n              breaks[i] = '_';\n              p += 2;\n            }\n          else\n            {\n              fprintf (stderr, \"%s:%d.%d: syntax error expecting '\u00c3\u00b7' or '\u00c3\u0097'\\n\",\n                       filename, lineno, (int) (p - line + 1));\n              exit (1);\n            }\n\n          p += strspn (p, \" \\t\\r\\n\");\n          if (*p == '\\0')\n            s[i] = 0;\n          else\n            {\n              unsigned int next_int;\n              int n;\n\n              if (sscanf (p, \"%x%n\", &next_int, &n) != 1)\n                {\n                  fprintf (stderr, \"%s:%d.%d: syntax error at '%s' \"\n                           \"expecting hexadecimal Unicode code point number\\n\",\n                           filename, lineno, (int) (p - line + 1), p);\n                  exit (1);\n                }\n              p += n;\n\n              s[i] = next_int;\n            }\n          p += strspn (p, \" \\t\\r\\n\");\n          i++;\n        }\n      while (*p != '\\0');\n\n      if (i > 0)\n        test_uc_grapheme_breaks (breaks, s, i, filename, lineno);\n    }\n\n  return exit_code;\n}",
      "lines": 97,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unigbrk/test-uc-is-grapheme-break.c": {
    "graphemebreakproperty_to_string": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "const char *\ngraphemebreakproperty_to_string (int gbp)\n{\n  printf (\"%d\\n\", gbp);\n  switch (gbp)\n    {\n#define CASE(VALUE) case GBP_##VALUE: return #VALUE;\n      CASE(OTHER)\n      CASE(CR)\n      CASE(LF)\n      CASE(CONTROL)\n      CASE(EXTEND)\n      CASE(PREPEND)\n      CASE(SPACINGMARK)\n      CASE(L)\n      CASE(V)\n      CASE(T)\n      CASE(LV)\n      CASE(LVT)\n      CASE(RI)\n      CASE(ZWJ)\n      CASE(EB)\n      CASE(EM)\n      CASE(GAZ)\n      CASE(EBG)\n    }\n  abort ();\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngraphemebreakproperty_to_string (int gbp)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  const char *filename;\n  char line[1024];\n  int exit_code;\n  FILE *stream;\n  int lineno;\n\n  if (argc != 2)\n    {\n      fprintf (stderr, \"usage: %s FILENAME\\n\"\n               \"where FILENAME is the location of the GraphemeBreakTest.txt\\n\"\n               \"test file.\\n\", argv[0]);\n      exit (1);\n    }\n\n  filename = argv[1];\n  stream = fopen (filename, \"r\");\n  if (stream == NULL)\n    {\n      fprintf (stderr, \"error during fopen of '%s'\\n\", filename);\n      exit (1);\n    }\n\n  exit_code = 0;\n  lineno = 0;\n  while (fgets (line, sizeof line, stream))\n    {\n      char *comment;\n      const char *p;\n      ucs4_t prev;\n      int last_compchar_prop;\n      size_t ri_count;\n\n      lineno++;\n\n      comment = strchr (line, '#');\n      if (comment != NULL)\n        *comment = '\\0';\n      if (line[strspn (line, \" \\t\\r\\n\")] == '\\0')\n        continue;\n\n      last_compchar_prop = -1;\n      ri_count = 0;\n      prev = 0;\n      p = line;\n      do\n        {\n          bool should_break;\n          ucs4_t next;\n\n          p += strspn (p, \" \\t\\r\\n\");\n          if (!strncmp (p, \"\\303\\267\" /* \u00c3\u00b7 */, 2))\n            {\n              should_break = true;\n              p += 2;\n            }\n          else if (!strncmp (p, \"\\303\\227\" /* \u00c3\u0097 */, 2))\n            {\n              should_break = false;\n              p += 2;\n            }\n          else\n            {\n              fprintf (stderr, \"%s:%d.%d: syntax error expecting '\u00c3\u00b7' or '\u00c3\u0097'\\n\",\n                       filename, lineno, (int) (p - line + 1));\n              exit (1);\n            }\n\n          p += strspn (p, \" \\t\\r\\n\");\n          if (*p == '\\0')\n            next = 0;\n          else\n            {\n              unsigned int next_int;\n              int n;\n\n              if (sscanf (p, \"%x%n\", &next_int, &n) != 1)\n                {\n                  fprintf (stderr, \"%s:%d.%d: syntax error at '%s' \"\n                           \"expecting hexadecimal Unicode code point number\\n\",\n                           filename, lineno, (int) (p - line + 1), p);\n                  exit (1);\n                }\n              p += n;\n\n              next = next_int;\n            }\n\n          if ((last_compchar_prop == GBP_EB\n               || last_compchar_prop == GBP_EBG)\n              && uc_graphemeclusterbreak_property (next) == GBP_EM)\n            {\n              int prev_gbp = uc_graphemeclusterbreak_property (prev);\n              int next_gbp = uc_graphemeclusterbreak_property (next);\n              fprintf (stderr, \"%s:%d: skipping GB10: should join U+%04X (%s) \"\n                       \"and U+%04X (%s)\\n\",\n                       filename, lineno,\n                       prev, graphemebreakproperty_to_string (prev_gbp),\n                       next, graphemebreakproperty_to_string (next_gbp));\n            }\n          else if (uc_graphemeclusterbreak_property (next) == GBP_RI\n                   && ri_count % 2 != 0)\n            {\n              int prev_gbp = uc_graphemeclusterbreak_property (prev);\n              int next_gbp = uc_graphemeclusterbreak_property (next);\n              fprintf (stderr, \"%s:%d: skipping GB12: should join U+%04X (%s) \"\n                       \"and U+%04X (%s)\\n\",\n                       filename, lineno,\n                       prev, graphemebreakproperty_to_string (prev_gbp),\n                       next, graphemebreakproperty_to_string (next_gbp));\n            }\n          else if (uc_is_grapheme_break (prev, next) != should_break)\n            {\n              int prev_gbp = uc_graphemeclusterbreak_property (prev);\n              int next_gbp = uc_graphemeclusterbreak_property (next);\n              fprintf (stderr, \"%s:%d: should %s U+%04X (%s) and \"\n                       \"U+%04X (%s)\\n\",\n                       filename, lineno,\n                       should_break ? \"break\" : \"join\",\n                       prev, graphemebreakproperty_to_string (prev_gbp),\n                       next, graphemebreakproperty_to_string (next_gbp));\n              exit_code = 1;\n            }\n\n          p += strspn (p, \" \\t\\r\\n\");\n          prev = next;\n\n          if (!(uc_graphemeclusterbreak_property (next) == GBP_EXTEND\n                && (last_compchar_prop == GBP_EB\n                    || last_compchar_prop == GBP_EBG)))\n            last_compchar_prop = uc_graphemeclusterbreak_property (next);\n\n          if (uc_graphemeclusterbreak_property (next) == GBP_RI)\n            ri_count++;\n          else\n            ri_count = 0;\n        }\n      while (*p != '\\0');\n    }\n\n  return exit_code;\n}",
      "lines": 144,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unigbrk/test-ulc-grapheme-breaks.c": {
    "is_8859_6_break": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "static bool\nis_8859_6_break (unsigned char c)\n{\n  /* ISO-8859-6 has combining characters in positions 0xeb through 0xf2. */\n  return !(c >= 0xeb && c <= 0xf2);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "int\nmain ()\n{\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  /* Test case n = 0.  */\n  ulc_grapheme_breaks (NULL, 0, NULL);\n\n#if HAVE_ICONV\n  {\n    /* This is just a random collection of bytes from ISO-8859-6.\n\n       (We use ISO-8859-6 because it is one of very few non-UTF-8 locale\n       encodings supported by glibc that have combining characters.) */\n    static const char s[] = \"ZYX\\352\\353W\\360\\361V\\362\";\n    enum { LENGTH = sizeof s - 1 };\n    char p[LENGTH];\n    size_t i;\n\n    ulc_grapheme_breaks (s, LENGTH, p);\n    for (i = 0; i < LENGTH; i++)\n      if (p[i] != is_8859_6_break (s[i]))\n        {\n          size_t j;\n\n          fprintf (stderr, \"wrong grapheme breaks:\\n\");\n\n          fprintf (stderr, \"   input:\");\n          for (j = 0; j < LENGTH; j++)\n            fprintf (stderr, \" %02x\", (unsigned char) s[j]);\n          putc ('\\n', stderr);\n\n          fprintf (stderr, \"expected:\");\n          for (j = 0; j < LENGTH; j++)\n            fprintf (stderr, \"  %d\", is_8859_6_break (s[j]));\n          putc ('\\n', stderr);\n\n          fprintf (stderr, \"  actual:\");\n          for (j = 0; j < LENGTH; j++)\n            fprintf (stderr, \"  %d\", p[j]);\n          putc ('\\n', stderr);\n\n          abort ();\n        }\n  }\n#endif\n\n  return 0;\n}",
      "lines": 51,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unilbrk/test-u16-possible-linebreaks.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Test case n = 0.  */\n  u16_possible_linebreaks (NULL, 0, \"GB18030\", NULL);\n\n  {\n    static const uint16_t input[61] =\n      /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n\n    {\n      char *p = (char *) malloc (SIZEOF (input));\n      size_t i;\n\n      u16_possible_linebreaks (input, SIZEOF (input), \"GB18030\", p);\n      for (i = 0; i < 61; i++)\n        {\n          ASSERT (p[i] == (i == 60 ? UC_BREAK_MANDATORY :\n                           i == 5\n                           || i == 11 || i == 25\n                           || i == 29 || i == 30\n                           || i == 45 || i == 51\n                           || i == 52 || i == 53 || i == 55 || i == 56\n                           || i == 58 || i == 59 ? UC_BREAK_POSSIBLE :\n                           UC_BREAK_PROHIBITED));\n        }\n      free (p);\n    }\n\n    {\n      char *p = (char *) malloc (SIZEOF (input));\n      size_t i;\n\n      u16_possible_linebreaks (input, SIZEOF (input), \"GB2312\", p);\n      for (i = 0; i < 61; i++)\n        {\n          ASSERT (p[i] == (i == 60 ? UC_BREAK_MANDATORY :\n                           i == 5\n                           || i == 11 || i == 25\n                           || i == 29 || i == 30\n                           || i == 37 || i == 45 || i == 51\n                           || i == 52 || i == 53 || i == 55 || i == 56\n                           || i == 58 || i == 59 ? UC_BREAK_POSSIBLE :\n                           UC_BREAK_PROHIBITED));\n        }\n      free (p);\n    }\n  }\n\n  /* Test that a break is possible after a zero-width space followed by some\n     regular spaces (rule LB8 in Unicode TR#14 revision 26).  */\n  {\n    static const uint16_t input[4] = { 'x', 0x200B, ' ', 'y' };\n    char *p = (char *) malloc (SIZEOF (input));\n    size_t i;\n\n    u16_possible_linebreaks (input, SIZEOF (input), \"UTF-8\", p);\n    for (i = 0; i < 4; i++)\n      {\n        ASSERT (p[i] == (i == 3 ? UC_BREAK_POSSIBLE : UC_BREAK_PROHIBITED));\n      }\n    free (p);\n  }\n\n  return 0;\n}",
      "lines": 73,
      "depth": 28,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unilbrk/test-u16-width-linebreaks.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Test case n = 0.  */\n  u16_width_linebreaks (NULL, 0, 80, 0, 0, NULL, \"GB18030\", NULL);\n\n  {\n    static const uint16_t input[61] =\n      /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n\n    {\n      char *p = (char *) malloc (SIZEOF (input));\n      size_t i;\n\n      u16_width_linebreaks (input, SIZEOF (input), 25, 0, 0, NULL, \"GB18030\", p);\n      for (i = 0; i < 61; i++)\n        {\n          ASSERT (p[i] == (i == 60 ? UC_BREAK_MANDATORY :\n                           i == 25 || i == 45 ? UC_BREAK_POSSIBLE :\n                           UC_BREAK_PROHIBITED));\n        }\n      free (p);\n    }\n\n    {\n      char *p = (char *) malloc (SIZEOF (input));\n      size_t i;\n\n      u16_width_linebreaks (input, SIZEOF (input), 25, 0, 0, NULL, \"GB2312\", p);\n      for (i = 0; i < 61; i++)\n        {\n          ASSERT (p[i] == (i == 60 ? UC_BREAK_MANDATORY :\n                           i == 11 || i == 25 || i == 45 ? UC_BREAK_POSSIBLE :\n                           UC_BREAK_PROHIBITED));\n        }\n      free (p);\n    }\n  }\n\n  return 0;\n}",
      "lines": 48,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unilbrk/test-u32-possible-linebreaks.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Test case n = 0.  */\n  u32_possible_linebreaks (NULL, 0, \"GB18030\", NULL);\n\n  {\n    static const uint32_t input[61] =\n      /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n\n    {\n      char *p = (char *) malloc (SIZEOF (input));\n      size_t i;\n\n      u32_possible_linebreaks (input, SIZEOF (input), \"GB18030\", p);\n      for (i = 0; i < 61; i++)\n        {\n          ASSERT (p[i] == (i == 60 ? UC_BREAK_MANDATORY :\n                           i == 5\n                           || i == 11 || i == 25\n                           || i == 29 || i == 30\n                           || i == 45 || i == 51\n                           || i == 52 || i == 53 || i == 55 || i == 56\n                           || i == 58 || i == 59 ? UC_BREAK_POSSIBLE :\n                           UC_BREAK_PROHIBITED));\n        }\n      free (p);\n    }\n\n    {\n      char *p = (char *) malloc (SIZEOF (input));\n      size_t i;\n\n      u32_possible_linebreaks (input, SIZEOF (input), \"GB2312\", p);\n      for (i = 0; i < 61; i++)\n        {\n          ASSERT (p[i] == (i == 60 ? UC_BREAK_MANDATORY :\n                           i == 5\n                           || i == 11 || i == 25\n                           || i == 29 || i == 30\n                           || i == 37 || i == 45 || i == 51\n                           || i == 52 || i == 53 || i == 55 || i == 56\n                           || i == 58 || i == 59 ? UC_BREAK_POSSIBLE :\n                           UC_BREAK_PROHIBITED));\n        }\n      free (p);\n    }\n  }\n\n  /* Test that a break is possible after a zero-width space followed by some\n     regular spaces (rule LB8 in Unicode TR#14 revision 26).  */\n  {\n    static const uint32_t input[4] = { 'x', 0x200B, ' ', 'y' };\n    char *p = (char *) malloc (SIZEOF (input));\n    size_t i;\n\n    u32_possible_linebreaks (input, SIZEOF (input), \"UTF-8\", p);\n    for (i = 0; i < 4; i++)\n      {\n        ASSERT (p[i] == (i == 3 ? UC_BREAK_POSSIBLE : UC_BREAK_PROHIBITED));\n      }\n    free (p);\n  }\n\n  return 0;\n}",
      "lines": 73,
      "depth": 28,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unilbrk/test-u32-width-linebreaks.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Test case n = 0.  */\n  u32_width_linebreaks (NULL, 0, 80, 0, 0, NULL, \"GB18030\", NULL);\n\n  {\n    static const uint32_t input[61] =\n      /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n\n    {\n      char *p = (char *) malloc (SIZEOF (input));\n      size_t i;\n\n      u32_width_linebreaks (input, SIZEOF (input), 25, 0, 0, NULL, \"GB18030\", p);\n      for (i = 0; i < 61; i++)\n        {\n          ASSERT (p[i] == (i == 60 ? UC_BREAK_MANDATORY :\n                           i == 25 || i == 45 ? UC_BREAK_POSSIBLE :\n                           UC_BREAK_PROHIBITED));\n        }\n      free (p);\n    }\n\n    {\n      char *p = (char *) malloc (SIZEOF (input));\n      size_t i;\n\n      u32_width_linebreaks (input, SIZEOF (input), 25, 0, 0, NULL, \"GB2312\", p);\n      for (i = 0; i < 61; i++)\n        {\n          ASSERT (p[i] == (i == 60 ? UC_BREAK_MANDATORY :\n                           i == 11 || i == 25 || i == 45 ? UC_BREAK_POSSIBLE :\n                           UC_BREAK_PROHIBITED));\n        }\n      free (p);\n    }\n  }\n\n  return 0;\n}",
      "lines": 48,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unilbrk/test-u8-possible-linebreaks.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Test case n = 0.  */\n  u8_possible_linebreaks (NULL, 0, \"GB18030\", NULL);\n\n  {\n    static const uint8_t input[91] =\n      /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n      \"Gr\\303\\274\\303\\237 Gott. \\320\\227\\320\\264\\321\\200\\320\\260\\320\\262\\321\\201\\321\\202\\320\\262\\321\\203\\320\\271\\321\\202\\320\\265! x=(-b\\302\\261sqrt(b\\302\\262-4ac))/(2a)  \\346\\227\\245\\346\\234\\254\\350\\252\\236,\\344\\270\\255\\346\\226\\207,\\355\\225\\234\\352\\270\\200\\n\";\n\n    {\n      char *p = (char *) malloc (SIZEOF (input));\n      size_t i;\n\n      u8_possible_linebreaks (input, SIZEOF (input), \"GB18030\", p);\n      for (i = 0; i < 91; i++)\n        {\n          ASSERT (p[i] == (i == 90 ? UC_BREAK_MANDATORY :\n                           i == 7\n                           || i == 13 || i == 39\n                           || i == 43 || i == 44\n                           || i == 61 || i == 67\n                           || i == 70 || i == 73 || i == 77 || i == 80\n                           || i == 84 || i == 87 ? UC_BREAK_POSSIBLE :\n                           UC_BREAK_PROHIBITED));\n        }\n      free (p);\n    }\n\n    {\n      char *p = (char *) malloc (SIZEOF (input));\n      size_t i;\n\n      u8_possible_linebreaks (input, SIZEOF (input), \"GB2312\", p);\n      for (i = 0; i < 91; i++)\n        {\n          ASSERT (p[i] == (i == 90 ? UC_BREAK_MANDATORY :\n                           i == 7\n                           || i == 13 || i == 39\n                           || i == 43 || i == 44\n                           || i == 52 || i == 61 || i == 67\n                           || i == 70 || i == 73 || i == 77 || i == 80\n                           || i == 84 || i == 87 ? UC_BREAK_POSSIBLE :\n                           UC_BREAK_PROHIBITED));\n        }\n      free (p);\n    }\n  }\n\n  /* Test that a break is possible after a zero-width space followed by some\n     regular spaces (rule LB8 in Unicode TR#14 revision 26).  */\n  {\n    static const uint8_t input[6] = \"x\\342\\200\\213 y\";\n    char *p = (char *) malloc (SIZEOF (input));\n    size_t i;\n\n    u8_possible_linebreaks (input, SIZEOF (input), \"UTF-8\", p);\n    for (i = 0; i < 4; i++)\n      {\n        ASSERT (p[i] == (i == 5 ? UC_BREAK_POSSIBLE : UC_BREAK_PROHIBITED));\n      }\n    free (p);\n  }\n\n  return 0;\n}",
      "lines": 67,
      "depth": 28,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unilbrk/test-u8-width-linebreaks.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Test case n = 0.  */\n  u8_width_linebreaks (NULL, 0, 80, 0, 0, NULL, \"GB18030\", NULL);\n\n  {\n    static const uint8_t input[91] =\n      /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n      \"Gr\\303\\274\\303\\237 Gott. \\320\\227\\320\\264\\321\\200\\320\\260\\320\\262\\321\\201\\321\\202\\320\\262\\321\\203\\320\\271\\321\\202\\320\\265! x=(-b\\302\\261sqrt(b\\302\\262-4ac))/(2a)  \\346\\227\\245\\346\\234\\254\\350\\252\\236,\\344\\270\\255\\346\\226\\207,\\355\\225\\234\\352\\270\\200\\n\";\n\n    {\n      char *p = (char *) malloc (SIZEOF (input));\n      size_t i;\n\n      u8_width_linebreaks (input, SIZEOF (input), 25, 0, 0, NULL, \"GB18030\", p);\n      for (i = 0; i < 91; i++)\n        {\n          ASSERT (p[i] == (i == 90 ? UC_BREAK_MANDATORY :\n                           i == 39 || i == 61 ? UC_BREAK_POSSIBLE :\n                           UC_BREAK_PROHIBITED));\n        }\n      free (p);\n    }\n\n    {\n      char *p = (char *) malloc (SIZEOF (input));\n      size_t i;\n\n      u8_width_linebreaks (input, SIZEOF (input), 25, 0, 0, NULL, \"GB2312\", p);\n      for (i = 0; i < 91; i++)\n        {\n          ASSERT (p[i] == (i == 90 ? UC_BREAK_MANDATORY :\n                           i == 13 || i == 39 || i == 61 ? UC_BREAK_POSSIBLE :\n                           UC_BREAK_PROHIBITED));\n        }\n      free (p);\n    }\n  }\n\n  return 0;\n}",
      "lines": 42,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unilbrk/test-ulc-possible-linebreaks.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Test case n = 0.  */\n  ulc_possible_linebreaks (NULL, 0, \"GB18030\", NULL);\n\n#if HAVE_ICONV\n  {\n    static const char input[36] =\n      /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)\" */\n      \"Gr\\374\\337 Gott. x=(-b\\261sqrt(b\\262-4ac))/(2a)\\n\";\n    char *p = (char *) malloc (SIZEOF (input));\n    size_t i;\n\n    ulc_possible_linebreaks (input, SIZEOF (input), \"ISO-8859-1\", p);\n    for (i = 0; i < 36; i++)\n      {\n        ASSERT (p[i] == (i == 35 ? UC_BREAK_MANDATORY :\n                         i == 5 || i == 11 || i == 15 || i == 16\n                         || i == 31 ? UC_BREAK_POSSIBLE :\n                         UC_BREAK_PROHIBITED));\n      }\n    free (p);\n  }\n#endif\n\n  return 0;\n}",
      "lines": 28,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unilbrk/test-ulc-width-linebreaks.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Test case n = 0.  */\n  ulc_width_linebreaks (NULL, 0, 80, 0, 0, NULL, \"GB18030\", NULL);\n\n#if HAVE_ICONV\n  {\n    static const char input[36] =\n      /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)\" */\n      \"Gr\\374\\337 Gott. x=(-b\\261sqrt(b\\262-4ac))/(2a)\\n\";\n    char *p = (char *) malloc (SIZEOF (input));\n    size_t i;\n\n    ulc_width_linebreaks (input, SIZEOF (input), 12, 0, 0, NULL, \"ISO-8859-1\", p);\n    for (i = 0; i < 36; i++)\n      {\n        ASSERT (p[i] == (i == 35 ? UC_BREAK_MANDATORY :\n                         i == 11 || i == 16 || i == 31 ? UC_BREAK_POSSIBLE :\n                         UC_BREAK_PROHIBITED));\n      }\n    free (p);\n  }\n#endif\n\n  return 0;\n}",
      "lines": 27,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uniname/test-uninames.c": {
    "fill_names": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "static void\nfill_names (const char *unicodedata_filename)\n{\n  FILE *stream;\n  char *field0;\n  char *field1;\n  char line[1024];\n  int lineno = 0;\n\n  stream = fopen (unicodedata_filename, \"r\");\n  if (stream == NULL)\n    {\n      fprintf (stderr, \"error during fopen of '%s'\\n\", unicodedata_filename);\n      exit (EXIT_FAILURE);\n    }\n\n  while (fgets (line, sizeof line, stream))\n    {\n      char *p;\n      char *comment;\n      unsigned long i;\n\n      lineno++;\n\n      comment = strchr (line, '#');\n      if (comment != NULL)\n        *comment = '\\0';\n      if (line[strspn (line, \" \\t\\r\\n\")] == '\\0')\n        continue;\n\n      field0 = p = line;\n      p = strchr (p, ';');\n      if (!p)\n        {\n          fprintf (stderr, \"short line in '%s':%d\\n\",\n                   unicodedata_filename, lineno);\n          exit (EXIT_FAILURE);\n        }\n      *p++ = '\\0';\n\n      field1 = p;\n      if (*field1 == '<')\n        continue;\n      p = strchr (p, ';');\n      if (!p)\n        {\n          fprintf (stderr, \"short line in '%s':%d\\n\",\n                   unicodedata_filename, lineno);\n          exit (EXIT_FAILURE);\n        }\n      *p = '\\0';\n      i = strtoul (field0, NULL, 16);\n      if (i >= 0x110000)\n        {\n          fprintf (stderr, \"index too large\\n\");\n          exit (EXIT_FAILURE);\n        }\n      unicode_names[i] = xstrdup (field1);\n    }\n  if (ferror (stream) || fclose (stream))\n    {\n      fprintf (stderr, \"error reading from '%s'\\n\", unicodedata_filename);\n      exit (1);\n    }\n}",
      "lines": 65,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fill_aliases": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "static void\nfill_aliases (const char *namealiases_filename)\n{\n  FILE *stream;\n  char *field0;\n  char *field1;\n  char line[1024];\n  int lineno = 0;\n\n  stream = fopen (namealiases_filename, \"r\");\n  if (stream == NULL)\n    {\n      fprintf (stderr, \"error during fopen of '%s'\\n\", namealiases_filename);\n      exit (EXIT_FAILURE);\n    }\n\n  while (fgets (line, sizeof line, stream))\n    {\n      char *p;\n      char *comment;\n      unsigned long uc;\n\n      comment = strchr (line, '#');\n      if (comment != NULL)\n        *comment = '\\0';\n      if (line[strspn (line, \" \\t\\r\\n\")] == '\\0')\n        continue;\n\n      lineno++;\n\n      field0 = p = line;\n      p = strchr (p, ';');\n      if (!p)\n        {\n          fprintf (stderr, \"short line in '%s':%d\\n\",\n                   namealiases_filename, lineno);\n          exit (EXIT_FAILURE);\n        }\n      *p++ = '\\0';\n\n      field1 = p;\n      p = strchr (p, ';');\n      if (!p)\n        {\n          fprintf (stderr, \"short line in '%s':%d\\n\",\n                   namealiases_filename, lineno);\n          exit (EXIT_FAILURE);\n        }\n      *p = '\\0';\n\n      uc = strtoul (field0, NULL, 16);\n      if (uc >= 0x110000)\n        {\n          fprintf (stderr, \"index too large\\n\");\n          exit (EXIT_FAILURE);\n        }\n\n      if (aliases_count == ALIASLEN)\n        {\n          fprintf (stderr, \"too many aliases\\n\");\n          exit (EXIT_FAILURE);\n        }\n      unicode_aliases[aliases_count].name = xstrdup (field1);\n      unicode_aliases[aliases_count].uc = uc;\n      aliases_count++;\n    }\n  if (ferror (stream) || fclose (stream))\n    {\n      fprintf (stderr, \"error reading from '%s'\\n\", namealiases_filename);\n      exit (1);\n    }\n}",
      "lines": 72,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "name_has_alias": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "static int\nname_has_alias (unsigned int uc)\n{\n  int i;\n  for (i = 0; i < ALIASLEN; i++)\n    if (unicode_aliases[i].uc == uc)\n      return 1;\n  return 0;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_name_lookup": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        246,
        1
      ],
      "content": "static int\ntest_name_lookup ()\n{\n  int error = 0;\n  unsigned int i;\n  char buf[UNINAME_MAX];\n\n  for (i = 0; i < 0x11000; i++)\n    {\n      char *result = unicode_character_name (i, buf);\n\n      if (unicode_names[i] != NULL)\n        {\n          if (result == NULL)\n            {\n              fprintf (stderr, \"\\\\u%04X name lookup failed!\\n\", i);\n              error = 1;\n            }\n          else if (strcmp (result, unicode_names[i]) != 0)\n            {\n              fprintf (stderr, \"\\\\u%04X name lookup returned wrong name: %s\\n\",\n                               i, result);\n              error = 1;\n            }\n        }\n      else\n        {\n          if (result != NULL)\n            {\n              fprintf (stderr, \"\\\\u%04X name lookup returned wrong name: %s\\n\",\n                               i, result);\n              error = 1;\n            }\n        }\n    }\n\n  for (i = 0x110000; i < 0x1000000; i++)\n    {\n      char *result = unicode_character_name (i, buf);\n\n      if (result != NULL)\n        {\n          fprintf (stderr, \"\\\\u%04X name lookup returned wrong name: %s\\n\",\n                           i, result);\n          error = 1;\n        }\n    }\n\n  return error;\n}",
      "lines": 50,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_inverse_lookup": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        328,
        1
      ],
      "content": "static int\ntest_inverse_lookup ()\n{\n  int error = 0;\n  unsigned int i;\n\n  /* First, verify all valid character names are recognized.  */\n  for (i = 0; i < 0x110000; i++)\n    if (unicode_names[i] != NULL)\n      {\n        unsigned int result = unicode_name_character (unicode_names[i]);\n        if (result != i)\n          {\n            if (result == UNINAME_INVALID)\n              fprintf (stderr, \"inverse name lookup of \\\"%s\\\" failed\\n\",\n                       unicode_names[i]);\n            else\n              fprintf (stderr,\n                       \"inverse name lookup of \\\"%s\\\" returned 0x%04X\\n\",\n                       unicode_names[i], result);\n            error = 1;\n          }\n      }\n\n  /* Second, generate random but likely names and verify they are not\n     recognized unless really valid.  */\n  for (i = 0; i < 10000; i++)\n    {\n      unsigned int i1, i2;\n      const char *s1;\n      const char *s2;\n      unsigned int l1, l2, j1, j2;\n      char buf[2*UNINAME_MAX];\n      unsigned int result;\n\n      do i1 = ((rand () % 0x11) << 16)\n              + ((rand () & 0xff) << 8)\n              + (rand () & 0xff);\n      while (unicode_names[i1] == NULL);\n\n      do i2 = ((rand () % 0x11) << 16)\n              + ((rand () & 0xff) << 8)\n              + (rand () & 0xff);\n      while (unicode_names[i2] == NULL);\n\n      s1 = unicode_names[i1];\n      l1 = strlen (s1);\n      s2 = unicode_names[i2];\n      l2 = strlen (s2);\n\n      /* Concatenate a starting piece of s1 with an ending piece of s2.  */\n      for (j1 = 1; j1 <= l1; j1++)\n        if (j1 == l1 || s1[j1] == ' ')\n          for (j2 = 0; j2 < l2; j2++)\n            if (j2 == 0 || s2[j2-1] == ' ')\n              {\n                memcpy (buf, s1, j1);\n                buf[j1] = ' ';\n                memcpy (buf + j1 + 1, s2 + j2, l2 - j2 + 1);\n\n                result = unicode_name_character (buf);\n                if (result != UNINAME_INVALID\n                    && !name_has_alias (result)\n                    && !(unicode_names[result] != NULL\n                         && strcmp (unicode_names[result], buf) == 0))\n                  {\n                    fprintf (stderr,\n                             \"inverse name lookup of \\\"%s\\\" returned 0x%04X\\n\",\n                             unicode_names[i], result);\n                    error = 1;\n                  }\n              }\n    }\n\n  /* Third, some extreme case that used to loop.  */\n  if (unicode_name_character (\"A A\") != UNINAME_INVALID)\n    error = 1;\n\n  return error;\n}",
      "lines": 80,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_alias_lookup": {
      "start_point": [
        331,
        0
      ],
      "end_point": [
        360,
        1
      ],
      "content": "static int\ntest_alias_lookup ()\n{\n  int error = 0;\n  unsigned int i;\n  char buf[UNINAME_MAX];\n\n  /* Verify all valid character names are recognized.  */\n  for (i = 0; i < ALIASLEN; i++)\n    if (unicode_aliases[i].uc != UNINAME_INVALID\n        /* Skip if the character has no canonical name (e.g. control\n           characters).  */\n        && unicode_character_name (unicode_aliases[i].uc, buf))\n      {\n        unsigned int result = unicode_name_character (unicode_aliases[i].name);\n        if (result != unicode_aliases[i].uc)\n          {\n            if (result == UNINAME_INVALID)\n              fprintf (stderr, \"inverse name lookup of \\\"%s\\\" failed\\n\",\n                       unicode_aliases[i].name);\n            else\n              fprintf (stderr,\n                       \"inverse name lookup of \\\"%s\\\" returned 0x%04X\\n\",\n                       unicode_aliases[i].name, result);\n            error = 1;\n          }\n      }\n\n  return error;\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        362,
        0
      ],
      "end_point": [
        389,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int error = 0;\n  int i;\n\n  for (i = 1; i < argc && strcmp (argv[i], \"--\") != 0; i++)\n    fill_names (argv[i]);\n\n  if (i < argc)\n    {\n      int j;\n      for (j = 0; j < ALIASLEN; j++)\n        unicode_aliases[j].uc = UNINAME_INVALID;\n\n      i++;\n      for (; i < argc; i++)\n        fill_aliases (argv[i]);\n    }\n\n  error |= test_name_lookup ();\n  error |= test_inverse_lookup ();\n\n  if (aliases_count > 0)\n    error |= test_alias_lookup ();\n\n  return error;\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-canonical-decomposition.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "int\nmain ()\n{\n  ucs4_t decomposed[UC_DECOMPOSITION_MAX_LENGTH];\n  int ret;\n\n  /* SPACE */\n  ret = uc_canonical_decomposition (0x0020, decomposed);\n  ASSERT (ret == -1);\n\n  /* LATIN CAPITAL LETTER A WITH DIAERESIS */\n  ret = uc_canonical_decomposition (0x00C4, decomposed);\n  ASSERT (ret == 2);\n  ASSERT (decomposed[0] == 0x0041);\n  ASSERT (decomposed[1] == 0x0308);\n\n  /* LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON */\n  ret = uc_canonical_decomposition (0x01DE, decomposed);\n  ASSERT (ret == 2);\n  ASSERT (decomposed[0] == 0x00C4);\n  ASSERT (decomposed[1] == 0x0304);\n\n  /* GREEK DIALYTIKA AND PERISPOMENI */\n  ret = uc_canonical_decomposition (0x1FC1, decomposed);\n  ASSERT (ret == 2);\n  ASSERT (decomposed[0] == 0x00A8);\n  ASSERT (decomposed[1] == 0x0342);\n\n  /* SCRIPT SMALL L */\n  ret = uc_canonical_decomposition (0x2113, decomposed);\n  ASSERT (ret == -1);\n\n  /* NO-BREAK SPACE */\n  ret = uc_canonical_decomposition (0x00A0, decomposed);\n  ASSERT (ret == -1);\n\n  /* ARABIC LETTER VEH INITIAL FORM */\n  ret = uc_canonical_decomposition (0xFB6C, decomposed);\n  ASSERT (ret == -1);\n\n  /* ARABIC LETTER VEH MEDIAL FORM */\n  ret = uc_canonical_decomposition (0xFB6D, decomposed);\n  ASSERT (ret == -1);\n\n  /* ARABIC LETTER VEH FINAL FORM */\n  ret = uc_canonical_decomposition (0xFB6B, decomposed);\n  ASSERT (ret == -1);\n\n  /* ARABIC LETTER VEH ISOLATED FORM */\n  ret = uc_canonical_decomposition (0xFB6A, decomposed);\n  ASSERT (ret == -1);\n\n  /* CIRCLED NUMBER FIFTEEN */\n  ret = uc_canonical_decomposition (0x246E, decomposed);\n  ASSERT (ret == -1);\n\n  /* TRADE MARK SIGN */\n  ret = uc_canonical_decomposition (0x2122, decomposed);\n  ASSERT (ret == -1);\n\n  /* LATIN SUBSCRIPT SMALL LETTER I */\n  ret = uc_canonical_decomposition (0x1D62, decomposed);\n  ASSERT (ret == -1);\n\n  /* PRESENTATION FORM FOR VERTICAL LEFT PARENTHESIS */\n  ret = uc_canonical_decomposition (0xFE35, decomposed);\n  ASSERT (ret == -1);\n\n  /* FULLWIDTH LATIN CAPITAL LETTER A */\n  ret = uc_canonical_decomposition (0xFF21, decomposed);\n  ASSERT (ret == -1);\n\n  /* HALFWIDTH IDEOGRAPHIC COMMA */\n  ret = uc_canonical_decomposition (0xFF64, decomposed);\n  ASSERT (ret == -1);\n\n  /* SMALL IDEOGRAPHIC COMMA */\n  ret = uc_canonical_decomposition (0xFE51, decomposed);\n  ASSERT (ret == -1);\n\n  /* SQUARE MHZ */\n  ret = uc_canonical_decomposition (0x3392, decomposed);\n  ASSERT (ret == -1);\n\n  /* VULGAR FRACTION THREE EIGHTHS */\n  ret = uc_canonical_decomposition (0x215C, decomposed);\n  ASSERT (ret == -1);\n\n  /* MICRO SIGN */\n  ret = uc_canonical_decomposition (0x00B5, decomposed);\n  ASSERT (ret == -1);\n\n  /* ARABIC LIGATURE SALLALLAHOU ALAYHE WASALLAM */\n  ret = uc_canonical_decomposition (0xFDFA, decomposed);\n  ASSERT (ret == -1);\n\n  /* HANGUL SYLLABLE GEUL */\n  ret = uc_canonical_decomposition (0xAE00, decomposed);\n  /* See the clarification at <http://www.unicode.org/versions/Unicode5.1.0/>,\n     section \"Clarification of Hangul Jamo Handling\".  */\n#if 1\n  ASSERT (ret == 2);\n  ASSERT (decomposed[0] == 0xADF8);\n  ASSERT (decomposed[1] == 0x11AF);\n#else\n  ASSERT (ret == 3);\n  ASSERT (decomposed[0] == 0x1100);\n  ASSERT (decomposed[1] == 0x1173);\n  ASSERT (decomposed[2] == 0x11AF);\n#endif\n\n  /* HANGUL SYLLABLE GEU */\n  ret = uc_canonical_decomposition (0xADF8, decomposed);\n  ASSERT (ret == 2);\n  ASSERT (decomposed[0] == 0x1100);\n  ASSERT (decomposed[1] == 0x1173);\n\n  return 0;\n}",
      "lines": 119,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-compat-decomposition.c": {
    "main": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "int\nmain ()\n{\n  ucs4_t decomposed[UC_DECOMPOSITION_MAX_LENGTH];\n  int ret;\n\n  /* SPACE */\n  ret = uc_compat_decomposition (0x0020, decomposed);\n  ASSERT (ret == -1);\n\n  /* LATIN CAPITAL LETTER A WITH DIAERESIS */\n  ret = uc_compat_decomposition (0x00C4, decomposed);\n  ASSERT (ret == 2);\n  ASSERT (decomposed[0] == 0x0041);\n  ASSERT (decomposed[1] == 0x0308);\n\n  /* LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON */\n  ret = uc_compat_decomposition (0x01DE, decomposed);\n  ASSERT (ret == 2);\n  ASSERT (decomposed[0] == 0x00C4);\n  ASSERT (decomposed[1] == 0x0304);\n\n  /* GREEK DIALYTIKA AND PERISPOMENI */\n  ret = uc_compat_decomposition (0x1FC1, decomposed);\n  ASSERT (ret == 2);\n  ASSERT (decomposed[0] == 0x00A8);\n  ASSERT (decomposed[1] == 0x0342);\n\n  /* SCRIPT SMALL L */\n  ret = uc_compat_decomposition (0x2113, decomposed);\n  ASSERT (ret == 1);\n  ASSERT (decomposed[0] == 0x006C);\n\n  /* NO-BREAK SPACE */\n  ret = uc_compat_decomposition (0x00A0, decomposed);\n  ASSERT (ret == 1);\n  ASSERT (decomposed[0] == 0x0020);\n\n  /* ARABIC LETTER VEH INITIAL FORM */\n  ret = uc_compat_decomposition (0xFB6C, decomposed);\n  ASSERT (ret == 1);\n  ASSERT (decomposed[0] == 0x06A4);\n\n  /* ARABIC LETTER VEH MEDIAL FORM */\n  ret = uc_compat_decomposition (0xFB6D, decomposed);\n  ASSERT (ret == 1);\n  ASSERT (decomposed[0] == 0x06A4);\n\n  /* ARABIC LETTER VEH FINAL FORM */\n  ret = uc_compat_decomposition (0xFB6B, decomposed);\n  ASSERT (ret == 1);\n  ASSERT (decomposed[0] == 0x06A4);\n\n  /* ARABIC LETTER VEH ISOLATED FORM */\n  ret = uc_compat_decomposition (0xFB6A, decomposed);\n  ASSERT (ret == 1);\n  ASSERT (decomposed[0] == 0x06A4);\n\n  /* CIRCLED NUMBER FIFTEEN */\n  ret = uc_compat_decomposition (0x246E, decomposed);\n  ASSERT (ret == 2);\n  ASSERT (decomposed[0] == 0x0031);\n  ASSERT (decomposed[1] == 0x0035);\n\n  /* TRADE MARK SIGN */\n  ret = uc_compat_decomposition (0x2122, decomposed);\n  ASSERT (ret == 2);\n  ASSERT (decomposed[0] == 0x0054);\n  ASSERT (decomposed[1] == 0x004D);\n\n  /* LATIN SUBSCRIPT SMALL LETTER I */\n  ret = uc_compat_decomposition (0x1D62, decomposed);\n  ASSERT (ret == 1);\n  ASSERT (decomposed[0] == 0x0069);\n\n  /* PRESENTATION FORM FOR VERTICAL LEFT PARENTHESIS */\n  ret = uc_compat_decomposition (0xFE35, decomposed);\n  ASSERT (ret == 1);\n  ASSERT (decomposed[0] == 0x0028);\n\n  /* FULLWIDTH LATIN CAPITAL LETTER A */\n  ret = uc_compat_decomposition (0xFF21, decomposed);\n  ASSERT (ret == 1);\n  ASSERT (decomposed[0] == 0x0041);\n\n  /* HALFWIDTH IDEOGRAPHIC COMMA */\n  ret = uc_compat_decomposition (0xFF64, decomposed);\n  ASSERT (ret == 1);\n  ASSERT (decomposed[0] == 0x3001);\n\n  /* SMALL IDEOGRAPHIC COMMA */\n  ret = uc_compat_decomposition (0xFE51, decomposed);\n  ASSERT (ret == 1);\n  ASSERT (decomposed[0] == 0x3001);\n\n  /* SQUARE MHZ */\n  ret = uc_compat_decomposition (0x3392, decomposed);\n  ASSERT (ret == 3);\n  ASSERT (decomposed[0] == 0x004D);\n  ASSERT (decomposed[1] == 0x0048);\n  ASSERT (decomposed[2] == 0x007A);\n\n  /* VULGAR FRACTION THREE EIGHTHS */\n  ret = uc_compat_decomposition (0x215C, decomposed);\n  ASSERT (ret == 3);\n  ASSERT (decomposed[0] == 0x0033);\n  ASSERT (decomposed[1] == 0x2044);\n  ASSERT (decomposed[2] == 0x0038);\n\n  /* MICRO SIGN */\n  ret = uc_compat_decomposition (0x00B5, decomposed);\n  ASSERT (ret == 1);\n  ASSERT (decomposed[0] == 0x03BC);\n\n  /* ARABIC LIGATURE SALLALLAHOU ALAYHE WASALLAM */\n  ret = uc_compat_decomposition (0xFDFA, decomposed);\n  ASSERT (ret == 18);\n  ASSERT (decomposed[0] == 0x0635);\n  ASSERT (decomposed[1] == 0x0644);\n  ASSERT (decomposed[2] == 0x0649);\n  ASSERT (decomposed[3] == 0x0020);\n  ASSERT (decomposed[4] == 0x0627);\n  ASSERT (decomposed[5] == 0x0644);\n  ASSERT (decomposed[6] == 0x0644);\n  ASSERT (decomposed[7] == 0x0647);\n  ASSERT (decomposed[8] == 0x0020);\n  ASSERT (decomposed[9] == 0x0639);\n  ASSERT (decomposed[10] == 0x0644);\n  ASSERT (decomposed[11] == 0x064A);\n  ASSERT (decomposed[12] == 0x0647);\n  ASSERT (decomposed[13] == 0x0020);\n  ASSERT (decomposed[14] == 0x0648);\n  ASSERT (decomposed[15] == 0x0633);\n  ASSERT (decomposed[16] == 0x0644);\n  ASSERT (decomposed[17] == 0x0645);\n\n  /* HANGUL SYLLABLE GEUL */\n  ret = uc_compat_decomposition (0xAE00, decomposed);\n  /* See the clarification at <http://www.unicode.org/versions/Unicode5.1.0/>,\n     section \"Clarification of Hangul Jamo Handling\".  */\n#if 1\n  ASSERT (ret == 2);\n  ASSERT (decomposed[0] == 0xADF8);\n  ASSERT (decomposed[1] == 0x11AF);\n#else\n  ASSERT (ret == 3);\n  ASSERT (decomposed[0] == 0x1100);\n  ASSERT (decomposed[1] == 0x1173);\n  ASSERT (decomposed[2] == 0x11AF);\n#endif\n\n  /* HANGUL SYLLABLE GEU */\n  ret = uc_compat_decomposition (0xADF8, decomposed);\n  ASSERT (ret == 2);\n  ASSERT (decomposed[0] == 0x1100);\n  ASSERT (decomposed[1] == 0x1173);\n\n  return 0;\n}",
      "lines": 159,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-composition.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "int\nmain ()\n{\n  /* LATIN CAPITAL LETTER A WITH DIAERESIS */\n  ASSERT (uc_composition (0x0041, 0x0308) == 0x00C4);\n\n  /* LATIN CAPITAL LETTER A WITH RING ABOVE */\n  ASSERT (uc_composition (0x0041, 0x030A) == 0x00C5);\n\n  /* LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON */\n  ASSERT (uc_composition (0x00C4, 0x0304) == 0x01DE);\n\n  /* GREEK DIALYTIKA AND PERISPOMENI */\n  ASSERT (uc_composition (0x00A8, 0x0342) == 0x1FC1);\n\n  /* CIRCLED NUMBER FIFTEEN */\n  ASSERT (uc_composition (0x0031, 0x0035) == 0);\n\n  /* TRADE MARK SIGN */\n  ASSERT (uc_composition (0x0054, 0x004D) == 0);\n\n  /* HANGUL SYLLABLE GEU */\n  ASSERT (uc_composition (0x1100, 0x1173) == 0xADF8);\n\n  /* HANGUL SYLLABLE GEUL */\n  ASSERT (uc_composition (0xADF8, 0x11AF) == 0xAE00);\n\n  return 0;\n}",
      "lines": 29,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-decomposing-form.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\nmain ()\n{\n  ASSERT (uninorm_decomposing_form (UNINORM_NFC) == UNINORM_NFD);\n  ASSERT (uninorm_decomposing_form (UNINORM_NFD) == UNINORM_NFD);\n  ASSERT (uninorm_decomposing_form (UNINORM_NFKC) == UNINORM_NFKD);\n  ASSERT (uninorm_decomposing_form (UNINORM_NFKD) == UNINORM_NFKD);\n\n  return 0;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-decomposition.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "int\nmain ()\n{\n  ucs4_t decomposed[UC_DECOMPOSITION_MAX_LENGTH];\n  int tag;\n  int ret;\n\n  /* SPACE */\n  ret = uc_decomposition (0x0020, &tag, decomposed);\n  ASSERT (ret == -1);\n\n  /* LATIN CAPITAL LETTER A WITH DIAERESIS */\n  ret = uc_decomposition (0x00C4, &tag, decomposed);\n  ASSERT (ret == 2);\n  ASSERT (tag == UC_DECOMP_CANONICAL);\n  ASSERT (decomposed[0] == 0x0041);\n  ASSERT (decomposed[1] == 0x0308);\n\n  /* LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON */\n  ret = uc_decomposition (0x01DE, &tag, decomposed);\n  ASSERT (ret == 2);\n  ASSERT (tag == UC_DECOMP_CANONICAL);\n  ASSERT (decomposed[0] == 0x00C4);\n  ASSERT (decomposed[1] == 0x0304);\n\n  /* GREEK DIALYTIKA AND PERISPOMENI */\n  ret = uc_decomposition (0x1FC1, &tag, decomposed);\n  ASSERT (ret == 2);\n  ASSERT (tag == UC_DECOMP_CANONICAL);\n  ASSERT (decomposed[0] == 0x00A8);\n  ASSERT (decomposed[1] == 0x0342);\n\n  /* SCRIPT SMALL L */\n  ret = uc_decomposition (0x2113, &tag, decomposed);\n  ASSERT (ret == 1);\n  ASSERT (tag == UC_DECOMP_FONT);\n  ASSERT (decomposed[0] == 0x006C);\n\n  /* NO-BREAK SPACE */\n  ret = uc_decomposition (0x00A0, &tag, decomposed);\n  ASSERT (ret == 1);\n  ASSERT (tag == UC_DECOMP_NOBREAK);\n  ASSERT (decomposed[0] == 0x0020);\n\n  /* ARABIC LETTER VEH INITIAL FORM */\n  ret = uc_decomposition (0xFB6C, &tag, decomposed);\n  ASSERT (ret == 1);\n  ASSERT (tag == UC_DECOMP_INITIAL);\n  ASSERT (decomposed[0] == 0x06A4);\n\n  /* ARABIC LETTER VEH MEDIAL FORM */\n  ret = uc_decomposition (0xFB6D, &tag, decomposed);\n  ASSERT (ret == 1);\n  ASSERT (tag == UC_DECOMP_MEDIAL);\n  ASSERT (decomposed[0] == 0x06A4);\n\n  /* ARABIC LETTER VEH FINAL FORM */\n  ret = uc_decomposition (0xFB6B, &tag, decomposed);\n  ASSERT (ret == 1);\n  ASSERT (tag == UC_DECOMP_FINAL);\n  ASSERT (decomposed[0] == 0x06A4);\n\n  /* ARABIC LETTER VEH ISOLATED FORM */\n  ret = uc_decomposition (0xFB6A, &tag, decomposed);\n  ASSERT (ret == 1);\n  ASSERT (tag == UC_DECOMP_ISOLATED);\n  ASSERT (decomposed[0] == 0x06A4);\n\n  /* CIRCLED NUMBER FIFTEEN */\n  ret = uc_decomposition (0x246E, &tag, decomposed);\n  ASSERT (ret == 2);\n  ASSERT (tag == UC_DECOMP_CIRCLE);\n  ASSERT (decomposed[0] == 0x0031);\n  ASSERT (decomposed[1] == 0x0035);\n\n  /* TRADE MARK SIGN */\n  ret = uc_decomposition (0x2122, &tag, decomposed);\n  ASSERT (ret == 2);\n  ASSERT (tag == UC_DECOMP_SUPER);\n  ASSERT (decomposed[0] == 0x0054);\n  ASSERT (decomposed[1] == 0x004D);\n\n  /* LATIN SUBSCRIPT SMALL LETTER I */\n  ret = uc_decomposition (0x1D62, &tag, decomposed);\n  ASSERT (ret == 1);\n  ASSERT (tag == UC_DECOMP_SUB);\n  ASSERT (decomposed[0] == 0x0069);\n\n  /* PRESENTATION FORM FOR VERTICAL LEFT PARENTHESIS */\n  ret = uc_decomposition (0xFE35, &tag, decomposed);\n  ASSERT (ret == 1);\n  ASSERT (tag == UC_DECOMP_VERTICAL);\n  ASSERT (decomposed[0] == 0x0028);\n\n  /* FULLWIDTH LATIN CAPITAL LETTER A */\n  ret = uc_decomposition (0xFF21, &tag, decomposed);\n  ASSERT (ret == 1);\n  ASSERT (tag == UC_DECOMP_WIDE);\n  ASSERT (decomposed[0] == 0x0041);\n\n  /* HALFWIDTH IDEOGRAPHIC COMMA */\n  ret = uc_decomposition (0xFF64, &tag, decomposed);\n  ASSERT (ret == 1);\n  ASSERT (tag == UC_DECOMP_NARROW);\n  ASSERT (decomposed[0] == 0x3001);\n\n  /* SMALL IDEOGRAPHIC COMMA */\n  ret = uc_decomposition (0xFE51, &tag, decomposed);\n  ASSERT (ret == 1);\n  ASSERT (tag == UC_DECOMP_SMALL);\n  ASSERT (decomposed[0] == 0x3001);\n\n  /* SQUARE MHZ */\n  ret = uc_decomposition (0x3392, &tag, decomposed);\n  ASSERT (ret == 3);\n  ASSERT (tag == UC_DECOMP_SQUARE);\n  ASSERT (decomposed[0] == 0x004D);\n  ASSERT (decomposed[1] == 0x0048);\n  ASSERT (decomposed[2] == 0x007A);\n\n  /* VULGAR FRACTION THREE EIGHTHS */\n  ret = uc_decomposition (0x215C, &tag, decomposed);\n  ASSERT (ret == 3);\n  ASSERT (tag == UC_DECOMP_FRACTION);\n  ASSERT (decomposed[0] == 0x0033);\n  ASSERT (decomposed[1] == 0x2044);\n  ASSERT (decomposed[2] == 0x0038);\n\n  /* MICRO SIGN */\n  ret = uc_decomposition (0x00B5, &tag, decomposed);\n  ASSERT (ret == 1);\n  ASSERT (tag == UC_DECOMP_COMPAT);\n  ASSERT (decomposed[0] == 0x03BC);\n\n  /* ARABIC LIGATURE SALLALLAHOU ALAYHE WASALLAM */\n  ret = uc_decomposition (0xFDFA, &tag, decomposed);\n  ASSERT (ret == 18);\n  ASSERT (tag == UC_DECOMP_ISOLATED);\n  ASSERT (decomposed[0] == 0x0635);\n  ASSERT (decomposed[1] == 0x0644);\n  ASSERT (decomposed[2] == 0x0649);\n  ASSERT (decomposed[3] == 0x0020);\n  ASSERT (decomposed[4] == 0x0627);\n  ASSERT (decomposed[5] == 0x0644);\n  ASSERT (decomposed[6] == 0x0644);\n  ASSERT (decomposed[7] == 0x0647);\n  ASSERT (decomposed[8] == 0x0020);\n  ASSERT (decomposed[9] == 0x0639);\n  ASSERT (decomposed[10] == 0x0644);\n  ASSERT (decomposed[11] == 0x064A);\n  ASSERT (decomposed[12] == 0x0647);\n  ASSERT (decomposed[13] == 0x0020);\n  ASSERT (decomposed[14] == 0x0648);\n  ASSERT (decomposed[15] == 0x0633);\n  ASSERT (decomposed[16] == 0x0644);\n  ASSERT (decomposed[17] == 0x0645);\n\n  /* HANGUL SYLLABLE GEUL */\n  ret = uc_decomposition (0xAE00, &tag, decomposed);\n  /* See the clarification at <http://www.unicode.org/versions/Unicode5.1.0/>,\n     section \"Clarification of Hangul Jamo Handling\".  */\n#if 1\n  ASSERT (ret == 2);\n  ASSERT (tag == UC_DECOMP_CANONICAL);\n  ASSERT (decomposed[0] == 0xADF8);\n  ASSERT (decomposed[1] == 0x11AF);\n#else\n  ASSERT (ret == 3);\n  ASSERT (tag == UC_DECOMP_CANONICAL);\n  ASSERT (decomposed[0] == 0x1100);\n  ASSERT (decomposed[1] == 0x1173);\n  ASSERT (decomposed[2] == 0x11AF);\n#endif\n\n  /* HANGUL SYLLABLE GEU */\n  ret = uc_decomposition (0xADF8, &tag, decomposed);\n  ASSERT (ret == 2);\n  ASSERT (tag == UC_DECOMP_CANONICAL);\n  ASSERT (decomposed[0] == 0x1100);\n  ASSERT (decomposed[1] == 0x1173);\n\n  return 0;\n}",
      "lines": 183,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-nfc.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Check that UNINORM_NFC is defined and links.  */\n  uninorm_t nf = UNINORM_NFC;\n  (void) nf;\n\n  test_u32_nfc ();\n  test_u16_nfc ();\n  test_u8_nfc ();\n\n  return 0;\n}",
      "lines": 13,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-nfd.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Check that UNINORM_NFD is defined and links.  */\n  uninorm_t nf = UNINORM_NFD;\n  (void) nf;\n\n  test_u32_nfd ();\n  test_u16_nfd ();\n  test_u8_nfd ();\n\n  return 0;\n}",
      "lines": 13,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-nfkc.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Check that UNINORM_NFKC is defined and links.  */\n  uninorm_t nf = UNINORM_NFKC;\n  (void) nf;\n\n  test_u32_nfkc ();\n  test_u16_nfkc ();\n  test_u8_nfkc ();\n\n  return 0;\n}",
      "lines": 13,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-nfkd.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Check that UNINORM_NFKD is defined and links.  */\n  uninorm_t nf = UNINORM_NFKD;\n  (void) nf;\n\n  test_u32_nfkd ();\n  test_u16_nfkd ();\n  test_u8_nfkd ();\n\n  return 0;\n}",
      "lines": 13,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-u16-nfc.c": {
    "check": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "static int\ncheck (const uint16_t *input, size_t input_length,\n       const uint16_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint16_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u16_normalize (UNINORM_NFC, input, input_length, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u16_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint16_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint16_t *) malloc (length * sizeof (uint16_t));\n      result = u16_normalize (UNINORM_NFC, input, input_length, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u16_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint16_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint16_t *) malloc (length * sizeof (uint16_t));\n    result = u16_normalize (UNINORM_NFC, input, input_length, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u16_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_u16_nfc": [
      {
        "start_point": [
          89,
          0
        ],
        "end_point": [
          322,
          1
        ],
        "content": "void\ntest_u16_nfc (void)\n{\n  { /* Empty string.  */\n    ASSERT (check (NULL, 0, NULL, 0) == 0);\n  }\n  { /* SPACE */\n    static const uint16_t input[]    = { 0x0020 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS */\n    static const uint16_t input[]      = { 0x00C4 };\n    static const uint16_t decomposed[] = { 0x0041, 0x0308 };\n    ASSERT (check (input, SIZEOF (input),           input, SIZEOF (input)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), input, SIZEOF (input)) == 0);\n  }\n\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON */\n    static const uint16_t input[]      = { 0x01DE };\n    static const uint16_t decomposed[] = { 0x0041, 0x0308, 0x0304 };\n    ASSERT (check (input, SIZEOF (input),           input, SIZEOF (input)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ANGSTROM SIGN */\n    static const uint16_t input[]      = { 0x212B };\n    static const uint16_t decomposed[] = { 0x0041, 0x030A };\n    static const uint16_t expected[]   = { 0x00C5 };\n    ASSERT (check (input, SIZEOF (input),           expected, SIZEOF (expected)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), expected, SIZEOF (expected)) == 0);\n    ASSERT (check (expected, SIZEOF (expected),     expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* GREEK DIALYTIKA AND PERISPOMENI */\n    static const uint16_t input[]      = { 0x1FC1 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* SCRIPT SMALL L */\n    static const uint16_t input[]      = { 0x2113 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* NO-BREAK SPACE */\n    static const uint16_t input[]      = { 0x00A0 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH INITIAL FORM */\n    static const uint16_t input[]      = { 0xFB6C };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH MEDIAL FORM */\n    static const uint16_t input[]      = { 0xFB6D };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH FINAL FORM */\n    static const uint16_t input[]      = { 0xFB6B };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH ISOLATED FORM */\n    static const uint16_t input[]      = { 0xFB6A };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* CIRCLED NUMBER FIFTEEN */\n    static const uint16_t input[]      = { 0x246E };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* TRADE MARK SIGN */\n    static const uint16_t input[]      = { 0x2122 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* LATIN SUBSCRIPT SMALL LETTER I */\n    static const uint16_t input[]      = { 0x1D62 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* PRESENTATION FORM FOR VERTICAL LEFT PARENTHESIS */\n    static const uint16_t input[]      = { 0xFE35 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* FULLWIDTH LATIN CAPITAL LETTER A */\n    static const uint16_t input[]      = { 0xFF21 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* HALFWIDTH IDEOGRAPHIC COMMA */\n    static const uint16_t input[]      = { 0xFF64 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* SMALL IDEOGRAPHIC COMMA */\n    static const uint16_t input[]      = { 0xFE51 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* SQUARE MHZ */\n    static const uint16_t input[]      = { 0x3392 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* VULGAR FRACTION THREE EIGHTHS */\n    static const uint16_t input[]      = { 0x215C };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* MICRO SIGN */\n    static const uint16_t input[]      = { 0x00B5 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LIGATURE SALLALLAHOU ALAYHE WASALLAM */\n    static const uint16_t input[]      = { 0xFDFA };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* HANGUL SYLLABLE GEUL */\n    static const uint16_t input[]      = { 0xAE00 };\n    static const uint16_t decomposed[] = { 0x1100, 0x1173, 0x11AF };\n    ASSERT (check (input, SIZEOF (input),           input, SIZEOF (input)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), input, SIZEOF (input)) == 0);\n  }\n\n  { /* HANGUL SYLLABLE GEU */\n    static const uint16_t input[]      = { 0xADF8 };\n    static const uint16_t decomposed[] = { 0x1100, 0x1173 };\n    ASSERT (check (input, SIZEOF (input),           input, SIZEOF (input)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), input, SIZEOF (input)) == 0);\n  }\n\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint16_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    static const uint16_t decomposed[] =\n      { 'G', 'r', 0x0075, 0x0308, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0438, 0x0306, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',',\n        0x1112, 0x1161, 0x11AB, 0x1100, 0x1173, 0x11AF, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input),           input, SIZEOF (input)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), input, SIZEOF (input)) == 0);\n  }\n\n#if HAVE_DECL_ALARM\n  /* Declare failure if test takes too long, by using default abort\n     caused by SIGALRM.  */\n  signal (SIGALRM, SIG_DFL);\n  alarm (50);\n#endif\n\n  /* Check that the sorting is not O(n\u00c2\u00b2) but O(n log n).  */\n  {\n    int pass;\n    for (pass = 0; pass < 3; pass++)\n      {\n        size_t repeat = 1;\n        size_t m = 100000;\n        uint16_t *input = (uint16_t *) malloc (2 * m * sizeof (uint16_t));\n        if (input != NULL)\n          {\n            uint16_t *expected = input + m;\n            size_t m1 = m / 2;\n            size_t m2 = (m - 1) / 2;\n            /* NB: m1 + m2 == m - 1.  */\n            uint16_t *p;\n            size_t i;\n\n            input[0] = 0x0041;\n            p = input + 1;\n            switch (pass)\n              {\n              case 0:\n                for (i = 0; i < m1; i++)\n                  *p++ = 0x0319;\n                for (i = 0; i < m2; i++)\n                  *p++ = 0x0300;\n                break;\n\n              case 1:\n                for (i = 0; i < m2; i++)\n                  *p++ = 0x0300;\n                for (i = 0; i < m1; i++)\n                  *p++ = 0x0319;\n                break;\n\n              case 2:\n                for (i = 0; i < m2; i++)\n                  {\n                    *p++ = 0x0319;\n                    *p++ = 0x0300;\n                  }\n                for (; i < m1; i++)\n                  *p++ = 0x0319;\n                break;\n\n              default:\n                abort ();\n              }\n\n            expected[0] = 0x00C0;\n            p = expected + 1;\n            for (i = 0; i < m1; i++)\n              *p++ = 0x0319;\n            for (i = 0; i < m2 - 1; i++)\n              *p++ = 0x0300;\n\n            for (; repeat > 0; repeat--)\n              {\n                ASSERT (check (input, m,        expected, m - 1) == 0);\n                ASSERT (check (expected, m - 1, expected, m - 1) == 0);\n              }\n\n            free (input);\n          }\n      }\n  }\n}",
        "lines": 234,
        "depth": 17,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          326,
          0
        ],
        "end_point": [
          329,
          1
        ],
        "content": "void\ntest_u16_nfc (void)\n{\n}",
        "lines": 4,
        "depth": 5,
        "decorators": [
          "void"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-u16-nfd.c": {
    "check": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "static int\ncheck (const uint16_t *input, size_t input_length,\n       const uint16_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint16_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u16_normalize (UNINORM_NFD, input, input_length, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u16_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint16_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint16_t *) malloc (length * sizeof (uint16_t));\n      result = u16_normalize (UNINORM_NFD, input, input_length, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u16_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint16_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint16_t *) malloc (length * sizeof (uint16_t));\n    result = u16_normalize (UNINORM_NFD, input, input_length, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u16_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_u16_nfd": [
      {
        "start_point": [
          89,
          0
        ],
        "end_point": [
          306,
          1
        ],
        "content": "void\ntest_u16_nfd (void)\n{\n  { /* Empty string.  */\n    ASSERT (check (NULL, 0, NULL, 0) == 0);\n  }\n  { /* SPACE */\n    static const uint16_t input[]    = { 0x0020 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS */\n    static const uint16_t input[]    = { 0x00C4 };\n    static const uint16_t expected[] = { 0x0041, 0x0308 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON */\n    static const uint16_t input[]    = { 0x01DE };\n    static const uint16_t expected[] = { 0x0041, 0x0308, 0x0304 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* GREEK DIALYTIKA AND PERISPOMENI */\n    static const uint16_t input[]    = { 0x1FC1 };\n    static const uint16_t expected[] = { 0x00A8, 0x0342 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* SCRIPT SMALL L */\n    static const uint16_t input[]    = { 0x2113 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* NO-BREAK SPACE */\n    static const uint16_t input[]    = { 0x00A0 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH INITIAL FORM */\n    static const uint16_t input[]    = { 0xFB6C };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH MEDIAL FORM */\n    static const uint16_t input[]    = { 0xFB6D };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH FINAL FORM */\n    static const uint16_t input[]    = { 0xFB6B };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH ISOLATED FORM */\n    static const uint16_t input[]    = { 0xFB6A };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* CIRCLED NUMBER FIFTEEN */\n    static const uint16_t input[]    = { 0x246E };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* TRADE MARK SIGN */\n    static const uint16_t input[]    = { 0x2122 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* LATIN SUBSCRIPT SMALL LETTER I */\n    static const uint16_t input[]    = { 0x1D62 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* PRESENTATION FORM FOR VERTICAL LEFT PARENTHESIS */\n    static const uint16_t input[]    = { 0xFE35 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* FULLWIDTH LATIN CAPITAL LETTER A */\n    static const uint16_t input[]    = { 0xFF21 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* HALFWIDTH IDEOGRAPHIC COMMA */\n    static const uint16_t input[]    = { 0xFF64 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* SMALL IDEOGRAPHIC COMMA */\n    static const uint16_t input[]    = { 0xFE51 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* SQUARE MHZ */\n    static const uint16_t input[]    = { 0x3392 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* VULGAR FRACTION THREE EIGHTHS */\n    static const uint16_t input[]    = { 0x215C };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* MICRO SIGN */\n    static const uint16_t input[]    = { 0x00B5 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LIGATURE SALLALLAHOU ALAYHE WASALLAM */\n    static const uint16_t input[]    = { 0xFDFA };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* HANGUL SYLLABLE GEUL */\n    static const uint16_t input[]    = { 0xAE00 };\n    static const uint16_t expected[] = { 0x1100, 0x1173, 0x11AF };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* HANGUL SYLLABLE GEU */\n    static const uint16_t input[]    = { 0xADF8 };\n    static const uint16_t expected[] = { 0x1100, 0x1173 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint16_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    static const uint16_t expected[] =\n      { 'G', 'r', 0x0075, 0x0308, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0438, 0x0306, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',',\n        0x1112, 0x1161, 0x11AB, 0x1100, 0x1173, 0x11AF, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n#if HAVE_DECL_ALARM\n  /* Declare failure if test takes too long, by using default abort\n     caused by SIGALRM.  */\n  signal (SIGALRM, SIG_DFL);\n  alarm (50);\n#endif\n\n  /* Check that the sorting is not O(n\u00c2\u00b2) but O(n log n).  */\n  {\n    int pass;\n    for (pass = 0; pass < 3; pass++)\n      {\n        size_t repeat = 1;\n        size_t m = 100000;\n        uint16_t *input = (uint16_t *) malloc (2 * m * sizeof (uint16_t));\n        if (input != NULL)\n          {\n            uint16_t *expected = input + m;\n            size_t m1 = m / 2;\n            size_t m2 = (m - 1) / 2;\n            /* NB: m1 + m2 == m - 1.  */\n            uint16_t *p;\n            size_t i;\n\n            input[0] = 0x0041;\n            p = input + 1;\n            switch (pass)\n              {\n              case 0:\n                for (i = 0; i < m1; i++)\n                  *p++ = 0x0319;\n                for (i = 0; i < m2; i++)\n                  *p++ = 0x0300;\n                break;\n\n              case 1:\n                for (i = 0; i < m2; i++)\n                  *p++ = 0x0300;\n                for (i = 0; i < m1; i++)\n                  *p++ = 0x0319;\n                break;\n\n              case 2:\n                for (i = 0; i < m2; i++)\n                  {\n                    *p++ = 0x0319;\n                    *p++ = 0x0300;\n                  }\n                for (; i < m1; i++)\n                  *p++ = 0x0319;\n                break;\n\n              default:\n                abort ();\n              }\n\n            expected[0] = 0x0041;\n            p = expected + 1;\n            for (i = 0; i < m1; i++)\n              *p++ = 0x0319;\n            for (i = 0; i < m2; i++)\n              *p++ = 0x0300;\n\n            for (; repeat > 0; repeat--)\n              ASSERT (check (input, m, expected, m) == 0);\n\n            free (input);\n          }\n      }\n  }\n}",
        "lines": 218,
        "depth": 17,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          310,
          0
        ],
        "end_point": [
          313,
          1
        ],
        "content": "void\ntest_u16_nfd (void)\n{\n}",
        "lines": 4,
        "depth": 5,
        "decorators": [
          "void"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-u16-nfkc.c": {
    "check": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "static int\ncheck (const uint16_t *input, size_t input_length,\n       const uint16_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint16_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u16_normalize (UNINORM_NFKC, input, input_length, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u16_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint16_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint16_t *) malloc (length * sizeof (uint16_t));\n      result = u16_normalize (UNINORM_NFKC, input, input_length, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u16_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint16_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint16_t *) malloc (length * sizeof (uint16_t));\n    result = u16_normalize (UNINORM_NFKC, input, input_length, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u16_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_u16_nfkc": [
      {
        "start_point": [
          89,
          0
        ],
        "end_point": [
          370,
          1
        ],
        "content": "void\ntest_u16_nfkc (void)\n{\n  { /* Empty string.  */\n    ASSERT (check (NULL, 0, NULL, 0) == 0);\n  }\n  { /* SPACE */\n    static const uint16_t input[]    = { 0x0020 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS */\n    static const uint16_t input[]      = { 0x00C4 };\n    static const uint16_t decomposed[] = { 0x0041, 0x0308 };\n    ASSERT (check (input, SIZEOF (input),           input, SIZEOF (input)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), input, SIZEOF (input)) == 0);\n  }\n\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON */\n    static const uint16_t input[]      = { 0x01DE };\n    static const uint16_t decomposed[] = { 0x0041, 0x0308, 0x0304 };\n    ASSERT (check (input, SIZEOF (input),           input, SIZEOF (input)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ANGSTROM SIGN */\n    static const uint16_t input[]      = { 0x212B };\n    static const uint16_t decomposed[] = { 0x0041, 0x030A };\n    static const uint16_t expected[]   = { 0x00C5 };\n    ASSERT (check (input, SIZEOF (input),           expected, SIZEOF (expected)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), expected, SIZEOF (expected)) == 0);\n    ASSERT (check (expected, SIZEOF (expected),     expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* GREEK DIALYTIKA AND PERISPOMENI */\n    static const uint16_t input[]      = { 0x1FC1 };\n    static const uint16_t decomposed[] = { 0x0020, 0x0308, 0x0342 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* SCRIPT SMALL L */\n    static const uint16_t input[]      = { 0x2113 };\n    static const uint16_t decomposed[] = { 0x006C };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* NO-BREAK SPACE */\n    static const uint16_t input[]      = { 0x00A0 };\n    static const uint16_t decomposed[] = { 0x0020 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH INITIAL FORM */\n    static const uint16_t input[]      = { 0xFB6C };\n    static const uint16_t decomposed[] = { 0x06A4 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH MEDIAL FORM */\n    static const uint16_t input[]      = { 0xFB6D };\n    static const uint16_t decomposed[] = { 0x06A4 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH FINAL FORM */\n    static const uint16_t input[]      = { 0xFB6B };\n    static const uint16_t decomposed[] = { 0x06A4 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH ISOLATED FORM */\n    static const uint16_t input[]      = { 0xFB6A };\n    static const uint16_t decomposed[] = { 0x06A4 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* CIRCLED NUMBER FIFTEEN */\n    static const uint16_t input[]      = { 0x246E };\n    static const uint16_t decomposed[] = { 0x0031, 0x0035 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* TRADE MARK SIGN */\n    static const uint16_t input[]      = { 0x2122 };\n    static const uint16_t decomposed[] = { 0x0054, 0x004D };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* LATIN SUBSCRIPT SMALL LETTER I */\n    static const uint16_t input[]      = { 0x1D62 };\n    static const uint16_t decomposed[] = { 0x0069 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* PRESENTATION FORM FOR VERTICAL LEFT PARENTHESIS */\n    static const uint16_t input[]      = { 0xFE35 };\n    static const uint16_t decomposed[] = { 0x0028 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* FULLWIDTH LATIN CAPITAL LETTER A */\n    static const uint16_t input[]      = { 0xFF21 };\n    static const uint16_t decomposed[] = { 0x0041 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* HALFWIDTH IDEOGRAPHIC COMMA */\n    static const uint16_t input[]      = { 0xFF64 };\n    static const uint16_t decomposed[] = { 0x3001 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* SMALL IDEOGRAPHIC COMMA */\n    static const uint16_t input[]      = { 0xFE51 };\n    static const uint16_t decomposed[] = { 0x3001 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* SQUARE MHZ */\n    static const uint16_t input[]      = { 0x3392 };\n    static const uint16_t decomposed[] = { 0x004D, 0x0048, 0x007A };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* VULGAR FRACTION THREE EIGHTHS */\n    static const uint16_t input[]      = { 0x215C };\n    static const uint16_t decomposed[] = { 0x0033, 0x2044, 0x0038 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* MICRO SIGN */\n    static const uint16_t input[]      = { 0x00B5 };\n    static const uint16_t decomposed[] = { 0x03BC };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* ARABIC LIGATURE SALLALLAHOU ALAYHE WASALLAM */\n    static const uint16_t input[]      = { 0xFDFA };\n    static const uint16_t decomposed[] =\n      { 0x0635, 0x0644, 0x0649, 0x0020, 0x0627, 0x0644, 0x0644, 0x0647, 0x0020,\n        0x0639, 0x0644, 0x064A, 0x0647, 0x0020, 0x0648, 0x0633, 0x0644, 0x0645\n      };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* HANGUL SYLLABLE GEUL */\n    static const uint16_t input[]      = { 0xAE00 };\n    static const uint16_t decomposed[] = { 0x1100, 0x1173, 0x11AF };\n    ASSERT (check (input, SIZEOF (input),           input, SIZEOF (input)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), input, SIZEOF (input)) == 0);\n  }\n\n  { /* HANGUL SYLLABLE GEU */\n    static const uint16_t input[]      = { 0xADF8 };\n    static const uint16_t decomposed[] = { 0x1100, 0x1173 };\n    ASSERT (check (input, SIZEOF (input),           input, SIZEOF (input)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), input, SIZEOF (input)) == 0);\n  }\n\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint16_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    static const uint16_t decomposed[] =\n      { 'G', 'r', 0x0075, 0x0308, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0438, 0x0306, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x0032,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',',\n        0x1112, 0x1161, 0x11AB, 0x1100, 0x1173, 0x11AF, '\\n'\n      };\n    static const uint16_t expected[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x0032,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input),           expected, SIZEOF (expected)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), expected, SIZEOF (expected)) == 0);\n    ASSERT (check (expected, SIZEOF (expected),     expected, SIZEOF (expected)) == 0);\n  }\n\n#if HAVE_DECL_ALARM\n  /* Declare failure if test takes too long, by using default abort\n     caused by SIGALRM.  */\n  signal (SIGALRM, SIG_DFL);\n  alarm (50);\n#endif\n\n  /* Check that the sorting is not O(n\u00c2\u00b2) but O(n log n).  */\n  {\n    int pass;\n    for (pass = 0; pass < 3; pass++)\n      {\n        size_t repeat = 1;\n        size_t m = 100000;\n        uint16_t *input = (uint16_t *) malloc (2 * m * sizeof (uint16_t));\n        if (input != NULL)\n          {\n            uint16_t *expected = input + m;\n            size_t m1 = m / 2;\n            size_t m2 = (m - 1) / 2;\n            /* NB: m1 + m2 == m - 1.  */\n            uint16_t *p;\n            size_t i;\n\n            input[0] = 0x0041;\n            p = input + 1;\n            switch (pass)\n              {\n              case 0:\n                for (i = 0; i < m1; i++)\n                  *p++ = 0x0319;\n                for (i = 0; i < m2; i++)\n                  *p++ = 0x0300;\n                break;\n\n              case 1:\n                for (i = 0; i < m2; i++)\n                  *p++ = 0x0300;\n                for (i = 0; i < m1; i++)\n                  *p++ = 0x0319;\n                break;\n\n              case 2:\n                for (i = 0; i < m2; i++)\n                  {\n                    *p++ = 0x0319;\n                    *p++ = 0x0300;\n                  }\n                for (; i < m1; i++)\n                  *p++ = 0x0319;\n                break;\n\n              default:\n                abort ();\n              }\n\n            expected[0] = 0x00C0;\n            p = expected + 1;\n            for (i = 0; i < m1; i++)\n              *p++ = 0x0319;\n            for (i = 0; i < m2 - 1; i++)\n              *p++ = 0x0300;\n\n            for (; repeat > 0; repeat--)\n              {\n                ASSERT (check (input, m,        expected, m - 1) == 0);\n                ASSERT (check (expected, m - 1, expected, m - 1) == 0);\n              }\n\n            free (input);\n          }\n      }\n  }\n}",
        "lines": 282,
        "depth": 17,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          374,
          0
        ],
        "end_point": [
          377,
          1
        ],
        "content": "void\ntest_u16_nfkc (void)\n{\n}",
        "lines": 4,
        "depth": 5,
        "decorators": [
          "void"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-u16-nfkd.c": {
    "check": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "static int\ncheck (const uint16_t *input, size_t input_length,\n       const uint16_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint16_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u16_normalize (UNINORM_NFKD, input, input_length, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u16_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint16_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint16_t *) malloc (length * sizeof (uint16_t));\n      result = u16_normalize (UNINORM_NFKD, input, input_length, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u16_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint16_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint16_t *) malloc (length * sizeof (uint16_t));\n    result = u16_normalize (UNINORM_NFKD, input, input_length, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u16_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_u16_nfkd": [
      {
        "start_point": [
          89,
          0
        ],
        "end_point": [
          326,
          1
        ],
        "content": "void\ntest_u16_nfkd (void)\n{\n  { /* Empty string.  */\n    ASSERT (check (NULL, 0, NULL, 0) == 0);\n  }\n  { /* SPACE */\n    static const uint16_t input[]    = { 0x0020 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS */\n    static const uint16_t input[]    = { 0x00C4 };\n    static const uint16_t expected[] = { 0x0041, 0x0308 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON */\n    static const uint16_t input[]    = { 0x01DE };\n    static const uint16_t expected[] = { 0x0041, 0x0308, 0x0304 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* GREEK DIALYTIKA AND PERISPOMENI */\n    static const uint16_t input[]    = { 0x1FC1 };\n    static const uint16_t expected[] = { 0x0020, 0x0308, 0x0342 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* SCRIPT SMALL L */\n    static const uint16_t input[]    = { 0x2113 };\n    static const uint16_t expected[] = { 0x006C };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* NO-BREAK SPACE */\n    static const uint16_t input[]    = { 0x00A0 };\n    static const uint16_t expected[] = { 0x0020 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH INITIAL FORM */\n    static const uint16_t input[]    = { 0xFB6C };\n    static const uint16_t expected[] = { 0x06A4 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH MEDIAL FORM */\n    static const uint16_t input[]    = { 0xFB6D };\n    static const uint16_t expected[] = { 0x06A4 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH FINAL FORM */\n    static const uint16_t input[]    = { 0xFB6B };\n    static const uint16_t expected[] = { 0x06A4 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH ISOLATED FORM */\n    static const uint16_t input[]    = { 0xFB6A };\n    static const uint16_t expected[] = { 0x06A4 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* CIRCLED NUMBER FIFTEEN */\n    static const uint16_t input[]    = { 0x246E };\n    static const uint16_t expected[] = { 0x0031, 0x0035 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* TRADE MARK SIGN */\n    static const uint16_t input[]    = { 0x2122 };\n    static const uint16_t expected[] = { 0x0054, 0x004D };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* LATIN SUBSCRIPT SMALL LETTER I */\n    static const uint16_t input[]    = { 0x1D62 };\n    static const uint16_t expected[] = { 0x0069 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* PRESENTATION FORM FOR VERTICAL LEFT PARENTHESIS */\n    static const uint16_t input[]    = { 0xFE35 };\n    static const uint16_t expected[] = { 0x0028 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* FULLWIDTH LATIN CAPITAL LETTER A */\n    static const uint16_t input[]    = { 0xFF21 };\n    static const uint16_t expected[] = { 0x0041 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* HALFWIDTH IDEOGRAPHIC COMMA */\n    static const uint16_t input[]    = { 0xFF64 };\n    static const uint16_t expected[] = { 0x3001 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* SMALL IDEOGRAPHIC COMMA */\n    static const uint16_t input[]    = { 0xFE51 };\n    static const uint16_t expected[] = { 0x3001 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* SQUARE MHZ */\n    static const uint16_t input[]    = { 0x3392 };\n    static const uint16_t expected[] = { 0x004D, 0x0048, 0x007A };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* VULGAR FRACTION THREE EIGHTHS */\n    static const uint16_t input[]    = { 0x215C };\n    static const uint16_t expected[] = { 0x0033, 0x2044, 0x0038 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* MICRO SIGN */\n    static const uint16_t input[]    = { 0x00B5 };\n    static const uint16_t expected[] = { 0x03BC };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* ARABIC LIGATURE SALLALLAHOU ALAYHE WASALLAM */\n    static const uint16_t input[]    = { 0xFDFA };\n    static const uint16_t expected[] =\n      { 0x0635, 0x0644, 0x0649, 0x0020, 0x0627, 0x0644, 0x0644, 0x0647, 0x0020,\n        0x0639, 0x0644, 0x064A, 0x0647, 0x0020, 0x0648, 0x0633, 0x0644, 0x0645\n      };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* HANGUL SYLLABLE GEUL */\n    static const uint16_t input[]    = { 0xAE00 };\n    static const uint16_t expected[] = { 0x1100, 0x1173, 0x11AF };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* HANGUL SYLLABLE GEU */\n    static const uint16_t input[]    = { 0xADF8 };\n    static const uint16_t expected[] = { 0x1100, 0x1173 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint16_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    static const uint16_t expected[] =\n      { 'G', 'r', 0x0075, 0x0308, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0438, 0x0306, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x0032,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',',\n        0x1112, 0x1161, 0x11AB, 0x1100, 0x1173, 0x11AF, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n#if HAVE_DECL_ALARM\n  /* Declare failure if test takes too long, by using default abort\n     caused by SIGALRM.  */\n  signal (SIGALRM, SIG_DFL);\n  alarm (50);\n#endif\n\n  /* Check that the sorting is not O(n\u00c2\u00b2) but O(n log n).  */\n  {\n    int pass;\n    for (pass = 0; pass < 3; pass++)\n      {\n        size_t repeat = 1;\n        size_t m = 100000;\n        uint16_t *input = (uint16_t *) malloc (2 * m * sizeof (uint16_t));\n        if (input != NULL)\n          {\n            uint16_t *expected = input + m;\n            size_t m1 = m / 2;\n            size_t m2 = (m - 1) / 2;\n            /* NB: m1 + m2 == m - 1.  */\n            uint16_t *p;\n            size_t i;\n\n            input[0] = 0x0041;\n            p = input + 1;\n            switch (pass)\n              {\n              case 0:\n                for (i = 0; i < m1; i++)\n                  *p++ = 0x0319;\n                for (i = 0; i < m2; i++)\n                  *p++ = 0x0300;\n                break;\n\n              case 1:\n                for (i = 0; i < m2; i++)\n                  *p++ = 0x0300;\n                for (i = 0; i < m1; i++)\n                  *p++ = 0x0319;\n                break;\n\n              case 2:\n                for (i = 0; i < m2; i++)\n                  {\n                    *p++ = 0x0319;\n                    *p++ = 0x0300;\n                  }\n                for (; i < m1; i++)\n                  *p++ = 0x0319;\n                break;\n\n              default:\n                abort ();\n              }\n\n            expected[0] = 0x0041;\n            p = expected + 1;\n            for (i = 0; i < m1; i++)\n              *p++ = 0x0319;\n            for (i = 0; i < m2; i++)\n              *p++ = 0x0300;\n\n            for (; repeat > 0; repeat--)\n              ASSERT (check (input, m, expected, m) == 0);\n\n            free (input);\n          }\n      }\n  }\n}",
        "lines": 238,
        "depth": 17,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          330,
          0
        ],
        "end_point": [
          333,
          1
        ],
        "content": "void\ntest_u16_nfkd (void)\n{\n}",
        "lines": 4,
        "depth": 5,
        "decorators": [
          "void"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-u16-normcmp.c": {
    "test_nonascii": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "static void\ntest_nonascii (int (*my_normcmp) (const uint16_t *, size_t, const uint16_t *, size_t, uninorm_t, int *))\n{\n  /* Normalization effects.  */\n  {\n    static const uint16_t input1[] = { 'H', 0x00F6, 'h', 'l', 'e' };\n    static const uint16_t input2[] = { 'H', 'o', 0x0308, 'h', 'l', 'e' };\n    static const uint16_t input3[] = { 'H', 0x00F6, 'h', 'l', 'e', 'n' };\n    static const uint16_t input4[] = { 'H', 'o', 0x0308, 'h', 'l', 'e', 'n' };\n    static const uint16_t input5[] = { 'H', 'u', 'r', 'z' };\n    int cmp;\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input2, SIZEOF (input2), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_normcmp (input2, SIZEOF (input2), input1, SIZEOF (input1), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_normcmp (input3, SIZEOF (input3), input4, SIZEOF (input4), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_normcmp (input4, SIZEOF (input4), input3, SIZEOF (input3), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_normcmp (input2, SIZEOF (input2), input3, SIZEOF (input3), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input4, SIZEOF (input4), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input5, SIZEOF (input5), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_normcmp (input2, SIZEOF (input2), input5, SIZEOF (input5), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n  }\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS */\n    static const uint16_t input1[] = { 0x00C4 };\n    static const uint16_t input2[] = { 0x0041, 0x0308 };\n    int cmp;\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input2, SIZEOF (input2), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON */\n    static const uint16_t input1[] = { 0x01DE };\n    static const uint16_t input2[] = { 0x0041, 0x0308, 0x0304 };\n    int cmp;\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input2, SIZEOF (input2), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* GREEK DIALYTIKA AND PERISPOMENI */\n    static const uint16_t input1[] = { 0x1FC1 };\n    static const uint16_t input2[] = { 0x00A8, 0x0342 };\n    int cmp;\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input2, SIZEOF (input2), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* HANGUL SYLLABLE GEUL */\n    static const uint16_t input1[] = { 0xAE00 };\n    static const uint16_t input2[] = { 0xADF8, 0x11AF };\n    static const uint16_t input3[] = { 0x1100, 0x1173, 0x11AF };\n    int cmp;\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input2, SIZEOF (input2), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input3, SIZEOF (input3), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* HANGUL SYLLABLE GEU */\n    static const uint16_t input1[] = { 0xADF8 };\n    static const uint16_t input2[] = { 0x1100, 0x1173 };\n    int cmp;\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input2, SIZEOF (input2), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n}",
      "lines": 81,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "int\nmain ()\n{\n  test_ascii (u16_normcmp, UNINORM_NFD);\n  test_nonascii (u16_normcmp);\n\n  return 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-u16-normcmp.h": {
    "test_ascii": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static void\ntest_ascii (int (*my_normcmp) (const uint16_t *, size_t, const uint16_t *, size_t, uninorm_t, int *),\n            uninorm_t nf)\n{\n  /* Empty string.  */\n  {\n    int cmp;\n\n    ASSERT (my_normcmp (NULL, 0, NULL, 0, nf, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  {\n    static const uint16_t input[] = { 'x', 'y' };\n    int cmp;\n\n    ASSERT (my_normcmp (input, SIZEOF (input), NULL, 0, nf, &cmp) == 0);\n    ASSERT (cmp == 1);\n\n    ASSERT (my_normcmp (NULL, 0, input, SIZEOF (input), nf, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_normcmp (input, SIZEOF (input), input, SIZEOF (input), nf, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n\n  /* Normal lexicographic order.  */\n  {\n    static const uint16_t input1[] = { 'A', 'm', 'e', 'r', 'i', 'c', 'a' };\n    static const uint16_t input2[] = { 'A', 'm', 'i', 'g', 'o' };\n    int cmp;\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input2, SIZEOF (input2), nf, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_normcmp (input2, SIZEOF (input2), input1, SIZEOF (input1), nf, &cmp) == 0);\n    ASSERT (cmp == 1);\n  }\n\n  /* Shorter and longer strings.  */\n  {\n    static const uint16_t input1[] = { 'R', 'e', 'a', 'g', 'a', 'n' };\n    static const uint16_t input2[] = { 'R', 'e', 'a', 'g', 'a', 'n', 'o', 'm', 'i', 'c', 's' };\n    int cmp;\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input2, SIZEOF (input2), nf, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_normcmp (input2, SIZEOF (input2), input1, SIZEOF (input1), nf, &cmp) == 0);\n    ASSERT (cmp == 1);\n  }\n}",
      "lines": 51,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-u16-normcoll.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "int\nmain ()\n{\n  /* In the \"C\" locale, strcoll is equivalent to strcmp, therefore u8_normcoll\n     on ASCII strings should behave like strcmp as well.  */\n  test_ascii (u16_normcoll, UNINORM_NFC);\n\n  return 0;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-u32-nfc-big.c": {
    "check": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "static int\ncheck (const uint32_t *c1, size_t c1_length,\n       const uint32_t *c2, size_t c2_length,\n       const uint32_t *c3, size_t c3_length,\n       const uint32_t *c4, size_t c4_length,\n       const uint32_t *c5, size_t c5_length)\n{\n  /* Check\n       c2 ==  NFC(c1) ==  NFC(c2) ==  NFC(c3)\n       c4 ==  NFC(c4) ==  NFC(c5)\n   */\n  {\n    size_t length;\n    uint32_t *result;\n\n    result = u32_normalize (UNINORM_NFC, c1, c1_length, NULL, &length);\n    if (!(result != NULL\n          && length == c2_length\n          && u32_cmp (result, c2, c2_length) == 0))\n      return 1;\n    free (result);\n  }\n  {\n    size_t length;\n    uint32_t *result;\n\n    result = u32_normalize (UNINORM_NFC, c2, c2_length, NULL, &length);\n    if (!(result != NULL\n          && length == c2_length\n          && u32_cmp (result, c2, c2_length) == 0))\n      return 2;\n    free (result);\n  }\n  {\n    size_t length;\n    uint32_t *result;\n\n    result = u32_normalize (UNINORM_NFC, c3, c3_length, NULL, &length);\n    if (!(result != NULL\n          && length == c2_length\n          && u32_cmp (result, c2, c2_length) == 0))\n      return 3;\n    free (result);\n  }\n  {\n    size_t length;\n    uint32_t *result;\n\n    result = u32_normalize (UNINORM_NFC, c4, c4_length, NULL, &length);\n    if (!(result != NULL\n          && length == c4_length\n          && u32_cmp (result, c4, c4_length) == 0))\n      return 4;\n    free (result);\n  }\n  {\n    size_t length;\n    uint32_t *result;\n\n    result = u32_normalize (UNINORM_NFC, c5, c5_length, NULL, &length);\n    if (!(result != NULL\n          && length == c4_length\n          && u32_cmp (result, c4, c4_length) == 0))\n      return 5;\n    free (result);\n  }\n  return 0;\n}",
      "lines": 68,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": [
      {
        "start_point": [
          98,
          0
        ],
        "end_point": [
          109,
          1
        ],
        "content": "int\nmain (int argc, char *argv[])\n{\n  struct normalization_test_file file;\n\n  read_normalization_test_file (argv[1], &file);\n\n  test_specific (&file, check);\n  test_other (&file, UNINORM_NFC);\n\n  return 0;\n}",
        "lines": 12,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          115,
          0
        ],
        "end_point": [
          120,
          1
        ],
        "content": "int\nmain ()\n{\n  fprintf (stderr, \"Skipping test: uninorm/u32-normalize module not included.\\n\");\n  return 77;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-u32-nfc.c": {
    "check": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "static int\ncheck (const uint32_t *input, size_t input_length,\n       const uint32_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint32_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u32_normalize (UNINORM_NFC, input, input_length, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u32_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint32_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint32_t *) malloc (length * sizeof (uint32_t));\n      result = u32_normalize (UNINORM_NFC, input, input_length, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u32_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint32_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint32_t *) malloc (length * sizeof (uint32_t));\n    result = u32_normalize (UNINORM_NFC, input, input_length, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u32_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_u32_nfc": [
      {
        "start_point": [
          89,
          0
        ],
        "end_point": [
          322,
          1
        ],
        "content": "void\ntest_u32_nfc (void)\n{\n  { /* Empty string.  */\n    ASSERT (check (NULL, 0, NULL, 0) == 0);\n  }\n  { /* SPACE */\n    static const uint32_t input[]    = { 0x0020 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS */\n    static const uint32_t input[]      = { 0x00C4 };\n    static const uint32_t decomposed[] = { 0x0041, 0x0308 };\n    ASSERT (check (input, SIZEOF (input),           input, SIZEOF (input)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), input, SIZEOF (input)) == 0);\n  }\n\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON */\n    static const uint32_t input[]      = { 0x01DE };\n    static const uint32_t decomposed[] = { 0x0041, 0x0308, 0x0304 };\n    ASSERT (check (input, SIZEOF (input),           input, SIZEOF (input)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ANGSTROM SIGN */\n    static const uint32_t input[]      = { 0x212B };\n    static const uint32_t decomposed[] = { 0x0041, 0x030A };\n    static const uint32_t expected[]   = { 0x00C5 };\n    ASSERT (check (input, SIZEOF (input),           expected, SIZEOF (expected)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), expected, SIZEOF (expected)) == 0);\n    ASSERT (check (expected, SIZEOF (expected),     expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* GREEK DIALYTIKA AND PERISPOMENI */\n    static const uint32_t input[]      = { 0x1FC1 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* SCRIPT SMALL L */\n    static const uint32_t input[]      = { 0x2113 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* NO-BREAK SPACE */\n    static const uint32_t input[]      = { 0x00A0 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH INITIAL FORM */\n    static const uint32_t input[]      = { 0xFB6C };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH MEDIAL FORM */\n    static const uint32_t input[]      = { 0xFB6D };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH FINAL FORM */\n    static const uint32_t input[]      = { 0xFB6B };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH ISOLATED FORM */\n    static const uint32_t input[]      = { 0xFB6A };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* CIRCLED NUMBER FIFTEEN */\n    static const uint32_t input[]      = { 0x246E };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* TRADE MARK SIGN */\n    static const uint32_t input[]      = { 0x2122 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* LATIN SUBSCRIPT SMALL LETTER I */\n    static const uint32_t input[]      = { 0x1D62 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* PRESENTATION FORM FOR VERTICAL LEFT PARENTHESIS */\n    static const uint32_t input[]      = { 0xFE35 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* FULLWIDTH LATIN CAPITAL LETTER A */\n    static const uint32_t input[]      = { 0xFF21 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* HALFWIDTH IDEOGRAPHIC COMMA */\n    static const uint32_t input[]      = { 0xFF64 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* SMALL IDEOGRAPHIC COMMA */\n    static const uint32_t input[]      = { 0xFE51 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* SQUARE MHZ */\n    static const uint32_t input[]      = { 0x3392 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* VULGAR FRACTION THREE EIGHTHS */\n    static const uint32_t input[]      = { 0x215C };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* MICRO SIGN */\n    static const uint32_t input[]      = { 0x00B5 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LIGATURE SALLALLAHOU ALAYHE WASALLAM */\n    static const uint32_t input[]      = { 0xFDFA };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* HANGUL SYLLABLE GEUL */\n    static const uint32_t input[]      = { 0xAE00 };\n    static const uint32_t decomposed[] = { 0x1100, 0x1173, 0x11AF };\n    ASSERT (check (input, SIZEOF (input),           input, SIZEOF (input)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), input, SIZEOF (input)) == 0);\n  }\n\n  { /* HANGUL SYLLABLE GEU */\n    static const uint32_t input[]      = { 0xADF8 };\n    static const uint32_t decomposed[] = { 0x1100, 0x1173 };\n    ASSERT (check (input, SIZEOF (input),           input, SIZEOF (input)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), input, SIZEOF (input)) == 0);\n  }\n\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint32_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    static const uint32_t decomposed[] =\n      { 'G', 'r', 0x0075, 0x0308, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0438, 0x0306, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',',\n        0x1112, 0x1161, 0x11AB, 0x1100, 0x1173, 0x11AF, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input),           input, SIZEOF (input)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), input, SIZEOF (input)) == 0);\n  }\n\n#if HAVE_DECL_ALARM\n  /* Declare failure if test takes too long, by using default abort\n     caused by SIGALRM.  */\n  signal (SIGALRM, SIG_DFL);\n  alarm (50);\n#endif\n\n  /* Check that the sorting is not O(n\u00c2\u00b2) but O(n log n).  */\n  {\n    int pass;\n    for (pass = 0; pass < 3; pass++)\n      {\n        size_t repeat = 1;\n        size_t m = 100000;\n        uint32_t *input = (uint32_t *) malloc (2 * m * sizeof (uint32_t));\n        if (input != NULL)\n          {\n            uint32_t *expected = input + m;\n            size_t m1 = m / 2;\n            size_t m2 = (m - 1) / 2;\n            /* NB: m1 + m2 == m - 1.  */\n            uint32_t *p;\n            size_t i;\n\n            input[0] = 0x0041;\n            p = input + 1;\n            switch (pass)\n              {\n              case 0:\n                for (i = 0; i < m1; i++)\n                  *p++ = 0x0319;\n                for (i = 0; i < m2; i++)\n                  *p++ = 0x0300;\n                break;\n\n              case 1:\n                for (i = 0; i < m2; i++)\n                  *p++ = 0x0300;\n                for (i = 0; i < m1; i++)\n                  *p++ = 0x0319;\n                break;\n\n              case 2:\n                for (i = 0; i < m2; i++)\n                  {\n                    *p++ = 0x0319;\n                    *p++ = 0x0300;\n                  }\n                for (; i < m1; i++)\n                  *p++ = 0x0319;\n                break;\n\n              default:\n                abort ();\n              }\n\n            expected[0] = 0x00C0;\n            p = expected + 1;\n            for (i = 0; i < m1; i++)\n              *p++ = 0x0319;\n            for (i = 0; i < m2 - 1; i++)\n              *p++ = 0x0300;\n\n            for (; repeat > 0; repeat--)\n              {\n                ASSERT (check (input, m,        expected, m - 1) == 0);\n                ASSERT (check (expected, m - 1, expected, m - 1) == 0);\n              }\n\n            free (input);\n          }\n      }\n  }\n}",
        "lines": 234,
        "depth": 17,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          326,
          0
        ],
        "end_point": [
          329,
          1
        ],
        "content": "void\ntest_u32_nfc (void)\n{\n}",
        "lines": 4,
        "depth": 5,
        "decorators": [
          "void"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-u32-nfd-big.c": {
    "check": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "static int\ncheck (const uint32_t *c1, size_t c1_length,\n       const uint32_t *c2, size_t c2_length,\n       const uint32_t *c3, size_t c3_length,\n       const uint32_t *c4, size_t c4_length,\n       const uint32_t *c5, size_t c5_length)\n{\n  /* Check\n       c3 ==  NFD(c1) ==  NFD(c2) ==  NFD(c3)\n       c5 ==  NFD(c4) ==  NFD(c5)\n   */\n  {\n    size_t length;\n    uint32_t *result;\n\n    result = u32_normalize (UNINORM_NFD, c1, c1_length, NULL, &length);\n    if (!(result != NULL\n          && length == c3_length\n          && u32_cmp (result, c3, c3_length) == 0))\n      return 1;\n    free (result);\n  }\n  {\n    size_t length;\n    uint32_t *result;\n\n    result = u32_normalize (UNINORM_NFD, c2, c2_length, NULL, &length);\n    if (!(result != NULL\n          && length == c3_length\n          && u32_cmp (result, c3, c3_length) == 0))\n      return 2;\n    free (result);\n  }\n  {\n    size_t length;\n    uint32_t *result;\n\n    result = u32_normalize (UNINORM_NFD, c3, c3_length, NULL, &length);\n    if (!(result != NULL\n          && length == c3_length\n          && u32_cmp (result, c3, c3_length) == 0))\n      return 3;\n    free (result);\n  }\n  {\n    size_t length;\n    uint32_t *result;\n\n    result = u32_normalize (UNINORM_NFD, c4, c4_length, NULL, &length);\n    if (!(result != NULL\n          && length == c5_length\n          && u32_cmp (result, c5, c5_length) == 0))\n      return 4;\n    free (result);\n  }\n  {\n    size_t length;\n    uint32_t *result;\n\n    result = u32_normalize (UNINORM_NFD, c5, c5_length, NULL, &length);\n    if (!(result != NULL\n          && length == c5_length\n          && u32_cmp (result, c5, c5_length) == 0))\n      return 5;\n    free (result);\n  }\n  return 0;\n}",
      "lines": 68,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": [
      {
        "start_point": [
          98,
          0
        ],
        "end_point": [
          109,
          1
        ],
        "content": "int\nmain (int argc, char *argv[])\n{\n  struct normalization_test_file file;\n\n  read_normalization_test_file (argv[1], &file);\n\n  test_specific (&file, check);\n  test_other (&file, UNINORM_NFD);\n\n  return 0;\n}",
        "lines": 12,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          115,
          0
        ],
        "end_point": [
          120,
          1
        ],
        "content": "int\nmain ()\n{\n  fprintf (stderr, \"Skipping test: uninorm/u32-normalize module not included.\\n\");\n  return 77;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-u32-nfd.c": {
    "check": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "static int\ncheck (const uint32_t *input, size_t input_length,\n       const uint32_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint32_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u32_normalize (UNINORM_NFD, input, input_length, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u32_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint32_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint32_t *) malloc (length * sizeof (uint32_t));\n      result = u32_normalize (UNINORM_NFD, input, input_length, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u32_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint32_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint32_t *) malloc (length * sizeof (uint32_t));\n    result = u32_normalize (UNINORM_NFD, input, input_length, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u32_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_u32_nfd": [
      {
        "start_point": [
          89,
          0
        ],
        "end_point": [
          306,
          1
        ],
        "content": "void\ntest_u32_nfd (void)\n{\n  { /* Empty string.  */\n    ASSERT (check (NULL, 0, NULL, 0) == 0);\n  }\n  { /* SPACE */\n    static const uint32_t input[]    = { 0x0020 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS */\n    static const uint32_t input[]    = { 0x00C4 };\n    static const uint32_t expected[] = { 0x0041, 0x0308 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON */\n    static const uint32_t input[]    = { 0x01DE };\n    static const uint32_t expected[] = { 0x0041, 0x0308, 0x0304 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* GREEK DIALYTIKA AND PERISPOMENI */\n    static const uint32_t input[]    = { 0x1FC1 };\n    static const uint32_t expected[] = { 0x00A8, 0x0342 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* SCRIPT SMALL L */\n    static const uint32_t input[]    = { 0x2113 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* NO-BREAK SPACE */\n    static const uint32_t input[]    = { 0x00A0 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH INITIAL FORM */\n    static const uint32_t input[]    = { 0xFB6C };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH MEDIAL FORM */\n    static const uint32_t input[]    = { 0xFB6D };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH FINAL FORM */\n    static const uint32_t input[]    = { 0xFB6B };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH ISOLATED FORM */\n    static const uint32_t input[]    = { 0xFB6A };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* CIRCLED NUMBER FIFTEEN */\n    static const uint32_t input[]    = { 0x246E };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* TRADE MARK SIGN */\n    static const uint32_t input[]    = { 0x2122 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* LATIN SUBSCRIPT SMALL LETTER I */\n    static const uint32_t input[]    = { 0x1D62 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* PRESENTATION FORM FOR VERTICAL LEFT PARENTHESIS */\n    static const uint32_t input[]    = { 0xFE35 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* FULLWIDTH LATIN CAPITAL LETTER A */\n    static const uint32_t input[]    = { 0xFF21 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* HALFWIDTH IDEOGRAPHIC COMMA */\n    static const uint32_t input[]    = { 0xFF64 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* SMALL IDEOGRAPHIC COMMA */\n    static const uint32_t input[]    = { 0xFE51 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* SQUARE MHZ */\n    static const uint32_t input[]    = { 0x3392 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* VULGAR FRACTION THREE EIGHTHS */\n    static const uint32_t input[]    = { 0x215C };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* MICRO SIGN */\n    static const uint32_t input[]    = { 0x00B5 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LIGATURE SALLALLAHOU ALAYHE WASALLAM */\n    static const uint32_t input[]    = { 0xFDFA };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* HANGUL SYLLABLE GEUL */\n    static const uint32_t input[]    = { 0xAE00 };\n    static const uint32_t expected[] = { 0x1100, 0x1173, 0x11AF };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* HANGUL SYLLABLE GEU */\n    static const uint32_t input[]    = { 0xADF8 };\n    static const uint32_t expected[] = { 0x1100, 0x1173 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint32_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    static const uint32_t expected[] =\n      { 'G', 'r', 0x0075, 0x0308, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0438, 0x0306, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',',\n        0x1112, 0x1161, 0x11AB, 0x1100, 0x1173, 0x11AF, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n#if HAVE_DECL_ALARM\n  /* Declare failure if test takes too long, by using default abort\n     caused by SIGALRM.  */\n  signal (SIGALRM, SIG_DFL);\n  alarm (50);\n#endif\n\n  /* Check that the sorting is not O(n\u00c2\u00b2) but O(n log n).  */\n  {\n    int pass;\n    for (pass = 0; pass < 3; pass++)\n      {\n        size_t repeat = 1;\n        size_t m = 100000;\n        uint32_t *input = (uint32_t *) malloc (2 * m * sizeof (uint32_t));\n        if (input != NULL)\n          {\n            uint32_t *expected = input + m;\n            size_t m1 = m / 2;\n            size_t m2 = (m - 1) / 2;\n            /* NB: m1 + m2 == m - 1.  */\n            uint32_t *p;\n            size_t i;\n\n            input[0] = 0x0041;\n            p = input + 1;\n            switch (pass)\n              {\n              case 0:\n                for (i = 0; i < m1; i++)\n                  *p++ = 0x0319;\n                for (i = 0; i < m2; i++)\n                  *p++ = 0x0300;\n                break;\n\n              case 1:\n                for (i = 0; i < m2; i++)\n                  *p++ = 0x0300;\n                for (i = 0; i < m1; i++)\n                  *p++ = 0x0319;\n                break;\n\n              case 2:\n                for (i = 0; i < m2; i++)\n                  {\n                    *p++ = 0x0319;\n                    *p++ = 0x0300;\n                  }\n                for (; i < m1; i++)\n                  *p++ = 0x0319;\n                break;\n\n              default:\n                abort ();\n              }\n\n            expected[0] = 0x0041;\n            p = expected + 1;\n            for (i = 0; i < m1; i++)\n              *p++ = 0x0319;\n            for (i = 0; i < m2; i++)\n              *p++ = 0x0300;\n\n            for (; repeat > 0; repeat--)\n              ASSERT (check (input, m, expected, m) == 0);\n\n            free (input);\n          }\n      }\n  }\n}",
        "lines": 218,
        "depth": 17,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          310,
          0
        ],
        "end_point": [
          313,
          1
        ],
        "content": "void\ntest_u32_nfd (void)\n{\n}",
        "lines": 4,
        "depth": 5,
        "decorators": [
          "void"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-u32-nfkc-big.c": {
    "check": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static int\ncheck (const uint32_t *c1, size_t c1_length,\n       const uint32_t *c2, size_t c2_length,\n       const uint32_t *c3, size_t c3_length,\n       const uint32_t *c4, size_t c4_length,\n       const uint32_t *c5, size_t c5_length)\n{\n  /* Check c4 == NFKC(c1) == NFKC(c2) == NFKC(c3) == NFKC(c4) == NFKC(c5).  */\n  {\n    size_t length;\n    uint32_t *result;\n\n    result = u32_normalize (UNINORM_NFKC, c1, c1_length, NULL, &length);\n    if (!(result != NULL\n          && length == c4_length\n          && u32_cmp (result, c4, c4_length) == 0))\n      return 1;\n    free (result);\n  }\n  {\n    size_t length;\n    uint32_t *result;\n\n    result = u32_normalize (UNINORM_NFKC, c2, c2_length, NULL, &length);\n    if (!(result != NULL\n          && length == c4_length\n          && u32_cmp (result, c4, c4_length) == 0))\n      return 2;\n    free (result);\n  }\n  {\n    size_t length;\n    uint32_t *result;\n\n    result = u32_normalize (UNINORM_NFKC, c3, c3_length, NULL, &length);\n    if (!(result != NULL\n          && length == c4_length\n          && u32_cmp (result, c4, c4_length) == 0))\n      return 3;\n    free (result);\n  }\n  {\n    size_t length;\n    uint32_t *result;\n\n    result = u32_normalize (UNINORM_NFKC, c4, c4_length, NULL, &length);\n    if (!(result != NULL\n          && length == c4_length\n          && u32_cmp (result, c4, c4_length) == 0))\n      return 4;\n    free (result);\n  }\n  {\n    size_t length;\n    uint32_t *result;\n\n    result = u32_normalize (UNINORM_NFKC, c5, c5_length, NULL, &length);\n    if (!(result != NULL\n          && length == c4_length\n          && u32_cmp (result, c4, c4_length) == 0))\n      return 5;\n    free (result);\n  }\n  return 0;\n}",
      "lines": 65,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": [
      {
        "start_point": [
          95,
          0
        ],
        "end_point": [
          106,
          1
        ],
        "content": "int\nmain (int argc, char *argv[])\n{\n  struct normalization_test_file file;\n\n  read_normalization_test_file (argv[1], &file);\n\n  test_specific (&file, check);\n  test_other (&file, UNINORM_NFKC);\n\n  return 0;\n}",
        "lines": 12,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          112,
          0
        ],
        "end_point": [
          117,
          1
        ],
        "content": "int\nmain ()\n{\n  fprintf (stderr, \"Skipping test: uninorm/u32-normalize module not included.\\n\");\n  return 77;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-u32-nfkc.c": {
    "check": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "static int\ncheck (const uint32_t *input, size_t input_length,\n       const uint32_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint32_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u32_normalize (UNINORM_NFKC, input, input_length, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u32_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint32_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint32_t *) malloc (length * sizeof (uint32_t));\n      result = u32_normalize (UNINORM_NFKC, input, input_length, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u32_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint32_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint32_t *) malloc (length * sizeof (uint32_t));\n    result = u32_normalize (UNINORM_NFKC, input, input_length, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u32_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_u32_nfkc": [
      {
        "start_point": [
          89,
          0
        ],
        "end_point": [
          370,
          1
        ],
        "content": "void\ntest_u32_nfkc (void)\n{\n  { /* Empty string.  */\n    ASSERT (check (NULL, 0, NULL, 0) == 0);\n  }\n  { /* SPACE */\n    static const uint32_t input[]    = { 0x0020 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS */\n    static const uint32_t input[]      = { 0x00C4 };\n    static const uint32_t decomposed[] = { 0x0041, 0x0308 };\n    ASSERT (check (input, SIZEOF (input),           input, SIZEOF (input)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), input, SIZEOF (input)) == 0);\n  }\n\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON */\n    static const uint32_t input[]      = { 0x01DE };\n    static const uint32_t decomposed[] = { 0x0041, 0x0308, 0x0304 };\n    ASSERT (check (input, SIZEOF (input),           input, SIZEOF (input)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ANGSTROM SIGN */\n    static const uint32_t input[]      = { 0x212B };\n    static const uint32_t decomposed[] = { 0x0041, 0x030A };\n    static const uint32_t expected[]   = { 0x00C5 };\n    ASSERT (check (input, SIZEOF (input),           expected, SIZEOF (expected)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), expected, SIZEOF (expected)) == 0);\n    ASSERT (check (expected, SIZEOF (expected),     expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* GREEK DIALYTIKA AND PERISPOMENI */\n    static const uint32_t input[]      = { 0x1FC1 };\n    static const uint32_t decomposed[] = { 0x0020, 0x0308, 0x0342 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* SCRIPT SMALL L */\n    static const uint32_t input[]      = { 0x2113 };\n    static const uint32_t decomposed[] = { 0x006C };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* NO-BREAK SPACE */\n    static const uint32_t input[]      = { 0x00A0 };\n    static const uint32_t decomposed[] = { 0x0020 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH INITIAL FORM */\n    static const uint32_t input[]      = { 0xFB6C };\n    static const uint32_t decomposed[] = { 0x06A4 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH MEDIAL FORM */\n    static const uint32_t input[]      = { 0xFB6D };\n    static const uint32_t decomposed[] = { 0x06A4 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH FINAL FORM */\n    static const uint32_t input[]      = { 0xFB6B };\n    static const uint32_t decomposed[] = { 0x06A4 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH ISOLATED FORM */\n    static const uint32_t input[]      = { 0xFB6A };\n    static const uint32_t decomposed[] = { 0x06A4 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* CIRCLED NUMBER FIFTEEN */\n    static const uint32_t input[]      = { 0x246E };\n    static const uint32_t decomposed[] = { 0x0031, 0x0035 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* TRADE MARK SIGN */\n    static const uint32_t input[]      = { 0x2122 };\n    static const uint32_t decomposed[] = { 0x0054, 0x004D };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* LATIN SUBSCRIPT SMALL LETTER I */\n    static const uint32_t input[]      = { 0x1D62 };\n    static const uint32_t decomposed[] = { 0x0069 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* PRESENTATION FORM FOR VERTICAL LEFT PARENTHESIS */\n    static const uint32_t input[]      = { 0xFE35 };\n    static const uint32_t decomposed[] = { 0x0028 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* FULLWIDTH LATIN CAPITAL LETTER A */\n    static const uint32_t input[]      = { 0xFF21 };\n    static const uint32_t decomposed[] = { 0x0041 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* HALFWIDTH IDEOGRAPHIC COMMA */\n    static const uint32_t input[]      = { 0xFF64 };\n    static const uint32_t decomposed[] = { 0x3001 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* SMALL IDEOGRAPHIC COMMA */\n    static const uint32_t input[]      = { 0xFE51 };\n    static const uint32_t decomposed[] = { 0x3001 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* SQUARE MHZ */\n    static const uint32_t input[]      = { 0x3392 };\n    static const uint32_t decomposed[] = { 0x004D, 0x0048, 0x007A };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* VULGAR FRACTION THREE EIGHTHS */\n    static const uint32_t input[]      = { 0x215C };\n    static const uint32_t decomposed[] = { 0x0033, 0x2044, 0x0038 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* MICRO SIGN */\n    static const uint32_t input[]      = { 0x00B5 };\n    static const uint32_t decomposed[] = { 0x03BC };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* ARABIC LIGATURE SALLALLAHOU ALAYHE WASALLAM */\n    static const uint32_t input[]      = { 0xFDFA };\n    static const uint32_t decomposed[] =\n      { 0x0635, 0x0644, 0x0649, 0x0020, 0x0627, 0x0644, 0x0644, 0x0647, 0x0020,\n        0x0639, 0x0644, 0x064A, 0x0647, 0x0020, 0x0648, 0x0633, 0x0644, 0x0645\n      };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* HANGUL SYLLABLE GEUL */\n    static const uint32_t input[]      = { 0xAE00 };\n    static const uint32_t decomposed[] = { 0x1100, 0x1173, 0x11AF };\n    ASSERT (check (input, SIZEOF (input),           input, SIZEOF (input)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), input, SIZEOF (input)) == 0);\n  }\n\n  { /* HANGUL SYLLABLE GEU */\n    static const uint32_t input[]      = { 0xADF8 };\n    static const uint32_t decomposed[] = { 0x1100, 0x1173 };\n    ASSERT (check (input, SIZEOF (input),           input, SIZEOF (input)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), input, SIZEOF (input)) == 0);\n  }\n\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint32_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    static const uint32_t decomposed[] =\n      { 'G', 'r', 0x0075, 0x0308, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0438, 0x0306, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x0032,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',',\n        0x1112, 0x1161, 0x11AB, 0x1100, 0x1173, 0x11AF, '\\n'\n      };\n    static const uint32_t expected[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x0032,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input),           expected, SIZEOF (expected)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), expected, SIZEOF (expected)) == 0);\n    ASSERT (check (expected, SIZEOF (expected),     expected, SIZEOF (expected)) == 0);\n  }\n\n#if HAVE_DECL_ALARM\n  /* Declare failure if test takes too long, by using default abort\n     caused by SIGALRM.  */\n  signal (SIGALRM, SIG_DFL);\n  alarm (50);\n#endif\n\n  /* Check that the sorting is not O(n\u00c2\u00b2) but O(n log n).  */\n  {\n    int pass;\n    for (pass = 0; pass < 3; pass++)\n      {\n        size_t repeat = 1;\n        size_t m = 100000;\n        uint32_t *input = (uint32_t *) malloc (2 * m * sizeof (uint32_t));\n        if (input != NULL)\n          {\n            uint32_t *expected = input + m;\n            size_t m1 = m / 2;\n            size_t m2 = (m - 1) / 2;\n            /* NB: m1 + m2 == m - 1.  */\n            uint32_t *p;\n            size_t i;\n\n            input[0] = 0x0041;\n            p = input + 1;\n            switch (pass)\n              {\n              case 0:\n                for (i = 0; i < m1; i++)\n                  *p++ = 0x0319;\n                for (i = 0; i < m2; i++)\n                  *p++ = 0x0300;\n                break;\n\n              case 1:\n                for (i = 0; i < m2; i++)\n                  *p++ = 0x0300;\n                for (i = 0; i < m1; i++)\n                  *p++ = 0x0319;\n                break;\n\n              case 2:\n                for (i = 0; i < m2; i++)\n                  {\n                    *p++ = 0x0319;\n                    *p++ = 0x0300;\n                  }\n                for (; i < m1; i++)\n                  *p++ = 0x0319;\n                break;\n\n              default:\n                abort ();\n              }\n\n            expected[0] = 0x00C0;\n            p = expected + 1;\n            for (i = 0; i < m1; i++)\n              *p++ = 0x0319;\n            for (i = 0; i < m2 - 1; i++)\n              *p++ = 0x0300;\n\n            for (; repeat > 0; repeat--)\n              {\n                ASSERT (check (input, m,        expected, m - 1) == 0);\n                ASSERT (check (expected, m - 1, expected, m - 1) == 0);\n              }\n\n            free (input);\n          }\n      }\n  }\n}",
        "lines": 282,
        "depth": 17,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          374,
          0
        ],
        "end_point": [
          377,
          1
        ],
        "content": "void\ntest_u32_nfkc (void)\n{\n}",
        "lines": 4,
        "depth": 5,
        "decorators": [
          "void"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-u32-nfkd-big.c": {
    "check": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static int\ncheck (const uint32_t *c1, size_t c1_length,\n       const uint32_t *c2, size_t c2_length,\n       const uint32_t *c3, size_t c3_length,\n       const uint32_t *c4, size_t c4_length,\n       const uint32_t *c5, size_t c5_length)\n{\n  /* Check c5 == NFKD(c1) == NFKD(c2) == NFKD(c3) == NFKD(c4) == NFKD(c5).  */\n  {\n    size_t length;\n    uint32_t *result;\n\n    result = u32_normalize (UNINORM_NFKD, c1, c1_length, NULL, &length);\n    if (!(result != NULL\n          && length == c5_length\n          && u32_cmp (result, c5, c5_length) == 0))\n      return 1;\n    free (result);\n  }\n  {\n    size_t length;\n    uint32_t *result;\n\n    result = u32_normalize (UNINORM_NFKD, c2, c2_length, NULL, &length);\n    if (!(result != NULL\n          && length == c5_length\n          && u32_cmp (result, c5, c5_length) == 0))\n      return 2;\n    free (result);\n  }\n  {\n    size_t length;\n    uint32_t *result;\n\n    result = u32_normalize (UNINORM_NFKD, c3, c3_length, NULL, &length);\n    if (!(result != NULL\n          && length == c5_length\n          && u32_cmp (result, c5, c5_length) == 0))\n      return 3;\n    free (result);\n  }\n  {\n    size_t length;\n    uint32_t *result;\n\n    result = u32_normalize (UNINORM_NFKD, c4, c4_length, NULL, &length);\n    if (!(result != NULL\n          && length == c5_length\n          && u32_cmp (result, c5, c5_length) == 0))\n      return 4;\n    free (result);\n  }\n  {\n    size_t length;\n    uint32_t *result;\n\n    result = u32_normalize (UNINORM_NFKD, c5, c5_length, NULL, &length);\n    if (!(result != NULL\n          && length == c5_length\n          && u32_cmp (result, c5, c5_length) == 0))\n      return 5;\n    free (result);\n  }\n  return 0;\n}",
      "lines": 65,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": [
      {
        "start_point": [
          95,
          0
        ],
        "end_point": [
          106,
          1
        ],
        "content": "int\nmain (int argc, char *argv[])\n{\n  struct normalization_test_file file;\n\n  read_normalization_test_file (argv[1], &file);\n\n  test_specific (&file, check);\n  test_other (&file, UNINORM_NFKD);\n\n  return 0;\n}",
        "lines": 12,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          112,
          0
        ],
        "end_point": [
          117,
          1
        ],
        "content": "int\nmain ()\n{\n  fprintf (stderr, \"Skipping test: uninorm/u32-normalize module not included.\\n\");\n  return 77;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-u32-nfkd.c": {
    "check": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "static int\ncheck (const uint32_t *input, size_t input_length,\n       const uint32_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint32_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u32_normalize (UNINORM_NFKD, input, input_length, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u32_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint32_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint32_t *) malloc (length * sizeof (uint32_t));\n      result = u32_normalize (UNINORM_NFKD, input, input_length, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u32_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint32_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint32_t *) malloc (length * sizeof (uint32_t));\n    result = u32_normalize (UNINORM_NFKD, input, input_length, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u32_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_u32_nfkd": [
      {
        "start_point": [
          89,
          0
        ],
        "end_point": [
          326,
          1
        ],
        "content": "void\ntest_u32_nfkd (void)\n{\n  { /* Empty string.  */\n    ASSERT (check (NULL, 0, NULL, 0) == 0);\n  }\n  { /* SPACE */\n    static const uint32_t input[]    = { 0x0020 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS */\n    static const uint32_t input[]    = { 0x00C4 };\n    static const uint32_t expected[] = { 0x0041, 0x0308 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON */\n    static const uint32_t input[]    = { 0x01DE };\n    static const uint32_t expected[] = { 0x0041, 0x0308, 0x0304 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* GREEK DIALYTIKA AND PERISPOMENI */\n    static const uint32_t input[]    = { 0x1FC1 };\n    static const uint32_t expected[] = { 0x0020, 0x0308, 0x0342 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* SCRIPT SMALL L */\n    static const uint32_t input[]    = { 0x2113 };\n    static const uint32_t expected[] = { 0x006C };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* NO-BREAK SPACE */\n    static const uint32_t input[]    = { 0x00A0 };\n    static const uint32_t expected[] = { 0x0020 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH INITIAL FORM */\n    static const uint32_t input[]    = { 0xFB6C };\n    static const uint32_t expected[] = { 0x06A4 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH MEDIAL FORM */\n    static const uint32_t input[]    = { 0xFB6D };\n    static const uint32_t expected[] = { 0x06A4 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH FINAL FORM */\n    static const uint32_t input[]    = { 0xFB6B };\n    static const uint32_t expected[] = { 0x06A4 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH ISOLATED FORM */\n    static const uint32_t input[]    = { 0xFB6A };\n    static const uint32_t expected[] = { 0x06A4 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* CIRCLED NUMBER FIFTEEN */\n    static const uint32_t input[]    = { 0x246E };\n    static const uint32_t expected[] = { 0x0031, 0x0035 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* TRADE MARK SIGN */\n    static const uint32_t input[]    = { 0x2122 };\n    static const uint32_t expected[] = { 0x0054, 0x004D };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* LATIN SUBSCRIPT SMALL LETTER I */\n    static const uint32_t input[]    = { 0x1D62 };\n    static const uint32_t expected[] = { 0x0069 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* PRESENTATION FORM FOR VERTICAL LEFT PARENTHESIS */\n    static const uint32_t input[]    = { 0xFE35 };\n    static const uint32_t expected[] = { 0x0028 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* FULLWIDTH LATIN CAPITAL LETTER A */\n    static const uint32_t input[]    = { 0xFF21 };\n    static const uint32_t expected[] = { 0x0041 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* HALFWIDTH IDEOGRAPHIC COMMA */\n    static const uint32_t input[]    = { 0xFF64 };\n    static const uint32_t expected[] = { 0x3001 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* SMALL IDEOGRAPHIC COMMA */\n    static const uint32_t input[]    = { 0xFE51 };\n    static const uint32_t expected[] = { 0x3001 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* SQUARE MHZ */\n    static const uint32_t input[]    = { 0x3392 };\n    static const uint32_t expected[] = { 0x004D, 0x0048, 0x007A };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* VULGAR FRACTION THREE EIGHTHS */\n    static const uint32_t input[]    = { 0x215C };\n    static const uint32_t expected[] = { 0x0033, 0x2044, 0x0038 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* MICRO SIGN */\n    static const uint32_t input[]    = { 0x00B5 };\n    static const uint32_t expected[] = { 0x03BC };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* ARABIC LIGATURE SALLALLAHOU ALAYHE WASALLAM */\n    static const uint32_t input[]    = { 0xFDFA };\n    static const uint32_t expected[] =\n      { 0x0635, 0x0644, 0x0649, 0x0020, 0x0627, 0x0644, 0x0644, 0x0647, 0x0020,\n        0x0639, 0x0644, 0x064A, 0x0647, 0x0020, 0x0648, 0x0633, 0x0644, 0x0645\n      };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* HANGUL SYLLABLE GEUL */\n    static const uint32_t input[]    = { 0xAE00 };\n    static const uint32_t expected[] = { 0x1100, 0x1173, 0x11AF };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* HANGUL SYLLABLE GEU */\n    static const uint32_t input[]    = { 0xADF8 };\n    static const uint32_t expected[] = { 0x1100, 0x1173 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint32_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    static const uint32_t expected[] =\n      { 'G', 'r', 0x0075, 0x0308, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0438, 0x0306, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x0032,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',',\n        0x1112, 0x1161, 0x11AB, 0x1100, 0x1173, 0x11AF, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n#if HAVE_DECL_ALARM\n  /* Declare failure if test takes too long, by using default abort\n     caused by SIGALRM.  */\n  signal (SIGALRM, SIG_DFL);\n  alarm (50);\n#endif\n\n  /* Check that the sorting is not O(n\u00c2\u00b2) but O(n log n).  */\n  {\n    int pass;\n    for (pass = 0; pass < 3; pass++)\n      {\n        size_t repeat = 1;\n        size_t m = 100000;\n        uint32_t *input = (uint32_t *) malloc (2 * m * sizeof (uint32_t));\n        if (input != NULL)\n          {\n            uint32_t *expected = input + m;\n            size_t m1 = m / 2;\n            size_t m2 = (m - 1) / 2;\n            /* NB: m1 + m2 == m - 1.  */\n            uint32_t *p;\n            size_t i;\n\n            input[0] = 0x0041;\n            p = input + 1;\n            switch (pass)\n              {\n              case 0:\n                for (i = 0; i < m1; i++)\n                  *p++ = 0x0319;\n                for (i = 0; i < m2; i++)\n                  *p++ = 0x0300;\n                break;\n\n              case 1:\n                for (i = 0; i < m2; i++)\n                  *p++ = 0x0300;\n                for (i = 0; i < m1; i++)\n                  *p++ = 0x0319;\n                break;\n\n              case 2:\n                for (i = 0; i < m2; i++)\n                  {\n                    *p++ = 0x0319;\n                    *p++ = 0x0300;\n                  }\n                for (; i < m1; i++)\n                  *p++ = 0x0319;\n                break;\n\n              default:\n                abort ();\n              }\n\n            expected[0] = 0x0041;\n            p = expected + 1;\n            for (i = 0; i < m1; i++)\n              *p++ = 0x0319;\n            for (i = 0; i < m2; i++)\n              *p++ = 0x0300;\n\n            for (; repeat > 0; repeat--)\n              ASSERT (check (input, m, expected, m) == 0);\n\n            free (input);\n          }\n      }\n  }\n}",
        "lines": 238,
        "depth": 17,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          330,
          0
        ],
        "end_point": [
          333,
          1
        ],
        "content": "void\ntest_u32_nfkd (void)\n{\n}",
        "lines": 4,
        "depth": 5,
        "decorators": [
          "void"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-u32-normalize-big.c": {
    "cmp_ucs4_t": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static int\ncmp_ucs4_t (const void *a, const void *b)\n{\n  ucs4_t a_value = *(const ucs4_t *)a;\n  ucs4_t b_value = *(const ucs4_t *)b;\n  return (a_value < b_value ? -1 : a_value > b_value ? 1 : 0);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "read_normalization_test_file": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "void\nread_normalization_test_file (const char *filename,\n                              struct normalization_test_file *file)\n{\n  FILE *stream;\n  unsigned int lineno;\n  int part_index;\n  struct normalization_test_line *lines;\n  size_t lines_length;\n  size_t lines_allocated;\n\n  stream = fopen (filename, \"r\");\n  if (stream == NULL)\n    {\n      fprintf (stderr, \"error during fopen of '%s'\\n\", filename);\n      exit (1);\n    }\n\n  for (part_index = 0; part_index < 4; part_index++)\n    {\n      file->parts[part_index].lines = NULL;\n      file->parts[part_index].lines_length = 0;\n    }\n\n  lineno = 0;\n\n  part_index = -1;\n  lines = NULL;\n  lines_length = 0;\n  lines_allocated = 0;\n\n  for (;;)\n    {\n      char buf[1000+1];\n      char *ptr;\n      int c;\n      struct normalization_test_line line;\n      size_t sequence_index;\n\n      lineno++;\n\n      /* Read a line.  */\n      ptr = buf;\n      do\n        {\n          c = getc (stream);\n          if (c == EOF || c == '\\n')\n            break;\n          *ptr++ = c;\n        }\n      while (ptr < buf + 1000);\n      *ptr = '\\0';\n      if (c == EOF)\n        break;\n\n      /* Ignore empty lines and comment lines.  */\n      if (buf[0] == '\\0' || buf[0] == '#')\n        continue;\n\n      /* Handle lines that introduce a new part.  */\n      if (buf[0] == '@')\n        {\n          /* Switch to the next part.  */\n          if (part_index >= 0)\n            {\n              lines =\n                (struct normalization_test_line *)\n                xnrealloc (lines, lines_length, sizeof (struct normalization_test_line));\n              file->parts[part_index].lines = lines;\n              file->parts[part_index].lines_length = lines_length;\n            }\n          part_index++;\n          lines = NULL;\n          lines_length = 0;\n          lines_allocated = 0;\n          continue;\n        }\n\n      /* It's a line containing 5 sequences of Unicode characters.\n         Parse it and append it to the current part.  */\n      if (!(part_index >= 0 && part_index < 4))\n        {\n          fprintf (stderr, \"unexpected structure of '%s'\\n\", filename);\n          exit (1);\n        }\n      ptr = buf;\n      line.lineno = lineno;\n      for (sequence_index = 0; sequence_index < 5; sequence_index++)\n        line.sequences[sequence_index] = NULL;\n      for (sequence_index = 0; sequence_index < 5; sequence_index++)\n        {\n          uint32_t *sequence = XNMALLOC (1, uint32_t);\n          size_t sequence_length = 0;\n\n          for (;;)\n            {\n              char *endptr;\n              unsigned int uc;\n\n              uc = strtoul (ptr, &endptr, 16);\n              if (endptr == ptr)\n                break;\n              ptr = endptr;\n\n              /* Append uc to the sequence.  */\n              sequence =\n                (uint32_t *)\n                xnrealloc (sequence, sequence_length + 2, sizeof (uint32_t));\n              sequence[sequence_length] = uc;\n              sequence_length++;\n\n              if (*ptr == ' ')\n                ptr++;\n            }\n          if (sequence_length == 0)\n            {\n              fprintf (stderr, \"empty character sequence in '%s'\\n\", filename);\n              exit (1);\n            }\n          sequence[sequence_length] = 0; /* terminator */\n\n          line.sequences[sequence_index] = sequence;\n\n          if (*ptr != ';')\n            {\n              fprintf (stderr, \"error parsing '%s'\\n\", filename);\n              exit (1);\n            }\n          ptr++;\n        }\n\n      /* Append the line to the current part.  */\n      if (lines_length == lines_allocated)\n        {\n          lines_allocated = 2 * lines_allocated;\n          if (lines_allocated < 7)\n            lines_allocated = 7;\n          lines =\n            (struct normalization_test_line *)\n            xnrealloc (lines, lines_allocated, sizeof (struct normalization_test_line));\n        }\n      lines[lines_length] = line;\n      lines_length++;\n    }\n\n  if (part_index >= 0)\n    {\n      lines =\n        (struct normalization_test_line *)\n        xnrealloc (lines, lines_length, sizeof (struct normalization_test_line));\n      file->parts[part_index].lines = lines;\n      file->parts[part_index].lines_length = lines_length;\n    }\n\n  {\n    /* Collect all c1 values from the part 1 in an array.  */\n    const struct normalization_test_part *p = &file->parts[1];\n    ucs4_t *c1_array = XNMALLOC (p->lines_length + 1, ucs4_t);\n    size_t line_index;\n\n    for (line_index = 0; line_index < p->lines_length; line_index++)\n      {\n        const uint32_t *sequence = p->lines[line_index].sequences[0];\n        /* In part 1, every sequences[0] consists of a single character.  */\n        if (!(sequence[0] != 0 && sequence[1] == 0))\n          abort ();\n        c1_array[line_index] = sequence[0];\n      }\n\n    /* Sort this array.  */\n    qsort (c1_array, p->lines_length, sizeof (ucs4_t), cmp_ucs4_t);\n\n    /* Add the sentinel at the end.  */\n    c1_array[p->lines_length] = 0x110000;\n\n    file->part1_c1_sorted = c1_array;\n  }\n\n  file->filename = xstrdup (filename);\n\n  if (ferror (stream) || fclose (stream))\n    {\n      fprintf (stderr, \"error reading from '%s'\\n\", filename);\n      exit (1);\n    }\n}",
      "lines": 186,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "test_specific": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "void\ntest_specific (const struct normalization_test_file *file,\n               int (*check) (const uint32_t *c1, size_t c1_length,\n                             const uint32_t *c2, size_t c2_length,\n                             const uint32_t *c3, size_t c3_length,\n                             const uint32_t *c4, size_t c4_length,\n                             const uint32_t *c5, size_t c5_length))\n{\n  size_t part_index;\n\n  for (part_index = 0; part_index < 4; part_index++)\n    {\n      const struct normalization_test_part *p = &file->parts[part_index];\n      size_t line_index;\n\n      for (line_index = 0; line_index < p->lines_length; line_index++)\n        {\n          const struct normalization_test_line *l = &p->lines[line_index];\n\n          ASSERT_WITH_LINE (check (l->sequences[0], u32_strlen (l->sequences[0]),\n                                   l->sequences[1], u32_strlen (l->sequences[1]),\n                                   l->sequences[2], u32_strlen (l->sequences[2]),\n                                   l->sequences[3], u32_strlen (l->sequences[3]),\n                                   l->sequences[4], u32_strlen (l->sequences[4]))\n                            == 0,\n                            file->filename, l->lineno);\n        }\n    }\n}",
      "lines": 29,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "test_other": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "void\ntest_other (const struct normalization_test_file *file, uninorm_t nf)\n{\n  /* Check that for every character not listed in part 1 of the\n     NormalizationTest.txt file, the character maps to itself in each\n     of the four normalization forms.  */\n  const ucs4_t *p = file->part1_c1_sorted;\n  ucs4_t uc;\n\n  for (uc = 0; uc < 0x110000; uc++)\n    {\n      if (uc >= 0xD800 && uc < 0xE000)\n        {\n          /* A surrogate, not a character.  Skip uc.  */\n        }\n      else if (uc == *p)\n        {\n          /* Skip uc.  */\n          p++;\n        }\n      else\n        {\n          uint32_t input[1];\n          size_t length;\n          uint32_t *result;\n\n          input[0] = uc;\n          result = u32_normalize (nf, input, 1, NULL, &length);\n          ASSERT (result != NULL && length == 1 && result[0] == uc);\n        }\n    }\n}",
      "lines": 32,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-u32-normalize-big.h": {},
  "libunistring/libunistring-0.9.10/tests/uninorm/test-u32-normcmp.c": {
    "test_nonascii": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "static void\ntest_nonascii (int (*my_normcmp) (const uint32_t *, size_t, const uint32_t *, size_t, uninorm_t, int *))\n{\n  /* Normalization effects.  */\n  {\n    static const uint32_t input1[] = { 'H', 0x00F6, 'h', 'l', 'e' };\n    static const uint32_t input2[] = { 'H', 'o', 0x0308, 'h', 'l', 'e' };\n    static const uint32_t input3[] = { 'H', 0x00F6, 'h', 'l', 'e', 'n' };\n    static const uint32_t input4[] = { 'H', 'o', 0x0308, 'h', 'l', 'e', 'n' };\n    static const uint32_t input5[] = { 'H', 'u', 'r', 'z' };\n    int cmp;\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input2, SIZEOF (input2), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_normcmp (input2, SIZEOF (input2), input1, SIZEOF (input1), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_normcmp (input3, SIZEOF (input3), input4, SIZEOF (input4), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_normcmp (input4, SIZEOF (input4), input3, SIZEOF (input3), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_normcmp (input2, SIZEOF (input2), input3, SIZEOF (input3), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input4, SIZEOF (input4), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input5, SIZEOF (input5), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_normcmp (input2, SIZEOF (input2), input5, SIZEOF (input5), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n  }\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS */\n    static const uint32_t input1[] = { 0x00C4 };\n    static const uint32_t input2[] = { 0x0041, 0x0308 };\n    int cmp;\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input2, SIZEOF (input2), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON */\n    static const uint32_t input1[] = { 0x01DE };\n    static const uint32_t input2[] = { 0x0041, 0x0308, 0x0304 };\n    int cmp;\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input2, SIZEOF (input2), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* GREEK DIALYTIKA AND PERISPOMENI */\n    static const uint32_t input1[] = { 0x1FC1 };\n    static const uint32_t input2[] = { 0x00A8, 0x0342 };\n    int cmp;\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input2, SIZEOF (input2), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* HANGUL SYLLABLE GEUL */\n    static const uint32_t input1[] = { 0xAE00 };\n    static const uint32_t input2[] = { 0xADF8, 0x11AF };\n    static const uint32_t input3[] = { 0x1100, 0x1173, 0x11AF };\n    int cmp;\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input2, SIZEOF (input2), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input3, SIZEOF (input3), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* HANGUL SYLLABLE GEU */\n    static const uint32_t input1[] = { 0xADF8 };\n    static const uint32_t input2[] = { 0x1100, 0x1173 };\n    int cmp;\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input2, SIZEOF (input2), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n}",
      "lines": 81,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "int\nmain ()\n{\n  test_ascii (u32_normcmp, UNINORM_NFD);\n  test_nonascii (u32_normcmp);\n\n  return 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-u32-normcmp.h": {
    "test_ascii": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static void\ntest_ascii (int (*my_normcmp) (const uint32_t *, size_t, const uint32_t *, size_t, uninorm_t, int *),\n            uninorm_t nf)\n{\n  /* Empty string.  */\n  {\n    int cmp;\n\n    ASSERT (my_normcmp (NULL, 0, NULL, 0, nf, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  {\n    static const uint32_t input[] = { 'x', 'y' };\n    int cmp;\n\n    ASSERT (my_normcmp (input, SIZEOF (input), NULL, 0, nf, &cmp) == 0);\n    ASSERT (cmp == 1);\n\n    ASSERT (my_normcmp (NULL, 0, input, SIZEOF (input), nf, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_normcmp (input, SIZEOF (input), input, SIZEOF (input), nf, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n\n  /* Normal lexicographic order.  */\n  {\n    static const uint32_t input1[] = { 'A', 'm', 'e', 'r', 'i', 'c', 'a' };\n    static const uint32_t input2[] = { 'A', 'm', 'i', 'g', 'o' };\n    int cmp;\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input2, SIZEOF (input2), nf, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_normcmp (input2, SIZEOF (input2), input1, SIZEOF (input1), nf, &cmp) == 0);\n    ASSERT (cmp == 1);\n  }\n\n  /* Shorter and longer strings.  */\n  {\n    static const uint32_t input1[] = { 'R', 'e', 'a', 'g', 'a', 'n' };\n    static const uint32_t input2[] = { 'R', 'e', 'a', 'g', 'a', 'n', 'o', 'm', 'i', 'c', 's' };\n    int cmp;\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input2, SIZEOF (input2), nf, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_normcmp (input2, SIZEOF (input2), input1, SIZEOF (input1), nf, &cmp) == 0);\n    ASSERT (cmp == 1);\n  }\n}",
      "lines": 51,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-u32-normcoll.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "int\nmain ()\n{\n  /* In the \"C\" locale, strcoll is equivalent to strcmp, therefore u8_normcoll\n     on ASCII strings should behave like strcmp as well.  */\n  test_ascii (u32_normcoll, UNINORM_NFC);\n\n  return 0;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-u8-nfc.c": {
    "check": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "static int\ncheck (const uint8_t *input, size_t input_length,\n       const uint8_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint8_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u8_normalize (UNINORM_NFC, input, input_length, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u8_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint8_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint8_t *) malloc (length * sizeof (uint8_t));\n      result = u8_normalize (UNINORM_NFC, input, input_length, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u8_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint8_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint8_t *) malloc (length * sizeof (uint8_t));\n    result = u8_normalize (UNINORM_NFC, input, input_length, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u8_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_u8_nfc": [
      {
        "start_point": [
          89,
          0
        ],
        "end_point": [
          352,
          1
        ],
        "content": "void\ntest_u8_nfc (void)\n{\n  { /* Empty string.  */\n    ASSERT (check (NULL, 0, NULL, 0) == 0);\n  }\n  { /* SPACE */\n    static const uint8_t input[]    = { 0x20 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS */\n    static const uint8_t input[]      = { 0xC3, 0x84 };\n    static const uint8_t decomposed[] = { 0x41, 0xCC, 0x88 };\n    ASSERT (check (input, SIZEOF (input),           input, SIZEOF (input)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), input, SIZEOF (input)) == 0);\n  }\n\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON */\n    static const uint8_t input[]      = { 0xC7, 0x9E };\n    static const uint8_t decomposed[] = { 0x41, 0xCC, 0x88, 0xCC, 0x84 };\n    ASSERT (check (input, SIZEOF (input),           input, SIZEOF (input)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ANGSTROM SIGN */\n    static const uint8_t input[]      = { 0xE2, 0x84, 0xAB };\n    static const uint8_t decomposed[] = { 0x41, 0xCC, 0x8A };\n    static const uint8_t expected[]   = { 0xC3, 0x85 };\n    ASSERT (check (input, SIZEOF (input),           expected, SIZEOF (expected)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), expected, SIZEOF (expected)) == 0);\n    ASSERT (check (expected, SIZEOF (expected),     expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* GREEK DIALYTIKA AND PERISPOMENI */\n    static const uint8_t input[]      = { 0xE1, 0xBF, 0x81 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* SCRIPT SMALL L */\n    static const uint8_t input[]      = { 0xE2, 0x84, 0x93 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* NO-BREAK SPACE */\n    static const uint8_t input[]      = { 0xC2, 0xA0 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH INITIAL FORM */\n    static const uint8_t input[]      = { 0xEF, 0xAD, 0xAC };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH MEDIAL FORM */\n    static const uint8_t input[]      = { 0xEF, 0xAD, 0xAD };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH FINAL FORM */\n    static const uint8_t input[]      = { 0xEF, 0xAD, 0xAB };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH ISOLATED FORM */\n    static const uint8_t input[]      = { 0xEF, 0xAD, 0xAA };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* CIRCLED NUMBER FIFTEEN */\n    static const uint8_t input[]      = { 0xE2, 0x91, 0xAE };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* TRADE MARK SIGN */\n    static const uint8_t input[]      = { 0xE2, 0x84, 0xA2 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* LATIN SUBSCRIPT SMALL LETTER I */\n    static const uint8_t input[]      = { 0xE1, 0xB5, 0xA2 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* PRESENTATION FORM FOR VERTICAL LEFT PARENTHESIS */\n    static const uint8_t input[]      = { 0xEF, 0xB8, 0xB5 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* FULLWIDTH LATIN CAPITAL LETTER A */\n    static const uint8_t input[]      = { 0xEF, 0xBC, 0xA1 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* HALFWIDTH IDEOGRAPHIC COMMA */\n    static const uint8_t input[]      = { 0xEF, 0xBD, 0xA4 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* SMALL IDEOGRAPHIC COMMA */\n    static const uint8_t input[]      = { 0xEF, 0xB9, 0x91 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* SQUARE MHZ */\n    static const uint8_t input[]      = { 0xE3, 0x8E, 0x92 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* VULGAR FRACTION THREE EIGHTHS */\n    static const uint8_t input[]      = { 0xE2, 0x85, 0x9C };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* MICRO SIGN */\n    static const uint8_t input[]      = { 0xC2, 0xB5 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LIGATURE SALLALLAHOU ALAYHE WASALLAM */\n    static const uint8_t input[]      = { 0xEF, 0xB7, 0xBA };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* HANGUL SYLLABLE GEUL */\n    static const uint8_t input[]      = { 0xEA, 0xB8, 0x80 };\n    static const uint8_t decomposed[] =\n      { 0xE1, 0x84, 0x80, 0xE1, 0x85, 0xB3, 0xE1, 0x86, 0xAF };\n    ASSERT (check (input, SIZEOF (input),           input, SIZEOF (input)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), input, SIZEOF (input)) == 0);\n  }\n\n  { /* HANGUL SYLLABLE GEU */\n    static const uint8_t input[]      = { 0xEA, 0xB7, 0xB8 };\n    static const uint8_t decomposed[] = { 0xE1, 0x84, 0x80, 0xE1, 0x85, 0xB3 };\n    ASSERT (check (input, SIZEOF (input),           input, SIZEOF (input)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), input, SIZEOF (input)) == 0);\n  }\n\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint8_t input[] =\n      { 'G', 'r', 0xC3, 0xBC, 0xC3, 0x9F, ' ', 'G', 'o', 't', 't', '.',\n        ' ', 0xD0, 0x97, 0xD0, 0xB4, 0xD1, 0x80, 0xD0, 0xB0, 0xD0, 0xB2, 0xD1,\n        0x81, 0xD1, 0x82, 0xD0, 0xB2, 0xD1, 0x83, 0xD0, 0xB9,\n        0xD1, 0x82, 0xD0, 0xB5, '!', ' ', 'x', '=', '(', '-', 'b', 0xC2, 0xB1,\n        's', 'q', 'r', 't', '(', 'b', 0xC2, 0xB2, '-', '4', 'a', 'c', ')', ')',\n        '/', '(', '2', 'a', ')', ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC,\n        0xE8, 0xAA, 0x9E, ',', 0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xED, 0x95, 0x9C,\n        0xEA, 0xB8, 0x80, '\\n'\n      };\n    static const uint8_t decomposed[] =\n      { 'G', 'r', 0x75, 0xCC, 0x88, 0xC3, 0x9F, ' ', 'G', 'o', 't', 't', '.',\n        ' ', 0xD0, 0x97, 0xD0, 0xB4, 0xD1, 0x80, 0xD0, 0xB0, 0xD0, 0xB2, 0xD1,\n        0x81, 0xD1, 0x82, 0xD0, 0xB2, 0xD1, 0x83, 0xD0, 0xB8, 0xCC, 0x86,\n        0xD1, 0x82, 0xD0, 0xB5, '!', ' ', 'x', '=', '(', '-', 'b', 0xC2, 0xB1,\n        's', 'q', 'r', 't', '(', 'b', 0xC2, 0xB2, '-', '4', 'a', 'c', ')', ')',\n        '/', '(', '2', 'a', ')', ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC,\n        0xE8, 0xAA, 0x9E, ',', 0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xE1, 0x84, 0x92, 0xE1, 0x85, 0xA1, 0xE1, 0x86, 0xAB,\n        0xE1, 0x84, 0x80, 0xE1, 0x85, 0xB3, 0xE1, 0x86, 0xAF, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input),           input, SIZEOF (input)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), input, SIZEOF (input)) == 0);\n  }\n\n#if HAVE_DECL_ALARM\n  /* Declare failure if test takes too long, by using default abort\n     caused by SIGALRM.  */\n  signal (SIGALRM, SIG_DFL);\n  alarm (50);\n#endif\n\n  /* Check that the sorting is not O(n\u00c2\u00b2) but O(n log n).  */\n  {\n    int pass;\n    for (pass = 0; pass < 3; pass++)\n      {\n        size_t repeat = 1;\n        size_t m = 100000;\n        uint8_t *input = (uint8_t *) malloc (2 * (2 * m - 1) * sizeof (uint8_t));\n        if (input != NULL)\n          {\n            uint8_t *expected = input + (2 * m - 1);\n            size_t m1 = m / 2;\n            size_t m2 = (m - 1) / 2;\n            /* NB: m1 + m2 == m - 1.  */\n            uint8_t *p;\n            size_t i;\n\n            input[0] = 0x41;\n            p = input + 1;\n            switch (pass)\n              {\n              case 0:\n                for (i = 0; i < m1; i++)\n                  {\n                    *p++ = 0xCC;\n                    *p++ = 0x99;\n                  }\n                for (i = 0; i < m2; i++)\n                  {\n                    *p++ = 0xCC;\n                    *p++ = 0x80;\n                  }\n                break;\n\n              case 1:\n                for (i = 0; i < m2; i++)\n                  {\n                    *p++ = 0xCC;\n                    *p++ = 0x80;\n                  }\n                for (i = 0; i < m1; i++)\n                  {\n                    *p++ = 0xCC;\n                    *p++ = 0x99;\n                  }\n                break;\n\n              case 2:\n                for (i = 0; i < m2; i++)\n                  {\n                    *p++ = 0xCC;\n                    *p++ = 0x99;\n                    *p++ = 0xCC;\n                    *p++ = 0x80;\n                  }\n                for (; i < m1; i++)\n                  {\n                    *p++ = 0xCC;\n                    *p++ = 0x99;\n                  }\n                break;\n\n              default:\n                abort ();\n              }\n\n            expected[0] = 0xC3;\n            expected[1] = 0x80;\n            p = expected + 2;\n            for (i = 0; i < m1; i++)\n              {\n                *p++ = 0xCC;\n                *p++ = 0x99;\n              }\n            for (i = 0; i < m2 - 1; i++)\n              {\n                *p++ = 0xCC;\n                *p++ = 0x80;\n              }\n\n            for (; repeat > 0; repeat--)\n              {\n                ASSERT (check (input, 2 * m - 1,    expected, 2 * m - 2) == 0);\n                ASSERT (check (expected, 2 * m - 2, expected, 2 * m - 2) == 0);\n              }\n\n            free (input);\n          }\n      }\n  }\n}",
        "lines": 264,
        "depth": 18,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          356,
          0
        ],
        "end_point": [
          359,
          1
        ],
        "content": "void\ntest_u8_nfc (void)\n{\n}",
        "lines": 4,
        "depth": 5,
        "decorators": [
          "void"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-u8-nfd.c": {
    "check": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "static int\ncheck (const uint8_t *input, size_t input_length,\n       const uint8_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint8_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u8_normalize (UNINORM_NFD, input, input_length, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u8_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint8_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint8_t *) malloc (length * sizeof (uint8_t));\n      result = u8_normalize (UNINORM_NFD, input, input_length, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u8_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint8_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint8_t *) malloc (length * sizeof (uint8_t));\n    result = u8_normalize (UNINORM_NFD, input, input_length, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u8_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_u8_nfd": [
      {
        "start_point": [
          89,
          0
        ],
        "end_point": [
          335,
          1
        ],
        "content": "void\ntest_u8_nfd (void)\n{\n  { /* Empty string.  */\n    ASSERT (check (NULL, 0, NULL, 0) == 0);\n  }\n  { /* SPACE */\n    static const uint8_t input[]    = { 0x20 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS */\n    static const uint8_t input[]    = { 0xC3, 0x84 };\n    static const uint8_t expected[] = { 0x41, 0xCC, 0x88 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON */\n    static const uint8_t input[]    = { 0xC7, 0x9E };\n    static const uint8_t expected[] = { 0x41, 0xCC, 0x88, 0xCC, 0x84 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* GREEK DIALYTIKA AND PERISPOMENI */\n    static const uint8_t input[]    = { 0xE1, 0xBF, 0x81 };\n    static const uint8_t expected[] = { 0xC2, 0xA8, 0xCD, 0x82 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* SCRIPT SMALL L */\n    static const uint8_t input[]    = { 0xE2, 0x84, 0x93 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* NO-BREAK SPACE */\n    static const uint8_t input[]    = { 0xC2, 0xA0 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH INITIAL FORM */\n    static const uint8_t input[]    = { 0xEF, 0xAD, 0xAC };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH MEDIAL FORM */\n    static const uint8_t input[]    = { 0xEF, 0xAD, 0xAD };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH FINAL FORM */\n    static const uint8_t input[]    = { 0xEF, 0xAD, 0xAB };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH ISOLATED FORM */\n    static const uint8_t input[]    = { 0xEF, 0xAD, 0xAA };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* CIRCLED NUMBER FIFTEEN */\n    static const uint8_t input[]    = { 0xE2, 0x91, 0xAE };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* TRADE MARK SIGN */\n    static const uint8_t input[]    = { 0xE2, 0x84, 0xA2 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* LATIN SUBSCRIPT SMALL LETTER I */\n    static const uint8_t input[]    = { 0xE1, 0xB5, 0xA2 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* PRESENTATION FORM FOR VERTICAL LEFT PARENTHESIS */\n    static const uint8_t input[]    = { 0xEF, 0xB8, 0xB5 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* FULLWIDTH LATIN CAPITAL LETTER A */\n    static const uint8_t input[]    = { 0xEF, 0xBC, 0xA1 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* HALFWIDTH IDEOGRAPHIC COMMA */\n    static const uint8_t input[]    = { 0xEF, 0xBD, 0xA4 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* SMALL IDEOGRAPHIC COMMA */\n    static const uint8_t input[]    = { 0xEF, 0xB9, 0x91 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* SQUARE MHZ */\n    static const uint8_t input[]    = { 0xE3, 0x8E, 0x92 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* VULGAR FRACTION THREE EIGHTHS */\n    static const uint8_t input[]    = { 0xE2, 0x85, 0x9C };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* MICRO SIGN */\n    static const uint8_t input[]    = { 0xC2, 0xB5 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ARABIC LIGATURE SALLALLAHOU ALAYHE WASALLAM */\n    static const uint8_t input[]    = { 0xEF, 0xB7, 0xBA };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* HANGUL SYLLABLE GEUL */\n    static const uint8_t input[]    = { 0xEA, 0xB8, 0x80 };\n    static const uint8_t expected[] =\n      { 0xE1, 0x84, 0x80, 0xE1, 0x85, 0xB3, 0xE1, 0x86, 0xAF };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* HANGUL SYLLABLE GEU */\n    static const uint8_t input[]    = { 0xEA, 0xB7, 0xB8 };\n    static const uint8_t expected[] = { 0xE1, 0x84, 0x80, 0xE1, 0x85, 0xB3 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint8_t input[] =\n      { 'G', 'r', 0xC3, 0xBC, 0xC3, 0x9F, ' ', 'G', 'o', 't', 't', '.',\n        ' ', 0xD0, 0x97, 0xD0, 0xB4, 0xD1, 0x80, 0xD0, 0xB0, 0xD0, 0xB2, 0xD1,\n        0x81, 0xD1, 0x82, 0xD0, 0xB2, 0xD1, 0x83, 0xD0, 0xB9,\n        0xD1, 0x82, 0xD0, 0xB5, '!', ' ', 'x', '=', '(', '-', 'b', 0xC2, 0xB1,\n        's', 'q', 'r', 't', '(', 'b', 0xC2, 0xB2, '-', '4', 'a', 'c', ')', ')',\n        '/', '(', '2', 'a', ')', ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC,\n        0xE8, 0xAA, 0x9E, ',', 0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xED, 0x95, 0x9C,\n        0xEA, 0xB8, 0x80, '\\n'\n      };\n    static const uint8_t expected[] =\n      { 'G', 'r', 0x75, 0xCC, 0x88, 0xC3, 0x9F, ' ', 'G', 'o', 't', 't', '.',\n        ' ', 0xD0, 0x97, 0xD0, 0xB4, 0xD1, 0x80, 0xD0, 0xB0, 0xD0, 0xB2, 0xD1,\n        0x81, 0xD1, 0x82, 0xD0, 0xB2, 0xD1, 0x83, 0xD0, 0xB8, 0xCC, 0x86,\n        0xD1, 0x82, 0xD0, 0xB5, '!', ' ', 'x', '=', '(', '-', 'b', 0xC2, 0xB1,\n        's', 'q', 'r', 't', '(', 'b', 0xC2, 0xB2, '-', '4', 'a', 'c', ')', ')',\n        '/', '(', '2', 'a', ')', ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC,\n        0xE8, 0xAA, 0x9E, ',', 0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xE1, 0x84, 0x92, 0xE1, 0x85, 0xA1, 0xE1, 0x86, 0xAB,\n        0xE1, 0x84, 0x80, 0xE1, 0x85, 0xB3, 0xE1, 0x86, 0xAF, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n#if HAVE_DECL_ALARM\n  /* Declare failure if test takes too long, by using default abort\n     caused by SIGALRM.  */\n  signal (SIGALRM, SIG_DFL);\n  alarm (50);\n#endif\n\n  /* Check that the sorting is not O(n\u00c2\u00b2) but O(n log n).  */\n  {\n    int pass;\n    for (pass = 0; pass < 3; pass++)\n      {\n        size_t repeat = 1;\n        size_t m = 100000;\n        uint8_t *input = (uint8_t *) malloc (2 * (2 * m - 1) * sizeof (uint8_t));\n        if (input != NULL)\n          {\n            uint8_t *expected = input + (2 * m - 1);\n            size_t m1 = m / 2;\n            size_t m2 = (m - 1) / 2;\n            /* NB: m1 + m2 == m - 1.  */\n            uint8_t *p;\n            size_t i;\n\n            input[0] = 0x41;\n            p = input + 1;\n            switch (pass)\n              {\n              case 0:\n                for (i = 0; i < m1; i++)\n                  {\n                    *p++ = 0xCC;\n                    *p++ = 0x99;\n                  }\n                for (i = 0; i < m2; i++)\n                  {\n                    *p++ = 0xCC;\n                    *p++ = 0x80;\n                  }\n                break;\n\n              case 1:\n                for (i = 0; i < m2; i++)\n                  {\n                    *p++ = 0xCC;\n                    *p++ = 0x80;\n                  }\n                for (i = 0; i < m1; i++)\n                  {\n                    *p++ = 0xCC;\n                    *p++ = 0x99;\n                  }\n                break;\n\n              case 2:\n                for (i = 0; i < m2; i++)\n                  {\n                    *p++ = 0xCC;\n                    *p++ = 0x99;\n                    *p++ = 0xCC;\n                    *p++ = 0x80;\n                  }\n                for (; i < m1; i++)\n                  {\n                    *p++ = 0xCC;\n                    *p++ = 0x99;\n                  }\n                break;\n\n              default:\n                abort ();\n              }\n\n            expected[0] = 0x41;\n            p = expected + 1;\n            for (i = 0; i < m1; i++)\n              {\n                *p++ = 0xCC;\n                *p++ = 0x99;\n              }\n            for (i = 0; i < m2; i++)\n              {\n                *p++ = 0xCC;\n                *p++ = 0x80;\n              }\n\n            for (; repeat > 0; repeat--)\n              ASSERT (check (input, 2 * m - 1, expected, 2 * m - 1) == 0);\n\n            free (input);\n          }\n      }\n  }\n}",
        "lines": 247,
        "depth": 17,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          339,
          0
        ],
        "end_point": [
          342,
          1
        ],
        "content": "void\ntest_u8_nfd (void)\n{\n}",
        "lines": 4,
        "depth": 5,
        "decorators": [
          "void"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-u8-nfkc.c": {
    "check": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "static int\ncheck (const uint8_t *input, size_t input_length,\n       const uint8_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint8_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u8_normalize (UNINORM_NFKC, input, input_length, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u8_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint8_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint8_t *) malloc (length * sizeof (uint8_t));\n      result = u8_normalize (UNINORM_NFKC, input, input_length, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u8_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint8_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint8_t *) malloc (length * sizeof (uint8_t));\n    result = u8_normalize (UNINORM_NFKC, input, input_length, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u8_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_u8_nfkc": [
      {
        "start_point": [
          89,
          0
        ],
        "end_point": [
          404,
          1
        ],
        "content": "void\ntest_u8_nfkc (void)\n{\n  { /* Empty string.  */\n    ASSERT (check (NULL, 0, NULL, 0) == 0);\n  }\n  { /* SPACE */\n    static const uint8_t input[]    = { 0x20 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS */\n    static const uint8_t input[]      = { 0xC3, 0x84 };\n    static const uint8_t decomposed[] = { 0x41, 0xCC, 0x88 };\n    ASSERT (check (input, SIZEOF (input),           input, SIZEOF (input)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), input, SIZEOF (input)) == 0);\n  }\n\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON */\n    static const uint8_t input[]      = { 0xC7, 0x9E };\n    static const uint8_t decomposed[] = { 0x41, 0xCC, 0x88, 0xCC, 0x84 };\n    ASSERT (check (input, SIZEOF (input),           input, SIZEOF (input)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), input, SIZEOF (input)) == 0);\n  }\n\n  { /* ANGSTROM SIGN */\n    static const uint8_t input[]      = { 0xE2, 0x84, 0xAB };\n    static const uint8_t decomposed[] = { 0x41, 0xCC, 0x8A };\n    static const uint8_t expected[]   = { 0xC3, 0x85 };\n    ASSERT (check (input, SIZEOF (input),           expected, SIZEOF (expected)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), expected, SIZEOF (expected)) == 0);\n    ASSERT (check (expected, SIZEOF (expected),     expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* GREEK DIALYTIKA AND PERISPOMENI */\n    static const uint8_t input[]      = { 0xE1, 0xBF, 0x81 };\n    static const uint8_t decomposed[] = { 0x20, 0xCC, 0x88, 0xCD, 0x82 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* SCRIPT SMALL L */\n    static const uint8_t input[]      = { 0xE2, 0x84, 0x93 };\n    static const uint8_t decomposed[] = { 0x6C };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* NO-BREAK SPACE */\n    static const uint8_t input[]      = { 0xC2, 0xA0 };\n    static const uint8_t decomposed[] = { 0x20 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH INITIAL FORM */\n    static const uint8_t input[]      = { 0xEF, 0xAD, 0xAC };\n    static const uint8_t decomposed[] = { 0xDA, 0xA4 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH MEDIAL FORM */\n    static const uint8_t input[]      = { 0xEF, 0xAD, 0xAD };\n    static const uint8_t decomposed[] = { 0xDA, 0xA4 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH FINAL FORM */\n    static const uint8_t input[]      = { 0xEF, 0xAD, 0xAB };\n    static const uint8_t decomposed[] = { 0xDA, 0xA4 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH ISOLATED FORM */\n    static const uint8_t input[]      = { 0xEF, 0xAD, 0xAA };\n    static const uint8_t decomposed[] = { 0xDA, 0xA4 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* CIRCLED NUMBER FIFTEEN */\n    static const uint8_t input[]      = { 0xE2, 0x91, 0xAE };\n    static const uint8_t decomposed[] = { 0x31, 0x35 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* TRADE MARK SIGN */\n    static const uint8_t input[]      = { 0xE2, 0x84, 0xA2 };\n    static const uint8_t decomposed[] = { 0x54, 0x4D };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* LATIN SUBSCRIPT SMALL LETTER I */\n    static const uint8_t input[]      = { 0xE1, 0xB5, 0xA2 };\n    static const uint8_t decomposed[] = { 0x69 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* PRESENTATION FORM FOR VERTICAL LEFT PARENTHESIS */\n    static const uint8_t input[]      = { 0xEF, 0xB8, 0xB5 };\n    static const uint8_t decomposed[] = { 0x28 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* FULLWIDTH LATIN CAPITAL LETTER A */\n    static const uint8_t input[]      = { 0xEF, 0xBC, 0xA1 };\n    static const uint8_t decomposed[] = { 0x41 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* HALFWIDTH IDEOGRAPHIC COMMA */\n    static const uint8_t input[]      = { 0xEF, 0xBD, 0xA4 };\n    static const uint8_t decomposed[] = { 0xE3, 0x80, 0x81 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* SMALL IDEOGRAPHIC COMMA */\n    static const uint8_t input[]      = { 0xEF, 0xB9, 0x91 };\n    static const uint8_t decomposed[] = { 0xE3, 0x80, 0x81 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* SQUARE MHZ */\n    static const uint8_t input[]      = { 0xE3, 0x8E, 0x92 };\n    static const uint8_t decomposed[] = { 0x4D, 0x48, 0x7A };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* VULGAR FRACTION THREE EIGHTHS */\n    static const uint8_t input[]      = { 0xE2, 0x85, 0x9C };\n    static const uint8_t decomposed[] = { 0x33, 0xE2, 0x81, 0x84, 0x38 };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* MICRO SIGN */\n    static const uint8_t input[]      = { 0xC2, 0xB5 };\n    static const uint8_t decomposed[] = { 0xCE, 0xBC };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* ARABIC LIGATURE SALLALLAHOU ALAYHE WASALLAM */\n    static const uint8_t input[]      = { 0xEF, 0xB7, 0xBA };\n    static const uint8_t decomposed[] =\n      { 0xD8, 0xB5, 0xD9, 0x84, 0xD9, 0x89, 0x20, 0xD8, 0xA7, 0xD9, 0x84, 0xD9,\n        0x84, 0xD9, 0x87, 0x20, 0xD8, 0xB9, 0xD9, 0x84, 0xD9, 0x8A, 0xD9, 0x87,\n        0x20, 0xD9, 0x88, 0xD8, 0xB3, 0xD9, 0x84, 0xD9, 0x85\n      };\n    ASSERT (check (input, SIZEOF (input),           decomposed, SIZEOF (decomposed)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), decomposed, SIZEOF (decomposed)) == 0);\n  }\n\n  { /* HANGUL SYLLABLE GEUL */\n    static const uint8_t input[]      = { 0xEA, 0xB8, 0x80 };\n    static const uint8_t decomposed[] =\n      { 0xE1, 0x84, 0x80, 0xE1, 0x85, 0xB3, 0xE1, 0x86, 0xAF };\n    ASSERT (check (input, SIZEOF (input),           input, SIZEOF (input)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), input, SIZEOF (input)) == 0);\n  }\n\n  { /* HANGUL SYLLABLE GEU */\n    static const uint8_t input[]      = { 0xEA, 0xB7, 0xB8 };\n    static const uint8_t decomposed[] = { 0xE1, 0x84, 0x80, 0xE1, 0x85, 0xB3 };\n    ASSERT (check (input, SIZEOF (input),           input, SIZEOF (input)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), input, SIZEOF (input)) == 0);\n  }\n\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint8_t input[] =\n      { 'G', 'r', 0xC3, 0xBC, 0xC3, 0x9F, ' ', 'G', 'o', 't', 't', '.',\n        ' ', 0xD0, 0x97, 0xD0, 0xB4, 0xD1, 0x80, 0xD0, 0xB0, 0xD0, 0xB2, 0xD1,\n        0x81, 0xD1, 0x82, 0xD0, 0xB2, 0xD1, 0x83, 0xD0, 0xB9,\n        0xD1, 0x82, 0xD0, 0xB5, '!', ' ', 'x', '=', '(', '-', 'b', 0xC2, 0xB1,\n        's', 'q', 'r', 't', '(', 'b', 0xC2, 0xB2, '-', '4', 'a', 'c', ')', ')',\n        '/', '(', '2', 'a', ')', ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC,\n        0xE8, 0xAA, 0x9E, ',', 0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xED, 0x95, 0x9C,\n        0xEA, 0xB8, 0x80, '\\n'\n      };\n    static const uint8_t decomposed[] =\n      { 'G', 'r', 0x75, 0xCC, 0x88, 0xC3, 0x9F, ' ', 'G', 'o', 't', 't', '.',\n        ' ', 0xD0, 0x97, 0xD0, 0xB4, 0xD1, 0x80, 0xD0, 0xB0, 0xD0, 0xB2, 0xD1,\n        0x81, 0xD1, 0x82, 0xD0, 0xB2, 0xD1, 0x83, 0xD0, 0xB8, 0xCC, 0x86,\n        0xD1, 0x82, 0xD0, 0xB5, '!', ' ', 'x', '=', '(', '-', 'b', 0xC2, 0xB1,\n        's', 'q', 'r', 't', '(', 'b', 0x32, '-', '4', 'a', 'c', ')', ')',\n        '/', '(', '2', 'a', ')', ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC,\n        0xE8, 0xAA, 0x9E, ',', 0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xE1, 0x84, 0x92, 0xE1, 0x85, 0xA1, 0xE1, 0x86, 0xAB,\n        0xE1, 0x84, 0x80, 0xE1, 0x85, 0xB3, 0xE1, 0x86, 0xAF, '\\n'\n      };\n    static const uint8_t expected[] =\n      { 'G', 'r', 0xC3, 0xBC, 0xC3, 0x9F, ' ', 'G', 'o', 't', 't', '.',\n        ' ', 0xD0, 0x97, 0xD0, 0xB4, 0xD1, 0x80, 0xD0, 0xB0, 0xD0, 0xB2, 0xD1,\n        0x81, 0xD1, 0x82, 0xD0, 0xB2, 0xD1, 0x83, 0xD0, 0xB9,\n        0xD1, 0x82, 0xD0, 0xB5, '!', ' ', 'x', '=', '(', '-', 'b', 0xC2, 0xB1,\n        's', 'q', 'r', 't', '(', 'b', 0x32, '-', '4', 'a', 'c', ')', ')',\n        '/', '(', '2', 'a', ')', ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC,\n        0xE8, 0xAA, 0x9E, ',', 0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xED, 0x95, 0x9C,\n        0xEA, 0xB8, 0x80, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input),           expected, SIZEOF (expected)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), expected, SIZEOF (expected)) == 0);\n    ASSERT (check (expected, SIZEOF (expected),     expected, SIZEOF (expected)) == 0);\n  }\n\n#if HAVE_DECL_ALARM\n  /* Declare failure if test takes too long, by using default abort\n     caused by SIGALRM.  */\n  signal (SIGALRM, SIG_DFL);\n  alarm (50);\n#endif\n\n  /* Check that the sorting is not O(n\u00c2\u00b2) but O(n log n).  */\n  {\n    int pass;\n    for (pass = 0; pass < 3; pass++)\n      {\n        size_t repeat = 1;\n        size_t m = 100000;\n        uint8_t *input = (uint8_t *) malloc (2 * (2 * m - 1) * sizeof (uint8_t));\n        if (input != NULL)\n          {\n            uint8_t *expected = input + (2 * m - 1);\n            size_t m1 = m / 2;\n            size_t m2 = (m - 1) / 2;\n            /* NB: m1 + m2 == m - 1.  */\n            uint8_t *p;\n            size_t i;\n\n            input[0] = 0x41;\n            p = input + 1;\n            switch (pass)\n              {\n              case 0:\n                for (i = 0; i < m1; i++)\n                  {\n                    *p++ = 0xCC;\n                    *p++ = 0x99;\n                  }\n                for (i = 0; i < m2; i++)\n                  {\n                    *p++ = 0xCC;\n                    *p++ = 0x80;\n                  }\n                break;\n\n              case 1:\n                for (i = 0; i < m2; i++)\n                  {\n                    *p++ = 0xCC;\n                    *p++ = 0x80;\n                  }\n                for (i = 0; i < m1; i++)\n                  {\n                    *p++ = 0xCC;\n                    *p++ = 0x99;\n                  }\n                break;\n\n              case 2:\n                for (i = 0; i < m2; i++)\n                  {\n                    *p++ = 0xCC;\n                    *p++ = 0x99;\n                    *p++ = 0xCC;\n                    *p++ = 0x80;\n                  }\n                for (; i < m1; i++)\n                  {\n                    *p++ = 0xCC;\n                    *p++ = 0x99;\n                  }\n                break;\n\n              default:\n                abort ();\n              }\n\n            expected[0] = 0xC3;\n            expected[1] = 0x80;\n            p = expected + 2;\n            for (i = 0; i < m1; i++)\n              {\n                *p++ = 0xCC;\n                *p++ = 0x99;\n              }\n            for (i = 0; i < m2 - 1; i++)\n              {\n                *p++ = 0xCC;\n                *p++ = 0x80;\n              }\n\n            for (; repeat > 0; repeat--)\n              {\n                ASSERT (check (input, 2 * m - 1,    expected, 2 * m - 2) == 0);\n                ASSERT (check (expected, 2 * m - 2, expected, 2 * m - 2) == 0);\n              }\n\n            free (input);\n          }\n      }\n  }\n}",
        "lines": 316,
        "depth": 18,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          408,
          0
        ],
        "end_point": [
          411,
          1
        ],
        "content": "void\ntest_u8_nfkc (void)\n{\n}",
        "lines": 4,
        "depth": 5,
        "decorators": [
          "void"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-u8-nfkd.c": {
    "check": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "static int\ncheck (const uint8_t *input, size_t input_length,\n       const uint8_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint8_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u8_normalize (UNINORM_NFKD, input, input_length, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u8_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint8_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint8_t *) malloc (length * sizeof (uint8_t));\n      result = u8_normalize (UNINORM_NFKD, input, input_length, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u8_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint8_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint8_t *) malloc (length * sizeof (uint8_t));\n    result = u8_normalize (UNINORM_NFKD, input, input_length, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u8_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_u8_nfkd": [
      {
        "start_point": [
          89,
          0
        ],
        "end_point": [
          356,
          1
        ],
        "content": "void\ntest_u8_nfkd (void)\n{\n  { /* Empty string.  */\n    ASSERT (check (NULL, 0, NULL, 0) == 0);\n  }\n  { /* SPACE */\n    static const uint8_t input[]    = { 0x20 };\n    ASSERT (check (input, SIZEOF (input), input, SIZEOF (input)) == 0);\n  }\n\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS */\n    static const uint8_t input[]    = { 0xC3, 0x84 };\n    static const uint8_t expected[] = { 0x41, 0xCC, 0x88 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON */\n    static const uint8_t input[]    = { 0xC7, 0x9E };\n    static const uint8_t expected[] = { 0x41, 0xCC, 0x88, 0xCC, 0x84 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* GREEK DIALYTIKA AND PERISPOMENI */\n    static const uint8_t input[]    = { 0xE1, 0xBF, 0x81 };\n    static const uint8_t expected[] = { 0x20, 0xCC, 0x88, 0xCD, 0x82 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* SCRIPT SMALL L */\n    static const uint8_t input[]    = { 0xE2, 0x84, 0x93 };\n    static const uint8_t expected[] = { 0x6C };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* NO-BREAK SPACE */\n    static const uint8_t input[]    = { 0xC2, 0xA0 };\n    static const uint8_t expected[] = { 0x20 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH INITIAL FORM */\n    static const uint8_t input[]    = { 0xEF, 0xAD, 0xAC };\n    static const uint8_t expected[] = { 0xDA, 0xA4 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH MEDIAL FORM */\n    static const uint8_t input[]    = { 0xEF, 0xAD, 0xAD };\n    static const uint8_t expected[] = { 0xDA, 0xA4 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH FINAL FORM */\n    static const uint8_t input[]    = { 0xEF, 0xAD, 0xAB };\n    static const uint8_t expected[] = { 0xDA, 0xA4 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* ARABIC LETTER VEH ISOLATED FORM */\n    static const uint8_t input[]    = { 0xEF, 0xAD, 0xAA };\n    static const uint8_t expected[] = { 0xDA, 0xA4 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* CIRCLED NUMBER FIFTEEN */\n    static const uint8_t input[]    = { 0xE2, 0x91, 0xAE };\n    static const uint8_t expected[] = { 0x31, 0x35 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* TRADE MARK SIGN */\n    static const uint8_t input[]    = { 0xE2, 0x84, 0xA2 };\n    static const uint8_t expected[] = { 0x54, 0x4D };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* LATIN SUBSCRIPT SMALL LETTER I */\n    static const uint8_t input[]    = { 0xE1, 0xB5, 0xA2 };\n    static const uint8_t expected[] = { 0x69 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* PRESENTATION FORM FOR VERTICAL LEFT PARENTHESIS */\n    static const uint8_t input[]    = { 0xEF, 0xB8, 0xB5 };\n    static const uint8_t expected[] = { 0x28 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* FULLWIDTH LATIN CAPITAL LETTER A */\n    static const uint8_t input[]    = { 0xEF, 0xBC, 0xA1 };\n    static const uint8_t expected[] = { 0x41 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* HALFWIDTH IDEOGRAPHIC COMMA */\n    static const uint8_t input[]    = { 0xEF, 0xBD, 0xA4 };\n    static const uint8_t expected[] = { 0xE3, 0x80, 0x81 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* SMALL IDEOGRAPHIC COMMA */\n    static const uint8_t input[]    = { 0xEF, 0xB9, 0x91 };\n    static const uint8_t expected[] = { 0xE3, 0x80, 0x81 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* SQUARE MHZ */\n    static const uint8_t input[]    = { 0xE3, 0x8E, 0x92 };\n    static const uint8_t expected[] = { 0x4D, 0x48, 0x7A };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* VULGAR FRACTION THREE EIGHTHS */\n    static const uint8_t input[]    = { 0xE2, 0x85, 0x9C };\n    static const uint8_t expected[] = { 0x33, 0xE2, 0x81, 0x84, 0x38 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* MICRO SIGN */\n    static const uint8_t input[]    = { 0xC2, 0xB5 };\n    static const uint8_t expected[] = { 0xCE, 0xBC };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* ARABIC LIGATURE SALLALLAHOU ALAYHE WASALLAM */\n    static const uint8_t input[]    = { 0xEF, 0xB7, 0xBA };\n    static const uint8_t expected[] =\n      { 0xD8, 0xB5, 0xD9, 0x84, 0xD9, 0x89, 0x20, 0xD8, 0xA7, 0xD9, 0x84, 0xD9,\n        0x84, 0xD9, 0x87, 0x20, 0xD8, 0xB9, 0xD9, 0x84, 0xD9, 0x8A, 0xD9, 0x87,\n        0x20, 0xD9, 0x88, 0xD8, 0xB3, 0xD9, 0x84, 0xD9, 0x85\n      };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* HANGUL SYLLABLE GEUL */\n    static const uint8_t input[]    = { 0xEA, 0xB8, 0x80 };\n    static const uint8_t expected[] =\n      { 0xE1, 0x84, 0x80, 0xE1, 0x85, 0xB3, 0xE1, 0x86, 0xAF };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* HANGUL SYLLABLE GEU */\n    static const uint8_t input[]    = { 0xEA, 0xB7, 0xB8 };\n    static const uint8_t expected[] = { 0xE1, 0x84, 0x80, 0xE1, 0x85, 0xB3 };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint8_t input[] =\n      { 'G', 'r', 0xC3, 0xBC, 0xC3, 0x9F, ' ', 'G', 'o', 't', 't', '.',\n        ' ', 0xD0, 0x97, 0xD0, 0xB4, 0xD1, 0x80, 0xD0, 0xB0, 0xD0, 0xB2, 0xD1,\n        0x81, 0xD1, 0x82, 0xD0, 0xB2, 0xD1, 0x83, 0xD0, 0xB9,\n        0xD1, 0x82, 0xD0, 0xB5, '!', ' ', 'x', '=', '(', '-', 'b', 0xC2, 0xB1,\n        's', 'q', 'r', 't', '(', 'b', 0xC2, 0xB2, '-', '4', 'a', 'c', ')', ')',\n        '/', '(', '2', 'a', ')', ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC,\n        0xE8, 0xAA, 0x9E, ',', 0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xED, 0x95, 0x9C,\n        0xEA, 0xB8, 0x80, '\\n'\n      };\n    static const uint8_t expected[] =\n      { 'G', 'r', 0x75, 0xCC, 0x88, 0xC3, 0x9F, ' ', 'G', 'o', 't', 't', '.',\n        ' ', 0xD0, 0x97, 0xD0, 0xB4, 0xD1, 0x80, 0xD0, 0xB0, 0xD0, 0xB2, 0xD1,\n        0x81, 0xD1, 0x82, 0xD0, 0xB2, 0xD1, 0x83, 0xD0, 0xB8, 0xCC, 0x86,\n        0xD1, 0x82, 0xD0, 0xB5, '!', ' ', 'x', '=', '(', '-', 'b', 0xC2, 0xB1,\n        's', 'q', 'r', 't', '(', 'b', 0x32, '-', '4', 'a', 'c', ')', ')',\n        '/', '(', '2', 'a', ')', ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC,\n        0xE8, 0xAA, 0x9E, ',', 0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xE1, 0x84, 0x92, 0xE1, 0x85, 0xA1, 0xE1, 0x86, 0xAB,\n        0xE1, 0x84, 0x80, 0xE1, 0x85, 0xB3, 0xE1, 0x86, 0xAF, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n#if HAVE_DECL_ALARM\n  /* Declare failure if test takes too long, by using default abort\n     caused by SIGALRM.  */\n  signal (SIGALRM, SIG_DFL);\n  alarm (50);\n#endif\n\n  /* Check that the sorting is not O(n\u00c2\u00b2) but O(n log n).  */\n  {\n    int pass;\n    for (pass = 0; pass < 3; pass++)\n      {\n        size_t repeat = 1;\n        size_t m = 100000;\n        uint8_t *input = (uint8_t *) malloc (2 * (2 * m - 1) * sizeof (uint8_t));\n        if (input != NULL)\n          {\n            uint8_t *expected = input + (2 * m - 1);\n            size_t m1 = m / 2;\n            size_t m2 = (m - 1) / 2;\n            /* NB: m1 + m2 == m - 1.  */\n            uint8_t *p;\n            size_t i;\n\n            input[0] = 0x41;\n            p = input + 1;\n            switch (pass)\n              {\n              case 0:\n                for (i = 0; i < m1; i++)\n                  {\n                    *p++ = 0xCC;\n                    *p++ = 0x99;\n                  }\n                for (i = 0; i < m2; i++)\n                  {\n                    *p++ = 0xCC;\n                    *p++ = 0x80;\n                  }\n                break;\n\n              case 1:\n                for (i = 0; i < m2; i++)\n                  {\n                    *p++ = 0xCC;\n                    *p++ = 0x80;\n                  }\n                for (i = 0; i < m1; i++)\n                  {\n                    *p++ = 0xCC;\n                    *p++ = 0x99;\n                  }\n                break;\n\n              case 2:\n                for (i = 0; i < m2; i++)\n                  {\n                    *p++ = 0xCC;\n                    *p++ = 0x99;\n                    *p++ = 0xCC;\n                    *p++ = 0x80;\n                  }\n                for (; i < m1; i++)\n                  {\n                    *p++ = 0xCC;\n                    *p++ = 0x99;\n                  }\n                break;\n\n              default:\n                abort ();\n              }\n\n            expected[0] = 0x41;\n            p = expected + 1;\n            for (i = 0; i < m1; i++)\n              {\n                *p++ = 0xCC;\n                *p++ = 0x99;\n              }\n            for (i = 0; i < m2; i++)\n              {\n                *p++ = 0xCC;\n                *p++ = 0x80;\n              }\n\n            for (; repeat > 0; repeat--)\n              ASSERT (check (input, 2 * m - 1, expected, 2 * m - 1) == 0);\n\n            free (input);\n          }\n      }\n  }\n}",
        "lines": 268,
        "depth": 17,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          360,
          0
        ],
        "end_point": [
          363,
          1
        ],
        "content": "void\ntest_u8_nfkd (void)\n{\n}",
        "lines": 4,
        "depth": 5,
        "decorators": [
          "void"
        ]
      }
    ]
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-u8-normcmp.c": {
    "test_nonascii": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "static void\ntest_nonascii (int (*my_normcmp) (const uint8_t *, size_t, const uint8_t *, size_t, uninorm_t, int *))\n{\n  /* Normalization effects.  */\n  {\n    static const uint8_t input1[] = { 'H', 0xC3, 0xB6, 'h', 'l', 'e' };\n    static const uint8_t input2[] = { 'H', 'o', 0xCC, 0x88, 'h', 'l', 'e' };\n    static const uint8_t input3[] = { 'H', 0xC3, 0xB6, 'h', 'l', 'e', 'n' };\n    static const uint8_t input4[] = { 'H', 'o', 0xCC, 0x88, 'h', 'l', 'e', 'n' };\n    static const uint8_t input5[] = { 'H', 'u', 'r', 'z' };\n    int cmp;\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input2, SIZEOF (input2), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_normcmp (input2, SIZEOF (input2), input1, SIZEOF (input1), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_normcmp (input3, SIZEOF (input3), input4, SIZEOF (input4), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_normcmp (input4, SIZEOF (input4), input3, SIZEOF (input3), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_normcmp (input2, SIZEOF (input2), input3, SIZEOF (input3), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input4, SIZEOF (input4), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input5, SIZEOF (input5), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_normcmp (input2, SIZEOF (input2), input5, SIZEOF (input5), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == -1);\n  }\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS */\n    static const uint8_t input1[] = { 0xC3, 0x84 };\n    static const uint8_t input2[] = { 0x41, 0xCC, 0x88 };\n    int cmp;\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input2, SIZEOF (input2), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON */\n    static const uint8_t input1[] = { 0xC7, 0x9E };\n    static const uint8_t input2[] = { 0x41, 0xCC, 0x88, 0xCC, 0x84 };\n    int cmp;\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input2, SIZEOF (input2), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* GREEK DIALYTIKA AND PERISPOMENI */\n    static const uint8_t input1[] = { 0xE1, 0xBF, 0x81 };\n    static const uint8_t input2[] = { 0xC2, 0xA8, 0xCD, 0x82 };\n    int cmp;\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input2, SIZEOF (input2), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* HANGUL SYLLABLE GEUL */\n    static const uint8_t input1[] = { 0xEA, 0xB8, 0x80 };\n    static const uint8_t input2[] = { 0xEA, 0xB7, 0xB8, 0xE1, 0x86, 0xAF };\n    static const uint8_t input3[] = { 0xE1, 0x84, 0x80, 0xE1, 0x85, 0xB3, 0xE1, 0x86, 0xAF };\n    int cmp;\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input2, SIZEOF (input2), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input3, SIZEOF (input3), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  { /* HANGUL SYLLABLE GEU */\n    static const uint8_t input1[] = { 0xEA, 0xB7, 0xB8 };\n    static const uint8_t input2[] = { 0xE1, 0x84, 0x80, 0xE1, 0x85, 0xB3 };\n    int cmp;\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input2, SIZEOF (input2), UNINORM_NFD, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n}",
      "lines": 81,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "int\nmain ()\n{\n  test_ascii (u8_normcmp, UNINORM_NFD);\n  test_nonascii (u8_normcmp);\n\n  return 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-u8-normcmp.h": {
    "test_ascii": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static void\ntest_ascii (int (*my_normcmp) (const uint8_t *, size_t, const uint8_t *, size_t, uninorm_t, int *),\n            uninorm_t nf)\n{\n  /* Empty string.  */\n  {\n    int cmp;\n\n    ASSERT (my_normcmp (NULL, 0, NULL, 0, nf, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n  {\n    static const uint8_t input[] = { 'x', 'y' };\n    int cmp;\n\n    ASSERT (my_normcmp (input, SIZEOF (input), NULL, 0, nf, &cmp) == 0);\n    ASSERT (cmp == 1);\n\n    ASSERT (my_normcmp (NULL, 0, input, SIZEOF (input), nf, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_normcmp (input, SIZEOF (input), input, SIZEOF (input), nf, &cmp) == 0);\n    ASSERT (cmp == 0);\n  }\n\n  /* Normal lexicographic order.  */\n  {\n    static const uint8_t input1[] = { 'A', 'm', 'e', 'r', 'i', 'c', 'a' };\n    static const uint8_t input2[] = { 'A', 'm', 'i', 'g', 'o' };\n    int cmp;\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input2, SIZEOF (input2), nf, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_normcmp (input2, SIZEOF (input2), input1, SIZEOF (input1), nf, &cmp) == 0);\n    ASSERT (cmp == 1);\n  }\n\n  /* Shorter and longer strings.  */\n  {\n    static const uint8_t input1[] = { 'R', 'e', 'a', 'g', 'a', 'n' };\n    static const uint8_t input2[] = { 'R', 'e', 'a', 'g', 'a', 'n', 'o', 'm', 'i', 'c', 's' };\n    int cmp;\n\n    ASSERT (my_normcmp (input1, SIZEOF (input1), input2, SIZEOF (input2), nf, &cmp) == 0);\n    ASSERT (cmp == -1);\n\n    ASSERT (my_normcmp (input2, SIZEOF (input2), input1, SIZEOF (input1), nf, &cmp) == 0);\n    ASSERT (cmp == 1);\n  }\n}",
      "lines": 51,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-u8-normcoll.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "int\nmain ()\n{\n  /* In the \"C\" locale, strcoll is equivalent to strcmp, therefore u8_normcoll\n     on ASCII strings should behave like strcmp as well.  */\n  test_ascii (u8_normcoll, UNINORM_NFC);\n\n  return 0;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uninorm/test-uninorm-filter-nfc.c": {
    "write_to_accumulator": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "static int\nwrite_to_accumulator (void *stream_data, ucs4_t uc)\n{\n  struct accumulator *accu = (struct accumulator *) stream_data;\n\n  if (accu->length == accu->allocated)\n    {\n      accu->allocated = 2 * accu->allocated + 1;\n      accu->result = (uint32_t *) realloc (accu->result, accu->allocated * sizeof (uint32_t));\n    }\n  accu->result[accu->length] = uc;\n  accu->length++;\n  return 0;\n}",
      "lines": 14,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static int\ncheck (const uint32_t *input, size_t input_length,\n       const uint32_t *expected, size_t expected_length)\n{\n  struct accumulator accu;\n  struct uninorm_filter *filter;\n  size_t i;\n\n  accu.result = NULL;\n  accu.length = 0;\n  accu.allocated = 0;\n\n  filter = uninorm_filter_create (UNINORM_NFC, write_to_accumulator, &accu);\n  ASSERT (filter != NULL);\n\n  for (i = 0; i < input_length; i++)\n    ASSERT (uninorm_filter_write (filter, input[i]) == 0);\n\n  ASSERT (uninorm_filter_free (filter) == 0);\n\n  if (!(accu.result != NULL))\n    return 1;\n  if (!(accu.length == expected_length))\n    return 2;\n  if (!(u32_cmp (accu.result, expected, expected_length) == 0))\n    return 3;\n  free (accu.result);\n\n  return 0;\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "int\nmain ()\n{\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint32_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    static const uint32_t decomposed[] =\n      { 'G', 'r', 0x0075, 0x0308, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0438, 0x0306, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',',\n        0x1112, 0x1161, 0x11AB, 0x1100, 0x1173, 0x11AF, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input),           input, SIZEOF (input)) == 0);\n    ASSERT (check (decomposed, SIZEOF (decomposed), input, SIZEOF (input)) == 0);\n  }\n\n  return 0;\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-u16-asnprintf1.c": {
    "test_asnprintf": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "static void\ntest_asnprintf ()\n{\n  test_function (u16_asnprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  test_asnprintf ();\n  return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-u16-asnprintf1.h": {
    "test_function": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static void\ntest_function (uint16_t * (*my_asnprintf) (uint16_t *, size_t *, const char *, ...))\n{\n  uint16_t buf[8];\n  int size;\n\n  /* Test return value convention.  */\n\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length = size;\n      uint16_t *result = my_asnprintf (NULL, &length, \"%d\", 12345);\n      static const uint16_t expected[] =\n        { '1', '2', '3', '4', '5', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      ASSERT (length == 5);\n      free (result);\n    }\n\n  for (size = 0; size <= 8; size++)\n    {\n      static const uint16_t initializer[] =\n        { 'D', 'E', 'A', 'D', 'B', 'E', 'E', 'F', 0 };\n      static const uint16_t expected[] =\n        { '1', '2', '3', '4', '5', 0 };\n      size_t length;\n      uint16_t *result;\n\n      u16_cpy (buf, initializer, 8);\n      length = size;\n      result = my_asnprintf (buf, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      ASSERT (length == 5);\n      if (size < 6)\n        ASSERT (result != buf);\n      ASSERT (u16_cmp (buf + size, initializer + size, 8 - size) == 0);\n      if (result != buf)\n        free (result);\n    }\n}",
      "lines": 42,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-u16-printf1.h": {
    "test_xfunction": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        940,
        1
      ],
      "content": "static void\ntest_xfunction (uint16_t * (*my_xasprintf) (const char *, ...))\n{\n  /* Test support of size specifiers as in C99.  */\n\n  {\n    uint16_t *result =\n      my_xasprintf (\"%ju %d\", (uintmax_t) 12345671, 33, 44, 55);\n    static const uint16_t expected[] =\n      { '1', '2', '3', '4', '5', '6', '7', '1', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  {\n    uint16_t *result =\n      my_xasprintf (\"%zu %d\", (size_t) 12345672, 33, 44, 55);\n    static const uint16_t expected[] =\n      { '1', '2', '3', '4', '5', '6', '7', '2', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  {\n    uint16_t *result =\n      my_xasprintf (\"%tu %d\", (ptrdiff_t) 12345673, 33, 44, 55);\n    static const uint16_t expected[] =\n      { '1', '2', '3', '4', '5', '6', '7', '3', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  {\n    uint16_t *result =\n      my_xasprintf (\"%Lg %d\", (long double) 1.5, 33, 44, 55);\n    static const uint16_t expected[] =\n      { '1', '.', '5', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  /* Test the support of the 'U' conversion specifier for Unicode strings.  */\n\n  {\n    static const uint8_t unicode_string[] = \"Hello\";\n    {\n      uint16_t *result =\n        my_xasprintf (\"%U %d\", unicode_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { 'H', 'e', 'l', 'l', 'o', ' ', '3', '3', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* Width.  */\n      uint16_t *result =\n        my_xasprintf (\"%10U %d\", unicode_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { ' ', ' ', ' ', ' ', ' ', 'H', 'e', 'l', 'l', 'o', ' ', '3', '3', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      uint16_t *result =\n        my_xasprintf (\"%-10U %d\", unicode_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { 'H', 'e', 'l', 'l', 'o', ' ', ' ', ' ', ' ', ' ', ' ', '3', '3', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      uint16_t *result =\n        my_xasprintf (\"%010U %d\", unicode_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { ' ', ' ', ' ', ' ', ' ', 'H', 'e', 'l', 'l', 'o', ' ', '3', '3', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      free (result);\n    }\n  }\n\n  {\n    static const uint16_t unicode_string[] = { 'H', 'e', 'l', 'l', 'o', 0 };\n    {\n      uint16_t *result =\n        my_xasprintf (\"%lU %d\", unicode_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { 'H', 'e', 'l', 'l', 'o', ' ', '3', '3', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* Width.  */\n      uint16_t *result =\n        my_xasprintf (\"%10lU %d\", unicode_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { ' ', ' ', ' ', ' ', ' ', 'H', 'e', 'l', 'l', 'o', ' ', '3', '3', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      uint16_t *result =\n        my_xasprintf (\"%-10lU %d\", unicode_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { 'H', 'e', 'l', 'l', 'o', ' ', ' ', ' ', ' ', ' ', ' ', '3', '3', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      uint16_t *result =\n        my_xasprintf (\"%010lU %d\", unicode_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { ' ', ' ', ' ', ' ', ' ', 'H', 'e', 'l', 'l', 'o', ' ', '3', '3', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      free (result);\n    }\n  }\n\n  {\n    static const uint32_t unicode_string[] = { 'H', 'e', 'l', 'l', 'o', 0 };\n    {\n      uint16_t *result =\n        my_xasprintf (\"%llU %d\", unicode_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { 'H', 'e', 'l', 'l', 'o', ' ', '3', '3', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* Width.  */\n      uint16_t *result =\n        my_xasprintf (\"%10llU %d\", unicode_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { ' ', ' ', ' ', ' ', ' ', 'H', 'e', 'l', 'l', 'o', ' ', '3', '3', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      uint16_t *result =\n        my_xasprintf (\"%-10llU %d\", unicode_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { 'H', 'e', 'l', 'l', 'o', ' ', ' ', ' ', ' ', ' ', ' ', '3', '3', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      uint16_t *result =\n        my_xasprintf (\"%010llU %d\", unicode_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { ' ', ' ', ' ', ' ', ' ', 'H', 'e', 'l', 'l', 'o', ' ', '3', '3', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      free (result);\n    }\n  }\n\n  /* Test the support of the 's' conversion specifier for strings.  */\n\n  {\n    uint16_t *result =\n      my_xasprintf (\"Mr. %s %d\", \"Ronald Reagan\", 33, 44, 55);\n    static const uint16_t expected[] =\n      { 'M', 'r', '.', ' ', 'R', 'o', 'n', 'a', 'l', 'd',\n        ' ', 'R', 'e', 'a', 'g', 'a', 'n', ' ', '3', '3',\n        0\n      };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    uint16_t *result =\n      my_xasprintf (\"Mr. %20s %d\", \"Ronald Reagan\", 33, 44, 55);\n    static const uint16_t expected[] =\n      { 'M', 'r', '.', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n        ' ', 'R', 'o', 'n', 'a', 'l', 'd', ' ', 'R', 'e',\n        'a', 'g', 'a', 'n', ' ', '3', '3', 0\n      };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* FLAG_LEFT.  */\n    uint16_t *result =\n      my_xasprintf (\"Mr. %-20s %d\", \"Ronald Reagan\", 33, 44, 55);\n    static const uint16_t expected[] =\n      { 'M', 'r', '.', ' ', 'R', 'o', 'n', 'a', 'l', 'd',\n        ' ', 'R', 'e', 'a', 'g', 'a', 'n', ' ', ' ', ' ',\n        ' ', ' ', ' ', ' ', ' ', '3', '3', 0\n      };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* FLAG_ZERO: no effect.  */\n    uint16_t *result =\n      my_xasprintf (\"Mr. %020s %d\", \"Ronald Reagan\", 33, 44, 55);\n    static const uint16_t expected[] =\n      { 'M', 'r', '.', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n        ' ', 'R', 'o', 'n', 'a', 'l', 'd', ' ', 'R', 'e',\n        'a', 'g', 'a', 'n', ' ', '3', '3', 0\n      };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  /* Test the support of the 'a' and 'A' conversion specifier for hexadecimal\n     output of floating-point numbers.  */\n\n  { /* A positive number.  */\n    uint16_t *result =\n      my_xasprintf (\"%a %d\", 3.1416015625, 33, 44, 55);\n    static const uint16_t expected1[] =\n      { '0', 'x', '1', '.', '9', '2', '2', 'p', '+', '1', ' ', '3', '3', 0 };\n    static const uint16_t expected2[] =\n      { '0', 'x', '3', '.', '2', '4', '4', 'p', '+', '0', ' ', '3', '3', 0 };\n    static const uint16_t expected3[] =\n      { '0', 'x', '6', '.', '4', '8', '8', 'p', '-', '1', ' ', '3', '3', 0 };\n    static const uint16_t expected4[] =\n      { '0', 'x', 'c', '.', '9', '1', 'p', '-', '2', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected1) == 0\n            || u16_strcmp (result, expected2) == 0\n            || u16_strcmp (result, expected3) == 0\n            || u16_strcmp (result, expected4) == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    uint16_t *result =\n      my_xasprintf (\"%10a %d\", 1.75, 33, 44, 55);\n    static const uint16_t expected1[] =\n      { ' ', ' ', '0', 'x', '1', '.', 'c', 'p', '+', '0', ' ', '3', '3', 0 };\n    static const uint16_t expected2[] =\n      { ' ', ' ', '0', 'x', '3', '.', '8', 'p', '-', '1', ' ', '3', '3', 0 };\n    static const uint16_t expected3[] =\n      { ' ', ' ', ' ', ' ', '0', 'x', '7', 'p', '-', '2', ' ', '3', '3', 0 };\n    static const uint16_t expected4[] =\n      { ' ', ' ', ' ', ' ', '0', 'x', 'e', 'p', '-', '3', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected1) == 0\n            || u16_strcmp (result, expected2) == 0\n            || u16_strcmp (result, expected3) == 0\n            || u16_strcmp (result, expected4) == 0);\n    free (result);\n  }\n\n  { /* Small precision.  */\n    uint16_t *result =\n      my_xasprintf (\"%.10a %d\", 1.75, 33, 44, 55);\n    static const uint16_t expected1[] =\n      { '0', 'x', '1', '.', 'c', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '+', '0', ' ', '3', '3',\n        0\n      };\n    static const uint16_t expected2[] =\n      { '0', 'x', '3', '.', '8', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '-', '1', ' ', '3', '3',\n        0\n      };\n    static const uint16_t expected3[] =\n      { '0', 'x', '7', '.', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '-', '2', ' ', '3', '3',\n        0\n      };\n    static const uint16_t expected4[] =\n      { '0', 'x', 'e', '.', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '-', '3', ' ', '3', '3',\n        0\n      };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected1) == 0\n            || u16_strcmp (result, expected2) == 0\n            || u16_strcmp (result, expected3) == 0\n            || u16_strcmp (result, expected4) == 0);\n    free (result);\n  }\n\n  { /* Large precision.  */\n    uint16_t *result =\n      my_xasprintf (\"%.50a %d\", 1.75, 33, 44, 55);\n    static const uint16_t expected1[] =\n      { '0', 'x', '1', '.', 'c', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '+', '0', ' ', '3', '3',\n        0\n      };\n    static const uint16_t expected2[] =\n      { '0', 'x', '3', '.', '8', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '-', '1', ' ', '3', '3',\n        0\n      };\n    static const uint16_t expected3[] =\n      { '0', 'x', '7', '.', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '-', '2', ' ', '3', '3',\n        0\n      };\n    static const uint16_t expected4[] =\n      { '0', 'x', 'e', '.', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '-', '3', ' ', '3', '3',\n        0\n      };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected1) == 0\n            || u16_strcmp (result, expected2) == 0\n            || u16_strcmp (result, expected3) == 0\n            || u16_strcmp (result, expected4) == 0);\n    free (result);\n  }\n\n  { /* A positive number.  */\n    uint16_t *result =\n      my_xasprintf (\"%La %d\", 3.1416015625L, 33, 44, 55);\n    static const uint16_t expected1[] =\n      { '0', 'x', '1', '.', '9', '2', '2', 'p', '+', '1',\n        ' ', '3', '3', 0\n      };\n    static const uint16_t expected2[] =\n      { '0', 'x', '3', '.', '2', '4', '4', 'p', '+', '0',\n        ' ', '3', '3', 0\n      };\n    static const uint16_t expected3[] =\n      { '0', 'x', '6', '.', '4', '8', '8', 'p', '-', '1',\n        ' ', '3', '3', 0\n      };\n    static const uint16_t expected4[] =\n      { '0', 'x', 'c', '.', '9', '1', 'p', '-', '2', ' ',\n        '3', '3', 0\n      };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected1) == 0\n            || u16_strcmp (result, expected2) == 0\n            || u16_strcmp (result, expected3) == 0\n            || u16_strcmp (result, expected4) == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    uint16_t *result =\n      my_xasprintf (\"%10La %d\", 1.75L, 33, 44, 55);\n    static const uint16_t expected1[] =\n      { ' ', ' ', '0', 'x', '1', '.', 'c', 'p', '+', '0', ' ', '3', '3', 0 };\n    static const uint16_t expected2[] =\n      { ' ', ' ', '0', 'x', '3', '.', '8', 'p', '-', '1', ' ', '3', '3', 0 };\n    static const uint16_t expected3[] =\n      { ' ', ' ', ' ', ' ', '0', 'x', '7', 'p', '-', '2', ' ', '3', '3', 0 };\n    static const uint16_t expected4[] =\n      { ' ', ' ', ' ', ' ', '0', 'x', 'e', 'p', '-', '3', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected1) == 0\n            || u16_strcmp (result, expected2) == 0\n            || u16_strcmp (result, expected3) == 0\n            || u16_strcmp (result, expected4) == 0);\n    free (result);\n  }\n\n  { /* Small precision.  */\n    uint16_t *result =\n      my_xasprintf (\"%.10La %d\", 1.75L, 33, 44, 55);\n    static const uint16_t expected1[] =\n      { '0', 'x', '1', '.', 'c', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '+', '0', ' ', '3', '3',\n        0\n      };\n    static const uint16_t expected2[] =\n      { '0', 'x', '3', '.', '8', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '-', '1', ' ', '3', '3',\n        0\n      };\n    static const uint16_t expected3[] =\n      { '0', 'x', '7', '.', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '-', '2', ' ', '3', '3',\n        0\n      };\n    static const uint16_t expected4[] =\n      { '0', 'x', 'e', '.', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '-', '3', ' ', '3', '3',\n        0\n      };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected1) == 0\n            || u16_strcmp (result, expected2) == 0\n            || u16_strcmp (result, expected3) == 0\n            || u16_strcmp (result, expected4) == 0);\n    free (result);\n  }\n\n  { /* Large precision.  */\n    uint16_t *result =\n      my_xasprintf (\"%.50La %d\", 1.75L, 33, 44, 55);\n    static const uint16_t expected1[] =\n      { '0', 'x', '1', '.', 'c', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '+', '0', ' ', '3', '3',\n        0\n      };\n    static const uint16_t expected2[] =\n      { '0', 'x', '3', '.', '8', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '-', '1', ' ', '3', '3',\n        0\n      };\n    static const uint16_t expected3[] =\n      { '0', 'x', '7', '.', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '-', '2', ' ', '3', '3',\n        0\n      };\n    static const uint16_t expected4[] =\n      { '0', 'x', 'e', '.', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '-', '3', ' ', '3', '3',\n        0\n      };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected1) == 0\n            || u16_strcmp (result, expected2) == 0\n            || u16_strcmp (result, expected3) == 0\n            || u16_strcmp (result, expected4) == 0);\n    free (result);\n  }\n\n  /* Test the support of the %f format directive.  */\n\n  { /* A positive number.  */\n    uint16_t *result =\n      my_xasprintf (\"%f %d\", 12.75, 33, 44, 55);\n    static const uint16_t expected[] =\n      { '1', '2', '.', '7', '5', '0', '0', '0', '0', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    uint16_t *result =\n      my_xasprintf (\"%10f %d\", 1.75, 33, 44, 55);\n    static const uint16_t expected[] =\n      { ' ', ' ', '1', '.', '7', '5', '0', '0', '0', '0', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    uint16_t *result =\n      my_xasprintf (\"%.f %d\", 1234.0, 33, 44, 55);\n    static const uint16_t expected[] =\n      { '1', '2', '3', '4', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* A positive number.  */\n    uint16_t *result =\n      my_xasprintf (\"%Lf %d\", 12.75L, 33, 44, 55);\n    static const uint16_t expected[] =\n      { '1', '2', '.', '7', '5', '0', '0', '0', '0', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    uint16_t *result =\n      my_xasprintf (\"%10Lf %d\", 1.75L, 33, 44, 55);\n    static const uint16_t expected[] =\n      { ' ', ' ', '1', '.', '7', '5', '0', '0', '0', '0', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    uint16_t *result =\n      my_xasprintf (\"%.Lf %d\", 1234.0L, 33, 44, 55);\n    static const uint16_t expected[] =\n      { '1', '2', '3', '4', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  /* Test the support of the %F format directive.  */\n\n  { /* A positive number.  */\n    uint16_t *result =\n      my_xasprintf (\"%F %d\", 12.75, 33, 44, 55);\n    static const uint16_t expected[] =\n      { '1', '2', '.', '7', '5', '0', '0', '0', '0', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    uint16_t *result =\n      my_xasprintf (\"%.F %d\", 1234.0, 33, 44, 55);\n    static const uint16_t expected[] =\n      { '1', '2', '3', '4', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* A positive number.  */\n    uint16_t *result =\n      my_xasprintf (\"%LF %d\", 12.75L, 33, 44, 55);\n    static const uint16_t expected[] =\n      { '1', '2', '.', '7', '5', '0', '0', '0', '0', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    uint16_t *result =\n      my_xasprintf (\"%.LF %d\", 1234.0L, 33, 44, 55);\n    static const uint16_t expected[] =\n      { '1', '2', '3', '4', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  /* Test the support of the %e format directive.  */\n\n  { /* A positive number.  */\n    uint16_t *result =\n      my_xasprintf (\"%e %d\", 12.75, 33, 44, 55);\n    static const uint16_t expected1[] =\n      { '1', '.', '2', '7', '5', '0', '0', '0', 'e', '+',\n        '0', '1', ' ', '3', '3', 0\n      };\n    static const uint16_t expected2[] =\n      { '1', '.', '2', '7', '5', '0', '0', '0', 'e', '+',\n        '0', '0', '1', ' ', '3', '3', 0\n      };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected1) == 0\n            || u16_strcmp (result, expected2) == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    uint16_t *result =\n      my_xasprintf (\"%15e %d\", 1.75, 33, 44, 55);\n    static const uint16_t expected1[] =\n      { ' ', ' ', ' ', '1', '.', '7', '5', '0', '0', '0',\n        '0', 'e', '+', '0', '0', ' ', '3', '3', 0\n      };\n    static const uint16_t expected2[] =\n      { ' ', ' ', '1', '.', '7', '5', '0', '0', '0', '0',\n        'e', '+', '0', '0', '0', ' ', '3', '3', 0\n      };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected1) == 0\n            || u16_strcmp (result, expected2) == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    uint16_t *result =\n      my_xasprintf (\"%.e %d\", 1234.0, 33, 44, 55);\n    static const uint16_t expected1[] =\n      { '1', 'e', '+', '0', '3', ' ', '3', '3', 0 };\n    static const uint16_t expected2[] =\n      { '1', 'e', '+', '0', '0', '3', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected1) == 0\n            || u16_strcmp (result, expected2) == 0);\n    free (result);\n  }\n\n  { /* A positive number.  */\n    uint16_t *result =\n      my_xasprintf (\"%Le %d\", 12.75L, 33, 44, 55);\n    static const uint16_t expected[] =\n      { '1', '.', '2', '7', '5', '0', '0', '0', 'e', '+',\n        '0', '1', ' ', '3', '3', 0\n      };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    uint16_t *result =\n      my_xasprintf (\"%15Le %d\", 1.75L, 33, 44, 55);\n    static const uint16_t expected[] =\n      { ' ', ' ', ' ', '1', '.', '7', '5', '0', '0', '0',\n        '0', 'e', '+', '0', '0', ' ', '3', '3', 0\n      };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    uint16_t *result =\n      my_xasprintf (\"%.Le %d\", 1234.0L, 33, 44, 55);\n    static const uint16_t expected[] =\n      { '1', 'e', '+', '0', '3', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  /* Test the support of the %g format directive.  */\n\n  { /* A positive number.  */\n    uint16_t *result =\n      my_xasprintf (\"%g %d\", 12.75, 33, 44, 55);\n    static const uint16_t expected[] =\n      { '1', '2', '.', '7', '5', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    uint16_t *result =\n      my_xasprintf (\"%10g %d\", 1.75, 33, 44, 55);\n    static const uint16_t expected[] =\n      { ' ', ' ', ' ', ' ', ' ', ' ', '1', '.', '7', '5', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    uint16_t *result =\n      my_xasprintf (\"%.g %d\", 1234.0, 33, 44, 55);\n    static const uint16_t expected1[] =\n      { '1', 'e', '+', '0', '3', ' ', '3', '3', 0 };\n    static const uint16_t expected2[] =\n      { '1', 'e', '+', '0', '0', '3', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected1) == 0\n            || u16_strcmp (result, expected2) == 0);\n    free (result);\n  }\n\n  { /* A positive number.  */\n    uint16_t *result =\n      my_xasprintf (\"%Lg %d\", 12.75L, 33, 44, 55);\n    static const uint16_t expected[] =\n      { '1', '2', '.', '7', '5', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    uint16_t *result =\n      my_xasprintf (\"%10Lg %d\", 1.75L, 33, 44, 55);\n    static const uint16_t expected[] =\n      { ' ', ' ', ' ', ' ', ' ', ' ', '1', '.', '7', '5', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    uint16_t *result =\n      my_xasprintf (\"%.Lg %d\", 1234.0L, 33, 44, 55);\n    static const uint16_t expected[] =\n      { '1', 'e', '+', '0', '3', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  /* Test the support of the %n format directive.  */\n\n  {\n    int count = -1;\n    uint16_t *result =\n      my_xasprintf (\"%d %n\", 123, &count, 33, 44, 55);\n    static const uint16_t expected[] =\n      { '1', '2', '3', ' ', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected) == 0);\n    ASSERT (count == 4);\n    free (result);\n  }\n\n  /* Test the support of the POSIX/XSI format strings with positions.  */\n\n  {\n    uint16_t *result =\n      my_xasprintf (\"%2$d %1$d\", 33, 55);\n    static const uint16_t expected[] =\n      { '5', '5', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u16_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  /* Test the support of the grouping flag.  */\n\n  {\n    uint16_t *result =\n      my_xasprintf (\"%'d %d\", 1234567, 99);\n    ASSERT (result != NULL);\n    ASSERT (result[u16_strlen (result) - 1] == '9');\n    free (result);\n  }\n\n  /* Test the support of the 'U' conversion specifier for Unicode strings.  */\n\n  {\n    static const uint8_t unicode_string[] = \"Rafa\\305\\202 Maszkowski\"; /* Rafa\u00c5\u0082 Maszkowski */\n    {\n      uint16_t *result =\n        my_xasprintf (\"%U %d\", unicode_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { 'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z',\n          'k', 'o', 'w', 's', 'k', 'i', ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* Width.  */\n      uint16_t *result =\n        my_xasprintf (\"%20U %d\", unicode_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { ' ', ' ', ' ', ' ', 'R', 'a', 'f', 'a', 0x0142, ' ',\n          'M', 'a', 's', 'z', 'k', 'o', 'w', 's', 'k', 'i',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      uint16_t *result =\n        my_xasprintf (\"%-20U %d\", unicode_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { 'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z',\n          'k', 'o', 'w', 's', 'k', 'i', ' ', ' ', ' ', ' ',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      uint16_t *result =\n        my_xasprintf (\"%020U %d\", unicode_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { ' ', ' ', ' ', ' ', 'R', 'a', 'f', 'a', 0x0142, ' ',\n          'M', 'a', 's', 'z', 'k', 'o', 'w', 's', 'k', 'i',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      free (result);\n    }\n  }\n\n  {\n    static const uint16_t unicode_string[] = /* Rafa\u00c5\u0082 Maszkowski */\n      {\n        'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z', 'k', 'o', 'w',\n        's', 'k', 'i', 0\n      };\n    {\n      uint16_t *result =\n        my_xasprintf (\"%lU %d\", unicode_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { 'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z',\n          'k', 'o', 'w', 's', 'k', 'i', ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* Width.  */\n      uint16_t *result =\n        my_xasprintf (\"%20lU %d\", unicode_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { ' ', ' ', ' ', ' ', 'R', 'a', 'f', 'a', 0x0142, ' ',\n          'M', 'a', 's', 'z', 'k', 'o', 'w', 's', 'k', 'i',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      uint16_t *result =\n        my_xasprintf (\"%-20lU %d\", unicode_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { 'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z',\n          'k', 'o', 'w', 's', 'k', 'i', ' ', ' ', ' ', ' ',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      uint16_t *result =\n        my_xasprintf (\"%020lU %d\", unicode_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { ' ', ' ', ' ', ' ', 'R', 'a', 'f', 'a', 0x0142, ' ',\n          'M', 'a', 's', 'z', 'k', 'o', 'w', 's', 'k', 'i',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      free (result);\n    }\n  }\n\n  {\n    static const uint32_t unicode_string[] = /* Rafa\u00c5\u0082 Maszkowski */\n      {\n        'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z', 'k', 'o', 'w',\n        's', 'k', 'i', 0\n      };\n    {\n      uint16_t *result =\n        my_xasprintf (\"%llU %d\", unicode_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { 'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z',\n          'k', 'o', 'w', 's', 'k', 'i', ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* Width.  */\n      uint16_t *result =\n        my_xasprintf (\"%20llU %d\", unicode_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { ' ', ' ', ' ', ' ', 'R', 'a', 'f', 'a', 0x0142, ' ',\n          'M', 'a', 's', 'z', 'k', 'o', 'w', 's', 'k', 'i',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      uint16_t *result =\n        my_xasprintf (\"%-20llU %d\", unicode_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { 'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z',\n          'k', 'o', 'w', 's', 'k', 'i', ' ', ' ', ' ', ' ',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      uint16_t *result =\n        my_xasprintf (\"%020llU %d\", unicode_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { ' ', ' ', ' ', ' ', 'R', 'a', 'f', 'a', 0x0142, ' ',\n          'M', 'a', 's', 'z', 'k', 'o', 'w', 's', 'k', 'i',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      free (result);\n    }\n  }\n\n  /* Test non-ASCII characters in the format string.  */\n\n  {\n    uint16_t *result =\n      my_xasprintf (\"\\304rger\", 33, 44, 55);\n    ASSERT (result == NULL && errno == EINVAL);\n  }\n}",
      "lines": 923,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-u16-vasnprintf1.c": {
    "my_asnprintf": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "static uint16_t *\nmy_asnprintf (uint16_t *resultbuf, size_t *lengthp, const char *format, ...)\n{\n  va_list args;\n  uint16_t *ret;\n\n  va_start (args, format);\n  ret = u16_vasnprintf (resultbuf, lengthp, format, args);\n  va_end (args);\n  return ret;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "uint16_t",
        "*\nmy_asnprintf (uint16_t *resultbuf, size_t *lengthp, const char *format, ...)",
        "*"
      ]
    },
    "my_xasprintf": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "static uint16_t *\nmy_xasprintf (const char *format, ...)\n{\n  va_list args;\n  size_t length;\n  uint16_t *ret;\n\n  va_start (args, format);\n  ret = u16_vasnprintf (NULL, &length, format, args);\n  va_end (args);\n  if (ret != NULL)\n    ASSERT (length == u16_strlen (ret));\n  return ret;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "uint16_t",
        "*\nmy_xasprintf (const char *format, ...)",
        "*"
      ]
    },
    "test_vasnprintf": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static void\ntest_vasnprintf ()\n{\n  test_function (my_asnprintf);\n  test_xfunction (my_xasprintf);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  test_vasnprintf ();\n  return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-u16-vasnprintf2.c": {
    "test_function": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static void\ntest_function (uint16_t * (*my_asnprintf) (uint16_t *, size_t *, const char *, ...))\n{\n  /* Test the support of the 's' conversion specifier for strings.  */\n\n  {\n    const char *locale_string = \"\\304rger\"; /* \u00c3\u0084rger */\n    {\n      size_t length;\n      uint16_t *result =\n        my_asnprintf (NULL, &length, \"%s %d\", locale_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { 0x00c4, 'r', 'g', 'e', 'r', ' ', '3', '3', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      ASSERT (length == u16_strlen (result));\n      free (result);\n    }\n    { /* Width.  */\n      size_t length;\n      uint16_t *result =\n        my_asnprintf (NULL, &length, \"%10s %d\", locale_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { ' ', ' ', ' ', ' ', ' ', 0x00c4, 'r', 'g', 'e', 'r',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      ASSERT (length == u16_strlen (result));\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      size_t length;\n      uint16_t *result =\n        my_asnprintf (NULL, &length, \"%-10s %d\", locale_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { 0x00c4, 'r', 'g', 'e', 'r', ' ', ' ', ' ', ' ', ' ',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      ASSERT (length == u16_strlen (result));\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      size_t length;\n      uint16_t *result =\n        my_asnprintf (NULL, &length, \"%010s %d\", locale_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { ' ', ' ', ' ', ' ', ' ', 0x00c4, 'r', 'g', 'e', 'r',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      ASSERT (length == u16_strlen (result));\n      free (result);\n    }\n  }\n}",
      "lines": 59,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "my_asnprintf": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "static uint16_t *\nmy_asnprintf (uint16_t *resultbuf, size_t *lengthp, const char *format, ...)\n{\n  va_list args;\n  uint16_t *ret;\n\n  va_start (args, format);\n  ret = u16_vasnprintf (resultbuf, lengthp, format, args);\n  va_end (args);\n  return ret;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "uint16_t",
        "*\nmy_asnprintf (uint16_t *resultbuf, size_t *lengthp, const char *format, ...)",
        "*"
      ]
    },
    "test_vasnprintf": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static void\ntest_vasnprintf ()\n{\n  test_function (my_asnprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  test_vasnprintf ();\n  return 0;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-u16-vasnprintf3.c": {
    "test_function": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static void\ntest_function (uint16_t * (*my_asnprintf) (uint16_t *, size_t *, const char *, ...))\n{\n  /* Test the support of the 's' conversion specifier for strings.  */\n\n  {\n    const char *locale_string = \"\\303\\204rger\"; /* \u00c3\u0084rger */\n    {\n      size_t length;\n      uint16_t *result =\n        my_asnprintf (NULL, &length, \"%s %d\", locale_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { 0x00c4, 'r', 'g', 'e', 'r', ' ', '3', '3', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      ASSERT (length == u16_strlen (result));\n      free (result);\n    }\n    { /* Width.  */\n      size_t length;\n      uint16_t *result =\n        my_asnprintf (NULL, &length, \"%10s %d\", locale_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { ' ', ' ', ' ', ' ', ' ', 0x00c4, 'r', 'g', 'e', 'r',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      ASSERT (length == u16_strlen (result));\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      size_t length;\n      uint16_t *result =\n        my_asnprintf (NULL, &length, \"%-10s %d\", locale_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { 0x00c4, 'r', 'g', 'e', 'r', ' ', ' ', ' ', ' ', ' ',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      ASSERT (length == u16_strlen (result));\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      size_t length;\n      uint16_t *result =\n        my_asnprintf (NULL, &length, \"%010s %d\", locale_string, 33, 44, 55);\n      static const uint16_t expected[] =\n        { ' ', ' ', ' ', ' ', ' ', 0x00c4, 'r', 'g', 'e', 'r',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u16_strcmp (result, expected) == 0);\n      ASSERT (length == u16_strlen (result));\n      free (result);\n    }\n  }\n}",
      "lines": 59,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "my_asnprintf": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "static uint16_t *\nmy_asnprintf (uint16_t *resultbuf, size_t *lengthp, const char *format, ...)\n{\n  va_list args;\n  uint16_t *ret;\n\n  va_start (args, format);\n  ret = u16_vasnprintf (resultbuf, lengthp, format, args);\n  va_end (args);\n  return ret;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "uint16_t",
        "*\nmy_asnprintf (uint16_t *resultbuf, size_t *lengthp, const char *format, ...)",
        "*"
      ]
    },
    "test_vasnprintf": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static void\ntest_vasnprintf ()\n{\n  test_function (my_asnprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  test_vasnprintf ();\n  return 0;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-u16-vasprintf1.c": {
    "my_xasprintf": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "static uint16_t *\nmy_xasprintf (const char *format, ...)\n{\n  va_list args;\n  uint16_t *result;\n  int retval;\n\n  va_start (args, format);\n  retval = u16_vasprintf (&result, format, args);\n  va_end (args);\n  if (retval < 0)\n    return NULL;\n  ASSERT (result != NULL);\n  return result;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "uint16_t",
        "*\nmy_xasprintf (const char *format, ...)",
        "*"
      ]
    },
    "test_vasprintf": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "static void\ntest_vasprintf ()\n{\n  test_xfunction (my_xasprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  test_vasprintf ();\n  return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-u16-vsnprintf1.c": {
    "my_xasprintf": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static uint16_t *\nmy_xasprintf (const char *format, ...)\n{\n  va_list args;\n  uint16_t buf[1000];\n  int retval;\n  size_t length;\n  uint16_t *result;\n\n  va_start (args, format);\n  retval = u16_vsnprintf (buf, sizeof (buf), format, args);\n  va_end (args);\n  if (retval < 0 || retval >= (int) sizeof (buf))\n    return NULL;\n  length = u16_strlen (buf);\n  result = XNMALLOC (length + 1, uint16_t);\n  u16_cpy (result, buf, length + 1);\n  return result;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "uint16_t",
        "*\nmy_xasprintf (const char *format, ...)",
        "*"
      ]
    },
    "test_vsnprintf": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static void\ntest_vsnprintf ()\n{\n  test_xfunction (my_xasprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  test_vsnprintf ();\n\n  return 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-u16-vsprintf1.c": {
    "my_xasprintf": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static uint16_t *\nmy_xasprintf (const char *format, ...)\n{\n  va_list args;\n  uint16_t buf[1000];\n  int retval;\n  size_t length;\n  uint16_t *result;\n\n  va_start (args, format);\n  retval = u16_vsprintf (buf, format, args);\n  va_end (args);\n  if (retval < 0 || retval >= (int) sizeof (buf))\n    return NULL;\n  length = u16_strlen (buf);\n  result = XNMALLOC (length + 1, uint16_t);\n  u16_cpy (result, buf, length + 1);\n  return result;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "uint16_t",
        "*\nmy_xasprintf (const char *format, ...)",
        "*"
      ]
    },
    "test_vsprintf": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static void\ntest_vsprintf ()\n{\n  test_xfunction (my_xasprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  test_vsprintf ();\n\n  return 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-u32-asnprintf1.c": {
    "test_asnprintf": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "static void\ntest_asnprintf ()\n{\n  test_function (u32_asnprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  test_asnprintf ();\n  return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-u32-asnprintf1.h": {
    "test_function": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static void\ntest_function (uint32_t * (*my_asnprintf) (uint32_t *, size_t *, const char *, ...))\n{\n  uint32_t buf[8];\n  int size;\n\n  /* Test return value convention.  */\n\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length = size;\n      uint32_t *result = my_asnprintf (NULL, &length, \"%d\", 12345);\n      static const uint32_t expected[] =\n        { '1', '2', '3', '4', '5', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      ASSERT (length == 5);\n      free (result);\n    }\n\n  for (size = 0; size <= 8; size++)\n    {\n      static const uint32_t initializer[] =\n        { 'D', 'E', 'A', 'D', 'B', 'E', 'E', 'F', 0 };\n      static const uint32_t expected[] =\n        { '1', '2', '3', '4', '5', 0 };\n      size_t length;\n      uint32_t *result;\n\n      u32_cpy (buf, initializer, 8);\n      length = size;\n      result = my_asnprintf (buf, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      ASSERT (length == 5);\n      if (size < 6)\n        ASSERT (result != buf);\n      ASSERT (u32_cmp (buf + size, initializer + size, 8 - size) == 0);\n      if (result != buf)\n        free (result);\n    }\n}",
      "lines": 42,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-u32-printf1.h": {
    "test_xfunction": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        940,
        1
      ],
      "content": "static void\ntest_xfunction (uint32_t * (*my_xasprintf) (const char *, ...))\n{\n  /* Test support of size specifiers as in C99.  */\n\n  {\n    uint32_t *result =\n      my_xasprintf (\"%ju %d\", (uintmax_t) 12345671, 33, 44, 55);\n    static const uint32_t expected[] =\n      { '1', '2', '3', '4', '5', '6', '7', '1', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  {\n    uint32_t *result =\n      my_xasprintf (\"%zu %d\", (size_t) 12345672, 33, 44, 55);\n    static const uint32_t expected[] =\n      { '1', '2', '3', '4', '5', '6', '7', '2', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  {\n    uint32_t *result =\n      my_xasprintf (\"%tu %d\", (ptrdiff_t) 12345673, 33, 44, 55);\n    static const uint32_t expected[] =\n      { '1', '2', '3', '4', '5', '6', '7', '3', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  {\n    uint32_t *result =\n      my_xasprintf (\"%Lg %d\", (long double) 1.5, 33, 44, 55);\n    static const uint32_t expected[] =\n      { '1', '.', '5', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  /* Test the support of the 'U' conversion specifier for Unicode strings.  */\n\n  {\n    static const uint8_t unicode_string[] = \"Hello\";\n    {\n      uint32_t *result =\n        my_xasprintf (\"%U %d\", unicode_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { 'H', 'e', 'l', 'l', 'o', ' ', '3', '3', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* Width.  */\n      uint32_t *result =\n        my_xasprintf (\"%10U %d\", unicode_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { ' ', ' ', ' ', ' ', ' ', 'H', 'e', 'l', 'l', 'o', ' ', '3', '3', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      uint32_t *result =\n        my_xasprintf (\"%-10U %d\", unicode_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { 'H', 'e', 'l', 'l', 'o', ' ', ' ', ' ', ' ', ' ', ' ', '3', '3', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      uint32_t *result =\n        my_xasprintf (\"%010U %d\", unicode_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { ' ', ' ', ' ', ' ', ' ', 'H', 'e', 'l', 'l', 'o', ' ', '3', '3', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      free (result);\n    }\n  }\n\n  {\n    static const uint16_t unicode_string[] = { 'H', 'e', 'l', 'l', 'o', 0 };\n    {\n      uint32_t *result =\n        my_xasprintf (\"%lU %d\", unicode_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { 'H', 'e', 'l', 'l', 'o', ' ', '3', '3', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* Width.  */\n      uint32_t *result =\n        my_xasprintf (\"%10lU %d\", unicode_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { ' ', ' ', ' ', ' ', ' ', 'H', 'e', 'l', 'l', 'o', ' ', '3', '3', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      uint32_t *result =\n        my_xasprintf (\"%-10lU %d\", unicode_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { 'H', 'e', 'l', 'l', 'o', ' ', ' ', ' ', ' ', ' ', ' ', '3', '3', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      uint32_t *result =\n        my_xasprintf (\"%010lU %d\", unicode_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { ' ', ' ', ' ', ' ', ' ', 'H', 'e', 'l', 'l', 'o', ' ', '3', '3', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      free (result);\n    }\n  }\n\n  {\n    static const uint32_t unicode_string[] = { 'H', 'e', 'l', 'l', 'o', 0 };\n    {\n      uint32_t *result =\n        my_xasprintf (\"%llU %d\", unicode_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { 'H', 'e', 'l', 'l', 'o', ' ', '3', '3', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* Width.  */\n      uint32_t *result =\n        my_xasprintf (\"%10llU %d\", unicode_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { ' ', ' ', ' ', ' ', ' ', 'H', 'e', 'l', 'l', 'o', ' ', '3', '3', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      uint32_t *result =\n        my_xasprintf (\"%-10llU %d\", unicode_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { 'H', 'e', 'l', 'l', 'o', ' ', ' ', ' ', ' ', ' ', ' ', '3', '3', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      uint32_t *result =\n        my_xasprintf (\"%010llU %d\", unicode_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { ' ', ' ', ' ', ' ', ' ', 'H', 'e', 'l', 'l', 'o', ' ', '3', '3', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      free (result);\n    }\n  }\n\n  /* Test the support of the 's' conversion specifier for strings.  */\n\n  {\n    uint32_t *result =\n      my_xasprintf (\"Mr. %s %d\", \"Ronald Reagan\", 33, 44, 55);\n    static const uint32_t expected[] =\n      { 'M', 'r', '.', ' ', 'R', 'o', 'n', 'a', 'l', 'd',\n        ' ', 'R', 'e', 'a', 'g', 'a', 'n', ' ', '3', '3',\n        0\n      };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    uint32_t *result =\n      my_xasprintf (\"Mr. %20s %d\", \"Ronald Reagan\", 33, 44, 55);\n    static const uint32_t expected[] =\n      { 'M', 'r', '.', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n        ' ', 'R', 'o', 'n', 'a', 'l', 'd', ' ', 'R', 'e',\n        'a', 'g', 'a', 'n', ' ', '3', '3', 0\n      };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* FLAG_LEFT.  */\n    uint32_t *result =\n      my_xasprintf (\"Mr. %-20s %d\", \"Ronald Reagan\", 33, 44, 55);\n    static const uint32_t expected[] =\n      { 'M', 'r', '.', ' ', 'R', 'o', 'n', 'a', 'l', 'd',\n        ' ', 'R', 'e', 'a', 'g', 'a', 'n', ' ', ' ', ' ',\n        ' ', ' ', ' ', ' ', ' ', '3', '3', 0\n      };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* FLAG_ZERO: no effect.  */\n    uint32_t *result =\n      my_xasprintf (\"Mr. %020s %d\", \"Ronald Reagan\", 33, 44, 55);\n    static const uint32_t expected[] =\n      { 'M', 'r', '.', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n        ' ', 'R', 'o', 'n', 'a', 'l', 'd', ' ', 'R', 'e',\n        'a', 'g', 'a', 'n', ' ', '3', '3', 0\n      };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  /* Test the support of the 'a' and 'A' conversion specifier for hexadecimal\n     output of floating-point numbers.  */\n\n  { /* A positive number.  */\n    uint32_t *result =\n      my_xasprintf (\"%a %d\", 3.1416015625, 33, 44, 55);\n    static const uint32_t expected1[] =\n      { '0', 'x', '1', '.', '9', '2', '2', 'p', '+', '1', ' ', '3', '3', 0 };\n    static const uint32_t expected2[] =\n      { '0', 'x', '3', '.', '2', '4', '4', 'p', '+', '0', ' ', '3', '3', 0 };\n    static const uint32_t expected3[] =\n      { '0', 'x', '6', '.', '4', '8', '8', 'p', '-', '1', ' ', '3', '3', 0 };\n    static const uint32_t expected4[] =\n      { '0', 'x', 'c', '.', '9', '1', 'p', '-', '2', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected1) == 0\n            || u32_strcmp (result, expected2) == 0\n            || u32_strcmp (result, expected3) == 0\n            || u32_strcmp (result, expected4) == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    uint32_t *result =\n      my_xasprintf (\"%10a %d\", 1.75, 33, 44, 55);\n    static const uint32_t expected1[] =\n      { ' ', ' ', '0', 'x', '1', '.', 'c', 'p', '+', '0', ' ', '3', '3', 0 };\n    static const uint32_t expected2[] =\n      { ' ', ' ', '0', 'x', '3', '.', '8', 'p', '-', '1', ' ', '3', '3', 0 };\n    static const uint32_t expected3[] =\n      { ' ', ' ', ' ', ' ', '0', 'x', '7', 'p', '-', '2', ' ', '3', '3', 0 };\n    static const uint32_t expected4[] =\n      { ' ', ' ', ' ', ' ', '0', 'x', 'e', 'p', '-', '3', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected1) == 0\n            || u32_strcmp (result, expected2) == 0\n            || u32_strcmp (result, expected3) == 0\n            || u32_strcmp (result, expected4) == 0);\n    free (result);\n  }\n\n  { /* Small precision.  */\n    uint32_t *result =\n      my_xasprintf (\"%.10a %d\", 1.75, 33, 44, 55);\n    static const uint32_t expected1[] =\n      { '0', 'x', '1', '.', 'c', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '+', '0', ' ', '3', '3',\n        0\n      };\n    static const uint32_t expected2[] =\n      { '0', 'x', '3', '.', '8', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '-', '1', ' ', '3', '3',\n        0\n      };\n    static const uint32_t expected3[] =\n      { '0', 'x', '7', '.', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '-', '2', ' ', '3', '3',\n        0\n      };\n    static const uint32_t expected4[] =\n      { '0', 'x', 'e', '.', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '-', '3', ' ', '3', '3',\n        0\n      };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected1) == 0\n            || u32_strcmp (result, expected2) == 0\n            || u32_strcmp (result, expected3) == 0\n            || u32_strcmp (result, expected4) == 0);\n    free (result);\n  }\n\n  { /* Large precision.  */\n    uint32_t *result =\n      my_xasprintf (\"%.50a %d\", 1.75, 33, 44, 55);\n    static const uint32_t expected1[] =\n      { '0', 'x', '1', '.', 'c', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '+', '0', ' ', '3', '3',\n        0\n      };\n    static const uint32_t expected2[] =\n      { '0', 'x', '3', '.', '8', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '-', '1', ' ', '3', '3',\n        0\n      };\n    static const uint32_t expected3[] =\n      { '0', 'x', '7', '.', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '-', '2', ' ', '3', '3',\n        0\n      };\n    static const uint32_t expected4[] =\n      { '0', 'x', 'e', '.', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '-', '3', ' ', '3', '3',\n        0\n      };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected1) == 0\n            || u32_strcmp (result, expected2) == 0\n            || u32_strcmp (result, expected3) == 0\n            || u32_strcmp (result, expected4) == 0);\n    free (result);\n  }\n\n  { /* A positive number.  */\n    uint32_t *result =\n      my_xasprintf (\"%La %d\", 3.1416015625L, 33, 44, 55);\n    static const uint32_t expected1[] =\n      { '0', 'x', '1', '.', '9', '2', '2', 'p', '+', '1',\n        ' ', '3', '3', 0\n      };\n    static const uint32_t expected2[] =\n      { '0', 'x', '3', '.', '2', '4', '4', 'p', '+', '0',\n        ' ', '3', '3', 0\n      };\n    static const uint32_t expected3[] =\n      { '0', 'x', '6', '.', '4', '8', '8', 'p', '-', '1',\n        ' ', '3', '3', 0\n      };\n    static const uint32_t expected4[] =\n      { '0', 'x', 'c', '.', '9', '1', 'p', '-', '2', ' ',\n        '3', '3', 0\n      };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected1) == 0\n            || u32_strcmp (result, expected2) == 0\n            || u32_strcmp (result, expected3) == 0\n            || u32_strcmp (result, expected4) == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    uint32_t *result =\n      my_xasprintf (\"%10La %d\", 1.75L, 33, 44, 55);\n    static const uint32_t expected1[] =\n      { ' ', ' ', '0', 'x', '1', '.', 'c', 'p', '+', '0', ' ', '3', '3', 0 };\n    static const uint32_t expected2[] =\n      { ' ', ' ', '0', 'x', '3', '.', '8', 'p', '-', '1', ' ', '3', '3', 0 };\n    static const uint32_t expected3[] =\n      { ' ', ' ', ' ', ' ', '0', 'x', '7', 'p', '-', '2', ' ', '3', '3', 0 };\n    static const uint32_t expected4[] =\n      { ' ', ' ', ' ', ' ', '0', 'x', 'e', 'p', '-', '3', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected1) == 0\n            || u32_strcmp (result, expected2) == 0\n            || u32_strcmp (result, expected3) == 0\n            || u32_strcmp (result, expected4) == 0);\n    free (result);\n  }\n\n  { /* Small precision.  */\n    uint32_t *result =\n      my_xasprintf (\"%.10La %d\", 1.75L, 33, 44, 55);\n    static const uint32_t expected1[] =\n      { '0', 'x', '1', '.', 'c', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '+', '0', ' ', '3', '3',\n        0\n      };\n    static const uint32_t expected2[] =\n      { '0', 'x', '3', '.', '8', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '-', '1', ' ', '3', '3',\n        0\n      };\n    static const uint32_t expected3[] =\n      { '0', 'x', '7', '.', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '-', '2', ' ', '3', '3',\n        0\n      };\n    static const uint32_t expected4[] =\n      { '0', 'x', 'e', '.', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '-', '3', ' ', '3', '3',\n        0\n      };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected1) == 0\n            || u32_strcmp (result, expected2) == 0\n            || u32_strcmp (result, expected3) == 0\n            || u32_strcmp (result, expected4) == 0);\n    free (result);\n  }\n\n  { /* Large precision.  */\n    uint32_t *result =\n      my_xasprintf (\"%.50La %d\", 1.75L, 33, 44, 55);\n    static const uint32_t expected1[] =\n      { '0', 'x', '1', '.', 'c', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '+', '0', ' ', '3', '3',\n        0\n      };\n    static const uint32_t expected2[] =\n      { '0', 'x', '3', '.', '8', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '-', '1', ' ', '3', '3',\n        0\n      };\n    static const uint32_t expected3[] =\n      { '0', 'x', '7', '.', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '-', '2', ' ', '3', '3',\n        0\n      };\n    static const uint32_t expected4[] =\n      { '0', 'x', 'e', '.', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n        '0', '0', '0', '0', 'p', '-', '3', ' ', '3', '3',\n        0\n      };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected1) == 0\n            || u32_strcmp (result, expected2) == 0\n            || u32_strcmp (result, expected3) == 0\n            || u32_strcmp (result, expected4) == 0);\n    free (result);\n  }\n\n  /* Test the support of the %f format directive.  */\n\n  { /* A positive number.  */\n    uint32_t *result =\n      my_xasprintf (\"%f %d\", 12.75, 33, 44, 55);\n    static const uint32_t expected[] =\n      { '1', '2', '.', '7', '5', '0', '0', '0', '0', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    uint32_t *result =\n      my_xasprintf (\"%10f %d\", 1.75, 33, 44, 55);\n    static const uint32_t expected[] =\n      { ' ', ' ', '1', '.', '7', '5', '0', '0', '0', '0', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    uint32_t *result =\n      my_xasprintf (\"%.f %d\", 1234.0, 33, 44, 55);\n    static const uint32_t expected[] =\n      { '1', '2', '3', '4', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* A positive number.  */\n    uint32_t *result =\n      my_xasprintf (\"%Lf %d\", 12.75L, 33, 44, 55);\n    static const uint32_t expected[] =\n      { '1', '2', '.', '7', '5', '0', '0', '0', '0', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    uint32_t *result =\n      my_xasprintf (\"%10Lf %d\", 1.75L, 33, 44, 55);\n    static const uint32_t expected[] =\n      { ' ', ' ', '1', '.', '7', '5', '0', '0', '0', '0', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    uint32_t *result =\n      my_xasprintf (\"%.Lf %d\", 1234.0L, 33, 44, 55);\n    static const uint32_t expected[] =\n      { '1', '2', '3', '4', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  /* Test the support of the %F format directive.  */\n\n  { /* A positive number.  */\n    uint32_t *result =\n      my_xasprintf (\"%F %d\", 12.75, 33, 44, 55);\n    static const uint32_t expected[] =\n      { '1', '2', '.', '7', '5', '0', '0', '0', '0', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    uint32_t *result =\n      my_xasprintf (\"%.F %d\", 1234.0, 33, 44, 55);\n    static const uint32_t expected[] =\n      { '1', '2', '3', '4', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* A positive number.  */\n    uint32_t *result =\n      my_xasprintf (\"%LF %d\", 12.75L, 33, 44, 55);\n    static const uint32_t expected[] =\n      { '1', '2', '.', '7', '5', '0', '0', '0', '0', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    uint32_t *result =\n      my_xasprintf (\"%.LF %d\", 1234.0L, 33, 44, 55);\n    static const uint32_t expected[] =\n      { '1', '2', '3', '4', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  /* Test the support of the %e format directive.  */\n\n  { /* A positive number.  */\n    uint32_t *result =\n      my_xasprintf (\"%e %d\", 12.75, 33, 44, 55);\n    static const uint32_t expected1[] =\n      { '1', '.', '2', '7', '5', '0', '0', '0', 'e', '+',\n        '0', '1', ' ', '3', '3', 0\n      };\n    static const uint32_t expected2[] =\n      { '1', '.', '2', '7', '5', '0', '0', '0', 'e', '+',\n        '0', '0', '1', ' ', '3', '3', 0\n      };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected1) == 0\n            || u32_strcmp (result, expected2) == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    uint32_t *result =\n      my_xasprintf (\"%15e %d\", 1.75, 33, 44, 55);\n    static const uint32_t expected1[] =\n      { ' ', ' ', ' ', '1', '.', '7', '5', '0', '0', '0',\n        '0', 'e', '+', '0', '0', ' ', '3', '3', 0\n      };\n    static const uint32_t expected2[] =\n      { ' ', ' ', '1', '.', '7', '5', '0', '0', '0', '0',\n        'e', '+', '0', '0', '0', ' ', '3', '3', 0\n      };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected1) == 0\n            || u32_strcmp (result, expected2) == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    uint32_t *result =\n      my_xasprintf (\"%.e %d\", 1234.0, 33, 44, 55);\n    static const uint32_t expected1[] =\n      { '1', 'e', '+', '0', '3', ' ', '3', '3', 0 };\n    static const uint32_t expected2[] =\n      { '1', 'e', '+', '0', '0', '3', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected1) == 0\n            || u32_strcmp (result, expected2) == 0);\n    free (result);\n  }\n\n  { /* A positive number.  */\n    uint32_t *result =\n      my_xasprintf (\"%Le %d\", 12.75L, 33, 44, 55);\n    static const uint32_t expected[] =\n      { '1', '.', '2', '7', '5', '0', '0', '0', 'e', '+',\n        '0', '1', ' ', '3', '3', 0\n      };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    uint32_t *result =\n      my_xasprintf (\"%15Le %d\", 1.75L, 33, 44, 55);\n    static const uint32_t expected[] =\n      { ' ', ' ', ' ', '1', '.', '7', '5', '0', '0', '0',\n        '0', 'e', '+', '0', '0', ' ', '3', '3', 0\n      };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    uint32_t *result =\n      my_xasprintf (\"%.Le %d\", 1234.0L, 33, 44, 55);\n    static const uint32_t expected[] =\n      { '1', 'e', '+', '0', '3', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  /* Test the support of the %g format directive.  */\n\n  { /* A positive number.  */\n    uint32_t *result =\n      my_xasprintf (\"%g %d\", 12.75, 33, 44, 55);\n    static const uint32_t expected[] =\n      { '1', '2', '.', '7', '5', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    uint32_t *result =\n      my_xasprintf (\"%10g %d\", 1.75, 33, 44, 55);\n    static const uint32_t expected[] =\n      { ' ', ' ', ' ', ' ', ' ', ' ', '1', '.', '7', '5', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    uint32_t *result =\n      my_xasprintf (\"%.g %d\", 1234.0, 33, 44, 55);\n    static const uint32_t expected1[] =\n      { '1', 'e', '+', '0', '3', ' ', '3', '3', 0 };\n    static const uint32_t expected2[] =\n      { '1', 'e', '+', '0', '0', '3', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected1) == 0\n            || u32_strcmp (result, expected2) == 0);\n    free (result);\n  }\n\n  { /* A positive number.  */\n    uint32_t *result =\n      my_xasprintf (\"%Lg %d\", 12.75L, 33, 44, 55);\n    static const uint32_t expected[] =\n      { '1', '2', '.', '7', '5', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    uint32_t *result =\n      my_xasprintf (\"%10Lg %d\", 1.75L, 33, 44, 55);\n    static const uint32_t expected[] =\n      { ' ', ' ', ' ', ' ', ' ', ' ', '1', '.', '7', '5', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    uint32_t *result =\n      my_xasprintf (\"%.Lg %d\", 1234.0L, 33, 44, 55);\n    static const uint32_t expected[] =\n      { '1', 'e', '+', '0', '3', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  /* Test the support of the %n format directive.  */\n\n  {\n    int count = -1;\n    uint32_t *result =\n      my_xasprintf (\"%d %n\", 123, &count, 33, 44, 55);\n    static const uint32_t expected[] =\n      { '1', '2', '3', ' ', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected) == 0);\n    ASSERT (count == 4);\n    free (result);\n  }\n\n  /* Test the support of the POSIX/XSI format strings with positions.  */\n\n  {\n    uint32_t *result =\n      my_xasprintf (\"%2$d %1$d\", 33, 55);\n    static const uint32_t expected[] =\n      { '5', '5', ' ', '3', '3', 0 };\n    ASSERT (result != NULL);\n    ASSERT (u32_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  /* Test the support of the grouping flag.  */\n\n  {\n    uint32_t *result =\n      my_xasprintf (\"%'d %d\", 1234567, 99);\n    ASSERT (result != NULL);\n    ASSERT (result[u32_strlen (result) - 1] == '9');\n    free (result);\n  }\n\n  /* Test the support of the 'U' conversion specifier for Unicode strings.  */\n\n  {\n    static const uint8_t unicode_string[] = \"Rafa\\305\\202 Maszkowski\"; /* Rafa\u00c5\u0082 Maszkowski */\n    {\n      uint32_t *result =\n        my_xasprintf (\"%U %d\", unicode_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { 'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z',\n          'k', 'o', 'w', 's', 'k', 'i', ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* Width.  */\n      uint32_t *result =\n        my_xasprintf (\"%20U %d\", unicode_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { ' ', ' ', ' ', ' ', 'R', 'a', 'f', 'a', 0x0142, ' ',\n          'M', 'a', 's', 'z', 'k', 'o', 'w', 's', 'k', 'i',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      uint32_t *result =\n        my_xasprintf (\"%-20U %d\", unicode_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { 'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z',\n          'k', 'o', 'w', 's', 'k', 'i', ' ', ' ', ' ', ' ',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      uint32_t *result =\n        my_xasprintf (\"%020U %d\", unicode_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { ' ', ' ', ' ', ' ', 'R', 'a', 'f', 'a', 0x0142, ' ',\n          'M', 'a', 's', 'z', 'k', 'o', 'w', 's', 'k', 'i',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      free (result);\n    }\n  }\n\n  {\n    static const uint16_t unicode_string[] = /* Rafa\u00c5\u0082 Maszkowski */\n      {\n        'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z', 'k', 'o', 'w',\n        's', 'k', 'i', 0\n      };\n    {\n      uint32_t *result =\n        my_xasprintf (\"%lU %d\", unicode_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { 'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z',\n          'k', 'o', 'w', 's', 'k', 'i', ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* Width.  */\n      uint32_t *result =\n        my_xasprintf (\"%20lU %d\", unicode_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { ' ', ' ', ' ', ' ', 'R', 'a', 'f', 'a', 0x0142, ' ',\n          'M', 'a', 's', 'z', 'k', 'o', 'w', 's', 'k', 'i',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      uint32_t *result =\n        my_xasprintf (\"%-20lU %d\", unicode_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { 'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z',\n          'k', 'o', 'w', 's', 'k', 'i', ' ', ' ', ' ', ' ',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      uint32_t *result =\n        my_xasprintf (\"%020lU %d\", unicode_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { ' ', ' ', ' ', ' ', 'R', 'a', 'f', 'a', 0x0142, ' ',\n          'M', 'a', 's', 'z', 'k', 'o', 'w', 's', 'k', 'i',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      free (result);\n    }\n  }\n\n  {\n    static const uint32_t unicode_string[] = /* Rafa\u00c5\u0082 Maszkowski */\n      {\n        'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z', 'k', 'o', 'w',\n        's', 'k', 'i', 0\n      };\n    {\n      uint32_t *result =\n        my_xasprintf (\"%llU %d\", unicode_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { 'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z',\n          'k', 'o', 'w', 's', 'k', 'i', ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* Width.  */\n      uint32_t *result =\n        my_xasprintf (\"%20llU %d\", unicode_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { ' ', ' ', ' ', ' ', 'R', 'a', 'f', 'a', 0x0142, ' ',\n          'M', 'a', 's', 'z', 'k', 'o', 'w', 's', 'k', 'i',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      uint32_t *result =\n        my_xasprintf (\"%-20llU %d\", unicode_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { 'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z',\n          'k', 'o', 'w', 's', 'k', 'i', ' ', ' ', ' ', ' ',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      uint32_t *result =\n        my_xasprintf (\"%020llU %d\", unicode_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { ' ', ' ', ' ', ' ', 'R', 'a', 'f', 'a', 0x0142, ' ',\n          'M', 'a', 's', 'z', 'k', 'o', 'w', 's', 'k', 'i',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      free (result);\n    }\n  }\n\n  /* Test non-ASCII characters in the format string.  */\n\n  {\n    uint32_t *result =\n      my_xasprintf (\"\\304rger\", 33, 44, 55);\n    ASSERT (result == NULL && errno == EINVAL);\n  }\n}",
      "lines": 923,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-u32-vasnprintf1.c": {
    "my_asnprintf": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "static uint32_t *\nmy_asnprintf (uint32_t *resultbuf, size_t *lengthp, const char *format, ...)\n{\n  va_list args;\n  uint32_t *ret;\n\n  va_start (args, format);\n  ret = u32_vasnprintf (resultbuf, lengthp, format, args);\n  va_end (args);\n  return ret;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "uint32_t",
        "*\nmy_asnprintf (uint32_t *resultbuf, size_t *lengthp, const char *format, ...)",
        "*"
      ]
    },
    "my_xasprintf": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "static uint32_t *\nmy_xasprintf (const char *format, ...)\n{\n  va_list args;\n  size_t length;\n  uint32_t *ret;\n\n  va_start (args, format);\n  ret = u32_vasnprintf (NULL, &length, format, args);\n  va_end (args);\n  if (ret != NULL)\n    ASSERT (length == u32_strlen (ret));\n  return ret;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "uint32_t",
        "*\nmy_xasprintf (const char *format, ...)",
        "*"
      ]
    },
    "test_vasnprintf": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static void\ntest_vasnprintf ()\n{\n  test_function (my_asnprintf);\n  test_xfunction (my_xasprintf);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  test_vasnprintf ();\n  return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-u32-vasnprintf2.c": {
    "test_function": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static void\ntest_function (uint32_t * (*my_asnprintf) (uint32_t *, size_t *, const char *, ...))\n{\n  /* Test the support of the 's' conversion specifier for strings.  */\n\n  {\n    const char *locale_string = \"\\304rger\"; /* \u00c3\u0084rger */\n    {\n      size_t length;\n      uint32_t *result =\n        my_asnprintf (NULL, &length, \"%s %d\", locale_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { 0x00c4, 'r', 'g', 'e', 'r', ' ', '3', '3', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      ASSERT (length == u32_strlen (result));\n      free (result);\n    }\n    { /* Width.  */\n      size_t length;\n      uint32_t *result =\n        my_asnprintf (NULL, &length, \"%10s %d\", locale_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { ' ', ' ', ' ', ' ', ' ', 0x00c4, 'r', 'g', 'e', 'r',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      ASSERT (length == u32_strlen (result));\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      size_t length;\n      uint32_t *result =\n        my_asnprintf (NULL, &length, \"%-10s %d\", locale_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { 0x00c4, 'r', 'g', 'e', 'r', ' ', ' ', ' ', ' ', ' ',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      ASSERT (length == u32_strlen (result));\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      size_t length;\n      uint32_t *result =\n        my_asnprintf (NULL, &length, \"%010s %d\", locale_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { ' ', ' ', ' ', ' ', ' ', 0x00c4, 'r', 'g', 'e', 'r',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      ASSERT (length == u32_strlen (result));\n      free (result);\n    }\n  }\n}",
      "lines": 59,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "my_asnprintf": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "static uint32_t *\nmy_asnprintf (uint32_t *resultbuf, size_t *lengthp, const char *format, ...)\n{\n  va_list args;\n  uint32_t *ret;\n\n  va_start (args, format);\n  ret = u32_vasnprintf (resultbuf, lengthp, format, args);\n  va_end (args);\n  return ret;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "uint32_t",
        "*\nmy_asnprintf (uint32_t *resultbuf, size_t *lengthp, const char *format, ...)",
        "*"
      ]
    },
    "test_vasnprintf": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static void\ntest_vasnprintf ()\n{\n  test_function (my_asnprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  test_vasnprintf ();\n  return 0;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-u32-vasnprintf3.c": {
    "test_function": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static void\ntest_function (uint32_t * (*my_asnprintf) (uint32_t *, size_t *, const char *, ...))\n{\n  /* Test the support of the 's' conversion specifier for strings.  */\n\n  {\n    const char *locale_string = \"\\303\\204rger\"; /* \u00c3\u0084rger */\n    {\n      size_t length;\n      uint32_t *result =\n        my_asnprintf (NULL, &length, \"%s %d\", locale_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { 0x00c4, 'r', 'g', 'e', 'r', ' ', '3', '3', 0 };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      ASSERT (length == u32_strlen (result));\n      free (result);\n    }\n    { /* Width.  */\n      size_t length;\n      uint32_t *result =\n        my_asnprintf (NULL, &length, \"%10s %d\", locale_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { ' ', ' ', ' ', ' ', ' ', 0x00c4, 'r', 'g', 'e', 'r',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      ASSERT (length == u32_strlen (result));\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      size_t length;\n      uint32_t *result =\n        my_asnprintf (NULL, &length, \"%-10s %d\", locale_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { 0x00c4, 'r', 'g', 'e', 'r', ' ', ' ', ' ', ' ', ' ',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      ASSERT (length == u32_strlen (result));\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      size_t length;\n      uint32_t *result =\n        my_asnprintf (NULL, &length, \"%010s %d\", locale_string, 33, 44, 55);\n      static const uint32_t expected[] =\n        { ' ', ' ', ' ', ' ', ' ', 0x00c4, 'r', 'g', 'e', 'r',\n          ' ', '3', '3', 0\n        };\n      ASSERT (result != NULL);\n      ASSERT (u32_strcmp (result, expected) == 0);\n      ASSERT (length == u32_strlen (result));\n      free (result);\n    }\n  }\n}",
      "lines": 59,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "my_asnprintf": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "static uint32_t *\nmy_asnprintf (uint32_t *resultbuf, size_t *lengthp, const char *format, ...)\n{\n  va_list args;\n  uint32_t *ret;\n\n  va_start (args, format);\n  ret = u32_vasnprintf (resultbuf, lengthp, format, args);\n  va_end (args);\n  return ret;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "uint32_t",
        "*\nmy_asnprintf (uint32_t *resultbuf, size_t *lengthp, const char *format, ...)",
        "*"
      ]
    },
    "test_vasnprintf": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static void\ntest_vasnprintf ()\n{\n  test_function (my_asnprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  test_vasnprintf ();\n  return 0;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-u32-vasprintf1.c": {
    "my_xasprintf": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "static uint32_t *\nmy_xasprintf (const char *format, ...)\n{\n  va_list args;\n  uint32_t *result;\n  int retval;\n\n  va_start (args, format);\n  retval = u32_vasprintf (&result, format, args);\n  va_end (args);\n  if (retval < 0)\n    return NULL;\n  ASSERT (result != NULL);\n  return result;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "uint32_t",
        "*\nmy_xasprintf (const char *format, ...)",
        "*"
      ]
    },
    "test_vasprintf": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "static void\ntest_vasprintf ()\n{\n  test_xfunction (my_xasprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  test_vasprintf ();\n  return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-u32-vsnprintf1.c": {
    "my_xasprintf": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static uint32_t *\nmy_xasprintf (const char *format, ...)\n{\n  va_list args;\n  uint32_t buf[1000];\n  int retval;\n  size_t length;\n  uint32_t *result;\n\n  va_start (args, format);\n  retval = u32_vsnprintf (buf, sizeof (buf), format, args);\n  va_end (args);\n  if (retval < 0 || retval >= (int) sizeof (buf))\n    return NULL;\n  length = u32_strlen (buf);\n  result = XNMALLOC (length + 1, uint32_t);\n  u32_cpy (result, buf, length + 1);\n  return result;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "uint32_t",
        "*\nmy_xasprintf (const char *format, ...)",
        "*"
      ]
    },
    "test_vsnprintf": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static void\ntest_vsnprintf ()\n{\n  test_xfunction (my_xasprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  test_vsnprintf ();\n\n  return 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-u32-vsprintf1.c": {
    "my_xasprintf": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static uint32_t *\nmy_xasprintf (const char *format, ...)\n{\n  va_list args;\n  uint32_t buf[1000];\n  int retval;\n  size_t length;\n  uint32_t *result;\n\n  va_start (args, format);\n  retval = u32_vsprintf (buf, format, args);\n  va_end (args);\n  if (retval < 0 || retval >= (int) sizeof (buf))\n    return NULL;\n  length = u32_strlen (buf);\n  result = XNMALLOC (length + 1, uint32_t);\n  u32_cpy (result, buf, length + 1);\n  return result;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "uint32_t",
        "*\nmy_xasprintf (const char *format, ...)",
        "*"
      ]
    },
    "test_vsprintf": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static void\ntest_vsprintf ()\n{\n  test_xfunction (my_xasprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  test_vsprintf ();\n\n  return 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-u8-asnprintf1.c": {
    "test_asnprintf": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "static void\ntest_asnprintf ()\n{\n  test_function (u8_asnprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  test_asnprintf ();\n  return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-u8-asnprintf1.h": {
    "test_function": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static void\ntest_function (uint8_t * (*my_asnprintf) (uint8_t *, size_t *, const char *, ...))\n{\n  uint8_t buf[8];\n  int size;\n\n  /* Test return value convention.  */\n\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length = size;\n      uint8_t *result = my_asnprintf (NULL, &length, \"%d\", 12345);\n      static const uint8_t expected[] = \"12345\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      ASSERT (length == 5);\n      free (result);\n    }\n\n  for (size = 0; size <= 8; size++)\n    {\n      static const uint8_t initializer[] = \"DEADBEEF\";\n      static const uint8_t expected[] = \"12345\";\n      size_t length;\n      uint8_t *result;\n\n      u8_cpy (buf, initializer, 8);\n      length = size;\n      result = my_asnprintf (buf, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      ASSERT (length == 5);\n      if (size < 6)\n        ASSERT (result != buf);\n      ASSERT (u8_cmp (buf + size, initializer + size, 8 - size) == 0);\n      if (result != buf)\n        free (result);\n    }\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-u8-printf1.h": {
    "test_xfunction": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        703,
        1
      ],
      "content": "static void\ntest_xfunction (uint8_t * (*my_xasprintf) (const char *, ...))\n{\n  /* Test support of size specifiers as in C99.  */\n\n  {\n    uint8_t *result =\n      my_xasprintf (\"%ju %d\", (uintmax_t) 12345671, 33, 44, 55);\n    static const uint8_t expected[] = \"12345671 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  {\n    uint8_t *result =\n      my_xasprintf (\"%zu %d\", (size_t) 12345672, 33, 44, 55);\n    static const uint8_t expected[] = \"12345672 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  {\n    uint8_t *result =\n      my_xasprintf (\"%tu %d\", (ptrdiff_t) 12345673, 33, 44, 55);\n    static const uint8_t expected[] = \"12345673 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  {\n    uint8_t *result =\n      my_xasprintf (\"%Lg %d\", (long double) 1.5, 33, 44, 55);\n    static const uint8_t expected[] = \"1.5 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  /* Test the support of the 'U' conversion specifier for Unicode strings.  */\n\n  {\n    static const uint8_t unicode_string[] = \"Hello\";\n    {\n      uint8_t *result =\n        my_xasprintf (\"%U %d\", unicode_string, 33, 44, 55);\n      static const uint8_t expected[] = \"Hello 33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* Width.  */\n      uint8_t *result =\n        my_xasprintf (\"%10U %d\", unicode_string, 33, 44, 55);\n      static const uint8_t expected[] = \"     Hello 33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      uint8_t *result =\n        my_xasprintf (\"%-10U %d\", unicode_string, 33, 44, 55);\n      static const uint8_t expected[] = \"Hello      33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      uint8_t *result =\n        my_xasprintf (\"%010U %d\", unicode_string, 33, 44, 55);\n      static const uint8_t expected[] = \"     Hello 33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      free (result);\n    }\n  }\n\n  {\n    static const uint16_t unicode_string[] = { 'H', 'e', 'l', 'l', 'o', 0 };\n    {\n      uint8_t *result =\n        my_xasprintf (\"%lU %d\", unicode_string, 33, 44, 55);\n      static const uint8_t expected[] = \"Hello 33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* Width.  */\n      uint8_t *result =\n        my_xasprintf (\"%10lU %d\", unicode_string, 33, 44, 55);\n      static const uint8_t expected[] = \"     Hello 33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      uint8_t *result =\n        my_xasprintf (\"%-10lU %d\", unicode_string, 33, 44, 55);\n      static const uint8_t expected[] = \"Hello      33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      uint8_t *result =\n        my_xasprintf (\"%010lU %d\", unicode_string, 33, 44, 55);\n      static const uint8_t expected[] = \"     Hello 33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      free (result);\n    }\n  }\n\n  {\n    static const uint32_t unicode_string[] = { 'H', 'e', 'l', 'l', 'o', 0 };\n    {\n      uint8_t *result =\n        my_xasprintf (\"%llU %d\", unicode_string, 33, 44, 55);\n      static const uint8_t expected[] = \"Hello 33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* Width.  */\n      uint8_t *result =\n        my_xasprintf (\"%10llU %d\", unicode_string, 33, 44, 55);\n      static const uint8_t expected[] = \"     Hello 33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      uint8_t *result =\n        my_xasprintf (\"%-10llU %d\", unicode_string, 33, 44, 55);\n      static const uint8_t expected[] = \"Hello      33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      uint8_t *result =\n        my_xasprintf (\"%010llU %d\", unicode_string, 33, 44, 55);\n      static const uint8_t expected[] = \"     Hello 33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      free (result);\n    }\n  }\n\n  /* Test the support of the 's' conversion specifier for strings.  */\n\n  {\n    uint8_t *result =\n      my_xasprintf (\"Mr. %s %d\", \"Ronald Reagan\", 33, 44, 55);\n    static const uint8_t expected[] = \"Mr. Ronald Reagan 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    uint8_t *result =\n      my_xasprintf (\"Mr. %20s %d\", \"Ronald Reagan\", 33, 44, 55);\n    static const uint8_t expected[] = \"Mr.        Ronald Reagan 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* FLAG_LEFT.  */\n    uint8_t *result =\n      my_xasprintf (\"Mr. %-20s %d\", \"Ronald Reagan\", 33, 44, 55);\n    static const uint8_t expected[] = \"Mr. Ronald Reagan        33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* FLAG_ZERO: no effect.  */\n    uint8_t *result =\n      my_xasprintf (\"Mr. %020s %d\", \"Ronald Reagan\", 33, 44, 55);\n    static const uint8_t expected[] = \"Mr.        Ronald Reagan 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  /* Test the support of the 'a' and 'A' conversion specifier for hexadecimal\n     output of floating-point numbers.  */\n\n  { /* A positive number.  */\n    uint8_t *result =\n      my_xasprintf (\"%a %d\", 3.1416015625, 33, 44, 55);\n    static const uint8_t expected1[] = \"0x1.922p+1 33\";\n    static const uint8_t expected2[] = \"0x3.244p+0 33\";\n    static const uint8_t expected3[] = \"0x6.488p-1 33\";\n    static const uint8_t expected4[] = \"0xc.91p-2 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected1) == 0\n            || u8_strcmp (result, expected2) == 0\n            || u8_strcmp (result, expected3) == 0\n            || u8_strcmp (result, expected4) == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    uint8_t *result =\n      my_xasprintf (\"%10a %d\", 1.75, 33, 44, 55);\n    static const uint8_t expected1[] = \"  0x1.cp+0 33\";\n    static const uint8_t expected2[] = \"  0x3.8p-1 33\";\n    static const uint8_t expected3[] = \"    0x7p-2 33\";\n    static const uint8_t expected4[] = \"    0xep-3 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected1) == 0\n            || u8_strcmp (result, expected2) == 0\n            || u8_strcmp (result, expected3) == 0\n            || u8_strcmp (result, expected4) == 0);\n    free (result);\n  }\n\n  { /* Small precision.  */\n    uint8_t *result =\n      my_xasprintf (\"%.10a %d\", 1.75, 33, 44, 55);\n    static const uint8_t expected1[] = \"0x1.c000000000p+0 33\";\n    static const uint8_t expected2[] = \"0x3.8000000000p-1 33\";\n    static const uint8_t expected3[] = \"0x7.0000000000p-2 33\";\n    static const uint8_t expected4[] = \"0xe.0000000000p-3 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected1) == 0\n            || u8_strcmp (result, expected2) == 0\n            || u8_strcmp (result, expected3) == 0\n            || u8_strcmp (result, expected4) == 0);\n    free (result);\n  }\n\n  { /* Large precision.  */\n    uint8_t *result =\n      my_xasprintf (\"%.50a %d\", 1.75, 33, 44, 55);\n    static const uint8_t expected1[] = \"0x1.c0000000000000000000000000000000000000000000000000p+0 33\";\n    static const uint8_t expected2[] = \"0x3.80000000000000000000000000000000000000000000000000p-1 33\";\n    static const uint8_t expected3[] = \"0x7.00000000000000000000000000000000000000000000000000p-2 33\";\n    static const uint8_t expected4[] = \"0xe.00000000000000000000000000000000000000000000000000p-3 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected1) == 0\n            || u8_strcmp (result, expected2) == 0\n            || u8_strcmp (result, expected3) == 0\n            || u8_strcmp (result, expected4) == 0);\n    free (result);\n  }\n\n  { /* A positive number.  */\n    uint8_t *result =\n      my_xasprintf (\"%La %d\", 3.1416015625L, 33, 44, 55);\n    static const uint8_t expected1[] = \"0x1.922p+1 33\";\n    static const uint8_t expected2[] = \"0x3.244p+0 33\";\n    static const uint8_t expected3[] = \"0x6.488p-1 33\";\n    static const uint8_t expected4[] = \"0xc.91p-2 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected1) == 0\n            || u8_strcmp (result, expected2) == 0\n            || u8_strcmp (result, expected3) == 0\n            || u8_strcmp (result, expected4) == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    uint8_t *result =\n      my_xasprintf (\"%10La %d\", 1.75L, 33, 44, 55);\n    static const uint8_t expected1[] = \"  0x1.cp+0 33\";\n    static const uint8_t expected2[] = \"  0x3.8p-1 33\";\n    static const uint8_t expected3[] = \"    0x7p-2 33\";\n    static const uint8_t expected4[] = \"    0xep-3 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected1) == 0\n            || u8_strcmp (result, expected2) == 0\n            || u8_strcmp (result, expected3) == 0\n            || u8_strcmp (result, expected4) == 0);\n    free (result);\n  }\n\n  { /* Small precision.  */\n    uint8_t *result =\n      my_xasprintf (\"%.10La %d\", 1.75L, 33, 44, 55);\n    static const uint8_t expected1[] = \"0x1.c000000000p+0 33\";\n    static const uint8_t expected2[] = \"0x3.8000000000p-1 33\";\n    static const uint8_t expected3[] = \"0x7.0000000000p-2 33\";\n    static const uint8_t expected4[] = \"0xe.0000000000p-3 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected1) == 0\n            || u8_strcmp (result, expected2) == 0\n            || u8_strcmp (result, expected3) == 0\n            || u8_strcmp (result, expected4) == 0);\n    free (result);\n  }\n\n  { /* Large precision.  */\n    uint8_t *result =\n      my_xasprintf (\"%.50La %d\", 1.75L, 33, 44, 55);\n    static const uint8_t expected1[] = \"0x1.c0000000000000000000000000000000000000000000000000p+0 33\";\n    static const uint8_t expected2[] = \"0x3.80000000000000000000000000000000000000000000000000p-1 33\";\n    static const uint8_t expected3[] = \"0x7.00000000000000000000000000000000000000000000000000p-2 33\";\n    static const uint8_t expected4[] = \"0xe.00000000000000000000000000000000000000000000000000p-3 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected1) == 0\n            || u8_strcmp (result, expected2) == 0\n            || u8_strcmp (result, expected3) == 0\n            || u8_strcmp (result, expected4) == 0);\n    free (result);\n  }\n\n  /* Test the support of the %f format directive.  */\n\n  { /* A positive number.  */\n    uint8_t *result =\n      my_xasprintf (\"%f %d\", 12.75, 33, 44, 55);\n    static const uint8_t expected[] = \"12.750000 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    uint8_t *result =\n      my_xasprintf (\"%10f %d\", 1.75, 33, 44, 55);\n    static const uint8_t expected[] = \"  1.750000 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    uint8_t *result =\n      my_xasprintf (\"%.f %d\", 1234.0, 33, 44, 55);\n    static const uint8_t expected[] = \"1234 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* A positive number.  */\n    uint8_t *result =\n      my_xasprintf (\"%Lf %d\", 12.75L, 33, 44, 55);\n    static const uint8_t expected[] = \"12.750000 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    uint8_t *result =\n      my_xasprintf (\"%10Lf %d\", 1.75L, 33, 44, 55);\n    static const uint8_t expected[] = \"  1.750000 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    uint8_t *result =\n      my_xasprintf (\"%.Lf %d\", 1234.0L, 33, 44, 55);\n    static const uint8_t expected[] = \"1234 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  /* Test the support of the %F format directive.  */\n\n  { /* A positive number.  */\n    uint8_t *result =\n      my_xasprintf (\"%F %d\", 12.75, 33, 44, 55);\n    static const uint8_t expected[] = \"12.750000 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    uint8_t *result =\n      my_xasprintf (\"%.F %d\", 1234.0, 33, 44, 55);\n    static const uint8_t expected[] = \"1234 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* A positive number.  */\n    uint8_t *result =\n      my_xasprintf (\"%LF %d\", 12.75L, 33, 44, 55);\n    static const uint8_t expected[] = \"12.750000 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    uint8_t *result =\n      my_xasprintf (\"%.LF %d\", 1234.0L, 33, 44, 55);\n    static const uint8_t expected[] = \"1234 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  /* Test the support of the %e format directive.  */\n\n  { /* A positive number.  */\n    uint8_t *result =\n      my_xasprintf (\"%e %d\", 12.75, 33, 44, 55);\n    static const uint8_t expected1[] = \"1.275000e+01 33\";\n    static const uint8_t expected2[] = \"1.275000e+001 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected1) == 0\n            || u8_strcmp (result, expected2) == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    uint8_t *result =\n      my_xasprintf (\"%15e %d\", 1.75, 33, 44, 55);\n    static const uint8_t expected1[] = \"   1.750000e+00 33\";\n    static const uint8_t expected2[] = \"  1.750000e+000 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected1) == 0\n            || u8_strcmp (result, expected2) == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    uint8_t *result =\n      my_xasprintf (\"%.e %d\", 1234.0, 33, 44, 55);\n    static const uint8_t expected1[] = \"1e+03 33\";\n    static const uint8_t expected2[] = \"1e+003 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected1) == 0\n            || u8_strcmp (result, expected2) == 0);\n    free (result);\n  }\n\n  { /* A positive number.  */\n    uint8_t *result =\n      my_xasprintf (\"%Le %d\", 12.75L, 33, 44, 55);\n    static const uint8_t expected[] = \"1.275000e+01 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    uint8_t *result =\n      my_xasprintf (\"%15Le %d\", 1.75L, 33, 44, 55);\n    static const uint8_t expected[] = \"   1.750000e+00 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    uint8_t *result =\n      my_xasprintf (\"%.Le %d\", 1234.0L, 33, 44, 55);\n    static const uint8_t expected[] = \"1e+03 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  /* Test the support of the %g format directive.  */\n\n  { /* A positive number.  */\n    uint8_t *result =\n      my_xasprintf (\"%g %d\", 12.75, 33, 44, 55);\n    static const uint8_t expected[] = \"12.75 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    uint8_t *result =\n      my_xasprintf (\"%10g %d\", 1.75, 33, 44, 55);\n    static const uint8_t expected[] = \"      1.75 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    uint8_t *result =\n      my_xasprintf (\"%.g %d\", 1234.0, 33, 44, 55);\n    static const uint8_t expected1[] = \"1e+03 33\";\n    static const uint8_t expected2[] = \"1e+003 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected1) == 0\n            || u8_strcmp (result, expected2) == 0);\n    free (result);\n  }\n\n  { /* A positive number.  */\n    uint8_t *result =\n      my_xasprintf (\"%Lg %d\", 12.75L, 33, 44, 55);\n    static const uint8_t expected[] = \"12.75 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    uint8_t *result =\n      my_xasprintf (\"%10Lg %d\", 1.75L, 33, 44, 55);\n    static const uint8_t expected[] = \"      1.75 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    uint8_t *result =\n      my_xasprintf (\"%.Lg %d\", 1234.0L, 33, 44, 55);\n    static const uint8_t expected[] = \"1e+03 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  /* Test the support of the %n format directive.  */\n\n  {\n    int count = -1;\n    uint8_t *result =\n      my_xasprintf (\"%d %n\", 123, &count, 33, 44, 55);\n    static const uint8_t expected[] = \"123 \";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected) == 0);\n    ASSERT (count == 4);\n    free (result);\n  }\n\n  /* Test the support of the POSIX/XSI format strings with positions.  */\n\n  {\n    uint8_t *result =\n      my_xasprintf (\"%2$d %1$d\", 33, 55);\n    static const uint8_t expected[] = \"55 33\";\n    ASSERT (result != NULL);\n    ASSERT (u8_strcmp (result, expected) == 0);\n    free (result);\n  }\n\n  /* Test the support of the grouping flag.  */\n\n  {\n    uint8_t *result =\n      my_xasprintf (\"%'d %d\", 1234567, 99);\n    ASSERT (result != NULL);\n    ASSERT (result[u8_strlen (result) - 1] == '9');\n    free (result);\n  }\n\n  /* Test the support of the 'U' conversion specifier for Unicode strings.  */\n\n  {\n    static const uint8_t unicode_string[] = \"Rafa\\305\\202 Maszkowski\"; /* Rafa\u00c5\u0082 Maszkowski */\n    {\n      uint8_t *result =\n        my_xasprintf (\"%U %d\", unicode_string, 33, 44, 55);\n      static const uint8_t expected[] = \"Rafa\\305\\202 Maszkowski 33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* Width.  */\n      uint8_t *result =\n        my_xasprintf (\"%20U %d\", unicode_string, 33, 44, 55);\n      static const uint8_t expected[] = \"    Rafa\\305\\202 Maszkowski 33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      uint8_t *result =\n        my_xasprintf (\"%-20U %d\", unicode_string, 33, 44, 55);\n      static const uint8_t expected[] = \"Rafa\\305\\202 Maszkowski     33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      uint8_t *result =\n        my_xasprintf (\"%020U %d\", unicode_string, 33, 44, 55);\n      static const uint8_t expected[] = \"    Rafa\\305\\202 Maszkowski 33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      free (result);\n    }\n  }\n\n  {\n    static const uint16_t unicode_string[] = /* Rafa\u00c5\u0082 Maszkowski */\n      {\n        'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z', 'k', 'o', 'w',\n        's', 'k', 'i', 0\n      };\n    {\n      uint8_t *result =\n        my_xasprintf (\"%lU %d\", unicode_string, 33, 44, 55);\n      static const uint8_t expected[] = \"Rafa\\305\\202 Maszkowski 33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* Width.  */\n      uint8_t *result =\n        my_xasprintf (\"%20lU %d\", unicode_string, 33, 44, 55);\n      static const uint8_t expected[] = \"    Rafa\\305\\202 Maszkowski 33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      uint8_t *result =\n        my_xasprintf (\"%-20lU %d\", unicode_string, 33, 44, 55);\n      static const uint8_t expected[] = \"Rafa\\305\\202 Maszkowski     33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      uint8_t *result =\n        my_xasprintf (\"%020lU %d\", unicode_string, 33, 44, 55);\n      static const uint8_t expected[] = \"    Rafa\\305\\202 Maszkowski 33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      free (result);\n    }\n  }\n\n  {\n    static const uint32_t unicode_string[] = /* Rafa\u00c5\u0082 Maszkowski */\n      {\n        'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z', 'k', 'o', 'w',\n        's', 'k', 'i', 0\n      };\n    {\n      uint8_t *result =\n        my_xasprintf (\"%llU %d\", unicode_string, 33, 44, 55);\n      static const uint8_t expected[] = \"Rafa\\305\\202 Maszkowski 33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* Width.  */\n      uint8_t *result =\n        my_xasprintf (\"%20llU %d\", unicode_string, 33, 44, 55);\n      static const uint8_t expected[] = \"    Rafa\\305\\202 Maszkowski 33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      uint8_t *result =\n        my_xasprintf (\"%-20llU %d\", unicode_string, 33, 44, 55);\n      static const uint8_t expected[] = \"Rafa\\305\\202 Maszkowski     33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      uint8_t *result =\n        my_xasprintf (\"%020llU %d\", unicode_string, 33, 44, 55);\n      static const uint8_t expected[] = \"    Rafa\\305\\202 Maszkowski 33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      free (result);\n    }\n  }\n\n  /* Test non-ASCII characters in the format string.  */\n\n  {\n    uint8_t *result =\n      my_xasprintf (\"\\304rger\", 33, 44, 55);\n    ASSERT (result == NULL && errno == EINVAL);\n  }\n}",
      "lines": 686,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-u8-vasnprintf1.c": {
    "my_asnprintf": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "static uint8_t *\nmy_asnprintf (uint8_t *resultbuf, size_t *lengthp, const char *format, ...)\n{\n  va_list args;\n  uint8_t *ret;\n\n  va_start (args, format);\n  ret = u8_vasnprintf (resultbuf, lengthp, format, args);\n  va_end (args);\n  return ret;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "uint8_t",
        "*\nmy_asnprintf (uint8_t *resultbuf, size_t *lengthp, const char *format, ...)",
        "*"
      ]
    },
    "my_xasprintf": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "static uint8_t *\nmy_xasprintf (const char *format, ...)\n{\n  va_list args;\n  size_t length;\n  uint8_t *ret;\n\n  va_start (args, format);\n  ret = u8_vasnprintf (NULL, &length, format, args);\n  va_end (args);\n  if (ret != NULL)\n    ASSERT (length == u8_strlen (ret));\n  return ret;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "uint8_t",
        "*\nmy_xasprintf (const char *format, ...)",
        "*"
      ]
    },
    "test_vasnprintf": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static void\ntest_vasnprintf ()\n{\n  test_function (my_asnprintf);\n  test_xfunction (my_xasprintf);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  test_vasnprintf ();\n  return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-u8-vasnprintf2.c": {
    "test_function": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static void\ntest_function (uint8_t * (*my_asnprintf) (uint8_t *, size_t *, const char *, ...))\n{\n  /* Test the support of the 's' conversion specifier for strings.  */\n\n  {\n    const char *locale_string = \"\\304rger\"; /* \u00c3\u0084rger */\n    {\n      size_t length;\n      uint8_t *result =\n        my_asnprintf (NULL, &length, \"%s %d\", locale_string, 33, 44, 55);\n      static const uint8_t expected[] = \"\\303\\204rger 33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      ASSERT (length == u8_strlen (result));\n      free (result);\n    }\n    { /* Width.  */\n      size_t length;\n      uint8_t *result =\n        my_asnprintf (NULL, &length, \"%10s %d\", locale_string, 33, 44, 55);\n      static const uint8_t expected[] = \"     \\303\\204rger 33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      ASSERT (length == u8_strlen (result));\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      size_t length;\n      uint8_t *result =\n        my_asnprintf (NULL, &length, \"%-10s %d\", locale_string, 33, 44, 55);\n      static const uint8_t expected[] = \"\\303\\204rger      33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      ASSERT (length == u8_strlen (result));\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      size_t length;\n      uint8_t *result =\n        my_asnprintf (NULL, &length, \"%010s %d\", locale_string, 33, 44, 55);\n      static const uint8_t expected[] = \"     \\303\\204rger 33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      ASSERT (length == u8_strlen (result));\n      free (result);\n    }\n  }\n}",
      "lines": 49,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "my_asnprintf": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static uint8_t *\nmy_asnprintf (uint8_t *resultbuf, size_t *lengthp, const char *format, ...)\n{\n  va_list args;\n  uint8_t *ret;\n\n  va_start (args, format);\n  ret = u8_vasnprintf (resultbuf, lengthp, format, args);\n  va_end (args);\n  return ret;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "uint8_t",
        "*\nmy_asnprintf (uint8_t *resultbuf, size_t *lengthp, const char *format, ...)",
        "*"
      ]
    },
    "test_vasnprintf": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "static void\ntest_vasnprintf ()\n{\n  test_function (my_asnprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  test_vasnprintf ();\n  return 0;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-u8-vasnprintf3.c": {
    "test_function": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static void\ntest_function (uint8_t * (*my_asnprintf) (uint8_t *, size_t *, const char *, ...))\n{\n  /* Test the support of the 's' conversion specifier for strings.  */\n\n  {\n    const char *locale_string = \"\\303\\204rger\"; /* \u00c3\u0084rger */\n    {\n      size_t length;\n      uint8_t *result =\n        my_asnprintf (NULL, &length, \"%s %d\", locale_string, 33, 44, 55);\n      static const uint8_t expected[] = \"\\303\\204rger 33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      ASSERT (length == u8_strlen (result));\n      free (result);\n    }\n    { /* Width.  */\n      size_t length;\n      uint8_t *result =\n        my_asnprintf (NULL, &length, \"%10s %d\", locale_string, 33, 44, 55);\n      static const uint8_t expected[] = \"     \\303\\204rger 33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      ASSERT (length == u8_strlen (result));\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      size_t length;\n      uint8_t *result =\n        my_asnprintf (NULL, &length, \"%-10s %d\", locale_string, 33, 44, 55);\n      static const uint8_t expected[] = \"\\303\\204rger      33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      ASSERT (length == u8_strlen (result));\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      size_t length;\n      uint8_t *result =\n        my_asnprintf (NULL, &length, \"%010s %d\", locale_string, 33, 44, 55);\n      static const uint8_t expected[] = \"     \\303\\204rger 33\";\n      ASSERT (result != NULL);\n      ASSERT (u8_strcmp (result, expected) == 0);\n      ASSERT (length == u8_strlen (result));\n      free (result);\n    }\n  }\n}",
      "lines": 49,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "my_asnprintf": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static uint8_t *\nmy_asnprintf (uint8_t *resultbuf, size_t *lengthp, const char *format, ...)\n{\n  va_list args;\n  uint8_t *ret;\n\n  va_start (args, format);\n  ret = u8_vasnprintf (resultbuf, lengthp, format, args);\n  va_end (args);\n  return ret;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "uint8_t",
        "*\nmy_asnprintf (uint8_t *resultbuf, size_t *lengthp, const char *format, ...)",
        "*"
      ]
    },
    "test_vasnprintf": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "static void\ntest_vasnprintf ()\n{\n  test_function (my_asnprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  test_vasnprintf ();\n  return 0;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-u8-vasprintf1.c": {
    "my_xasprintf": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "static uint8_t *\nmy_xasprintf (const char *format, ...)\n{\n  va_list args;\n  uint8_t *result;\n  int retval;\n\n  va_start (args, format);\n  retval = u8_vasprintf (&result, format, args);\n  va_end (args);\n  if (retval < 0)\n    return NULL;\n  ASSERT (result != NULL);\n  return result;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "uint8_t",
        "*\nmy_xasprintf (const char *format, ...)",
        "*"
      ]
    },
    "test_vasprintf": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "static void\ntest_vasprintf ()\n{\n  test_xfunction (my_xasprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  test_vasprintf ();\n  return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-u8-vsnprintf1.c": {
    "my_xasprintf": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static uint8_t *\nmy_xasprintf (const char *format, ...)\n{\n  va_list args;\n  uint8_t buf[1000];\n  int retval;\n  size_t length;\n  uint8_t *result;\n\n  va_start (args, format);\n  retval = u8_vsnprintf (buf, sizeof (buf), format, args);\n  va_end (args);\n  if (retval < 0 || retval >= (int) sizeof (buf))\n    return NULL;\n  length = u8_strlen (buf);\n  result = XNMALLOC (length + 1, uint8_t);\n  u8_cpy (result, buf, length + 1);\n  return result;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "uint8_t",
        "*\nmy_xasprintf (const char *format, ...)",
        "*"
      ]
    },
    "test_vsnprintf": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static void\ntest_vsnprintf ()\n{\n  test_xfunction (my_xasprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  test_vsnprintf ();\n\n  return 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-u8-vsprintf1.c": {
    "my_xasprintf": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static uint8_t *\nmy_xasprintf (const char *format, ...)\n{\n  va_list args;\n  uint8_t buf[1000];\n  int retval;\n  size_t length;\n  uint8_t *result;\n\n  va_start (args, format);\n  retval = u8_vsprintf (buf, format, args);\n  va_end (args);\n  if (retval < 0 || retval >= (int) sizeof (buf))\n    return NULL;\n  length = u8_strlen (buf);\n  result = XNMALLOC (length + 1, uint8_t);\n  u8_cpy (result, buf, length + 1);\n  return result;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "uint8_t",
        "*\nmy_xasprintf (const char *format, ...)",
        "*"
      ]
    },
    "test_vsprintf": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static void\ntest_vsprintf ()\n{\n  test_xfunction (my_xasprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  test_vsprintf ();\n\n  return 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-ulc-asnprintf1.c": {
    "test_asnprintf": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static void\ntest_asnprintf ()\n{\n  test_function (ulc_asnprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  test_asnprintf ();\n  return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-ulc-asnprintf1.h": {
    "test_function": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static void\ntest_function (char * (*my_asnprintf) (char *, size_t *, const char *, ...))\n{\n  char buf[8];\n  int size;\n\n  /* Test return value convention.  */\n\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length = size;\n      char *result = my_asnprintf (NULL, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      ASSERT (length == 5);\n      free (result);\n    }\n\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length;\n      char *result;\n\n      memcpy (buf, \"DEADBEEF\", 8);\n      length = size;\n      result = my_asnprintf (buf, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      ASSERT (length == 5);\n      if (size < 6)\n        ASSERT (result != buf);\n      ASSERT (memcmp (buf + size, &\"DEADBEEF\"[size], 8 - size) == 0);\n      if (result != buf)\n        free (result);\n    }\n}",
      "lines": 36,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-ulc-printf1.h": {
    "test_xfunction": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        497,
        1
      ],
      "content": "static void\ntest_xfunction (char * (*my_xasprintf) (const char *, ...))\n{\n  /* Test support of size specifiers as in C99.  */\n\n  {\n    char *result =\n      my_xasprintf (\"%ju %d\", (uintmax_t) 12345671, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"12345671 33\") == 0);\n    free (result);\n  }\n\n  {\n    char *result =\n      my_xasprintf (\"%zu %d\", (size_t) 12345672, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"12345672 33\") == 0);\n    free (result);\n  }\n\n  {\n    char *result =\n      my_xasprintf (\"%tu %d\", (ptrdiff_t) 12345673, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"12345673 33\") == 0);\n    free (result);\n  }\n\n  {\n    char *result =\n      my_xasprintf (\"%Lg %d\", (long double) 1.5, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"1.5 33\") == 0);\n    free (result);\n  }\n\n  /* Test the support of the 'U' conversion specifier for Unicode strings.  */\n\n  {\n    static const uint8_t unicode_string[] = \"Hello\";\n    {\n      char *result =\n        my_xasprintf (\"%U %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"Hello 33\") == 0);\n      free (result);\n    }\n    { /* Width.  */\n      char *result =\n        my_xasprintf (\"%10U %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"     Hello 33\") == 0);\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      char *result =\n        my_xasprintf (\"%-10U %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"Hello      33\") == 0);\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      char *result =\n        my_xasprintf (\"%010U %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"     Hello 33\") == 0);\n      free (result);\n    }\n  }\n\n  {\n    static const uint16_t unicode_string[] = { 'H', 'e', 'l', 'l', 'o', 0 };\n    {\n      char *result =\n        my_xasprintf (\"%lU %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"Hello 33\") == 0);\n      free (result);\n    }\n    { /* Width.  */\n      char *result =\n        my_xasprintf (\"%10lU %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"     Hello 33\") == 0);\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      char *result =\n        my_xasprintf (\"%-10lU %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"Hello      33\") == 0);\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      char *result =\n        my_xasprintf (\"%010lU %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"     Hello 33\") == 0);\n      free (result);\n    }\n  }\n\n  {\n    static const uint32_t unicode_string[] = { 'H', 'e', 'l', 'l', 'o', 0 };\n    {\n      char *result =\n        my_xasprintf (\"%llU %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"Hello 33\") == 0);\n      free (result);\n    }\n    { /* Width.  */\n      char *result =\n        my_xasprintf (\"%10llU %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"     Hello 33\") == 0);\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      char *result =\n        my_xasprintf (\"%-10llU %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"Hello      33\") == 0);\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      char *result =\n        my_xasprintf (\"%010llU %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"     Hello 33\") == 0);\n      free (result);\n    }\n  }\n\n  /* Test the support of the 's' conversion specifier for strings.  */\n\n  {\n    char *result =\n      my_xasprintf (\"Mr. %s %d\", \"Ronald Reagan\", 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"Mr. Ronald Reagan 33\") == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    char *result =\n      my_xasprintf (\"Mr. %20s %d\", \"Ronald Reagan\", 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"Mr.        Ronald Reagan 33\") == 0);\n    free (result);\n  }\n\n  { /* FLAG_LEFT.  */\n    char *result =\n      my_xasprintf (\"Mr. %-20s %d\", \"Ronald Reagan\", 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"Mr. Ronald Reagan        33\") == 0);\n    free (result);\n  }\n\n  { /* FLAG_ZERO: no effect.  */\n    char *result =\n      my_xasprintf (\"Mr. %020s %d\", \"Ronald Reagan\", 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"Mr.        Ronald Reagan 33\") == 0);\n    free (result);\n  }\n\n  /* Test the support of the 'a' and 'A' conversion specifier for hexadecimal\n     output of floating-point numbers.  */\n\n  { /* A positive number.  */\n    char *result =\n      my_xasprintf (\"%a %d\", 3.1416015625, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"0x1.922p+1 33\") == 0\n            || strcmp (result, \"0x3.244p+0 33\") == 0\n            || strcmp (result, \"0x6.488p-1 33\") == 0\n            || strcmp (result, \"0xc.91p-2 33\") == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    char *result =\n      my_xasprintf (\"%10a %d\", 1.75, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"  0x1.cp+0 33\") == 0\n            || strcmp (result, \"  0x3.8p-1 33\") == 0\n            || strcmp (result, \"    0x7p-2 33\") == 0\n            || strcmp (result, \"    0xep-3 33\") == 0);\n    free (result);\n  }\n\n  { /* Small precision.  */\n    char *result =\n      my_xasprintf (\"%.10a %d\", 1.75, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"0x1.c000000000p+0 33\") == 0\n            || strcmp (result, \"0x3.8000000000p-1 33\") == 0\n            || strcmp (result, \"0x7.0000000000p-2 33\") == 0\n            || strcmp (result, \"0xe.0000000000p-3 33\") == 0);\n    free (result);\n  }\n\n  { /* Large precision.  */\n    char *result =\n      my_xasprintf (\"%.50a %d\", 1.75, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"0x1.c0000000000000000000000000000000000000000000000000p+0 33\") == 0\n            || strcmp (result, \"0x3.80000000000000000000000000000000000000000000000000p-1 33\") == 0\n            || strcmp (result, \"0x7.00000000000000000000000000000000000000000000000000p-2 33\") == 0\n            || strcmp (result, \"0xe.00000000000000000000000000000000000000000000000000p-3 33\") == 0);\n    free (result);\n  }\n\n  { /* A positive number.  */\n    char *result =\n      my_xasprintf (\"%La %d\", 3.1416015625L, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"0x1.922p+1 33\") == 0\n            || strcmp (result, \"0x3.244p+0 33\") == 0\n            || strcmp (result, \"0x6.488p-1 33\") == 0\n            || strcmp (result, \"0xc.91p-2 33\") == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    char *result =\n      my_xasprintf (\"%10La %d\", 1.75L, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"  0x1.cp+0 33\") == 0\n            || strcmp (result, \"  0x3.8p-1 33\") == 0\n            || strcmp (result, \"    0x7p-2 33\") == 0\n            || strcmp (result, \"    0xep-3 33\") == 0);\n    free (result);\n  }\n\n  { /* Small precision.  */\n    char *result =\n      my_xasprintf (\"%.10La %d\", 1.75L, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"0x1.c000000000p+0 33\") == 0\n            || strcmp (result, \"0x3.8000000000p-1 33\") == 0\n            || strcmp (result, \"0x7.0000000000p-2 33\") == 0\n            || strcmp (result, \"0xe.0000000000p-3 33\") == 0);\n    free (result);\n  }\n\n  { /* Large precision.  */\n    char *result =\n      my_xasprintf (\"%.50La %d\", 1.75L, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"0x1.c0000000000000000000000000000000000000000000000000p+0 33\") == 0\n            || strcmp (result, \"0x3.80000000000000000000000000000000000000000000000000p-1 33\") == 0\n            || strcmp (result, \"0x7.00000000000000000000000000000000000000000000000000p-2 33\") == 0\n            || strcmp (result, \"0xe.00000000000000000000000000000000000000000000000000p-3 33\") == 0);\n    free (result);\n  }\n\n  /* Test the support of the %f format directive.  */\n\n  { /* A positive number.  */\n    char *result =\n      my_xasprintf (\"%f %d\", 12.75, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"12.750000 33\") == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    char *result =\n      my_xasprintf (\"%10f %d\", 1.75, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"  1.750000 33\") == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    char *result =\n      my_xasprintf (\"%.f %d\", 1234.0, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"1234 33\") == 0);\n    free (result);\n  }\n\n  { /* A positive number.  */\n    char *result =\n      my_xasprintf (\"%Lf %d\", 12.75L, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"12.750000 33\") == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    char *result =\n      my_xasprintf (\"%10Lf %d\", 1.75L, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"  1.750000 33\") == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    char *result =\n      my_xasprintf (\"%.Lf %d\", 1234.0L, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"1234 33\") == 0);\n    free (result);\n  }\n\n  /* Test the support of the %F format directive.  */\n\n  { /* A positive number.  */\n    char *result =\n      my_xasprintf (\"%F %d\", 12.75, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"12.750000 33\") == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    char *result =\n      my_xasprintf (\"%.F %d\", 1234.0, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"1234 33\") == 0);\n    free (result);\n  }\n\n  { /* A positive number.  */\n    char *result =\n      my_xasprintf (\"%LF %d\", 12.75L, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"12.750000 33\") == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    char *result =\n      my_xasprintf (\"%.LF %d\", 1234.0L, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"1234 33\") == 0);\n    free (result);\n  }\n\n  /* Test the support of the %e format directive.  */\n\n  { /* A positive number.  */\n    char *result =\n      my_xasprintf (\"%e %d\", 12.75, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"1.275000e+01 33\") == 0\n            || strcmp (result, \"1.275000e+001 33\") == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    char *result =\n      my_xasprintf (\"%15e %d\", 1.75, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"   1.750000e+00 33\") == 0\n            || strcmp (result, \"  1.750000e+000 33\") == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    char *result =\n      my_xasprintf (\"%.e %d\", 1234.0, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"1e+03 33\") == 0\n            || strcmp (result, \"1e+003 33\") == 0);\n    free (result);\n  }\n\n  { /* A positive number.  */\n    char *result =\n      my_xasprintf (\"%Le %d\", 12.75L, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"1.275000e+01 33\") == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    char *result =\n      my_xasprintf (\"%15Le %d\", 1.75L, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"   1.750000e+00 33\") == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    char *result =\n      my_xasprintf (\"%.Le %d\", 1234.0L, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"1e+03 33\") == 0);\n    free (result);\n  }\n\n  /* Test the support of the %g format directive.  */\n\n  { /* A positive number.  */\n    char *result =\n      my_xasprintf (\"%g %d\", 12.75, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"12.75 33\") == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    char *result =\n      my_xasprintf (\"%10g %d\", 1.75, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"      1.75 33\") == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    char *result =\n      my_xasprintf (\"%.g %d\", 1234.0, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"1e+03 33\") == 0\n            || strcmp (result, \"1e+003 33\") == 0);\n    free (result);\n  }\n\n  { /* A positive number.  */\n    char *result =\n      my_xasprintf (\"%Lg %d\", 12.75L, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"12.75 33\") == 0);\n    free (result);\n  }\n\n  { /* Width.  */\n    char *result =\n      my_xasprintf (\"%10Lg %d\", 1.75L, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"      1.75 33\") == 0);\n    free (result);\n  }\n\n  { /* Precision.  */\n    char *result =\n      my_xasprintf (\"%.Lg %d\", 1234.0L, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"1e+03 33\") == 0);\n    free (result);\n  }\n\n  /* Test the support of the %n format directive.  */\n\n  {\n    int count = -1;\n    char *result =\n      my_xasprintf (\"%d %n\", 123, &count, 33, 44, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"123 \") == 0);\n    ASSERT (count == 4);\n    free (result);\n  }\n\n  /* Test the support of the POSIX/XSI format strings with positions.  */\n\n  {\n    char *result =\n      my_xasprintf (\"%2$d %1$d\", 33, 55);\n    ASSERT (result != NULL);\n    ASSERT (strcmp (result, \"55 33\") == 0);\n    free (result);\n  }\n\n  /* Test the support of the grouping flag.  */\n\n  {\n    char *result =\n      my_xasprintf (\"%'d %d\", 1234567, 99);\n    ASSERT (result != NULL);\n    ASSERT (result[strlen (result) - 1] == '9');\n    free (result);\n  }\n}",
      "lines": 480,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-ulc-vasnprintf1.c": {
    "my_asnprintf": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "static char *\nmy_asnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)\n{\n  va_list args;\n  char *ret;\n\n  va_start (args, format);\n  ret = ulc_vasnprintf (resultbuf, lengthp, format, args);\n  va_end (args);\n  return ret;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nmy_asnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)",
        "*"
      ]
    },
    "my_xasprintf": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static char *\nmy_xasprintf (const char *format, ...)\n{\n  va_list args;\n  size_t length;\n  char *ret;\n\n  va_start (args, format);\n  ret = ulc_vasnprintf (NULL, &length, format, args);\n  va_end (args);\n  if (ret != NULL)\n    ASSERT (length == strlen (ret));\n  return ret;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nmy_xasprintf (const char *format, ...)",
        "*"
      ]
    },
    "test_vasnprintf": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static void\ntest_vasnprintf ()\n{\n  test_function (my_asnprintf);\n  test_xfunction (my_xasprintf);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  test_vasnprintf ();\n  return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-ulc-vasnprintf2.c": {
    "test_function": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        216,
        1
      ],
      "content": "static void\ntest_function (char * (*my_asnprintf) (char *, size_t *, const char *, ...))\n{\n  /* Test the support of the 'U' conversion specifier for Unicode strings.  */\n\n  {\n    static const uint8_t unicode_string[] = \"Rafa\\305\\202 Maszkowski\"; /* Rafa\u00c5\u0082 Maszkowski */\n    {\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%U %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"Rafa? Maszkowski 33\") == 0\n              || strcmp (result, \"Rafal Maszkowski 33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n    { /* Width.  */\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%20U %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"    Rafa? Maszkowski 33\") == 0\n              || strcmp (result, \"    Rafal Maszkowski 33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%-20U %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"Rafa? Maszkowski     33\") == 0\n              || strcmp (result, \"Rafal Maszkowski     33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%020U %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"    Rafa? Maszkowski 33\") == 0\n              || strcmp (result, \"    Rafal Maszkowski 33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n  }\n\n  {\n    static const uint16_t unicode_string[] = /* Rafa\u00c5\u0082 Maszkowski */\n      {\n        'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z', 'k', 'o', 'w',\n        's', 'k', 'i', 0\n      };\n    {\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%lU %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"Rafa? Maszkowski 33\") == 0\n              || strcmp (result, \"Rafal Maszkowski 33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n    { /* Width.  */\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%20lU %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"    Rafa? Maszkowski 33\") == 0\n              || strcmp (result, \"    Rafal Maszkowski 33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%-20lU %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"Rafa? Maszkowski     33\") == 0\n              || strcmp (result, \"Rafal Maszkowski     33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%020lU %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"    Rafa? Maszkowski 33\") == 0\n              || strcmp (result, \"    Rafal Maszkowski 33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n  }\n\n  {\n    static const uint32_t unicode_string[] = /* Rafa\u00c5\u0082 Maszkowski */\n      {\n        'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z', 'k', 'o', 'w',\n        's', 'k', 'i', 0\n      };\n    {\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%llU %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"Rafa? Maszkowski 33\") == 0\n              || strcmp (result, \"Rafal Maszkowski 33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n    { /* Width.  */\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%20llU %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"    Rafa? Maszkowski 33\") == 0\n              || strcmp (result, \"    Rafal Maszkowski 33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%-20llU %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"Rafa? Maszkowski     33\") == 0\n              || strcmp (result, \"Rafal Maszkowski     33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%020llU %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"    Rafa? Maszkowski 33\") == 0\n              || strcmp (result, \"    Rafal Maszkowski 33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n  }\n\n  /* Test the support of the 's' conversion specifier for strings.  */\n\n  {\n    const char *locale_string = \"\\304rger\"; /* \u00c3\u0084rger */\n    {\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%s %d\", locale_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"\\304rger 33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n    { /* Width.  */\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%10s %d\", locale_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"     \\304rger 33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%-10s %d\", locale_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"\\304rger      33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%010s %d\", locale_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"     \\304rger 33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n  }\n}",
      "lines": 187,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "my_asnprintf": {
      "start_point": [
        218,
        0
      ],
      "end_point": [
        228,
        1
      ],
      "content": "static char *\nmy_asnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)\n{\n  va_list args;\n  char *ret;\n\n  va_start (args, format);\n  ret = ulc_vasnprintf (resultbuf, lengthp, format, args);\n  va_end (args);\n  return ret;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nmy_asnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)",
        "*"
      ]
    },
    "test_vasnprintf": {
      "start_point": [
        230,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "static void\ntest_vasnprintf ()\n{\n  test_function (my_asnprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        245,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  test_vasnprintf ();\n  return 0;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-ulc-vasnprintf3.c": {
    "test_function": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "static void\ntest_function (char * (*my_asnprintf) (char *, size_t *, const char *, ...))\n{\n  /* Test the support of the 'U' conversion specifier for Unicode strings.  */\n\n  {\n    static const uint8_t unicode_string[] = \"Rafa\\305\\202 Maszkowski\"; /* Rafa\u00c5\u0082 Maszkowski */\n    {\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%U %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"Rafa\\305\\202 Maszkowski 33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n    { /* Width.  */\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%20U %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"    Rafa\\305\\202 Maszkowski 33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%-20U %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"Rafa\\305\\202 Maszkowski     33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%020U %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"    Rafa\\305\\202 Maszkowski 33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n  }\n\n  {\n    static const uint16_t unicode_string[] = /* Rafa\u00c5\u0082 Maszkowski */\n      {\n        'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z', 'k', 'o', 'w',\n        's', 'k', 'i', 0\n      };\n    {\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%lU %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"Rafa\\305\\202 Maszkowski 33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n    { /* Width.  */\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%20lU %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"    Rafa\\305\\202 Maszkowski 33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%-20lU %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"Rafa\\305\\202 Maszkowski     33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%020lU %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"    Rafa\\305\\202 Maszkowski 33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n  }\n\n  {\n    static const uint32_t unicode_string[] = /* Rafa\u00c5\u0082 Maszkowski */\n      {\n        'R', 'a', 'f', 'a', 0x0142, ' ', 'M', 'a', 's', 'z', 'k', 'o', 'w',\n        's', 'k', 'i', 0\n      };\n    {\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%llU %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"Rafa\\305\\202 Maszkowski 33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n    { /* Width.  */\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%20llU %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"    Rafa\\305\\202 Maszkowski 33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%-20llU %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"Rafa\\305\\202 Maszkowski     33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%020llU %d\", unicode_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"    Rafa\\305\\202 Maszkowski 33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n  }\n\n  /* Test the support of the 's' conversion specifier for strings.  */\n\n  {\n    const char *locale_string = \"\\303\\204rger\"; /* \u00c3\u0084rger */\n    {\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%s %d\", locale_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"\\303\\204rger 33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n    { /* Width.  */\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%10s %d\", locale_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"     \\303\\204rger 33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n    { /* FLAG_LEFT.  */\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%-10s %d\", locale_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"\\303\\204rger      33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n    { /* FLAG_ZERO: no effect.  */\n      size_t length;\n      char *result =\n        my_asnprintf (NULL, &length, \"%010s %d\", locale_string, 33, 44, 55);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"     \\303\\204rger 33\") == 0);\n      ASSERT (length == strlen (result));\n      free (result);\n    }\n  }\n}",
      "lines": 175,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "my_asnprintf": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        216,
        1
      ],
      "content": "static char *\nmy_asnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)\n{\n  va_list args;\n  char *ret;\n\n  va_start (args, format);\n  ret = ulc_vasnprintf (resultbuf, lengthp, format, args);\n  va_end (args);\n  return ret;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nmy_asnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)",
        "*"
      ]
    },
    "test_vasnprintf": {
      "start_point": [
        218,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "static void\ntest_vasnprintf ()\n{\n  test_function (my_asnprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        224,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  test_vasnprintf ();\n  return 0;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-ulc-vasprintf1.c": {
    "my_xasprintf": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "static char *\nmy_xasprintf (const char *format, ...)\n{\n  va_list args;\n  char *result;\n  int retval;\n\n  va_start (args, format);\n  retval = ulc_vasprintf (&result, format, args);\n  va_end (args);\n  if (retval < 0)\n    return NULL;\n  ASSERT (result != NULL);\n  return result;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nmy_xasprintf (const char *format, ...)",
        "*"
      ]
    },
    "test_vasprintf": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static void\ntest_vasprintf ()\n{\n  test_xfunction (my_xasprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  test_vasprintf ();\n  return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-ulc-vsnprintf1.c": {
    "my_xasprintf": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "static char *\nmy_xasprintf (const char *format, ...)\n{\n  va_list args;\n  char result[1000];\n  int retval;\n\n  va_start (args, format);\n  retval = ulc_vsnprintf (result, sizeof (result), format, args);\n  va_end (args);\n  if (retval < 0 || retval >= (int) sizeof (result))\n    return NULL;\n  return xstrdup (result);\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nmy_xasprintf (const char *format, ...)",
        "*"
      ]
    },
    "test_vsnprintf": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static void\ntest_vsnprintf ()\n{\n  test_xfunction (my_xasprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  test_vsnprintf ();\n\n  return 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistdio/test-ulc-vsprintf1.c": {
    "my_xasprintf": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "static char *\nmy_xasprintf (const char *format, ...)\n{\n  va_list args;\n  char result[1000];\n  int retval;\n\n  va_start (args, format);\n  retval = ulc_vsprintf (result, format, args);\n  va_end (args);\n  if (retval < 0 || retval >= (int) sizeof (result))\n    return NULL;\n  return xstrdup (result);\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nmy_xasprintf (const char *format, ...)",
        "*"
      ]
    },
    "test_vsprintf": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static void\ntest_vsprintf ()\n{\n  test_xfunction (my_xasprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  test_vsprintf ();\n\n  return 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-chr.h": {
    "main": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "int\nmain (void)\n{\n  size_t size = 0x100000;\n  size_t i;\n  size_t length;\n  UNIT *input;\n  uint32_t *input32 = (uint32_t *) malloc (size * sizeof (uint32_t));\n  ASSERT (input32);\n\n  input32[0] = 'a';\n  input32[1] = 'b';\n  u32_set (input32 + 2, 'c', 1024);\n  for (i = 1026; i < size - 2; i += 63)\n    {\n      size_t last = i + 63 < size - 2 ? i + 63 : size - 2;\n      ucs4_t uc = 'd' | (i - 1026);\n      if (uc >= 0xd800 && uc <= 0xdfff)\n        uc |= 0x100000;\n      u32_set (input32 + i, uc, last - i);\n    }\n\n  input32[size - 2] = 'e';\n  input32[size - 1] = 'a';\n\n  input = U32_TO_U (input32, size, NULL, &length);\n  ASSERT (input);\n\n  /* Basic behavior tests.  */\n  ASSERT (U_CHR (input, length, 'a') == input);\n\n  ASSERT (U_CHR (input, 0, 'a') == NULL);\n  ASSERT (U_CHR (zerosize_ptr (), 0, 'a') == NULL);\n\n  ASSERT (U_CHR (input, length, 'b') == input + 1);\n  ASSERT (U_CHR (input, length, 'c') == input + 2);\n  ASSERT (U_CHR (input, length, 'd') == input + 1026);\n\n  {\n    UNIT *exp = input + 1026;\n    UNIT *prev = input + 1;\n    for (i = 1026; i < size - 2; i += 63)\n      {\n        UNIT c[6];\n        size_t n;\n        ucs4_t uc = 'd' | (i - 1026);\n        if (uc >= 0xd800 && uc <= 0xdfff)\n          uc |= 0x100000;\n        n = U_UCTOMB (c, uc, 6);\n        ASSERT (exp < input + length - 1);\n        ASSERT (U_CHR (prev, (length - 1) - (prev - input), uc) == exp);\n        ASSERT (memcmp (exp, c, n * sizeof (UNIT)) == 0);\n        prev = exp;\n        exp += n * 63;\n      }\n  }\n\n  ASSERT (U_CHR (input + 1, length - 1, 'a') == input + length - 1);\n  ASSERT (U_CHR (input + 1, length - 1, 'e') == input + length - 2);\n\n  ASSERT (U_CHR (input, length, 'f') == NULL);\n  ASSERT (U_CHR (input, length, '\\0') == NULL);\n\n  /* Check that a very long haystack is handled quickly if the byte is\n     found near the beginning.  */\n  {\n    size_t repeat = 10000;\n    for (; repeat > 0; repeat--)\n      {\n        ASSERT (U_CHR (input, length, 'c') == input + 2);\n      }\n  }\n\n  /* Alignment tests.  */\n  {\n    int i, j;\n    for (i = 0; i < 32; i++)\n      {\n        for (j = 0; j < 128; j++)\n          input[i + j] = j;\n        for (j = 0; j < 128; j++)\n          {\n            ASSERT (U_CHR (input + i, 128, j) == input + i + j);\n          }\n      }\n  }\n\n  /* Check that uN_chr() does not read past the first occurrence of the\n     byte being searched.  */\n  {\n    char *page_boundary = (char *) zerosize_ptr ();\n    size_t n;\n\n    if (page_boundary != NULL)\n      {\n        for (n = 1; n <= 500 / sizeof (UNIT); n++)\n          {\n            UNIT *mem = (UNIT *) (page_boundary - n * sizeof (UNIT));\n            U_SET (mem, 'X', n);\n            ASSERT (U_CHR (mem, n, 'U') == NULL);\n\n            {\n              size_t i;\n\n              for (i = 0; i < n; i++)\n                {\n                  mem[i] = 'U';\n                  ASSERT (U_CHR (mem, 4000, 'U') == mem + i);\n                  mem[i] = 'X';\n                }\n            }\n          }\n      }\n  }\n\n  free (input);\n\n  return 0;\n}",
      "lines": 119,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-cmp.h": {
    "test_cmp": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "static void\ntest_cmp (void)\n{\n  /* Test equal / not equal distinction.  */\n  ASSERT (U_CMP (zerosize_ptr (), zerosize_ptr (), 0) == 0);\n  {\n    static const UNIT input1[] = { 'f', 'o', 'o', 0 };\n    static const UNIT input2[] = { 'f', 'o', 'o', 'b', 'a', 'r', 0 };\n    ASSERT (U_CMP (input1, input2, 2) == 0);\n    ASSERT (U_CMP (input1, input2, 3) == 0);\n    ASSERT (U_CMP (input1, input2, 4) != 0);\n  }\n  {\n    static const UNIT input1[] = { 'f', 'o', 'o', 0 };\n    static const UNIT input2[] = { 'b', 'a', 'r', 0 };\n    ASSERT (U_CMP (input1, input2, 1) != 0);\n    ASSERT (U_CMP (input1, input2, 3) != 0);\n  }\n\n  /* Test less / equal / greater distinction.  */\n  {\n    static const UNIT input1[] = { 'f', 'o', 'o', 0 };\n    static const UNIT input2[] = { 'm', 'o', 'o', 0 };\n    ASSERT (U_CMP (input1, input2, 4) < 0);\n    ASSERT (U_CMP (input2, input1, 4) > 0);\n  }\n  {\n    static const UNIT input1[] = { 'o', 'o', 'm', 'p', 'h', 0 };\n    static const UNIT input2[] = { 'o', 'o', 'p', 's', 0 };\n    ASSERT (U_CMP (input1, input2, 3) < 0);\n    ASSERT (U_CMP (input2, input1, 3) > 0);\n  }\n  {\n    static const UNIT input1[] = { 'f', 'o', 'o', 0 };\n    static const UNIT input2[] = { 'f', 'o', 'o', 'b', 'a', 'r', 0 };\n    ASSERT (U_CMP (input1, input2, 4) < 0);\n    ASSERT (U_CMP (input2, input1, 4) > 0);\n  }\n\n  /* Some old versions of memcmp were not 8-bit clean.  */\n  {\n    static const UNIT input1[] = { 0x40 };\n    static const UNIT input2[] = { 0xC2 };\n    ASSERT (U_CMP (input1, input2, 1) < 0);\n    ASSERT (U_CMP (input2, input1, 1) > 0);\n  }\n  {\n    static const UNIT input1[] = { 0xC2 };\n    static const UNIT input2[] = { 0xC3 };\n    ASSERT (U_CMP (input1, input2, 1) < 0);\n    ASSERT (U_CMP (input2, input1, 1) > 0);\n  }\n\n  /* The Next x86 OpenStep bug shows up only when comparing 16 bytes\n     or more and with at least one buffer not starting on a 4-byte boundary.\n     William Lewis provided this test program.   */\n  {\n    UNIT foo[21];\n    UNIT bar[21];\n    int i;\n    for (i = 0; i < 4; i++)\n      {\n        UNIT *a = foo + i;\n        UNIT *b = bar + i;\n        int j;\n        for (j = 0; j < 8; j++)\n          a[j] = '-';\n        a[8] = '0';\n        for (j = 9; j < 16; j++)\n          a[j] = '1';\n        for (j = 0; j < 8; j++)\n          b[j] = '-';\n        b[8] = '1';\n        for (j = 9; j < 16; j++)\n          b[j] = '0';\n        ASSERT (U_CMP (a, b, 16) < 0);\n      }\n  }\n}",
      "lines": 79,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-cmp2.h": {
    "main": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nmain ()\n{\n  {\n    static const UNIT input1[] = { 'a' };\n    static const UNIT input2[] = { 'b' };\n    ASSERT (U_CMP2 (input1, 0, input2, 0) == 0);\n    ASSERT (U_CMP2 (input1, 1, input2, 0) > 0);\n    ASSERT (U_CMP2 (input1, 0, input2, 1) < 0);\n  }\n  {\n    static const UNIT input1[] = { 'f', 'o', 'o', 0 };\n    static const UNIT input2[] = { 'f', 'o', 'o', 'b', 'a', 'r', 0 };\n    ASSERT (U_CMP2 (input1, 3, input2, 3) == 0);\n    ASSERT (U_CMP2 (input1, 4, input2, 3) > 0);\n    ASSERT (U_CMP2 (input2, 3, input1, 4) < 0);\n    ASSERT (U_CMP2 (input1, 3, input2, 4) < 0);\n    ASSERT (U_CMP2 (input2, 4, input1, 3) > 0);\n    ASSERT (U_CMP2 (input1, 4, input2, 4) < 0);\n    ASSERT (U_CMP2 (input2, 4, input1, 4) > 0);\n    ASSERT (U_CMP2 (input1, 3, input2, 7) < 0);\n    ASSERT (U_CMP2 (input2, 7, input1, 3) > 0);\n  }\n  {\n    static const UNIT input1[] = { 'f', 'o', 'o' };\n    static const UNIT input2[] = { 'm', 'o', 'o' };\n    ASSERT (U_CMP2 (input1, 3, input2, 3) < 0);\n    ASSERT (U_CMP2 (input2, 3, input1, 3) > 0);\n  }\n  {\n    static const UNIT input1[] = { 'o', 'o', 'm', 'p', 'h' };\n    static const UNIT input2[] = { 'o', 'o', 'p', 's' };\n    ASSERT (U_CMP2 (input1, 5, input2, 4) < 0);\n    ASSERT (U_CMP2 (input2, 4, input1, 5) > 0);\n  }\n\n  return 0;\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-cpy-alloc.h": {
    "main": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Test small copying operations.  */\n  {\n    static const UNIT src[] = { 'c', 'l', 'i', 'm', 'a', 't', 'e' };\n    size_t n;\n\n    for (n = 0; n <= SIZEOF (src); n++)\n      {\n        UNIT *result = U_CPY_ALLOC (src, n);\n        size_t i;\n\n        ASSERT (result != NULL);\n        for (i = 0; i < n; i++)\n          ASSERT (result[i] == src[i]);\n\n        free (result);\n      }\n  }\n\n  return 0;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-cpy.h": {
    "main": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Test small copying operations.  */\n  {\n    static const UNIT src[] = { 'c', 'l', 'i', 'm', 'a', 't', 'e' };\n    size_t n;\n\n    for (n = 0; n <= SIZEOF (src); n++)\n      {\n        UNIT dest[1 + SIZEOF (src) + 1] =\n          { MAGIC, MAGIC, MAGIC, MAGIC, MAGIC, MAGIC, MAGIC, MAGIC, MAGIC };\n        UNIT *ret;\n        size_t i;\n\n        ret = U_CPY (dest + 1, src, n);\n        ASSERT (ret == dest + 1);\n        ASSERT (dest[0] == MAGIC);\n        for (i = 0; i < n; i++)\n          ASSERT (dest[1 + i] == src[i]);\n        ASSERT (dest[1 + n] == MAGIC);\n      }\n  }\n\n  return 0;\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-move.h": {
    "main": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Test copying operations with disjoint source and destination.  */\n  {\n    static const UNIT src[] = { 'c', 'l', 'i', 'm', 'a', 't', 'e' };\n    size_t n;\n\n    for (n = 0; n <= SIZEOF (src); n++)\n      {\n        UNIT dest[1 + SIZEOF (src) + 1] =\n          { MAGIC, MAGIC, MAGIC, MAGIC, MAGIC, MAGIC, MAGIC, MAGIC, MAGIC };\n        UNIT *ret;\n        size_t i;\n\n        ret = U_MOVE (dest + 1, src, n);\n        ASSERT (ret == dest + 1);\n        ASSERT (dest[0] == MAGIC);\n        for (i = 0; i < n; i++)\n          ASSERT (dest[1 + i] == src[i]);\n        ASSERT (dest[1 + n] == MAGIC);\n      }\n  }\n\n  /* Test copying operations with overlap, in-place.  */\n  {\n    static const UNIT src[] = { 'c', 'l', 'i', 'm', 'a', 't', 'e' };\n    size_t n;\n\n    for (n = 0; n <= SIZEOF (src); n++)\n      {\n        UNIT dest[1 + SIZEOF (src) + 1];\n        UNIT *ret;\n        size_t i;\n\n        dest[0] = MAGIC;\n        for (i = 0; i < n; i++)\n          dest[1 + i] = src[i];\n        dest[1 + n] = MAGIC;\n\n        ret = U_MOVE (dest + 1, dest + 1, n);\n        ASSERT (ret == dest + 1);\n        ASSERT (dest[0] == MAGIC);\n        for (i = 0; i < n; i++)\n          ASSERT (dest[1 + i] == src[i]);\n        ASSERT (dest[1 + n] == MAGIC);\n      }\n  }\n\n  /* Test copying operations with overlap, moving downward.  */\n  {\n    static const UNIT src[] = { 'c', 'l', 'i', 'm', 'a', 't', 'e' };\n    static const UNIT src2[] = { 'C', 'L', 'I', 'M', 'A', 'T', 'E' };\n    size_t d;\n\n    ASSERT (SIZEOF (src) == SIZEOF (src2));\n    for (d = 0; d <= SIZEOF (src); d++)\n      {\n        size_t n;\n\n        for (n = 0; n <= SIZEOF (src); n++)\n          {\n            UNIT dest[1 + 2 * SIZEOF (src) + 1];\n            UNIT *ret;\n            size_t i;\n\n            dest[0] = MAGIC;\n            for (i = 0; i < SIZEOF (src2); i++)\n              dest[1 + i] = src2[i];\n            for (i = 0; i < SIZEOF (src); i++)\n              dest[1 + SIZEOF (src) + i] = src[i];\n            dest[1 + 2 * SIZEOF (src)] = MAGIC;\n\n            ret =\n              U_MOVE (dest + 1 + SIZEOF (src) - d, dest + 1 + SIZEOF (src), n);\n            ASSERT (ret == dest + 1 + SIZEOF (src) - d);\n            ASSERT (dest[0] == MAGIC);\n            for (i = 0; i < SIZEOF (src) - d; i++)\n              ASSERT (dest[1 + i] == src2[i]);\n            for (i = 0; i < n; i++)\n              ASSERT (dest[1 + SIZEOF (src) - d + i] == src[i]);\n            for (i = SIZEOF (src) - d + n; i < SIZEOF (src2); i++)\n              ASSERT (dest[1 + i] == src2[i]);\n            for (i = (n >= d ? n - d : 0); i < SIZEOF (src); i++)\n              ASSERT (dest[1 + SIZEOF (src) + i] == src[i]);\n            ASSERT (dest[1 + 2 * SIZEOF (src)] == MAGIC);\n          }\n      }\n  }\n\n  /* Test copying operations with overlap, moving upward.  */\n  {\n    static const UNIT src[] = { 'c', 'l', 'i', 'm', 'a', 't', 'e' };\n    static const UNIT src2[] = { 'C', 'L', 'I', 'M', 'A', 'T', 'E' };\n    size_t d;\n\n    ASSERT (SIZEOF (src) == SIZEOF (src2));\n    for (d = 0; d <= SIZEOF (src); d++)\n      {\n        size_t n;\n\n        for (n = 0; n <= SIZEOF (src); n++)\n          {\n            UNIT dest[1 + 2 * SIZEOF (src) + 1];\n            UNIT *ret;\n            size_t i;\n\n            dest[0] = MAGIC;\n            for (i = 0; i < SIZEOF (src); i++)\n              dest[1 + i] = src[i];\n            for (i = 0; i < SIZEOF (src2); i++)\n              dest[1 + SIZEOF (src) + i] = src2[i];\n            dest[1 + 2 * SIZEOF (src)] = MAGIC;\n\n            ret = U_MOVE (dest + 1 + d, dest + 1, n);\n            ASSERT (ret == dest + 1 + d);\n            ASSERT (dest[0] == MAGIC);\n            for (i = 0; i < d; i++)\n              ASSERT (dest[1 + i] == src[i]);\n            for (i = 0; i < n; i++)\n              ASSERT (dest[1 + d + i] == src[i]);\n            for (i = d + n; i < SIZEOF (src); i++)\n              ASSERT (dest[1 + i] == src[i]);\n            for (i = (d + n >= SIZEOF (src) ? d + n - SIZEOF (src) : 0);\n                 i < SIZEOF (src2);\n                 i++)\n              ASSERT (dest[1 + SIZEOF (src) + i] == src2[i]);\n            ASSERT (dest[1 + 2 * SIZEOF (src)] == MAGIC);\n          }\n      }\n  }\n\n  return 0;\n}",
      "lines": 134,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-set.h": {
    "main": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nmain ()\n{\n  {\n#define NMAX 7\n    size_t n;\n\n    for (n = 0; n <= NMAX; n++)\n      {\n        UNIT dest[1 + NMAX + 1] =\n          { MAGIC, MAGIC, MAGIC, MAGIC, MAGIC, MAGIC, MAGIC, MAGIC, MAGIC };\n        UNIT *ret;\n        size_t i;\n\n        ret = U_SET (dest + 1, VALUE, n);\n        ASSERT (ret == dest + 1);\n        ASSERT (dest[0] == MAGIC);\n        for (i = 0; i < n; i++)\n          ASSERT (dest[1 + i] == VALUE);\n        ASSERT (dest[1 + n] == MAGIC);\n      }\n#undef NMAX\n  }\n\n  return 0;\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-stpcpy.h": {
    "main": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Test small copying operations.  */\n  {\n    static const UNIT src[] = { 'c', 'l', 'i', 'm', 'a', 't', 'e', 0 };\n    size_t n;\n\n    for (n = 1; n <= SIZEOF (src); n++)\n      {\n        UNIT dest[1 + SIZEOF (src) + 1] =\n          { MAGIC, MAGIC, MAGIC, MAGIC, MAGIC, MAGIC, MAGIC, MAGIC, MAGIC,\n            MAGIC\n          };\n        UNIT *result;\n        size_t i;\n\n        result = U_STPCPY (dest + 1, src + SIZEOF (src) - n);\n        ASSERT (result == dest + n);\n\n        ASSERT (dest[0] == MAGIC);\n        for (i = 0; i < n; i++)\n          ASSERT (dest[1 + i] == src[SIZEOF (src) - n + i]);\n        ASSERT (dest[1 + n] == MAGIC);\n      }\n  }\n\n  return 0;\n}",
      "lines": 29,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-stpncpy.h": {
    "check_single": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "static void\ncheck_single (const UNIT *input, size_t length, size_t n)\n{\n  UNIT *dest;\n  UNIT *result;\n  size_t i;\n\n  dest = (UNIT *) malloc ((1 + n + 1) * sizeof (UNIT));\n  ASSERT (dest != NULL);\n\n  for (i = 0; i < 1 + n + 1; i++)\n    dest[i] = MAGIC;\n\n  result = U_STPNCPY (dest + 1, input, n);\n  ASSERT (result == dest + 1 + (n <= length ? n : length));\n\n  ASSERT (dest[0] == MAGIC);\n  for (i = 0; i < (n <= length ? n : length + 1); i++)\n    ASSERT (dest[1 + i] == input[i]);\n  for (; i < n; i++)\n    ASSERT (dest[1 + i] == 0);\n  ASSERT (dest[1 + n] == MAGIC);\n\n  free (dest);\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static void\ncheck (const UNIT *input, size_t input_length)\n{\n  size_t length;\n  size_t n;\n\n  ASSERT (input_length > 0);\n  ASSERT (input[input_length - 1] == 0);\n  length = input_length - 1; /* = U_STRLEN (input) */\n\n  for (n = 0; n <= 2 * length + 2; n++)\n    check_single (input, length, n);\n\n  /* Check that U_STPNCPY (D, S, N) does not look at more than\n     MIN (U_STRLEN (S) + 1, N) units.  */\n  {\n    char *page_boundary = (char *) zerosize_ptr ();\n\n    if (page_boundary != NULL)\n      {\n        for (n = 0; n <= 2 * length + 2; n++)\n          {\n            size_t n_to_copy = (n <= length ? n : length + 1);\n            UNIT *copy;\n            size_t i;\n\n            copy = (UNIT *) page_boundary - n_to_copy;\n            for (i = 0; i < n_to_copy; i++)\n              copy[i] = input[i];\n\n            check_single (copy, length, n);\n          }\n      }\n  }\n}",
      "lines": 35,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-strcat.h": {
    "main": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Test small copying operations.  */\n  {\n    static const UNIT base[] = { 'C', 'h', 'a', 'n', 'g', 'i', 'n', 'g', 0 };\n    static const UNIT src[] = { 'c', 'l', 'i', 'm', 'a', 't', 'e', 0 };\n    size_t m;\n    size_t n;\n\n    for (m = 0; m < SIZEOF (base); m++)\n      for (n = 1; n <= SIZEOF (src); n++)\n        {\n          UNIT dest[1 + (SIZEOF (base) - 1) + SIZEOF (src) + 1] =\n            { MAGIC, MAGIC, MAGIC, MAGIC, MAGIC, MAGIC, MAGIC, MAGIC, MAGIC,\n              MAGIC, MAGIC, MAGIC, MAGIC, MAGIC, MAGIC, MAGIC, MAGIC, MAGIC\n            };\n          UNIT *result;\n          size_t i;\n\n          for (i = 0; i < m; i++)\n            dest[1 + i] = base[i];\n          dest[1 + m] = 0;\n\n          result = U_STRCAT (dest + 1, src + SIZEOF (src) - n);\n          ASSERT (result == dest + 1);\n\n          ASSERT (dest[0] == MAGIC);\n          for (i = 0; i < m; i++)\n            ASSERT (dest[1 + i] == base[i]);\n          for (i = 0; i < n; i++)\n            ASSERT (dest[1 + m + i] == src[SIZEOF (src) - n + i]);\n          ASSERT (dest[1 + m + n] == MAGIC);\n        }\n  }\n\n  return 0;\n}",
      "lines": 38,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-strchr.h": {
    "test_strchr": {
      "start_point": [
        19,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "static void\ntest_strchr (void)\n{\n  size_t size = 0x100000;\n  size_t length;\n  size_t i;\n  UNIT *input;\n  uint32_t *input32 = (uint32_t *) malloc ((size + 1) * sizeof (uint32_t));\n  ASSERT (input32);\n\n  input32[0] = 'a';\n  input32[1] = 'b';\n  u32_set (input32 + 2, 'c', 1024);\n  for (i = 1026; i < size - 2; i += 63)\n    {\n      size_t last = i + 63 < size - 2 ? i + 63 : size - 2;\n      ucs4_t uc = 'd' | (i - 1026);\n      if (uc >= 0xd800 && uc <= 0xdfff)\n        uc |= 0x100000;\n      u32_set (input32 + i, uc, last - i);\n    }\n  input32[size - 2] = 'e';\n  input32[size - 1] = 'a';\n  input32[size] = 0;\n\n  input = U32_TO_U (input32, size + 1, NULL, &length);\n  ASSERT (input);\n\n  /* Basic behavior tests.  */\n  ASSERT (U_STRCHR (input, 'a') == input);\n  ASSERT (U_STRCHR (input, 'b') == input + 1);\n  ASSERT (U_STRCHR (input, 'c') == input + 2);\n\n  {\n    UNIT *exp = input + 1026;\n    UNIT *prev = input + 2;\n\n    for (i = 1026; i < size - 2; i += 63)\n      {\n        UNIT c[6];\n        size_t n;\n        ucs4_t uc = 'd' | (i - 1026);\n        if (uc >= 0xd800 && uc <= 0xdfff)\n          uc |= 0x100000;\n        n = U_UCTOMB (c, uc, 6);\n        ASSERT (exp < input + length - 2);\n        ASSERT (U_STRCHR (prev, uc) == exp);\n        ASSERT (memcmp (exp, c, n * sizeof (UNIT)) == 0);\n        prev = exp;\n        exp += n * 63;\n      }\n  }\n\n  ASSERT (U_STRCHR (input + 1, 'a') == input + length - 2);\n  ASSERT (U_STRCHR (input + 1, 'e') == input + length - 3);\n\n  ASSERT (U_STRCHR (input, 'f') == NULL);\n  ASSERT (U_STRCHR (input, '\\0') == input + length - 1);\n\n  /* Check that a very long haystack is handled quickly if the byte is\n     found near the beginning.  */\n  {\n    size_t repeat = 10000;\n    for (; repeat > 0; repeat--)\n      {\n        ASSERT (U_STRCHR (input, 'c') == input + 2);\n      }\n  }\n\n  /* Alignment tests.  */\n  {\n    int i, j;\n    for (i = 0; i < 32; i++)\n      {\n        for (j = 0; j < 127; j++)\n          input[i + j] = j + 1;\n        input[i + 128] = 0;\n        for (j = 0; j < 127; j++)\n          {\n            ASSERT (U_STRCHR (input + i, j + 1) == input + i + j);\n          }\n      }\n  }\n\n  /* Check that uN_strchr() does not read past the end of the string.  */\n  {\n    char *page_boundary = (char *) zerosize_ptr ();\n    size_t n;\n\n    if (page_boundary != NULL)\n      {\n        for (n = 2; n <= 500 / sizeof (UNIT); n++)\n          {\n            UNIT *mem = (UNIT *) (page_boundary - n * sizeof (UNIT));\n            U_SET (mem, 'X', n - 2);\n            mem[n - 2] = 0;\n            ASSERT (U_STRCHR (mem, 'U') == NULL);\n            mem[n - 2] = 'X';\n            mem[n - 1] = 0;\n            ASSERT (U_STRCHR (mem, 'U') == NULL);\n          }\n      }\n  }\n\n#if 0\n  /* This check is disabled, because uN_strchr() is allowed to read past the\n     first occurrence of the byte being searched.  In fact, u8_strchr() does\n     so, on i586 glibc systems: u8_strchr calls strchr, which in\n     glibc/sysdeps/i386/i586/strchr.S loads the second word before the\n     handling of the first word has been completed.  */\n  /* Check that uN_strchr() does not read past the first occurrence of the\n     byte being searched.  */\n  {\n    char *page_boundary = (char *) zerosize_ptr ();\n    size_t n;\n\n    if (page_boundary != NULL)\n      {\n        for (n = 2; n <= 500 / sizeof (UNIT); n++)\n          {\n            UNIT *mem = (UNIT *) (page_boundary - n * sizeof (UNIT));\n            U_SET (mem, 'X', n - 1);\n            mem[n - 1] = 0;\n            ASSERT (U_STRCHR (mem, 'U') == NULL);\n\n            {\n              size_t i;\n\n              for (i = 0; i < n; i++)\n                {\n                  mem[i] = 'U';\n                  ASSERT (U_STRCHR (mem, 'U') == mem + i);\n                  mem[i] = 'X';\n                }\n            }\n          }\n      }\n  }\n#endif\n\n  free (input);\n}",
      "lines": 142,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-strcmp.h": {
    "test_strcmp": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "static void\ntest_strcmp (void)\n{\n  {\n    static const UNIT input1[] = { 0 };\n    static const UNIT input2[] = { 0 };\n    ASSERT (U_STRCMP (input1, input2) == 0);\n  }\n  {\n    static const UNIT input1[] = { 0 };\n    static const UNIT input2[] = { 'f', 'o', 'o', 0 };\n    ASSERT (U_STRCMP (input1, input2) < 0);\n    ASSERT (U_STRCMP (input2, input1) > 0);\n  }\n  {\n    static const UNIT input1[] = { 'f', 'o', 'o', 0 };\n    static const UNIT input2[] = { 'f', 'o', 'o', 0 };\n    ASSERT (U_STRCMP (input1, input2) == 0);\n  }\n  {\n    static const UNIT input1[] = { 'f', 'o', 'o', 0 };\n    static const UNIT input2[] = { 'b', 'a', 'r', 0 };\n    ASSERT (U_STRCMP (input1, input2) > 0);\n    ASSERT (U_STRCMP (input2, input1) < 0);\n  }\n  {\n    static const UNIT input1[] = { 'f', 'o', 'o', 0 };\n    static const UNIT input2[] = { 'f', 'o', 'o', 'b', 'a', 'r', 0 };\n    ASSERT (U_STRCMP (input1, input2) < 0);\n    ASSERT (U_STRCMP (input2, input1) > 0);\n  }\n  {\n    static const UNIT input1[] = { 'o', 'o', 'm', 'p', 'h', 0 };\n    static const UNIT input2[] = { 'o', 'o', 'p', 's', 0 };\n    ASSERT (U_STRCMP (input1, input2) < 0);\n    ASSERT (U_STRCMP (input2, input1) > 0);\n  }\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-strcpy.h": {
    "main": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Test small copying operations.  */\n  {\n    static const UNIT src[] = { 'c', 'l', 'i', 'm', 'a', 't', 'e', 0 };\n    size_t n;\n\n    for (n = 1; n <= SIZEOF (src); n++)\n      {\n        UNIT dest[1 + SIZEOF (src) + 1] =\n          { MAGIC, MAGIC, MAGIC, MAGIC, MAGIC, MAGIC, MAGIC, MAGIC, MAGIC,\n            MAGIC\n          };\n        UNIT *result;\n        size_t i;\n\n        result = U_STRCPY (dest + 1, src + SIZEOF (src) - n);\n        ASSERT (result == dest + 1);\n\n        ASSERT (dest[0] == MAGIC);\n        for (i = 0; i < n; i++)\n          ASSERT (dest[1 + i] == src[SIZEOF (src) - n + i]);\n        ASSERT (dest[1 + n] == MAGIC);\n      }\n  }\n\n  return 0;\n}",
      "lines": 29,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-strdup.h": {
    "main": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Test small copying operations.  */\n  {\n    static const UNIT src[] = { 'c', 'l', 'i', 'm', 'a', 't', 'e', 0 };\n    size_t n;\n\n    for (n = 1; n <= SIZEOF (src); n++)\n      {\n        UNIT *result = U_STRDUP (src + SIZEOF (src) - n);\n        size_t i;\n\n        ASSERT (result != NULL);\n        for (i = 0; i < n; i++)\n          ASSERT (result[i] == src[SIZEOF (src) - n + i]);\n\n        free (result);\n      }\n  }\n\n  return 0;\n}",
      "lines": 23,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-strncat.h": {
    "check_single": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static void\ncheck_single (const UNIT *input, size_t length, size_t n)\n{\n  static const UNIT base[] = { 'C', 'h', 'a', 'n', 'g', 'i', 'n', 'g', 0 };\n  size_t m;\n\n  for (m = 0; m < SIZEOF (base); m++)\n    {\n      UNIT *dest;\n      UNIT *result;\n      size_t i;\n\n      dest = (UNIT *) malloc ((1 + m + n + 2) * sizeof (UNIT));\n      ASSERT (dest != NULL);\n\n      dest[0] = MAGIC;\n      for (i = 0; i < m; i++)\n        dest[1 + i] = base[i];\n      dest[1 + m] = 0;\n      for (i = 1; i < n + 2; i++)\n        dest[1 + m + i] = MAGIC;\n\n      result = U_STRNCAT (dest + 1, input, n);\n      ASSERT (result == dest + 1);\n\n      ASSERT (dest[0] == MAGIC);\n      for (i = 0; i < m; i++)\n        ASSERT (dest[1 + i] == base[i]);\n      for (i = 0; i < (n <= length ? n : length); i++)\n        ASSERT (dest[1 + m + i] == input[i]);\n      ASSERT (dest[1 + m + i] == 0);\n      ASSERT (dest[1 + m + i + 1] == MAGIC);\n\n      free (dest);\n    }\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static void\ncheck (const UNIT *input, size_t input_length)\n{\n  size_t length;\n  size_t n;\n\n  ASSERT (input_length > 0);\n  ASSERT (input[input_length - 1] == 0);\n  length = input_length - 1; /* = U_STRLEN (input) */\n\n  for (n = 0; n <= 2 * length + 2; n++)\n    check_single (input, length, n);\n\n  /* Check that U_STRNCAT (D, S, N) does not look at more than\n     MIN (U_STRLEN (S) + 1, N) units.  */\n  {\n    char *page_boundary = (char *) zerosize_ptr ();\n\n    if (page_boundary != NULL)\n      {\n        for (n = 0; n <= 2 * length + 2; n++)\n          {\n            size_t n_to_copy = (n <= length ? n : length + 1);\n            UNIT *copy;\n            size_t i;\n\n            copy = (UNIT *) page_boundary - n_to_copy;\n            for (i = 0; i < n_to_copy; i++)\n              copy[i] = input[i];\n\n            check_single (copy, length, n);\n          }\n      }\n  }\n}",
      "lines": 35,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-strncmp.h": {
    "test_strncmp": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static void\ntest_strncmp (void)\n{\n  {\n    static const UNIT input1[] = { 0 };\n    static const UNIT input2[] = { 0 };\n    ASSERT (U_STRNCMP (input1, input2, 0) == 0);\n    ASSERT (U_STRNCMP (input1, input2, 1) == 0);\n    ASSERT (U_STRNCMP (input1, input2, 1000000) == 0);\n  }\n  {\n    static const UNIT input1[] = { 0 };\n    static const UNIT input2[] = { 'f', 'o', 'o', 0 };\n    ASSERT (U_STRNCMP (input1, input2, 0) == 0);\n    ASSERT (U_STRNCMP (input1, input2, 1) < 0);\n    ASSERT (U_STRNCMP (input2, input1, 1) > 0);\n    ASSERT (U_STRNCMP (input1, input2, 3) < 0);\n    ASSERT (U_STRNCMP (input2, input1, 3) > 0);\n    ASSERT (U_STRNCMP (input1, input2, 4) < 0);\n    ASSERT (U_STRNCMP (input2, input1, 4) > 0);\n    ASSERT (U_STRNCMP (input1, input2, 1000000) < 0);\n    ASSERT (U_STRNCMP (input2, input1, 1000000) > 0);\n  }\n  {\n    static const UNIT input1[] = { 'f', 'o', 'o', 0 };\n    static const UNIT input2[] = { 'f', 'o', 'o', 0 };\n    ASSERT (U_STRNCMP (input1, input2, 0) == 0);\n    ASSERT (U_STRNCMP (input1, input2, 1) == 0);\n    ASSERT (U_STRNCMP (input1, input2, 2) == 0);\n    ASSERT (U_STRNCMP (input1, input2, 3) == 0);\n    ASSERT (U_STRNCMP (input1, input2, 4) == 0);\n    ASSERT (U_STRNCMP (input1, input2, 1000000) == 0);\n  }\n  {\n    static const UNIT input1[] = { 'f', 'o', 'o', 0 };\n    static const UNIT input2[] = { 'b', 'a', 'r', 0 };\n    ASSERT (U_STRNCMP (input1, input2, 0) == 0);\n    ASSERT (U_STRNCMP (input1, input2, 1) > 0);\n    ASSERT (U_STRNCMP (input2, input1, 1) < 0);\n    ASSERT (U_STRNCMP (input1, input2, 2) > 0);\n    ASSERT (U_STRNCMP (input2, input1, 2) < 0);\n    ASSERT (U_STRNCMP (input1, input2, 1000000) > 0);\n    ASSERT (U_STRNCMP (input2, input1, 1000000) < 0);\n  }\n  {\n    static const UNIT input1[] = { 'f', 'o', 'o', 0 };\n    static const UNIT input2[] = { 'f', 'o', 'o', 'b', 'a', 'r', 0 };\n    ASSERT (U_STRNCMP (input1, input2, 0) == 0);\n    ASSERT (U_STRNCMP (input1, input2, 1) == 0);\n    ASSERT (U_STRNCMP (input1, input2, 2) == 0);\n    ASSERT (U_STRNCMP (input1, input2, 3) == 0);\n    ASSERT (U_STRNCMP (input1, input2, 4) < 0);\n    ASSERT (U_STRNCMP (input2, input1, 4) > 0);\n    ASSERT (U_STRNCMP (input1, input2, 1000000) < 0);\n    ASSERT (U_STRNCMP (input2, input1, 1000000) > 0);\n  }\n  {\n    static const UNIT input1[] = { 'o', 'o', 'm', 'p', 'h', 0 };\n    static const UNIT input2[] = { 'o', 'o', 'p', 's', 0 };\n    ASSERT (U_STRNCMP (input1, input2, 0) == 0);\n    ASSERT (U_STRNCMP (input1, input2, 1) == 0);\n    ASSERT (U_STRNCMP (input1, input2, 2) == 0);\n    ASSERT (U_STRNCMP (input1, input2, 3) < 0);\n    ASSERT (U_STRNCMP (input2, input1, 3) > 0);\n    ASSERT (U_STRNCMP (input1, input2, 4) < 0);\n    ASSERT (U_STRNCMP (input2, input1, 4) > 0);\n    ASSERT (U_STRNCMP (input1, input2, 5) < 0);\n    ASSERT (U_STRNCMP (input2, input1, 5) > 0);\n    ASSERT (U_STRNCMP (input1, input2, 6) < 0);\n    ASSERT (U_STRNCMP (input2, input1, 6) > 0);\n    ASSERT (U_STRNCMP (input1, input2, 1000000) < 0);\n    ASSERT (U_STRNCMP (input2, input1, 1000000) > 0);\n  }\n}",
      "lines": 74,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-strncpy.h": {
    "check_single": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "static void\ncheck_single (const UNIT *input, size_t length, size_t n)\n{\n  UNIT *dest;\n  UNIT *result;\n  size_t i;\n\n  dest = (UNIT *) malloc ((1 + n + 1) * sizeof (UNIT));\n  ASSERT (dest != NULL);\n\n  for (i = 0; i < 1 + n + 1; i++)\n    dest[i] = MAGIC;\n\n  result = U_STRNCPY (dest + 1, input, n);\n  ASSERT (result == dest + 1);\n\n  ASSERT (dest[0] == MAGIC);\n  for (i = 0; i < (n <= length ? n : length + 1); i++)\n    ASSERT (dest[1 + i] == input[i]);\n  for (; i < n; i++)\n    ASSERT (dest[1 + i] == 0);\n  ASSERT (dest[1 + n] == MAGIC);\n\n  free (dest);\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static void\ncheck (const UNIT *input, size_t input_length)\n{\n  size_t length;\n  size_t n;\n\n  ASSERT (input_length > 0);\n  ASSERT (input[input_length - 1] == 0);\n  length = input_length - 1; /* = U_STRLEN (input) */\n\n  for (n = 0; n <= 2 * length + 2; n++)\n    check_single (input, length, n);\n\n  /* Check that U_STRNCPY (D, S, N) does not look at more than\n     MIN (U_STRLEN (S) + 1, N) units.  */\n  {\n    char *page_boundary = (char *) zerosize_ptr ();\n\n    if (page_boundary != NULL)\n      {\n        for (n = 0; n <= 2 * length + 2; n++)\n          {\n            size_t n_to_copy = (n <= length ? n : length + 1);\n            UNIT *copy;\n            size_t i;\n\n            copy = (UNIT *) page_boundary - n_to_copy;\n            for (i = 0; i < n_to_copy; i++)\n              copy[i] = input[i];\n\n            check_single (copy, length, n);\n          }\n      }\n  }\n}",
      "lines": 35,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-strnlen.h": {
    "check_single": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        23,
        1
      ],
      "content": "static void\ncheck_single (const UNIT *input, size_t length, size_t n)\n{\n  size_t result = U_STRNLEN (input, n);\n  ASSERT (result == (n <= length ? n : length));\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static void\ncheck (const UNIT *input, size_t input_length)\n{\n  size_t length;\n  size_t n;\n\n  ASSERT (input_length > 0);\n  ASSERT (input[input_length - 1] == 0);\n  length = input_length - 1; /* = U_STRLEN (input) */\n\n  for (n = 0; n <= 2 * length + 2; n++)\n    check_single (input, length, n);\n\n  /* Check that U_STRNLEN (S, N) does not look at more than\n     MIN (U_STRLEN (S) + 1, N) units.  */\n  {\n    char *page_boundary = (char *) zerosize_ptr ();\n\n    if (page_boundary != NULL)\n      {\n        for (n = 0; n <= 2 * length + 2; n++)\n          {\n            size_t n_to_copy = (n <= length ? n : length + 1);\n            UNIT *copy;\n            size_t i;\n\n            copy = (UNIT *) page_boundary - n_to_copy;\n            for (i = 0; i < n_to_copy; i++)\n              copy[i] = input[i];\n\n            check_single (copy, length, n);\n          }\n      }\n  }\n}",
      "lines": 35,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u-strstr.h": {
    "test_u_strstr": {
      "start_point": [
        16,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "static void\ntest_u_strstr (void)\n{\n  {\n    const UNIT input[] = { 'f', 'o', 'o', 0 };\n    const UNIT needle[] = { 0 };\n    const UNIT *result = U_STRSTR (input, needle);\n    ASSERT (result == input);\n  }\n\n  {\n    const UNIT input[] = { 'f', 'o', 'o', 0 };\n    const UNIT needle[] = { 'o', 0 };\n    const UNIT *result = U_STRSTR (input, needle);\n    ASSERT (result == input + 1);\n  }\n\n  {\n    const UNIT input[] =\n      { 'A', 'B', 'C', ' ', 'A', 'B', 'C', 'D', 'A', 'B', ' ', 'A', 'B', 'C',\n        'D', 'A', 'B', 'C', 'D', 'A', 'B', 'D', 'E', 0\n      };\n    const UNIT needle[] = { 'A', 'B', 'C', 'D', 'A', 'B', 'D', 0 };\n    const UNIT *result = U_STRSTR (input, needle);\n    ASSERT (result == input + 15);\n  }\n\n  {\n    const UNIT input[] =\n      { 'A', 'B', 'C', ' ', 'A', 'B', 'C', 'D', 'A', 'B', ' ', 'A', 'B', 'C',\n        'D', 'A', 'B', 'C', 'D', 'A', 'B', 'D', 'E', 0\n      };\n    const UNIT needle[] = { 'A', 'B', 'C', 'D', 'A', 'B', 'E', 0 };\n    const UNIT *result = U_STRSTR (input, needle);\n    ASSERT (result == NULL);\n  }\n\n  {\n    const UNIT input[] =\n      { 'A', 'B', 'C', ' ', 'A', 'B', 'C', 'D', 'A', 'B', ' ', 'A', 'B', 'C',\n        'D', 'A', 'B', 'C', 'D', 'A', 'B', 'D', 'E', 0\n      };\n    const UNIT needle[] = { 'A', 'B', 'C', 'D', 'A', 'B', 'C', 'D', 0 };\n    const UNIT *result = U_STRSTR (input, needle);\n    ASSERT (result == input + 11);\n  }\n\n  /* Check that a long periodic needle does not cause false positives.  */\n  {\n    const UNIT input[] =\n      { 'F', '_', 'B', 'D', '_', 'C', 'E', '_', 'B', 'D', '_', 'E', 'F',\n        '_', 'B', 'F', '_', 'B', 'D', '_', 'E', 'F', '_', 'B', 'F',\n        '_', 'B', 'D', '_', 'E', 'F', '_', 'B', 'F', '_', 'B', 'D',\n        '_', 'E', 'F', '_', 'B', 'F', '_', 'B', 'D', '_', 'C', '3',\n        '_', '8', '8', '_', '2', '0', '_', 'E', 'F', '_', 'B', 'F',\n        '_', 'B', 'D', '_', 'E', 'F', '_', 'B', 'F', '_', 'B', 'D',\n        '_', 'E', 'F', '_', 'B', 'F', '_', 'B', 'D', '_', 'C', '3',\n        '_', 'A', '7', '_', '2', '0', '_', 'E', 'F', '_', 'B', 'F',\n        '_', 'B', 'D', 0\n      };\n    const UNIT needle[] =\n      { '_', 'E', 'F', '_', 'B', 'F', '_', 'B', 'D', '_', 'E', 'F',\n        '_', 'B', 'F', '_', 'B', 'D', '_', 'E', 'F', '_', 'B', 'F',\n        '_', 'B', 'D', '_', 'E', 'F', '_', 'B', 'F', '_', 'B', 'D',\n        '_', 'E', 'F', '_', 'B', 'F', '_', 'B', 'D', 0\n      };\n    const UNIT *result = U_STRSTR (input, needle);\n    ASSERT (result == NULL);\n  }\n  {\n    const UNIT input[] =\n      { 'F', '_', 'B', 'D', '_', 'C', 'E', '_', 'B', 'D', '_', 'E', 'F',\n        '_', 'B', 'F', '_', 'B', 'D', '_', 'E', 'F', '_', 'B', 'F',\n        '_', 'B', 'D', '_', 'E', 'F', '_', 'B', 'F', '_', 'B', 'D',\n        '_', 'E', 'F', '_', 'B', 'F', '_', 'B', 'D', '_', 'C', '3',\n        '_', '8', '8', '_', '2', '0', '_', 'E', 'F', '_', 'B', 'F',\n        '_', 'B', 'D', '_', 'E', 'F', '_', 'B', 'F', '_', 'B', 'D',\n        '_', 'E', 'F', '_', 'B', 'F', '_', 'B', 'D', '_', 'C', '3',\n        '_', 'A', '7', '_', '2', '0', '_', 'E', 'F', '_', 'B', 'F',\n        '_', 'B', 'D', '_', 'D', 'A', '_', 'B', '5', '_', 'C', '2',\n        '_', 'A', '6', '_', '2', '0', '_', 'E', 'F', '_', 'B', 'F',\n        '_', 'B', 'D', '_', 'E', 'F', '_', 'B', 'F', '_', 'B', 'D',\n        '_', 'E', 'F', '_', 'B', 'F', '_', 'B', 'D', '_', 'E', 'F',\n        '_', 'B', 'F', '_', 'B', 'D', '_', 'E', 'F', '_', 'B', 'F',\n        '_', 'B', 'D', 0\n      };\n    const UNIT needle[] =\n      { '_', 'E', 'F', '_', 'B', 'F', '_', 'B', 'D', '_', 'E', 'F',\n        '_', 'B', 'F', '_', 'B', 'D', '_', 'E', 'F', '_', 'B', 'F',\n        '_', 'B', 'D', '_', 'E', 'F', '_', 'B', 'F', '_', 'B', 'D',\n        '_', 'E', 'F', '_', 'B', 'F', '_', 'B', 'D', 0\n      };\n    const UNIT *result = U_STRSTR (input, needle);\n    ASSERT (result == input + 115);\n  }\n\n  /* Check that a very long haystack is handled quickly if the needle is\n     short and occurs near the beginning.  */\n  {\n    size_t repeat = 10000;\n    size_t m = 1000000;\n    const UNIT needle[] =\n      { 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',\n        'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',\n        'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',\n        'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',\n        'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',\n        'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',\n        'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',\n        'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',\n        'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',\n        'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 0\n      };\n    UNIT *haystack = (UNIT *) malloc ((m + 1) * sizeof (UNIT));\n    if (haystack != NULL)\n      {\n        size_t i;\n\n        haystack[0] = 'B';\n        for (i = 1; i < m; i++)\n          haystack[i] = 'A';\n        haystack[m] = '\\0';\n\n        for (; repeat > 0; repeat--)\n          {\n            ASSERT (U_STRSTR (haystack, needle) == haystack + 1);\n          }\n\n        free (haystack);\n      }\n  }\n\n  /* Check that a very long needle is discarded quickly if the haystack is\n     short.  */\n  {\n    size_t repeat = 10000;\n    size_t m = 1000000;\n    const UNIT haystack[] =\n      { 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',\n        'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',\n        'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',\n        'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',\n        'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'B',\n        'A', 'B', 'A', 'B', 'A', 'B', 'A', 'B', 'A', 'B', 'A', 'B', 'A', 'B',\n        'A', 'B', 'A', 'B', 'A', 'B', 'A', 'B', 'A', 'B', 'A', 'B', 'A', 'B',\n        'A', 'B', 'A', 'B', 'A', 'B', 'A', 'B', 'A', 'B', 'A', 'B', 'A', 'B',\n        'A', 'B', 'A', 'B', 'A', 'B', 'A', 'B', 'A', 'B', 'A', 'B', 'A', 'B',\n        'A', 'B', 'A', 'B', 'A', 'B', 'A', 'B', 'A', 'B', 0\n      };\n    UNIT *needle = (UNIT *) malloc ((m + 1) * sizeof (UNIT));\n    if (needle != NULL)\n      {\n        size_t i;\n\n        for (i = 0; i < m; i++)\n          needle[i] = 'A';\n        needle[m] = '\\0';\n\n        for (; repeat > 0; repeat--)\n          {\n            ASSERT (U_STRSTR (haystack, needle) == NULL);\n          }\n\n        free (needle);\n      }\n  }\n\n  /* Check that the asymptotic worst-case complexity is not quadratic.  */\n  {\n    size_t m = 1000000;\n    UNIT *haystack = (UNIT *) malloc ((2 * m + 2) * sizeof (UNIT));\n    UNIT *needle = (UNIT *) malloc ((m + 2) * sizeof (UNIT));\n    if (haystack != NULL && needle != NULL)\n      {\n        size_t i;\n        const UNIT *result;\n\n        for (i = 0; i < 2 * m; i++)\n          haystack[i] = 'A';\n        haystack[2 * m] = 'B';\n        haystack[2 * m + 1] = 0;\n\n        for (i = 0; i < m; i++)\n          needle[i] = 'A';\n        needle[m] = 'B';\n        needle[m + 1] = 0;\n\n        result = U_STRSTR (haystack, needle);\n        ASSERT (result == haystack + m);\n      }\n    free (needle);\n    free (haystack);\n  }\n}",
      "lines": 194,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u-strtok.h": {
    "test_u_strtok": {
      "start_point": [
        16,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "static void\ntest_u_strtok (void)\n{\n  {\n    UNIT input[] = { 'f', 'o', 'o', 0 };\n    const UNIT delim[] = { 0 };\n    UNIT *state;\n    const UNIT *result = U_STRTOK (input, delim, &state);\n    ASSERT (result == input);\n  }\n\n  {\n    UNIT input[] =\n      { 'A', 'B', 'C', ' ', 'A', 'B', 'C', 'D', 'A', 'B', ' ', '\\t',\n        'A', 'B', 'C', 'D', 'A', 'B', 'C', 'D', 'A', 'B', 'D', 'E', 0\n      };\n    const UNIT delim[] = { ' ', '\\t', 0 };\n    UNIT *state;\n    const UNIT *result;\n    result = U_STRTOK (input, delim, &state);\n    ASSERT (result == input);\n    result = U_STRTOK (NULL, delim, &state);\n    ASSERT (result == input + 4);\n    result = U_STRTOK (NULL, delim, &state);\n    ASSERT (result == input + 12);\n    result = U_STRTOK (NULL, delim, &state);\n    ASSERT (result == NULL);\n  }\n\n  /* Check for multibyte delimiters.  */\n  {\n    ucs4_t u_input[] =\n      { 'A', 'B', 'C', 0x3000, 'A', 'B', 'C', 'D', 'A', 'B', 0x3000, 0x3001,\n        'A', 'B', 'C', 'D', 'A', 'B', 'C', 'D', 'A', 'B', 'D', 'E', 0\n      };\n    ucs4_t u_delim[] = { 0x3000, 0x3001, 0 };\n    size_t input_len = 6 * SIZEOF (u_input);\n    UNIT *input = (UNIT *) malloc (input_len);\n    size_t delim_len = 6 * SIZEOF (u_delim);\n    UNIT *delim = (UNIT *) malloc (delim_len);\n    UNIT *state;\n    const UNIT *result;\n    UNIT *ptr, *first_ptr, *second_ptr;\n    size_t i;\n    for (i = 0, ptr = input; i < SIZEOF (u_input) && u_input[i] != 0; i++)\n      {\n        int ret = U_UCTOMB (ptr, u_input[i], input_len - (ptr - input));\n        if (i == 4)\n          first_ptr = ptr;\n        if (i == 12)\n          second_ptr = ptr;\n        ptr += ret;\n      }\n    *ptr = 0;\n    for (i = 0, ptr = delim; i < SIZEOF (u_delim) && u_delim[i] != 0; i++)\n      {\n        int ret = U_UCTOMB (ptr, u_delim[i], delim_len - (ptr - delim));\n        ptr += ret;\n      }\n    *ptr = 0;\n    result = U_STRTOK (input, delim, &state);\n    ASSERT (result == input);\n    result = U_STRTOK (NULL, delim, &state);\n    ASSERT (result == first_ptr);\n    result = U_STRTOK (NULL, delim, &state);\n    ASSERT (result == second_ptr);\n    result = U_STRTOK (NULL, delim, &state);\n    ASSERT (result == NULL);\n    free (input);\n    free (delim);\n  }\n}",
      "lines": 72,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-check.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Test empty string.  */\n  {\n    static const uint16_t input[] = { 0 };\n    ASSERT (u16_check (input, 0) == NULL);\n  }\n\n  /* Test valid non-empty string.  */\n  {\n    static const uint16_t input[] = /* \"\u00d0\u0094\u00d0\u00b0\u00d0\u00bd\u00d0\u00b8\u00d0\u00bb\u00d0\u00be \u00d0\u00a8\u00d0\u00b5\u00d0\u00b3\u00d0\u00b0\u00d0\u00bd\" */\n      { 0x0414, 0x0430, 0x043D, 0x0438, 0x043B, 0x043E, 0x0020, 0x0428, 0x0435, 0x0433, 0x0430, 0x043D };\n    ASSERT (u16_check (input, SIZEOF (input)) == NULL);\n  }\n\n  /* Test out-of-range character with 2 units: U+110000.  */\n  {\n    static const uint16_t input[] = { 0x0414, 0x0430, 0xDBFF, 0xE000 };\n    ASSERT (u16_check (input, SIZEOF (input)) == input + 2);\n  }\n\n  /* Test surrogate codepoints.  */\n  {\n    static const uint16_t input[] = { 0x0414, 0x0430, 0xDBFF, 0xDFFF };\n    ASSERT (u16_check (input, SIZEOF (input)) == NULL);\n  }\n  {\n    static const uint16_t input[] = { 0x0414, 0x0430, 0xDBFF };\n    ASSERT (u16_check (input, SIZEOF (input)) == input + 2);\n  }\n  {\n    static const uint16_t input[] = { 0x0414, 0x0430, 0xDFFF };\n    ASSERT (u16_check (input, SIZEOF (input)) == input + 2);\n  }\n  {\n    static const uint16_t input[] = { 0x0414, 0x0430, 0xDFFF, 0xDBFF };\n    ASSERT (u16_check (input, SIZEOF (input)) == input + 2);\n  }\n\n  return 0;\n}",
      "lines": 42,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-chr.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-cmp.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "int\nmain ()\n{\n  test_cmp ();\n\n  /* Test comparison with non-BMP characters, split into surrogates.  */\n  {\n    static const UNIT input1[] = { 0xD835, 0xDD1E };\n    static const UNIT input2[] = { 0xFEFF, 0xFFE5 };\n    ASSERT (U_CMP (input1, input2, 2) > 0);\n    ASSERT (U_CMP (input2, input1, 2) < 0);\n    ASSERT (U_CMP (input1, input2, 1) > 0);\n    ASSERT (U_CMP (input2, input1, 1) < 0);\n  }\n\n  return 0;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-cmp2.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-cpy-alloc.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-cpy.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-mblen.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "int\nmain ()\n{\n  int ret;\n\n  /* Test zero-length input.  */\n  {\n    static const uint16_t input[] = { 0 };\n    ret = u16_mblen (input, 0);\n    ASSERT (ret == -1);\n  }\n\n  /* Test NUL unit input.  */\n  {\n    static const uint16_t input[] = { 0 };\n    ret = u16_mblen (input, 1);\n    ASSERT (ret == 0);\n  }\n\n  /* Test ISO 646 unit input.  */\n  {\n    ucs4_t c;\n    uint16_t buf[1];\n\n    for (c = 1; c < 0x80; c++)\n      {\n        buf[0] = c;\n        ret = u16_mblen (buf, 1);\n        ASSERT (ret == 1);\n      }\n  }\n\n  /* Test BMP unit input.  */\n  {\n    static const uint16_t input[] = { 0x20AC };\n    ret = u16_mblen (input, 1);\n    ASSERT (ret == 1);\n  }\n\n  /* Test 2-units character input.  */\n  {\n    static const uint16_t input[] = { 0xD835, 0xDD1F };\n    ret = u16_mblen (input, 2);\n    ASSERT (ret == 2);\n  }\n\n  /* Test incomplete/invalid 1-unit input.  */\n  {\n    static const uint16_t input[] = { 0xD835 };\n    ret = u16_mblen (input, 1);\n    ASSERT (ret == -1);\n  }\n  {\n    static const uint16_t input[] = { 0xDD1F };\n    ret = u16_mblen (input, 1);\n    ASSERT (ret == -1);\n  }\n\n  return 0;\n}",
      "lines": 60,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-mbsnlen.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint16_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    size_t n;\n\n    for (n = 0; n <= SIZEOF (input); n++)\n      {\n        size_t len = u16_mbsnlen (input, n);\n        ASSERT (len == n);\n      }\n  }\n\n  /* String with characters outside the BMP.  */\n  {\n    static const uint16_t input[] =\n      { '-', '(', 0xD835, 0xDD1E, 0x00D7, 0xD835, 0xDD1F, ')', '=',\n        0xD835, 0xDD1F, 0x00D7, 0xD835, 0xDD1E\n      };\n    static const size_t expected[SIZEOF (input) + 1] =\n      { 0,\n        1, 2, 3, 3, 4, 5, 5, 6, 7,\n        8, 8, 9, 10, 10\n      };\n    size_t n;\n\n    for (n = 0; n <= SIZEOF (input); n++)\n      {\n        size_t len = u16_mbsnlen (input, n);\n        ASSERT (len == expected[n]);\n      }\n  }\n\n  return 0;\n}",
      "lines": 44,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-mbtouc-unsafe.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nmain ()\n{\n  test_function (u16_mbtouc_unsafe);\n\n  return 0;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-mbtouc.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nmain ()\n{\n  test_function (u16_mbtouc);\n\n  return 0;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-mbtouc.h": {
    "test_function": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static void\ntest_function (int (*my_u16_mbtouc) (ucs4_t *, const uint16_t *, size_t))\n{\n  ucs4_t uc;\n  int ret;\n\n  /* Test NUL unit input.  */\n  {\n    static const uint16_t input[] = { 0 };\n    uc = 0xBADFACE;\n    ret = my_u16_mbtouc (&uc, input, 1);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0);\n  }\n\n  /* Test ISO 646 unit input.  */\n  {\n    ucs4_t c;\n    uint16_t buf[1];\n\n    for (c = 0; c < 0x80; c++)\n      {\n        buf[0] = c;\n        uc = 0xBADFACE;\n        ret = my_u16_mbtouc (&uc, buf, 1);\n        ASSERT (ret == 1);\n        ASSERT (uc == c);\n      }\n  }\n\n  /* Test BMP unit input.  */\n  {\n    static const uint16_t input[] = { 0x20AC };\n    uc = 0xBADFACE;\n    ret = my_u16_mbtouc (&uc, input, 1);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0x20AC);\n  }\n\n  /* Test 2-units character input.  */\n  {\n    static const uint16_t input[] = { 0xD835, 0xDD1F };\n    uc = 0xBADFACE;\n    ret = my_u16_mbtouc (&uc, input, 2);\n    ASSERT (ret == 2);\n    ASSERT (uc == 0x1D51F);\n  }\n\n  /* Test incomplete/invalid 1-unit input.  */\n  {\n    static const uint16_t input[] = { 0xD835 };\n    uc = 0xBADFACE;\n    ret = my_u16_mbtouc (&uc, input, 1);\n    ASSERT (ret == 1 || ret == 2);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint16_t input[] = { 0xDD1F };\n    uc = 0xBADFACE;\n    ret = my_u16_mbtouc (&uc, input, 1);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0xFFFD);\n  }\n}",
      "lines": 64,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-mbtoucr.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "int\nmain ()\n{\n  ucs4_t uc;\n  int ret;\n\n  /* Test NUL unit input.  */\n  {\n    static const uint16_t input[] = { 0 };\n    uc = 0xBADFACE;\n    ret = u16_mbtoucr (&uc, input, 1);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0);\n  }\n\n  /* Test ISO 646 unit input.  */\n  {\n    ucs4_t c;\n    uint16_t buf[1];\n\n    for (c = 0; c < 0x80; c++)\n      {\n        buf[0] = c;\n        uc = 0xBADFACE;\n        ret = u16_mbtoucr (&uc, buf, 1);\n        ASSERT (ret == 1);\n        ASSERT (uc == c);\n      }\n  }\n\n  /* Test BMP unit input.  */\n  {\n    static const uint16_t input[] = { 0x20AC };\n    uc = 0xBADFACE;\n    ret = u16_mbtoucr (&uc, input, 1);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0x20AC);\n  }\n\n  /* Test 2-units character input.  */\n  {\n    static const uint16_t input[] = { 0xD835, 0xDD1F };\n    uc = 0xBADFACE;\n    ret = u16_mbtoucr (&uc, input, 2);\n    ASSERT (ret == 2);\n    ASSERT (uc == 0x1D51F);\n  }\n\n  /* Test incomplete/invalid 1-unit input.  */\n  {\n    static const uint16_t input[] = { 0xD835 };\n    uc = 0xBADFACE;\n    ret = u16_mbtoucr (&uc, input, 1);\n    ASSERT (ret == -2);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint16_t input[] = { 0xDD1F };\n    uc = 0xBADFACE;\n    ret = u16_mbtoucr (&uc, input, 1);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xFFFD);\n  }\n\n  return 0;\n}",
      "lines": 66,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-move.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-next.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "int\nmain ()\n{\n  ucs4_t uc;\n  const uint16_t *ret;\n\n  /* Test NUL unit input.  */\n  {\n    static const uint16_t input[] = { 0 };\n    uc = 0xBADFACE;\n    ret = u16_next (&uc, input);\n    ASSERT (ret == NULL);\n    ASSERT (uc == 0);\n  }\n\n  /* Test ISO 646 unit input.  */\n  {\n    ucs4_t c;\n    uint16_t buf[2];\n\n    for (c = 1; c < 0x80; c++)\n      {\n        buf[0] = c;\n        buf[1] = 0;\n        uc = 0xBADFACE;\n        ret = u16_next (&uc, buf);\n        ASSERT (ret == buf + 1);\n        ASSERT (uc == c);\n      }\n  }\n\n  /* Test BMP unit input.  */\n  {\n    static const uint16_t input[] = { 0x20AC, 0 };\n    uc = 0xBADFACE;\n    ret = u16_next (&uc, input);\n    ASSERT (ret == input + 1);\n    ASSERT (uc == 0x20AC);\n  }\n\n  /* Test 2-units character input.  */\n  {\n    static const uint16_t input[] = { 0xD835, 0xDD1F, 0 };\n    uc = 0xBADFACE;\n    ret = u16_next (&uc, input);\n    ASSERT (ret == input + 2);\n    ASSERT (uc == 0x1D51F);\n  }\n\n  /* Test incomplete/invalid 1-unit input.  */\n  {\n    static const uint16_t input[] = { 0xD835, 0 };\n    uc = 0xBADFACE;\n    ret = u16_next (&uc, input);\n    ASSERT (ret == NULL);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint16_t input[] = { 0xDD1F, 0 };\n    uc = 0xBADFACE;\n    ret = u16_next (&uc, input);\n    ASSERT (ret == NULL);\n    ASSERT (uc == 0xFFFD);\n  }\n\n  return 0;\n}",
      "lines": 67,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-prev.c": {
    "check": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static int\ncheck (const uint16_t *input, size_t input_length, ucs4_t *puc)\n{\n  ucs4_t uc;\n\n  /* Test recognition when at the beginning of the string.  */\n  if (u16_prev (&uc, input + input_length, input) != input)\n    return 1;\n\n  /* Test recognition when preceded by a 1-unit character.  */\n  {\n    uint16_t buf[100];\n    uint16_t *ptr;\n    size_t i;\n    ucs4_t uc1;\n\n    ptr = buf;\n    *ptr++ = 0x2102;\n    for (i = 0; i < input_length; i++)\n      ptr[i] = input[i];\n\n    if (u16_prev (&uc1, ptr + input_length, buf) != ptr)\n      return 2;\n    if (uc1 != uc)\n      return 3;\n  }\n\n  /* Test recognition when preceded by a 2-unit character.  */\n  {\n    uint16_t buf[100];\n    uint16_t *ptr;\n    size_t i;\n    ucs4_t uc1;\n\n    ptr = buf;\n    *ptr++ = 0xD835;\n    *ptr++ = 0xDD1E;\n    for (i = 0; i < input_length; i++)\n      ptr[i] = input[i];\n\n    if (u16_prev (&uc1, ptr + input_length, buf) != ptr)\n      return 4;\n    if (uc1 != uc)\n      return 5;\n  }\n\n  *puc = uc;\n  return 0;\n}",
      "lines": 49,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_invalid": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "static int\ncheck_invalid (const uint16_t *input, size_t input_length)\n{\n  ucs4_t uc;\n\n  /* Test recognition when at the beginning of the string.  */\n  uc = 0xBADFACE;\n  if (u16_prev (&uc, input + input_length, input) != NULL)\n    return 1;\n  if (uc != 0xBADFACE)\n    return 2;\n\n  /* Test recognition when preceded by a 1-unit character.  */\n  {\n    uint16_t buf[100];\n    uint16_t *ptr;\n    size_t i;\n\n    ptr = buf;\n    *ptr++ = 0x2102;\n    for (i = 0; i < input_length; i++)\n      ptr[i] = input[i];\n\n    uc = 0xBADFACE;\n    if (u16_prev (&uc, ptr + input_length, buf) != NULL)\n      return 3;\n    if (uc != 0xBADFACE)\n      return 4;\n  }\n\n  /* Test recognition when preceded by a 2-unit character.  */\n  {\n    uint16_t buf[100];\n    uint16_t *ptr;\n    size_t i;\n\n    ptr = buf;\n    *ptr++ = 0xD835;\n    *ptr++ = 0xDD1E;\n    for (i = 0; i < input_length; i++)\n      ptr[i] = input[i];\n\n    uc = 0xBADFACE;\n    if (u16_prev (&uc, ptr + input_length, buf) != NULL)\n      return 5;\n    if (uc != 0xBADFACE)\n      return 6;\n  }\n\n  return 0;\n}",
      "lines": 51,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "int\nmain ()\n{\n  ucs4_t uc;\n\n  /* Test ISO 646 unit input.  */\n  {\n    ucs4_t c;\n    uint16_t buf[1];\n\n    for (c = 0; c < 0x80; c++)\n      {\n        buf[0] = c;\n        uc = 0xBADFACE;\n        ASSERT (check (buf, 1, &uc) == 0);\n        ASSERT (uc == c);\n      }\n  }\n\n  /* Test BMP unit input.  */\n  {\n    static const uint16_t input[] = { 0x20AC };\n    uc = 0xBADFACE;\n    ASSERT (check (input, SIZEOF (input), &uc) == 0);\n    ASSERT (uc == 0x20AC);\n  }\n\n  /* Test 2-units character input.  */\n  {\n    static const uint16_t input[] = { 0xD835, 0xDD1F };\n    uc = 0xBADFACE;\n    ASSERT (check (input, SIZEOF (input), &uc) == 0);\n    ASSERT (uc == 0x1D51F);\n  }\n\n  /* Test incomplete/invalid 1-unit input.  */\n  {\n    static const uint16_t input[] = { 0xD835 };\n    ASSERT (check_invalid (input, SIZEOF (input)) == 0);\n  }\n  {\n    static const uint16_t input[] = { 0xDD1F };\n    ASSERT (check_invalid (input, SIZEOF (input)) == 0);\n  }\n\n  return 0;\n}",
      "lines": 47,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-set.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-stpcpy.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-stpncpy.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint16_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, 0\n      };\n    check (input, SIZEOF (input));\n  }\n\n  /* String with characters outside the BMP.  */\n  {\n    static const uint16_t input[] =\n      { '-', '(', 0xD835, 0xDD1E, 0x00D7, 0xD835, 0xDD1F, ')', '=',\n        0xD835, 0xDD1F, 0x00D7, 0xD835, 0xDD1E, 0\n      };\n    check (input, SIZEOF (input));\n  }\n\n  return 0;\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-strcat.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-strchr.c": {
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "int\nmain (void)\n{\n  test_strchr ();\n\n  return 0;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-strcmp.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\nmain ()\n{\n  test_u16_strcmp ();\n\n  return 0;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-strcmp.h": {
    "test_u16_strcmp": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "static void\ntest_u16_strcmp (void)\n{\n  test_strcmp ();\n\n  /* Test comparison between ASCII and non-ASCII characters.  */\n  {\n    static const UNIT input1[] = { 'f', 'o', 'o', 0 };\n    static const UNIT input2[] = { 0x2022, 0 };\n    ASSERT (U_STRCMP (input1, input2) < 0);\n    ASSERT (U_STRCMP (input2, input1) > 0);\n  }\n\n  /* Test comparison with non-BMP characters, split into surrogates.  */\n  {\n    static const UNIT input1[] = { 0xD835, 0xDD1E, 0 };\n    static const UNIT input2[] = { 0xFEFF, 0 };\n    ASSERT (U_STRCMP (input1, input2) > 0);\n    ASSERT (U_STRCMP (input2, input1) < 0);\n  }\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-strcoll.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\nmain ()\n{\n  /* This test relies on three facts:\n     - setlocale is not being called, therefore the locale is the \"C\" locale.\n     - In the \"C\" locale, strcoll is equivalent to strcmp.\n     - In the u16_strcoll implementation, Unicode strings that are not\n       convertible to the locale encoding are sorted higher than convertible\n       strings and compared according to u16_strcmp.  */\n\n  test_u16_strcmp ();\n\n  return 0;\n}",
      "lines": 14,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-strcpy.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-strdup.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-strlen.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Empty string.  */\n  {\n    static const uint16_t input[] = { 0 };\n    ASSERT (u16_strlen (input) == 0);\n  }\n\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint16_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, 0\n      };\n    ASSERT (u16_strlen (input) == SIZEOF (input) - 1);\n  }\n\n  /* String with characters outside the BMP.  */\n  {\n    static const uint16_t input[] =\n      { '-', '(', 0xD835, 0xDD1E, 0x00D7, 0xD835, 0xDD1F, ')', '=',\n        0xD835, 0xDD1F, 0x00D7, 0xD835, 0xDD1E, 0\n      };\n    ASSERT (u16_strlen (input) == SIZEOF (input) - 1);\n  }\n\n  return 0;\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-strmblen.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nmain ()\n{\n  int ret;\n\n  /* Test NUL unit input.  */\n  {\n    static const uint16_t input[] = { 0 };\n    ret = u16_strmblen (input);\n    ASSERT (ret == 0);\n  }\n\n  /* Test ISO 646 unit input.  */\n  {\n    ucs4_t c;\n    uint16_t buf[2];\n\n    for (c = 1; c < 0x80; c++)\n      {\n        buf[0] = c;\n        buf[1] = 0;\n        ret = u16_strmblen (buf);\n        ASSERT (ret == 1);\n      }\n  }\n\n  /* Test BMP unit input.  */\n  {\n    static const uint16_t input[] = { 0x20AC, 0 };\n    ret = u16_strmblen (input);\n    ASSERT (ret == 1);\n  }\n\n  /* Test 2-units character input.  */\n  {\n    static const uint16_t input[] = { 0xD835, 0xDD1F, 0 };\n    ret = u16_strmblen (input);\n    ASSERT (ret == 2);\n  }\n\n  /* Test incomplete/invalid 1-unit input.  */\n  {\n    static const uint16_t input[] = { 0xD835, 0 };\n    ret = u16_strmblen (input);\n    ASSERT (ret == -1);\n  }\n  {\n    static const uint16_t input[] = { 0xDD1F, 0 };\n    ret = u16_strmblen (input);\n    ASSERT (ret == -1);\n  }\n\n  return 0;\n}",
      "lines": 54,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-strmbtouc.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "int\nmain ()\n{\n  ucs4_t uc;\n  int ret;\n\n  /* Test NUL unit input.  */\n  {\n    static const uint16_t input[] = { 0 };\n    uc = 0xBADFACE;\n    ret = u16_strmbtouc (&uc, input);\n    ASSERT (ret == 0);\n    ASSERT (uc == 0);\n  }\n\n  /* Test ISO 646 unit input.  */\n  {\n    ucs4_t c;\n    uint16_t buf[2];\n\n    for (c = 1; c < 0x80; c++)\n      {\n        buf[0] = c;\n        buf[1] = 0;\n        uc = 0xBADFACE;\n        ret = u16_strmbtouc (&uc, buf);\n        ASSERT (ret == 1);\n        ASSERT (uc == c);\n      }\n  }\n\n  /* Test BMP unit input.  */\n  {\n    static const uint16_t input[] = { 0x20AC, 0 };\n    uc = 0xBADFACE;\n    ret = u16_strmbtouc (&uc, input);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0x20AC);\n  }\n\n  /* Test 2-units character input.  */\n  {\n    static const uint16_t input[] = { 0xD835, 0xDD1F, 0 };\n    uc = 0xBADFACE;\n    ret = u16_strmbtouc (&uc, input);\n    ASSERT (ret == 2);\n    ASSERT (uc == 0x1D51F);\n  }\n\n  /* Test incomplete/invalid 1-unit input.  */\n  {\n    static const uint16_t input[] = { 0xD835, 0 };\n    uc = 0xBADFACE;\n    ret = u16_strmbtouc (&uc, input);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xBADFACE);\n  }\n  {\n    static const uint16_t input[] = { 0xDD1F, 0 };\n    uc = 0xBADFACE;\n    ret = u16_strmbtouc (&uc, input);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xBADFACE);\n  }\n\n  return 0;\n}",
      "lines": 67,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-strncat.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint16_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, 0\n      };\n    check (input, SIZEOF (input));\n  }\n\n  /* String with characters outside the BMP.  */\n  {\n    static const uint16_t input[] =\n      { '-', '(', 0xD835, 0xDD1E, 0x00D7, 0xD835, 0xDD1F, ')', '=',\n        0xD835, 0xDD1F, 0x00D7, 0xD835, 0xDD1E, 0\n      };\n    check (input, SIZEOF (input));\n  }\n\n  return 0;\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-strncmp.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "int\nmain ()\n{\n  test_strncmp ();\n\n  /* Test comparison with non-BMP characters, split into surrogates.  */\n  {\n    static const UNIT input1[] = { 0xD835, 0xDD1E, 0 };\n    static const UNIT input2[] = { 0xFEFF, 0 };\n    ASSERT (U_STRNCMP (input1, input2, 1) > 0);\n    ASSERT (U_STRNCMP (input2, input1, 1) < 0);\n    ASSERT (U_STRNCMP (input1, input2, 2) > 0);\n    ASSERT (U_STRNCMP (input2, input1, 2) < 0);\n    ASSERT (U_STRNCMP (input1, input2, 1000000) > 0);\n    ASSERT (U_STRNCMP (input2, input1, 1000000) < 0);\n  }\n\n  return 0;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-strncpy.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint16_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, 0\n      };\n    check (input, SIZEOF (input));\n  }\n\n  /* String with characters outside the BMP.  */\n  {\n    static const uint16_t input[] =\n      { '-', '(', 0xD835, 0xDD1E, 0x00D7, 0xD835, 0xDD1F, ')', '=',\n        0xD835, 0xDD1F, 0x00D7, 0xD835, 0xDD1E, 0\n      };\n    check (input, SIZEOF (input));\n  }\n\n  return 0;\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-strnlen.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint16_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, 0\n      };\n    check (input, SIZEOF (input));\n  }\n\n  /* String with characters outside the BMP.  */\n  {\n    static const uint16_t input[] =\n      { '-', '(', 0xD835, 0xDD1E, 0x00D7, 0xD835, 0xDD1F, ')', '=',\n        0xD835, 0xDD1F, 0x00D7, 0xD835, 0xDD1E, 0\n      };\n    check (input, SIZEOF (input));\n  }\n\n  return 0;\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-strstr.c": {
    "main": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "int\nmain (void)\n{\n#if HAVE_DECL_ALARM\n  /* Declare failure if test takes too long, by using default abort\n     caused by SIGALRM.  */\n  signal (SIGALRM, SIG_DFL);\n  alarm (10);\n#endif\n\n  test_u_strstr ();\n\n  return 0;\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-strtok.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int\nmain (void)\n{\n  test_u_strtok ();\n\n  return 0;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-to-u32.c": {
    "check": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "static int\ncheck (const uint16_t *input, size_t input_length,\n       const uint32_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint32_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u16_to_u32 (input, input_length, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u32_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint32_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint32_t *) malloc (length * sizeof (uint32_t));\n      result = u16_to_u32 (input, input_length, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u32_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint32_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint32_t *) malloc (length * sizeof (uint32_t));\n    result = u16_to_u32 (input, input_length, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u32_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Empty string.  */\n  ASSERT (check (NULL, 0, NULL, 0) == 0);\n\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint16_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    static const uint32_t expected[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  /* String with characters outside the BMP.  */\n  {\n    static const uint16_t input[] =\n      { '-', '(', 0xD835, 0xDD1E, 0x00D7, 0xD835, 0xDD1F, ')', '=',\n        0xD835, 0xDD1F, 0x00D7, 0xD835, 0xDD1E\n      };\n    static const uint32_t expected[] =\n      { '-', '(', 0x1D51E, 0x00D7, 0x1D51F, ')', '=',\n        0x1D51F, 0x00D7, 0x1D51E\n      };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  /* Invalid input.  */\n  {\n    static const uint16_t input[] = { 'x', 0xDD1E, 0xD835, 'y' };\n#if 0 /* Currently invalid input is rejected, not accommodated.  */\n    static const uint32_t expected[] = { 'x', 0xFFFD, 0xFFFD, 'y' };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n#else\n    size_t length;\n    uint32_t *result;\n    uint32_t preallocated[10];\n\n    /* Test return conventions with resultbuf == NULL.  */\n    result = u16_to_u32 (input, SIZEOF (input), NULL, &length);\n    ASSERT (result == NULL);\n    ASSERT (errno == EILSEQ);\n\n    /* Test return conventions with resultbuf too small.  */\n    length = 1;\n    result = u16_to_u32 (input, SIZEOF (input), preallocated, &length);\n    ASSERT (result == NULL);\n    ASSERT (errno == EILSEQ);\n\n    /* Test return conventions with resultbuf large enough.  */\n    length = SIZEOF (preallocated);\n    result = u16_to_u32 (input, SIZEOF (input), preallocated, &length);\n    ASSERT (result == NULL);\n    ASSERT (errno == EILSEQ);\n#endif\n  }\n\n  return 0;\n}",
      "lines": 72,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-to-u8.c": {
    "check": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "static int\ncheck (const uint16_t *input, size_t input_length,\n       const uint8_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint8_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u16_to_u8 (input, input_length, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u8_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint8_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint8_t *) malloc (length * sizeof (uint8_t));\n      result = u16_to_u8 (input, input_length, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u8_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint8_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint8_t *) malloc (length * sizeof (uint8_t));\n    result = u16_to_u8 (input, input_length, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u8_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Empty string.  */\n  ASSERT (check (NULL, 0, NULL, 0) == 0);\n\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint16_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    static const uint8_t expected[] =\n      { 'G', 'r', 0xC3, 0xBC, 0xC3, 0x9F, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0xD0, 0x97, 0xD0, 0xB4, 0xD1, 0x80, 0xD0, 0xB0, 0xD0, 0xB2, 0xD1, 0x81,\n        0xD1, 0x82, 0xD0, 0xB2, 0xD1, 0x83, 0xD0, 0xB9, 0xD1, 0x82, 0xD0, 0xB5,\n        '!', ' ', 'x', '=', '(', '-', 'b', 0xC2, 0xB1, 's', 'q', 'r', 't', '(',\n        'b', 0xC2, 0xB2, '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')',\n        ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC, 0xE8, 0xAA, 0x9E, ',',\n        0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xED, 0x95, 0x9C, 0xEA, 0xB8, 0x80, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  /* String with characters outside the BMP.  */\n  {\n    static const uint16_t input[] =\n      { '-', '(', 0xD835, 0xDD1E, 0x00D7, 0xD835, 0xDD1F, ')', '=',\n        0xD835, 0xDD1F, 0x00D7, 0xD835, 0xDD1E\n      };\n    static const uint8_t expected[] =\n      { '-', '(', 0xF0, 0x9D, 0x94, 0x9E, 0xC3, 0x97, 0xF0, 0x9D, 0x94, 0x9F,\n        ')', '=', 0xF0, 0x9D, 0x94, 0x9F, 0xC3, 0x97, 0xF0, 0x9D, 0x94, 0x9E\n      };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  /* Invalid input.  */\n  {\n    static const uint16_t input[] = { 'x', 0xDD1E, 0xD835, 'y' };\n#if 0 /* Currently invalid input is rejected, not accommodated.  */\n    static const uint8_t expected[] =\n      { 'x', 0xEF, 0xBF, 0xBD, 0xEF, 0xBF, 0xBD, 'y' };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n#else\n    size_t length;\n    uint8_t *result;\n    uint8_t preallocated[10];\n\n    /* Test return conventions with resultbuf == NULL.  */\n    result = u16_to_u8 (input, SIZEOF (input), NULL, &length);\n    ASSERT (result == NULL);\n    ASSERT (errno == EILSEQ);\n\n    /* Test return conventions with resultbuf too small.  */\n    length = 1;\n    result = u16_to_u8 (input, SIZEOF (input), preallocated, &length);\n    ASSERT (result == NULL);\n    ASSERT (errno == EILSEQ);\n\n    /* Test return conventions with resultbuf large enough.  */\n    length = SIZEOF (preallocated);\n    result = u16_to_u8 (input, SIZEOF (input), preallocated, &length);\n    ASSERT (result == NULL);\n    ASSERT (errno == EILSEQ);\n#endif\n  }\n\n  return 0;\n}",
      "lines": 75,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u16-uctomb.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Test ISO 646 character, in particular the NUL character.  */\n  {\n    ucs4_t uc;\n\n    for (uc = 0; uc < 0x80; uc++)\n      {\n        uint16_t buf[3] = { MAGIC, MAGIC, MAGIC };\n        int ret;\n\n        ret = u16_uctomb (buf, uc, 0);\n        ASSERT (ret == -2);\n        ASSERT (buf[0] == MAGIC);\n\n        ret = u16_uctomb (buf, uc, 1);\n        ASSERT (ret == 1);\n        ASSERT (buf[0] == uc);\n        ASSERT (buf[1] == MAGIC);\n      }\n  }\n\n  /* Test BMP character.  */\n  {\n    ucs4_t uc = 0x20AC;\n    uint16_t buf[3] = { MAGIC, MAGIC, MAGIC };\n    int ret;\n\n    ret = u16_uctomb (buf, uc, 0);\n    ASSERT (ret == -2);\n    ASSERT (buf[0] == MAGIC);\n\n    ret = u16_uctomb (buf, uc, 1);\n    ASSERT (ret == 1);\n    ASSERT (buf[0] == uc);\n    ASSERT (buf[1] == MAGIC);\n  }\n\n  /* Test non-BMP character.  */\n  {\n    ucs4_t uc = 0x10FFFD;\n    uint16_t buf[3] = { MAGIC, MAGIC, MAGIC };\n    int ret;\n\n    ret = u16_uctomb (buf, uc, 0);\n    ASSERT (ret == -2);\n    ASSERT (buf[0] == MAGIC);\n\n    ret = u16_uctomb (buf, uc, 1);\n    ASSERT (ret == -2);\n    ASSERT (buf[0] == MAGIC);\n\n    ret = u16_uctomb (buf, uc, 2);\n    ASSERT (ret == 2);\n    ASSERT (buf[0] == 0xDBFF);\n    ASSERT (buf[1] == 0xDFFD);\n    ASSERT (buf[2] == MAGIC);\n  }\n\n  /* Test invalid characters.  */\n  {\n    ucs4_t invalid[] = { 0x110000, 0xD800, 0xDBFF, 0xDC00, 0xDFFF };\n    uint16_t buf[3] = { MAGIC, MAGIC, MAGIC };\n    size_t i;\n\n    for (i = 0; i < SIZEOF (invalid); i++)\n      {\n        ucs4_t uc = invalid[i];\n        int n;\n\n        for (n = 0; n <= 2; n++)\n          {\n            int ret = u16_uctomb (buf, uc, n);\n            ASSERT (ret == -1);\n            ASSERT (buf[0] == MAGIC);\n            ASSERT (buf[1] == MAGIC);\n            ASSERT (buf[2] == MAGIC);\n          }\n      }\n  }\n\n  return 0;\n}",
      "lines": 84,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-check.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Test empty string.  */\n  {\n    static const uint32_t input[] = { 0 };\n    ASSERT (u32_check (input, 0) == NULL);\n  }\n\n  /* Test valid non-empty string.  */\n  {\n    static const uint32_t input[] = /* \"\u00d0\u0094\u00d0\u00b0\u00d0\u00bd\u00d0\u00b8\u00d0\u00bb\u00d0\u00be \u00d0\u00a8\u00d0\u00b5\u00d0\u00b3\u00d0\u00b0\u00d0\u00bd\" */\n      { 0x0414, 0x0430, 0x043D, 0x0438, 0x043B, 0x043E, 0x0020, 0x0428, 0x0435, 0x0433, 0x0430, 0x043D };\n    ASSERT (u32_check (input, SIZEOF (input)) == NULL);\n  }\n\n  /* Test out-of-range character with 1 unit: U+110000.  */\n  {\n    static const uint32_t input[] = { 0x0414, 0x0430, 0x110000 };\n    ASSERT (u32_check (input, SIZEOF (input)) == input + 2);\n  }\n\n  /* Test surrogate codepoints.  */\n  {\n    static const uint32_t input[] = { 0x0414, 0x0430, 0xDBFF, 0xDFFF };\n    ASSERT (u32_check (input, SIZEOF (input)) == input + 2);\n  }\n  {\n    static const uint32_t input[] = { 0x0414, 0x0430, 0xDBFF };\n    ASSERT (u32_check (input, SIZEOF (input)) == input + 2);\n  }\n  {\n    static const uint32_t input[] = { 0x0414, 0x0430, 0xDFFF };\n    ASSERT (u32_check (input, SIZEOF (input)) == input + 2);\n  }\n  {\n    static const uint32_t input[] = { 0x0414, 0x0430, 0xDFFF, 0xDBFF };\n    ASSERT (u32_check (input, SIZEOF (input)) == input + 2);\n  }\n\n  return 0;\n}",
      "lines": 42,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-chr.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-cmp.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "int\nmain ()\n{\n  test_cmp ();\n\n  /* Test comparison with non-BMP characters.  */\n  {\n    static const UNIT input1[] = { 0x1D51F };\n    static const UNIT input2[] = { 0xFEFF };\n    ASSERT (U_CMP (input1, input2, 1) > 0);\n    ASSERT (U_CMP (input2, input1, 1) < 0);\n  }\n\n  return 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-cmp2.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-cpy-alloc.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-cpy.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-mblen.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int\nmain ()\n{\n  int ret;\n\n  /* Test zero-length input.  */\n  {\n    static const uint32_t input[] = { 0 };\n    ret = u32_mblen (input, 0);\n    ASSERT (ret == -1);\n  }\n\n  /* Test NUL unit input.  */\n  {\n    static const uint32_t input[] = { 0 };\n    ret = u32_mblen (input, 1);\n    ASSERT (ret == 0);\n  }\n\n  /* Test ISO 646 unit input.  */\n  {\n    ucs4_t c;\n    uint32_t buf[1];\n\n    for (c = 1; c < 0x80; c++)\n      {\n        buf[0] = c;\n        ret = u32_mblen (buf, 1);\n        ASSERT (ret == 1);\n      }\n  }\n\n  /* Test BMP unit input.  */\n  {\n    static const uint32_t input[] = { 0x20AC };\n    ret = u32_mblen (input, 1);\n    ASSERT (ret == 1);\n  }\n\n  /* Test non-BMP unit input.  */\n  {\n    static const uint32_t input[] = { 0x1D51F };\n    ret = u32_mblen (input, 1);\n    ASSERT (ret == 1);\n  }\n\n  /* Test incomplete/invalid 1-unit input.  */\n  {\n    static const uint32_t input[] = { 0x340000 };\n    ret = u32_mblen (input, 1);\n    ASSERT (ret == -1);\n  }\n\n  return 0;\n}",
      "lines": 55,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-mbsnlen.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\nmain ()\n{\n\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint32_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    size_t n;\n\n    for (n = 0; n <= SIZEOF (input); n++)\n      {\n        size_t len = u32_mbsnlen (input, n);\n        ASSERT (len == n);\n      }\n  }\n\n  /* String with characters outside the BMP.  */\n  {\n    static const uint32_t input[] =\n      { '-', '(', 0x1D51E, 0x00D7, 0x1D51F, ')', '=',\n        0x1D51F, 0x00D7, 0x1D51E\n      };\n    size_t n;\n\n    for (n = 0; n <= SIZEOF (input); n++)\n      {\n        size_t len = u32_mbsnlen (input, n);\n        ASSERT (len == n);\n      }\n  }\n  return 0;\n}",
      "lines": 39,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-mbtouc-unsafe.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nmain ()\n{\n  test_function (u32_mbtouc_unsafe);\n\n  return 0;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-mbtouc.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nmain ()\n{\n  test_function (u32_mbtouc);\n\n  return 0;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-mbtouc.h": {
    "test_function": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static void\ntest_function (int (*my_u32_mbtouc) (ucs4_t *, const uint32_t *, size_t))\n{\n  ucs4_t uc;\n  int ret;\n\n  /* Test NUL unit input.  */\n  {\n    static const uint32_t input[] = { 0 };\n    uc = 0xBADFACE;\n    ret = my_u32_mbtouc (&uc, input, 1);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0);\n  }\n\n  /* Test ISO 646 unit input.  */\n  {\n    ucs4_t c;\n    uint32_t buf[1];\n\n    for (c = 0; c < 0x80; c++)\n      {\n        buf[0] = c;\n        uc = 0xBADFACE;\n        ret = my_u32_mbtouc (&uc, buf, 1);\n        ASSERT (ret == 1);\n        ASSERT (uc == c);\n      }\n  }\n\n  /* Test BMP unit input.  */\n  {\n    static const uint32_t input[] = { 0x20AC };\n    uc = 0xBADFACE;\n    ret = my_u32_mbtouc (&uc, input, 1);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0x20AC);\n  }\n\n  /* Test non-BMP unit input.  */\n  {\n    static const uint32_t input[] = { 0x1D51F };\n    uc = 0xBADFACE;\n    ret = my_u32_mbtouc (&uc, input, 1);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0x1D51F);\n  }\n\n  /* Test incomplete/invalid 1-unit input.  */\n  {\n    static const uint32_t input[] = { 0x340000 };\n    uc = 0xBADFACE;\n    ret = my_u32_mbtouc (&uc, input, 1);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0xFFFD);\n  }\n}",
      "lines": 57,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-mbtoucr.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "int\nmain ()\n{\n  ucs4_t uc;\n  int ret;\n\n  /* Test NUL unit input.  */\n  {\n    static const uint32_t input[] = { 0 };\n    uc = 0xBADFACE;\n    ret = u32_mbtoucr (&uc, input, 1);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0);\n  }\n\n  /* Test ISO 646 unit input.  */\n  {\n    ucs4_t c;\n    uint32_t buf[1];\n\n    for (c = 0; c < 0x80; c++)\n      {\n        buf[0] = c;\n        uc = 0xBADFACE;\n        ret = u32_mbtoucr (&uc, buf, 1);\n        ASSERT (ret == 1);\n        ASSERT (uc == c);\n      }\n  }\n\n  /* Test BMP unit input.  */\n  {\n    static const uint32_t input[] = { 0x20AC };\n    uc = 0xBADFACE;\n    ret = u32_mbtoucr (&uc, input, 1);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0x20AC);\n  }\n\n  /* Test non-BMP unit input.  */\n  {\n    static const uint32_t input[] = { 0x1D51F };\n    uc = 0xBADFACE;\n    ret = u32_mbtoucr (&uc, input, 1);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0x1D51F);\n  }\n\n  /* Test incomplete/invalid 1-unit input.  */\n  {\n    static const uint32_t input[] = { 0x340000 };\n    uc = 0xBADFACE;\n    ret = u32_mbtoucr (&uc, input, 1);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xFFFD);\n  }\n\n  return 0;\n}",
      "lines": 59,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-move.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-next.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "int\nmain ()\n{\n  ucs4_t uc;\n  const uint32_t *ret;\n\n  /* Test NUL unit input.  */\n  {\n    static const uint32_t input[] = { 0 };\n    uc = 0xBADFACE;\n    ret = u32_next (&uc, input);\n    ASSERT (ret == NULL);\n    ASSERT (uc == 0);\n  }\n\n  /* Test ISO 646 unit input.  */\n  {\n    ucs4_t c;\n    uint32_t buf[2];\n\n    for (c = 1; c < 0x80; c++)\n      {\n        buf[0] = c;\n        buf[1] = 0;\n        uc = 0xBADFACE;\n        ret = u32_next (&uc, buf);\n        ASSERT (ret == buf + 1);\n        ASSERT (uc == c);\n      }\n  }\n\n  /* Test BMP unit input.  */\n  {\n    static const uint32_t input[] = { 0x20AC, 0 };\n    uc = 0xBADFACE;\n    ret = u32_next (&uc, input);\n    ASSERT (ret == input + 1);\n    ASSERT (uc == 0x20AC);\n  }\n\n  /* Test non-BMP unit input.  */\n  {\n    static const uint32_t input[] = { 0x1D51F, 0 };\n    uc = 0xBADFACE;\n    ret = u32_next (&uc, input);\n    ASSERT (ret == input + 1);\n    ASSERT (uc == 0x1D51F);\n  }\n\n  /* Test incomplete/invalid 1-unit input.  */\n  {\n    static const uint32_t input[] = { 0x340000, 0 };\n    uc = 0xBADFACE;\n    ret = u32_next (&uc, input);\n    ASSERT (ret == NULL);\n    ASSERT (uc == 0xFFFD);\n  }\n\n  return 0;\n}",
      "lines": 60,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-prev.c": {
    "check": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static int\ncheck (const uint32_t *input, size_t input_length, ucs4_t *puc)\n{\n  ucs4_t uc;\n\n  /* Test recognition when at the beginning of the string.  */\n  if (u32_prev (&uc, input + input_length, input) != input)\n    return 1;\n\n  /* Test recognition when preceded by a 1-unit character.  */\n  {\n    uint32_t buf[100];\n    uint32_t *ptr;\n    size_t i;\n    ucs4_t uc1;\n\n    ptr = buf;\n    *ptr++ = 0x1D51E;\n    for (i = 0; i < input_length; i++)\n      ptr[i] = input[i];\n\n    if (u32_prev (&uc1, ptr + input_length, buf) != ptr)\n      return 2;\n    if (uc1 != uc)\n      return 3;\n  }\n\n  *puc = uc;\n  return 0;\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_invalid": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static int\ncheck_invalid (const uint32_t *input, size_t input_length)\n{\n  ucs4_t uc;\n\n  /* Test recognition when at the beginning of the string.  */\n  uc = 0xBADFACE;\n  if (u32_prev (&uc, input + input_length, input) != NULL)\n    return 1;\n  if (uc != 0xBADFACE)\n    return 2;\n\n  /* Test recognition when preceded by a 1-unit character.  */\n  {\n    uint32_t buf[100];\n    uint32_t *ptr;\n    size_t i;\n\n    ptr = buf;\n    *ptr++ = 0x1D51E;\n    for (i = 0; i < input_length; i++)\n      ptr[i] = input[i];\n\n    uc = 0xBADFACE;\n    if (u32_prev (&uc, ptr + input_length, buf) != NULL)\n      return 3;\n    if (uc != 0xBADFACE)\n      return 4;\n  }\n\n  return 0;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "int\nmain ()\n{\n  ucs4_t uc;\n\n  /* Test ISO 646 unit input.  */\n  {\n    ucs4_t c;\n    uint32_t buf[1];\n\n    for (c = 0; c < 0x80; c++)\n      {\n        buf[0] = c;\n        uc = 0xBADFACE;\n        ASSERT (check (buf, 1, &uc) == 0);\n        ASSERT (uc == c);\n      }\n  }\n\n  /* Test BMP unit input.  */\n  {\n    static const uint32_t input[] = { 0x20AC };\n    uc = 0xBADFACE;\n    ASSERT (check (input, SIZEOF (input), &uc) == 0);\n    ASSERT (uc == 0x20AC);\n  }\n\n  /* Test non-BMP unit input.  */\n  {\n    static const uint32_t input[] = { 0x1D51F };\n    uc = 0xBADFACE;\n    ASSERT (check (input, SIZEOF (input), &uc) == 0);\n    ASSERT (uc == 0x1D51F);\n  }\n\n  /* Test incomplete/invalid 1-unit input.  */\n  {\n    static const uint32_t input[] = { 0x340000 };\n    ASSERT (check_invalid (input, SIZEOF (input)) == 0);\n  }\n\n  return 0;\n}",
      "lines": 43,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-set.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-stpcpy.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-stpncpy.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint32_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, 0\n      };\n    check (input, SIZEOF (input));\n  }\n\n  /* String with characters outside the BMP.  */\n  {\n    static const uint32_t input[] =\n      { '-', '(', 0x1D51E, 0x00D7, 0x1D51F, ')', '=',\n        0x1D51F, 0x00D7, 0x1D51E, 0\n      };\n    check (input, SIZEOF (input));\n  }\n\n  return 0;\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-strcat.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-strchr.c": {
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "int\nmain (void)\n{\n  test_strchr ();\n\n  return 0;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-strcmp.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\nmain ()\n{\n  test_u32_strcmp ();\n\n  return 0;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-strcmp.h": {
    "test_u32_strcmp": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "static void\ntest_u32_strcmp (void)\n{\n  test_strcmp ();\n\n  /* Test comparison between ASCII and non-ASCII characters.  */\n  {\n    static const UNIT input1[] = { 'f', 'o', 'o', 0 };\n    static const UNIT input2[] = { 0x2022, 0 };\n    ASSERT (U_STRCMP (input1, input2) < 0);\n    ASSERT (U_STRCMP (input2, input1) > 0);\n  }\n\n  /* Test comparison with non-BMP characters.  */\n  {\n    static const UNIT input1[] = { 0x1D51F, 0 };\n    static const UNIT input2[] = { 0xFEFF, 0 };\n    ASSERT (U_STRCMP (input1, input2) > 0);\n    ASSERT (U_STRCMP (input2, input1) < 0);\n  }\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-strcoll.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\nmain ()\n{\n  /* This test relies on three facts:\n     - setlocale is not being called, therefore the locale is the \"C\" locale.\n     - In the \"C\" locale, strcoll is equivalent to strcmp.\n     - In the u32_strcoll implementation, Unicode strings that are not\n       convertible to the locale encoding are sorted higher than convertible\n       strings and compared according to u32_strcmp.  */\n\n  test_u32_strcmp ();\n\n  return 0;\n}",
      "lines": 14,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-strcpy.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-strdup.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-strlen.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Empty string.  */\n  {\n    static const uint32_t input[] = { 0 };\n    ASSERT (u32_strlen (input) == 0);\n  }\n\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint32_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, 0\n      };\n    ASSERT (u32_strlen (input) == SIZEOF (input) - 1);\n  }\n\n  /* String with characters outside the BMP.  */\n  {\n    static const uint32_t input[] =\n      { '-', '(', 0x1D51E, 0x00D7, 0x1D51F, ')', '=',\n        0x1D51F, 0x00D7, 0x1D51E, 0\n      };\n    ASSERT (u32_strlen (input) == SIZEOF (input) - 1);\n  }\n\n  return 0;\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-strmblen.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "int\nmain ()\n{\n  int ret;\n\n  /* Test NUL unit input.  */\n  {\n    static const uint32_t input[] = { 0 };\n    ret = u32_strmblen (input);\n    ASSERT (ret == 0);\n  }\n\n  /* Test ISO 646 unit input.  */\n  {\n    ucs4_t c;\n    uint32_t buf[2];\n\n    for (c = 1; c < 0x80; c++)\n      {\n        buf[0] = c;\n        buf[1] = 0;\n        ret = u32_strmblen (buf);\n        ASSERT (ret == 1);\n      }\n  }\n\n  /* Test BMP unit input.  */\n  {\n    static const uint32_t input[] = { 0x20AC, 0 };\n    ret = u32_strmblen (input);\n    ASSERT (ret == 1);\n  }\n\n  /* Test non-BMP unit input.  */\n  {\n    static const uint32_t input[] = { 0x1D51F, 0 };\n    ret = u32_strmblen (input);\n    ASSERT (ret == 1);\n  }\n\n  /* Test incomplete/invalid 1-unit input.  */\n  {\n    static const uint32_t input[] = { 0x340000, 0 };\n    ret = u32_strmblen (input);\n    ASSERT (ret == -1);\n  }\n\n  return 0;\n}",
      "lines": 49,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-strmbtouc.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "int\nmain ()\n{\n  ucs4_t uc;\n  int ret;\n\n  /* Test NUL unit input.  */\n  {\n    static const uint32_t input[] = { 0 };\n    uc = 0xBADFACE;\n    ret = u32_strmbtouc (&uc, input);\n    ASSERT (ret == 0);\n    ASSERT (uc == 0);\n  }\n\n  /* Test ISO 646 unit input.  */\n  {\n    ucs4_t c;\n    uint32_t buf[2];\n\n    for (c = 1; c < 0x80; c++)\n      {\n        buf[0] = c;\n        buf[1] = 0;\n        uc = 0xBADFACE;\n        ret = u32_strmbtouc (&uc, buf);\n        ASSERT (ret == 1);\n        ASSERT (uc == c);\n      }\n  }\n\n  /* Test BMP unit input.  */\n  {\n    static const uint32_t input[] = { 0x20AC, 0 };\n    uc = 0xBADFACE;\n    ret = u32_strmbtouc (&uc, input);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0x20AC);\n  }\n\n  /* Test non-BMP unit input.  */\n  {\n    static const uint32_t input[] = { 0x1D51F, 0 };\n    uc = 0xBADFACE;\n    ret = u32_strmbtouc (&uc, input);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0x1D51F);\n  }\n\n  /* Test incomplete/invalid 1-unit input.  */\n  {\n    static const uint32_t input[] = { 0x340000, 0 };\n    uc = 0xBADFACE;\n    ret = u32_strmbtouc (&uc, input);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xBADFACE);\n  }\n\n  return 0;\n}",
      "lines": 60,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-strncat.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint32_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, 0\n      };\n    check (input, SIZEOF (input));\n  }\n\n  /* String with characters outside the BMP.  */\n  {\n    static const uint32_t input[] =\n      { '-', '(', 0x1D51E, 0x00D7, 0x1D51F, ')', '=',\n        0x1D51F, 0x00D7, 0x1D51E, 0\n      };\n    check (input, SIZEOF (input));\n  }\n\n  return 0;\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-strncmp.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "int\nmain ()\n{\n  test_strncmp ();\n\n  /* Test comparison with non-BMP characters.  */\n  {\n    static const UNIT input1[] = { 0x1D51F, 0 };\n    static const UNIT input2[] = { 0xFEFF, 0 };\n    ASSERT (U_STRNCMP (input1, input2, 1) > 0);\n    ASSERT (U_STRNCMP (input2, input1, 1) < 0);\n    ASSERT (U_STRNCMP (input1, input2, 2) > 0);\n    ASSERT (U_STRNCMP (input2, input1, 2) < 0);\n    ASSERT (U_STRNCMP (input1, input2, 1000000) > 0);\n    ASSERT (U_STRNCMP (input2, input1, 1000000) < 0);\n  }\n\n  return 0;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-strncpy.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint32_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, 0\n      };\n    check (input, SIZEOF (input));\n  }\n\n  /* String with characters outside the BMP.  */\n  {\n    static const uint32_t input[] =\n      { '-', '(', 0x1D51E, 0x00D7, 0x1D51F, ')', '=',\n        0x1D51F, 0x00D7, 0x1D51E, 0\n      };\n    check (input, SIZEOF (input));\n  }\n\n  return 0;\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-strnlen.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint32_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, 0\n      };\n    check (input, SIZEOF (input));\n  }\n\n  /* String with characters outside the BMP.  */\n  {\n    static const uint32_t input[] =\n      { '-', '(', 0x1D51E, 0x00D7, 0x1D51F, ')', '=',\n        0x1D51F, 0x00D7, 0x1D51E, 0\n      };\n    check (input, SIZEOF (input));\n  }\n\n  return 0;\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-strstr.c": {
    "main": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "int\nmain (void)\n{\n#if HAVE_DECL_ALARM\n  /* Declare failure if test takes too long, by using default abort\n     caused by SIGALRM.  */\n  signal (SIGALRM, SIG_DFL);\n  alarm (10);\n#endif\n\n  test_u_strstr ();\n\n  return 0;\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-strtok.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int\nmain (void)\n{\n  test_u_strtok ();\n\n  return 0;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-to-u16.c": {
    "check": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "static int\ncheck (const uint32_t *input, size_t input_length,\n       const uint16_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint16_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u32_to_u16 (input, input_length, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u16_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint16_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint16_t *) malloc (length * sizeof (uint16_t));\n      result = u32_to_u16 (input, input_length, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u16_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint16_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint16_t *) malloc (length * sizeof (uint16_t));\n    result = u32_to_u16 (input, input_length, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u16_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Empty string.  */\n  ASSERT (check (NULL, 0, NULL, 0) == 0);\n\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint32_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    static const uint16_t expected[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  /* String with characters outside the BMP.  */\n  {\n    static const uint32_t input[] =\n      { '-', '(', 0x1D51E, 0x00D7, 0x1D51F, ')', '=',\n        0x1D51F, 0x00D7, 0x1D51E\n      };\n    static const uint16_t expected[] =\n      { '-', '(', 0xD835, 0xDD1E, 0x00D7, 0xD835, 0xDD1F, ')', '=',\n        0xD835, 0xDD1F, 0x00D7, 0xD835, 0xDD1E\n      };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  /* Invalid input.  */\n  {\n    static const uint32_t input[] = { 'x', 0x340000, 0x50000000, 'y' };\n#if 0 /* Currently invalid input is rejected, not accommodated.  */\n    static const uint16_t expected[] = { 'x', 0xFFFD, 0xFFFD, 'y' };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n#else\n    size_t length;\n    uint16_t *result;\n    uint16_t preallocated[10];\n\n    /* Test return conventions with resultbuf == NULL.  */\n    result = u32_to_u16 (input, SIZEOF (input), NULL, &length);\n    ASSERT (result == NULL);\n    ASSERT (errno == EILSEQ);\n\n    /* Test return conventions with resultbuf too small.  */\n    length = 1;\n    result = u32_to_u16 (input, SIZEOF (input), preallocated, &length);\n    ASSERT (result == NULL);\n    ASSERT (errno == EILSEQ);\n\n    /* Test return conventions with resultbuf large enough.  */\n    length = SIZEOF (preallocated);\n    result = u32_to_u16 (input, SIZEOF (input), preallocated, &length);\n    ASSERT (result == NULL);\n    ASSERT (errno == EILSEQ);\n#endif\n  }\n\n  return 0;\n}",
      "lines": 72,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-to-u8.c": {
    "check": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "static int\ncheck (const uint32_t *input, size_t input_length,\n       const uint8_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint8_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u32_to_u8 (input, input_length, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u8_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint8_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint8_t *) malloc (length * sizeof (uint8_t));\n      result = u32_to_u8 (input, input_length, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u8_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint8_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint8_t *) malloc (length * sizeof (uint8_t));\n    result = u32_to_u8 (input, input_length, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u8_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Empty string.  */\n  ASSERT (check (NULL, 0, NULL, 0) == 0);\n\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint32_t input[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    static const uint8_t expected[] =\n      { 'G', 'r', 0xC3, 0xBC, 0xC3, 0x9F, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0xD0, 0x97, 0xD0, 0xB4, 0xD1, 0x80, 0xD0, 0xB0, 0xD0, 0xB2, 0xD1, 0x81,\n        0xD1, 0x82, 0xD0, 0xB2, 0xD1, 0x83, 0xD0, 0xB9, 0xD1, 0x82, 0xD0, 0xB5,\n        '!', ' ', 'x', '=', '(', '-', 'b', 0xC2, 0xB1, 's', 'q', 'r', 't', '(',\n        'b', 0xC2, 0xB2, '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')',\n        ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC, 0xE8, 0xAA, 0x9E, ',',\n        0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xED, 0x95, 0x9C, 0xEA, 0xB8, 0x80, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  /* String with characters outside the BMP.  */\n  {\n    static const uint32_t input[] =\n      { '-', '(', 0x1D51E, 0x00D7, 0x1D51F, ')', '=',\n        0x1D51F, 0x00D7, 0x1D51E\n      };\n    static const uint8_t expected[] =\n      { '-', '(', 0xF0, 0x9D, 0x94, 0x9E, 0xC3, 0x97, 0xF0, 0x9D, 0x94, 0x9F,\n        ')', '=', 0xF0, 0x9D, 0x94, 0x9F, 0xC3, 0x97, 0xF0, 0x9D, 0x94, 0x9E\n      };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  /* Invalid input.  */\n  {\n    static const uint32_t input[] = { 'x', 0x340000, 0x50000000, 'y' };\n#if 0 /* Currently invalid input is rejected, not accommodated.  */\n    static const uint8_t expected[] =\n      { 'x', 0xEF, 0xBF, 0xBD, 0xEF, 0xBF, 0xBD, 'y' };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n#else\n    size_t length;\n    uint8_t *result;\n    uint8_t preallocated[10];\n\n    /* Test return conventions with resultbuf == NULL.  */\n    result = u32_to_u8 (input, SIZEOF (input), NULL, &length);\n    ASSERT (result == NULL);\n    ASSERT (errno == EILSEQ);\n\n    /* Test return conventions with resultbuf too small.  */\n    length = 1;\n    result = u32_to_u8 (input, SIZEOF (input), preallocated, &length);\n    ASSERT (result == NULL);\n    ASSERT (errno == EILSEQ);\n\n    /* Test return conventions with resultbuf large enough.  */\n    length = SIZEOF (preallocated);\n    result = u32_to_u8 (input, SIZEOF (input), preallocated, &length);\n    ASSERT (result == NULL);\n    ASSERT (errno == EILSEQ);\n#endif\n  }\n\n  return 0;\n}",
      "lines": 75,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u32-uctomb.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Test ISO 646 character, in particular the NUL character.  */\n  {\n    ucs4_t uc;\n\n    for (uc = 0; uc < 0x80; uc++)\n      {\n        uint32_t buf[2] = { MAGIC, MAGIC };\n        int ret;\n\n        ret = u32_uctomb (buf, uc, 0);\n        ASSERT (ret == -2);\n        ASSERT (buf[0] == MAGIC);\n\n        ret = u32_uctomb (buf, uc, 1);\n        ASSERT (ret == 1);\n        ASSERT (buf[0] == uc);\n        ASSERT (buf[1] == MAGIC);\n      }\n  }\n\n  /* Test BMP character.  */\n  {\n    ucs4_t uc = 0x20AC;\n    uint32_t buf[2] = { MAGIC, MAGIC };\n    int ret;\n\n    ret = u32_uctomb (buf, uc, 0);\n    ASSERT (ret == -2);\n    ASSERT (buf[0] == MAGIC);\n\n    ret = u32_uctomb (buf, uc, 1);\n    ASSERT (ret == 1);\n    ASSERT (buf[0] == uc);\n    ASSERT (buf[1] == MAGIC);\n  }\n\n  /* Test non-BMP character.  */\n  {\n    ucs4_t uc = 0x10FFFD;\n    uint32_t buf[2] = { MAGIC, MAGIC };\n    int ret;\n\n    ret = u32_uctomb (buf, uc, 0);\n    ASSERT (ret == -2);\n    ASSERT (buf[0] == MAGIC);\n\n    ret = u32_uctomb (buf, uc, 1);\n    ASSERT (ret == 1);\n    ASSERT (buf[0] == uc);\n    ASSERT (buf[1] == MAGIC);\n  }\n\n  /* Test invalid characters.  */\n  {\n    ucs4_t invalid[] = { 0x110000, 0xD800, 0xDBFF, 0xDC00, 0xDFFF };\n    uint32_t buf[2] = { MAGIC, MAGIC };\n    size_t i;\n\n    for (i = 0; i < SIZEOF (invalid); i++)\n      {\n        ucs4_t uc = invalid[i];\n        int n;\n\n        for (n = 0; n <= 2; n++)\n          {\n            int ret = u32_uctomb (buf, uc, n);\n            ASSERT (ret == -1);\n            ASSERT (buf[0] == MAGIC);\n            ASSERT (buf[1] == MAGIC);\n          }\n      }\n  }\n\n  return 0;\n}",
      "lines": 78,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-check.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Test empty string.  */\n  {\n    static const uint8_t input[] = \"\";\n    ASSERT (u8_check (input, 0) == NULL);\n  }\n\n  /* Test valid non-empty string.  */\n  {\n    static const uint8_t input[] = /* \"\u00d0\u0094\u00d0\u00b0\u00d0\u00bd\u00d0\u00b8\u00d0\u00bb\u00d0\u00be \u00d0\u00a8\u00d0\u00b5\u00d0\u00b3\u00d0\u00b0\u00d0\u00bd\" */\n      \"\\320\\224\\320\\260\\320\\275\\320\\270\\320\\273\\320\\276 \\320\\250\\320\\265\\320\\263\\320\\260\\320\\275\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == NULL);\n  }\n\n  /* Test out-of-range character with 4 bytes: U+110000.  */\n  {\n    static const uint8_t input[] = \"\\320\\224\\320\\260\\364\\220\\200\\200\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);\n  }\n\n  /* Test out-of-range character with 5 bytes: U+200000.  */\n  {\n    static const uint8_t input[] = \"\\320\\224\\320\\260\\370\\210\\200\\200\\200\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);\n  }\n\n  /* Test out-of-range character with 6 bytes: U+4000000.  */\n  {\n    static const uint8_t input[] = \"\\320\\224\\320\\260\\374\\204\\200\\200\\200\\200\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);\n  }\n\n  /* Test invalid lead byte.  */\n  {\n    static const uint8_t input[] = \"\\320\\224\\320\\260\\376\\200\\200\\200\\200\\200\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);\n  }\n  {\n    static const uint8_t input[] = \"\\320\\224\\320\\260\\377\\200\\200\\200\\200\\200\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);\n  }\n\n  /* Test overlong 2-byte character.  */\n  {\n    static const uint8_t input[] = \"\\320\\224\\320\\260\\301\\200\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);\n  }\n\n  /* Test overlong 3-byte character.  */\n  {\n    static const uint8_t input[] = \"\\320\\224\\320\\260\\340\\200\\277\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);\n  }\n\n  /* Test overlong 4-byte character.  */\n  {\n    static const uint8_t input[] = \"\\320\\224\\320\\260\\360\\200\\277\\277\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);\n  }\n\n  /* Test invalid bytes in 2-byte character.  */\n  {\n    static const uint8_t input[] = \"\\320\\224\\320\\260\\302\\200\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == NULL);\n  }\n  {\n    static const uint8_t input[] = \"\\320\\224\\320\\260\\302\\100\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);\n  }\n  {\n    static const uint8_t input[] = \"\\320\\224\\320\\260\\302\\300\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);\n  }\n\n  /* Test invalid bytes in 3-byte character.  */\n  {\n    static const uint8_t input[] = \"\\320\\224\\320\\260\\342\\200\\200\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == NULL);\n  }\n  {\n    static const uint8_t input[] = \"\\320\\224\\320\\260\\342\\100\\200\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);\n  }\n  {\n    static const uint8_t input[] = \"\\320\\224\\320\\260\\342\\300\\200\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);\n  }\n  {\n    static const uint8_t input[] = \"\\320\\224\\320\\260\\342\\200\\100\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);\n  }\n  {\n    static const uint8_t input[] = \"\\320\\224\\320\\260\\342\\200\\300\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);\n  }\n\n  /* Test invalid bytes in 4-byte character.  */\n  {\n    static const uint8_t input[] = \"\\320\\224\\320\\260\\362\\200\\200\\200\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == NULL);\n  }\n  {\n    static const uint8_t input[] = \"\\320\\224\\320\\260\\362\\100\\200\\200\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);\n  }\n  {\n    static const uint8_t input[] = \"\\320\\224\\320\\260\\362\\300\\200\\200\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);\n  }\n  {\n    static const uint8_t input[] = \"\\320\\224\\320\\260\\362\\200\\100\\200\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);\n  }\n  {\n    static const uint8_t input[] = \"\\320\\224\\320\\260\\362\\200\\300\\200\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);\n  }\n  {\n    static const uint8_t input[] = \"\\320\\224\\320\\260\\362\\200\\200\\100\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);\n  }\n  {\n    static const uint8_t input[] = \"\\320\\224\\320\\260\\362\\200\\200\\300\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);\n  }\n\n  /* Test truncated/incomplete 2-byte character.  */\n  {\n    static const uint8_t input[] = \"\\320\\224\\320\\260\\302\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);\n  }\n\n  /* Test truncated/incomplete 3-byte character.  */\n  {\n    static const uint8_t input[] = \"\\320\\224\\320\\260\\342\\200\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);\n  }\n\n  /* Test truncated/incomplete 4-byte character.  */\n  {\n    static const uint8_t input[] = \"\\320\\224\\320\\260\\362\\200\\200\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);\n  }\n\n  /* Test missing lead byte.  */\n  {\n    static const uint8_t input[] = \"\\320\\224\\320\\260\\200\\200\\200\\200\\200\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);\n  }\n\n  /* Test surrogate codepoints.  */\n  {\n    static const uint8_t input[] = \"\\320\\224\\320\\260\\355\\240\\200\\355\\260\\200\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);\n  }\n  {\n    static const uint8_t input[] = \"\\320\\224\\320\\260\\355\\260\\200\";\n    ASSERT (u8_check (input, sizeof (input) - 1) == input + 4);\n  }\n\n  return 0;\n}",
      "lines": 164,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-chr.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-cmp.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "int\nmain ()\n{\n  test_cmp ();\n\n  /* Test comparison with non-BMP characters.  */\n  {\n    static const UNIT input1[] = { 0xF0, 0x9D, 0x94, 0x9E };\n    static const UNIT input2[] = { 0xEF, 0xBB, 0xBF, 0x00 };\n    ASSERT (U_CMP (input1, input2, 4) > 0);\n    ASSERT (U_CMP (input2, input1, 4) < 0);\n  }\n\n  return 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-cmp2.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-cpy-alloc.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-cpy.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-mblen.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "int\nmain ()\n{\n  int ret;\n\n  /* Test zero-length input.  */\n  {\n    static const uint8_t input[] = \"\";\n    ret = u8_mblen (input, 0);\n    ASSERT (ret == -1);\n  }\n\n  /* Test NUL unit input.  */\n  {\n    static const uint8_t input[] = \"\";\n    ret = u8_mblen (input, 1);\n    ASSERT (ret == 0);\n  }\n\n  /* Test ISO 646 unit input.  */\n  {\n    ucs4_t c;\n    uint8_t buf[1];\n\n    for (c = 1; c < 0x80; c++)\n      {\n        buf[0] = c;\n        ret = u8_mblen (buf, 1);\n        ASSERT (ret == 1);\n      }\n  }\n\n  /* Test 2-byte character input.  */\n  {\n    static const uint8_t input[] = { 0xC3, 0x97 };\n    ret = u8_mblen (input, 2);\n    ASSERT (ret == 2);\n  }\n\n  /* Test 3-byte character input.  */\n  {\n    static const uint8_t input[] = { 0xE2, 0x82, 0xAC };\n    ret = u8_mblen (input, 3);\n    ASSERT (ret == 3);\n  }\n\n  /* Test 4-byte character input.  */\n  {\n    static const uint8_t input[] = { 0xF4, 0x8F, 0xBF, 0xBD };\n    ret = u8_mblen (input, 4);\n    ASSERT (ret == 4);\n  }\n\n  /* Test incomplete/invalid 1-byte input.  */\n  {\n    static const uint8_t input[] = { 0xC1 };\n    ret = u8_mblen (input, 1);\n    ASSERT (ret == -1);\n  }\n  {\n    static const uint8_t input[] = { 0xC3 };\n    ret = u8_mblen (input, 1);\n    ASSERT (ret == -1);\n  }\n  {\n    static const uint8_t input[] = { 0xE2 };\n    ret = u8_mblen (input, 1);\n    ASSERT (ret == -1);\n  }\n  {\n    static const uint8_t input[] = { 0xF4 };\n    ret = u8_mblen (input, 1);\n    ASSERT (ret == -1);\n  }\n  {\n    static const uint8_t input[] = { 0xFE };\n    ret = u8_mblen (input, 1);\n    ASSERT (ret == -1);\n  }\n\n  /* Test incomplete/invalid 2-byte input.  */\n  {\n    static const uint8_t input[] = { 0xE0, 0x9F };\n    ret = u8_mblen (input, 2);\n    ASSERT (ret == -1);\n  }\n  {\n    static const uint8_t input[] = { 0xE2, 0x82 };\n    ret = u8_mblen (input, 2);\n    ASSERT (ret == -1);\n  }\n  {\n    static const uint8_t input[] = { 0xE2, 0xD0 };\n    ret = u8_mblen (input, 2);\n    ASSERT (ret == -1);\n  }\n  {\n    static const uint8_t input[] = { 0xF0, 0x8F };\n    ret = u8_mblen (input, 2);\n    ASSERT (ret == -1);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0x8F };\n    ret = u8_mblen (input, 2);\n    ASSERT (ret == -1);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0xD0 };\n    ret = u8_mblen (input, 2);\n    ASSERT (ret == -1);\n  }\n\n  /* Test incomplete/invalid 3-byte input.  */\n  {\n    static const uint8_t input[] = { 0xF3, 0x8F, 0xBF };\n    ret = u8_mblen (input, 3);\n    ASSERT (ret == -1);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0xD0, 0xBF };\n    ret = u8_mblen (input, 3);\n    ASSERT (ret == -1);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0x8F, 0xD0 };\n    ret = u8_mblen (input, 3);\n    ASSERT (ret == -1);\n  }\n\n  return 0;\n}",
      "lines": 131,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-mbsnlen.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint8_t input[] =\n      { 'G', 'r', 0xC3, 0xBC, 0xC3, 0x9F, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0xD0, 0x97, 0xD0, 0xB4, 0xD1, 0x80, 0xD0, 0xB0, 0xD0, 0xB2, 0xD1, 0x81,\n        0xD1, 0x82, 0xD0, 0xB2, 0xD1, 0x83, 0xD0, 0xB9, 0xD1, 0x82, 0xD0, 0xB5,\n        '!', ' ', 'x', '=', '(', '-', 'b', 0xC2, 0xB1, 's', 'q', 'r', 't', '(',\n        'b', 0xC2, 0xB2, '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')',\n        ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC, 0xE8, 0xAA, 0x9E, ',',\n        0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xED, 0x95, 0x9C, 0xEA, 0xB8, 0x80, '\\n'\n      };\n    static const size_t expected[SIZEOF (input) + 1] =\n      { 0,\n        1, 2, 3, 3, 4, 4, 5, 6, 7, 8, 9, 10, 11,\n        12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17,\n        18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23,\n        24, 25, 26, 27, 28, 29, 30, 31, 31, 32, 33, 34, 35, 36,\n        37, 38, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,\n        50, 51, 52, 52, 52, 53, 53, 53, 54, 54, 54, 55,\n        56, 56, 56, 57, 57, 57, 58,\n        59, 59, 59, 60, 60, 60, 61\n      };\n    size_t n;\n\n    for (n = 0; n <= SIZEOF (input); n++)\n      {\n        size_t len = u8_mbsnlen (input, n);\n        ASSERT (len == expected[n]);\n      }\n  }\n\n  /* Test behaviour required by ISO 10646-1, sections R.7 and 2.3c, namely,\n     that a \"malformed sequence\" is interpreted in the same way as\n     \"a character that is outside the adopted subset\".\n     Reference:\n       Markus Kuhn: UTF-8 decoder capability and stress test\n       <https://www.cl.cam.ac.uk/~mgk25/ucs/examples/UTF-8-test.txt>\n       <https://www.w3.org/2001/06/utf-8-wrong/UTF-8-test.html>\n   */\n  /* 3.1. Test that each unexpected continuation byte is signalled as a\n     malformed sequence of its own.  */\n  {\n    static const uint8_t input[] = { '\"', 0x80, 0xBF, 0x80, 0xBF, '\"' };\n    ASSERT (u8_mbsnlen (input, 6) == 6);\n  }\n  /* 3.2. Lonely start characters.  */\n  {\n    ucs4_t c;\n    uint8_t input[2];\n\n    for (c = 0xC0; c <= 0xFF; c++)\n      {\n        input[0] = c;\n        input[1] = ' ';\n\n        ASSERT (u8_mbsnlen (input, 2) == 2);\n      }\n  }\n  /* 3.3. Sequences with last continuation byte missing.  */\n  /* 3.3.1. 2-byte sequence with last byte missing.  */\n  {\n    static const uint8_t input[] = { '\"', 0xC0, '\"' };\n    ASSERT (u8_mbsnlen (input, 3) == 3);\n  }\n  /* 3.3.6. 2-byte sequence with last byte missing.  */\n  {\n    static const uint8_t input[] = { '\"', 0xDF, '\"' };\n    ASSERT (u8_mbsnlen (input, 3) == 3);\n  }\n  /* 3.3.2. 3-byte sequence with last byte missing.  */\n  {\n    static const uint8_t input[] = { '\"', 0xE0, 0x80, '\"' };\n    ASSERT (u8_mbsnlen (input, 4) == 3);\n  }\n  /* 3.3.7. 3-byte sequence with last byte missing.  */\n  {\n    static const uint8_t input[] = { '\"', 0xEF, 0xBF, '\"' };\n    ASSERT (u8_mbsnlen (input, 4) == 3);\n  }\n  /* 3.3.3. 4-byte sequence with last byte missing.  */\n  {\n    static const uint8_t input[] = { '\"', 0xF0, 0x80, 0x80, '\"' };\n    ASSERT (u8_mbsnlen (input, 5) == 3);\n  }\n  /* 3.3.8. 4-byte sequence with last byte missing.  */\n  {\n    static const uint8_t input[] = { '\"', 0xF7, 0xBF, 0xBF, '\"' };\n    ASSERT (u8_mbsnlen (input, 5) == 3);\n  }\n\n  return 0;\n}",
      "lines": 96,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-mbtouc-unsafe.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nmain ()\n{\n  test_function (u8_mbtouc_unsafe);\n\n  return 0;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-mbtouc.c": {
    "test_safe_function": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "static void\ntest_safe_function (int (*my_u8_mbtouc) (ucs4_t *, const uint8_t *, size_t))\n{\n  ucs4_t uc;\n  int ret;\n\n  /* Test behaviour required by ISO 10646-1, sections R.7 and 2.3c, namely,\n     that a \"malformed sequence\" is interpreted in the same way as\n     \"a character that is outside the adopted subset\".\n     Reference:\n       Markus Kuhn: UTF-8 decoder capability and stress test\n       <https://www.cl.cam.ac.uk/~mgk25/ucs/examples/UTF-8-test.txt>\n       <https://www.w3.org/2001/06/utf-8-wrong/UTF-8-test.html>\n   */\n  /* 3.1. Test that each unexpected continuation byte is signalled as a\n     malformed sequence of its own.  */\n  {\n    static const uint8_t input[] = { '\"', 0x80, 0xBF, 0x80, 0xBF, '\"' };\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input, 6);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0x0022);\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input + 1, 5);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0xFFFD);\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input + 2, 4);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0xFFFD);\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input + 3, 3);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0xFFFD);\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input + 4, 2);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0xFFFD);\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input + 5, 1);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0x0022);\n  }\n  /* 3.2. Lonely start characters.  */\n  {\n    ucs4_t c;\n    uint8_t input[2];\n\n    for (c = 0xC0; c <= 0xFF; c++)\n      {\n        input[0] = c;\n        input[1] = ' ';\n\n        uc = 0xBADFACE;\n        ret = my_u8_mbtouc (&uc, input, 2);\n        ASSERT (ret == 1);\n        ASSERT (uc == 0xFFFD);\n      }\n  }\n  /* 3.3. Sequences with last continuation byte missing.  */\n  /* 3.3.1. 2-byte sequence with last byte missing.  */\n  {\n    static const uint8_t input[] = { '\"', 0xC0, '\"' };\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input, 3);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0x0022);\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input + 1, 2);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0xFFFD);\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input + 2, 1);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0x0022);\n  }\n  /* 3.3.6. 2-byte sequence with last byte missing.  */\n  {\n    static const uint8_t input[] = { '\"', 0xDF, '\"' };\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input, 3);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0x0022);\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input + 1, 2);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0xFFFD);\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input + 2, 1);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0x0022);\n  }\n  /* 3.3.2. 3-byte sequence with last byte missing.  */\n  {\n    static const uint8_t input[] = { '\"', 0xE0, 0x80, '\"' };\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input, 4);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0x0022);\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input + 1, 3);\n    ASSERT (ret == 2);\n    ASSERT (uc == 0xFFFD);\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input + 3, 1);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0x0022);\n  }\n  /* 3.3.7. 3-byte sequence with last byte missing.  */\n  {\n    static const uint8_t input[] = { '\"', 0xEF, 0xBF, '\"' };\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input, 4);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0x0022);\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input + 1, 3);\n    ASSERT (ret == 2);\n    ASSERT (uc == 0xFFFD);\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input + 3, 1);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0x0022);\n  }\n  /* 3.3.3. 4-byte sequence with last byte missing.  */\n  {\n    static const uint8_t input[] = { '\"', 0xF0, 0x80, 0x80, '\"' };\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input, 5);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0x0022);\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input + 1, 4);\n    ASSERT (ret == 3);\n    ASSERT (uc == 0xFFFD);\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input + 4, 1);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0x0022);\n  }\n  /* 3.3.8. 4-byte sequence with last byte missing.  */\n  {\n    static const uint8_t input[] = { '\"', 0xF7, 0xBF, 0xBF, '\"' };\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input, 5);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0x0022);\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input + 1, 4);\n    ASSERT (ret == 3);\n    ASSERT (uc == 0xFFFD);\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input + 4, 1);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0x0022);\n  }\n}",
      "lines": 157,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        184,
        0
      ],
      "end_point": [
        191,
        1
      ],
      "content": "int\nmain ()\n{\n  test_function (u8_mbtouc);\n  test_safe_function (u8_mbtouc);\n\n  return 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-mbtouc.h": {
    "test_function": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "static void\ntest_function (int (*my_u8_mbtouc) (ucs4_t *, const uint8_t *, size_t))\n{\n  ucs4_t uc;\n  int ret;\n\n  /* Test NUL unit input.  */\n  {\n    static const uint8_t input[] = \"\";\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input, 1);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0);\n  }\n\n  /* Test ISO 646 unit input.  */\n  {\n    ucs4_t c;\n    uint8_t buf[1];\n\n    for (c = 0; c < 0x80; c++)\n      {\n        buf[0] = c;\n        uc = 0xBADFACE;\n        ret = my_u8_mbtouc (&uc, buf, 1);\n        ASSERT (ret == 1);\n        ASSERT (uc == c);\n      }\n  }\n\n  /* Test 2-byte character input.  */\n  {\n    static const uint8_t input[] = { 0xC3, 0x97 };\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input, 2);\n    ASSERT (ret == 2);\n    ASSERT (uc == 0x00D7);\n  }\n\n  /* Test 3-byte character input.  */\n  {\n    static const uint8_t input[] = { 0xE2, 0x82, 0xAC };\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input, 3);\n    ASSERT (ret == 3);\n    ASSERT (uc == 0x20AC);\n  }\n\n  /* Test 4-byte character input.  */\n  {\n    static const uint8_t input[] = { 0xF4, 0x8F, 0xBF, 0xBD };\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input, 4);\n    ASSERT (ret == 4);\n    ASSERT (uc == 0x10FFFD);\n  }\n\n  /* Test incomplete/invalid 1-byte input.  */\n  {\n    static const uint8_t input[] = { 0xC1 };\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input, 1);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xC3 };\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input, 1);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xE2 };\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input, 1);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xF4 };\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input, 1);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xFE };\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input, 1);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0xFFFD);\n  }\n\n  /* Test incomplete/invalid 2-byte input.  */\n  {\n    static const uint8_t input[] = { 0xE0, 0x9F };\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input, 2);\n    ASSERT (ret == 1 || ret == 2);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xE2, 0x82 };\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input, 2);\n    ASSERT (ret == 2);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xE2, 0xD0 };\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input, 2);\n    ASSERT (ret == 1 || ret == 2);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xF0, 0x8F };\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input, 2);\n    ASSERT (ret == 1 || ret == 2);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0x8F };\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input, 2);\n    ASSERT (ret == 2);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0xD0 };\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input, 2);\n    ASSERT (ret == 1 || ret == 2);\n    ASSERT (uc == 0xFFFD);\n  }\n\n  /* Test incomplete/invalid 3-byte input.  */\n  {\n    static const uint8_t input[] = { 0xF3, 0x8F, 0xBF };\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input, 3);\n    ASSERT (ret == 3);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0xD0, 0xBF };\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input, 3);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0x8F, 0xD0 };\n    uc = 0xBADFACE;\n    ret = my_u8_mbtouc (&uc, input, 3);\n    ASSERT (ret == 2);\n    ASSERT (uc == 0xFFFD);\n  }\n}",
      "lines": 161,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-mbtoucr.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "int\nmain ()\n{\n  ucs4_t uc;\n  int ret;\n\n  /* Test NUL unit input.  */\n  {\n    static const uint8_t input[] = \"\";\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 1);\n    ASSERT (ret == 1);\n    ASSERT (uc == 0);\n  }\n\n  /* Test ISO 646 unit input.  */\n  {\n    ucs4_t c;\n    uint8_t buf[1];\n\n    for (c = 0; c < 0x80; c++)\n      {\n        buf[0] = c;\n        uc = 0xBADFACE;\n        ret = u8_mbtoucr (&uc, buf, 1);\n        ASSERT (ret == 1);\n        ASSERT (uc == c);\n      }\n  }\n\n  /* Test 2-byte character input.  */\n  {\n    static const uint8_t input[] = { 0xC3, 0x97 };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 2);\n    ASSERT (ret == 2);\n    ASSERT (uc == 0x00D7);\n  }\n\n  /* Test 3-byte character input.  */\n  {\n    static const uint8_t input[] = { 0xE2, 0x82, 0xAC };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 3);\n    ASSERT (ret == 3);\n    ASSERT (uc == 0x20AC);\n  }\n\n  /* Test 4-byte character input.  */\n  {\n    static const uint8_t input[] = { 0xF4, 0x8F, 0xBF, 0xBD };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 4);\n    ASSERT (ret == 4);\n    ASSERT (uc == 0x10FFFD);\n  }\n\n  /* Test incomplete/invalid 1-byte input.  */\n  {\n    static const uint8_t input[] = { 0xC1 };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 1);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xC3 };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 1);\n    ASSERT (ret == -2);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xE2 };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 1);\n    ASSERT (ret == -2);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xF4 };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 1);\n    ASSERT (ret == -2);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xFE };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 1);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xFFFD);\n  }\n\n  /* Test incomplete/invalid 2-byte input.  */\n  {\n    static const uint8_t input[] = { 0xE0, 0x9F };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 2);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xE2, 0x82 };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 2);\n    ASSERT (ret == -2);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xE2, 0xD0 };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 2);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xF0, 0x8F };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 2);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0x8F };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 2);\n    ASSERT (ret == -2);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0xD0 };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 2);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xFFFD);\n  }\n\n  /* Test incomplete/invalid 3-byte input.  */\n  {\n    static const uint8_t input[] = { 0xF3, 0x8F, 0xBF };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 3);\n    ASSERT (ret == -2);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0xD0, 0xBF };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 3);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0x8F, 0xD0 };\n    uc = 0xBADFACE;\n    ret = u8_mbtoucr (&uc, input, 3);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xFFFD);\n  }\n\n  return 0;\n}",
      "lines": 163,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-move.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-next.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "int\nmain ()\n{\n  ucs4_t uc;\n  const uint8_t *ret;\n\n  /* Test NUL unit input.  */\n  {\n    static const uint8_t input[] = \"\";\n    uc = 0xBADFACE;\n    ret = u8_next (&uc, input);\n    ASSERT (ret == NULL);\n    ASSERT (uc == 0);\n  }\n\n  /* Test ISO 646 unit input.  */\n  {\n    ucs4_t c;\n    uint8_t buf[2];\n\n    for (c = 1; c < 0x80; c++)\n      {\n        buf[0] = c;\n        buf[1] = 0;\n        uc = 0xBADFACE;\n        ret = u8_next (&uc, buf);\n        ASSERT (ret == buf + 1);\n        ASSERT (uc == c);\n      }\n  }\n\n  /* Test 2-byte character input.  */\n  {\n    static const uint8_t input[] = { 0xC3, 0x97, 0 };\n    uc = 0xBADFACE;\n    ret = u8_next (&uc, input);\n    ASSERT (ret == input + 2);\n    ASSERT (uc == 0x00D7);\n  }\n\n  /* Test 3-byte character input.  */\n  {\n    static const uint8_t input[] = { 0xE2, 0x82, 0xAC, 0 };\n    uc = 0xBADFACE;\n    ret = u8_next (&uc, input);\n    ASSERT (ret == input + 3);\n    ASSERT (uc == 0x20AC);\n  }\n\n  /* Test 4-byte character input.  */\n  {\n    static const uint8_t input[] = { 0xF4, 0x8F, 0xBF, 0xBD, 0 };\n    uc = 0xBADFACE;\n    ret = u8_next (&uc, input);\n    ASSERT (ret == input + 4);\n    ASSERT (uc == 0x10FFFD);\n  }\n\n  /* Test incomplete/invalid 1-byte input.  */\n  {\n    static const uint8_t input[] = { 0xC1, 0 };\n    uc = 0xBADFACE;\n    ret = u8_next (&uc, input);\n    ASSERT (ret == NULL);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xC3, 0 };\n    uc = 0xBADFACE;\n    ret = u8_next (&uc, input);\n    ASSERT (ret == NULL);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xE2, 0 };\n    uc = 0xBADFACE;\n    ret = u8_next (&uc, input);\n    ASSERT (ret == NULL);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xF4, 0 };\n    uc = 0xBADFACE;\n    ret = u8_next (&uc, input);\n    ASSERT (ret == NULL);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xFE, 0 };\n    uc = 0xBADFACE;\n    ret = u8_next (&uc, input);\n    ASSERT (ret == NULL);\n    ASSERT (uc == 0xFFFD);\n  }\n\n  /* Test incomplete/invalid 2-byte input.  */\n  {\n    static const uint8_t input[] = { 0xE0, 0x9F, 0 };\n    uc = 0xBADFACE;\n    ret = u8_next (&uc, input);\n    ASSERT (ret == NULL);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xE2, 0x82, 0 };\n    uc = 0xBADFACE;\n    ret = u8_next (&uc, input);\n    ASSERT (ret == NULL);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xE2, 0xD0, 0 };\n    uc = 0xBADFACE;\n    ret = u8_next (&uc, input);\n    ASSERT (ret == NULL);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xF0, 0x8F, 0 };\n    uc = 0xBADFACE;\n    ret = u8_next (&uc, input);\n    ASSERT (ret == NULL);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0x8F, 0 };\n    uc = 0xBADFACE;\n    ret = u8_next (&uc, input);\n    ASSERT (ret == NULL);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0xD0, 0 };\n    uc = 0xBADFACE;\n    ret = u8_next (&uc, input);\n    ASSERT (ret == NULL);\n    ASSERT (uc == 0xFFFD);\n  }\n\n  /* Test incomplete/invalid 3-byte input.  */\n  {\n    static const uint8_t input[] = { 0xF3, 0x8F, 0xBF, 0 };\n    uc = 0xBADFACE;\n    ret = u8_next (&uc, input);\n    ASSERT (ret == NULL);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0xD0, 0xBF, 0 };\n    uc = 0xBADFACE;\n    ret = u8_next (&uc, input);\n    ASSERT (ret == NULL);\n    ASSERT (uc == 0xFFFD);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0x8F, 0xD0, 0 };\n    uc = 0xBADFACE;\n    ret = u8_next (&uc, input);\n    ASSERT (ret == NULL);\n    ASSERT (uc == 0xFFFD);\n  }\n\n  return 0;\n}",
      "lines": 164,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-prev.c": {
    "check": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "static int\ncheck (const uint8_t *input, size_t input_length, ucs4_t *puc)\n{\n  ucs4_t uc;\n\n  /* Test recognition when at the beginning of the string.  */\n  if (u8_prev (&uc, input + input_length, input) != input)\n    return 1;\n\n  /* Test recognition when preceded by a 1-unit character.  */\n  {\n    uint8_t buf[100];\n    uint8_t *ptr;\n    size_t i;\n    ucs4_t uc1;\n\n    ptr = buf;\n    *ptr++ = 'x';\n    for (i = 0; i < input_length; i++)\n      ptr[i] = input[i];\n\n    if (u8_prev (&uc1, ptr + input_length, buf) != ptr)\n      return 2;\n    if (uc1 != uc)\n      return 3;\n  }\n\n  /* Test recognition when preceded by a 2-unit character.  */\n  {\n    uint8_t buf[100];\n    uint8_t *ptr;\n    size_t i;\n    ucs4_t uc1;\n\n    ptr = buf;\n    *ptr++ = 0xC3;\n    *ptr++ = 0x97;\n    for (i = 0; i < input_length; i++)\n      ptr[i] = input[i];\n\n    if (u8_prev (&uc1, ptr + input_length, buf) != ptr)\n      return 4;\n    if (uc1 != uc)\n      return 5;\n  }\n\n  /* Test recognition when preceded by a 3-unit character.  */\n  {\n    uint8_t buf[100];\n    uint8_t *ptr;\n    size_t i;\n    ucs4_t uc1;\n\n    ptr = buf;\n    *ptr++ = 0xE2;\n    *ptr++ = 0x84;\n    *ptr++ = 0x82;\n    for (i = 0; i < input_length; i++)\n      ptr[i] = input[i];\n\n    if (u8_prev (&uc1, ptr + input_length, buf) != ptr)\n      return 6;\n    if (uc1 != uc)\n      return 7;\n  }\n\n  /* Test recognition when preceded by a 4-unit character.  */\n  {\n    uint8_t buf[100];\n    uint8_t *ptr;\n    size_t i;\n    ucs4_t uc1;\n\n    ptr = buf;\n    *ptr++ = 0xF0;\n    *ptr++ = 0x9D;\n    *ptr++ = 0x94;\n    *ptr++ = 0x9E;\n    for (i = 0; i < input_length; i++)\n      ptr[i] = input[i];\n\n    if (u8_prev (&uc1, ptr + input_length, buf) != ptr)\n      return 8;\n    if (uc1 != uc)\n      return 9;\n  }\n\n  *puc = uc;\n  return 0;\n}",
      "lines": 90,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_invalid": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "static int\ncheck_invalid (const uint8_t *input, size_t input_length)\n{\n  ucs4_t uc;\n\n  /* Test recognition when at the beginning of the string.  */\n  uc = 0xBADFACE;\n  if (u8_prev (&uc, input + input_length, input) != NULL)\n    return 1;\n  if (uc != 0xBADFACE)\n    return 2;\n\n  /* Test recognition when preceded by a 1-unit character.  */\n  {\n    uint8_t buf[100];\n    uint8_t *ptr;\n    size_t i;\n\n    ptr = buf;\n    *ptr++ = 'x';\n    for (i = 0; i < input_length; i++)\n      ptr[i] = input[i];\n\n    uc = 0xBADFACE;\n    if (u8_prev (&uc, ptr + input_length, buf) != NULL)\n      return 3;\n    if (uc != 0xBADFACE)\n      return 4;\n  }\n\n  /* Test recognition when preceded by a 2-unit character.  */\n  {\n    uint8_t buf[100];\n    uint8_t *ptr;\n    size_t i;\n\n    ptr = buf;\n    *ptr++ = 0xC3;\n    *ptr++ = 0x97;\n    for (i = 0; i < input_length; i++)\n      ptr[i] = input[i];\n\n    uc = 0xBADFACE;\n    if (u8_prev (&uc, ptr + input_length, buf) != NULL)\n      return 5;\n    if (uc != 0xBADFACE)\n      return 6;\n  }\n\n  /* Test recognition when preceded by a 3-unit character.  */\n  {\n    uint8_t buf[100];\n    uint8_t *ptr;\n    size_t i;\n\n    ptr = buf;\n    *ptr++ = 0xE2;\n    *ptr++ = 0x84;\n    *ptr++ = 0x82;\n    for (i = 0; i < input_length; i++)\n      ptr[i] = input[i];\n\n    uc = 0xBADFACE;\n    if (u8_prev (&uc, ptr + input_length, buf) != NULL)\n      return 7;\n    if (uc != 0xBADFACE)\n      return 8;\n  }\n\n  /* Test recognition when preceded by a 4-unit character.  */\n  {\n    uint8_t buf[100];\n    uint8_t *ptr;\n    size_t i;\n\n    ptr = buf;\n    *ptr++ = 0xF0;\n    *ptr++ = 0x9D;\n    *ptr++ = 0x94;\n    *ptr++ = 0x9E;\n    for (i = 0; i < input_length; i++)\n      ptr[i] = input[i];\n\n    uc = 0xBADFACE;\n    if (u8_prev (&uc, ptr + input_length, buf) != NULL)\n      return 9;\n    if (uc != 0xBADFACE)\n      return 10;\n  }\n\n  return 0;\n}",
      "lines": 92,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        314,
        1
      ],
      "content": "int\nmain ()\n{\n  ucs4_t uc;\n\n  /* Test ISO 646 unit input.  */\n  {\n    ucs4_t c;\n    uint8_t buf[1];\n\n    for (c = 0; c < 0x80; c++)\n      {\n        buf[0] = c;\n        uc = 0xBADFACE;\n        ASSERT (check (buf, 1, &uc) == 0);\n        ASSERT (uc == c);\n      }\n  }\n\n  /* Test 2-byte character input.  */\n  {\n    static const uint8_t input[] = { 0xC3, 0x97 };\n    uc = 0xBADFACE;\n    ASSERT (check (input, SIZEOF (input), &uc) == 0);\n    ASSERT (uc == 0x00D7);\n  }\n\n  /* Test 3-byte character input.  */\n  {\n    static const uint8_t input[] = { 0xE2, 0x82, 0xAC };\n    uc = 0xBADFACE;\n    ASSERT (check (input, SIZEOF (input), &uc) == 0);\n    ASSERT (uc == 0x20AC);\n  }\n\n  /* Test 4-byte character input.  */\n  {\n    static const uint8_t input[] = { 0xF4, 0x8F, 0xBF, 0xBD };\n    uc = 0xBADFACE;\n    ASSERT (check (input, SIZEOF (input), &uc) == 0);\n    ASSERT (uc == 0x10FFFD);\n  }\n\n  /* Test incomplete/invalid 1-byte input.  */\n  {\n    static const uint8_t input[] = { 0xC1 };\n    ASSERT (check_invalid (input, SIZEOF (input)) == 0);\n  }\n  {\n    static const uint8_t input[] = { 0xC3 };\n    ASSERT (check_invalid (input, SIZEOF (input)) == 0);\n  }\n  {\n    static const uint8_t input[] = { 0xE2 };\n    ASSERT (check_invalid (input, SIZEOF (input)) == 0);\n  }\n  {\n    static const uint8_t input[] = { 0xF4 };\n    ASSERT (check_invalid (input, SIZEOF (input)) == 0);\n  }\n  {\n    static const uint8_t input[] = { 0xFE };\n    ASSERT (check_invalid (input, SIZEOF (input)) == 0);\n  }\n\n  /* Test incomplete/invalid 2-byte input.  */\n  {\n    static const uint8_t input[] = { 0xE0, 0x9F };\n    ASSERT (check_invalid (input, SIZEOF (input)) == 0);\n  }\n  {\n    static const uint8_t input[] = { 0xE2, 0x82 };\n    ASSERT (check_invalid (input, SIZEOF (input)) == 0);\n  }\n  {\n    static const uint8_t input[] = { 0xE2, 0xD0 };\n    ASSERT (check_invalid (input, SIZEOF (input)) == 0);\n  }\n  {\n    static const uint8_t input[] = { 0xF0, 0x8F };\n    ASSERT (check_invalid (input, SIZEOF (input)) == 0);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0x8F };\n    ASSERT (check_invalid (input, SIZEOF (input)) == 0);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0xD0 };\n    ASSERT (check_invalid (input, SIZEOF (input)) == 0);\n  }\n\n  /* Test incomplete/invalid 3-byte input.  */\n  {\n    static const uint8_t input[] = { 0xF3, 0x8F, 0xBF };\n    ASSERT (check_invalid (input, SIZEOF (input)) == 0);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0xE4, 0xBF };\n    ASSERT (check_invalid (input, SIZEOF (input)) == 0);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0x8F, 0xD0 };\n    ASSERT (check_invalid (input, SIZEOF (input)) == 0);\n  }\n\n  return 0;\n}",
      "lines": 107,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-set.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-stpcpy.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-stpncpy.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint8_t input[] =\n      { 'G', 'r', 0xC3, 0xBC, 0xC3, 0x9F, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0xD0, 0x97, 0xD0, 0xB4, 0xD1, 0x80, 0xD0, 0xB0, 0xD0, 0xB2, 0xD1, 0x81,\n        0xD1, 0x82, 0xD0, 0xB2, 0xD1, 0x83, 0xD0, 0xB9, 0xD1, 0x82, 0xD0, 0xB5,\n        '!', ' ', 'x', '=', '(', '-', 'b', 0xC2, 0xB1, 's', 'q', 'r', 't', '(',\n        'b', 0xC2, 0xB2, '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')',\n        ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC, 0xE8, 0xAA, 0x9E, ',',\n        0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xED, 0x95, 0x9C, 0xEA, 0xB8, 0x80, '\\0'\n      };\n    check (input, SIZEOF (input));\n  }\n\n  return 0;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-strcat.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-strchr.c": {
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "int\nmain (void)\n{\n  test_strchr ();\n\n  /* Check that u8_strchr() does not read past the end of the string.  */\n  {\n    char *page_boundary = (char *) zerosize_ptr ();\n\n    if (page_boundary != NULL)\n      {\n        UNIT *mem;\n\n        mem = (UNIT *) (page_boundary - 1 * sizeof (UNIT));\n        mem[0] = 0;\n        ASSERT (u8_strchr (mem, 0x55) == NULL);\n        ASSERT (u8_strchr (mem, 0x123) == NULL);\n        ASSERT (u8_strchr (mem, 0x3456) == NULL);\n        ASSERT (u8_strchr (mem, 0x23456) == NULL);\n\n        mem = (UNIT *) (page_boundary - 2 * sizeof (UNIT));\n        mem[0] = 0x50;\n        mem[1] = 0;\n        ASSERT (u8_strchr (mem, 0x55) == NULL);\n        ASSERT (u8_strchr (mem, 0x123) == NULL);\n        ASSERT (u8_strchr (mem, 0x3456) == NULL);\n        ASSERT (u8_strchr (mem, 0x23456) == NULL);\n\n        mem = (UNIT *) (page_boundary - 3 * sizeof (UNIT));\n        mem[0] = 0x50;\n        mem[1] = 0x50;\n        mem[2] = 0;\n        ASSERT (u8_strchr (mem, 0x55) == NULL);\n        ASSERT (u8_strchr (mem, 0x123) == NULL);\n        ASSERT (u8_strchr (mem, 0x3456) == NULL);\n        ASSERT (u8_strchr (mem, 0x23456) == NULL);\n\n        mem = (UNIT *) (page_boundary - 3 * sizeof (UNIT));\n        mem[0] = 0xC4; mem[1] = 0xA0; /* U+0120 */\n        mem[2] = 0;\n        ASSERT (u8_strchr (mem, 0x55) == NULL);\n        ASSERT (u8_strchr (mem, 0x123) == NULL);\n        ASSERT (u8_strchr (mem, 0x3456) == NULL);\n        ASSERT (u8_strchr (mem, 0x23456) == NULL);\n\n        mem = (UNIT *) (page_boundary - 3 * sizeof (UNIT));\n        mem[0] = 0xC5; mem[1] = 0xA3; /* U+0163 */\n        mem[2] = 0;\n        ASSERT (u8_strchr (mem, 0x55) == NULL);\n        ASSERT (u8_strchr (mem, 0x123) == NULL);\n        ASSERT (u8_strchr (mem, 0x3456) == NULL);\n        ASSERT (u8_strchr (mem, 0x23456) == NULL);\n\n        mem = (UNIT *) (page_boundary - 4 * sizeof (UNIT));\n        mem[0] = 0x50;\n        mem[1] = 0x50;\n        mem[2] = 0x50;\n        mem[3] = 0;\n        ASSERT (u8_strchr (mem, 0x55) == NULL);\n        ASSERT (u8_strchr (mem, 0x123) == NULL);\n        ASSERT (u8_strchr (mem, 0x3456) == NULL);\n        ASSERT (u8_strchr (mem, 0x23456) == NULL);\n\n        mem = (UNIT *) (page_boundary - 4 * sizeof (UNIT));\n        mem[0] = 0x50;\n        mem[1] = 0xC5; mem[2] = 0xA3; /* U+0163 */\n        mem[3] = 0;\n        ASSERT (u8_strchr (mem, 0x55) == NULL);\n        ASSERT (u8_strchr (mem, 0x123) == NULL);\n        ASSERT (u8_strchr (mem, 0x3456) == NULL);\n        ASSERT (u8_strchr (mem, 0x23456) == NULL);\n        ASSERT (u8_strchr (mem, 0x163) == mem + 1);\n\n        mem = (UNIT *) (page_boundary - 4 * sizeof (UNIT));\n        mem[0] = 0xE3; mem[1] = 0x91; mem[2] = 0x00; /* U+3450 */\n        mem[3] = 0;\n        ASSERT (u8_strchr (mem, 0x55) == NULL);\n        ASSERT (u8_strchr (mem, 0x123) == NULL);\n        ASSERT (u8_strchr (mem, 0x3456) == NULL);\n        ASSERT (u8_strchr (mem, 0x23456) == NULL);\n\n        mem = (UNIT *) (page_boundary - 4 * sizeof (UNIT));\n        mem[0] = 0xE3; mem[1] = 0x92; mem[2] = 0x96; /* U+3496 */\n        mem[3] = 0;\n        ASSERT (u8_strchr (mem, 0x55) == NULL);\n        ASSERT (u8_strchr (mem, 0x123) == NULL);\n        ASSERT (u8_strchr (mem, 0x3456) == NULL);\n        ASSERT (u8_strchr (mem, 0x23456) == NULL);\n\n        mem = (UNIT *) (page_boundary - 5 * sizeof (UNIT));\n        mem[0] = 0x50;\n        mem[1] = 0x50;\n        mem[2] = 0x50;\n        mem[3] = 0x50;\n        mem[4] = 0;\n        ASSERT (u8_strchr (mem, 0x55) == NULL);\n        ASSERT (u8_strchr (mem, 0x123) == NULL);\n        ASSERT (u8_strchr (mem, 0x3456) == NULL);\n        ASSERT (u8_strchr (mem, 0x23456) == NULL);\n\n        mem = (UNIT *) (page_boundary - 5 * sizeof (UNIT));\n        mem[0] = 0x50;\n        mem[1] = 0xE3; mem[2] = 0x92; mem[3] = 0x96; /* U+3496 */\n        mem[4] = 0;\n        ASSERT (u8_strchr (mem, 0x55) == NULL);\n        ASSERT (u8_strchr (mem, 0x123) == NULL);\n        ASSERT (u8_strchr (mem, 0x3456) == NULL);\n        ASSERT (u8_strchr (mem, 0x23456) == NULL);\n        ASSERT (u8_strchr (mem, 0x3496) == mem + 1);\n      }\n  }\n\n  return 0;\n}",
      "lines": 114,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-strcmp.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\nmain ()\n{\n  test_u8_strcmp ();\n\n  return 0;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-strcmp.h": {
    "test_u8_strcmp": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "static void\ntest_u8_strcmp (void)\n{\n  test_strcmp ();\n\n  /* Test comparison between ASCII and non-ASCII characters.  */\n  {\n    static const UNIT input1[] = { 'f', 'o', 'o', 0 };\n    static const UNIT input2[] = { 0xE2, 0x80, 0xA2, 0 };\n    ASSERT (U_STRCMP (input1, input2) < 0);\n    ASSERT (U_STRCMP (input2, input1) > 0);\n  }\n\n  /* Test comparison with non-BMP characters.  */\n  {\n    static const UNIT input1[] = { 0xF0, 0x9D, 0x94, 0x9E, 0 };\n    static const UNIT input2[] = { 0xEF, 0xBB, 0xBF, 0 };\n    ASSERT (U_STRCMP (input1, input2) > 0);\n    ASSERT (U_STRCMP (input2, input1) < 0);\n  }\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-strcoll.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\nmain ()\n{\n  /* This test relies on three facts:\n     - setlocale is not being called, therefore the locale is the \"C\" locale.\n     - In the \"C\" locale, strcoll is equivalent to strcmp.\n     - In the u8_strcoll implementation, Unicode strings that are not\n       convertible to the locale encoding are sorted higher than convertible\n       strings and compared according to u8_strcmp.  */\n\n  test_u8_strcmp ();\n\n  return 0;\n}",
      "lines": 14,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-strcpy.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-strdup.c": {},
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-strlen.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Empty string.  */\n  {\n    static const uint8_t input[] = { 0 };\n    ASSERT (u8_strlen (input) == 0);\n  }\n\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint8_t input[] =\n      { 'G', 'r', 0xC3, 0xBC, 0xC3, 0x9F, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0xD0, 0x97, 0xD0, 0xB4, 0xD1, 0x80, 0xD0, 0xB0, 0xD0, 0xB2, 0xD1, 0x81,\n        0xD1, 0x82, 0xD0, 0xB2, 0xD1, 0x83, 0xD0, 0xB9, 0xD1, 0x82, 0xD0, 0xB5,\n        '!', ' ', 'x', '=', '(', '-', 'b', 0xC2, 0xB1, 's', 'q', 'r', 't', '(',\n        'b', 0xC2, 0xB2, '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')',\n        ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC, 0xE8, 0xAA, 0x9E, ',',\n        0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xED, 0x95, 0x9C, 0xEA, 0xB8, 0x80, '\\0'\n      };\n    ASSERT (u8_strlen (input) == SIZEOF (input) - 1);\n  }\n\n  return 0;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-strmblen.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "int\nmain ()\n{\n  int ret;\n\n  /* Test NUL unit input.  */\n  {\n    static const uint8_t input[] = \"\";\n    ret = u8_strmblen (input);\n    ASSERT (ret == 0);\n  }\n\n  /* Test ISO 646 unit input.  */\n  {\n    ucs4_t c;\n    uint8_t buf[2];\n\n    for (c = 1; c < 0x80; c++)\n      {\n        buf[0] = c;\n        buf[1] = 0;\n        ret = u8_strmblen (buf);\n        ASSERT (ret == 1);\n      }\n  }\n\n  /* Test 2-byte character input.  */\n  {\n    static const uint8_t input[] = { 0xC3, 0x97, 0 };\n    ret = u8_strmblen (input);\n    ASSERT (ret == 2);\n  }\n\n  /* Test 3-byte character input.  */\n  {\n    static const uint8_t input[] = { 0xE2, 0x82, 0xAC, 0 };\n    ret = u8_strmblen (input);\n    ASSERT (ret == 3);\n  }\n\n  /* Test 4-byte character input.  */\n  {\n    static const uint8_t input[] = { 0xF4, 0x8F, 0xBF, 0xBD, 0 };\n    ret = u8_strmblen (input);\n    ASSERT (ret == 4);\n  }\n\n  /* Test incomplete/invalid 1-byte input.  */\n  {\n    static const uint8_t input[] = { 0xC1, 0 };\n    ret = u8_strmblen (input);\n    ASSERT (ret == -1);\n  }\n  {\n    static const uint8_t input[] = { 0xC3, 0 };\n    ret = u8_strmblen (input);\n    ASSERT (ret == -1);\n  }\n  {\n    static const uint8_t input[] = { 0xE2, 0 };\n    ret = u8_strmblen (input);\n    ASSERT (ret == -1);\n  }\n  {\n    static const uint8_t input[] = { 0xF4, 0 };\n    ret = u8_strmblen (input);\n    ASSERT (ret == -1);\n  }\n  {\n    static const uint8_t input[] = { 0xFE, 0 };\n    ret = u8_strmblen (input);\n    ASSERT (ret == -1);\n  }\n\n  /* Test incomplete/invalid 2-byte input.  */\n  {\n    static const uint8_t input[] = { 0xE0, 0x9F, 0 };\n    ret = u8_strmblen (input);\n    ASSERT (ret == -1);\n  }\n  {\n    static const uint8_t input[] = { 0xE2, 0x82, 0 };\n    ret = u8_strmblen (input);\n    ASSERT (ret == -1);\n  }\n  {\n    static const uint8_t input[] = { 0xE2, 0xD0, 0 };\n    ret = u8_strmblen (input);\n    ASSERT (ret == -1);\n  }\n  {\n    static const uint8_t input[] = { 0xF0, 0x8F, 0 };\n    ret = u8_strmblen (input);\n    ASSERT (ret == -1);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0x8F, 0 };\n    ret = u8_strmblen (input);\n    ASSERT (ret == -1);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0xD0, 0 };\n    ret = u8_strmblen (input);\n    ASSERT (ret == -1);\n  }\n\n  /* Test incomplete/invalid 3-byte input.  */\n  {\n    static const uint8_t input[] = { 0xF3, 0x8F, 0xBF, 0 };\n    ret = u8_strmblen (input);\n    ASSERT (ret == -1);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0xD0, 0xBF, 0 };\n    ret = u8_strmblen (input);\n    ASSERT (ret == -1);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0x8F, 0xD0, 0 };\n    ret = u8_strmblen (input);\n    ASSERT (ret == -1);\n  }\n\n  return 0;\n}",
      "lines": 125,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-strmbtouc.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "int\nmain ()\n{\n  ucs4_t uc;\n  int ret;\n\n  /* Test NUL unit input.  */\n  {\n    static const uint8_t input[] = \"\";\n    uc = 0xBADFACE;\n    ret = u8_strmbtouc (&uc, input);\n    ASSERT (ret == 0);\n    ASSERT (uc == 0);\n  }\n\n  /* Test ISO 646 unit input.  */\n  {\n    ucs4_t c;\n    uint8_t buf[2];\n\n    for (c = 1; c < 0x80; c++)\n      {\n        buf[0] = c;\n        buf[1] = 0;\n        uc = 0xBADFACE;\n        ret = u8_strmbtouc (&uc, buf);\n        ASSERT (ret == 1);\n        ASSERT (uc == c);\n      }\n  }\n\n  /* Test 2-byte character input.  */\n  {\n    static const uint8_t input[] = { 0xC3, 0x97, 0 };\n    uc = 0xBADFACE;\n    ret = u8_strmbtouc (&uc, input);\n    ASSERT (ret == 2);\n    ASSERT (uc == 0x00D7);\n  }\n\n  /* Test 3-byte character input.  */\n  {\n    static const uint8_t input[] = { 0xE2, 0x82, 0xAC, 0 };\n    uc = 0xBADFACE;\n    ret = u8_strmbtouc (&uc, input);\n    ASSERT (ret == 3);\n    ASSERT (uc == 0x20AC);\n  }\n\n  /* Test 4-byte character input.  */\n  {\n    static const uint8_t input[] = { 0xF4, 0x8F, 0xBF, 0xBD, 0 };\n    uc = 0xBADFACE;\n    ret = u8_strmbtouc (&uc, input);\n    ASSERT (ret == 4);\n    ASSERT (uc == 0x10FFFD);\n  }\n\n  /* Test incomplete/invalid 1-byte input.  */\n  {\n    static const uint8_t input[] = { 0xC1, 0 };\n    uc = 0xBADFACE;\n    ret = u8_strmbtouc (&uc, input);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xBADFACE);\n  }\n  {\n    static const uint8_t input[] = { 0xC3, 0 };\n    uc = 0xBADFACE;\n    ret = u8_strmbtouc (&uc, input);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xBADFACE);\n  }\n  {\n    static const uint8_t input[] = { 0xE2, 0 };\n    uc = 0xBADFACE;\n    ret = u8_strmbtouc (&uc, input);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xBADFACE);\n  }\n  {\n    static const uint8_t input[] = { 0xF4, 0 };\n    uc = 0xBADFACE;\n    ret = u8_strmbtouc (&uc, input);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xBADFACE);\n  }\n  {\n    static const uint8_t input[] = { 0xFE, 0 };\n    uc = 0xBADFACE;\n    ret = u8_strmbtouc (&uc, input);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xBADFACE);\n  }\n\n  /* Test incomplete/invalid 2-byte input.  */\n  {\n    static const uint8_t input[] = { 0xE0, 0x9F, 0 };\n    uc = 0xBADFACE;\n    ret = u8_strmbtouc (&uc, input);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xBADFACE);\n  }\n  {\n    static const uint8_t input[] = { 0xE2, 0x82, 0 };\n    uc = 0xBADFACE;\n    ret = u8_strmbtouc (&uc, input);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xBADFACE);\n  }\n  {\n    static const uint8_t input[] = { 0xE2, 0xD0, 0 };\n    uc = 0xBADFACE;\n    ret = u8_strmbtouc (&uc, input);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xBADFACE);\n  }\n  {\n    static const uint8_t input[] = { 0xF0, 0x8F, 0 };\n    uc = 0xBADFACE;\n    ret = u8_strmbtouc (&uc, input);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xBADFACE);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0x8F, 0 };\n    uc = 0xBADFACE;\n    ret = u8_strmbtouc (&uc, input);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xBADFACE);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0xD0, 0 };\n    uc = 0xBADFACE;\n    ret = u8_strmbtouc (&uc, input);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xBADFACE);\n  }\n\n  /* Test incomplete/invalid 3-byte input.  */\n  {\n    static const uint8_t input[] = { 0xF3, 0x8F, 0xBF, 0 };\n    uc = 0xBADFACE;\n    ret = u8_strmbtouc (&uc, input);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xBADFACE);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0xD0, 0xBF, 0 };\n    uc = 0xBADFACE;\n    ret = u8_strmbtouc (&uc, input);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xBADFACE);\n  }\n  {\n    static const uint8_t input[] = { 0xF3, 0x8F, 0xD0, 0 };\n    uc = 0xBADFACE;\n    ret = u8_strmbtouc (&uc, input);\n    ASSERT (ret == -1);\n    ASSERT (uc == 0xBADFACE);\n  }\n\n  return 0;\n}",
      "lines": 164,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-strncat.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint8_t input[] =\n      { 'G', 'r', 0xC3, 0xBC, 0xC3, 0x9F, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0xD0, 0x97, 0xD0, 0xB4, 0xD1, 0x80, 0xD0, 0xB0, 0xD0, 0xB2, 0xD1, 0x81,\n        0xD1, 0x82, 0xD0, 0xB2, 0xD1, 0x83, 0xD0, 0xB9, 0xD1, 0x82, 0xD0, 0xB5,\n        '!', ' ', 'x', '=', '(', '-', 'b', 0xC2, 0xB1, 's', 'q', 'r', 't', '(',\n        'b', 0xC2, 0xB2, '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')',\n        ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC, 0xE8, 0xAA, 0x9E, ',',\n        0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xED, 0x95, 0x9C, 0xEA, 0xB8, 0x80, '\\0'\n      };\n    check (input, SIZEOF (input));\n  }\n\n  return 0;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-strncmp.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "int\nmain ()\n{\n  test_strncmp ();\n\n  /* Test comparison with non-BMP characters.  */\n  {\n    static const UNIT input1[] = { 0xF0, 0x9D, 0x94, 0x9E, 0 };\n    static const UNIT input2[] = { 0xEF, 0xBB, 0xBF, 0 };\n    ASSERT (U_STRNCMP (input1, input2, 1) > 0);\n    ASSERT (U_STRNCMP (input2, input1, 1) < 0);\n    ASSERT (U_STRNCMP (input1, input2, 2) > 0);\n    ASSERT (U_STRNCMP (input2, input1, 2) < 0);\n    ASSERT (U_STRNCMP (input1, input2, 3) > 0);\n    ASSERT (U_STRNCMP (input2, input1, 3) < 0);\n    ASSERT (U_STRNCMP (input1, input2, 4) > 0);\n    ASSERT (U_STRNCMP (input2, input1, 4) < 0);\n    ASSERT (U_STRNCMP (input1, input2, 5) > 0);\n    ASSERT (U_STRNCMP (input2, input1, 5) < 0);\n    ASSERT (U_STRNCMP (input1, input2, 1000000) > 0);\n    ASSERT (U_STRNCMP (input2, input1, 1000000) < 0);\n  }\n\n  return 0;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-strncpy.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint8_t input[] =\n      { 'G', 'r', 0xC3, 0xBC, 0xC3, 0x9F, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0xD0, 0x97, 0xD0, 0xB4, 0xD1, 0x80, 0xD0, 0xB0, 0xD0, 0xB2, 0xD1, 0x81,\n        0xD1, 0x82, 0xD0, 0xB2, 0xD1, 0x83, 0xD0, 0xB9, 0xD1, 0x82, 0xD0, 0xB5,\n        '!', ' ', 'x', '=', '(', '-', 'b', 0xC2, 0xB1, 's', 'q', 'r', 't', '(',\n        'b', 0xC2, 0xB2, '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')',\n        ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC, 0xE8, 0xAA, 0x9E, ',',\n        0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xED, 0x95, 0x9C, 0xEA, 0xB8, 0x80, '\\0'\n      };\n    check (input, SIZEOF (input));\n  }\n\n  return 0;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-strnlen.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint8_t input[] =\n      { 'G', 'r', 0xC3, 0xBC, 0xC3, 0x9F, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0xD0, 0x97, 0xD0, 0xB4, 0xD1, 0x80, 0xD0, 0xB0, 0xD0, 0xB2, 0xD1, 0x81,\n        0xD1, 0x82, 0xD0, 0xB2, 0xD1, 0x83, 0xD0, 0xB9, 0xD1, 0x82, 0xD0, 0xB5,\n        '!', ' ', 'x', '=', '(', '-', 'b', 0xC2, 0xB1, 's', 'q', 'r', 't', '(',\n        'b', 0xC2, 0xB2, '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')',\n        ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC, 0xE8, 0xAA, 0x9E, ',',\n        0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xED, 0x95, 0x9C, 0xEA, 0xB8, 0x80, '\\0'\n      };\n    check (input, SIZEOF (input));\n  }\n\n  return 0;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-strstr.c": {
    "main": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nmain (void)\n{\n#if HAVE_DECL_ALARM\n  /* Declare failure if test takes too long, by using default abort\n     caused by SIGALRM.  Note since we defer to strstr() in this\n     case, we're assuming that we're running this test on the\n     same system that we did the check to ensure it has linear\n     performance characteristics.  */\n  signal (SIGALRM, SIG_DFL);\n  alarm (5);\n#endif\n\n  test_u_strstr ();\n\n  return 0;\n}",
      "lines": 17,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-strtok.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int\nmain (void)\n{\n  test_u_strtok ();\n\n  return 0;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-to-u16.c": {
    "check": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "static int\ncheck (const uint8_t *input, size_t input_length,\n       const uint16_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint16_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u8_to_u16 (input, input_length, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u16_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint16_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint16_t *) malloc (length * sizeof (uint16_t));\n      result = u8_to_u16 (input, input_length, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u16_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint16_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint16_t *) malloc (length * sizeof (uint16_t));\n    result = u8_to_u16 (input, input_length, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u16_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Empty string.  */\n  ASSERT (check (NULL, 0, NULL, 0) == 0);\n\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint8_t input[] =\n      { 'G', 'r', 0xC3, 0xBC, 0xC3, 0x9F, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0xD0, 0x97, 0xD0, 0xB4, 0xD1, 0x80, 0xD0, 0xB0, 0xD0, 0xB2, 0xD1, 0x81,\n        0xD1, 0x82, 0xD0, 0xB2, 0xD1, 0x83, 0xD0, 0xB9, 0xD1, 0x82, 0xD0, 0xB5,\n        '!', ' ', 'x', '=', '(', '-', 'b', 0xC2, 0xB1, 's', 'q', 'r', 't', '(',\n        'b', 0xC2, 0xB2, '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')',\n        ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC, 0xE8, 0xAA, 0x9E, ',',\n        0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xED, 0x95, 0x9C, 0xEA, 0xB8, 0x80, '\\n'\n      };\n    static const uint16_t expected[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  /* String with characters outside the BMP.  */\n  {\n    static const uint8_t input[] =\n      { '-', '(', 0xF0, 0x9D, 0x94, 0x9E, 0xC3, 0x97, 0xF0, 0x9D, 0x94, 0x9F,\n        ')', '=', 0xF0, 0x9D, 0x94, 0x9F, 0xC3, 0x97, 0xF0, 0x9D, 0x94, 0x9E\n      };\n    static const uint16_t expected[] =\n      { '-', '(', 0xD835, 0xDD1E, 0x00D7, 0xD835, 0xDD1F, ')', '=',\n        0xD835, 0xDD1F, 0x00D7, 0xD835, 0xDD1E\n      };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  /* Invalid input.  */\n  {\n    static const uint8_t input[] = { 'x', 0xC2, 0xC3, 'y' };\n#if 0 /* Currently invalid input is rejected, not accommodated.  */\n    static const uint16_t expected[] = { 'x', 0xFFFD, 0xFFFD, 'y' };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n#else\n    size_t length;\n    uint16_t *result;\n    uint16_t preallocated[10];\n\n    /* Test return conventions with resultbuf == NULL.  */\n    result = u8_to_u16 (input, SIZEOF (input), NULL, &length);\n    ASSERT (result == NULL);\n    ASSERT (errno == EILSEQ);\n\n    /* Test return conventions with resultbuf too small.  */\n    length = 1;\n    result = u8_to_u16 (input, SIZEOF (input), preallocated, &length);\n    ASSERT (result == NULL);\n    ASSERT (errno == EILSEQ);\n\n    /* Test return conventions with resultbuf large enough.  */\n    length = SIZEOF (preallocated);\n    result = u8_to_u16 (input, SIZEOF (input), preallocated, &length);\n    ASSERT (result == NULL);\n    ASSERT (errno == EILSEQ);\n#endif\n  }\n\n  return 0;\n}",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-to-u32.c": {
    "check": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "static int\ncheck (const uint8_t *input, size_t input_length,\n       const uint32_t *expected, size_t expected_length)\n{\n  size_t length;\n  uint32_t *result;\n\n  /* Test return conventions with resultbuf == NULL.  */\n  result = u8_to_u32 (input, input_length, NULL, &length);\n  if (!(result != NULL))\n    return 1;\n  if (!(length == expected_length))\n    return 2;\n  if (!(u32_cmp (result, expected, expected_length) == 0))\n    return 3;\n  free (result);\n\n  /* Test return conventions with resultbuf too small.  */\n  if (expected_length > 0)\n    {\n      uint32_t *preallocated;\n\n      length = expected_length - 1;\n      preallocated = (uint32_t *) malloc (length * sizeof (uint32_t));\n      result = u8_to_u32 (input, input_length, preallocated, &length);\n      if (!(result != NULL))\n        return 4;\n      if (!(result != preallocated))\n        return 5;\n      if (!(length == expected_length))\n        return 6;\n      if (!(u32_cmp (result, expected, expected_length) == 0))\n        return 7;\n      free (result);\n      free (preallocated);\n    }\n\n  /* Test return conventions with resultbuf large enough.  */\n  {\n    uint32_t *preallocated;\n\n    length = expected_length;\n    preallocated = (uint32_t *) malloc (length * sizeof (uint32_t));\n    result = u8_to_u32 (input, input_length, preallocated, &length);\n    if (!(result != NULL))\n      return 8;\n    if (!(preallocated == NULL || result == preallocated))\n      return 9;\n    if (!(length == expected_length))\n      return 10;\n    if (!(u32_cmp (result, expected, expected_length) == 0))\n      return 11;\n    free (preallocated);\n  }\n\n  return 0;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Empty string.  */\n  ASSERT (check (NULL, 0, NULL, 0) == 0);\n\n  /* Simple string.  */\n  { /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n    static const uint8_t input[] =\n      { 'G', 'r', 0xC3, 0xBC, 0xC3, 0x9F, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0xD0, 0x97, 0xD0, 0xB4, 0xD1, 0x80, 0xD0, 0xB0, 0xD0, 0xB2, 0xD1, 0x81,\n        0xD1, 0x82, 0xD0, 0xB2, 0xD1, 0x83, 0xD0, 0xB9, 0xD1, 0x82, 0xD0, 0xB5,\n        '!', ' ', 'x', '=', '(', '-', 'b', 0xC2, 0xB1, 's', 'q', 'r', 't', '(',\n        'b', 0xC2, 0xB2, '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')',\n        ' ', ' ', 0xE6, 0x97, 0xA5, 0xE6, 0x9C, 0xAC, 0xE8, 0xAA, 0x9E, ',',\n        0xE4, 0xB8, 0xAD, 0xE6, 0x96, 0x87, ',',\n        0xED, 0x95, 0x9C, 0xEA, 0xB8, 0x80, '\\n'\n      };\n    static const uint32_t expected[] =\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  /* String with characters outside the BMP.  */\n  {\n    static const uint8_t input[] =\n      { '-', '(', 0xF0, 0x9D, 0x94, 0x9E, 0xC3, 0x97, 0xF0, 0x9D, 0x94, 0x9F,\n        ')', '=', 0xF0, 0x9D, 0x94, 0x9F, 0xC3, 0x97, 0xF0, 0x9D, 0x94, 0x9E\n      };\n    static const uint32_t expected[] =\n      { '-', '(', 0x1D51E, 0x00D7, 0x1D51F, ')', '=',\n        0x1D51F, 0x00D7, 0x1D51E\n      };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n  }\n\n  /* Invalid input.  */\n  {\n    static const uint8_t input[] = { 'x', 0xC2, 0xC3, 'y' };\n#if 0 /* Currently invalid input is rejected, not accommodated.  */\n    static const uint32_t expected[] = { 'x', 0xFFFD, 0xFFFD, 'y' };\n    ASSERT (check (input, SIZEOF (input), expected, SIZEOF (expected)) == 0);\n#else\n    size_t length;\n    uint32_t *result;\n    uint32_t preallocated[10];\n\n    /* Test return conventions with resultbuf == NULL.  */\n    result = u8_to_u32 (input, SIZEOF (input), NULL, &length);\n    ASSERT (result == NULL);\n    ASSERT (errno == EILSEQ);\n\n    /* Test return conventions with resultbuf too small.  */\n    length = 1;\n    result = u8_to_u32 (input, SIZEOF (input), preallocated, &length);\n    ASSERT (result == NULL);\n    ASSERT (errno == EILSEQ);\n\n    /* Test return conventions with resultbuf large enough.  */\n    length = SIZEOF (preallocated);\n    result = u8_to_u32 (input, SIZEOF (input), preallocated, &length);\n    ASSERT (result == NULL);\n    ASSERT (errno == EILSEQ);\n#endif\n  }\n\n  return 0;\n}",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/unistr/test-u8-uctomb.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Test ISO 646 character, in particular the NUL character.  */\n  {\n    ucs4_t uc;\n\n    for (uc = 0; uc < 0x80; uc++)\n      {\n        uint8_t buf[5] = { MAGIC, MAGIC, MAGIC, MAGIC, MAGIC };\n        int ret;\n\n        ret = u8_uctomb (buf, uc, 0);\n        ASSERT (ret == -2);\n        ASSERT (buf[0] == MAGIC);\n\n        ret = u8_uctomb (buf, uc, 1);\n        ASSERT (ret == 1);\n        ASSERT (buf[0] == uc);\n        ASSERT (buf[1] == MAGIC);\n      }\n  }\n\n  /* Test 2-byte character.  */\n  {\n    ucs4_t uc = 0x00D7;\n    uint8_t buf[5] = { MAGIC, MAGIC, MAGIC, MAGIC, MAGIC };\n    int ret;\n\n    ret = u8_uctomb (buf, uc, 0);\n    ASSERT (ret == -2);\n    ASSERT (buf[0] == MAGIC);\n\n    ret = u8_uctomb (buf, uc, 1);\n    ASSERT (ret == -2);\n    ASSERT (buf[0] == MAGIC);\n\n    ret = u8_uctomb (buf, uc, 2);\n    ASSERT (ret == 2);\n    ASSERT (buf[0] == 0xC3);\n    ASSERT (buf[1] == 0x97);\n    ASSERT (buf[2] == MAGIC);\n  }\n\n  /* Test 3-byte character.  */\n  {\n    ucs4_t uc = 0x20AC;\n    uint8_t buf[5] = { MAGIC, MAGIC, MAGIC, MAGIC, MAGIC };\n    int ret;\n\n    ret = u8_uctomb (buf, uc, 0);\n    ASSERT (ret == -2);\n    ASSERT (buf[0] == MAGIC);\n\n    ret = u8_uctomb (buf, uc, 1);\n    ASSERT (ret == -2);\n    ASSERT (buf[0] == MAGIC);\n\n    ret = u8_uctomb (buf, uc, 2);\n    ASSERT (ret == -2);\n    ASSERT (buf[0] == MAGIC);\n    ASSERT (buf[1] == MAGIC);\n\n    ret = u8_uctomb (buf, uc, 3);\n    ASSERT (ret == 3);\n    ASSERT (buf[0] == 0xE2);\n    ASSERT (buf[1] == 0x82);\n    ASSERT (buf[2] == 0xAC);\n    ASSERT (buf[3] == MAGIC);\n  }\n\n  /* Test 4-byte character.  */\n  {\n    ucs4_t uc = 0x10FFFD;\n    uint8_t buf[5] = { MAGIC, MAGIC, MAGIC, MAGIC, MAGIC };\n    int ret;\n\n    ret = u8_uctomb (buf, uc, 0);\n    ASSERT (ret == -2);\n    ASSERT (buf[0] == MAGIC);\n\n    ret = u8_uctomb (buf, uc, 1);\n    ASSERT (ret == -2);\n    ASSERT (buf[0] == MAGIC);\n\n    ret = u8_uctomb (buf, uc, 2);\n    ASSERT (ret == -2);\n    ASSERT (buf[0] == MAGIC);\n    ASSERT (buf[1] == MAGIC);\n\n    ret = u8_uctomb (buf, uc, 3);\n    ASSERT (ret == -2);\n    ASSERT (buf[0] == MAGIC);\n    ASSERT (buf[1] == MAGIC);\n    ASSERT (buf[2] == MAGIC);\n\n    ret = u8_uctomb (buf, uc, 4);\n    ASSERT (ret == 4);\n    ASSERT (buf[0] == 0xF4);\n    ASSERT (buf[1] == 0x8F);\n    ASSERT (buf[2] == 0xBF);\n    ASSERT (buf[3] == 0xBD);\n    ASSERT (buf[4] == MAGIC);\n  }\n\n  /* Test invalid characters.  */\n  {\n    ucs4_t invalid[] = { 0x110000, 0xD800, 0xDBFF, 0xDC00, 0xDFFF };\n    uint8_t buf[5] = { MAGIC, MAGIC, MAGIC, MAGIC, MAGIC };\n    size_t i;\n\n    for (i = 0; i < SIZEOF (invalid); i++)\n      {\n        ucs4_t uc = invalid[i];\n        int n;\n\n        for (n = 0; n <= 4; n++)\n          {\n            int ret = u8_uctomb (buf, uc, n);\n            ASSERT (ret == -1);\n            ASSERT (buf[0] == MAGIC);\n            ASSERT (buf[1] == MAGIC);\n            ASSERT (buf[2] == MAGIC);\n            ASSERT (buf[3] == MAGIC);\n            ASSERT (buf[4] == MAGIC);\n          }\n      }\n  }\n\n  return 0;\n}",
      "lines": 131,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uniwbrk/test-u16-wordbreaks.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Test case n = 0.  */\n  u16_wordbreaks (NULL, 0, NULL);\n\n  {\n    static const uint16_t input[61] =\n      /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    char *p = (char *) malloc (SIZEOF (input));\n    size_t i;\n\n    u16_wordbreaks (input, SIZEOF (input), p);\n\n    for (i = 0; i < 61; i++)\n      {\n        ASSERT (p[i] == ((i >= 4 && i <= 5)\n                         || (i >= 9 && i <= 11)\n                         || (i >= 23 && i <= 31)\n                         || (i >= 35 && i <= 39)\n                         || (i >= 42 && i <= 46)\n                         || (i >= 48 && i <= 58)\n                         || i == 60\n                         ? 1 : 0));\n      }\n    free (p);\n  }\n\n  {\n    /* Same input string, decomposed.  */\n    static const uint16_t input[67] =\n      /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n      { 'G', 'r', 0x0075, 0x0308, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0438, 0x0306, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',',\n        0x1112, 0x1161, 0x11AB, 0x1100, 0x1173, 0x11AF, '\\n'\n      };\n    char *p = (char *) malloc (SIZEOF (input));\n    size_t i;\n\n    u16_wordbreaks (input, SIZEOF (input), p);\n\n    for (i = 0; i < 67; i++)\n      {\n        ASSERT (p[i] == ((i >= 5 && i <= 6)\n                         || (i >= 10 && i <= 12)\n                         || (i >= 25 && i <= 33)\n                         || (i >= 37 && i <= 41)\n                         || (i >= 44 && i <= 48)\n                         || (i >= 50 && i <= 60)\n                         || i == 66\n                         ? 1 : 0));\n      }\n    free (p);\n  }\n\n  return 0;\n}",
      "lines": 68,
      "depth": 21,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uniwbrk/test-u32-wordbreaks.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Test case n = 0.  */\n  u32_wordbreaks (NULL, 0, NULL);\n\n  {\n    static const uint32_t input[61] =\n      /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n      { 'G', 'r', 0x00FC, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0439, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',', 0xD55C, 0xAE00, '\\n'\n      };\n    char *p = (char *) malloc (SIZEOF (input));\n    size_t i;\n\n    u32_wordbreaks (input, SIZEOF (input), p);\n\n    for (i = 0; i < 61; i++)\n      {\n        ASSERT (p[i] == ((i >= 4 && i <= 5)\n                         || (i >= 9 && i <= 11)\n                         || (i >= 23 && i <= 31)\n                         || (i >= 35 && i <= 39)\n                         || (i >= 42 && i <= 46)\n                         || (i >= 48 && i <= 58)\n                         || i == 60\n                         ? 1 : 0));\n      }\n    free (p);\n  }\n\n  {\n    /* Same input string, decomposed.  */\n    static const uint32_t input[67] =\n      /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n      { 'G', 'r', 0x0075, 0x0308, 0x00DF, ' ', 'G', 'o', 't', 't', '.', ' ',\n        0x0417, 0x0434, 0x0440, 0x0430, 0x0432, 0x0441, 0x0442, 0x0432, 0x0443,\n        0x0438, 0x0306, 0x0442, 0x0435, '!', ' ',\n        'x', '=', '(', '-', 'b', 0x00B1, 's', 'q', 'r', 't', '(', 'b', 0x00B2,\n        '-', '4', 'a', 'c', ')', ')', '/', '(', '2', 'a', ')', ' ', ' ',\n        0x65E5, 0x672C, 0x8A9E, ',', 0x4E2D, 0x6587, ',',\n        0x1112, 0x1161, 0x11AB, 0x1100, 0x1173, 0x11AF, '\\n'\n      };\n    char *p = (char *) malloc (SIZEOF (input));\n    size_t i;\n\n    u32_wordbreaks (input, SIZEOF (input), p);\n\n    for (i = 0; i < 67; i++)\n      {\n        ASSERT (p[i] == ((i >= 5 && i <= 6)\n                         || (i >= 10 && i <= 12)\n                         || (i >= 25 && i <= 33)\n                         || (i >= 37 && i <= 41)\n                         || (i >= 44 && i <= 48)\n                         || (i >= 50 && i <= 60)\n                         || i == 66\n                         ? 1 : 0));\n      }\n    free (p);\n  }\n\n  return 0;\n}",
      "lines": 68,
      "depth": 21,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uniwbrk/test-u8-wordbreaks.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Test case n = 0.  */\n  u8_wordbreaks (NULL, 0, NULL);\n\n  {\n    static const uint8_t input[91] =\n      /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n      \"Gr\\303\\274\\303\\237 Gott. \\320\\227\\320\\264\\321\\200\\320\\260\\320\\262\\321\\201\\321\\202\\320\\262\\321\\203\\320\\271\\321\\202\\320\\265! x=(-b\\302\\261sqrt(b\\302\\262-4ac))/(2a)  \\346\\227\\245\\346\\234\\254\\350\\252\\236,\\344\\270\\255\\346\\226\\207,\\355\\225\\234\\352\\270\\200\\n\";\n    char *p = (char *) malloc (SIZEOF (input));\n    size_t i;\n\n    u8_wordbreaks (input, SIZEOF (input), p);\n\n    for (i = 0; i < 91; i++)\n      {\n        ASSERT (p[i] == ((i >= 6 && i <= 7)\n                         || (i >= 11 && i <= 13)\n                         || (i >= 37 && i <= 44)\n                         || i == 46 || (i >= 50 && i <= 52)\n                         || (i >= 54 && i <= 55)\n                         || (i >= 58 && i <= 62) || (i >= 64 && i <= 67)\n                         || i == 70 || i == 73 || i == 76\n                         || i == 77 || i == 80 || i == 83\n                         || i == 84 || i == 90\n                         ? 1 : 0));\n      }\n    free (p);\n  }\n\n  {\n    /* Same input string, decomposed.  */\n    static const uint8_t input[106] =\n      /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d1\u0081\u00d1\u0082\u00d0\u00b2\u00d1\u0083\u00d0\u00b9\u00d1\u0082\u00d0\u00b5! x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)  \u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e,\u00e4\u00b8\u00ad\u00e6\u0096\u0087,\u00ed\u0095\u009c\u00ea\u00b8\u0080\" */\n      \"Gru\\314\\210\\303\\237 Gott. \\320\\227\\320\\264\\321\\200\\320\\260\\320\\262\\321\\201\\321\\202\\320\\262\\321\\203\\320\\270\\314\\206\\321\\202\\320\\265! x=(-b\\302\\261sqrt(b\\302\\262-4ac))/(2a)  \\346\\227\\245\\346\\234\\254\\350\\252\\236,\\344\\270\\255\\346\\226\\207,\\341\\204\\222\\341\\205\\241\\341\\206\\253\\341\\204\\200\\341\\205\\263\\341\\206\\257\\n\";\n    char *p = (char *) malloc (SIZEOF (input));\n    size_t i;\n\n    u8_wordbreaks (input, SIZEOF (input), p);\n\n    for (i = 0; i < 106; i++)\n      {\n        ASSERT (p[i] == ((i >= 7 && i <= 8)\n                         || (i >= 12 && i <= 14)\n                         || (i >= 40 && i <= 47)\n                         || i == 49 || (i >= 53 && i <= 55)\n                         || (i >= 57 && i <= 58)\n                         || (i >= 61 && i <= 65) || (i >= 67 && i <= 70)\n                         || i == 73 || i == 76 || i == 79\n                         || i == 80 || i == 83 || i == 86\n                         || i == 87 || i == 105\n                         ? 1 : 0));\n      }\n    free (p);\n  }\n\n  return 0;\n}",
      "lines": 59,
      "depth": 30,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uniwbrk/test-uc-wordbreaks.c": {
    "wordbreakproperty_to_string": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "const char *\nwordbreakproperty_to_string (int wbp)\n{\n  switch (wbp)\n    {\n#define CASE(VALUE) case WBP_##VALUE: return #VALUE;\n      CASE(OTHER)\n      CASE(CR)\n      CASE(LF)\n      CASE(NEWLINE)\n      CASE(EXTEND)\n      CASE(FORMAT)\n      CASE(KATAKANA)\n      CASE(ALETTER)\n      CASE(MIDNUMLET)\n      CASE(MIDLETTER)\n      CASE(MIDNUM)\n      CASE(NUMERIC)\n      CASE(EXTENDNUMLET)\n      CASE(RI)\n      CASE(DQ)\n      CASE(SQ)\n      CASE(HL)\n      CASE(ZWJ)\n      CASE(EB)\n      CASE(EM)\n      CASE(GAZ)\n      CASE(EBG)\n    }\n  abort ();\n}",
      "lines": 31,
      "depth": 9,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nwordbreakproperty_to_string (int wbp)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  const char *filename;\n  char line[4096];\n  int exit_code;\n  FILE *stream;\n  int lineno;\n\n  if (argc != 2)\n    {\n      fprintf (stderr, \"usage: %s FILENAME\\n\"\n               \"where FILENAME is the location of the WordBreakTest.txt\\n\"\n               \"test file.\\n\", argv[0]);\n      exit (1);\n    }\n\n  filename = argv[1];\n  stream = fopen (filename, \"r\");\n  if (stream == NULL)\n    {\n      fprintf (stderr, \"error during fopen of '%s'\\n\", filename);\n      exit (1);\n    }\n\n  exit_code = 0;\n  lineno = 0;\n  while (fgets (line, sizeof line, stream))\n    {\n      char *comment;\n      const char *p;\n      uint32_t input[100];\n      char breaks[101];\n      char breaks_expected[101];\n      int i;\n\n      lineno++;\n\n      memset (breaks, 0, sizeof (breaks));\n      memset (breaks_expected, 0, sizeof (breaks_expected));\n\n      comment = strchr (line, '#');\n      if (comment != NULL)\n        *comment = '\\0';\n      if (line[strspn (line, \" \\t\\r\\n\")] == '\\0')\n        continue;\n\n      i = 0;\n      p = line;\n      do\n        {\n          p += strspn (p, \" \\t\\r\\n\");\n          if (!strncmp (p, \"\\303\\267\" /* \u00c3\u00b7 */, 2))\n            {\n\t      breaks_expected[i] = 1;\n              p += 2;\n            }\n          else if (!strncmp (p, \"\\303\\227\" /* \u00c3\u0097 */, 2))\n            {\n\t      breaks_expected[i] = 0;\n              p += 2;\n            }\n          else\n            {\n              fprintf (stderr, \"%s:%d.%d: syntax error expecting '\u00c3\u00b7' or '\u00c3\u0097'\\n\",\n                       filename, lineno, (int) (p - line + 1));\n              exit (1);\n            }\n\n          p += strspn (p, \" \\t\\r\\n\");\n          if (*p != '\\0')\n            {\n              unsigned int next_int;\n              int n;\n\n              if (sscanf (p, \"%x%n\", &next_int, &n) != 1)\n                {\n                  fprintf (stderr, \"%s:%d.%d: syntax error at '%s' \"\n                           \"expecting hexadecimal Unicode code point number\\n\",\n                           filename, lineno, (int) (p - line + 1), p);\n                  exit (1);\n                }\n              p += n;\n\n\t      input[i] = next_int;\n\t    }\n\n          p += strspn (p, \" \\t\\r\\n\");\n\t  i++;\n        }\n      while (*p != '\\0');\n\n      u32_wordbreaks (input, i - 1, breaks);\n\n      /* u32_wordbreaks always set BREAKS[0] to 0.  */\n      breaks[0] = breaks_expected[0] = 1;\n      if (memcmp (breaks, breaks_expected, i - 1) != 0)\n\t{\n\t  int j;\n\n\t  fprintf (stderr, \"%s:%d: expected: \", filename, lineno);\n\t  for (j = 0; j < i - 1; j++)\n\t    {\n\t      int input_wbp = uc_wordbreak_property (input[j]);\n\t      fprintf (stderr, \"%s U+%04X (%s) \",\n\t\t       breaks_expected[j] == 1 ? \"\\303\\267\" : \"\\303\\227\",\n\t\t       input[j], wordbreakproperty_to_string (input_wbp));\n\t    }\n\t  fprintf (stderr, \"\\n\");\n\t  fprintf (stderr, \"%s:%d: actual: \", filename, lineno);\n\t  for (j = 0; j < i - 1; j++)\n\t    {\n\t      int input_wbp = uc_wordbreak_property (input[j]);\n\t      fprintf (stderr, \"%s U+%04X (%s) \",\n\t\t       breaks[j] == 1 ? \"\\303\\267\" : \"\\303\\227\",\n\t\t       input[j], wordbreakproperty_to_string (input_wbp));\n\t    }\n\t  fprintf (stderr, \"\\n\");\n\t  exit_code = 1;\n\t}\n    }\n\n  return exit_code;\n}",
      "lines": 124,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uniwbrk/test-ulc-wordbreaks.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nmain ()\n{\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  /* Test case n = 0.  */\n  ulc_wordbreaks (NULL, 0, NULL);\n\n#if HAVE_ICONV\n  {\n    static const char input[36] =\n      /* \"Gr\u00c3\u00bc\u00c3\u009f Gott. x=(-b\u00c2\u00b1sqrt(b\u00c2\u00b2-4ac))/(2a)\" */\n      \"Gr\\374\\337 Gott. x=(-b\\261sqrt(b\\262-4ac))/(2a)\\n\";\n    char *p = (char *) malloc (SIZEOF (input));\n    size_t i;\n\n    ulc_wordbreaks (input, SIZEOF (input), p);\n\n    for (i = 0; i < 36; i++)\n      {\n        ASSERT (p[i] == ((i >= 4 && i <= 5)\n                         || (i >= 9 && i <= 17)\n                         || (i >= 21 && i <= 25)\n                         || (i >= 28 && i <= 32)\n                         || (i >= 34 && i <= 35)\n                         ? 1 : 0));\n      }\n    free (p);\n  }\n#endif\n\n  return 0;\n}",
      "lines": 35,
      "depth": 20,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uniwidth/test-u16-strwidth.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\nmain ()\n{\n  {\n    static const uint16_t input[] = /* \"Danilo \u00c5\u00a0egan\" */\n      { 'D', 'a', 'n', 'i', 'l', 'o', ' ', 0x0160, 'e', 'g', 'a', 'n', 0 };\n    ASSERT (u16_strwidth (input, \"UTF-8\") == 12);\n  }\n\n  {\n    static const uint16_t input[] = /* \"Danilo \u00c5\u00a0egan\" decomposed */\n      { 'D', 'a', 'n', 'i', 'l', 'o', ' ', 'S', 0x030C, 'e', 'g', 'a', 'n', 0 };\n    ASSERT (u16_strwidth (input, \"UTF-8\") == 12);\n  }\n\n  {\n    static const uint16_t input[] = /* \"\u00d0\u0094\u00d0\u00b0\u00d0\u00bd\u00d0\u00b8\u00d0\u00bb\u00d0\u00be \u00d0\u00a8\u00d0\u00b5\u00d0\u00b3\u00d0\u00b0\u00d0\u00bd\" */\n      {\n        0x0414, 0x0430, 0x043D, 0x0438, 0x043B, 0x043E, ' ',\n        0x0428, 0x0435, 0x0433, 0x0430, 0x043D, 0\n      };\n    ASSERT (u16_strwidth (input, \"UTF-8\") == 12);\n    ASSERT (u16_strwidth (input, \"EUC-JP\") == 23);\n  }\n\n  {\n    static const uint16_t input[] = /* \u00e5\u0088\u0098\u00e5\u0086\u009b\u00e6\u00b0\u0091 */\n      { 0x5218, 0x519B, 0x6C11, 0 };\n    ASSERT (u16_strwidth (input, \"UTF-8\") == 6);\n    ASSERT (u16_strwidth (input, \"GB2312\") == 6);\n  }\n\n  return 0;\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uniwidth/test-u16-width.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "int\nmain ()\n{\n  static const uint16_t input[] =\n    {\n      #define INPUT1_OFFSET 0\n      #define INPUT1_LENGTH 12\n      'D', 'a', 'n', 'i', 'l', 'o', ' ', 0x0160, 'e', 'g', 'a', 'n',\n      #define INPUT2_OFFSET 12\n      #define INPUT2_LENGTH 13\n      'D', 'a', 'n', 'i', 'l', 'o', ' ', 'S', 0x030C, 'e', 'g', 'a', 'n',\n      #define INPUT3_OFFSET 25\n      #define INPUT3_LENGTH 12\n      0x0414, 0x0430, 0x043D, 0x0438, 0x043B, 0x043E, ' ',\n      0x0428, 0x0435, 0x0433, 0x0430, 0x043D,\n      #define INPUT4_OFFSET 37\n      #define INPUT4_LENGTH 3\n      0x5218, 0x519B, 0x6C11\n    };\n\n  { /* \"Danilo \u00c5\u00a0egan\" */\n    ASSERT (u16_width (input + INPUT1_OFFSET, INPUT1_LENGTH, \"UTF-8\") == 12);\n  }\n\n  { /* \"Danilo \u00c5\u00a0egan\" decomposed */\n    ASSERT (u16_width (input + INPUT2_OFFSET, INPUT2_LENGTH, \"UTF-8\") == 12);\n  }\n\n  { /* \"\u00d0\u0094\u00d0\u00b0\u00d0\u00bd\u00d0\u00b8\u00d0\u00bb\u00d0\u00be \u00d0\u00a8\u00d0\u00b5\u00d0\u00b3\u00d0\u00b0\u00d0\u00bd\" */\n    ASSERT (u16_width (input + INPUT3_OFFSET, INPUT3_LENGTH, \"UTF-8\") == 12);\n    ASSERT (u16_width (input + INPUT3_OFFSET, INPUT3_LENGTH, \"EUC-JP\") == 23);\n  }\n\n  { /* \u00e5\u0088\u0098\u00e5\u0086\u009b\u00e6\u00b0\u0091 */\n    ASSERT (u16_width (input + INPUT4_OFFSET, INPUT4_LENGTH, \"UTF-8\") == 6);\n    ASSERT (u16_width (input + INPUT4_OFFSET, INPUT4_LENGTH, \"GB2312\") == 6);\n  }\n\n  return 0;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uniwidth/test-u32-strwidth.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\nmain ()\n{\n  {\n    static const uint32_t input[] = /* \"Danilo \u00c5\u00a0egan\" */\n      { 'D', 'a', 'n', 'i', 'l', 'o', ' ', 0x0160, 'e', 'g', 'a', 'n', 0 };\n    ASSERT (u32_strwidth (input, \"UTF-8\") == 12);\n  }\n\n  {\n    static const uint32_t input[] = /* \"Danilo \u00c5\u00a0egan\" decomposed */\n      { 'D', 'a', 'n', 'i', 'l', 'o', ' ', 'S', 0x030C, 'e', 'g', 'a', 'n', 0 };\n    ASSERT (u32_strwidth (input, \"UTF-8\") == 12);\n  }\n\n  {\n    static const uint32_t input[] = /* \"\u00d0\u0094\u00d0\u00b0\u00d0\u00bd\u00d0\u00b8\u00d0\u00bb\u00d0\u00be \u00d0\u00a8\u00d0\u00b5\u00d0\u00b3\u00d0\u00b0\u00d0\u00bd\" */\n      {\n        0x0414, 0x0430, 0x043D, 0x0438, 0x043B, 0x043E, ' ',\n        0x0428, 0x0435, 0x0433, 0x0430, 0x043D, 0\n      };\n    ASSERT (u32_strwidth (input, \"UTF-8\") == 12);\n    ASSERT (u32_strwidth (input, \"EUC-JP\") == 23);\n  }\n\n  {\n    static const uint32_t input[] = /* \u00e5\u0088\u0098\u00e5\u0086\u009b\u00e6\u00b0\u0091 */\n      { 0x5218, 0x519B, 0x6C11, 0 };\n    ASSERT (u32_strwidth (input, \"UTF-8\") == 6);\n    ASSERT (u32_strwidth (input, \"GB2312\") == 6);\n  }\n\n  return 0;\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uniwidth/test-u32-width.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "int\nmain ()\n{\n  static const uint32_t input[] =\n    {\n      #define INPUT1_OFFSET 0\n      #define INPUT1_LENGTH 12\n      'D', 'a', 'n', 'i', 'l', 'o', ' ', 0x0160, 'e', 'g', 'a', 'n',\n      #define INPUT2_OFFSET 12\n      #define INPUT2_LENGTH 13\n      'D', 'a', 'n', 'i', 'l', 'o', ' ', 'S', 0x030C, 'e', 'g', 'a', 'n',\n      #define INPUT3_OFFSET 25\n      #define INPUT3_LENGTH 12\n      0x0414, 0x0430, 0x043D, 0x0438, 0x043B, 0x043E, ' ',\n      0x0428, 0x0435, 0x0433, 0x0430, 0x043D,\n      #define INPUT4_OFFSET 37\n      #define INPUT4_LENGTH 3\n      0x5218, 0x519B, 0x6C11\n    };\n\n  { /* \"Danilo \u00c5\u00a0egan\" */\n    ASSERT (u32_width (input + INPUT1_OFFSET, INPUT1_LENGTH, \"UTF-8\") == 12);\n  }\n\n  { /* \"Danilo \u00c5\u00a0egan\" decomposed */\n    ASSERT (u32_width (input + INPUT2_OFFSET, INPUT2_LENGTH, \"UTF-8\") == 12);\n  }\n\n  { /* \"\u00d0\u0094\u00d0\u00b0\u00d0\u00bd\u00d0\u00b8\u00d0\u00bb\u00d0\u00be \u00d0\u00a8\u00d0\u00b5\u00d0\u00b3\u00d0\u00b0\u00d0\u00bd\" */\n    ASSERT (u32_width (input + INPUT3_OFFSET, INPUT3_LENGTH, \"UTF-8\") == 12);\n    ASSERT (u32_width (input + INPUT3_OFFSET, INPUT3_LENGTH, \"EUC-JP\") == 23);\n  }\n\n  { /* \u00e5\u0088\u0098\u00e5\u0086\u009b\u00e6\u00b0\u0091 */\n    ASSERT (u32_width (input + INPUT4_OFFSET, INPUT4_LENGTH, \"UTF-8\") == 6);\n    ASSERT (u32_width (input + INPUT4_OFFSET, INPUT4_LENGTH, \"GB2312\") == 6);\n  }\n\n  return 0;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uniwidth/test-u8-strwidth.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "int\nmain ()\n{\n  {\n    static const uint8_t input[] = \"Danilo \\305\\240egan\"; /* \"Danilo \u00c5\u00a0egan\" */\n    ASSERT (u8_strwidth (input, \"UTF-8\") == 12);\n  }\n\n  {\n    static const uint8_t input[] = \"Danilo S\\314\\214egan\"; /* \"Danilo \u00c5\u00a0egan\" decomposed */\n    ASSERT (u8_strwidth (input, \"UTF-8\") == 12);\n  }\n\n  {\n    static const uint8_t input[] = /* \"\u00d0\u0094\u00d0\u00b0\u00d0\u00bd\u00d0\u00b8\u00d0\u00bb\u00d0\u00be \u00d0\u00a8\u00d0\u00b5\u00d0\u00b3\u00d0\u00b0\u00d0\u00bd\" */\n      \"\\320\\224\\320\\260\\320\\275\\320\\270\\320\\273\\320\\276 \\320\\250\\320\\265\\320\\263\\320\\260\\320\\275\";\n    ASSERT (u8_strwidth (input, \"UTF-8\") == 12);\n    ASSERT (u8_strwidth (input, \"EUC-JP\") == 23);\n  }\n\n  {\n    static const uint8_t input[] = /* \u00e5\u0088\u0098\u00e5\u0086\u009b\u00e6\u00b0\u0091 */\n      \"\\345\\210\\230\\345\\206\\233\\346\\260\\221\";\n    ASSERT (u8_strwidth (input, \"UTF-8\") == 6);\n    ASSERT (u8_strwidth (input, \"GB2312\") == 6);\n  }\n\n  return 0;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uniwidth/test-u8-width.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nmain ()\n{\n  static const uint8_t input[] =\n    #define INPUT1_OFFSET 0\n    #define INPUT1_LENGTH 13\n    \"Danilo \\305\\240egan\"\n    #define INPUT2_OFFSET 13\n    #define INPUT2_LENGTH 14\n    \"Danilo S\\314\\214egan\"\n    #define INPUT3_OFFSET 27\n    #define INPUT3_LENGTH 23\n    \"\\320\\224\\320\\260\\320\\275\\320\\270\\320\\273\\320\\276 \\320\\250\\320\\265\\320\\263\\320\\260\\320\\275\"\n    #define INPUT4_OFFSET 50\n    #define INPUT4_LENGTH 9\n    \"\\345\\210\\230\\345\\206\\233\\346\\260\\221\"\n    ;\n\n  { /* \"Danilo \u00c5\u00a0egan\" */\n    ASSERT (u8_width (input + INPUT1_OFFSET, INPUT1_LENGTH, \"UTF-8\") == 12);\n  }\n\n  { /* \"Danilo \u00c5\u00a0egan\" decomposed */\n    ASSERT (u8_width (input + INPUT2_OFFSET, INPUT2_LENGTH, \"UTF-8\") == 12);\n  }\n\n  { /* \"\u00d0\u0094\u00d0\u00b0\u00d0\u00bd\u00d0\u00b8\u00d0\u00bb\u00d0\u00be \u00d0\u00a8\u00d0\u00b5\u00d0\u00b3\u00d0\u00b0\u00d0\u00bd\" */\n    ASSERT (u8_width (input + INPUT3_OFFSET, INPUT3_LENGTH, \"UTF-8\") == 12);\n    ASSERT (u8_width (input + INPUT3_OFFSET, INPUT3_LENGTH, \"EUC-JP\") == 23);\n  }\n\n  { /* \u00e5\u0088\u0098\u00e5\u0086\u009b\u00e6\u00b0\u0091 */\n    ASSERT (u8_width (input + INPUT4_OFFSET, INPUT4_LENGTH, \"UTF-8\") == 6);\n    ASSERT (u8_width (input + INPUT4_OFFSET, INPUT4_LENGTH, \"GB2312\") == 6);\n  }\n\n  return 0;\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uniwidth/test-uc_width.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nmain ()\n{\n  ucs4_t uc;\n\n  /* Test width of ASCII characters.  */\n  for (uc = 0x0020; uc < 0x007F; uc++)\n    ASSERT (uc_width (uc, \"ISO-8859-2\") == 1);\n\n  /* Test width of some non-spacing characters.  */\n  ASSERT (uc_width (0x0301, \"UTF-8\") == 0);\n  ASSERT (uc_width (0x05B0, \"UTF-8\") == 0);\n\n  /* Test width of some format control characters.  */\n  ASSERT (uc_width (0x200E, \"UTF-8\") == 0);\n  ASSERT (uc_width (0x2060, \"UTF-8\") == 0);\n  ASSERT (uc_width (0xE0001, \"UTF-8\") == 0);\n  ASSERT (uc_width (0xE0044, \"UTF-8\") == 0);\n\n  /* Test width of some zero width characters.  */\n  ASSERT (uc_width (0x200B, \"UTF-8\") == 0);\n  ASSERT (uc_width (0xFEFF, \"UTF-8\") == 0);\n\n  /* Test width of some CJK characters.  */\n  ASSERT (uc_width (0x3000, \"UTF-8\") == 2);\n  ASSERT (uc_width (0xB250, \"UTF-8\") == 2);\n  ASSERT (uc_width (0xFF1A, \"UTF-8\") == 2);\n  ASSERT (uc_width (0x20369, \"UTF-8\") == 2);\n  ASSERT (uc_width (0x2F876, \"UTF-8\") == 2);\n\n  return 0;\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/tests/uniwidth/test-uc_width2.c": {
    "finish_interval": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static void\nfinish_interval (void)\n{\n  if (current_width != 0)\n    {\n      if (current_start == current_end)\n        printf (\"%04X\\t\\t%c\\n\", (unsigned) current_start, current_width);\n      else\n        printf (\"%04X..%04X\\t%c\\n\", (unsigned) current_start,\n                (unsigned) current_end, current_width);\n      current_width = 0;\n    }\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "add_to_interval": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static void\nadd_to_interval (ucs4_t uc, char width)\n{\n  if (current_width == width && uc == current_end + 1)\n    current_end = uc;\n  else\n    {\n      finish_interval ();\n      current_width = width;\n      current_start = current_end = uc;\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "int\nmain ()\n{\n  ucs4_t uc;\n\n  for (uc = 0; uc < 0x110000; uc++)\n    {\n      int w1 = uc_width (uc, \"UTF-8\");\n      int w2 = uc_width (uc, \"GBK\");\n      char width =\n        (w1 == 0 && w2 == 0 ? '0' :\n         w1 == 1 && w2 == 1 ? '1' :\n         w1 == 1 && w2 == 2 ? 'A' :\n         w1 == 2 && w2 == 2 ? '2' :\n         0);\n      if (width == 0)\n        {\n          /* uc must be a control character.  */\n          ASSERT (w1 < 0 && w2 < 0);\n        }\n      else\n        add_to_interval (uc, width);\n    }\n  finish_interval ();\n\n  return 0;\n}",
      "lines": 27,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "libunistring/libunistring-0.9.10/woe32dll/export.h": {},
  "libunistring/libunistring-0.9.10/woe32dll/unistring-exports.c": {}
}