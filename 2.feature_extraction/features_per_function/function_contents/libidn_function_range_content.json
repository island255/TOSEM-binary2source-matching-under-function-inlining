{
  "libidn/libidn2-2.0.5/doc/decode.c": {
    "main": {
      "start_point": [
        7,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int rc;\n  char src[BUFSIZ];\n  char *decoded;\n\n  setlocale (LC_ALL, \"\");\n\n  printf (\"Enter (possibly non-ASCII) domain name to decode: \");\n  fflush (stdout);\n  if (!fgets (src, sizeof (src), stdin))\n    {\n      perror (\"fgets\");\n      return 1;\n    }\n  src[strlen (src) - 1] = '\\0';\n\n  rc = idn2_to_unicode_lzlz (src, &decoded, 0);\n  if (rc != IDN2_OK)\n    {\n      fprintf (stderr, \"error: %s (%s, %d)\\n\",\n\t       idn2_strerror (rc), idn2_strerror_name (rc), rc);\n      return 1;\n    }\n\n  printf (\"Decoded domain name: %s\\n\", decoded);\n\n  free (decoded);\n\n  return 0;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/doc/example-toascii.c": {
    "main": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\nmain (void)\n{\n  char buf[BUFSIZ];\n  char *p;\n  int rc;\n  size_t i;\n\n  if (!fgets (buf, BUFSIZ, stdin))\n    perror (\"fgets\");\n  buf[strlen (buf) - 1] = '\\0';\n\n  printf (\"Read string (length %ld): \", (long int) strlen (buf));\n  for (i = 0; i < strlen (buf); i++)\n    printf (\"%02x \", (unsigned) buf[i] & 0xFF);\n  printf (\"\\n\");\n\n  /* Use non-transitional IDNA2008 */\n  rc = idn2_to_ascii_8z (buf, &p, IDN2_NONTRANSITIONAL);\n  if (rc != IDNA_SUCCESS)\n    {\n      printf (\"ToASCII() failed (%d): %s\\n\", rc, idn2_strerror (rc));\n      return EXIT_FAILURE;\n    }\n\n  printf (\"ACE label (length %ld): '%s'\\n\", (long int) strlen (p), p);\n\n  free (p); /* or idn2_free() */\n\n  return 0;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/doc/example-tounicode.c": {
    "main": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\nmain (void)\n{\n  char buf[BUFSIZ];\n  char *p;\n  int rc;\n  size_t i;\n\n  if (!fgets (buf, BUFSIZ, stdin))\n    perror (\"fgets\");\n  buf[strlen (buf) - 1] = '\\0';\n\n  printf (\"Read string (length %ld): \", (long int) strlen (buf));\n  for (i = 0; i < strlen (buf); i++)\n    printf (\"%02x \", (unsigned) buf[i] & 0xFF);\n  printf (\"\\n\");\n\n  rc = idn2_to_unicode_8z8z (buf, &p, 0);\n  if (rc != IDNA_SUCCESS)\n    {\n      printf (\"ToUnicode() failed (%d): %s\\n\", rc, idn2_strerror (rc));\n      return EXIT_FAILURE;\n    }\n\n  printf (\"ACE label (length %ld): '%s'\\n\", (long int) strlen (p), p);\n\n  free (p); /* or idn2_free() */\n\n  return 0;\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/doc/lookup.c": {
    "main": {
      "start_point": [
        6,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int rc;\n  char src[BUFSIZ];\n  char *lookupname;\n\n  setlocale (LC_ALL, \"\");\n\n  printf (\"Enter (possibly non-ASCII) domain name to lookup: \");\n  fflush (stdout);\n  if (!fgets (src, sizeof (src), stdin))\n    {\n      perror (\"fgets\");\n      return 1;\n    }\n  src[strlen (src) - 1] = '\\0';\n\n  rc = idn2_lookup_ul (src, &lookupname, 0);\n  if (rc != IDN2_OK)\n    {\n      fprintf (stderr, \"error: %s (%s, %d)\\n\",\n\t       idn2_strerror (rc), idn2_strerror_name (rc), rc);\n      return 1;\n    }\n\n  printf (\"IDNA2008 domain name to lookup in DNS: %s\\n\", lookupname);\n\n  free (lookupname);\n\n  return 0;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/doc/register.c": {
    "main": {
      "start_point": [
        6,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int rc;\n  char src[BUFSIZ];\n  char *insertname;\n\n  setlocale (LC_ALL, \"\");\n\n  printf (\"Enter (possibly non-ASCII) label to register: \");\n  fflush (stdout);\n  if (!fgets (src, sizeof (src), stdin))\n    {\n      perror (\"fgets\");\n      return 1;\n    }\n  src[strlen (src) - 1] = '\\0';\n\n  rc = idn2_register_ul (src, NULL, &insertname, 0);\n  if (rc != IDN2_OK)\n    {\n      fprintf (stderr, \"error: %s (%s, %d)\\n\",\n\t       idn2_strerror (rc), idn2_strerror_name (rc), rc);\n      return 1;\n    }\n\n  printf (\"IDNA2008 label to register in DNS: %s\\n\", insertname);\n\n  free (insertname);\n\n  return 0;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/examples/decode.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int rc;\n  char src[BUFSIZ];\n  char *decoded;\n\n  setlocale (LC_ALL, \"\");\n\n  printf (\"Enter (possibly non-ASCII) domain name to decode: \");\n  fflush (stdout);\n  if (!fgets (src, sizeof (src), stdin))\n    {\n      perror (\"fgets\");\n      return 1;\n    }\n  src[strlen (src) - 1] = '\\0';\n\n  rc = idn2_to_unicode_lzlz (src, &decoded, 0);\n  if (rc != IDN2_OK)\n    {\n      fprintf (stderr, \"error: %s (%s, %d)\\n\",\n\t       idn2_strerror (rc), idn2_strerror_name (rc), rc);\n      return 1;\n    }\n\n  printf (\"Decoded domain name: %s\\n\", decoded);\n\n  free (decoded);\n\n  return 0;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/examples/example-toascii.c": {
    "main": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\nmain (void)\n{\n  char buf[BUFSIZ];\n  char *p;\n  int rc;\n  size_t i;\n\n  if (!fgets (buf, BUFSIZ, stdin))\n    perror (\"fgets\");\n  buf[strlen (buf) - 1] = '\\0';\n\n  printf (\"Read string (length %ld): \", (long int) strlen (buf));\n  for (i = 0; i < strlen (buf); i++)\n    printf (\"%02x \", (unsigned) buf[i] & 0xFF);\n  printf (\"\\n\");\n\n  /* Use non-transitional IDNA2008 */\n  rc = idn2_to_ascii_8z (buf, &p, IDN2_NONTRANSITIONAL);\n  if (rc != IDNA_SUCCESS)\n    {\n      printf (\"ToASCII() failed (%d): %s\\n\", rc, idn2_strerror (rc));\n      return EXIT_FAILURE;\n    }\n\n  printf (\"ACE label (length %ld): '%s'\\n\", (long int) strlen (p), p);\n\n  free (p); /* or idn2_free() */\n\n  return 0;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/examples/example-tounicode.c": {
    "main": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\nmain (void)\n{\n  char buf[BUFSIZ];\n  char *p;\n  int rc;\n  size_t i;\n\n  if (!fgets (buf, BUFSIZ, stdin))\n    perror (\"fgets\");\n  buf[strlen (buf) - 1] = '\\0';\n\n  printf (\"Read string (length %ld): \", (long int) strlen (buf));\n  for (i = 0; i < strlen (buf); i++)\n    printf (\"%02x \", (unsigned) buf[i] & 0xFF);\n  printf (\"\\n\");\n\n  rc = idn2_to_unicode_8z8z (buf, &p, 0);\n  if (rc != IDNA_SUCCESS)\n    {\n      printf (\"ToUnicode() failed (%d): %s\\n\", rc, idn2_strerror (rc));\n      return EXIT_FAILURE;\n    }\n\n  printf (\"ACE label (length %ld): '%s'\\n\", (long int) strlen (p), p);\n\n  free (p); /* or idn2_free() */\n\n  return 0;\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/examples/lookup.c": {
    "main": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int rc;\n  char src[BUFSIZ];\n  char *lookupname;\n\n  setlocale (LC_ALL, \"\");\n\n  printf (\"Enter (possibly non-ASCII) domain name to lookup: \");\n  fflush (stdout);\n  if (!fgets (src, sizeof (src), stdin))\n    {\n      perror (\"fgets\");\n      return 1;\n    }\n  src[strlen (src) - 1] = '\\0';\n\n  rc = idn2_lookup_ul (src, &lookupname, 0);\n  if (rc != IDN2_OK)\n    {\n      fprintf (stderr, \"error: %s (%s, %d)\\n\",\n\t       idn2_strerror (rc), idn2_strerror_name (rc), rc);\n      return 1;\n    }\n\n  printf (\"IDNA2008 domain name to lookup in DNS: %s\\n\", lookupname);\n\n  free (lookupname);\n\n  return 0;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/examples/register.c": {
    "main": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int rc;\n  char src[BUFSIZ];\n  char *insertname;\n\n  setlocale (LC_ALL, \"\");\n\n  printf (\"Enter (possibly non-ASCII) label to register: \");\n  fflush (stdout);\n  if (!fgets (src, sizeof (src), stdin))\n    {\n      perror (\"fgets\");\n      return 1;\n    }\n  src[strlen (src) - 1] = '\\0';\n\n  rc = idn2_register_ul (src, NULL, &insertname, 0);\n  if (rc != IDN2_OK)\n    {\n      fprintf (stderr, \"error: %s (%s, %d)\\n\",\n\t       idn2_strerror (rc), idn2_strerror_name (rc), rc);\n      return 1;\n    }\n\n  printf (\"IDNA2008 label to register in DNS: %s\\n\", insertname);\n\n  free (insertname);\n\n  return 0;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/fuzz/fuzzer.h": {},
  "libidn/libidn2-2.0.5/fuzz/libidn2_to_ascii_8z_fuzzer.c": {
    "LLVMFuzzerTestOneInput": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n\tchar *domain;\n\tchar *out;\n\n\tif (size > 1024)\n\t\treturn 0;\n\n\tdomain = (char *) malloc(size + 1);\n\tassert(domain != NULL);\n\n\t/* 0 terminate */\n\tmemcpy(domain, data, size);\n\tdomain[size] = 0;\n\n\tfor (unsigned it = 0; it < sizeof(flags)/sizeof(flags[0]); it++) {\n\t\tif (idn2_to_ascii_8z(domain, &out, flags[it]) == IDNA_SUCCESS)\n\t\t\tidn2_free(out);\n\t}\n\n\tfree(domain);\n\treturn 0;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/fuzz/libidn2_to_unicode_8z8z_fuzzer.c": {
    "LLVMFuzzerTestOneInput": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n\tchar *domain;\n\tchar *out;\n\n\tif (size > 1024)\n\t\treturn 0;\n\n\tdomain = (char *) malloc(size + 1);\n\tassert(domain != NULL);\n\n\t// 0 terminate\n\tmemcpy(domain, data, size);\n\tdomain[size] = 0;\n\n\t// internally calls idn2_to_unicode_8zlz(), idn2_to_unicode_8z8z(), idn2_to_unicode_8z4z()\n\tif (idn2_to_unicode_lzlz(domain, &out, 0) == IDNA_SUCCESS)\n\t\tidn2_free(out);\n\n\tif ((size & 3) == 0) {\n\t\tuint32_t *u32 = (uint32_t *) malloc(size);\n\t\tsize_t u32len;\n\n\t\tassert(u32 != NULL);\n\n\t\t// internally calls idn2_to_unicode_4z4z(), idn2_to_unicode_8z4z()\n\t\tu32len = size / 4;\n\t\tidn2_to_unicode_44i((uint32_t *) data, size / 4, u32, &u32len, 0);\n\n\t\tfree(u32);\n\t}\n\n\tfree(domain);\n\treturn 0;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/fuzz/main.c": {
    "test_all_from": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static void test_all_from(const char *dirname)\n{\n\tDIR *dirp;\n\tstruct dirent *dp;\n\n\tif ((dirp = opendir(dirname))) {\n\t\twhile ((dp = readdir(dirp))) {\n\t\t\tif (*dp->d_name == '.') continue;\n\n\t\t\tchar fname[strlen(dirname) + strlen(dp->d_name) + 2];\n\t\t\tsnprintf(fname, sizeof(fname), \"%s/%s\", dirname, dp->d_name);\n\n\t\t\tint fd;\n\t\t\tif ((fd = open(fname, O_RDONLY)) == -1) {\n\t\t\t\tfprintf(stderr, \"Failed to open %s (%d)\\n\", fname, errno);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tstruct stat st;\n\t\t\tif (fstat(fd, &st) != 0) {\n\t\t\t\tfprintf(stderr, \"Failed to stat %d (%d)\\n\", fd, errno);\n\t\t\t\tclose(fd);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tuint8_t *data = malloc(st.st_size);\n\t\t\tssize_t n;\n\t\t\tif ((n = read(fd, data, st.st_size)) == st.st_size) {\n\t\t\t\tprintf(\"testing %llu bytes from '%s'\\n\", (unsigned long long) st.st_size, fname);\n\t\t\t\tLLVMFuzzerTestOneInput(data, st.st_size);\n\t\t\t} else\n\t\t\t\tfprintf(stderr, \"Failed to read %llu bytes from %s (%d), got %zd\\n\", (unsigned long long) st.st_size, fname, errno, n);\n\n\t\t\tfree(data);\n\t\t\tclose(fd);\n\t\t}\n\t\tclosedir(dirp);\n\t}\n}",
      "lines": 39,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": [
      {
        "start_point": [
          81,
          0
        ],
        "end_point": [
          109,
          1
        ],
        "content": "int main(int argc, char **argv)\n{\n\t/* if VALGRIND testing is enabled, we have to call ourselves with valgrind checking */\n\tif (argc == 1) {\n\t\tconst char *valgrind = getenv(\"TESTS_VALGRIND\");\n\n\t\tif (valgrind && *valgrind) {\n\t\t\tsize_t cmdsize = strlen(valgrind) + strlen(argv[0]) + 32;\n\t\t\tchar *cmd = alloca(cmdsize);\n\n\t\t\tsnprintf(cmd, cmdsize, \"TESTS_VALGRIND=\"\" %s %s\", valgrind, argv[0]);\n\t\t\treturn system(cmd) != 0;\n\t\t}\n\t}\n\n\tconst char *target = strrchr(argv[0], '/');\n\ttarget = target ? target + 1 : argv[0];\n\n\tchar corporadir[sizeof(SRCDIR) + 1 + strlen(target) + 8];\n\tsnprintf(corporadir, sizeof(corporadir), SRCDIR \"/%s.in\", target);\n\n\ttest_all_from(corporadir);\n\n\tsnprintf(corporadir, sizeof(corporadir), SRCDIR \"/%s.repro\", target);\n\n\ttest_all_from(corporadir);\n\n\treturn 0;\n}",
        "lines": 29,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          127,
          0
        ],
        "end_point": [
          141,
          1
        ],
        "content": "int main(int argc, char **argv)\n{\n\tint ret;\n\tunsigned char buf[64 * 1024];\n\n\twhile (__AFL_LOOP(10000)) { // only works with afl-clang-fast\n\t\tret = fread(buf, 1, sizeof(buf), stdin);\n\t\tif (ret < 0)\n\t\t\treturn 0;\n\n\t\tLLVMFuzzerTestOneInput(buf, ret);\n\t}\n\n\treturn 0;\n}",
        "lines": 15,
        "depth": 11,
        "decorators": [
          "int"
        ]
      }
    ],
    "__AFL_LOOP": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "static int __AFL_LOOP(int n)\n{\n\tstatic int first = 1;\n\n\tif (first) {\n\t\tfirst = 0;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/gl/arg-nonnull.h": {},
  "libidn/libidn2-2.0.5/gl/basename-lgpl.c": {
    "last_component": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "char *\nlast_component (char const *name)\n{\n  char const *base = name + FILE_SYSTEM_PREFIX_LEN (name);\n  char const *p;\n  bool saw_slash = false;\n\n  while (ISSLASH (*base))\n    base++;\n\n  for (p = base; *p; p++)\n    {\n      if (ISSLASH (*p))\n        saw_slash = true;\n      else if (saw_slash)\n        {\n          base = p;\n          saw_slash = false;\n        }\n    }\n\n  return (char *) base;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "char",
        "*\nlast_component (char const *name)",
        "*"
      ]
    },
    "base_len": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "size_t\nbase_len (char const *name)\n{\n  size_t len;\n  size_t prefix_len = FILE_SYSTEM_PREFIX_LEN (name);\n\n  for (len = strlen (name);  1 < len && ISSLASH (name[len - 1]);  len--)\n    continue;\n\n  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && len == 1\n      && ISSLASH (name[0]) && ISSLASH (name[1]) && ! name[2])\n    return 2;\n\n  if (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE && prefix_len\n      && len == prefix_len && ISSLASH (name[prefix_len]))\n    return prefix_len + 1;\n\n  return len;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    }
  },
  "libidn/libidn2-2.0.5/gl/c++defs.h": {},
  "libidn/libidn2-2.0.5/gl/dirname-lgpl.c": {
    "dir_len": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "size_t\ndir_len (char const *file)\n{\n  size_t prefix_length = FILE_SYSTEM_PREFIX_LEN (file);\n  size_t length;\n\n  /* Advance prefix_length beyond important leading slashes.  */\n  prefix_length += (prefix_length != 0\n                    ? (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                       && ISSLASH (file[prefix_length]))\n                    : (ISSLASH (file[0])\n                       ? ((DOUBLE_SLASH_IS_DISTINCT_ROOT\n                           && ISSLASH (file[1]) && ! ISSLASH (file[2])\n                           ? 2 : 1))\n                       : 0));\n\n  /* Strip the basename and any redundant slashes before it.  */\n  for (length = last_component (file) - file;\n       prefix_length < length; length--)\n    if (! ISSLASH (file[length - 1]))\n      break;\n  return length;\n}",
      "lines": 23,
      "depth": 17,
      "decorators": [
        "size_t"
      ]
    },
    "mdir_name": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "char *\nmdir_name (char const *file)\n{\n  size_t length = dir_len (file);\n  bool append_dot = (length == 0\n                     || (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                         && length == FILE_SYSTEM_PREFIX_LEN (file)\n                         && file[2] != '\\0' && ! ISSLASH (file[2])));\n  char *dir = malloc (length + append_dot + 1);\n  if (!dir)\n    return NULL;\n  memcpy (dir, file, length);\n  if (append_dot)\n    dir[length++] = '.';\n  dir[length] = '\\0';\n  return dir;\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "char",
        "*\nmdir_name (char const *file)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/gl/dirname.h": {},
  "libidn/libidn2-2.0.5/gl/dosname.h": {},
  "libidn/libidn2-2.0.5/gl/errno.in.h": {},
  "libidn/libidn2-2.0.5/gl/error.c": {
    "is_open": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "static int\nis_open (int fd)\n{\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows: The initial state of unassigned standard file\n     descriptors is that they are open but point to an INVALID_HANDLE_VALUE.\n     There is no fcntl, and the gnulib replacement fcntl does not support\n     F_GETFL.  */\n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n# else\n#  ifndef F_GETFL\n#   error Please port fcntl to your platform\n#  endif\n  return 0 <= fcntl (fd, F_GETFL);\n# endif\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "flush_stdout": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "static void\nflush_stdout (void)\n{\n#if !_LIBC\n  int stdout_fd;\n\n# if GNULIB_FREOPEN_SAFER\n  /* Use of gnulib's freopen-safer module normally ensures that\n       fileno (stdout) == 1\n     whenever stdout is open.  */\n  stdout_fd = STDOUT_FILENO;\n# else\n  /* POSIX states that fileno (stdout) after fclose is unspecified.  But in\n     practice it is not a problem, because stdout is statically allocated and\n     the fd of a FILE stream is stored as a field in its allocated memory.  */\n  stdout_fd = fileno (stdout);\n# endif\n  /* POSIX states that fflush (stdout) after fclose is unspecified; it\n     is safe in glibc, but not on all other platforms.  fflush (NULL)\n     is always defined, but too draconian.  */\n  if (0 <= stdout_fd && is_open (stdout_fd))\n#endif\n    fflush (stdout);\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_errno_message": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        202,
        1
      ],
      "content": "static void\nprint_errno_message (int errnum)\n{\n  char const *s;\n\n#if _LIBC || GNULIB_STRERROR_R_POSIX || defined HAVE_STRERROR_R\n  char errbuf[1024];\n# if _LIBC || (!GNULIB_STRERROR_R_POSIX && STRERROR_R_CHAR_P)\n  s = __strerror_r (errnum, errbuf, sizeof errbuf);\n# else\n  if (__strerror_r (errnum, errbuf, sizeof errbuf) == 0)\n    s = errbuf;\n  else\n    s = 0;\n# endif\n#else\n  s = strerror (errnum);\n#endif\n\n#if !_LIBC\n  if (! s)\n    s = _(\"Unknown system error\");\n#endif\n\n#if _LIBC\n  __fxprintf (NULL, \": %s\", s);\n#else\n  fprintf (stderr, \": %s\", s);\n#endif\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "error_tail": {
      "start_point": [
        205,
        42
      ],
      "end_point": [
        286,
        1
      ],
      "content": "char *message, va_list args)\n{\n#if _LIBC\n  if (_IO_fwide (stderr, 0) > 0)\n    {\n      size_t len = strlen (message) + 1;\n      wchar_t *wmessage = NULL;\n      mbstate_t st;\n      size_t res;\n      const char *tmp;\n      bool use_malloc = false;\n\n      while (1)\n        {\n          if (__libc_use_alloca (len * sizeof (wchar_t)))\n            wmessage = (wchar_t *) alloca (len * sizeof (wchar_t));\n          else\n            {\n              if (!use_malloc)\n                wmessage = NULL;\n\n              wchar_t *p = (wchar_t *) realloc (wmessage,\n                                                len * sizeof (wchar_t));\n              if (p == NULL)\n                {\n                  free (wmessage);\n                  fputws_unlocked (L\"out of memory\\n\", stderr);\n                  return;\n                }\n              wmessage = p;\n              use_malloc = true;\n            }\n\n          memset (&st, '\\0', sizeof (st));\n          tmp = message;\n\n          res = mbsrtowcs (wmessage, &tmp, len, &st);\n          if (res != len)\n            break;\n\n          if (__builtin_expect (len >= SIZE_MAX / sizeof (wchar_t) / 2, 0))\n            {\n              /* This really should not happen if everything is fine.  */\n              res = (size_t) -1;\n              break;\n            }\n\n          len *= 2;\n        }\n\n      if (res == (size_t) -1)\n        {\n          /* The string cannot be converted.  */\n          if (use_malloc)\n            {\n              free (wmessage);\n              use_malloc = false;\n            }\n          wmessage = (wchar_t *) L\"???\";\n        }\n\n      __vfwprintf (stderr, wmessage, args);\n\n      if (use_malloc)\n        free (wmessage);\n    }\n  else\n#endif\n    vfprintf (stderr, message, args);\n\n  ++error_message_count;\n  if (errnum)\n    print_errno_message (errnum);\n#if _LIBC\n  __fxprintf (NULL, \"\\n\");\n#else\n  putc ('\\n', stderr);\n#endif\n  fflush (stderr);\n  if (status)\n    exit (status);\n}",
      "lines": 82,
      "depth": 18,
      "decorators": null
    },
    "error": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        331,
        1
      ],
      "content": "void\nerror (int status, int errnum, const char *message, ...)\n{\n  va_list args;\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s: \", program_name);\n#else\n      fprintf (stderr, \"%s: \", program_name);\n#endif\n    }\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n  va_end (args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "error_at_line": {
      "start_point": [
        337,
        0
      ],
      "end_point": [
        402,
        1
      ],
      "content": "void\nerror_at_line (int status, int errnum, const char *file_name,\n               unsigned int line_number, const char *message, ...)\n{\n  va_list args;\n\n  if (error_one_per_line)\n    {\n      static const char *old_file_name;\n      static unsigned int old_line_number;\n\n      if (old_line_number == line_number\n          && (file_name == old_file_name\n              || (old_file_name != NULL\n                  && file_name != NULL\n                  && strcmp (old_file_name, file_name) == 0)))\n\n        /* Simply return and print nothing.  */\n        return;\n\n      old_file_name = file_name;\n      old_line_number = line_number;\n    }\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s:\", program_name);\n#else\n      fprintf (stderr, \"%s:\", program_name);\n#endif\n    }\n\n#if _LIBC\n  __fxprintf (NULL, file_name != NULL ? \"%s:%u: \" : \" \",\n              file_name, line_number);\n#else\n  fprintf (stderr, file_name != NULL ? \"%s:%u: \" : \" \",\n           file_name, line_number);\n#endif\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n  va_end (args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 66,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "libidn/libidn2-2.0.5/gl/error.h": {},
  "libidn/libidn2-2.0.5/gl/getdelim.c": {
    "alloc_failed": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static void\nalloc_failed (void)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* Avoid errno problem without using the realloc module; see:\n     http://lists.gnu.org/archive/html/bug-gnulib/2016-08/msg00025.html  */\n  errno = ENOMEM;\n#endif\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "getdelim": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "ssize_t\ngetdelim (char **lineptr, size_t *n, int delimiter, FILE *fp)\n{\n  ssize_t result;\n  size_t cur_len = 0;\n\n  if (lineptr == NULL || n == NULL || fp == NULL)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  flockfile (fp);\n\n  if (*lineptr == NULL || *n == 0)\n    {\n      char *new_lineptr;\n      *n = 120;\n      new_lineptr = (char *) realloc (*lineptr, *n);\n      if (new_lineptr == NULL)\n        {\n          alloc_failed ();\n          result = -1;\n          goto unlock_return;\n        }\n      *lineptr = new_lineptr;\n    }\n\n  for (;;)\n    {\n      int i;\n\n      i = getc_maybe_unlocked (fp);\n      if (i == EOF)\n        {\n          result = -1;\n          break;\n        }\n\n      /* Make enough space for len+1 (for final NUL) bytes.  */\n      if (cur_len + 1 >= *n)\n        {\n          size_t needed_max =\n            SSIZE_MAX < SIZE_MAX ? (size_t) SSIZE_MAX + 1 : SIZE_MAX;\n          size_t needed = 2 * *n + 1;   /* Be generous. */\n          char *new_lineptr;\n\n          if (needed_max < needed)\n            needed = needed_max;\n          if (cur_len + 1 >= needed)\n            {\n              result = -1;\n              errno = EOVERFLOW;\n              goto unlock_return;\n            }\n\n          new_lineptr = (char *) realloc (*lineptr, needed);\n          if (new_lineptr == NULL)\n            {\n              alloc_failed ();\n              result = -1;\n              goto unlock_return;\n            }\n\n          *lineptr = new_lineptr;\n          *n = needed;\n        }\n\n      (*lineptr)[cur_len] = i;\n      cur_len++;\n\n      if (i == delimiter)\n        break;\n    }\n  (*lineptr)[cur_len] = '\\0';\n  result = cur_len ? cur_len : result;\n\n unlock_return:\n  funlockfile (fp); /* doesn't set errno */\n\n  return result;\n}",
      "lines": 82,
      "depth": 13,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "libidn/libidn2-2.0.5/gl/getline.c": {
    "getline": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "ssize_t\ngetline (char **lineptr, size_t *n, FILE *stream)\n{\n  return getdelim (lineptr, n, '\\n', stream);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "libidn/libidn2-2.0.5/gl/getopt-cdefs.in.h": {},
  "libidn/libidn2-2.0.5/gl/getopt-core.h": {},
  "libidn/libidn2-2.0.5/gl/getopt-ext.h": {
    "struct": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "__BEGIN_DECLS\n\n/* Describe the long-named options requested by the application.\n   The LONG_OPTIONS argument to getopt_long or getopt_long_only is a vector\n   of 'struct option' terminated by an element containing a name which is\n   zero.\n\n   The field 'has_arg' is:\n   no_argument\t\t(or 0) if the option does not take an argument,\n   required_argument\t(or 1) if the option requires an argument,\n   optional_argument \t(or 2) if the option takes an optional argument.\n\n   If the field 'flag' is not NULL, it points to a variable that is set\n   to the value given in the field 'val' when the option is found, but\n   left unchanged if the option is not found.\n\n   To have a long-named option do something other than set an 'int' to\n   a compiled-in constant, such as set a value from 'optarg', set the\n   option's 'flag' field to zero and its 'val' field to a nonzero\n   value (the equivalent single-letter option character, if there is\n   one).  For long options that have a zero 'flag' field, 'getopt'\n   returns the contents of the 'val' field.  */\n\nstruct option\n{\n  const char *name;\n  /* has_arg can't be an enum because some compilers complain about\n     type mismatches in all the code that assumes it is an int.  */\n  int has_arg;\n  int *flag;\n  int val;\n}",
      "lines": 32,
      "depth": 5,
      "decorators": null
    }
  },
  "libidn/libidn2-2.0.5/gl/getopt-pfx-core.h": {},
  "libidn/libidn2-2.0.5/gl/getopt-pfx-ext.h": {},
  "libidn/libidn2-2.0.5/gl/getopt.c": {
    "exchange": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "static void\nexchange (char **argv, struct _getopt_data *d)\n{\n  int bottom = d->__first_nonopt;\n  int middle = d->__last_nonopt;\n  int top = d->optind;\n  char *tem;\n\n  /* Exchange the shorter segment with the far end of the longer segment.\n     That puts the shorter segment into the right place.\n     It leaves the longer segment in the right place overall,\n     but it consists of two parts that need to be swapped next.  */\n\n  while (top > middle && middle > bottom)\n    {\n      if (top - middle > middle - bottom)\n\t{\n\t  /* Bottom segment is the short one.  */\n\t  int len = middle - bottom;\n\t  int i;\n\n\t  /* Swap it with the top part of the top segment.  */\n\t  for (i = 0; i < len; i++)\n\t    {\n\t      tem = argv[bottom + i];\n\t      argv[bottom + i] = argv[top - (middle - bottom) + i];\n\t      argv[top - (middle - bottom) + i] = tem;\n\t    }\n\t  /* Exclude the moved bottom segment from further swapping.  */\n\t  top -= len;\n\t}\n      else\n\t{\n\t  /* Top segment is the short one.  */\n\t  int len = top - middle;\n\t  int i;\n\n\t  /* Swap it with the bottom part of the bottom segment.  */\n\t  for (i = 0; i < len; i++)\n\t    {\n\t      tem = argv[bottom + i];\n\t      argv[bottom + i] = argv[middle + i];\n\t      argv[middle + i] = tem;\n\t    }\n\t  /* Exclude the moved top segment from further swapping.  */\n\t  bottom += len;\n\t}\n    }\n\n  /* Update records for the slots the non-options now occupy.  */\n\n  d->__first_nonopt += (d->optind - d->__last_nonopt);\n  d->__last_nonopt = d->optind;\n}",
      "lines": 54,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "process_long_option": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        375,
        1
      ],
      "content": "static int\nprocess_long_option (int argc, char **argv, const char *optstring,\n\t\t     const struct option *longopts, int *longind,\n\t\t     int long_only, struct _getopt_data *d,\n\t\t     int print_errors, const char *prefix)\n{\n  char *nameend;\n  size_t namelen;\n  const struct option *p;\n  const struct option *pfound = NULL;\n  int n_options;\n  int option_index;\n\n  for (nameend = d->__nextchar; *nameend && *nameend != '='; nameend++)\n    /* Do nothing.  */ ;\n  namelen = nameend - d->__nextchar;\n\n  /* First look for an exact match, counting the options as a side\n     effect.  */\n  for (p = longopts, n_options = 0; p->name; p++, n_options++)\n    if (!strncmp (p->name, d->__nextchar, namelen)\n\t&& namelen == strlen (p->name))\n      {\n\t/* Exact match found.  */\n\tpfound = p;\n\toption_index = n_options;\n\tbreak;\n      }\n\n  if (pfound == NULL)\n    {\n      /* Didn't find an exact match, so look for abbreviations.  */\n      unsigned char *ambig_set = NULL;\n      int ambig_malloced = 0;\n      int ambig_fallback = 0;\n      int indfound = -1;\n\n      for (p = longopts, option_index = 0; p->name; p++, option_index++)\n\tif (!strncmp (p->name, d->__nextchar, namelen))\n\t  {\n\t    if (pfound == NULL)\n\t      {\n\t\t/* First nonexact match found.  */\n\t\tpfound = p;\n\t\tindfound = option_index;\n\t      }\n\t    else if (long_only\n\t\t     || pfound->has_arg != p->has_arg\n\t\t     || pfound->flag != p->flag\n\t\t     || pfound->val != p->val)\n\t      {\n\t\t/* Second or later nonexact match found.  */\n\t\tif (!ambig_fallback)\n\t\t  {\n\t\t    if (!print_errors)\n\t\t      /* Don't waste effort tracking the ambig set if\n\t\t\t we're not going to print it anyway.  */\n\t\t      ambig_fallback = 1;\n\t\t    else if (!ambig_set)\n\t\t      {\n\t\t\tif (__libc_use_alloca (n_options))\n\t\t\t  ambig_set = alloca (n_options);\n\t\t\telse if ((ambig_set = malloc (n_options)) == NULL)\n\t\t\t  /* Fall back to simpler error message.  */\n\t\t\t  ambig_fallback = 1;\n\t\t\telse\n\t\t\t  ambig_malloced = 1;\n\n\t\t\tif (ambig_set)\n\t\t\t  {\n\t\t\t    memset (ambig_set, 0, n_options);\n\t\t\t    ambig_set[indfound] = 1;\n\t\t\t  }\n\t\t      }\n\t\t    if (ambig_set)\n\t\t      ambig_set[option_index] = 1;\n\t\t  }\n\t      }\n\t  }\n\n      if (ambig_set || ambig_fallback)\n\t{\n\t  if (print_errors)\n\t    {\n\t      if (ambig_fallback)\n\t\tfprintf (stderr, _(\"%s: option '%s%s' is ambiguous\\n\"),\n\t\t\t argv[0], prefix, d->__nextchar);\n\t      else\n\t\t{\n\t\t  flockfile (stderr);\n\t\t  fprintf (stderr,\n\t\t\t   _(\"%s: option '%s%s' is ambiguous; possibilities:\"),\n\t\t\t   argv[0], prefix, d->__nextchar);\n\n\t\t  for (option_index = 0; option_index < n_options; option_index++)\n\t\t    if (ambig_set[option_index])\n\t\t      fprintf (stderr, \" '%s%s'\",\n\t\t\t       prefix, longopts[option_index].name);\n\n\t\t  /* This must use 'fprintf' even though it's only\n\t\t     printing a single character, so that it goes through\n\t\t     __fxprintf_nocancel when compiled as part of glibc.  */\n\t\t  fprintf (stderr, \"\\n\");\n\t\t  funlockfile (stderr);\n\t\t}\n\t    }\n\t  if (ambig_malloced)\n\t    free (ambig_set);\n\t  d->__nextchar += strlen (d->__nextchar);\n\t  d->optind++;\n\t  d->optopt = 0;\n\t  return '?';\n\t}\n\n      option_index = indfound;\n    }\n\n  if (pfound == NULL)\n    {\n      /* Can't find it as a long option.  If this is not getopt_long_only,\n\t or the option starts with '--' or is not a valid short option,\n\t then it's an error.  */\n      if (!long_only || argv[d->optind][1] == '-'\n\t  || strchr (optstring, *d->__nextchar) == NULL)\n\t{\n\t  if (print_errors)\n\t    fprintf (stderr, _(\"%s: unrecognized option '%s%s'\\n\"),\n\t\t     argv[0], prefix, d->__nextchar);\n\n\t  d->__nextchar = NULL;\n\t  d->optind++;\n\t  d->optopt = 0;\n\t  return '?';\n\t}\n\n      /* Otherwise interpret it as a short option.  */\n      return -1;\n    }\n\n  /* We have found a matching long option.  Consume it.  */\n  d->optind++;\n  d->__nextchar = NULL;\n  if (*nameend)\n    {\n      /* Don't test has_arg with >, because some C compilers don't\n\t allow it to be used on enums.  */\n      if (pfound->has_arg)\n\td->optarg = nameend + 1;\n      else\n\t{\n\t  if (print_errors)\n\t    fprintf (stderr,\n\t\t     _(\"%s: option '%s%s' doesn't allow an argument\\n\"),\n\t\t     argv[0], prefix, pfound->name);\n\n\t  d->optopt = pfound->val;\n\t  return '?';\n\t}\n    }\n  else if (pfound->has_arg == 1)\n    {\n      if (d->optind < argc)\n\td->optarg = argv[d->optind++];\n      else\n\t{\n\t  if (print_errors)\n\t    fprintf (stderr,\n\t\t     _(\"%s: option '%s%s' requires an argument\\n\"),\n\t\t     argv[0], prefix, pfound->name);\n\n\t  d->optopt = pfound->val;\n\t  return optstring[0] == ':' ? ':' : '?';\n\t}\n    }\n\n  if (longind != NULL)\n    *longind = option_index;\n  if (pfound->flag)\n    {\n      *(pfound->flag) = pfound->val;\n      return 0;\n    }\n  return pfound->val;\n}",
      "lines": 184,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_getopt_initialize": {
      "start_point": [
        379,
        0
      ],
      "end_point": [
        411,
        1
      ],
      "content": "static const char *\n_getopt_initialize (int argc _GL_UNUSED,\n\t\t    char **argv _GL_UNUSED, const char *optstring,\n\t\t    struct _getopt_data *d, int posixly_correct)\n{\n  /* Start processing options with ARGV-element 1 (since ARGV-element 0\n     is the program name); the sequence of previously skipped\n     non-option ARGV-elements is empty.  */\n  if (d->optind == 0)\n    d->optind = 1;\n\n  d->__first_nonopt = d->__last_nonopt = d->optind;\n  d->__nextchar = NULL;\n\n  /* Determine how to handle the ordering of options and nonoptions.  */\n  if (optstring[0] == '-')\n    {\n      d->__ordering = RETURN_IN_ORDER;\n      ++optstring;\n    }\n  else if (optstring[0] == '+')\n    {\n      d->__ordering = REQUIRE_ORDER;\n      ++optstring;\n    }\n  else if (posixly_correct || !!getenv (\"POSIXLY_CORRECT\"))\n    d->__ordering = REQUIRE_ORDER;\n  else\n    d->__ordering = PERMUTE;\n\n  d->__initialized = 1;\n  return optstring;\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\n_getopt_initialize (int argc _GL_UNUSED,\n\t\t    char **argv _GL_UNUSED, const char *optstring,\n\t\t    struct _getopt_data *d, int posixly_correct)",
        "*"
      ]
    },
    "_getopt_internal_r": {
      "start_point": [
        469,
        0
      ],
      "end_point": [
        699,
        1
      ],
      "content": "int\n_getopt_internal_r (int argc, char **argv, const char *optstring,\n\t\t    const struct option *longopts, int *longind,\n\t\t    int long_only, struct _getopt_data *d, int posixly_correct)\n{\n  int print_errors = d->opterr;\n\n  if (argc < 1)\n    return -1;\n\n  d->optarg = NULL;\n\n  if (d->optind == 0 || !d->__initialized)\n    optstring = _getopt_initialize (argc, argv, optstring, d, posixly_correct);\n  else if (optstring[0] == '-' || optstring[0] == '+')\n    optstring++;\n\n  if (optstring[0] == ':')\n    print_errors = 0;\n\n  /* Test whether ARGV[optind] points to a non-option argument.  */\n#define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0')\n\n  if (d->__nextchar == NULL || *d->__nextchar == '\\0')\n    {\n      /* Advance to the next ARGV-element.  */\n\n      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been\n\t moved back by the user (who may also have changed the arguments).  */\n      if (d->__last_nonopt > d->optind)\n\td->__last_nonopt = d->optind;\n      if (d->__first_nonopt > d->optind)\n\td->__first_nonopt = d->optind;\n\n      if (d->__ordering == PERMUTE)\n\t{\n\t  /* If we have just processed some options following some non-options,\n\t     exchange them so that the options come first.  */\n\n\t  if (d->__first_nonopt != d->__last_nonopt\n\t      && d->__last_nonopt != d->optind)\n\t    exchange (argv, d);\n\t  else if (d->__last_nonopt != d->optind)\n\t    d->__first_nonopt = d->optind;\n\n\t  /* Skip any additional non-options\n\t     and extend the range of non-options previously skipped.  */\n\n\t  while (d->optind < argc && NONOPTION_P)\n\t    d->optind++;\n\t  d->__last_nonopt = d->optind;\n\t}\n\n      /* The special ARGV-element '--' means premature end of options.\n\t Skip it like a null option,\n\t then exchange with previous non-options as if it were an option,\n\t then skip everything else like a non-option.  */\n\n      if (d->optind != argc && !strcmp (argv[d->optind], \"--\"))\n\t{\n\t  d->optind++;\n\n\t  if (d->__first_nonopt != d->__last_nonopt\n\t      && d->__last_nonopt != d->optind)\n\t    exchange (argv, d);\n\t  else if (d->__first_nonopt == d->__last_nonopt)\n\t    d->__first_nonopt = d->optind;\n\t  d->__last_nonopt = argc;\n\n\t  d->optind = argc;\n\t}\n\n      /* If we have done all the ARGV-elements, stop the scan\n\t and back over any non-options that we skipped and permuted.  */\n\n      if (d->optind == argc)\n\t{\n\t  /* Set the next-arg-index to point at the non-options\n\t     that we previously skipped, so the caller will digest them.  */\n\t  if (d->__first_nonopt != d->__last_nonopt)\n\t    d->optind = d->__first_nonopt;\n\t  return -1;\n\t}\n\n      /* If we have come to a non-option and did not permute it,\n\t either stop the scan or describe it to the caller and pass it by.  */\n\n      if (NONOPTION_P)\n\t{\n\t  if (d->__ordering == REQUIRE_ORDER)\n\t    return -1;\n\t  d->optarg = argv[d->optind++];\n\t  return 1;\n\t}\n\n      /* We have found another option-ARGV-element.\n\t Check whether it might be a long option.  */\n      if (longopts)\n\t{\n\t  if (argv[d->optind][1] == '-')\n\t    {\n\t      /* \"--foo\" is always a long option.  The special option\n\t\t \"--\" was handled above.  */\n\t      d->__nextchar = argv[d->optind] + 2;\n\t      return process_long_option (argc, argv, optstring, longopts,\n\t\t\t\t\t  longind, long_only, d,\n\t\t\t\t\t  print_errors, \"--\");\n\t    }\n\n\t  /* If long_only and the ARGV-element has the form \"-f\",\n\t     where f is a valid short option, don't consider it an\n\t     abbreviated form of a long option that starts with f.\n\t     Otherwise there would be no way to give the -f short\n\t     option.\n\n\t     On the other hand, if there's a long option \"fubar\" and\n\t     the ARGV-element is \"-fu\", do consider that an\n\t     abbreviation of the long option, just like \"--fu\", and\n\t     not \"-f\" with arg \"u\".\n\n\t     This distinction seems to be the most useful approach.  */\n\t  if (long_only && (argv[d->optind][2]\n\t\t\t    || !strchr (optstring, argv[d->optind][1])))\n\t    {\n\t      int code;\n\t      d->__nextchar = argv[d->optind] + 1;\n\t      code = process_long_option (argc, argv, optstring, longopts,\n\t\t\t\t\t  longind, long_only, d,\n\t\t\t\t\t  print_errors, \"-\");\n\t      if (code != -1)\n\t\treturn code;\n\t    }\n\t}\n\n      /* It is not a long option.  Skip the initial punctuation.  */\n      d->__nextchar = argv[d->optind] + 1;\n    }\n\n  /* Look at and handle the next short option-character.  */\n\n  {\n    char c = *d->__nextchar++;\n    const char *temp = strchr (optstring, c);\n\n    /* Increment 'optind' when we start to process its last character.  */\n    if (*d->__nextchar == '\\0')\n      ++d->optind;\n\n    if (temp == NULL || c == ':' || c == ';')\n      {\n\tif (print_errors)\n\t  fprintf (stderr, _(\"%s: invalid option -- '%c'\\n\"), argv[0], c);\n\td->optopt = c;\n\treturn '?';\n      }\n\n    /* Convenience. Treat POSIX -W foo same as long option --foo */\n    if (temp[0] == 'W' && temp[1] == ';' && longopts != NULL)\n      {\n\t/* This is an option that requires an argument.  */\n\tif (*d->__nextchar != '\\0')\n\t  d->optarg = d->__nextchar;\n\telse if (d->optind == argc)\n\t  {\n\t    if (print_errors)\n\t      fprintf (stderr,\n\t\t       _(\"%s: option requires an argument -- '%c'\\n\"),\n\t\t       argv[0], c);\n\n\t    d->optopt = c;\n\t    if (optstring[0] == ':')\n\t      c = ':';\n\t    else\n\t      c = '?';\n\t    return c;\n\t  }\n\telse\n\t  d->optarg = argv[d->optind];\n\n\td->__nextchar = d->optarg;\n\td->optarg = NULL;\n\treturn process_long_option (argc, argv, optstring, longopts, longind,\n\t\t\t\t    0 /* long_only */, d, print_errors, \"-W \");\n      }\n    if (temp[1] == ':')\n      {\n\tif (temp[2] == ':')\n\t  {\n\t    /* This is an option that accepts an argument optionally.  */\n\t    if (*d->__nextchar != '\\0')\n\t      {\n\t\td->optarg = d->__nextchar;\n\t\td->optind++;\n\t      }\n\t    else\n\t      d->optarg = NULL;\n\t    d->__nextchar = NULL;\n\t  }\n\telse\n\t  {\n\t    /* This is an option that requires an argument.  */\n\t    if (*d->__nextchar != '\\0')\n\t      {\n\t\td->optarg = d->__nextchar;\n\t\t/* If we end this ARGV-element by taking the rest as an arg,\n\t\t   we must advance to the next element now.  */\n\t\td->optind++;\n\t      }\n\t    else if (d->optind == argc)\n\t      {\n\t\tif (print_errors)\n\t\t  fprintf (stderr,\n\t\t\t   _(\"%s: option requires an argument -- '%c'\\n\"),\n\t\t\t   argv[0], c);\n\n\t\td->optopt = c;\n\t\tif (optstring[0] == ':')\n\t\t  c = ':';\n\t\telse\n\t\t  c = '?';\n\t      }\n\t    else\n\t      /* We already incremented 'optind' once;\n\t\t increment it again when taking next ARGV-elt as argument.  */\n\t      d->optarg = argv[d->optind++];\n\t    d->__nextchar = NULL;\n\t  }\n      }\n    return c;\n  }\n}",
      "lines": 231,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "_getopt_internal": {
      "start_point": [
        701,
        0
      ],
      "end_point": [
        720,
        1
      ],
      "content": "int\n_getopt_internal (int argc, char **argv, const char *optstring,\n\t\t  const struct option *longopts, int *longind, int long_only,\n\t\t  int posixly_correct)\n{\n  int result;\n\n  getopt_data.optind = optind;\n  getopt_data.opterr = opterr;\n\n  result = _getopt_internal_r (argc, argv, optstring, longopts,\n\t\t\t       longind, long_only, &getopt_data,\n\t\t\t       posixly_correct);\n\n  optind = getopt_data.optind;\n  optarg = getopt_data.optarg;\n  optopt = getopt_data.optopt;\n\n  return result;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        747,
        0
      ],
      "end_point": [
        808,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n\n      c = getopt (argc, argv, \"abc:d:0123456789\");\n      if (c == -1)\n\tbreak;\n\n      switch (c)\n\t{\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9':\n\t  if (digit_optind != 0 && digit_optind != this_option_optind)\n\t    printf (\"digits occur in two different argv-elements.\\n\");\n\t  digit_optind = this_option_optind;\n\t  printf (\"option %c\\n\", c);\n\t  break;\n\n\tcase 'a':\n\t  printf (\"option a\\n\");\n\t  break;\n\n\tcase 'b':\n\t  printf (\"option b\\n\");\n\t  break;\n\n\tcase 'c':\n\t  printf (\"option c with value '%s'\\n\", optarg);\n\t  break;\n\n\tcase '?':\n\t  break;\n\n\tdefault:\n\t  printf (\"?? getopt returned character code 0%o ??\\n\", c);\n\t}\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n\tprintf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/gl/getopt.in.h": {},
  "libidn/libidn2-2.0.5/gl/getopt1.c": {
    "getopt_long": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\ngetopt_long (int argc, char *__getopt_argv_const *argv, const char *options,\n\t     const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n\t\t\t   opt_index, 0, 0);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_r": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "int\n_getopt_long_r (int argc, char **argv, const char *options,\n\t\tconst struct option *long_options, int *opt_index,\n\t\tstruct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n\t\t\t     0, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "getopt_long_only": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\ngetopt_long_only (int argc, char *__getopt_argv_const *argv,\n\t\t  const char *options,\n\t\t  const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n\t\t\t   opt_index, 1, 0);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_only_r": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\n_getopt_long_only_r (int argc, char **argv, const char *options,\n\t\t     const struct option *long_options, int *opt_index,\n\t\t     struct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n\t\t\t     1, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n      int option_index = 0;\n      static const struct option long_options[] =\n      {\n\t{\"add\", 1, 0, 0},\n\t{\"append\", 0, 0, 0},\n\t{\"delete\", 1, 0, 0},\n\t{\"verbose\", 0, 0, 0},\n\t{\"create\", 0, 0, 0},\n\t{\"file\", 1, 0, 0},\n\t{0, 0, 0, 0}\n      };\n\n      c = getopt_long (argc, argv, \"abc:d:0123456789\",\n\t\t       long_options, &option_index);\n      if (c == -1)\n\tbreak;\n\n      switch (c)\n\t{\n\tcase 0:\n\t  printf (\"option %s\", long_options[option_index].name);\n\t  if (optarg)\n\t    printf (\" with arg %s\", optarg);\n\t  printf (\"\\n\");\n\t  break;\n\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9':\n\t  if (digit_optind != 0 && digit_optind != this_option_optind)\n\t    printf (\"digits occur in two different argv-elements.\\n\");\n\t  digit_optind = this_option_optind;\n\t  printf (\"option %c\\n\", c);\n\t  break;\n\n\tcase 'a':\n\t  printf (\"option a\\n\");\n\t  break;\n\n\tcase 'b':\n\t  printf (\"option b\\n\");\n\t  break;\n\n\tcase 'c':\n\t  printf (\"option c with value '%s'\\n\", optarg);\n\t  break;\n\n\tcase 'd':\n\t  printf (\"option d with value '%s'\\n\", optarg);\n\t  break;\n\n\tcase '?':\n\t  break;\n\n\tdefault:\n\t  printf (\"?? getopt returned character code 0%o ??\\n\", c);\n\t}\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n\tprintf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 85,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/gl/getopt_int.h": {},
  "libidn/libidn2-2.0.5/gl/getprogname.c": {
    "getprogname": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "char const *\ngetprogname (void)\n{\n# if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME                /* glibc, BeOS */\n  /* https://www.gnu.org/software/libc/manual/html_node/Error-Messages.html */\n  return program_invocation_short_name;\n# elif HAVE_DECL_PROGRAM_INVOCATION_NAME                    /* glibc, BeOS */\n  /* https://www.gnu.org/software/libc/manual/html_node/Error-Messages.html */\n  return last_component (program_invocation_name);\n# elif HAVE_GETEXECNAME                                     /* Solaris */\n  /* http://docs.oracle.com/cd/E19253-01/816-5168/6mbb3hrb1/index.html */\n  const char *p = getexecname ();\n  if (!p)\n    p = \"?\";\n  return last_component (p);\n# elif HAVE_DECL___ARGV                                     /* mingw, MSVC */\n  /* https://msdn.microsoft.com/en-us/library/dn727674.aspx */\n  const char *p = __argv && __argv[0] ? __argv[0] : \"?\";\n  return last_component (p);\n# elif HAVE_VAR___PROGNAME                                  /* OpenBSD, QNX */\n  /* http://man.openbsd.org/style.9 */\n  /* http://www.qnx.de/developers/docs/6.5.0/index.jsp?topic=%2Fcom.qnx.doc.neutrino_lib_ref%2Fp%2F__progname.html */\n  /* Be careful to declare this only when we absolutely need it\n     (OpenBSD 5.1), rather than when it's available.  Otherwise,\n     its mere declaration makes program_invocation_short_name\n     malfunction (have zero length) with Fedora 25's glibc.  */\n  extern char *__progname;\n  const char *p = __progname;\n  return p && p[0] ? p : \"?\";\n# elif _AIX                                                 /* AIX */\n  /* Idea by Bastien ROUCARI\u00c3\u0088S,\n     http://lists.gnu.org/archive/html/bug-gnulib/2010-12/msg00095.html\n     Reference: http://\n   ibm.biz/knowctr#ssw_aix_53/com.ibm.aix.basetechref/doc/basetrf1/getprocs.htm\n  */\n  static char *p;\n  static int first = 1;\n  if (first)\n    {\n      first = 0;\n      pid_t pid = getpid ();\n      struct procentry64 procs;\n      p = (0 < getprocs64 (&procs, sizeof procs, NULL, 0, &pid, 1)\n           ? strdup (procs.pi_comm)\n           : NULL);\n      if (!p)\n        p = \"?\";\n    }\n  return p;\n# elif defined __hpux\n  static char *p;\n  static int first = 1;\n  if (first)\n    {\n      first = 0;\n      pid_t pid = getpid ();\n      struct pst_status status;\n      p = (0 < pstat_getproc (&status, sizeof status, 0, pid)\n           ? strdup (status.pst_ucomm)\n           : NULL);\n      if (!p)\n        p = \"?\";\n    }\n  return p;\n# elif __MVS__                                              /* z/OS */\n  /* https://www.ibm.com/support/knowledgecenter/SSLTBW_2.1.0/com.ibm.zos.v2r1.bpxbd00/rtwgetp.htm */\n  static char *p = \"?\";\n  static int first = 1;\n  if (first)\n    {\n      pid_t pid = getpid ();\n      int token;\n      W_PSPROC buf;\n      first = 0;\n      memset (&buf, 0, sizeof(buf));\n      buf.ps_cmdptr    = (char *) malloc (buf.ps_cmdlen    = PS_CMDBLEN_LONG);\n      buf.ps_conttyptr = (char *) malloc (buf.ps_conttylen = PS_CONTTYBLEN);\n      buf.ps_pathptr   = (char *) malloc (buf.ps_pathlen   = PS_PATHBLEN);\n      if (buf.ps_cmdptr && buf.ps_conttyptr && buf.ps_pathptr)\n        {\n          for (token = 0; token >= 0;\n               token = w_getpsent (token, &buf, sizeof(buf)))\n            {\n              if (token > 0 && buf.ps_pid == pid)\n                {\n                  char *s = strdup (last_component (buf.ps_pathptr));\n                  if (s)\n                    p = s;\n                  break;\n                }\n            }\n        }\n      free (buf.ps_cmdptr);\n      free (buf.ps_conttyptr);\n      free (buf.ps_pathptr);\n    }\n  return p;\n# elif defined __sgi                                        /* IRIX */\n  char filename[50];\n  int fd;\n\n  sprintf (filename, \"/proc/pinfo/%d\", (int) getpid ());\n  fd = open (filename, O_RDONLY);\n  if (0 <= fd)\n    {\n      prpsinfo_t buf;\n      int ioctl_ok = 0 <= ioctl (fd, PIOCPSINFO, &buf);\n      close (fd);\n      if (ioctl_ok)\n        {\n          char *name = buf.pr_fname;\n          char *namesize = sizeof buf.pr_fname;\n          char *namenul = memchr (name, '\\0', namesize);\n          size_t namelen = namenul ? namenul - name : namesize;\n          char *namecopy = malloc (namelen + 1);\n          if (namecopy)\n            {\n              namecopy[namelen] = 0;\n              return memcpy (namecopy, name, namelen);\n            }\n        }\n    }\n  return NULL;\n# else\n#  error \"getprogname module not ported to this OS\"\n# endif\n}",
      "lines": 127,
      "depth": 26,
      "decorators": [
        "char",
        "const",
        "const",
        "*\ngetprogname (void)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/gl/getprogname.h": {},
  "libidn/libidn2-2.0.5/gl/gettext.h": {
    "pgettext_aux": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "static const char *\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)\n{\n  const char *translation = dcgettext (domain, msg_ctxt_id, category);\n  if (translation == msg_ctxt_id)\n    return msgid;\n  else\n    return translation;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)",
        "*"
      ]
    },
    "npgettext_aux": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "static const char *\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)\n{\n  const char *translation =\n    dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n  if (translation == msg_ctxt_id || translation == msgid_plural)\n    return (n == 1 ? msgid : msgid_plural);\n  else\n    return translation;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)",
        "*"
      ]
    },
    "dcpgettext_expr": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "static const char *\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      int found_translation;\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcgettext (domain, msg_ctxt_id, category);\n      found_translation = (translation != msg_ctxt_id);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (found_translation)\n        return translation;\n    }\n  return msgid;\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)",
        "*"
      ]
    },
    "dcnpgettext_expr": {
      "start_point": [
        257,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "static const char *\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      int found_translation;\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n      found_translation = !(translation == msg_ctxt_id || translation == msgid_plural);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (found_translation)\n        return translation;\n    }\n  return (n == 1 ? msgid : msgid_plural);\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/gl/intprops.h": {},
  "libidn/libidn2-2.0.5/gl/limits.in.h": {},
  "libidn/libidn2-2.0.5/gl/malloc.c": {
    "rpl_malloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void *\nrpl_malloc (size_t n)\n{\n  void *result;\n\n#if NEED_MALLOC_GNU\n  if (n == 0)\n    n = 1;\n#endif\n\n  result = malloc (n);\n\n#if !HAVE_MALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "void",
        "*\nrpl_malloc (size_t n)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/gl/msvc-inval.c": {
    "gl_msvc_invalid_parameter_handler": [
      {
        "start_point": [
          30,
          0
        ],
        "end_point": [
          37,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n}",
        "lines": 8,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          47,
          0
        ],
        "end_point": [
          55,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 9,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          96,
          0
        ],
        "end_point": [
          110,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  struct gl_msvc_inval_per_thread *current = gl_msvc_inval_current ();\n  if (current->restart_valid)\n    longjmp (current->restart, 1);\n  else\n    /* An invalid parameter notification from outside the gnulib code.\n       Give the caller a chance to intervene.  */\n    RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      }
    ],
    "gl_msvc_inval_current": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "struct gl_msvc_inval_per_thread *\ngl_msvc_inval_current (void)\n{\n  if (!tls_initialized)\n    {\n      tls_index = TlsAlloc ();\n      tls_initialized = 1;\n    }\n  if (tls_index == TLS_OUT_OF_INDEXES)\n    /* TlsAlloc had failed.  */\n    return &not_per_thread;\n  else\n    {\n      struct gl_msvc_inval_per_thread *pointer =\n        (struct gl_msvc_inval_per_thread *) TlsGetValue (tls_index);\n      if (pointer == NULL)\n        {\n          /* First call.  Allocate a new 'struct gl_msvc_inval_per_thread'.  */\n          pointer =\n            (struct gl_msvc_inval_per_thread *)\n            malloc (sizeof (struct gl_msvc_inval_per_thread));\n          if (pointer == NULL)\n            /* Could not allocate memory.  Use the global storage.  */\n            pointer = &not_per_thread;\n          TlsSetValue (tls_index, pointer);\n        }\n      return pointer;\n    }\n}",
      "lines": 29,
      "depth": 15,
      "decorators": [
        "struct gl_msvc_inval_per_thread",
        "struct",
        "gl_msvc_inval_per_thread",
        "*\ngl_msvc_inval_current (void)",
        "*"
      ]
    },
    "gl_msvc_inval_ensure_handler": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "void\ngl_msvc_inval_ensure_handler (void)\n{\n  if (gl_msvc_inval_initialized == 0)\n    {\n      _set_invalid_parameter_handler (gl_msvc_invalid_parameter_handler);\n      gl_msvc_inval_initialized = 1;\n    }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "libidn/libidn2-2.0.5/gl/msvc-inval.h": {},
  "libidn/libidn2-2.0.5/gl/msvc-nothrow.c": {
    "_gl_nothrow_get_osfhandle": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        41,
        5
      ],
      "content": "intptr_t\n_gl_nothrow_get_osfhandle (int fd)\n{\n  intptr_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _get_osfhandle (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "intptr_t"
      ]
    }
  },
  "libidn/libidn2-2.0.5/gl/msvc-nothrow.h": {},
  "libidn/libidn2-2.0.5/gl/progname.c": {
    "set_program_name": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "void\nset_program_name (const char *argv0)\n{\n  /* libtool creates a temporary executable whose name is sometimes prefixed\n     with \"lt-\" (depends on the platform).  It also makes argv[0] absolute.\n     But the name of the temporary executable is a detail that should not be\n     visible to the end user and to the test suite.\n     Remove this \"<dirname>/.libs/\" or \"<dirname>/.libs/lt-\" prefix here.  */\n  const char *slash;\n  const char *base;\n\n  /* Sanity check.  POSIX requires the invoking process to pass a non-NULL\n     argv[0].  */\n  if (argv0 == NULL)\n    {\n      /* It's a bug in the invoking program.  Help diagnosing it.  */\n      fputs (\"A NULL argv[0] was passed through an exec system call.\\n\",\n             stderr);\n      abort ();\n    }\n\n  slash = strrchr (argv0, '/');\n  base = (slash != NULL ? slash + 1 : argv0);\n  if (base - argv0 >= 7 && strncmp (base - 7, \"/.libs/\", 7) == 0)\n    {\n      argv0 = base;\n      if (strncmp (base, \"lt-\", 3) == 0)\n        {\n          argv0 = base + 3;\n          /* On glibc systems, remove the \"lt-\" prefix from the variable\n             program_invocation_short_name.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME\n          program_invocation_short_name = (char *) argv0;\n#endif\n        }\n    }\n\n  /* But don't strip off a leading <dirname>/ in general, because when the user\n     runs\n         /some/hidden/place/bin/cp foo foo\n     he should get the error message\n         /some/hidden/place/bin/cp: `foo' and `foo' are the same file\n     not\n         cp: `foo' and `foo' are the same file\n   */\n\n  program_name = argv0;\n\n  /* On glibc systems, the error() function comes from libc and uses the\n     variable program_invocation_name, not program_name.  So set this variable\n     as well.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_NAME\n  program_invocation_name = (char *) argv0;\n#endif\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "libidn/libidn2-2.0.5/gl/progname.h": {},
  "libidn/libidn2-2.0.5/gl/rawmemchr.c": {
    "rawmemchr": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "void *\nrawmemchr (const void *s, int c_in)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       (size_t) char_ptr % sizeof (longword) != 0;\n       ++char_ptr)\n    if (*char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will\n     test a longword at a time.  The tricky part is testing if *any of\n     the four* bytes in the longword in question are equal to NUL or\n     c.  We first use an xor with repeated_c.  This reduces the task\n     to testing whether *any of the four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     The test whether any byte in longword1 is zero is equivalent\n     to testing whether tmp is nonzero.\n\n     This test can read beyond the end of a string, depending on where\n     C_IN is encountered.  However, this is considered safe since the\n     initialization phase ensured that the read will be aligned,\n     therefore, the read will not cross page boundaries and will not\n     cause a fault.  */\n\n  while (1)\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that one of the sizeof (longword) bytes\n     starting at char_ptr is == c.  On little-endian machines, we\n     could determine the first such byte without any further memory\n     accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.\n     Choose code that works in both cases.  */\n\n  char_ptr = (unsigned char *) longword_ptr;\n  while (*char_ptr != c)\n    char_ptr++;\n  return (void *) char_ptr;\n}",
      "lines": 114,
      "depth": 14,
      "decorators": [
        "void",
        "*\nrawmemchr (const void *s, int c_in)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/gl/stdarg.in.h": {},
  "libidn/libidn2-2.0.5/gl/stdbool.in.h": {},
  "libidn/libidn2-2.0.5/gl/stddef.in.h": {},
  "libidn/libidn2-2.0.5/gl/stdint.in.h": {},
  "libidn/libidn2-2.0.5/gl/stdio.in.h": {},
  "libidn/libidn2-2.0.5/gl/stdlib.in.h": {},
  "libidn/libidn2-2.0.5/gl/strchrnul.c": {
    "strchrnul": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "char *\nstrchrnul (const char *s, int c_in)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned char c;\n\n  c = (unsigned char) c_in;\n  if (!c)\n    return rawmemchr (s, 0);\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       (size_t) char_ptr % sizeof (longword) != 0;\n       ++char_ptr)\n    if (!*char_ptr || *char_ptr == c)\n      return (char *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will\n     test a longword at a time.  The tricky part is testing if *any of\n     the four* bytes in the longword in question are equal to NUL or\n     c.  We first use an xor with repeated_c.  This reduces the task\n     to testing whether *any of the four* bytes in longword1 or\n     longword2 is zero.\n\n     Let's consider longword1.  We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     The test whether any byte in longword1 or longword2 is zero is equivalent\n     to testing whether tmp1 is nonzero or tmp2 is nonzero.  We can combine\n     this into a single test, whether (tmp1 | tmp2) is nonzero.\n\n     This test can read more than one byte beyond the end of a string,\n     depending on where the terminating NUL is encountered.  However,\n     this is considered safe since the initialization phase ensured\n     that the read will be aligned, therefore, the read will not cross\n     page boundaries and will not cause a fault.  */\n\n  while (1)\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n      longword longword2 = *longword_ptr;\n\n      if (((((longword1 - repeated_one) & ~longword1)\n            | ((longword2 - repeated_one) & ~longword2))\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that one of the sizeof (longword) bytes\n     starting at char_ptr is == 0 or == c.  On little-endian machines,\n     we could determine the first such byte without any further memory\n     accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.\n     Choose code that works in both cases.  */\n\n  char_ptr = (unsigned char *) longword_ptr;\n  while (*char_ptr && (*char_ptr != c))\n    char_ptr++;\n  return (char *) char_ptr;\n}",
      "lines": 120,
      "depth": 16,
      "decorators": [
        "char",
        "*\nstrchrnul (const char *s, int c_in)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/gl/strerror-override.c": {
    "strerror_override": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "const char *\nstrerror_override (int errnum)\n{\n  /* These error messages are taken from glibc/sysdeps/gnu/errlist.c.  */\n  switch (errnum)\n    {\n#if REPLACE_STRERROR_0\n    case 0:\n      return \"Success\";\n#endif\n\n#if GNULIB_defined_ESOCK /* native Windows platforms with older <errno.h> */\n    case EINPROGRESS:\n      return \"Operation now in progress\";\n    case EALREADY:\n      return \"Operation already in progress\";\n    case ENOTSOCK:\n      return \"Socket operation on non-socket\";\n    case EDESTADDRREQ:\n      return \"Destination address required\";\n    case EMSGSIZE:\n      return \"Message too long\";\n    case EPROTOTYPE:\n      return \"Protocol wrong type for socket\";\n    case ENOPROTOOPT:\n      return \"Protocol not available\";\n    case EPROTONOSUPPORT:\n      return \"Protocol not supported\";\n    case EOPNOTSUPP:\n      return \"Operation not supported\";\n    case EAFNOSUPPORT:\n      return \"Address family not supported by protocol\";\n    case EADDRINUSE:\n      return \"Address already in use\";\n    case EADDRNOTAVAIL:\n      return \"Cannot assign requested address\";\n    case ENETDOWN:\n      return \"Network is down\";\n    case ENETUNREACH:\n      return \"Network is unreachable\";\n    case ECONNRESET:\n      return \"Connection reset by peer\";\n    case ENOBUFS:\n      return \"No buffer space available\";\n    case EISCONN:\n      return \"Transport endpoint is already connected\";\n    case ENOTCONN:\n      return \"Transport endpoint is not connected\";\n    case ETIMEDOUT:\n      return \"Connection timed out\";\n    case ECONNREFUSED:\n      return \"Connection refused\";\n    case ELOOP:\n      return \"Too many levels of symbolic links\";\n    case EHOSTUNREACH:\n      return \"No route to host\";\n    case EWOULDBLOCK:\n      return \"Operation would block\";\n#endif\n#if GNULIB_defined_ESTREAMS /* native Windows platforms with older <errno.h> */\n    case ETXTBSY:\n      return \"Text file busy\";\n    case ENODATA:\n      return \"No data available\";\n    case ENOSR:\n      return \"Out of streams resources\";\n    case ENOSTR:\n      return \"Device not a stream\";\n    case ETIME:\n      return \"Timer expired\";\n    case EOTHER:\n      return \"Other error\";\n#endif\n#if GNULIB_defined_EWINSOCK /* native Windows platforms */\n    case ESOCKTNOSUPPORT:\n      return \"Socket type not supported\";\n    case EPFNOSUPPORT:\n      return \"Protocol family not supported\";\n    case ESHUTDOWN:\n      return \"Cannot send after transport endpoint shutdown\";\n    case ETOOMANYREFS:\n      return \"Too many references: cannot splice\";\n    case EHOSTDOWN:\n      return \"Host is down\";\n    case EPROCLIM:\n      return \"Too many processes\";\n    case EUSERS:\n      return \"Too many users\";\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n    case ESTALE:\n      return \"Stale NFS file handle\";\n    case EREMOTE:\n      return \"Object is remote\";\n# if HAVE_WINSOCK2_H\n      /* WSA_INVALID_HANDLE maps to EBADF */\n      /* WSA_NOT_ENOUGH_MEMORY maps to ENOMEM */\n      /* WSA_INVALID_PARAMETER maps to EINVAL */\n    case WSA_OPERATION_ABORTED:\n      return \"Overlapped operation aborted\";\n    case WSA_IO_INCOMPLETE:\n      return \"Overlapped I/O event object not in signaled state\";\n    case WSA_IO_PENDING:\n      return \"Overlapped operations will complete later\";\n      /* WSAEINTR maps to EINTR */\n      /* WSAEBADF maps to EBADF */\n      /* WSAEACCES maps to EACCES */\n      /* WSAEFAULT maps to EFAULT */\n      /* WSAEINVAL maps to EINVAL */\n      /* WSAEMFILE maps to EMFILE */\n      /* WSAEWOULDBLOCK maps to EWOULDBLOCK */\n      /* WSAEINPROGRESS maps to EINPROGRESS */\n      /* WSAEALREADY maps to EALREADY */\n      /* WSAENOTSOCK maps to ENOTSOCK */\n      /* WSAEDESTADDRREQ maps to EDESTADDRREQ */\n      /* WSAEMSGSIZE maps to EMSGSIZE */\n      /* WSAEPROTOTYPE maps to EPROTOTYPE */\n      /* WSAENOPROTOOPT maps to ENOPROTOOPT */\n      /* WSAEPROTONOSUPPORT maps to EPROTONOSUPPORT */\n      /* WSAESOCKTNOSUPPORT is ESOCKTNOSUPPORT */\n      /* WSAEOPNOTSUPP maps to EOPNOTSUPP */\n      /* WSAEPFNOSUPPORT is EPFNOSUPPORT */\n      /* WSAEAFNOSUPPORT maps to EAFNOSUPPORT */\n      /* WSAEADDRINUSE maps to EADDRINUSE */\n      /* WSAEADDRNOTAVAIL maps to EADDRNOTAVAIL */\n      /* WSAENETDOWN maps to ENETDOWN */\n      /* WSAENETUNREACH maps to ENETUNREACH */\n      /* WSAENETRESET maps to ENETRESET */\n      /* WSAECONNABORTED maps to ECONNABORTED */\n      /* WSAECONNRESET maps to ECONNRESET */\n      /* WSAENOBUFS maps to ENOBUFS */\n      /* WSAEISCONN maps to EISCONN */\n      /* WSAENOTCONN maps to ENOTCONN */\n      /* WSAESHUTDOWN is ESHUTDOWN */\n      /* WSAETOOMANYREFS is ETOOMANYREFS */\n      /* WSAETIMEDOUT maps to ETIMEDOUT */\n      /* WSAECONNREFUSED maps to ECONNREFUSED */\n      /* WSAELOOP maps to ELOOP */\n      /* WSAENAMETOOLONG maps to ENAMETOOLONG */\n      /* WSAEHOSTDOWN is EHOSTDOWN */\n      /* WSAEHOSTUNREACH maps to EHOSTUNREACH */\n      /* WSAENOTEMPTY maps to ENOTEMPTY */\n      /* WSAEPROCLIM is EPROCLIM */\n      /* WSAEUSERS is EUSERS */\n      /* WSAEDQUOT is EDQUOT */\n      /* WSAESTALE is ESTALE */\n      /* WSAEREMOTE is EREMOTE */\n    case WSASYSNOTREADY:\n      return \"Network subsystem is unavailable\";\n    case WSAVERNOTSUPPORTED:\n      return \"Winsock.dll version out of range\";\n    case WSANOTINITIALISED:\n      return \"Successful WSAStartup not yet performed\";\n    case WSAEDISCON:\n      return \"Graceful shutdown in progress\";\n    case WSAENOMORE: case WSA_E_NO_MORE:\n      return \"No more results\";\n    case WSAECANCELLED: case WSA_E_CANCELLED:\n      return \"Call was canceled\";\n    case WSAEINVALIDPROCTABLE:\n      return \"Procedure call table is invalid\";\n    case WSAEINVALIDPROVIDER:\n      return \"Service provider is invalid\";\n    case WSAEPROVIDERFAILEDINIT:\n      return \"Service provider failed to initialize\";\n    case WSASYSCALLFAILURE:\n      return \"System call failure\";\n    case WSASERVICE_NOT_FOUND:\n      return \"Service not found\";\n    case WSATYPE_NOT_FOUND:\n      return \"Class type not found\";\n    case WSAEREFUSED:\n      return \"Database query was refused\";\n    case WSAHOST_NOT_FOUND:\n      return \"Host not found\";\n    case WSATRY_AGAIN:\n      return \"Nonauthoritative host not found\";\n    case WSANO_RECOVERY:\n      return \"Nonrecoverable error\";\n    case WSANO_DATA:\n      return \"Valid name, no data record of requested type\";\n      /* WSA_QOS_* omitted */\n# endif\n#endif\n\n#if GNULIB_defined_ENOMSG\n    case ENOMSG:\n      return \"No message of desired type\";\n#endif\n\n#if GNULIB_defined_EIDRM\n    case EIDRM:\n      return \"Identifier removed\";\n#endif\n\n#if GNULIB_defined_ENOLINK\n    case ENOLINK:\n      return \"Link has been severed\";\n#endif\n\n#if GNULIB_defined_EPROTO\n    case EPROTO:\n      return \"Protocol error\";\n#endif\n\n#if GNULIB_defined_EMULTIHOP\n    case EMULTIHOP:\n      return \"Multihop attempted\";\n#endif\n\n#if GNULIB_defined_EBADMSG\n    case EBADMSG:\n      return \"Bad message\";\n#endif\n\n#if GNULIB_defined_EOVERFLOW\n    case EOVERFLOW:\n      return \"Value too large for defined data type\";\n#endif\n\n#if GNULIB_defined_ENOTSUP\n    case ENOTSUP:\n      return \"Not supported\";\n#endif\n\n#if GNULIB_defined_ENETRESET\n    case ENETRESET:\n      return \"Network dropped connection on reset\";\n#endif\n\n#if GNULIB_defined_ECONNABORTED\n    case ECONNABORTED:\n      return \"Software caused connection abort\";\n#endif\n\n#if GNULIB_defined_ESTALE\n    case ESTALE:\n      return \"Stale NFS file handle\";\n#endif\n\n#if GNULIB_defined_EDQUOT\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n#endif\n\n#if GNULIB_defined_ECANCELED\n    case ECANCELED:\n      return \"Operation canceled\";\n#endif\n\n#if GNULIB_defined_EOWNERDEAD\n    case EOWNERDEAD:\n      return \"Owner died\";\n#endif\n\n#if GNULIB_defined_ENOTRECOVERABLE\n    case ENOTRECOVERABLE:\n      return \"State not recoverable\";\n#endif\n\n#if GNULIB_defined_EILSEQ\n    case EILSEQ:\n      return \"Invalid or incomplete multibyte or wide character\";\n#endif\n\n    default:\n      return NULL;\n    }\n}",
      "lines": 269,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nstrerror_override (int errnum)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/gl/strerror-override.h": {},
  "libidn/libidn2-2.0.5/gl/strerror.c": {},
  "libidn/libidn2-2.0.5/gl/string.in.h": {},
  "libidn/libidn2-2.0.5/gl/stripslash.c": {
    "strip_trailing_slashes": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "bool\nstrip_trailing_slashes (char *file)\n{\n  char *base = last_component (file);\n  char *base_lim;\n  bool had_slash;\n\n  /* last_component returns \"\" for file system roots, but we need to turn\n     \"///\" into \"/\".  */\n  if (! *base)\n    base = file;\n  base_lim = base + base_len (base);\n  had_slash = (*base_lim != '\\0');\n  *base_lim = '\\0';\n  return had_slash;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    }
  },
  "libidn/libidn2-2.0.5/gl/strverscmp.c": {
    "__strverscmp": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "int\n__strverscmp (const char *s1, const char *s2)\n{\n  const unsigned char *p1 = (const unsigned char *) s1;\n  const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n  int state;\n  int diff;\n\n  /* Symbol(s)    0       [1-9]   others\n     Transition   (10) 0  (01) d  (00) x   */\n  static const unsigned char next_state[] =\n  {\n      /* state    x    d    0  */\n      /* S_N */  S_N, S_I, S_Z,\n      /* S_I */  S_N, S_I, S_I,\n      /* S_F */  S_N, S_F, S_F,\n      /* S_Z */  S_N, S_F, S_Z\n  };\n\n  static const signed char result_type[] =\n  {\n      /* state   x/x  x/d  x/0  d/x  d/d  d/0  0/x  0/d  0/0  */\n\n      /* S_N */  CMP, CMP, CMP, CMP, LEN, CMP, CMP, CMP, CMP,\n      /* S_I */  CMP, -1,  -1,  +1,  LEN, LEN, +1,  LEN, LEN,\n      /* S_F */  CMP, CMP, CMP, CMP, CMP, CMP, CMP, CMP, CMP,\n      /* S_Z */  CMP, +1,  +1,  -1,  CMP, CMP, -1,  CMP, CMP\n  };\n\n  if (p1 == p2)\n    return 0;\n\n  c1 = *p1++;\n  c2 = *p2++;\n  /* Hint: '0' is a digit too.  */\n  state = S_N + ((c1 == '0') + (isdigit (c1) != 0));\n\n  while ((diff = c1 - c2) == 0)\n    {\n      if (c1 == '\\0')\n        return diff;\n\n      state = next_state[state];\n      c1 = *p1++;\n      c2 = *p2++;\n      state += (c1 == '0') + (isdigit (c1) != 0);\n    }\n\n  state = result_type[state * 3 + (((c2 == '0') + (isdigit (c2) != 0)))];\n\n  switch (state)\n    {\n    case CMP:\n      return diff;\n\n    case LEN:\n      while (isdigit (*p1++))\n        if (!isdigit (*p2++))\n          return 1;\n\n      return isdigit (*p2) ? -1 : diff;\n\n    default:\n      return state;\n    }\n}",
      "lines": 67,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/gl/sys_types.in.h": {},
  "libidn/libidn2-2.0.5/gl/unistd.c": {},
  "libidn/libidn2-2.0.5/gl/unistd.in.h": {
    "rpl_environ": {
      "start_point": [
        427,
        0
      ],
      "end_point": [
        431,
        1
      ],
      "content": "_GL_UNISTD_INLINE char ***\nrpl_environ (void)\n{\n  return &environ;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "char",
        "char",
        "***\nrpl_environ (void)",
        "*",
        "**\nrpl_environ (void)",
        "*",
        "*\nrpl_environ (void)",
        "*"
      ]
    },
    "getpagesize": {
      "start_point": [
        894,
        0
      ],
      "end_point": [
        898,
        1
      ],
      "content": "_GL_UNISTD_INLINE int\ngetpagesize ()\n{\n  return _gl_getpagesize ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "int",
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/gl/verify.h": {},
  "libidn/libidn2-2.0.5/gl/version-etc.c": {
    "version_etc_arn": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "void\nversion_etc_arn (FILE *stream,\n                 const char *command_name, const char *package,\n                 const char *version,\n                 const char * const * authors, size_t n_authors)\n{\n  if (command_name)\n    fprintf (stream, \"%s (%s) %s\\n\", command_name, package, version);\n  else\n    fprintf (stream, \"%s %s\\n\", package, version);\n\n#ifdef PACKAGE_PACKAGER\n# ifdef PACKAGE_PACKAGER_VERSION\n  fprintf (stream, _(\"Packaged by %s (%s)\\n\"), PACKAGE_PACKAGER,\n           PACKAGE_PACKAGER_VERSION);\n# else\n  fprintf (stream, _(\"Packaged by %s\\n\"), PACKAGE_PACKAGER);\n# endif\n#endif\n\n  /* TRANSLATORS: Translate \"(C)\" to the copyright symbol\n     (C-in-a-circle), if this symbol is available in the user's\n     locale.  Otherwise, do not translate \"(C)\"; leave it as-is.  */\n  fprintf (stream, version_etc_copyright, _(\"(C)\"), COPYRIGHT_YEAR);\n\n  fputs (_(\"\\\n\\n\\\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\\n\\\nThis is free software: you are free to change and redistribute it.\\n\\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\\n\\n\\\n\"),\n         stream);\n\n  switch (n_authors)\n    {\n    case 0:\n      /* The caller must provide at least one author name.  */\n      abort ();\n    case 1:\n      /* TRANSLATORS: %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s.\\n\"), authors[0]);\n      break;\n    case 2:\n      /* TRANSLATORS: Each %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s and %s.\\n\"), authors[0], authors[1]);\n      break;\n    case 3:\n      /* TRANSLATORS: Each %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2]);\n      break;\n    case 4:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\nand %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3]);\n      break;\n    case 5:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4]);\n      break;\n    case 6:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5]);\n      break;\n    case 7:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5], authors[6]);\n      break;\n    case 8:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\"),\n                authors[0], authors[1], authors[2], authors[3], authors[4],\n                authors[5], authors[6], authors[7]);\n      break;\n    case 9:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5], authors[6], authors[7], authors[8]);\n      break;\n    default:\n      /* 10 or more authors.  Use an abbreviation, since the human reader\n         will probably not want to read the entire list anyway.  */\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\"),\n                authors[0], authors[1], authors[2], authors[3], authors[4],\n                authors[5], authors[6], authors[7], authors[8]);\n      break;\n    }\n}",
      "lines": 113,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "version_etc_ar": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "void\nversion_etc_ar (FILE *stream,\n                const char *command_name, const char *package,\n                const char *version, const char * const * authors)\n{\n  size_t n_authors;\n\n  for (n_authors = 0; authors[n_authors]; n_authors++)\n    ;\n  version_etc_arn (stream, command_name, package, version, authors, n_authors);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "version_etc_va": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "void\nversion_etc_va (FILE *stream,\n                const char *command_name, const char *package,\n                const char *version, va_list authors)\n{\n  size_t n_authors;\n  const char *authtab[10];\n\n  for (n_authors = 0;\n       n_authors < 10\n         && (authtab[n_authors] = va_arg (authors, const char *)) != NULL;\n       n_authors++)\n    ;\n  version_etc_arn (stream, command_name, package, version,\n                   authtab, n_authors);\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "version_etc": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "void\nversion_etc (FILE *stream,\n             const char *command_name, const char *package,\n             const char *version, /* const char *author1, ...*/ ...)\n{\n  va_list authors;\n\n  va_start (authors, version);\n  version_etc_va (stream, command_name, package, version, authors);\n  va_end (authors);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "emit_bug_reporting_address": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "void\nemit_bug_reporting_address (void)\n{\n  /* TRANSLATORS: The placeholder indicates the bug-reporting address\n     for this package.  Please add _another line_ saying\n     \"Report translation bugs to <...>\\n\" with the address for translation\n     bugs (typically your translation team's web or email address).  */\n  printf (_(\"\\nReport bugs to: %s\\n\"), PACKAGE_BUGREPORT);\n#ifdef PACKAGE_PACKAGER_BUG_REPORTS\n  printf (_(\"Report %s bugs to: %s\\n\"), PACKAGE_PACKAGER,\n          PACKAGE_PACKAGER_BUG_REPORTS);\n#endif\n#ifdef PACKAGE_URL\n  printf (_(\"%s home page: <%s>\\n\"), PACKAGE_NAME, PACKAGE_URL);\n#else\n  printf (_(\"%s home page: <http://www.gnu.org/software/%s/>\\n\"),\n          PACKAGE_NAME, PACKAGE);\n#endif\n  fputs (_(\"General help using GNU software: <http://www.gnu.org/gethelp/>\\n\"),\n         stdout);\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "libidn/libidn2-2.0.5/gl/version-etc.h": {},
  "libidn/libidn2-2.0.5/gl/warn-on-use.h": {},
  "libidn/libidn2-2.0.5/gl/_Noreturn.h": {},
  "libidn/libidn2-2.0.5/lib/bidi.c": {
    "_isBidi": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static bool\n_isBidi (const uint32_t *label, size_t llen)\n{\n  for (; (ssize_t) llen > 0; llen--) {\n    int bc = uc_bidi_category (*label++);\n\n    if (bc == UC_BIDI_R || bc == UC_BIDI_AL || bc == UC_BIDI_AN)\n      return 1;\n  }\n\n  return 0;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "_idn2_bidi": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "int\n_idn2_bidi (const uint32_t * label, size_t llen)\n{\n  int bc;\n  int endok = 1;\n\n  if (!_isBidi (label, llen))\n    return IDN2_OK;\n\n  // 2.1\n  switch ((bc = uc_bidi_category (*label))) {\n    case UC_BIDI_L:\n      // check 2.5 & 2.6\n      for (size_t it = 1; it < llen; it++) {\n\tbc = uc_bidi_category(label[it]);\n\n\tif (bc == UC_BIDI_L || bc == UC_BIDI_EN || bc == UC_BIDI_NSM) {\n\t  endok = 1;\n\t} else {\n\t  if (bc != UC_BIDI_ES && bc != UC_BIDI_CS && bc != UC_BIDI_ET && bc != UC_BIDI_ON && bc != UC_BIDI_BN) {\n\t    /* printf(\"LTR label contains invalid code point\\n\"); */\n\t    return IDN2_BIDI;\n\t  }\n\t  endok = 0;\n\t}\n      }\n      /* printf(\"LTR label ends with invalid code point\\n\"); */\n      return endok ? IDN2_OK : IDN2_BIDI;\n\n    case UC_BIDI_R:\n    case UC_BIDI_AL:\n      // check 2.2, 2.3, 2.4\n      /* printf(\"Label[0]=%04X: %s\\n\", label[0], uc_bidi_category_name(bc)); */\n      for (size_t it = 1; it < llen; it++) {\n\tbc = uc_bidi_category(label[it]);\n\n\t/* printf(\"Label[%zu]=%04X: %s\\n\", it, label[it], uc_bidi_category_name(bc)); */\n\tif (bc == UC_BIDI_R || bc == UC_BIDI_AL || bc == UC_BIDI_EN || bc == UC_BIDI_AN || bc == UC_BIDI_NSM) {\n\t  endok = 1;\n\t} else {\n\t  if (bc != UC_BIDI_ES && bc != UC_BIDI_CS && bc != UC_BIDI_ET && bc != UC_BIDI_ON && bc != UC_BIDI_BN) {\n\t    /* printf(\"RTL label contains invalid code point\\n\"); */\n\t    return IDN2_BIDI;\n\t  }\n\t  endok = 0;\n\t}\n      }\n      /* printf(\"RTL label ends with invalid code point\\n\"); */\n      return endok ? IDN2_OK : IDN2_BIDI;\n\n    default:\n      /* printf(\"Label begins with invalid BIDI class %s\\n\", uc_bidi_category_name(bc)); */\n      return IDN2_BIDI;\n  }\n}",
      "lines": 55,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/lib/bidi.h": {},
  "libidn/libidn2-2.0.5/lib/context.c": {
    "_idn2_contextj_rule": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "int\n_idn2_contextj_rule (const uint32_t * label, size_t llen, size_t pos)\n{\n  uint32_t cp;\n\n  if (llen == 0)\n    return IDN2_OK;\n\n  cp = label[pos];\n\n  if (!_idn2_contextj_p (cp))\n    return IDN2_OK;\n\n  switch (cp)\n    {\n    case 0x200C:\t\t/* ZERO WIDTH NON-JOINER */\n      if (pos > 0)\n\t{\n\t  /* If Canonical_Combining_Class(Before(cp)) .eq.  Virama Then True; */\n\t  uint32_t before_cp = label[pos - 1];\n\t  int cc = uc_combining_class (before_cp);\n\t  if (cc == UC_CCC_VR)\n\t    return IDN2_OK;\n\t}\n\n      /* See http://permalink.gmane.org/gmane.ietf.idnabis/6980 for\n         clarified rule. */\n\n      if (pos == 0 || pos == llen - 1)\n\treturn IDN2_CONTEXTJ;\n\n      {\n\tint jt;\n\tsize_t tmp;\n\n\t/* Search backwards. */\n\tfor (tmp = pos - 1;; tmp--)\n\t  {\n\t    jt = uc_joining_type (label[tmp]);\n\t    if (jt == UC_JOINING_TYPE_L || jt == UC_JOINING_TYPE_D)\n\t      break;\n\t    if (tmp == 0)\n\t      return IDN2_CONTEXTJ;\n\t    if (jt == UC_JOINING_TYPE_T)\n\t      continue;\n\t    return IDN2_CONTEXTJ;\n\t  }\n\n\t/* Search forward. */\n\tfor (tmp = pos + 1; tmp < llen; tmp++)\n\t  {\n\t    jt = uc_joining_type (label[tmp]);\n\t    if (jt == UC_JOINING_TYPE_R || jt == UC_JOINING_TYPE_D)\n\t      break;\n\t    if (tmp == llen - 1)\n\t      return IDN2_CONTEXTJ;\n\t    if (jt == UC_JOINING_TYPE_T)\n\t      continue;\n\t    return IDN2_CONTEXTJ;\n\t  }\n      }\n\n      return IDN2_OK;\n      break;\n\n    case 0x200D:\t\t/* ZERO WIDTH JOINER */\n      if (pos > 0)\n\t{\n\t  uint32_t before_cp = label[pos - 1];\n\t  int cc = uc_combining_class (before_cp);\n\t  if (cc == UC_CCC_VR)\n\t    return IDN2_OK;\n\t}\n      return IDN2_CONTEXTJ;\n    }\n\n  return IDN2_CONTEXTJ_NO_RULE;\n}",
      "lines": 78,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "_idn2_contexto_rule": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "int\n_idn2_contexto_rule (const uint32_t * label, size_t llen, size_t pos)\n{\n  uint32_t cp = label[pos];\n\n  if (!_idn2_contexto_p (cp))\n    return IDN2_OK;\n\n  switch (cp)\n    {\n    case 0x00B7:\n      /* MIDDLE DOT */\n      if (llen < 3)\n\treturn IDN2_CONTEXTO;\n      if (pos == 0 || pos == llen - 1)\n\treturn IDN2_CONTEXTO;\n      if (label[pos - 1] == 0x006C && label[pos + 1] == 0x006C)\n\treturn IDN2_OK;\n      return IDN2_CONTEXTO;\n      break;\n\n    case 0x0375:\n      /* GREEK LOWER NUMERAL SIGN (KERAIA) */\n      if (pos == llen - 1)\n\treturn IDN2_CONTEXTO;\n      if (strcmp (uc_script (label[pos + 1])->name, \"Greek\") == 0)\n\treturn IDN2_OK;\n      return IDN2_CONTEXTO;\n      break;\n\n    case 0x05F3:\n      /* HEBREW PUNCTUATION GERESH */\n    case 0x05F4:\n      /* HEBREW PUNCTUATION GERSHAYIM */\n      if (pos == 0)\n\treturn IDN2_CONTEXTO;\n      if (strcmp (uc_script (label[pos - 1])->name, \"Hebrew\") == 0)\n\treturn IDN2_OK;\n      return IDN2_CONTEXTO;\n      break;\n\n    case 0x0660:\n    case 0x0661:\n    case 0x0662:\n    case 0x0663:\n    case 0x0664:\n    case 0x0665:\n    case 0x0666:\n    case 0x0667:\n    case 0x0668:\n    case 0x0669:\n      {\n\t/* ARABIC-INDIC DIGITS */\n\tsize_t i;\n\tfor (i = 0; i < llen; i++)\n\t  if (label[i] >= 0x6F0 && label[i] <= 0x06F9)\n\t    return IDN2_CONTEXTO;\n\treturn IDN2_OK;\n\tbreak;\n      }\n\n    case 0x06F0:\n    case 0x06F1:\n    case 0x06F2:\n    case 0x06F3:\n    case 0x06F4:\n    case 0x06F5:\n    case 0x06F6:\n    case 0x06F7:\n    case 0x06F8:\n    case 0x06F9:\n      {\n\t/* EXTENDED ARABIC-INDIC DIGITS */\n\tsize_t i;\n\tfor (i = 0; i < llen; i++)\n\t  if (label[i] >= 0x660 && label[i] <= 0x0669)\n\t    return IDN2_CONTEXTO;\n\treturn IDN2_OK;\n\tbreak;\n      }\n    case 0x30FB:\n      {\n\t/* KATAKANA MIDDLE DOT */\n\tsize_t i;\n\tbool script_ok = false;\n\n\tfor (i = 0; !script_ok && i < llen; i++)\n\t  if (strcmp (uc_script (label[i])->name, \"Hiragana\") == 0\n\t      || strcmp (uc_script (label[i])->name, \"Katakana\") == 0\n\t      || strcmp (uc_script (label[i])->name, \"Han\") == 0)\n\t    script_ok = true;\n\n\tif (script_ok)\n\t  return IDN2_OK;\n\treturn IDN2_CONTEXTO;\n\tbreak;\n      }\n    }\n\n  return IDN2_CONTEXTO_NO_RULE;\n}",
      "lines": 101,
      "depth": 19,
      "decorators": [
        "int"
      ]
    },
    "_idn2_contexto_with_rule": {
      "start_point": [
        219,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "bool\n_idn2_contexto_with_rule (uint32_t cp)\n{\n  switch (cp)\n    {\n    case 0x00B7:\n      /* MIDDLE DOT */\n    case 0x0375:\n      /* GREEK LOWER NUMERAL SIGN (KERAIA) */\n    case 0x05F3:\n      /* HEBREW PUNCTUATION GERESH */\n    case 0x05F4:\n      /* HEBREW PUNCTUATION GERSHAYIM */\n    case 0x0660:\n    case 0x0661:\n    case 0x0662:\n    case 0x0663:\n    case 0x0664:\n    case 0x0665:\n    case 0x0666:\n    case 0x0667:\n    case 0x0668:\n    case 0x0669:\n      /* ARABIC-INDIC DIGITS */\n    case 0x06F0:\n    case 0x06F1:\n    case 0x06F2:\n    case 0x06F3:\n    case 0x06F4:\n    case 0x06F5:\n    case 0x06F6:\n    case 0x06F7:\n    case 0x06F8:\n    case 0x06F9:\n      /* EXTENDED ARABIC-INDIC DIGITS */\n    case 0x30FB:\n      /* KATAKANA MIDDLE DOT */\n      return true;\n      break;\n    }\n\n  return false;\n}",
      "lines": 43,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "libidn/libidn2-2.0.5/lib/context.h": {},
  "libidn/libidn2-2.0.5/lib/data.c": {},
  "libidn/libidn2-2.0.5/lib/data.h": {},
  "libidn/libidn2-2.0.5/lib/decode.c": {
    "idn2_to_unicode_8z4z": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "int\nidn2_to_unicode_8z4z (const char * input, uint32_t ** output, G_GNUC_UNUSED int flags)\n{\n  uint32_t *domain_u32;\n  int rc;\n\n  if (!input)\n    {\n      if (output)\n\t*output = NULL;\n      return IDN2_OK;\n    }\n\n  /* split into labels and check */\n  uint32_t out_u32[IDN2_DOMAIN_MAX_LENGTH + 1];\n  size_t out_len = 0;\n  const char *e, *s;\n\n  for (e = s = input; *e; s = e)\n    {\n      uint32_t label_u32[IDN2_LABEL_MAX_LENGTH];\n      size_t label_len = IDN2_LABEL_MAX_LENGTH;\n\n      while (*e && *e != '.')\n\te++;\n\n      if (e - s >= 4 && (s[0] == 'x' || s[0] == 'X')\n\t  && (s[1] == 'n' || s[1] == 'N')\n\t  && s[2] == '-' && s[3] == '-')\n\t{\n\t  s += 4;\n\n\t  rc =\n\t    _idn2_punycode_decode (e - s, (char *) s, &label_len, label_u32);\n\t  if (rc)\n\t    return rc;\n\n\t  if (out_len + label_len + (*e == '.') > IDN2_DOMAIN_MAX_LENGTH)\n\t    return IDN2_TOO_BIG_DOMAIN;\n\n\t  u32_cpy (out_u32 + out_len, label_u32, label_len);\n\t}\n      else\n        {\n\t  /* convert UTF-8 input to UTF-32 */\n\t  if (!(domain_u32 = u8_to_u32 ((uint8_t*)s, e - s, NULL, &label_len)))\n\t    {\n\t      if (errno == ENOMEM)\n\t\treturn IDN2_MALLOC;\n\t      return IDN2_ENCODING_ERROR;\n\t    }\n\n\t  if (label_len > IDN2_LABEL_MAX_LENGTH)\n\t    {\n\t      free (domain_u32);\n\t      return IDN2_TOO_BIG_LABEL;\n\t    }\n\n\t  if (out_len + label_len + (*e == '.') > IDN2_DOMAIN_MAX_LENGTH)\n\t    {\n\t      free (domain_u32);\n\t      return IDN2_TOO_BIG_DOMAIN;\n\t    }\n\n\t  u32_cpy (out_u32 + out_len, domain_u32, label_len);\n\t  free (domain_u32);\n\t}\n\n      out_len += label_len;\n      if (*e)\n\t{\n\t  out_u32[out_len++] = '.';\n\t  e++;\n\t}\n    }\n\n  if (output)\n    {\n      uint32_t *_out;\n\n      out_u32[out_len] = 0;\n\n      _out = u32_cpy_alloc (out_u32, out_len + 1);\n      if (!_out)\n        {\n\t  if (errno == ENOMEM)\n\t    return IDN2_MALLOC;\n\t  return IDN2_ENCODING_ERROR;\n\t}\n\n      *output = _out;\n    }\n\n  return IDN2_OK;\n}",
      "lines": 95,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "idn2_to_unicode_4z4z": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "int\nidn2_to_unicode_4z4z (const uint32_t * input, uint32_t ** output, int flags)\n{\n  uint8_t *input_u8;\n  uint32_t *output_u32;\n  size_t length;\n  int rc;\n\n  if (!input)\n    {\n      if (output)\n\t*output = NULL;\n      return IDN2_OK;\n    }\n\n  input_u8 = u32_to_u8 (input, u32_strlen(input) + 1, NULL, &length);\n  if (!input_u8)\n    {\n      if (errno == ENOMEM)\n\treturn IDN2_MALLOC;\n      return IDN2_ENCODING_ERROR;\n    }\n\n  rc = idn2_to_unicode_8z4z ((char*)input_u8, &output_u32, flags);\n  free (input_u8);\n\n  if (rc == IDN2_OK)\n    {\n      if (output)\n\t*output = output_u32;\n      else\n\tfree(output_u32);\n    }\n\n  return rc;\n}",
      "lines": 36,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "idn2_to_unicode_44i": {
      "start_point": [
        242,
        0
      ],
      "end_point": [
        278,
        1
      ],
      "content": "int\nidn2_to_unicode_44i (const uint32_t * in, size_t inlen, uint32_t * out, size_t * outlen, int flags)\n{\n  uint32_t *input_u32;\n  uint32_t *output_u32;\n  size_t len;\n  int rc;\n\n  if (!in)\n    {\n      if (outlen)\n\t*outlen = 0;\n      return IDN2_OK;\n    }\n\n  input_u32 = (uint32_t *) malloc ((inlen + 1) * sizeof(uint32_t));\n  if (!input_u32)\n    return IDN2_MALLOC;\n\n  u32_cpy (input_u32, in, inlen);\n  input_u32[inlen] = 0;\n\n  rc = idn2_to_unicode_4z4z (input_u32, &output_u32, flags);\n  free (input_u32);\n  if (rc != IDN2_OK)\n    return rc;\n\n  len = u32_strlen (output_u32);\n  if (out && outlen)\n    u32_cpy (out, output_u32, len < *outlen ? len : *outlen);\n  free (output_u32);\n\n  if (outlen)\n    *outlen = len;\n\n  return IDN2_OK;\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "idn2_to_unicode_8z8z": {
      "start_point": [
        301,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "int\nidn2_to_unicode_8z8z (const char * input, char ** output, int flags)\n{\n  uint32_t *output_u32;\n  uint8_t *output_u8;\n  size_t length;\n  int rc;\n\n  rc = idn2_to_unicode_8z4z (input, &output_u32, flags);\n  if (rc != IDN2_OK || !input)\n    return rc;\n\n  output_u8 = u32_to_u8 (output_u32, u32_strlen(output_u32) + 1, NULL, &length);\n  free (output_u32);\n\n  if (!output_u8)\n    {\n      if (errno == ENOMEM)\n\treturn IDN2_MALLOC;\n      return IDN2_ENCODING_ERROR;\n    }\n\n  if (output)\n    *output = (char *) output_u8;\n  else\n    free (output_u8);\n\n  return IDN2_OK;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "idn2_to_unicode_8zlz": {
      "start_point": [
        353,
        0
      ],
      "end_point": [
        389,
        1
      ],
      "content": "int\nidn2_to_unicode_8zlz (const char * input, char ** output, int flags)\n{\n  int rc;\n  uint8_t *output_u8, *output_l8;\n  const char *encoding;\n\n  rc = idn2_to_unicode_8z8z (input, (char **) &output_u8, flags);\n  if (rc != IDN2_OK || !input)\n    return rc;\n\n  encoding = locale_charset ();\n  output_l8 = (uint8_t*) u8_strconv_to_encoding (output_u8, encoding, iconveh_error);\n\n  if (!output_l8)\n    {\n      if (errno == ENOMEM)\n        rc = IDN2_MALLOC;\n      else\n        rc = IDN2_ENCODING_ERROR;\n\n      free(output_l8);\n    }\n  else\n    {\n      if (output)\n        *output = (char *) output_l8;\n      else\n        free (output_l8);\n\n      rc = IDN2_OK;\n    }\n\n  free (output_u8);\n\n  return rc;\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "idn2_to_unicode_lzlz": {
      "start_point": [
        414,
        0
      ],
      "end_point": [
        442,
        1
      ],
      "content": "int\nidn2_to_unicode_lzlz (const char * input, char ** output, int flags)\n{\n  uint8_t *input_l8;\n  const char *encoding;\n  int rc;\n\n  if (!input)\n    {\n      if (output)\n\t*output = NULL;\n      return IDN2_OK;\n    }\n\n  encoding = locale_charset ();\n  input_l8 = u8_strconv_from_encoding (input, encoding, iconveh_error);\n\n  if (!input_l8)\n    {\n      if (errno == ENOMEM)\n\treturn IDN2_MALLOC;\n      return IDN2_ICONV_FAIL;\n    }\n\n  rc = idn2_to_unicode_8zlz ((char*)input_l8, output, flags);\n  free (input_l8);\n\n  return rc;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/lib/error.c": {
    "idn2_strerror": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "const char *\nidn2_strerror (int rc)\n{\n  const char *p;\n\n  bindtextdomain (PACKAGE, LOCALEDIR);\n\n  switch (rc)\n    {\n    case IDN2_OK:\n      p = _(\"success\");\n      break;\n\n    case IDN2_MALLOC:\n      p = _(\"out of memory\");\n      break;\n\n    case IDN2_NO_CODESET:\n      p = _(\"could not determine locale encoding format\");\n      break;\n\n    case IDN2_ICONV_FAIL:\n      p = _(\"could not convert string to UTF-8\");\n      break;\n\n    case IDN2_ENCODING_ERROR:\n      p = _(\"string encoding error\");\n      break;\n\n    case IDN2_NFC:\n      p = _(\"string could not be NFC normalized\");\n      break;\n\n    case IDN2_PUNYCODE_BAD_INPUT:\n      p = _(\"string contains invalid punycode data\");\n      break;\n\n    case IDN2_PUNYCODE_BIG_OUTPUT:\n      p = _(\"punycode encoded data will be too large\");\n      break;\n\n    case IDN2_PUNYCODE_OVERFLOW:\n      p = _(\"punycode conversion resulted in overflow\");\n      break;\n\n    case IDN2_TOO_BIG_DOMAIN:\n      p = _(\"domain name longer than 255 characters\");\n      break;\n\n    case IDN2_TOO_BIG_LABEL:\n      p = _(\"domain label longer than 63 characters\");\n      break;\n\n    case IDN2_INVALID_ALABEL:\n      p = _(\"input A-label is not valid\");\n      break;\n\n    case IDN2_UALABEL_MISMATCH:\n      p = _(\"input A-label and U-label does not match\");\n      break;\n\n    case IDN2_NOT_NFC:\n      p = _(\"string is not in Unicode NFC format\");\n      break;\n\n    case IDN2_2HYPHEN:\n      p = _(\"string contains forbidden two hyphens pattern\");\n      break;\n\n    case IDN2_HYPHEN_STARTEND:\n      p = _(\"string start/ends with forbidden hyphen\");\n      break;\n\n    case IDN2_LEADING_COMBINING:\n      p = _(\"string contains a forbidden leading combining character\");\n      break;\n\n    case IDN2_DISALLOWED:\n      p = _(\"string contains a disallowed character\");\n      break;\n\n    case IDN2_CONTEXTJ:\n      p = _(\"string contains a forbidden context-j character\");\n      break;\n\n    case IDN2_CONTEXTJ_NO_RULE:\n      p = _(\"string contains a context-j character with null rule\");\n      break;\n\n    case IDN2_CONTEXTO:\n      p = _(\"string contains a forbidden context-o character\");\n      break;\n\n    case IDN2_CONTEXTO_NO_RULE:\n      p = _(\"string contains a context-o character with null rule\");\n      break;\n\n    case IDN2_UNASSIGNED:\n      p = _(\"string contains unassigned code point\");\n      break;\n\n    case IDN2_BIDI:\n      p = _(\"string has forbidden bi-directional properties\");\n      break;\n\n    default:\n      p = _(\"Unknown error\");\n      break;\n    }\n\n  return p;\n}",
      "lines": 112,
      "depth": 11,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nidn2_strerror (int rc)",
        "*"
      ]
    },
    "idn2_strerror_name": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "const char *\nidn2_strerror_name (int rc)\n{\n  const char *p;\n\n  switch (rc)\n    {\n    case IDN2_OK:\n      p = ERR2STR (IDN2_OK);\n      break;\n\n    case IDN2_MALLOC:\n      p = ERR2STR (IDN2_MALLOC);\n      break;\n\n    case IDN2_NO_CODESET:\n      p = ERR2STR (IDN2_NO_NODESET);\n      break;\n\n    case IDN2_ICONV_FAIL:\n      p = ERR2STR (IDN2_ICONV_FAIL);\n      break;\n\n    case IDN2_ENCODING_ERROR:\n      p = ERR2STR (IDN2_ENCODING_ERROR);\n      break;\n\n    case IDN2_NFC:\n      p = ERR2STR (IDN2_NFC);\n      break;\n\n    case IDN2_PUNYCODE_BAD_INPUT:\n      p = ERR2STR (IDN2_PUNYCODE_BAD_INPUT);\n      break;\n\n    case IDN2_PUNYCODE_BIG_OUTPUT:\n      p = ERR2STR (IDN2_PUNYCODE_BIG_OUTPUT);\n      break;\n\n    case IDN2_PUNYCODE_OVERFLOW:\n      p = ERR2STR (IDN2_PUNYCODE_OVERFLOW);\n      break;\n\n    case IDN2_TOO_BIG_DOMAIN:\n      p = ERR2STR (IDN2_TOO_BIG_DOMAIN);\n      break;\n\n    case IDN2_TOO_BIG_LABEL:\n      p = ERR2STR (IDN2_TOO_BIG_LABEL);\n      break;\n\n    case IDN2_INVALID_ALABEL:\n      p = ERR2STR (IDN2_INVALID_ALABEL);\n      break;\n\n    case IDN2_UALABEL_MISMATCH:\n      p = ERR2STR (IDN2_UALABEL_MISMATCH);\n      break;\n\n    case IDN2_NOT_NFC:\n      p = ERR2STR (IDN2_NOT_NFC);\n      break;\n\n    case IDN2_2HYPHEN:\n      p = ERR2STR (IDN2_2HYPHEN);\n      break;\n\n    case IDN2_HYPHEN_STARTEND:\n      p = ERR2STR (IDN2_HYPHEN_STARTEND);\n      break;\n\n    case IDN2_LEADING_COMBINING:\n      p = ERR2STR (IDN2_LEADING_COMBINING);\n      break;\n\n    case IDN2_DISALLOWED:\n      p = ERR2STR (IDN2_DISALLOWED);\n      break;\n\n    case IDN2_CONTEXTJ:\n      p = ERR2STR (IDN2_CONTEXTJ);\n      break;\n\n    case IDN2_CONTEXTJ_NO_RULE:\n      p = ERR2STR (IDN2_CONTEXTJ_NO_RULE);\n      break;\n\n    case IDN2_CONTEXTO:\n      p = ERR2STR (IDN2_CONTEXTO);\n      break;\n\n    case IDN2_CONTEXTO_NO_RULE:\n      p = ERR2STR (IDN2_CONTEXTO_NO_RULE);\n      break;\n\n    case IDN2_UNASSIGNED:\n      p = ERR2STR (IDN2_UNASSIGNED);\n      break;\n\n    case IDN2_BIDI:\n      p = ERR2STR (IDN2_BIDI);\n      break;\n\n    default:\n      p = \"IDN2_UNKNOWN\";\n      break;\n    }\n\n  return p;\n}",
      "lines": 110,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nidn2_strerror_name (int rc)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/lib/free.c": {
    "idn2_free": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\nidn2_free (void *ptr)\n{\n  free (ptr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "libidn/libidn2-2.0.5/lib/gentr46map.c": {
    "_nextField": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static char *\n_nextField (char **line)\n{\n  char *s = *line, *e;\n\n  if (!*s)\n    return NULL;\n\n  if (!(e = strpbrk (s, \";#\")))\n    {\n      e = *line += strlen (s);\n    }\n  else\n    {\n      *line = e + (*e == ';');\n      *e = 0;\n    }\n\n  // trim leading and trailing whitespace\n  while (isspace (*s))\n    s++;\n  while (e > s && isspace (e[-1]))\n    *--e = 0;\n\n  return s;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\n_nextField (char **line)",
        "*"
      ]
    },
    "_scan_file": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "static int\n_scan_file (const char *fname, int (*scan) (char *))\n{\n  FILE *fp = fopen (fname, \"r\");\n  char buf[1024], *linep;\n  ssize_t buflen;\n  int ret = 0;\n\n  if (!fp)\n    {\n      fprintf (stderr, \"Failed to open %s\\n\", fname);\n      return -1;\n    }\n\n  while (fgets(buf, sizeof(buf), fp))\n    {\n      linep = buf;\n      buflen = strlen(buf);\n\n      // strip off \\r\\n\n      while (buflen > 0 && (buf[buflen] == '\\n' || buf[buflen] == '\\r'))\n\tbuf[--buflen] = 0;\n\n      while (isspace (*linep))\n\tlinep++;\t\t// ignore leading whitespace\n\n      if (!*linep || *linep == '#')\n\tcontinue;\t\t// skip empty lines and comments\n\n      if ((ret = scan (linep)))\n\tbreak;\n    }\n\n  fclose (fp);\n\n  return ret;\n}",
      "lines": 37,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_u32_stream_len": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "static size_t\n_u32_stream_len (uint32_t * src, size_t len)\n{\n  unsigned it;\n  size_t n = 0;\n\n/*\n1 byte: 0-0x7f -> 0xxxxxxx\n2 bytes: 0x80-0x3fff ->1xxxxxxx 0xxxxxxx\n3 bytes: 0x4000-0x1fffff ->1xxxxxxx 1xxxxxxx 0xxxxxxx\n4 bytes: 0x200000-0xFFFFFFF -> 1xxxxxxx 1xxxxxxx 1xxxxxxx 0xxxxxxx\n5 bytes: 0x10000000->0xFFFFFFFF -> 1xxxxxxx 1xxxxxxx 1xxxxxxx 1xxxxxxx\n*/\n  for (it = 0; it < len; it++)\n    {\n      uint32_t cp = src[it];\n\n      if (cp <= 0x7f)\n\tn += 1;\n      else if (cp <= 0x3fff)\n\tn += 2;\n      else if (cp <= 0x1fffff)\n\tn += 3;\n      else if (cp <= 0xFFFFFFF)\n\tn += 4;\n      else\n\tn += 5;\n    }\n\n  return n;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "_u32_to_stream": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "static size_t\n_u32_to_stream (uint8_t * dst, size_t dst_size, uint32_t * src, size_t len)\n{\n  unsigned it;\n  size_t n = 0;\n\n  n = _u32_stream_len (src, len);\n\n  if (!dst)\n    return n;\n\n  if (dst_size < n)\n    return 0;\n\n  for (it = 0; it < len; it++)\n    {\n      uint32_t cp = src[it];\n\n      if (cp <= 0x7f)\n\t*dst++ = cp & 0x7F;\n      else if (cp <= 0x3fff)\n\t{\n\t  *dst++ = 0x80 | ((cp >> 7) & 0x7F);\n\t  *dst++ = cp & 0x7F;\n\t}\n      else if (cp <= 0x1fffff)\n\t{\n\t  *dst++ = 0x80 | ((cp >> 14) & 0x7F);\n\t  *dst++ = 0x80 | ((cp >> 7) & 0x7F);\n\t  *dst++ = cp & 0x7F;\n\t}\n      else if (cp <= 0xFFFFFFF)\n\t{\n\t  *dst++ = 0x80 | ((cp >> 21) & 0x7F);\n\t  *dst++ = 0x80 | ((cp >> 14) & 0x7F);\n\t  *dst++ = 0x80 | ((cp >> 7) & 0x7F);\n\t  *dst++ = cp & 0x7F;\n\t}\n      else\n\t{\n\t  *dst++ = 0x80 | ((cp >> 28) & 0x7F);\n\t  *dst++ = 0x80 | ((cp >> 21) & 0x7F);\n\t  *dst++ = 0x80 | ((cp >> 14) & 0x7F);\n\t  *dst++ = 0x80 | ((cp >> 7) & 0x7F);\n\t  *dst++ = cp & 0x7F;\n\t}\n    }\n\n  return n;\n}",
      "lines": 50,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "_copy_from_stream": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        228,
        1
      ],
      "content": "static void\n_copy_from_stream (uint32_t * dst, const uint8_t * src, size_t n)\n{\n  uint32_t cp = 0;\n\n  for (; n; src++)\n    {\n      cp = (cp << 7) | (*src & 0x7F);\n      if ((*src & 0x80) == 0)\n\t{\n\t  *dst++ = cp;\n\t  cp = 0;\n\t  n--;\n\t}\n    }\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_IdnaMappings": {
      "start_point": [
        230,
        0
      ],
      "end_point": [
        343,
        1
      ],
      "content": "static int\nread_IdnaMappings (char *linep)\n{\n  IDNAMap_gen *map = &idna_map[map_pos];\n  char *flag, *codepoint, *mapping;\n  int n;\n\n  codepoint = _nextField (&linep);\n  flag = _nextField (&linep);\n  mapping = _nextField (&linep);\n\n  if ((n = sscanf (codepoint, \"%X..%X\", &map->cp1, &map->cp2)) == 1)\n    {\n      map->cp2 = map->cp1;\n    }\n  else if (n != 2)\n    {\n      printf (\"Failed to scan mapping codepoint '%s'\\n\", codepoint);\n      return -1;\n    }\n\n  if (map->cp1 > map->cp2)\n    {\n      printf (\"Invalid codepoint range '%s'\\n\", codepoint);\n      return -1;\n    }\n\n  if (map_pos && map->cp1 <= idna_map[map_pos - 1].cp2)\n    {\n      printf (\"Mapping codepoints out of order '%s'\\n\", codepoint);\n      return -1;\n    }\n\n  if (!strcmp (flag, \"valid\"))\n    map->flags |= TR46_FLG_VALID;\n  else if (!strcmp (flag, \"mapped\"))\n    map->flags |= TR46_FLG_MAPPED;\n  else if (!strcmp (flag, \"disallowed\"))\n    map->flags |= TR46_FLG_DISALLOWED;\n  else if (!strcmp (flag, \"ignored\"))\n    map->flags |= TR46_FLG_IGNORED;\n  else if (!strcmp (flag, \"deviation\"))\n    map->flags |= TR46_FLG_DEVIATION;\n  else if (!strcmp (flag, \"disallowed_STD3_mapped\"))\n    map->flags |= TR46_FLG_DISALLOWED_STD3_MAPPED;\n  else if (!strcmp (flag, \"disallowed_STD3_valid\"))\n    map->flags |= TR46_FLG_DISALLOWED_STD3_VALID;\n  else\n    {\n      printf (\"Unknown flag '%s'\\n\", flag);\n      return -1;\n    }\n\n  if (mapping && *mapping)\n    {\n      uint32_t cp, tmp[20] = { 0 }, tmp2[20] = { 0 };\n      int pos;\n\n      while ((n = sscanf (mapping, \" %X%n\", &cp, &pos)) == 1)\n\t{\n\t  if (mapdata_pos >= countof (genmapdata))\n\t    {\n\t      printf (\"genmapdata too small - increase and retry\\n\");\n\t      break;\n\t    }\n\n\t  if (map->nmappings == 0)\n\t    {\n\t      map->offset = mapdata_pos;\n\t      if (map->offset != mapdata_pos)\n\t\tprintf (\"offset overflow (%zu)\\n\", mapdata_pos);\n\t    }\n\n\t  tmp[map->nmappings] = cp;\n\t  mapdata_pos += _u32_to_stream (genmapdata + mapdata_pos, 5, &cp, 1);\n\t  map->nmappings++;\n\t  mapping += pos;\n\t}\n\n      /* selftest */\n      _copy_from_stream (tmp2, genmapdata + map->offset, map->nmappings);\n      for (pos = 0; pos < map->nmappings; pos++)\n\tif (tmp[pos] != tmp2[pos])\n\t  abort ();\n    }\n  else if (map->flags &\n\t   (TR46_FLG_MAPPED | TR46_FLG_DISALLOWED_STD3_MAPPED |\n\t    TR46_FLG_DEVIATION))\n    {\n      if (map->cp1 != 0x200C && map->cp1 != 0x200D)\t/* ZWNJ and ZWJ */\n\tprintf (\"Missing mapping for '%s'\\n\", codepoint);\n    }\n\n  if (map_pos && map->nmappings == 0)\n    {\n      /* merge with previous if possible */\n      IDNAMap_gen *prev = &idna_map[map_pos - 1];\n      if (prev->cp2 + 1 == map->cp1\n\t  && prev->nmappings == 0 && prev->flags == map->flags)\n\t{\n\t  prev->cp2 = map->cp2;\n\t  memset (map, 0, sizeof (*map));\t/* clean up */\n\t  return 0;\n\t}\n    }\n\n  if (++map_pos >= countof (idna_map))\n    {\n      printf (\"Internal map size too small\\n\");\n      return -1;\n    }\n\n  return 0;\n}",
      "lines": 114,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_compare_map": {
      "start_point": [
        345,
        0
      ],
      "end_point": [
        353,
        1
      ],
      "content": "static int\n_compare_map (IDNAMap_gen * m1, IDNAMap_gen * m2)\n{\n  if (m1->cp1 < m2->cp1)\n    return -1;\n  if (m1->cp1 > m2->cp2)\n    return 1;\n  return 0;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "read_NFCQC": {
      "start_point": [
        355,
        0
      ],
      "end_point": [
        402,
        1
      ],
      "content": "static int\nread_NFCQC (char *linep)\n{\n  NFCQCMap *map = &nfcqc_map[nfcqc_pos];\n  char *codepoint, *type, *check;\n  int n;\n\n  codepoint = _nextField (&linep);\n  type = _nextField (&linep);\n  check = _nextField (&linep);\n\n  if (!type || strcmp (type, \"NFC_QC\"))\n    return 0;\n\n  if ((n = sscanf (codepoint, \"%X..%X\", &map->cp1, &map->cp2)) == 1)\n    {\n      map->cp2 = map->cp1;\n    }\n  else if (n != 2)\n    {\n      printf (\"Failed to scan mapping codepoint '%s'\\n\", codepoint);\n      return -1;\n    }\n\n  if (map->cp1 > map->cp2)\n    {\n      printf (\"Invalid codepoint range '%s'\\n\", codepoint);\n      return -1;\n    }\n\n  if (*check == 'N')\n    map->check = 1;\n  else if (*check == 'M')\n    map->check = 2;\n  else\n    {\n      printf (\"NFQQC: Unknown value '%s'\\n\", check);\n      return -1;\n    }\n\n  if (++nfcqc_pos >= countof (nfcqc_map))\n    {\n      printf (\"Internal NFCQC map size too small\\n\");\n      return -1;\n    }\n\n  return 0;\n}",
      "lines": 48,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_compare_map_by_maplen": {
      "start_point": [
        404,
        0
      ],
      "end_point": [
        414,
        1
      ],
      "content": "static int\n_compare_map_by_maplen (IDNAMap_gen * m1, IDNAMap_gen * m2)\n{\n  if (m1->nmappings != m2->nmappings)\n    return m2->nmappings - m1->nmappings;\n  if (m1->cp1 < m2->cp1)\n    return -1;\n  if (m1->cp1 > m2->cp2)\n    return 1;\n  return 0;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_u8_memmem": {
      "start_point": [
        435,
        0
      ],
      "end_point": [
        450,
        1
      ],
      "content": "static uint8_t *\n_u8_memmem (uint8_t * haystack, size_t hlen, uint8_t * needle, size_t nlen)\n{\n  uint8_t *p;\n\n  if (nlen == 0)\n    return haystack;\n\n  for (p = haystack; hlen >= nlen; p++, hlen--)\n    {\n      if (*p == *needle && (nlen == 1 || memcmp (p, needle, nlen) == 0))\n\treturn p;\n    }\n\n  return NULL;\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "uint8_t",
        "*\n_u8_memmem (uint8_t * haystack, size_t hlen, uint8_t * needle, size_t nlen)",
        "*"
      ]
    },
    "_u32_cp_stream_len": {
      "start_point": [
        452,
        0
      ],
      "end_point": [
        464,
        1
      ],
      "content": "static size_t\n_u32_cp_stream_len (const uint8_t * stream, size_t ncp)\n{\n  const uint8_t *end;\n\n  for (end = stream; ncp; end++)\n    {\n      if ((*end & 0x80) == 0)\n\tncp--;\n    }\n\n  return end - stream;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "_compact_idna_map": {
      "start_point": [
        471,
        0
      ],
      "end_point": [
        513,
        1
      ],
      "content": "static void\n_compact_idna_map (void)\n{\n  unsigned it;\n\n  /* sort into 'longest mappings first' */\n  qsort (idna_map, map_pos, sizeof (IDNAMap_gen),\n\t (int (*)(const void *, const void *)) _compare_map_by_maplen);\n\n  uint8_t *data = calloc (sizeof (uint8_t), mapdata_pos), *p;\n  size_t ndata = 0, slen;\n\n  if (data == NULL)\n    abort();\n\n  for (it = 0; it < map_pos; it++)\n    {\n      IDNAMap_gen *map = idna_map + it;\n\n      if (!map->nmappings)\n\tcontinue;\n\n      slen = _u32_cp_stream_len (genmapdata + map->offset, map->nmappings);\n\n      if ((p = _u8_memmem (data, ndata, genmapdata + map->offset, slen)))\n\t{\n\t  map->offset = p - data;\n\t  continue;\n\t}\n\n      memcpy (data + ndata, genmapdata + map->offset, slen);\n      map->offset = ndata;\n      ndata += slen;\n    }\n\n  memcpy (genmapdata, data, ndata);\n  mapdata_pos = ndata;\n  free (data);\n\n  /* sort into 'lowest codepoint first' */\n  qsort (idna_map, map_pos, sizeof (IDNAMap_gen),\n\t (int (*)(const void *, const void *)) _compare_map);\n}",
      "lines": 43,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_combine_idna_flags": {
      "start_point": [
        515,
        0
      ],
      "end_point": [
        558,
        1
      ],
      "content": "static void\n_combine_idna_flags (void)\n{\n  unsigned it, it2;\n\n  /* There are not many different combinations of flags */\n  for (it = 0; it < map_pos; it++)\n    {\n      IDNAMap_gen *map = idna_map + it;\n      int found = 0;\n\n      for (it2 = 0; it2 < flag_combinations && !found; it2++)\n\t{\n\t  if (flag_combination[it2] == map->flags)\n\t    {\n\t      map->flag_index = it2;\n\t      found = 1;\n\t    }\n\t}\n\n      if (!found)\n\t{\n\t  if (flag_combinations >= countof (flag_combination))\n\t    {\n\t      fprintf (stderr,\n\t\t       \"flag_combination[] too small - increase and retry\\n\");\n\t      exit (EXIT_FAILURE);\n\t    }\n\t  map->flag_index = flag_combinations++;\n\t  flag_combination[map->flag_index] = map->flags;\n\t}\n    }\n  for (it = 0; it < map_pos; it++)\n    {\n      IDNAMap_gen *map = idna_map + it;\n\n      if (map->flags != flag_combination[map->flag_index])\n\t{\n\t  fprintf (stderr, \"Flags do not for 0x%X-0x%X)\\n\", map->cp1,\n\t\t   map->cp2);\n\t  exit (EXIT_FAILURE);\n\t}\n    }\n}",
      "lines": 44,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_print_tr46_map": {
      "start_point": [
        560,
        0
      ],
      "end_point": [
        620,
        1
      ],
      "content": "static int\n_print_tr46_map (uint32_t min, uint32_t max, int do_print)\n{\n  unsigned it;\n  int it2, entries = 0;\n\n  for (it = 0; it < map_pos; it++)\n    {\n      const IDNAMap_gen *map = idna_map + it;\n      uint32_t cp2, cp1 = map->cp1, value, range;\n      int n;\n\n      if (cp1 < min)\n\tcontinue;\n\n      if (cp1 > max)\n\tbreak;\n\n      n = (map->cp2 - cp1) / 0x10000;\n\n      for (it2 = 0; it2 <= n; it2++, cp1 = cp2 + 1)\n\t{\n\t  entries++;\n\n\t  if (it2 == n)\n\t    cp2 = map->cp2;\n\t  else\n\t    cp2 = cp1 + 0xFFFF;\n\n\t  if (!do_print)\n\t    continue;\n\n\t  range = cp2 - cp1;\n\t  value =\n\t    (((map->nmappings << 14) | map->offset) << 3) | map->flag_index;\n\n\t  if (max == 0xFF)\n\t    printf (\"0x%X,0x%X,\", cp1 & 0xFF, range & 0xFF);\n\t  else if (max == 0xFFFF)\n\t    printf (\"0x%X,0x%X,0x%X,0x%X,\",\n\t\t    (cp1 >> 8) & 0xFF, cp1 & 0xFF,\n\t\t    (range >> 8) & 0xFF, range & 0xFF);\n\t  else if (max == 0xFFFFFF)\n\t    printf (\"0x%X,0x%X,0x%X,0x%X,0x%X,\",\n\t\t    (cp1 >> 16) & 0xFF, (cp1 >> 8) & 0xFF, cp1 & 0xFF,\n\t\t    (range >> 8) & 0xFF, range & 0xFF);\n\n\t  printf (\"0x%X,0x%X,0x%X,\\n\",\n\t\t  (value >> 16) & 0xFF, (value >> 8) & 0xFF, value & 0xFF);\n\t}\n    }\n\n  if (max == 0xFF)\n    return entries * 5;\n  if (max == 0xFFFF)\n    return entries * 7;\n  if (max == 0xFFFFFF)\n    return entries * 8;\n\n  return 0;\n}",
      "lines": 61,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        622,
        0
      ],
      "end_point": [
        683,
        1
      ],
      "content": "int\nmain (void)\n{\n  unsigned it;\n\n  // read IDNA mappings\n  if (_scan_file (SRCDIR \"/IdnaMappingTable.txt\", read_IdnaMappings))\n    return 1;\n\n  _compact_idna_map ();\n  _combine_idna_flags ();\n\n  // read NFC QuickCheck table\n  if (_scan_file (SRCDIR \"/DerivedNormalizationProps.txt\", read_NFCQC))\n    return 1;\n\n  qsort (nfcqc_map, nfcqc_pos, sizeof (NFCQCMap),\n\t (int (*)(const void *, const void *)) _compare_map);\n\n  printf (\"/* This file is automatically generated.  DO NOT EDIT! */\\n\\n\");\n  printf (\"#include <stdint.h>\\n\");\n  printf (\"#include \\\"tr46map.h\\\"\\n\\n\");\n\n  printf (\"static const uint8_t idna_flags[%u] =\\n{\", flag_combinations);\n  for (it = 0; it < flag_combinations; it++)\n    {\n      printf (\"0x%X,\", flag_combination[it]);\n    }\n  printf (\"};\\n\\n\");\n\n  printf (\"static const uint8_t idna_map_8[%d] = {\\n\",\n\t  _print_tr46_map (0x0, 0xFF, 0));\n  _print_tr46_map (0x0, 0xFF, 1);\n  printf (\"};\\n\\n\");\n\n  printf (\"static const uint8_t idna_map_16[%d] = {\\n\",\n\t  _print_tr46_map (0x100, 0xFFFF, 0));\n  _print_tr46_map (0x100, 0xFFFF, 1);\n  printf (\"};\\n\\n\");\n\n  printf (\"static const uint8_t idna_map_24[%d] = {\\n\",\n\t  _print_tr46_map (0x10000, 0xFFFFFF, 0));\n  _print_tr46_map (0x10000, 0xFFFFFF, 1);\n  printf (\"};\\n\\n\");\n\n  printf (\"static const uint8_t mapdata[%zu] = {\\n\", mapdata_pos);\n  for (it = 0; it < mapdata_pos; it++)\n    {\n      printf (\"0x%02X,%s\", genmapdata[it], it % 16 == 15 ? \"\\n\" : \"\");\n    }\n  printf (\"};\\n\\n\");\n\n  printf (\"static const NFCQCMap nfcqc_map[%zu] = {\\n\", nfcqc_pos);\n  for (it = 0; it < nfcqc_pos; it++)\n    {\n      NFCQCMap *map = nfcqc_map + it;\n      printf (\"{0x%X,0x%X,%d},\\n\", map->cp1, map->cp2, map->check);\n    }\n  printf (\"};\\n\");\n\n  return 0;\n}",
      "lines": 62,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/lib/idn2.h": {},
  "libidn/libidn2-2.0.5/lib/idna.c": {
    "_isNFC": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "static int\n_isNFC (uint32_t * label, size_t len)\n{\n  int lastCanonicalClass = 0;\n  int result = 1;\n  size_t it;\n\n  for (it = 0; it < len; it++)\n    {\n      uint32_t ch = label[it];\n\n      // supplementary code point\n      if (ch >= 0x10000)\n\tit++;\n\n      int canonicalClass = uc_combining_class (ch);\n      if (lastCanonicalClass > canonicalClass && canonicalClass != 0)\n\treturn 0;\n\n      NFCQCMap *map = get_nfcqc_map (ch);\n      if (map)\n\t{\n\t  if (map->check)\n\t    return 0;\n\t  result = -1;\n\t}\n\n      lastCanonicalClass = canonicalClass;\n    }\n\n  return result;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_idn2_u8_to_u32_nfc": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "int\n_idn2_u8_to_u32_nfc (const uint8_t * src, size_t srclen,\n\t\t     uint32_t ** out, size_t * outlen, int nfc)\n{\n  uint32_t *p;\n  size_t plen;\n\n  p = u8_to_u32 (src, srclen, NULL, &plen);\n  if (p == NULL)\n    {\n      if (errno == ENOMEM)\n\treturn IDN2_MALLOC;\n      return IDN2_ENCODING_ERROR;\n    }\n\n  if (nfc && !_isNFC (p, plen))\n    {\n      size_t tmplen;\n      uint32_t *tmp = u32_normalize (UNINORM_NFC, p, plen, NULL, &tmplen);\n      free (p);\n      if (tmp == NULL)\n\t{\n\t  if (errno == ENOMEM)\n\t    return IDN2_MALLOC;\n\t  return IDN2_NFC;\n\t}\n\n      p = tmp;\n      plen = tmplen;\n    }\n\n  *out = p;\n  *outlen = plen;\n  return IDN2_OK;\n}",
      "lines": 35,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_idn2_ascii_p": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "bool\n_idn2_ascii_p (const uint8_t * src, size_t srclen)\n{\n  size_t i;\n\n  for (i = 0; i < srclen; i++)\n    if (src[i] >= 0x80)\n      return false;\n\n  return true;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "_idn2_label_test": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "int\n_idn2_label_test (int what, const uint32_t * label, size_t llen)\n{\n  if (what & TEST_NFC)\n    {\n      size_t plen;\n      uint32_t *p = u32_normalize (UNINORM_NFC, label, llen,\n\t\t\t\t   NULL, &plen);\n      int ok;\n      if (p == NULL)\n\t{\n\t  if (errno == ENOMEM)\n\t    return IDN2_MALLOC;\n\t  return IDN2_NFC;\n\t}\n      ok = llen == plen && memcmp (label, p, plen * sizeof (*label)) == 0;\n      free (p);\n      if (!ok)\n\treturn IDN2_NOT_NFC;\n    }\n\n  if (what & TEST_2HYPHEN)\n    {\n      if (llen >= 4 && label[2] == '-' && label[3] == '-')\n\treturn IDN2_2HYPHEN;\n    }\n\n  if (what & TEST_HYPHEN_STARTEND)\n    {\n      if (llen > 0 && (label[0] == '-' || label[llen - 1] == '-'))\n\treturn IDN2_HYPHEN_STARTEND;\n    }\n\n  if (what & TEST_LEADING_COMBINING)\n    {\n      if (llen > 0 && uc_is_general_category (label[0], UC_CATEGORY_M))\n\treturn IDN2_LEADING_COMBINING;\n    }\n\n  if (what & TEST_DISALLOWED)\n    {\n      size_t i;\n      for (i = 0; i < llen; i++)\n\tif (_idn2_disallowed_p (label[i]))\n\t  {\n\t    if ((what & (TEST_TRANSITIONAL | TEST_NONTRANSITIONAL)) &&\n\t\t(what & TEST_ALLOW_STD3_DISALLOWED))\n\t    {\n\t      IDNAMap map;\n\t      get_idna_map (label[i], &map);\n\t      if (map_is (&map, TR46_FLG_DISALLOWED_STD3_VALID) ||\n\t\t  map_is (&map, TR46_FLG_DISALLOWED_STD3_MAPPED))\n\t      continue;\n\n\t    }\n\n\t    return IDN2_DISALLOWED;\n\t  }\n    }\n\n  if (what & TEST_CONTEXTJ)\n    {\n      size_t i;\n      for (i = 0; i < llen; i++)\n\tif (_idn2_contextj_p (label[i]))\n\t  return IDN2_CONTEXTJ;\n    }\n\n  if (what & TEST_CONTEXTJ_RULE)\n    {\n      size_t i;\n      int rc;\n\n      for (i = 0; i < llen; i++)\n\t{\n\t  rc = _idn2_contextj_rule (label, llen, i);\n\t  if (rc != IDN2_OK)\n\t    return rc;\n\t}\n    }\n\n  if (what & TEST_CONTEXTO)\n    {\n      size_t i;\n      for (i = 0; i < llen; i++)\n\tif (_idn2_contexto_p (label[i]))\n\t  return IDN2_CONTEXTO;\n    }\n\n  if (what & TEST_CONTEXTO_WITH_RULE)\n    {\n      size_t i;\n      for (i = 0; i < llen; i++)\n\tif (_idn2_contexto_p (label[i])\n\t    && !_idn2_contexto_with_rule (label[i]))\n\t  return IDN2_CONTEXTO_NO_RULE;\n    }\n\n  if (what & TEST_CONTEXTO_RULE)\n    {\n      size_t i;\n      int rc;\n\n      for (i = 0; i < llen; i++)\n\t{\n\t  rc = _idn2_contexto_rule (label, llen, i);\n\t  if (rc != IDN2_OK)\n\t    return rc;\n\t}\n    }\n\n  if (what & TEST_UNASSIGNED)\n    {\n      size_t i;\n      for (i = 0; i < llen; i++)\n\tif (_idn2_unassigned_p (label[i]))\n\t  return IDN2_UNASSIGNED;\n    }\n\n  if (what & TEST_BIDI)\n    {\n      int rc = _idn2_bidi (label, llen);\n      if (rc != IDN2_OK)\n\treturn rc;\n    }\n\n  if (what & (TEST_TRANSITIONAL | TEST_NONTRANSITIONAL))\n    {\n      size_t i;\n      int transitional = what & TEST_TRANSITIONAL;\n\n      /* TR46: 4. The label must not contain a U+002E ( . ) FULL STOP */\n      for (i = 0; i < llen; i++)\n\tif (label[i] == 0x002E)\n\t  return IDN2_DOT_IN_LABEL;\n\n      /* TR46: 6. Each code point in the label must only have certain status\n       * values according to Section 5, IDNA Mapping Table:\n       *    a. For Transitional Processing, each value must be valid.\n       *    b. For Nontransitional Processing, each value must be either valid or deviation. */\n      for (i = 0; i < llen; i++)\n\t{\n\t  IDNAMap map;\n\n\t  get_idna_map (label[i], &map);\n\n\t  if (map_is (&map, TR46_FLG_VALID) ||\n\t      (!transitional && map_is (&map, TR46_FLG_DEVIATION)))\n\t    continue;\n\n\t  if (what & TEST_ALLOW_STD3_DISALLOWED &&\n\t      (map_is (&map, TR46_FLG_DISALLOWED_STD3_VALID) ||\n\t       map_is (&map, TR46_FLG_DISALLOWED_STD3_MAPPED)))\n\t    continue;\n\n\t  return transitional ? IDN2_INVALID_TRANSITIONAL :\n\t    IDN2_INVALID_NONTRANSITIONAL;\n\t}\n    }\n\n  return IDN2_OK;\n}",
      "lines": 162,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/lib/idna.h": {},
  "libidn/libidn2-2.0.5/lib/lookup.c": {
    "set_default_flags": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static int set_default_flags(int *flags)\n{\n  if (((*flags) & IDN2_TRANSITIONAL) && ((*flags) & IDN2_NONTRANSITIONAL))\n    return IDN2_INVALID_FLAGS;\n\n  if (((*flags) & (IDN2_TRANSITIONAL|IDN2_NONTRANSITIONAL)) && ((*flags) & IDN2_NO_TR46))\n    return IDN2_INVALID_FLAGS;\n\n  if (!((*flags) & (IDN2_NO_TR46|IDN2_TRANSITIONAL)))\n    *flags |= IDN2_NONTRANSITIONAL;\n\n  return IDN2_OK;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "label": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "static int\nlabel (const uint8_t * src, size_t srclen, uint8_t * dst, size_t * dstlen,\n       int flags)\n{\n  size_t plen;\n  uint32_t *p;\n  int rc;\n  size_t tmpl;\n\n  if (_idn2_ascii_p (src, srclen))\n    {\n      if (flags & IDN2_ALABEL_ROUNDTRIP)\n\t/* FIXME implement this MAY:\n\n\t   If the input to this procedure appears to be an A-label\n\t   (i.e., it starts in \"xn--\", interpreted\n\t   case-insensitively), the lookup application MAY attempt to\n\t   convert it to a U-label, first ensuring that the A-label is\n\t   entirely in lowercase (converting it to lowercase if\n\t   necessary), and apply the tests of Section 5.4 and the\n\t   conversion of Section 5.5 to that form. */\n\treturn IDN2_INVALID_FLAGS;\n\n      if (srclen > IDN2_LABEL_MAX_LENGTH)\n\treturn IDN2_TOO_BIG_LABEL;\n      if (srclen > *dstlen)\n\treturn IDN2_TOO_BIG_DOMAIN;\n\n      memcpy (dst, src, srclen);\n      *dstlen = srclen;\n      return IDN2_OK;\n    }\n\n  rc = _idn2_u8_to_u32_nfc (src, srclen, &p, &plen, flags & IDN2_NFC_INPUT);\n  if (rc != IDN2_OK)\n    return rc;\n\n  if (!(flags & IDN2_TRANSITIONAL))\n    {\n      rc = _idn2_label_test(\n\tTEST_NFC |\n\tTEST_2HYPHEN |\n\tTEST_LEADING_COMBINING |\n\tTEST_DISALLOWED |\n\tTEST_CONTEXTJ_RULE |\n\tTEST_CONTEXTO_WITH_RULE |\n\tTEST_UNASSIGNED | TEST_BIDI |\n\t((flags & IDN2_NONTRANSITIONAL) ? TEST_NONTRANSITIONAL : 0) |\n\t((flags & IDN2_USE_STD3_ASCII_RULES) ? 0 : TEST_ALLOW_STD3_DISALLOWED),\n\tp, plen);\n\n      if (rc != IDN2_OK)\n\t{\n\t  free(p);\n\t  return rc;\n\t}\n    }\n\n  dst[0] = 'x';\n  dst[1] = 'n';\n  dst[2] = '-';\n  dst[3] = '-';\n\n  tmpl = *dstlen - 4;\n  rc = _idn2_punycode_encode (plen, p, &tmpl, (char *) dst + 4);\n  free (p);\n  if (rc != IDN2_OK)\n    return rc;\n\n  *dstlen = 4 + tmpl;\n\n  return IDN2_OK;\n}",
      "lines": 73,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_tr46": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        358,
        1
      ],
      "content": "static int\n_tr46 (const uint8_t * domain_u8, uint8_t ** out, int flags)\n{\n  size_t len, it;\n  uint32_t *domain_u32;\n  int err = IDN2_OK, rc;\n  int transitional = 0;\n  int test_flags;\n\n  if (flags & IDN2_TRANSITIONAL)\n    transitional = 1;\n\n  /* convert UTF-8 to UTF-32 */\n  if (!(domain_u32 =\n       u8_to_u32 (domain_u8, u8_strlen (domain_u8) + 1, NULL, &len)))\n    {\n      if (errno == ENOMEM)\n\treturn IDN2_MALLOC;\n      return IDN2_ENCODING_ERROR;\n    }\n\n  size_t len2 = 0;\n  for (it = 0; it < len - 1; it++)\n    {\n      IDNAMap map;\n\n      get_idna_map (domain_u32[it], &map);\n\n      if (map_is (&map, TR46_FLG_DISALLOWED))\n\t{\n\t  if (domain_u32[it])\n\t    {\n\t      free (domain_u32);\n\t      return IDN2_DISALLOWED;\n\t    }\n\t  len2++;\n\t}\n      else if (map_is (&map, TR46_FLG_MAPPED))\n\t{\n\t  len2 += map.nmappings;\n\t}\n      else if (map_is (&map, TR46_FLG_VALID))\n\t{\n\t  len2++;\n\t}\n      else if (map_is (&map, TR46_FLG_IGNORED))\n\t{\n\t  continue;\n\t}\n      else if (map_is (&map, TR46_FLG_DEVIATION))\n\t{\n\t  if (transitional)\n\t    {\n\t      len2 += map.nmappings;\n\t    }\n\t  else\n\t    len2++;\n\t}\n      else if (!(flags & IDN2_USE_STD3_ASCII_RULES))\n        {\n\t  if (map_is (&map, TR46_FLG_DISALLOWED_STD3_VALID))\n\t    {\n\t      /* valid because UseSTD3ASCIIRules=false, see #TR46 5 */\n\t      len2++;\n\t    }\n\t  else if (map_is (&map, TR46_FLG_DISALLOWED_STD3_MAPPED))\n\t    {\n\t      /* mapped because UseSTD3ASCIIRules=false, see #TR46 5 */\n\t      len2 += map.nmappings;\n\t    }\n        }\n    }\n\n  uint32_t *tmp = (uint32_t *) malloc ((len2 + 1) * sizeof (uint32_t));\n  if (!tmp)\n    {\n      free (domain_u32);\n      return IDN2_MALLOC;\n    }\n\n  len2 = 0;\n  for (it = 0; it < len - 1; it++)\n    {\n      uint32_t c = domain_u32[it];\n      IDNAMap map;\n\n      get_idna_map (c, &map);\n\n      if (map_is (&map, TR46_FLG_DISALLOWED))\n\t{\n\t  tmp[len2++] = c;\n\t}\n      else if (map_is (&map, TR46_FLG_MAPPED))\n\t{\n\t  len2 += get_map_data (tmp + len2, &map);\n\t}\n      else if (map_is (&map, TR46_FLG_VALID))\n\t{\n\t  tmp[len2++] = c;\n\t}\n      else if (map_is (&map, TR46_FLG_IGNORED))\n\t{\n\t  continue;\n\t}\n      else if (map_is (&map, TR46_FLG_DEVIATION))\n\t{\n\t  if (transitional)\n\t    {\n\t      len2 += get_map_data (tmp + len2, &map);\n\t    }\n\t  else\n\t    tmp[len2++] = c;\n\t}\n      else if (!(flags & IDN2_USE_STD3_ASCII_RULES))\n        {\n\t  if (map_is (&map, TR46_FLG_DISALLOWED_STD3_VALID))\n\t    {\n\t      tmp[len2++] = c;\n\t    }\n\t  else if (map_is (&map, TR46_FLG_DISALLOWED_STD3_MAPPED))\n\t    {\n\t      len2 += get_map_data (tmp + len2, &map);\n\t    }\n        }\n    }\n  free (domain_u32);\n\n  /* Normalize to NFC */\n  tmp[len2] = 0;\n  domain_u32 = u32_normalize (UNINORM_NFC, tmp, len2 + 1, NULL, &len);\n  free (tmp);\n  tmp = NULL;\n\n  if (!domain_u32)\n    {\n      if (errno == ENOMEM)\n\treturn IDN2_MALLOC;\n      return IDN2_ENCODING_ERROR;\n    }\n\n  /* split into labels and check */\n  uint32_t *e, *s;\n  for (e = s = domain_u32; *e; s = e)\n    {\n      while (*e && *e != '.')\n\te++;\n\n      if (e - s >= 4 && s[0] == 'x' && s[1] == 'n' && s[2] == '-'\n\t  && s[3] == '-')\n\t{\n\t  /* decode punycode and check result non-transitional */\n\t  size_t ace_len;\n\t  uint32_t name_u32[IDN2_LABEL_MAX_LENGTH];\n\t  size_t name_len = IDN2_LABEL_MAX_LENGTH;\n\t  uint8_t *ace;\n\n\t  ace = u32_to_u8 (s + 4, e - s - 4, NULL, &ace_len);\n\t  if (!ace)\n\t    {\n\t      free (domain_u32);\n\t      if (errno == ENOMEM)\n\t\treturn IDN2_MALLOC;\n\t      return IDN2_ENCODING_ERROR;\n\t    }\n\n\t  rc =\n\t    _idn2_punycode_decode (ace_len, (char *) ace, &name_len, name_u32);\n\n\t  free (ace);\n\n\t  if (rc)\n\t    {\n\t      free (domain_u32);\n\t      return rc;\n\t    }\n\n\t  test_flags = TR46_NONTRANSITIONAL_CHECK;\n\n\t  if (!(flags & IDN2_USE_STD3_ASCII_RULES))\n\t    test_flags |= TEST_ALLOW_STD3_DISALLOWED;\n\n\t  if ((rc =\n\t       _idn2_label_test (test_flags, name_u32,\n\t\t\t\t name_len)))\n\t    err = rc;\n\t}\n      else\n\t{\n\t  test_flags = transitional ? TR46_TRANSITIONAL_CHECK : TR46_NONTRANSITIONAL_CHECK;\n\n\t  if (!(flags & IDN2_USE_STD3_ASCII_RULES))\n\t    test_flags |= TEST_ALLOW_STD3_DISALLOWED;\n\n\t  if ((rc =\n\t       _idn2_label_test (test_flags, s, e - s)))\n\t    err = rc;\n\t}\n\n      if (*e)\n\te++;\n    }\n\n  if (err == IDN2_OK && out)\n    {\n      uint8_t *_out = u32_to_u8 (domain_u32, len, NULL, &len);\n      free (domain_u32);\n\n      if (!_out)\n\t{\n\t  if (errno == ENOMEM)\n\t    return IDN2_MALLOC;\n\t  return IDN2_ENCODING_ERROR;\n\t}\n\n      *out = _out;\n    }\n  else\n    free (domain_u32);\n\n  return err;\n}",
      "lines": 221,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "idn2_lookup_u8": {
      "start_point": [
        398,
        0
      ],
      "end_point": [
        484,
        1
      ],
      "content": "int\nidn2_lookup_u8 (const uint8_t * src, uint8_t ** lookupname, int flags)\n{\n  size_t lookupnamelen = 0;\n  uint8_t _lookupname[IDN2_DOMAIN_MAX_LENGTH + 1];\n  uint8_t _mapped[IDN2_DOMAIN_MAX_LENGTH + 1];\n  int rc;\n\n  if (src == NULL)\n    {\n      if (lookupname)\n\t*lookupname = NULL;\n      return IDN2_OK;\n    }\n\n  rc = set_default_flags(&flags);\n  if (rc != IDN2_OK)\n    return rc;\n\n  if (!(flags & IDN2_NO_TR46))\n    {\n      uint8_t *out;\n      size_t outlen;\n\n      rc = _tr46 (src, &out, flags);\n      if (rc != IDN2_OK)\n\treturn rc;\n\n      outlen = u8_strlen (out);\n      if (outlen >= sizeof (_mapped))\n\t{\n\t  free (out);\n\t  return IDN2_TOO_BIG_DOMAIN;\n\t}\n\n      memcpy (_mapped, out, outlen + 1);\n      src = _mapped;\n      free (out);\n    }\n\n  do\n    {\n      const uint8_t *end = (uint8_t *) strchrnul ((const char *) src, '.');\n      /* XXX Do we care about non-U+002E dots such as U+3002, U+FF0E\n         and U+FF61 here?  Perhaps when IDN2_NFC_INPUT? */\n      size_t labellen = end - src;\n      uint8_t tmp[IDN2_LABEL_MAX_LENGTH];\n      size_t tmplen = IDN2_LABEL_MAX_LENGTH;\n\n      rc = label (src, labellen, tmp, &tmplen, flags);\n      if (rc != IDN2_OK)\n\treturn rc;\n\n      if (lookupnamelen + tmplen\n\t  > IDN2_DOMAIN_MAX_LENGTH - (tmplen == 0 && *end == '\\0' ? 1 : 2))\n\treturn IDN2_TOO_BIG_DOMAIN;\n\n      memcpy (_lookupname + lookupnamelen, tmp, tmplen);\n      lookupnamelen += tmplen;\n\n      if (*end == '.')\n\t{\n\t  if (lookupnamelen + 1 > IDN2_DOMAIN_MAX_LENGTH)\n\t    return IDN2_TOO_BIG_DOMAIN;\n\n\t  _lookupname[lookupnamelen] = '.';\n\t  lookupnamelen++;\n\t}\n      _lookupname[lookupnamelen] = '\\0';\n\n      src = end;\n    }\n  while (*src++);\n\n  if (lookupname)\n    {\n      uint8_t *tmp = (uint8_t *) malloc (lookupnamelen + 1);\n\n      if (tmp == NULL)\n\treturn IDN2_MALLOC;\n\n      memcpy (tmp, _lookupname, lookupnamelen + 1);\n      *lookupname = tmp;\n    }\n\n  return IDN2_OK;\n}",
      "lines": 87,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "idn2_lookup_ul": {
      "start_point": [
        517,
        0
      ],
      "end_point": [
        543,
        1
      ],
      "content": "int\nidn2_lookup_ul (const char * src, char ** lookupname, int flags)\n{\n  uint8_t *utf8src = NULL;\n  int rc;\n\n  if (src)\n    {\n      const char *encoding = locale_charset ();\n\n      utf8src = u8_strconv_from_encoding (src, encoding, iconveh_error);\n\n      if (!utf8src)\n\t{\n\t  if (errno == ENOMEM)\n\t    return IDN2_MALLOC;\n\t  return IDN2_ICONV_FAIL;\n\t}\n    }\n\n  rc = idn2_lookup_u8 (utf8src, (uint8_t **) lookupname,\n\t\t       flags | IDN2_NFC_INPUT);\n\n  free (utf8src);\n\n  return rc;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "idn2_to_ascii_4i": {
      "start_point": [
        579,
        0
      ],
      "end_point": [
        625,
        1
      ],
      "content": "int\nidn2_to_ascii_4i (const uint32_t * input, size_t inlen, char * output, int flags)\n{\n  uint32_t *input_u32;\n  uint8_t *input_u8, *output_u8;\n  size_t length;\n  int rc;\n\n  if (!input)\n    {\n      if (output)\n\t*output = 0;\n      return IDN2_OK;\n    }\n\n  input_u32 = (uint32_t *) malloc ((inlen + 1) * sizeof(uint32_t));\n  if (!input_u32)\n    return IDN2_MALLOC;\n\n  u32_cpy (input_u32, input, inlen);\n  input_u32[inlen] = 0;\n\n  input_u8 = u32_to_u8 (input_u32, inlen + 1, NULL, &length);\n  free (input_u32);\n  if (!input_u8)\n    {\n      if (errno == ENOMEM)\n\treturn IDN2_MALLOC;\n      return IDN2_ENCODING_ERROR;\n    }\n\n  rc = idn2_lookup_u8 (input_u8, &output_u8, flags);\n  free (input_u8);\n\n  if (rc == IDN2_OK)\n    {\n      /* wow, this is ugly, but libidn manpage states:\n       * char * out  output zero terminated string that must have room for at\n       * least 63 characters plus the terminating zero.\n       */\n      if (output)\n\tstrcpy (output, (const char *) output_u8);\n    }\n\n  free(output_u8);\n  return rc;\n}",
      "lines": 47,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "idn2_to_ascii_4z": {
      "start_point": [
        647,
        0
      ],
      "end_point": [
        673,
        1
      ],
      "content": "int\nidn2_to_ascii_4z (const uint32_t * input, char ** output, int flags)\n{\n  uint8_t *input_u8;\n  size_t length;\n  int rc;\n\n  if (!input)\n    {\n      if (output)\n\t*output = NULL;\n      return IDN2_OK;\n    }\n\n  input_u8 = u32_to_u8 (input, u32_strlen(input) + 1, NULL, &length);\n  if (!input_u8)\n    {\n      if (errno == ENOMEM)\n\treturn IDN2_MALLOC;\n      return IDN2_ENCODING_ERROR;\n    }\n\n  rc = idn2_lookup_u8 (input_u8, (uint8_t **) output, flags);\n  free (input_u8);\n\n  return rc;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "idn2_to_ascii_8z": {
      "start_point": [
        695,
        0
      ],
      "end_point": [
        699,
        1
      ],
      "content": "int\nidn2_to_ascii_8z (const char * input, char ** output, int flags)\n{\n  return idn2_lookup_u8 ((const uint8_t *) input, (uint8_t **) output, flags);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "idn2_to_ascii_lz": {
      "start_point": [
        722,
        0
      ],
      "end_point": [
        726,
        1
      ],
      "content": "int\nidn2_to_ascii_lz (const char * input, char ** output, int flags)\n{\n  return idn2_lookup_ul (input, output, flags);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/lib/punycode.h": {},
  "libidn/libidn2-2.0.5/lib/puny_decode.c": {
    "decode_digit": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "static unsigned decode_digit(int cp)\n{\n  return (unsigned) (cp - 48 < 10 ? cp - 22 :  cp - 65 < 26 ? cp - 65 :\n         cp - 97 < 26 ? cp - 97 :  base);\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "adapt": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "static punycode_uint adapt(\n  punycode_uint delta, punycode_uint numpoints, int firsttime )\n{\n  punycode_uint k;\n\n  delta = firsttime ? delta / damp : delta >> 1;\n  /* delta >> 1 is a faster way of doing delta / 2 */\n  delta += delta / numpoints;\n\n  for (k = 0;  delta > ((base - tmin) * tmax) / 2;  k += base) {\n    delta /= base - tmin;\n  }\n\n  return k + (base - tmin + 1) * delta / (delta + skew);\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "punycode_uint"
      ]
    },
    "punycode_decode": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "int punycode_decode(\n  size_t input_length,\n  const char input[],\n  size_t *output_length,\n  punycode_uint output[])\n{\n  punycode_uint n, out, i, max_out, bias, oldi, w, k, digit, t;\n  size_t b, j, in;\n\n  /* Initialize the state: */\n\n  n = initial_n;\n  out = i = 0;\n  max_out = *output_length > maxint ? maxint\n            : (punycode_uint) *output_length;\n  bias = initial_bias;\n\n  /* Handle the basic code points:  Let b be the number of input code */\n  /* points before the last delimiter, or 0 if there is none, then    */\n  /* copy the first b code points to the output.                      */\n\n  for (b = j = 0;  j < input_length;  ++j)  if (delim(input[j])) b = j;\n  if (b > max_out) return punycode_big_output;\n\n  for (j = 0;  j < b;  ++j) {\n    if (!basic(input[j])) return punycode_bad_input;\n    output[out++] = input[j];\n  }\n\n  /* Main decoding loop:  Start just after the last delimiter if any  */\n  /* basic code points were copied; start at the beginning otherwise. */\n\n  for (in = b > 0 ? b + 1 : 0;  in < input_length;  ++out) {\n\n    /* in is the index of the next ASCII code point to be consumed, */\n    /* and out is the number of code points in the output array.    */\n\n    /* Decode a generalized variable-length integer into delta,  */\n    /* which gets added to i.  The overflow checking is easier   */\n    /* if we increase i as we go, then subtract off its starting */\n    /* value at the end to obtain delta.                         */\n\n    for (oldi = i, w = 1, k = base;  ;  k += base) {\n      if (in >= input_length) return punycode_bad_input;\n      digit = decode_digit(input[in++]);\n      if (digit >= base) return punycode_bad_input;\n      if (digit > (maxint - i) / w) return punycode_overflow;\n      i += digit * w;\n      t = k <= bias /* + tmin */ ? tmin :     /* +tmin not needed */\n          k >= bias + tmax ? tmax : k - bias;\n      if (digit < t) break;\n      if (w > maxint / (base - t)) return punycode_overflow;\n      w *= (base - t);\n    }\n\n    bias = adapt(i - oldi, out + 1, oldi == 0);\n\n    /* i was supposed to wrap around from out+1 to 0,   */\n    /* incrementing n each time, so we'll fix that now: */\n\n    if (i / (out + 1) > maxint - n) return punycode_overflow;\n    n += i / (out + 1);\n    i %= (out + 1);\n\n    /* Insert n at position i of the output: */\n\n    /* not needed for Punycode: */\n    /* if (basic(n)) return punycode_bad_input; */\n    if (out >= max_out) return punycode_big_output;\n\n    memmove(output + i + 1, output + i, (out - i) * sizeof *output);\n    output[i++] = n;\n  }\n\n  *output_length = (size_t) out;\n  /* cannot overflow because out <= old value of *output_length */\n  return punycode_success;\n}",
      "lines": 78,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/lib/puny_encode.c": {
    "encode_digit": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "static char encode_digit(punycode_uint d, int flag)\n{\n  return d + 22 + 75 * (d < 26) - ((flag != 0) << 5);\n  /*  0..25 map to ASCII a..z or A..Z */\n  /* 26..35 map to ASCII 0..9         */\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "adapt": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "static punycode_uint adapt(\n  punycode_uint delta, punycode_uint numpoints, int firsttime )\n{\n  punycode_uint k;\n\n  delta = firsttime ? delta / damp : delta >> 1;\n  /* delta >> 1 is a faster way of doing delta / 2 */\n  delta += delta / numpoints;\n\n  for (k = 0;  delta > ((base - tmin) * tmax) / 2;  k += base) {\n    delta /= base - tmin;\n  }\n\n  return k + (base - tmin + 1) * delta / (delta + skew);\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "punycode_uint"
      ]
    },
    "punycode_encode": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "int punycode_encode(\n  size_t input_length_orig,\n  const punycode_uint input[],\n  size_t *output_length,\n  char output[] )\n{\n  punycode_uint input_length, n, delta, h, b, bias, j, m, q, k, t;\n  size_t out, max_out;\n\n  /* The Punycode spec assumes that the input length is the same type */\n  /* of integer as a code point, so we need to convert the size_t to  */\n  /* a punycode_uint, which could overflow.                           */\n\n  if (input_length_orig > maxint) return punycode_overflow;\n  input_length = (punycode_uint) input_length_orig;\n\n  /* Initialize the state: */\n\n  n = initial_n;\n  delta = 0;\n  out = 0;\n  max_out = *output_length;\n  bias = initial_bias;\n\n  /* Handle the basic code points: */\n\n  for (j = 0;  j < input_length;  ++j) {\n    if (basic(input[j])) {\n      if (max_out - out < 2) return punycode_big_output;\n      output[out++] = (char) input[j];\n    }\n    /* else if (input[j] < n) return punycode_bad_input; */\n    /* (not needed for Punycode with unsigned code points) */\n  }\n\n  h = b = (punycode_uint) out;\n  /* cannot overflow because out <= input_length <= maxint */\n\n  /* h is the number of code points that have been handled, b is the  */\n  /* number of basic code points, and out is the number of ASCII code */\n  /* points that have been output.                                    */\n\n  if (b > 0) output[out++] = delimiter;\n\n  /* Main encoding loop: */\n\n  while (h < input_length) {\n    /* All non-basic code points < n have been     */\n    /* handled already.  Find the next larger one: */\n\n    for (m = maxint, j = 0;  j < input_length;  ++j) {\n      /* if (basic(input[j])) continue; */\n      /* (not needed for Punycode) */\n      if (input[j] >= n && input[j] < m) m = input[j];\n    }\n\n    /* Increase delta enough to advance the decoder's    */\n    /* <n,i> state to <m,0>, but guard against overflow: */\n\n    if (m - n > (maxint - delta) / (h + 1)) return punycode_overflow;\n    delta += (m - n) * (h + 1);\n    n = m;\n\n    for (j = 0;  j < input_length;  ++j) {\n      /* Punycode does not need to check whether input[j] is basic: */\n      if (input[j] < n /* || basic(input[j]) */ ) {\n        if (++delta == 0) return punycode_overflow;\n      }\n\n      if (input[j] == n) {\n        /* Represent delta as a generalized variable-length integer: */\n\n        for (q = delta, k = base;  ;  k += base) {\n          if (out >= max_out) return punycode_big_output;\n          t = k <= bias /* + tmin */ ? tmin :     /* +tmin not needed */\n              k >= bias + tmax ? tmax : k - bias;\n          if (q < t) break;\n          output[out++] = encode_digit(t + (q - t) % (base - t), 0);\n          q = (q - t) / (base - t);\n        }\n\n        output[out++] = encode_digit(q, 0);\n        bias = adapt(delta, h + 1, h == b);\n        delta = 0;\n        ++h;\n      }\n    }\n\n    ++delta, ++n;\n  }\n\n  *output_length = out;\n  return punycode_success;\n}",
      "lines": 94,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/lib/register.c": {
    "idn2_register_u8": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "int\nidn2_register_u8 (const uint8_t * ulabel, const uint8_t * alabel,\n\t\t  uint8_t ** insertname, int flags)\n{\n  int rc;\n\n  if (ulabel == NULL && alabel == NULL)\n    {\n      if (insertname)\n\t*insertname = NULL;\n      return IDN2_OK;\n    }\n\n  if (alabel)\n    {\n      size_t alabellen = u8_strlen (alabel), u32len =\n\tIDN2_LABEL_MAX_LENGTH * 4;\n      uint32_t u32[IDN2_DOMAIN_MAX_LENGTH * 4];\n      uint8_t *tmp;\n      uint8_t u8[IDN2_DOMAIN_MAX_LENGTH + 1];\n      size_t u8len;\n\n      if (alabellen >= IDN2_LABEL_MAX_LENGTH)\n\treturn IDN2_TOO_BIG_LABEL;\n\n      if (alabellen <= 4)\n\treturn IDN2_INVALID_ALABEL;\n      if (alabel[0] != 'x'\n\t  || alabel[1] != 'n' || alabel[2] != '-' || alabel[3] != '-')\n\treturn IDN2_INVALID_ALABEL;\n\n      if (!_idn2_ascii_p (alabel, alabellen))\n\treturn IDN2_INVALID_ALABEL;\n\n      rc = _idn2_punycode_decode (alabellen - 4, (char*)alabel + 4,\n\t\t\t\t  &u32len, u32);\n      if (rc != IDN2_OK)\n\treturn rc;\n\n      u8len = sizeof (u8);\n      if (u32_to_u8 (u32, u32len, u8, &u8len) == NULL)\n\treturn IDN2_ENCODING_ERROR;\n      u8[u8len] = '\\0';\n\n      if (ulabel)\n\t{\n\t  if (strcmp ((char*)ulabel, (char*)u8) != 0)\n\t    return IDN2_UALABEL_MISMATCH;\n\t}\n\n      rc = idn2_register_u8 (u8, NULL, &tmp, 0);\n      if (rc != IDN2_OK)\n\treturn rc;\n\n      rc = strcmp ((char*)alabel, (char*)tmp);\n      free (tmp);\n      if (rc != 0)\n\treturn IDN2_UALABEL_MISMATCH;\n\n      if (insertname)\n\t{\n\t  uint8_t *m = (uint8_t *)strdup ((char*)alabel);\n\t  if (!m)\n\t    return IDN2_MALLOC;\n\n\t  *insertname = m;\n\t}\n    }\n  else\t\t\t\t/* ulabel only */\n    {\n      size_t ulabellen = u8_strlen (ulabel);\n      uint32_t *u32;\n      size_t u32len;\n      size_t tmpl;\n      uint8_t tmp[IDN2_LABEL_MAX_LENGTH + 1];\n\n      if (ulabel && ulabellen >= IDN2_LABEL_MAX_LENGTH)\n\treturn IDN2_TOO_BIG_LABEL;\n\n      if (_idn2_ascii_p (ulabel, ulabellen))\n\t{\n\t  if (insertname)\n\t    {\n\t      uint8_t *m = (uint8_t *)strdup ((char*)ulabel);\n\t      if (!m)\n\t\treturn IDN2_MALLOC;\n\t      *insertname = m;\n\t    }\n\t  return IDN2_OK;\n\t}\n\n      rc = _idn2_u8_to_u32_nfc (ulabel, ulabellen, &u32, &u32len,\n\t\t\t\tflags & IDN2_NFC_INPUT);\n      if (rc != IDN2_OK)\n\treturn rc;\n\n      rc = _idn2_label_test (TEST_NFC\n\t\t\t     | TEST_DISALLOWED\n\t\t\t     | TEST_UNASSIGNED\n\t\t\t     | TEST_2HYPHEN\n\t\t\t     | TEST_HYPHEN_STARTEND\n\t\t\t     | TEST_LEADING_COMBINING\n\t\t\t     | TEST_CONTEXTJ_RULE\n\t\t\t     | TEST_CONTEXTO_RULE | TEST_BIDI, u32, u32len);\n      if (rc != IDN2_OK)\n\t{\n\t  free (u32);\n\t  return rc;\n\t}\n\n      tmp[0] = 'x';\n      tmp[1] = 'n';\n      tmp[2] = '-';\n      tmp[3] = '-';\n\n      tmpl = IDN2_LABEL_MAX_LENGTH - 4;\n      rc = _idn2_punycode_encode (u32len, u32, &tmpl, (char*)tmp + 4);\n      free (u32);\n      if (rc != IDN2_OK)\n\treturn rc;\n\n      tmp[4 + tmpl] = '\\0';\n\n      if (insertname)\n\t{\n\t  uint8_t *m = (uint8_t *)strdup ((char*)tmp);\n\t  if (!m)\n\t    return IDN2_MALLOC;\n\t  *insertname = m;\n\t}\n    }\n\n  return IDN2_OK;\n}",
      "lines": 134,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "idn2_register_ul": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "int\nidn2_register_ul (const char *ulabel, const char *alabel,\n\t\t  char **insertname, int flags)\n{\n  uint8_t *utf8ulabel = NULL;\n  int rc;\n\n  if (ulabel)\n    {\n      const char *encoding = locale_charset ();\n\n      utf8ulabel = u8_strconv_from_encoding (ulabel, encoding, iconveh_error);\n\n      if (utf8ulabel == NULL)\n\t{\n\t  if (errno == ENOMEM)\n\t    return IDN2_MALLOC;\n\t  return IDN2_ICONV_FAIL;\n\t}\n    }\n\n  rc = idn2_register_u8 (utf8ulabel, (const uint8_t *) alabel,\n\t\t\t (uint8_t **) insertname, flags | IDN2_NFC_INPUT);\n\n  free (utf8ulabel);\n\n  return rc;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/lib/tables.c": {
    "_compare": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static int\n_compare (const struct idna_table *m1, const struct idna_table *m2)\n{\n  if (m1->start < m2->start)\n    return -1;\n  if (m1->start > m2->end)\n    return 1;\n  return 0;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "property": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "static int\nproperty (uint32_t cp)\n{\n  const struct idna_table *result;\n  struct idna_table key;\n\n  key.start = cp;\n\n  result = (struct idna_table *)\n\tbsearch (&key, idna_table, idna_table_size,\n\t\t sizeof (struct idna_table),\n\t\t (int (*)(const void *, const void *)) _compare);\n\n  return result ? result->state : UNASSIGNED;\n}",
      "lines": 15,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_idn2_disallowed_p": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "int\n_idn2_disallowed_p (uint32_t cp)\n{\n  return property (cp) == DISALLOWED;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "_idn2_contextj_p": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "int\n_idn2_contextj_p (uint32_t cp)\n{\n  return property (cp) == CONTEXTJ;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "_idn2_contexto_p": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "int\n_idn2_contexto_p (uint32_t cp)\n{\n  return property (cp) == CONTEXTO;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "_idn2_unassigned_p": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "int\n_idn2_unassigned_p (uint32_t cp)\n{\n  return property (cp) == UNASSIGNED;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/lib/tables.h": {},
  "libidn/libidn2-2.0.5/lib/tr46map.c": {
    "_fill_map": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static void\n_fill_map (uint32_t c, const uint8_t * p, IDNAMap * map)\n{\n  uint32_t value;\n\n  if (c <= 0xFF)\n    {\n      map->cp1 = *p++;\n      map->range = *p++;\n    }\n  else if (c <= 0xFFFF)\n    {\n      map->cp1 = (p[0] << 8) | p[1];\n      map->range = (p[2] << 8) | p[3];\n      p += 4;\n    }\n  else\n    {\n      map->cp1 = (p[0] << 16) | (p[1] << 8) | p[2];\n      map->range = (p[3] << 8) | p[4];\n      p += 5;\n    }\n\n  value = (p[0] << 16) | (p[1] << 8) | p[2];\n\n  /* deconstruct value, construction was\n   *   value = (((map->nmappings << 14) | map->offset) << 3) | map->flag_index; */\n  map->flag_index = value & 0x7;\n  map->offset = (value >> 3) & 0x3FFF;\n  map->nmappings = (value >> 17) & 0x1F;\n}",
      "lines": 31,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_compare_idna_map": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "static int\n_compare_idna_map (const uint32_t * c, const uint8_t * p)\n{\n  IDNAMap map;\n\n  _fill_map (*c, p, &map);\n\n  if (*c < map.cp1)\n    return -1;\n  if (*c > map.cp1 + map.range)\n    return 1;\n  return 0;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "get_idna_map": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "int\nget_idna_map (uint32_t c, IDNAMap * map)\n{\n  uint8_t *p;\n\n  if (c <= 0xFF)\n    p =\n      (uint8_t *)bsearch (&c, idna_map_8, sizeof (idna_map_8) / 5, 5,\n\t       (int (*)(const void *, const void *)) _compare_idna_map);\n  else if (c <= 0xFFFF)\n    p =\n      (uint8_t *)bsearch (&c, idna_map_16, sizeof (idna_map_16) / 7, 7,\n\t       (int (*)(const void *, const void *)) _compare_idna_map);\n  else if (c <= 0xFFFFFF)\n    p =\n      (uint8_t *)bsearch (&c, idna_map_24, sizeof (idna_map_24) / 8, 8,\n\t       (int (*)(const void *, const void *)) _compare_idna_map);\n  else\n    p = NULL;\n\n  if (!p)\n    {\n      memset (map, 0, sizeof (IDNAMap));\n      return -1;\n    }\n\n  _fill_map (c, p, map);\n  return 0;\n}",
      "lines": 29,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "map_is": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "int\nmap_is (const IDNAMap * map, unsigned flags)\n{\n  return (idna_flags[map->flag_index] & flags) == flags;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "_compare_nfcqc_map": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "static int\n_compare_nfcqc_map (uint32_t * c, NFCQCMap * m2)\n{\n  if (*c < m2->cp1)\n    return -1;\n  if (*c > m2->cp2)\n    return 1;\n  return 0;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "get_nfcqc_map": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "NFCQCMap *\nget_nfcqc_map (uint32_t c)\n{\n  return (NFCQCMap *)bsearch (&c, nfcqc_map, countof (nfcqc_map), sizeof (NFCQCMap),\n\t\t  (int (*)(const void *, const void *)) _compare_nfcqc_map);\n}",
      "lines": 6,
      "depth": 13,
      "decorators": [
        "NFCQCMap",
        "*\nget_nfcqc_map (uint32_t c)",
        "*"
      ]
    },
    "get_map_data": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "int\nget_map_data (uint32_t * dst, const IDNAMap * map)\n{\n  int n = map->nmappings;\n  const uint8_t *src = mapdata + map->offset;\n\n  for (; n > 0; n--)\n    {\n      uint32_t cp = 0;\n      do\n\tcp = (cp << 7) | (*src & 0x7F);\n      while (*src++ & 0x80);\n      *dst++ = cp;\n    }\n\n  return map->nmappings;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/lib/tr46map.h": {},
  "libidn/libidn2-2.0.5/lib/tr46map_data.c": {},
  "libidn/libidn2-2.0.5/lib/version.c": {
    "idn2_check_version": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "const char *\nidn2_check_version (const char *req_version)\n{\n  if (!req_version || strverscmp (req_version, IDN2_VERSION) <= 0)\n    return IDN2_VERSION;\n\n  return NULL;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nidn2_check_version (const char *req_version)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/src/blurbs.h": {},
  "libidn/libidn2-2.0.5/src/idn2.c": {
    "usage": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "static void\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    fprintf (stderr, _(\"Try `%s --help' for more information.\\n\"),\n\t     program_name);\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... [STRINGS]...\\n\\\n\"), program_name);\n      fputs (_(\"\\\nInternationalized Domain Name (IDNA2008) convert STRINGS, or standard input.\\n\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\nCommand line interface to the Libidn2 implementation of IDNA2008.\\n\\\n\\n\\\nAll strings are expected to be encoded in the locale charset.\\n\\\n\\n\\\nTo process a string that starts with `-', for example `-foo', use `--'\\n\\\nto signal the end of parameters, as in `idn2 --quiet -- -foo'.\\n\\\n\\n\\\nMandatory arguments to long options are mandatory for short options too.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -h, --help               Print help and exit\\n\\\n  -V, --version            Print version and exit\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -d, --decode             Decode (punycode) domain name\\n\\\n  -l, --lookup             Lookup domain name (default)\\n\\\n  -r, --register           Register label\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -T, --tr46t              Enable TR46 transitional processing\\n\\\n  -N, --tr46nt             Enable TR46 non-transitional processing\\n\\\n      --no-tr46            Disable TR46 processing\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --usestd3asciirules  Enable STD3 ASCII rules\\n\\\n      --debug              Print debugging information\\n\\\n      --quiet              Silent operation\\n\\\n\"), stdout);\n      emit_bug_reporting_address ();\n    }\n  exit (status);\n}",
      "lines": 48,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hexdump": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "static void\nhexdump (const char *prefix, const char *str)\n{\n  uint8_t *u8;\n  uint32_t *u32 = NULL;\n  size_t u32len;\n  size_t i;\n  const char *encoding = locale_charset ();\n\n  u8 = u8_strconv_from_encoding (str, encoding, iconveh_error);\n  if (u8)\n    u32 = u8_to_u32 (u8, strlen ((char *) u8), NULL, &u32len);\n\n  for (i = 0; i < strlen (str); i++)\n    fprintf (stderr, \"%s[%lu] = 0x%02x\\n\",\n\t     prefix, (unsigned long) i, (unsigned) (str[i] & 0xFF));\n\n  if (u8 && strcmp (str, (char *) u8) != 0)\n    for (i = 0; i < strlen ((char *) u8); i++)\n      fprintf (stderr, \"UTF-8 %s[%lu] = 0x%02x\\n\",\n\t       prefix, (unsigned long) i, u8[i] & 0xFF);\n\n  if (u8 && u32)\n    for (i = 0; i < u32len; i++)\n      fprintf (stderr, \"UCS-4 %s[%lu] = U+%04x\\n\",\n\t       prefix, (unsigned long) i, u32[i]);\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "process_input": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "static void\nprocess_input (char *readbuf, int flags)\n{\n  size_t len = strlen (readbuf);\n  char *output;\n  const char *tag;\n  int rc;\n\n  if (len && readbuf[len - 1] == '\\n')\n    readbuf[len - 1] = '\\0';\n\n  if (strcmp (readbuf, \"show w\") == 0)\n    {\n      puts (WARRANTY);\n      return;\n    }\n  else if (strcmp (readbuf, \"show c\") == 0)\n    {\n      puts (CONDITIONS);\n      return;\n    }\n\n  if (args_info.debug_given)\n    hexdump (\"input\", readbuf);\n\n  if (args_info.register_given)\n    {\n      rc = idn2_register_ul(readbuf, NULL, &output, flags);\n      tag = \"register\";\n    }\n  else if (args_info.decode_given)\n    {\n      rc = idn2_to_unicode_lzlz (readbuf, &output, 0);\n      tag = \"decode\";\n    }\n  else\n    {\n      rc = idn2_to_ascii_lz (readbuf, &output, flags);\n      tag = \"toAscii\";\n    }\n\n  if (rc == IDN2_OK)\n    {\n      if (args_info.debug_given)\n\thexdump (\"output\", readbuf);\n\n      printf (\"%s\\n\", output);\n      free (output);\n    }\n  else\n    error (EXIT_FAILURE, 0, \"%s: %s\", tag, idn2_strerror (rc));\n}",
      "lines": 52,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  unsigned cmdn;\n  int flags = IDN2_NONTRANSITIONAL;\n\n  setlocale (LC_ALL, \"\");\n  set_program_name (argv[0]);\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  if (cmdline_parser (argc, argv, &args_info) != 0)\n    return EXIT_FAILURE;\n\n  if (args_info.version_given)\n    {\n      version_etc (stdout, \"idn2\", PACKAGE_NAME, VERSION,\n\t\t   \"Simon Josefsson\", (char *) NULL);\n      return EXIT_SUCCESS;\n    }\n\n  if (args_info.help_given)\n    usage (EXIT_SUCCESS);\n\n  if (!args_info.quiet_given\n      && args_info.inputs_num == 0 && isatty (fileno (stdin)))\n    fprintf (stderr, \"%s %s\\n\" GREETING, PACKAGE, VERSION);\n\n  if (args_info.debug_given)\n    fprintf (stderr, _(\"Charset: %s\\n\"), locale_charset ());\n\n  if (!args_info.quiet_given\n      && args_info.inputs_num == 0 && isatty (fileno (stdin)))\n    fprintf (stderr, \"%s\", _(\"Type each input string on a line by itself, \"\n\t\t\t     \"terminated by a newline character.\\n\"));\n\n  if (args_info.tr46t_given)\n    flags = IDN2_TRANSITIONAL;\n  else if (args_info.tr46nt_given)\n    flags = IDN2_NONTRANSITIONAL;\n  else if (args_info.no_tr46_given)\n    flags = 0;\n\n  if (flags && args_info.usestd3asciirules_given)\n    flags |= IDN2_USE_STD3_ASCII_RULES;\n\n  for (cmdn = 0; cmdn < args_info.inputs_num; cmdn++)\n    process_input (args_info.inputs[cmdn], flags | IDN2_NFC_INPUT);\n\n  if (!cmdn)\n    {\n      char *buf = NULL;\n      size_t bufsize = 0;\n\n      while (getline (&buf, &bufsize, stdin) > 0)\n\tprocess_input (buf, flags);\n\n      free (buf);\n    }\n\n  if (ferror (stdin))\n    error (EXIT_FAILURE, errno, \"%s\", _(\"input error\"));\n\n  cmdline_parser_free (&args_info);\n\n  return EXIT_SUCCESS;\n}",
      "lines": 67,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/src/idn2_cmd.c": {
    "clear_given": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static\nvoid clear_given (struct gengetopt_args_info *args_info)\n{\n  args_info->help_given = 0 ;\n  args_info->version_given = 0 ;\n  args_info->decode_given = 0 ;\n  args_info->lookup_given = 0 ;\n  args_info->register_given = 0 ;\n  args_info->tr46t_given = 0 ;\n  args_info->tr46nt_given = 0 ;\n  args_info->no_tr46_given = 0 ;\n  args_info->usestd3asciirules_given = 0 ;\n  args_info->debug_given = 0 ;\n  args_info->quiet_given = 0 ;\n}",
      "lines": 15,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "clear_args": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "static\nvoid clear_args (struct gengetopt_args_info *args_info)\n{\n  FIX_UNUSED (args_info);\n  args_info->tr46t_flag = 0;\n  args_info->tr46nt_flag = 0;\n  args_info->no_tr46_flag = 0;\n  args_info->usestd3asciirules_flag = 0;\n  args_info->debug_flag = 0;\n  args_info->quiet_flag = 0;\n  \n}",
      "lines": 12,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "init_args_info": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "static\nvoid init_args_info(struct gengetopt_args_info *args_info)\n{\n\n\n  args_info->help_help = gengetopt_args_info_help[0] ;\n  args_info->version_help = gengetopt_args_info_help[1] ;\n  args_info->decode_help = gengetopt_args_info_help[2] ;\n  args_info->lookup_help = gengetopt_args_info_help[3] ;\n  args_info->register_help = gengetopt_args_info_help[4] ;\n  args_info->tr46t_help = gengetopt_args_info_help[5] ;\n  args_info->tr46nt_help = gengetopt_args_info_help[6] ;\n  args_info->no_tr46_help = gengetopt_args_info_help[7] ;\n  args_info->usestd3asciirules_help = gengetopt_args_info_help[8] ;\n  args_info->debug_help = gengetopt_args_info_help[9] ;\n  args_info->quiet_help = gengetopt_args_info_help[10] ;\n  \n}",
      "lines": 18,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cmdline_parser_print_version": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "void\ncmdline_parser_print_version (void)\n{\n  printf (\"%s %s\\n\",\n     (strlen(CMDLINE_PARSER_PACKAGE_NAME) ? CMDLINE_PARSER_PACKAGE_NAME : CMDLINE_PARSER_PACKAGE),\n     CMDLINE_PARSER_VERSION);\n\n  if (strlen(gengetopt_args_info_versiontext) > 0)\n    printf(\"\\n%s\\n\", gengetopt_args_info_versiontext);\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "print_help_common": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "static void print_help_common(void) {\n  cmdline_parser_print_version ();\n\n  if (strlen(gengetopt_args_info_purpose) > 0)\n    printf(\"\\n%s\\n\", gengetopt_args_info_purpose);\n\n  if (strlen(gengetopt_args_info_usage) > 0)\n    printf(\"\\n%s\\n\", gengetopt_args_info_usage);\n\n  printf(\"\\n\");\n\n  if (strlen(gengetopt_args_info_description) > 0)\n    printf(\"%s\\n\\n\", gengetopt_args_info_description);\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cmdline_parser_print_help": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "void\ncmdline_parser_print_help (void)\n{\n  int i = 0;\n  print_help_common();\n  while (gengetopt_args_info_help[i])\n    printf(\"%s\\n\", gengetopt_args_info_help[i++]);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "cmdline_parser_init": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "void\ncmdline_parser_init (struct gengetopt_args_info *args_info)\n{\n  clear_given (args_info);\n  clear_args (args_info);\n  init_args_info (args_info);\n\n  args_info->inputs = 0;\n  args_info->inputs_num = 0;\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "cmdline_parser_params_init": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "void\ncmdline_parser_params_init(struct cmdline_parser_params *params)\n{\n  if (params)\n    { \n      params->override = 0;\n      params->initialize = 1;\n      params->check_required = 1;\n      params->check_ambiguity = 0;\n      params->print_errors = 1;\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "cmdline_parser_params_create": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "struct cmdline_parser_params *\ncmdline_parser_params_create(void)\n{\n  struct cmdline_parser_params *params = \n    (struct cmdline_parser_params *)malloc(sizeof(struct cmdline_parser_params));\n  cmdline_parser_params_init(params);  \n  return params;\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "struct cmdline_parser_params",
        "struct",
        "cmdline_parser_params",
        "*\ncmdline_parser_params_create(void)",
        "*"
      ]
    },
    "cmdline_parser_release": {
      "start_point": [
        185,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "static void\ncmdline_parser_release (struct gengetopt_args_info *args_info)\n{\n  unsigned int i;\n  \n  \n  for (i = 0; i < args_info->inputs_num; ++i)\n    free (args_info->inputs [i]);\n\n  if (args_info->inputs_num)\n    free (args_info->inputs);\n\n  clear_given (args_info);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "write_into_file": {
      "start_point": [
        201,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "static void\nwrite_into_file(FILE *outfile, const char *opt, const char *arg, const char *values[])\n{\n  FIX_UNUSED (values);\n  if (arg) {\n    fprintf(outfile, \"%s=\\\"%s\\\"\\n\", opt, arg);\n  } else {\n    fprintf(outfile, \"%s\\n\", opt);\n  }\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cmdline_parser_dump": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        250,
        1
      ],
      "content": "int\ncmdline_parser_dump(FILE *outfile, struct gengetopt_args_info *args_info)\n{\n  int i = 0;\n\n  if (!outfile)\n    {\n      fprintf (stderr, \"%s: cannot dump options to stream\\n\", CMDLINE_PARSER_PACKAGE);\n      return EXIT_FAILURE;\n    }\n\n  if (args_info->help_given)\n    write_into_file(outfile, \"help\", 0, 0 );\n  if (args_info->version_given)\n    write_into_file(outfile, \"version\", 0, 0 );\n  if (args_info->decode_given)\n    write_into_file(outfile, \"decode\", 0, 0 );\n  if (args_info->lookup_given)\n    write_into_file(outfile, \"lookup\", 0, 0 );\n  if (args_info->register_given)\n    write_into_file(outfile, \"register\", 0, 0 );\n  if (args_info->tr46t_given)\n    write_into_file(outfile, \"tr46t\", 0, 0 );\n  if (args_info->tr46nt_given)\n    write_into_file(outfile, \"tr46nt\", 0, 0 );\n  if (args_info->no_tr46_given)\n    write_into_file(outfile, \"no-tr46\", 0, 0 );\n  if (args_info->usestd3asciirules_given)\n    write_into_file(outfile, \"usestd3asciirules\", 0, 0 );\n  if (args_info->debug_given)\n    write_into_file(outfile, \"debug\", 0, 0 );\n  if (args_info->quiet_given)\n    write_into_file(outfile, \"quiet\", 0, 0 );\n  \n\n  i = EXIT_SUCCESS;\n  return i;\n}",
      "lines": 38,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "cmdline_parser_file_save": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        270,
        1
      ],
      "content": "int\ncmdline_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)\n{\n  FILE *outfile;\n  int i = 0;\n\n  outfile = fopen(filename, \"w\");\n\n  if (!outfile)\n    {\n      fprintf (stderr, \"%s: cannot open file for writing: %s\\n\", CMDLINE_PARSER_PACKAGE, filename);\n      return EXIT_FAILURE;\n    }\n\n  i = cmdline_parser_dump(outfile, args_info);\n  fclose (outfile);\n\n  return i;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "cmdline_parser_free": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        276,
        1
      ],
      "content": "void\ncmdline_parser_free (struct gengetopt_args_info *args_info)\n{\n  cmdline_parser_release (args_info);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gengetopt_strdup": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "char *\ngengetopt_strdup (const char *s)\n{\n  char *result = 0;\n  if (!s)\n    return result;\n\n  result = (char*)malloc(strlen(s) + 1);\n  if (result == (char*)0)\n    return (char*)0;\n  strcpy(result, s);\n  return result;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "char",
        "*\ngengetopt_strdup (const char *s)",
        "*"
      ]
    },
    "cmdline_parser": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        297,
        1
      ],
      "content": "int\ncmdline_parser (int argc, char **argv, struct gengetopt_args_info *args_info)\n{\n  return cmdline_parser2 (argc, argv, args_info, 0, 1, 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "cmdline_parser_ext": {
      "start_point": [
        299,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "int\ncmdline_parser_ext (int argc, char **argv, struct gengetopt_args_info *args_info,\n                   struct cmdline_parser_params *params)\n{\n  int result;\n  result = cmdline_parser_internal (argc, argv, args_info, params, 0);\n\n  if (result == EXIT_FAILURE)\n    {\n      cmdline_parser_free (args_info);\n      exit (EXIT_FAILURE);\n    }\n  \n  return result;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "cmdline_parser2": {
      "start_point": [
        315,
        0
      ],
      "end_point": [
        336,
        1
      ],
      "content": "int\ncmdline_parser2 (int argc, char **argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)\n{\n  int result;\n  struct cmdline_parser_params params;\n  \n  params.override = override;\n  params.initialize = initialize;\n  params.check_required = check_required;\n  params.check_ambiguity = 0;\n  params.print_errors = 1;\n\n  result = cmdline_parser_internal (argc, argv, args_info, &params, 0);\n\n  if (result == EXIT_FAILURE)\n    {\n      cmdline_parser_free (args_info);\n      exit (EXIT_FAILURE);\n    }\n  \n  return result;\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "cmdline_parser_required": {
      "start_point": [
        338,
        0
      ],
      "end_point": [
        344,
        1
      ],
      "content": "int\ncmdline_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)\n{\n  FIX_UNUSED (args_info);\n  FIX_UNUSED (prog_name);\n  return EXIT_SUCCESS;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "update_arg": {
      "start_point": [
        367,
        0
      ],
      "end_point": [
        437,
        1
      ],
      "content": "static\nint update_arg(void *field, char **orig_field,\n               unsigned int *field_given, unsigned int *prev_given, \n               char *value, const char *possible_values[],\n               const char *default_value,\n               cmdline_parser_arg_type arg_type,\n               int check_ambiguity, int override,\n               int no_free, int multiple_option,\n               const char *long_opt, char short_opt,\n               const char *additional_error)\n{\n  char *stop_char = 0;\n  const char *val = value;\n  int found;\n  FIX_UNUSED (field);\n\n  stop_char = 0;\n  found = 0;\n\n  if (!multiple_option && prev_given && (*prev_given || (check_ambiguity && *field_given)))\n    {\n      if (short_opt != '-')\n        fprintf (stderr, \"%s: `--%s' (`-%c') option given more than once%s\\n\", \n               package_name, long_opt, short_opt,\n               (additional_error ? additional_error : \"\"));\n      else\n        fprintf (stderr, \"%s: `--%s' option given more than once%s\\n\", \n               package_name, long_opt,\n               (additional_error ? additional_error : \"\"));\n      return 1; /* failure */\n    }\n\n  FIX_UNUSED (default_value);\n    \n  if (field_given && *field_given && ! override)\n    return 0;\n  if (prev_given)\n    (*prev_given)++;\n  if (field_given)\n    (*field_given)++;\n  if (possible_values)\n    val = possible_values[found];\n\n  switch(arg_type) {\n  case ARG_FLAG:\n    *((int *)field) = !*((int *)field);\n    break;\n  default:\n    break;\n  };\n\n\n  /* store the original value */\n  switch(arg_type) {\n  case ARG_NO:\n  case ARG_FLAG:\n    break;\n  default:\n    if (value && orig_field) {\n      if (no_free) {\n        *orig_field = value;\n      } else {\n        if (*orig_field)\n          free (*orig_field); /* free previous string */\n        *orig_field = gengetopt_strdup (value);\n      }\n    }\n  };\n\n  return 0; /* OK */\n}",
      "lines": 71,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cmdline_parser_internal": {
      "start_point": [
        440,
        0
      ],
      "end_point": [
        681,
        1
      ],
      "content": "int\ncmdline_parser_internal (\n  int argc, char **argv, struct gengetopt_args_info *args_info,\n                        struct cmdline_parser_params *params, const char *additional_error)\n{\n  int c;\t/* Character of the parsed option.  */\n\n  int error_occurred = 0;\n  struct gengetopt_args_info local_args_info;\n  \n  int override;\n  int initialize;\n  int check_required;\n  int check_ambiguity;\n  \n  package_name = argv[0];\n  \n  override = params->override;\n  initialize = params->initialize;\n  check_required = params->check_required;\n  check_ambiguity = params->check_ambiguity;\n\n  if (initialize)\n    cmdline_parser_init (args_info);\n\n  cmdline_parser_init (&local_args_info);\n\n  optarg = 0;\n  optind = 0;\n  opterr = params->print_errors;\n  optopt = '?';\n\n  while (1)\n    {\n      int option_index = 0;\n\n      static struct option long_options[] = {\n        { \"help\",\t0, NULL, 'h' },\n        { \"version\",\t0, NULL, 'V' },\n        { \"decode\",\t0, NULL, 'd' },\n        { \"lookup\",\t0, NULL, 'l' },\n        { \"register\",\t0, NULL, 'r' },\n        { \"tr46t\",\t0, NULL, 'T' },\n        { \"tr46nt\",\t0, NULL, 'N' },\n        { \"no-tr46\",\t0, NULL, 0 },\n        { \"usestd3asciirules\",\t0, NULL, 0 },\n        { \"debug\",\t0, NULL, 0 },\n        { \"quiet\",\t0, NULL, 0 },\n        { 0,  0, 0, 0 }\n      };\n\n      c = getopt_long (argc, argv, \"hVdlrTN\", long_options, &option_index);\n\n      if (c == -1) break;\t/* Exit from `while (1)' loop.  */\n\n      switch (c)\n        {\n        case 'h':\t/* Print help and exit.  */\n        \n        \n          if (update_arg( 0 , \n               0 , &(args_info->help_given),\n              &(local_args_info.help_given), optarg, 0, 0, ARG_NO,\n              check_ambiguity, override, 0, 0,\n              \"help\", 'h',\n              additional_error))\n            goto failure;\n          cmdline_parser_free (&local_args_info);\n          return 0;\n        \n          break;\n        case 'V':\t/* Print version and exit.  */\n        \n        \n          if (update_arg( 0 , \n               0 , &(args_info->version_given),\n              &(local_args_info.version_given), optarg, 0, 0, ARG_NO,\n              check_ambiguity, override, 0, 0,\n              \"version\", 'V',\n              additional_error))\n            goto failure;\n          cmdline_parser_free (&local_args_info);\n          return 0;\n        \n          break;\n        case 'd':\t/* Decode (punycode) domain name.  */\n        \n        \n          if (update_arg( 0 , \n               0 , &(args_info->decode_given),\n              &(local_args_info.decode_given), optarg, 0, 0, ARG_NO,\n              check_ambiguity, override, 0, 0,\n              \"decode\", 'd',\n              additional_error))\n            goto failure;\n        \n          break;\n        case 'l':\t/* Lookup domain name (default).  */\n        \n        \n          if (update_arg( 0 , \n               0 , &(args_info->lookup_given),\n              &(local_args_info.lookup_given), optarg, 0, 0, ARG_NO,\n              check_ambiguity, override, 0, 0,\n              \"lookup\", 'l',\n              additional_error))\n            goto failure;\n        \n          break;\n        case 'r':\t/* Register label.  */\n        \n        \n          if (update_arg( 0 , \n               0 , &(args_info->register_given),\n              &(local_args_info.register_given), optarg, 0, 0, ARG_NO,\n              check_ambiguity, override, 0, 0,\n              \"register\", 'r',\n              additional_error))\n            goto failure;\n        \n          break;\n        case 'T':\t/* Enable TR46 transitional processing.  */\n        \n        \n          if (update_arg((void *)&(args_info->tr46t_flag), 0, &(args_info->tr46t_given),\n              &(local_args_info.tr46t_given), optarg, 0, 0, ARG_FLAG,\n              check_ambiguity, override, 1, 0, \"tr46t\", 'T',\n              additional_error))\n            goto failure;\n        \n          break;\n        case 'N':\t/* Enable TR46 non-transitional processing.  */\n        \n        \n          if (update_arg((void *)&(args_info->tr46nt_flag), 0, &(args_info->tr46nt_given),\n              &(local_args_info.tr46nt_given), optarg, 0, 0, ARG_FLAG,\n              check_ambiguity, override, 1, 0, \"tr46nt\", 'N',\n              additional_error))\n            goto failure;\n        \n          break;\n\n        case 0:\t/* Long option with no short option */\n          /* Disable TR46 processing.  */\n          if (strcmp (long_options[option_index].name, \"no-tr46\") == 0)\n          {\n          \n          \n            if (update_arg((void *)&(args_info->no_tr46_flag), 0, &(args_info->no_tr46_given),\n                &(local_args_info.no_tr46_given), optarg, 0, 0, ARG_FLAG,\n                check_ambiguity, override, 1, 0, \"no-tr46\", '-',\n                additional_error))\n              goto failure;\n          \n          }\n          /* Enable STD3 ASCII rules.  */\n          else if (strcmp (long_options[option_index].name, \"usestd3asciirules\") == 0)\n          {\n          \n          \n            if (update_arg((void *)&(args_info->usestd3asciirules_flag), 0, &(args_info->usestd3asciirules_given),\n                &(local_args_info.usestd3asciirules_given), optarg, 0, 0, ARG_FLAG,\n                check_ambiguity, override, 1, 0, \"usestd3asciirules\", '-',\n                additional_error))\n              goto failure;\n          \n          }\n          /* Print debugging information.  */\n          else if (strcmp (long_options[option_index].name, \"debug\") == 0)\n          {\n          \n          \n            if (update_arg((void *)&(args_info->debug_flag), 0, &(args_info->debug_given),\n                &(local_args_info.debug_given), optarg, 0, 0, ARG_FLAG,\n                check_ambiguity, override, 1, 0, \"debug\", '-',\n                additional_error))\n              goto failure;\n          \n          }\n          /* Silent operation.  */\n          else if (strcmp (long_options[option_index].name, \"quiet\") == 0)\n          {\n          \n          \n            if (update_arg((void *)&(args_info->quiet_flag), 0, &(args_info->quiet_given),\n                &(local_args_info.quiet_given), optarg, 0, 0, ARG_FLAG,\n                check_ambiguity, override, 1, 0, \"quiet\", '-',\n                additional_error))\n              goto failure;\n          \n          }\n          \n          break;\n        case '?':\t/* Invalid option.  */\n          /* `getopt_long' already printed an error message.  */\n          goto failure;\n\n        default:\t/* bug: option not considered.  */\n          fprintf (stderr, \"%s: option unknown: %c%s\\n\", CMDLINE_PARSER_PACKAGE, c, (additional_error ? additional_error : \"\"));\n          abort ();\n        } /* switch */\n    } /* while */\n\n\n\n\n  cmdline_parser_release (&local_args_info);\n\n  if ( error_occurred )\n    return (EXIT_FAILURE);\n\n  if (optind < argc)\n    {\n      int i = 0 ;\n      int found_prog_name = 0;\n      /* whether program name, i.e., argv[0], is in the remaining args\n         (this may happen with some implementations of getopt,\n          but surely not with the one included by gengetopt) */\n\n      i = optind;\n      while (i < argc)\n        if (argv[i++] == argv[0]) {\n          found_prog_name = 1;\n          break;\n        }\n      i = 0;\n\n      args_info->inputs_num = argc - optind - found_prog_name;\n      args_info->inputs =\n        (char **)(malloc ((args_info->inputs_num)*sizeof(char *))) ;\n      while (optind < argc)\n        if (argv[optind++] != argv[0])\n          args_info->inputs[ i++ ] = gengetopt_strdup (argv[optind-1]) ;\n    }\n\n  return 0;\n\nfailure:\n  \n  cmdline_parser_release (&local_args_info);\n  return (EXIT_FAILURE);\n}",
      "lines": 242,
      "depth": 21,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/src/idn2_cmd.h": {},
  "libidn/libidn2-2.0.5/tests/test-lookup.c": {
    "_nextField": {
      "start_point": [
        841,
        0
      ],
      "end_point": [
        860,
        1
      ],
      "content": "static char *_nextField(char **line)\n{\n  char *s = *line, *e;\n\n  if (!*s)\n    return NULL;\n\n  if (!(e = strpbrk(s, \";#\"))) {\n    e = *line += strlen(s);\n  } else {\n    *line = e + (*e == ';');\n    *e = 0;\n  }\n\n  // trim leading and trailing whitespace\n  while (isspace(*s)) s++;\n  while (e > s && isspace(e[-1])) *--e = 0;\n\n  return s;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*_nextField(char **line)",
        "*"
      ]
    },
    "_scan_file": {
      "start_point": [
        862,
        0
      ],
      "end_point": [
        894,
        1
      ],
      "content": "static int _scan_file(const char *fname, int(*scan)(char *))\n{\n  FILE *fp = fopen(fname, \"r\");\n  char *buf = NULL, *linep;\n  size_t bufsize = 0;\n  ssize_t buflen;\n  int ret = 0;\n\n  if (!fp) {\n    fprintf(stderr, \"Failed to open %s (%d)\\n\", fname, errno);\n    return -1;\n  }\n\n  while ((buflen = getline(&buf, &bufsize, fp)) >= 0) {\n    linep = buf;\n\n    while (isspace(*linep)) linep++; // ignore leading whitespace\n\n    // strip off \\r\\n\n    while (buflen > 0 && (buf[buflen] == '\\n' || buf[buflen] == '\\r'))\n      buf[--buflen] = 0;\n\n    if (!*linep || *linep == '#') continue; // skip empty lines and comments\n\n    if ((ret = scan(linep)))\n      break;\n  }\n\n  free(buf);\n  fclose(fp);\n\n  return ret;\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_homebrewed": {
      "start_point": [
        896,
        0
      ],
      "end_point": [
        1041,
        1
      ],
      "content": "static void\ntest_homebrewed(void)\n{\n  uint32_t dummy_u32[4] = { 'a', 'b', 'c', 0 };\n  uint8_t *out;\n  char outbuf[4];\n  size_t i;\n  int rc;\n\n  for (i = 0; i < sizeof (idna) / sizeof (idna[0]); i++)\n    {\n      rc = idn2_lookup_u8 ((uint8_t *) idna[i].in, &out, idna[i].flags);\n      printf (\"%3d  %-25s %-40s %s\\n\", (int) i, idn2_strerror_name (rc),\n\t      rc == IDN2_OK ? idna[i].out : \"\", idna[i].in);\n\n      if (rc != idna[i].rc && rc == IDN2_ENCODING_ERROR) {\n\tprintf(\"utc bug\\n\");\n      } else if (rc != idna[i].rc && idna[i].rc != -1) {\n\tfailed++;\n\tprintf(\"expected rc %d got rc %d\\n\", idna[i].rc, rc);\n      } else if (rc == IDN2_OK && strcmp ((char *) out, idna[i].out) != 0) {\n\tfailed++;\n\tprintf(\"expected: %s\\ngot: %s\\n\", idna[i].out, out);\n      } else\n\tok++;\n\n      if (rc == IDN2_OK)\n\tidn2_free (out);\n\n      /* Try the IDN2_NO_TR46 flag behavior */\n      if (!(idna[i].flags & (IDN2_NONTRANSITIONAL|IDN2_TRANSITIONAL))) {\n\trc = idn2_lookup_u8 ((uint8_t *) idna[i].in, &out, idna[i].flags|IDN2_NO_TR46);\n\tprintf (\"%3d  %-25s %-40s %s\\n\", (int) i, idn2_strerror_name (rc),\n\t        rc == IDN2_OK ? idna[i].out : \"\", idna[i].in);\n\n        if (rc != idna[i].rc && rc == IDN2_ENCODING_ERROR) {\n\t  printf(\"utc bug\\n\");\n\t} else if (rc != idna[i].rc && idna[i].rc != -1) {\n\t  failed++;\n\t  printf(\"expected rc %d got rc %d\\n\", idna[i].rc, rc);\n        } else if (rc == IDN2_OK && strcmp ((char *) out, idna[i].out) != 0) {\n\t  failed++;\n\t  printf(\"expected: %s\\ngot: %s\\n\", idna[i].out, out);\n        } else\n\t  ok++;\n\n        if (rc == IDN2_OK)\n\t  idn2_free (out);\n      }\n\n      /* Try whether the default flags behave as NONTRANSITIONAL */\n      if (!(idna[i].flags & (IDN2_NO_TR46|IDN2_TRANSITIONAL))) {\n\trc = idn2_lookup_u8 ((uint8_t *) idna[i].in, &out, idna[i].flags|IDN2_NONTRANSITIONAL);\n\tprintf (\"%3d  %-25s %-40s %s\\n\", (int) i, idn2_strerror_name (rc),\n\t        rc == IDN2_OK ? idna[i].out : \"\", idna[i].in);\n\n        if (rc != idna[i].rc && rc == IDN2_ENCODING_ERROR) {\n\t  printf(\"utc bug\\n\");\n\t} else if (rc != idna[i].rc && idna[i].rc != -1) {\n\t  failed++;\n\t  printf(\"expected rc %d got rc %d\\n\", idna[i].rc, rc);\n        } else if (rc == IDN2_OK && strcmp ((char *) out, idna[i].out) != 0) {\n\t  failed++;\n\t  printf(\"expected: %s\\ngot: %s\\n\", idna[i].out, out);\n        } else\n\t  ok++;\n\n        if (rc == IDN2_OK)\n\t  idn2_free (out);\n      }\n\n      if (failed && break_on_error)\n\texit (EXIT_FAILURE);\n    }\n\n  /* special calls to cover edge cases */\n  if ((rc = idn2_lookup_u8 (NULL, NULL, 0)) != IDN2_OK) {\n    failed++;\n    printf(\"special #1 failed with %d\\n\", rc);\n  } else\n    ok++;\n\n  out = (uint8_t *) 0x123;\n  if ((rc = idn2_lookup_u8 (NULL, &out, 0)) != IDN2_OK) {\n    failed++;\n    printf(\"special #2 failed with %d\\n\", rc);\n  } else if (out) {\n    failed++;\n    printf(\"special #2 failed with out!=NULL\\n\");\n  } else\n    ok++;\n\n  if ((rc = idn2_lookup_ul (NULL, NULL, 0)) != IDN2_OK) {\n    failed++;\n    printf(\"special #3 failed with %d\\n\", rc);\n  } else\n    ok++;\n\n  out = (uint8_t *) 0x123;\n  if ((rc = idn2_lookup_ul (NULL, (char **) &out, 0)) != IDN2_OK) {\n    failed++;\n    printf(\"special #4 failed with %d\\n\", rc);\n  } else if (out) {\n    failed++;\n    printf(\"special #4 failed with out!=NULL\\n\");\n  } else\n    ok++;\n\n  if ((rc = idn2_lookup_ul (\"abc\", NULL, 0)) != IDN2_OK) {\n    failed++;\n    printf(\"special #5 failed with %d\\n\", rc);\n  } else\n    ok++;\n\n  /* test libidn compatibility functions */\n  if ((rc = idna_to_ascii_lz (\"abc\", (char **) &out, 0)) != IDN2_OK) {\n    failed++;\n    printf(\"special #6 failed with %d\\n\", rc);\n  } else {\n    idn2_free (out);\n    ok++;\n  }\n\n  if ((rc = idna_to_ascii_8z (\"abc\", (char **) &out, 0)) != IDN2_OK) {\n    failed++;\n    printf(\"special #7 failed with %d\\n\", rc);\n  } else {\n    idn2_free (out);\n    ok++;\n  }\n\n  if ((rc = idna_to_ascii_4z (dummy_u32, (char **) &out, 0)) != IDN2_OK) {\n    failed++;\n    printf(\"special #8 failed with %d\\n\", rc);\n  } else {\n    idn2_free (out);\n    ok++;\n  }\n\n  if ((rc = idna_to_ascii_4i (dummy_u32, 4, outbuf, 0)) != IDN2_OK) {\n    failed++;\n    printf(\"special #9 failed with %d\\n\", rc);\n  } else {\n    ok++;\n  }\n}",
      "lines": 146,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_decodeIdnaTest": {
      "start_point": [
        1044,
        0
      ],
      "end_point": [
        1099,
        1
      ],
      "content": "static char *\n_decodeIdnaTest(uint8_t *src_u8)\n{\n  size_t it2 = 0, len;\n  uint32_t *src;\n\n  // convert UTF-8 to UCS-4 (Unicode))\n  if (!(src = u8_to_u32(src_u8, u8_strlen(src_u8) + 1, NULL, &len))) {\n    printf(\"u8_to_u32(%s) failed (%d)\\n\", src_u8, errno);\n    return NULL;\n  }\n\n  // replace escaped UTF-16 incl. surrogates\n  for (size_t it = 0; it < len;) {\n    if (src[it] == '\\\\' && src[it + 1] == 'u') {\n      src[it2] =\n\t((src[it + 2] >= 'A' ? src[it + 2] - 'A' + 10 : src[it + 2] - '0') << 12) +\n\t((src[it + 3] >= 'A' ? src[it + 3] - 'A' + 10 : src[it + 3] - '0') << 8) +\n\t((src[it + 4] >= 'A' ? src[it + 4] - 'A' + 10 : src[it + 4] - '0') << 4) +\n\t(src[it + 5] >= 'A' ? src[it + 5] - 'A' + 10 : src[it + 5] - '0');\n      it += 6;\n\n      if (src[it2] >= 0xD800 && src[it2] <= 0xDBFF) {\n\t// high surrogate followed by low surrogate\n\tif (src[it] == '\\\\' && src[it + 1] == 'u') {\n\t  uint32_t low =\n\t    ((src[it + 2] >= 'A' ? src[it + 2] - 'A' + 10 : src[it + 2] - '0') << 12) +\n\t    ((src[it + 3] >= 'A' ? src[it + 3] - 'A' + 10 : src[it + 3] - '0') << 8) +\n\t    ((src[it + 4] >= 'A' ? src[it + 4] - 'A' + 10 : src[it + 4] - '0') << 4) +\n\t    (src[it + 5] >= 'A' ? src[it + 5] - 'A' + 10 : src[it + 5] - '0');\n\t  if (low >= 0xDC00 && low <= 0xDFFF)\n\t    src[it2] = 0x10000 + (src[it2] - 0xD800) * 0x400 + (low - 0xDC00);\n\t  else\n\t    printf(\"Missing low surrogate\\n\");\n\t  it += 6;\n\t} else {\n\t  it++;\n\t  printf(\"Missing low surrogate\\n\");\n\t}\n      }\n      it2++;\n    } else\n      src[it2++] = src[it++];\n  }\n\n  // convert UTF-32 to UTF-8\n  uint8_t *tmp=src_u8;\n  src_u8 = u32_to_u8(src, it2, NULL, &len);\n  free(src);\n  if (!src_u8) {\n    printf(\"u32_to_u8(%s) failed (%d)\\n\", tmp, errno);\n    return NULL;\n  }\n\n  return (char *) src_u8;\n}",
      "lines": 56,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "char",
        "*\n_decodeIdnaTest(uint8_t *src_u8)",
        "*"
      ]
    },
    "_check_toASCII": {
      "start_point": [
        1101,
        0
      ],
      "end_point": [
        1126,
        1
      ],
      "content": "static void\n_check_toASCII(char *source, char *expected, int transitional, int expected_toASCII_failure)\n{\n  int rc;\n  char *ace = NULL;\n\n  rc = idn2_lookup_u8 ((uint8_t *) source, (uint8_t **) &ace, transitional ? IDN2_TRANSITIONAL : IDN2_NONTRANSITIONAL);\n\n  // printf(\"n=%d expected=%s t=%d got=%s, expected_failure=%d\\n\", n, expected, transitional, ace ? ace : \"\", expected_toASCII_failure);\n  if (rc && expected_toASCII_failure) {\n    printf(\"OK\\n\");\n    ok++;\n  } else if (rc && !transitional && *expected != '[') {\n    failed++;\n    printf(\"Failed: _check_toASCII(%s) -> %d (expected 0) %p\\n\", source, rc, ace);\n  } else if (rc == 0 && !transitional && *expected != '[' && strcmp(expected, ace)) {\n    failed++;\n    printf(\"Failed: _check_toASCII(%s) -> %s (expected %s) %p\\n\", source, ace, expected, ace);\n  } else {\n    printf(\"OK\\n\");\n    ok++;\n  }\n\n  if (rc == IDN2_OK)\n    idn2_free(ace);\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_IdnaTest": {
      "start_point": [
        1128,
        0
      ],
      "end_point": [
        1186,
        1
      ],
      "content": "static int\ntest_IdnaTest(char *linep)\n{\n  char *type, *source, *toUnicode, *toASCII, *NV8, *org_source;\n  int expected_toASCII_failure;\n#if HAVE_LIBUNISTRING\n  extern int _libunistring_version;\n#endif\n\n  type = _nextField(&linep);\n  org_source = source = _nextField(&linep);\n  toUnicode = _nextField(&linep);\n  toASCII = _nextField(&linep);\n  NV8 = _nextField(&linep); // if set, the input should be disallowed for IDNA2008\n\n  // sigh, these Unicode people really mix UTF-8 and UCS-2/4\n  // quick and dirty translation of '\\uXXXX' found in IdnaTest.txt including surrogate handling\n  source = _decodeIdnaTest((uint8_t *) source);\n  if (!source)\n    return 0; // some Unicode sequences can't be encoded into UTF-8, skip them\n\n  if (!*toUnicode)\n    toUnicode = source;\n  if (!*toASCII)\n    toASCII = toUnicode;\n  expected_toASCII_failure = NV8 && *NV8;\n\n  printf(\"##########%s#%s#%s#%s#%s#\\n\", type, org_source, toUnicode, toASCII, NV8);\n\n#if HAVE_LIBUNISTRING\n  /* 3 tests fail with libunicode <= 0.9.3 - just skip them until we have a newer version installed */\n  /* watch out, libunicode changed versioning scheme up from 0.9.4 */\n  /* If !HAVE_LIBUNISTRING, we use internal gnulib code which works. */\n  if (_libunistring_version <= 9) {\n    if (!strcmp(toASCII, \"xn--8jb.xn--etb875g\")) {\n      free(source);\n      return 0;\n    }\n  }\n#endif\n\n  if (*type == 'B') {\n    _check_toASCII(source, toASCII, 1, expected_toASCII_failure);\n    _check_toASCII(source, toASCII, 0, expected_toASCII_failure);\n  } else if (*type == 'T') {\n    _check_toASCII(source, toASCII, 1, expected_toASCII_failure);\n  } else if (*type == 'N') {\n    _check_toASCII(source, toASCII, 0, expected_toASCII_failure);\n  } else {\n    printf(\"Failed: Unknown type '%s'\\n\", type);\n  }\n\n  free(source);\n\n  if (failed && break_on_error)\n    return 1;\n\n  return 0;\n}",
      "lines": 59,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "separator": {
      "start_point": [
        1188,
        0
      ],
      "end_point": [
        1193,
        1
      ],
      "content": "static void\nseparator(void)\n{\n  puts (\"-----------------------------------------------------------\"\n\t\"-------------------------------------\");\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_unicode_range": {
      "start_point": [
        1195,
        0
      ],
      "end_point": [
        1233,
        1
      ],
      "content": "static void\ntest_unicode_range (void)\n{\n  uint32_t i, ucs4[2];\n  uint8_t *utf8, *out;\n  size_t len;\n  int rc;\n\n  /* Unicode range is 0-0x10FFFF, go a bit further */\n  for (i = 0; i < 0x11FFFF; i++)\n  {\n    ucs4[0] = i;\n    ucs4[1] = 0;\n\n    utf8 = u32_to_u8 (ucs4, 2, NULL, &len);\n\n    rc = idn2_lookup_u8 (utf8, &out, 0);\n    if (rc == IDN2_OK)\n      idn2_free (out);\n\n    rc = idn2_lookup_u8 (utf8, &out, IDN2_NFC_INPUT);\n    if (rc == IDN2_OK)\n      idn2_free (out);\n\n    rc = idn2_lookup_u8 (utf8, &out, IDN2_TRANSITIONAL);\n    if (rc == IDN2_OK)\n      idn2_free (out);\n\n    rc = idn2_lookup_u8 (utf8, &out, IDN2_NONTRANSITIONAL);\n    if (rc == IDN2_OK)\n      idn2_free (out);\n\n    rc = idn2_lookup_u8 (utf8, &out, IDN2_NO_TR46);\n    if (rc == IDN2_OK)\n      idn2_free (out);\n\n    free (utf8);\n  }\n}",
      "lines": 39,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        1235,
        0
      ],
      "end_point": [
        1264,
        1
      ],
      "content": "int\nmain (int argc, const char *argv[])\n{\n  separator ();\n  puts (\"                                          IDNA2008 Lookup\\n\");\n  puts (\"  #  Result                    ACE output                  \"\n\t\"             Unicode input\");\n  separator();\n\n  test_homebrewed ();\n\n  separator();\n\n  // test all IDNA cases from Unicode 9.0.0\n  if (_scan_file(argc == 1 ? SRCDIR\"/IdnaTest.txt\" : argv[1], test_IdnaTest))\n    return EXIT_FAILURE;\n\n  separator();\n\n  test_unicode_range ();\n\n  if (failed) {\n    printf(\"Summary: %d out of %d tests failed\\n\", failed, ok + failed);\n    return EXIT_FAILURE;\n  }\n\n  printf(\"Summary: All %d tests passed\\n\", ok + failed);\n\n  return EXIT_SUCCESS;\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/tests/test-punycode.c": {
    "fail": {
      "start_point": [
        169,
        35
      ],
      "end_point": [
        180,
        1
      ],
      "content": "static void\nfail (const char *format, ...)\n{\n  va_list arg_ptr;\n\n  va_start (arg_ptr, format);\n  vfprintf (stderr, format, arg_ptr);\n  va_end (arg_ptr);\n  error_count++;\n  if (break_on_error)\n    exit (EXIT_FAILURE);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ucs4print": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "static void\nucs4print (const uint32_t * str, size_t len)\n{\n  size_t i;\n\n  printf (\"\\t;; \");\n  for (i = 0; i < len; i++)\n    {\n      printf (\"U+%04x \", str[i]);\n      if ((i + 1) % 4 == 0)\n\tprintf (\" \");\n      if ((i + 1) % 8 == 0 && i + 1 < len)\n\tprintf (\"\\n\\t;; \");\n    }\n  puts (\"\");\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        201,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "int\nmain (void)\n{\n  char *p;\n  uint32_t *q;\n  int rc;\n  size_t i, outlen;\n\n  if (!idn2_check_version (IDN2_VERSION))\n    fail (\"idn2_check_version(%s) failed\\n\", IDN2_VERSION);\n\n  if (!idn2_check_version (NULL))\n    fail (\"idn2_check_version(NULL) failed\\n\");\n\n  if (idn2_check_version (\"100.100\"))\n    fail (\"idn2_check_version(\\\"100.100\\\") failed\\n\");\n\n  p = (char *) malloc (sizeof (*p) * BUFSIZ);\n  if (p == NULL)\n    fail (\"malloc() returned NULL\\n\");\n\n  q = (uint32_t *) malloc (sizeof (*q) * BUFSIZ);\n  if (q == NULL)\n    fail (\"malloc() returned NULL\\n\");\n\n  for (i = 0; i < sizeof (punycode) / sizeof (punycode[0]); i++)\n    {\n      if (debug)\n\tprintf (\"PUNYCODE entry %d: %s\\n\", (int) i, punycode[i].name);\n\n      if (debug)\n\t{\n\t  printf (\"in:\\n\");\n\t  ucs4print (punycode[i].in, punycode[i].inlen);\n\t}\n\n      outlen = BUFSIZ;\n      rc = _idn2_punycode_encode (\n\tpunycode[i].inlen, punycode[i].in, &outlen, p);\n      if (rc != punycode[i].rc)\n\t{\n\t  fail (\"punycode_encode() entry %d failed: %d\\n\", (int) i, rc);\n\t  if (debug)\n\t    printf (\"FATAL\\n\");\n\t  continue;\n\t}\n\n      if (rc == IDN2_OK)\n\tp[outlen] = '\\0';\n\n      if (debug && rc == IDN2_OK)\n\t{\n\t  printf (\"computed out: %s\\n\", p);\n\t  printf (\"expected out: %s\\n\", punycode[i].out);\n\t}\n      else if (debug)\n\tprintf (\"returned %d expected %d\\n\", rc, punycode[i].rc);\n\n      if (rc == IDN2_OK)\n\t{\n\t  if (strlen (punycode[i].out) != strlen (p) ||\n\t      memcmp (punycode[i].out, p, strlen (p)) != 0)\n\t    {\n\t      fail (\"punycode() entry %d failed\\n\", (int) i);\n\t      if (debug)\n\t\tprintf (\"ERROR\\n\");\n\t    }\n\t  else if (debug)\n\t    printf (\"OK\\n\\n\");\n\t}\n      else if (debug)\n\tprintf (\"OK\\n\\n\");\n\n      if (debug)\n\t{\n\t  printf (\"in: %s\\n\", punycode[i].out);\n\t}\n\n      outlen = BUFSIZ;\n      rc = _idn2_punycode_decode (strlen (punycode[i].out), punycode[i].out,\n\t\t\t\t    &outlen, q);\n      if (rc != punycode[i].rc)\n\t{\n\t  fail (\"punycode() entry %d failed: %d\\n\", (int) i, rc);\n\t  if (debug)\n\t    printf (\"FATAL\\n\");\n\t  continue;\n\t}\n\n      if (debug && rc == IDN2_OK)\n\t{\n\t  printf (\"computed out:\\n\");\n\t  ucs4print (q, outlen);\n\t  printf (\"expected out:\\n\");\n\t  ucs4print (punycode[i].in, punycode[i].inlen);\n\t}\n      else if (debug)\n\tprintf (\"returned %d expected %d\\n\", rc, punycode[i].rc);\n\n      if (rc == IDN2_OK)\n\t{\n\t  if (punycode[i].inlen != outlen ||\n\t      memcmp (punycode[i].in, q, outlen) != 0)\n\t    {\n\t      fail (\"punycode_decode() entry %d failed\\n\", (int) i);\n\t      if (debug)\n\t\tprintf (\"ERROR\\n\");\n\t    }\n\t  else if (debug)\n\t    printf (\"OK\\n\\n\");\n\t}\n      else if (debug)\n\tprintf (\"OK\\n\\n\");\n    }\n\n  free (q);\n  free (p);\n\n  return 0;\n}",
      "lines": 120,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/tests/test-register.c": {
    "fail": {
      "start_point": [
        97,
        35
      ],
      "end_point": [
        108,
        1
      ],
      "content": "static void\nfail (const char *format, ...)\n{\n  va_list arg_ptr;\n\n  va_start (arg_ptr, format);\n  vfprintf (stderr, format, arg_ptr);\n  va_end (arg_ptr);\n  error_count++;\n  if (break_on_error)\n    exit (EXIT_FAILURE);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "int\nmain (void)\n{\n  uint8_t *out;\n  unsigned i;\n  int rc;\n\n  puts (\"-----------------------------------------------------------\"\n\t\"-------------------------------------\");\n  puts (\"                                          IDNA2008 Register\\n\");\n  puts (\"  #  Result                    Output                    A-label\"\n\t\" input             U-label input\");\n  puts (\"-----------------------------------------------------------\"\n\t\"-------------------------------------\");\n  for (i = 0; i < sizeof (idna) / sizeof (idna[0]); i++)\n    {\n      out = (uint8_t *) 0x1234;\n      rc = idn2_register_u8 ((uint8_t*)idna[i].ulabel, (uint8_t*)idna[i].alabel,\n\t\t\t     &out, idna[i].flags);\n      printf (\"%3u  %-25s %-25s %-25s %s\\n\", i, idn2_strerror_name (rc),\n\t      rc == IDN2_OK ? idna[i].out : \"\",\n\t      idna[i].alabel ? idna[i].alabel : \"(null)\",\n\t      idna[i].ulabel ? idna[i].ulabel : \"(null)\");\n      if (rc != idna[i].rc)\n\tfail (\"expected rc %d got rc %d\\n\", idna[i].rc, rc);\n      else if (rc == IDN2_OK && strcmp ((char*)out, idna[i].out) != 0)\n\tfail (\"expected: %s\\ngot: %s\\n\", idna[i].out, out);\n\n      if (rc == IDN2_OK)\n\t{\n\t  uint8_t *tmp;\n\n\t  if (out == (void *) 0x1234)\n\t    fail (\"out has not been set\");\n\n\t  rc = idn2_lookup_u8 ((uint8_t*)idna[i].ulabel, &tmp, idna[i].flags);\n\t  if (rc != IDN2_OK)\n\t    fail (\"lookup failed?! tv %u\", i);\n\t  if (strcmp ((char*)out, (char*)tmp) != 0)\n\t    fail (\"lookup and register different? lookup %s register %s\\n\",\n\t\t  tmp, out);\n\t  idn2_free (tmp);\n\t  idn2_free (out);\n\t}\n      else\n\t{\n\t  if (out != (void *) 0x1234)\n\t    fail (\"out has been tainted on error\");\n\t}\n    }\n  puts (\"-----------------------------------------------------------\"\n\t\"-------------------------------------\");\n\n  /* special calls to cover edge cases */\n  if ((rc = idn2_register_u8 (NULL, NULL, NULL, 0)) != IDN2_OK)\n    fail (\"special #1 failed with %d\\n\", rc);\n\n  out = (uint8_t *) 0x123;\n  if ((rc = idn2_register_u8 (NULL, NULL, &out, 0)) != IDN2_OK)\n    fail (\"special #2 failed with %d\\n\", rc);\n  if (out)\n    fail (\"special #2 failed with out!=NULL\\n\");\n\n  if ((rc = idn2_register_u8 (NULL, (uint8_t*)\"xn+-xxx\", &out, 0)) != IDN2_INVALID_ALABEL)\n    fail (\"special #3 failed with %d\\n\", rc);\n  if (out)\n    fail (\"special #3 failed with out!=NULL\\n\");\n\n  if ((rc = idn2_register_u8 (NULL, (uint8_t*)\"xn--\\xff\", &out, 0)) != IDN2_INVALID_ALABEL)\n    fail (\"special #4 failed with %d\\n\", rc);\n  if (out)\n    fail (\"special #4 failed with out!=NULL\\n\");\n\n  if ((rc = idn2_register_ul (NULL, NULL, NULL, 0)) != IDN2_OK)\n    fail (\"special #5 failed with %d\\n\", rc);\n\n  if ((rc = idn2_register_ul (\"foo\", NULL, NULL, 0)) != IDN2_OK)\n    fail (\"special #6 failed with %d\\n\", rc);\n\n  if ((rc = idn2_register_u8 ((uint8_t*)\"fa\u00c3\u009f\", NULL, NULL, IDN2_NFC_INPUT)) != IDN2_OK)\n    fail (\"special #7 failed with %d\\n\", rc);\n\n  return error_count;\n}",
      "lines": 84,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/tests/test-strerror.c": {
    "main": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int\nmain (void)\n{\n  int i, failed = 0;\n\n  /* just cover the code paths in idn2_strerror/idn2_strerror_name */\n  for (i = -1000; i <= 1000; i++)\n    {\n      if (!idn2_strerror (i))\n\tfailed++;\n      if (!idn2_strerror_name (i))\n\tfailed++;\n    }\n\n  return !!failed;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/tests/test-tounicode.c": {
    "fail": {
      "start_point": [
        358,
        35
      ],
      "end_point": [
        371,
        1
      ],
      "content": "static void\nfail (const char *format, ...)\n{\n  va_list arg_ptr;\n\n  va_start (arg_ptr, format);\n  vfprintf (stderr, format, arg_ptr);\n  va_end (arg_ptr);\n\n  error_count++;\n\n  if (break_on_error)\n    exit (EXIT_FAILURE);\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ucs4print": {
      "start_point": [
        373,
        0
      ],
      "end_point": [
        383,
        1
      ],
      "content": "static void\nucs4print (const uint32_t * str, size_t len)\n{\n  size_t i;\n\n  for (i = 0; i < len; i++)\n    printf (\"U+%04x%s\", str[i], (i + 1) % 8 ? \" \" : \"\\n\");\n\n  if (len % 8)\n    printf (\"\\n\");\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_u32_strlen": {
      "start_point": [
        385,
        0
      ],
      "end_point": [
        394,
        1
      ],
      "content": "static size_t\n_u32_strlen(const uint32_t *s)\n{\n  const uint32_t *e;\n\n  for (e = s; *e; e++)\n    ;\n\n  return e - s;\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "_u32_strcmp": {
      "start_point": [
        396,
        0
      ],
      "end_point": [
        403,
        1
      ],
      "content": "static size_t\n_u32_strcmp(const uint32_t *s1, const uint32_t *s2)\n{\n  while (*s1 && *s2 && *s1 == *s2)\n    s1++, s2++;\n\n  return *s1 - *s2;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "_check_4z": {
      "start_point": [
        405,
        0
      ],
      "end_point": [
        434,
        1
      ],
      "content": "static void\n_check_4z(const test_t *t, int rc, uint32_t *ucs4, const char *funcname)\n{\n  if (rc != t->rc_expected && !(rc == IDN2_ICONV_FAIL && t->rc_expected == IDN2_ENCODING_ERROR))\n    {\n      fprintf (stderr, \"Test[%u] '%s' failed (got %d, expected %d):\\n\",\n        (unsigned) (t - test), t->name, rc, t->rc_expected);\n      fail (\"  %s(): %s\\n\", funcname, idn2_strerror (rc));\n    }\n  else if (rc == IDN2_OK)\n    {\n      if (_u32_strcmp (t->u32_expected, ucs4) != 0)\n\t{\n\t  if (debug)\n\t    {\n\t      printf (\"got:\\n\");\n\t      ucs4print (ucs4, _u32_strlen (ucs4));\n\t      printf (\"expected:\\n\");\n\t      ucs4print (t->u32_expected, _u32_strlen (t->u32_expected));\n\t    }\n\n\t  fail (\"%s() entry %u mismatch\\n\", funcname, (unsigned) (t - test));\n        }\n    }\n  else if (debug)\n    printf (\"returned %d expected %d (%s)\\n\",\n      rc, t->rc_expected, idn2_strerror (t->rc_expected));\n\n  free (ucs4);\n}",
      "lines": 30,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        436,
        0
      ],
      "end_point": [
        574,
        1
      ],
      "content": "int\nmain (void)\n{\n  static uint32_t abc_u32[] = { 'a', 'b', 'c', 0 };\n  static uint32_t xntda_u32[] = { 'x', 'n', '-', '-', 't', 'd', 'a', 0 };\n\n  uint32_t q[128];\n  uint32_t *ucs4, *punycode_u32;\n  uint8_t *utf8;\n  char *utf8_lz;\n  const char *encoding;\n  size_t outlen, outlen2;\n  int rc, skip_lz = 0;\n  unsigned i;\n\n  /* Need to set UTF-8 for u8_strconv_from_locale / u8_strconv_to_locale to work.\n   * At least on Debian with libunistring 0.9.6+really0.9.3-0.1 and LC_ALL=C valgrind\n   * reports Conditional jump or move depends on uninitialised value */\n  setlocale (LC_ALL, \"C.UTF-8\");\n  encoding = locale_charset();\n\n  if (debug)\n    printf(\"charset=%s\\n\", encoding);\n\n  if (strcmp(encoding, \"UTF-8\") != 0)\n    skip_lz = 1;\n\n  for (i = 0; i < sizeof (test) / sizeof (test[0]); i++)\n    {\n      const test_t *t = test + i;\n\n      if (debug)\n\tprintf (\"\\nPUNYCODE entry %u: %s\\n\", i, t->name);\n\n      ucs4 = NULL; /* freed by _check_4z */\n      rc = idn2_to_unicode_8z4z (t->punycode, &ucs4, 0);\n      _check_4z (t, rc, ucs4, \"idn2_to_unicode_8z4z\");\n\n      punycode_u32 = u8_to_u32 (\n\t(uint8_t *) t->punycode, strlen (t->punycode) + 1, NULL, &outlen);\n\n      if (punycode_u32)\n\t{\n\t  ucs4 = NULL; /* freed by _check_4z */\n\t  rc = idn2_to_unicode_4z4z(punycode_u32, &ucs4, 0);\n\t  _check_4z(t, rc, ucs4, \"idn2_to_unicode_4z4z\");\n\n\t  outlen2 = sizeof (q) / sizeof (q[0]) - 1;\n\t  rc = idn2_to_unicode_44i(punycode_u32, outlen - 1, q, &outlen2, 0);\n\t  ucs4 = u32_cpy_alloc(q, outlen2 + 1);\n\t  ucs4[outlen2] = 0;\n\t  _check_4z(t, rc, ucs4, \"idn2_to_unicode_44i\");\n\n\t  free(punycode_u32);\n\t}\n\n      ucs4 = NULL;\n      rc = idn2_to_unicode_8z8z (t->punycode, (char **) &utf8, 0);\n      if (rc == IDN2_OK)\n\t{\n\t  ucs4 = u8_to_u32 (utf8, u8_strlen (utf8) + 1, NULL, &outlen);\n\t  free (utf8);\n\t}\n      _check_4z (t, rc, ucs4, \"idn2_to_unicode_8z8z\");\n\n      if (skip_lz)\n\tcontinue;\n\n      ucs4 = NULL;\n      rc = idn2_to_unicode_8zlz (t->punycode, &utf8_lz, 0);\n      if (rc == IDN2_OK)\n\t{\n          utf8 = u8_strconv_from_encoding (utf8_lz, encoding, iconveh_error);\n\t  free (utf8_lz);\n\t  ucs4 = u8_to_u32 (utf8, u8_strlen (utf8) + 1, NULL, &outlen);\n\t  free (utf8);\n\t}\n      _check_4z (t, rc, ucs4, \"idn2_to_unicode_8zlz\");\n\n      /* Since the test punycodes are completely ASCII,\n         idn2_to_unicode_8zlz and idn2_to_unicode_lzlz should\n         have the same results */\n      ucs4 = NULL;\n      rc = idn2_to_unicode_lzlz (t->punycode, (char **) &utf8_lz, 0);\n      if (rc == IDN2_OK)\n\t{\n          utf8 = u8_strconv_from_encoding (utf8_lz, encoding, iconveh_error);\n\t  free (utf8_lz);\n\t  ucs4 = u8_to_u32 (utf8, u8_strlen (utf8) + 1, NULL, &outlen);\n\t  free (utf8);\n\t}\n      _check_4z (t, rc, ucs4, \"idn2_to_unicode_lzlz\");\n    }\n\n  /* special checks with NULL values */\n  idn2_to_unicode_8z4z (NULL, NULL, 0);\n  idn2_to_unicode_8z4z (NULL, &ucs4, 0);\n  idn2_to_unicode_8z4z (\"abc\", NULL, 0);\n  idn2_to_unicode_8z4z (\"xn--tda\", NULL, 0);\n\n  idn2_to_unicode_4z4z (NULL, NULL, 0);\n  idn2_to_unicode_4z4z (NULL, &ucs4, 0);\n  idn2_to_unicode_4z4z (abc_u32, NULL, 0);\n  idn2_to_unicode_4z4z (xntda_u32, NULL, 0);\n\n  idn2_to_unicode_44i (NULL, 0, NULL, NULL, 0);\n  idn2_to_unicode_44i (NULL, 0, NULL, &outlen, 0);\n  idn2_to_unicode_44i (NULL, 0, q, NULL, 0);\n  outlen = 32; idn2_to_unicode_44i (NULL, 0, q, &outlen, 0);\n  outlen = 0; idn2_to_unicode_44i (NULL, 0, (uint32_t *) 123, &outlen, 0);\n\n  idn2_to_unicode_44i (abc_u32, 0, NULL, NULL, 0);\n  idn2_to_unicode_44i (abc_u32, 0, NULL, &outlen, 0);\n  idn2_to_unicode_44i (abc_u32, 0, q, NULL, 0);\n  outlen = 32; idn2_to_unicode_44i (abc_u32, 0, q, &outlen, 0);\n  outlen = 0; idn2_to_unicode_44i (abc_u32, 0, (uint32_t *) 123, &outlen, 0);\n  outlen = 0; idn2_to_unicode_44i (abc_u32, 3, (uint32_t *) 123, &outlen, 0);\n  outlen = 0; idn2_to_unicode_44i (abc_u32, 3, (uint32_t *) 123, NULL, 0);\n\n  idn2_to_unicode_8z8z (NULL, NULL, 0);\n  idn2_to_unicode_8z8z (NULL, (char **) &utf8, 0);\n  idn2_to_unicode_8z8z (\"abc\", NULL, 0);\n  idn2_to_unicode_8z8z (\"xn--tda\", NULL, 0);\n\n  idn2_to_unicode_8zlz (NULL, NULL, 0);\n  idn2_to_unicode_8zlz (NULL, (char **) &utf8, 0);\n  idn2_to_unicode_8zlz (\"abc\", NULL, 0);\n  idn2_to_unicode_8zlz (\"xn--tda\", NULL, 0);\n\n  idn2_to_unicode_lzlz (NULL, NULL, 0);\n  idn2_to_unicode_lzlz (NULL, (char **) &utf8, 0);\n  idn2_to_unicode_lzlz (\"abc\", NULL, 0);\n  idn2_to_unicode_lzlz (\"xn--tda\", NULL, 0);\n\n  if (debug && error_count)\n    printf(\"error_count: %d\\n\", error_count);\n\n  return !!error_count;\n}",
      "lines": 139,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/alloca.in.h": {},
  "libidn/libidn2-2.0.5/unistring/arg-nonnull.h": {},
  "libidn/libidn2-2.0.5/unistring/array-mergesort.h": {
    "merge": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static void\nmerge (const ELEMENT *src1, size_t n1,\n       const ELEMENT *src2, size_t n2,\n       ELEMENT *dst)\n{\n  for (;;) /* while (n1 > 0 && n2 > 0) */\n    {\n      if (COMPARE (src1, src2) <= 0)\n        {\n          *dst++ = *src1++;\n          n1--;\n          if (n1 == 0)\n            break;\n        }\n      else\n        {\n          *dst++ = *src2++;\n          n2--;\n          if (n2 == 0)\n            break;\n        }\n    }\n  /* Here n1 == 0 || n2 == 0 but also n1 > 0 || n2 > 0.  */\n  if (n1 > 0)\n    {\n      if (dst != src1)\n        do\n          {\n            *dst++ = *src1++;\n            n1--;\n          }\n        while (n1 > 0);\n    }\n  else /* n2 > 0 */\n    {\n      if (dst != src2)\n        do\n          {\n            *dst++ = *src2++;\n            n2--;\n          }\n        while (n2 > 0);\n    }\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "merge_sort_fromto": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "STATIC void\nmerge_sort_fromto (const ELEMENT *src, ELEMENT *dst, size_t n, ELEMENT *tmp)\n{\n  switch (n)\n    {\n    case 0:\n      return;\n    case 1:\n      /* Nothing to do.  */\n      dst[0] = src[0];\n      return;\n    case 2:\n      /* Trivial case.  */\n      if (COMPARE (&src[0], &src[1]) <= 0)\n        {\n          /* src[0] <= src[1] */\n          dst[0] = src[0];\n          dst[1] = src[1];\n        }\n      else\n        {\n          dst[0] = src[1];\n          dst[1] = src[0];\n        }\n      break;\n    case 3:\n      /* Simple case.  */\n      if (COMPARE (&src[0], &src[1]) <= 0)\n        {\n          if (COMPARE (&src[1], &src[2]) <= 0)\n            {\n              /* src[0] <= src[1] <= src[2] */\n              dst[0] = src[0];\n              dst[1] = src[1];\n              dst[2] = src[2];\n            }\n          else if (COMPARE (&src[0], &src[2]) <= 0)\n            {\n              /* src[0] <= src[2] < src[1] */\n              dst[0] = src[0];\n              dst[1] = src[2];\n              dst[2] = src[1];\n            }\n          else\n            {\n              /* src[2] < src[0] <= src[1] */\n              dst[0] = src[2];\n              dst[1] = src[0];\n              dst[2] = src[1];\n            }\n        }\n      else\n        {\n          if (COMPARE (&src[0], &src[2]) <= 0)\n            {\n              /* src[1] < src[0] <= src[2] */\n              dst[0] = src[1];\n              dst[1] = src[0];\n              dst[2] = src[2];\n            }\n          else if (COMPARE (&src[1], &src[2]) <= 0)\n            {\n              /* src[1] <= src[2] < src[0] */\n              dst[0] = src[1];\n              dst[1] = src[2];\n              dst[2] = src[0];\n            }\n          else\n            {\n              /* src[2] < src[1] < src[0] */\n              dst[0] = src[2];\n              dst[1] = src[1];\n              dst[2] = src[0];\n            }\n        }\n      break;\n    default:\n      {\n        size_t n1 = n / 2;\n        size_t n2 = (n + 1) / 2;\n        /* Note: n1 + n2 = n, n1 <= n2.  */\n        /* Sort src[n1..n-1] into dst[n1..n-1], scratching tmp[0..n2/2-1].  */\n        merge_sort_fromto (src + n1, dst + n1, n2, tmp);\n        /* Sort src[0..n1-1] into tmp[0..n1-1], scratching dst[0..n1-1].  */\n        merge_sort_fromto (src, tmp, n1, dst);\n        /* Merge the two half results.  */\n        merge (tmp, n1, dst + n1, n2, dst);\n      }\n      break;\n    }\n}",
      "lines": 91,
      "depth": 16,
      "decorators": [
        "STATIC",
        "void",
        "void"
      ]
    },
    "merge_sort_inplace": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        278,
        1
      ],
      "content": "STATIC void\nmerge_sort_inplace (ELEMENT *src, size_t n, ELEMENT *tmp)\n{\n  switch (n)\n    {\n    case 0:\n    case 1:\n      /* Nothing to do.  */\n      return;\n    case 2:\n      /* Trivial case.  */\n      if (COMPARE (&src[0], &src[1]) <= 0)\n        {\n          /* src[0] <= src[1] */\n        }\n      else\n        {\n          ELEMENT t = src[0];\n          src[0] = src[1];\n          src[1] = t;\n        }\n      break;\n    case 3:\n      /* Simple case.  */\n      if (COMPARE (&src[0], &src[1]) <= 0)\n        {\n          if (COMPARE (&src[1], &src[2]) <= 0)\n            {\n              /* src[0] <= src[1] <= src[2] */\n            }\n          else if (COMPARE (&src[0], &src[2]) <= 0)\n            {\n              /* src[0] <= src[2] < src[1] */\n              ELEMENT t = src[1];\n              src[1] = src[2];\n              src[2] = t;\n            }\n          else\n            {\n              /* src[2] < src[0] <= src[1] */\n              ELEMENT t = src[0];\n              src[0] = src[2];\n              src[2] = src[1];\n              src[1] = t;\n            }\n        }\n      else\n        {\n          if (COMPARE (&src[0], &src[2]) <= 0)\n            {\n              /* src[1] < src[0] <= src[2] */\n              ELEMENT t = src[0];\n              src[0] = src[1];\n              src[1] = t;\n            }\n          else if (COMPARE (&src[1], &src[2]) <= 0)\n            {\n              /* src[1] <= src[2] < src[0] */\n              ELEMENT t = src[0];\n              src[0] = src[1];\n              src[1] = src[2];\n              src[2] = t;\n            }\n          else\n            {\n              /* src[2] < src[1] < src[0] */\n              ELEMENT t = src[0];\n              src[0] = src[2];\n              src[2] = t;\n            }\n        }\n      break;\n    default:\n      {\n        size_t n1 = n / 2;\n        size_t n2 = (n + 1) / 2;\n        /* Note: n1 + n2 = n, n1 <= n2.  */\n        /* Sort src[n1..n-1], scratching tmp[0..n2-1].  */\n        merge_sort_inplace (src + n1, n2, tmp);\n        /* Sort src[0..n1-1] into tmp[0..n1-1], scratching tmp[n1..2*n1-1].  */\n        merge_sort_fromto (src, tmp, n1, tmp + n1);\n        /* Merge the two half results.  */\n        merge (tmp, n1, src + n1, n2, src);\n      }\n      break;\n    }\n}",
      "lines": 87,
      "depth": 16,
      "decorators": [
        "STATIC",
        "void",
        "void"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/c++defs.h": {},
  "libidn/libidn2-2.0.5/unistring/c-ctype.c": {},
  "libidn/libidn2-2.0.5/unistring/c-ctype.h": {
    "c_isalnum": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isalnum (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isalpha": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isalpha (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_LOWER:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isascii": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isascii (int c)\n{\n  switch (c)\n    {\n    case ' ':\n    _C_CTYPE_CNTRL:\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_PUNCT:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isblank": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isblank (int c)\n{\n  return c == ' ' || c == '\\t';\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_iscntrl": {
      "start_point": [
        228,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_iscntrl (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_CNTRL:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isdigit": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        250,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isdigit (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isgraph": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        265,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isgraph (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_PUNCT:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_islower": {
      "start_point": [
        267,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_islower (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_LOWER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isprint": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        293,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isprint (int c)\n{\n  switch (c)\n    {\n    case ' ':\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_PUNCT:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_ispunct": {
      "start_point": [
        295,
        0
      ],
      "end_point": [
        305,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_ispunct (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_PUNCT:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isspace": {
      "start_point": [
        307,
        0
      ],
      "end_point": [
        317,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isspace (int c)\n{\n  switch (c)\n    {\n    case ' ': case '\\t': case '\\n': case '\\v': case '\\f': case '\\r':\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isupper": {
      "start_point": [
        319,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isupper (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isxdigit": {
      "start_point": [
        331,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isxdigit (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_A_THRU_F:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_tolower": {
      "start_point": [
        344,
        0
      ],
      "end_point": [
        354,
        1
      ],
      "content": "C_CTYPE_INLINE int\nc_tolower (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_UPPER:\n      return c - 'A' + 'a';\n    default:\n      return c;\n    }\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "C_CTYPE_INLINE",
        "int",
        "int"
      ]
    },
    "c_toupper": {
      "start_point": [
        356,
        0
      ],
      "end_point": [
        366,
        1
      ],
      "content": "C_CTYPE_INLINE int\nc_toupper (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_LOWER:\n      return c - 'a' + 'A';\n    default:\n      return c;\n    }\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "C_CTYPE_INLINE",
        "int",
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/c-strcase.h": {},
  "libidn/libidn2-2.0.5/unistring/c-strcasecmp.c": {
    "c_strcasecmp": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\nc_strcasecmp (const char *s1, const char *s2)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2)\n    return 0;\n\n  do\n    {\n      c1 = c_tolower (*p1);\n      c2 = c_tolower (*p2);\n\n      if (c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/c-strcaseeq.h": {
    "strcaseeq9": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static inline int\nstrcaseeq9 (const char *s1, const char *s2)\n{\n  return c_strcasecmp (s1 + 9, s2 + 9) == 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq8": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static inline int\nstrcaseeq8 (const char *s1, const char *s2, char s28)\n{\n  if (CASEEQ (s1[8], s28))\n    {\n      if (s28 == 0)\n        return 1;\n      else\n        return strcaseeq9 (s1, s2);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq7": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static inline int\nstrcaseeq7 (const char *s1, const char *s2, char s27, char s28)\n{\n  if (CASEEQ (s1[7], s27))\n    {\n      if (s27 == 0)\n        return 1;\n      else\n        return strcaseeq8 (s1, s2, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq6": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "static inline int\nstrcaseeq6 (const char *s1, const char *s2, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[6], s26))\n    {\n      if (s26 == 0)\n        return 1;\n      else\n        return strcaseeq7 (s1, s2, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq5": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "static inline int\nstrcaseeq5 (const char *s1, const char *s2, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[5], s25))\n    {\n      if (s25 == 0)\n        return 1;\n      else\n        return strcaseeq6 (s1, s2, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq4": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "static inline int\nstrcaseeq4 (const char *s1, const char *s2, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[4], s24))\n    {\n      if (s24 == 0)\n        return 1;\n      else\n        return strcaseeq5 (s1, s2, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq3": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "static inline int\nstrcaseeq3 (const char *s1, const char *s2, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[3], s23))\n    {\n      if (s23 == 0)\n        return 1;\n      else\n        return strcaseeq4 (s1, s2, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq2": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "static inline int\nstrcaseeq2 (const char *s1, const char *s2, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[2], s22))\n    {\n      if (s22 == 0)\n        return 1;\n      else\n        return strcaseeq3 (s1, s2, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq1": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "static inline int\nstrcaseeq1 (const char *s1, const char *s2, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[1], s21))\n    {\n      if (s21 == 0)\n        return 1;\n      else\n        return strcaseeq2 (s1, s2, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq0": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "static inline int\nstrcaseeq0 (const char *s1, const char *s2, char s20, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[0], s20))\n    {\n      if (s20 == 0)\n        return 1;\n      else\n        return strcaseeq1 (s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/c-strncasecmp.c": {
    "c_strncasecmp": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\nc_strncasecmp (const char *s1, const char *s2, size_t n)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2 || n == 0)\n    return 0;\n\n  do\n    {\n      c1 = c_tolower (*p1);\n      c2 = c_tolower (*p2);\n\n      if (--n == 0 || c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/iconv.c": {
    "utf16be_mbtowc": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "static int\nutf16be_mbtowc (ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  if (n >= 2)\n    {\n      ucs4_t wc = (s[0] << 8) + s[1];\n      if (wc >= 0xd800 && wc < 0xdc00)\n        {\n          if (n >= 4)\n            {\n              ucs4_t wc2 = (s[2] << 8) + s[3];\n              if (!(wc2 >= 0xdc00 && wc2 < 0xe000))\n                return RET_ILSEQ;\n              *pwc = 0x10000 + ((wc - 0xd800) << 10) + (wc2 - 0xdc00);\n              return 4;\n            }\n        }\n      else if (wc >= 0xdc00 && wc < 0xe000)\n        {\n          return RET_ILSEQ;\n        }\n      else\n        {\n          *pwc = wc;\n          return 2;\n        }\n    }\n  return RET_TOOFEW;\n}",
      "lines": 29,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf16be_wctomb": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "static int\nutf16be_wctomb (unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (!(wc >= 0xd800 && wc < 0xe000))\n    {\n      if (wc < 0x10000)\n        {\n          if (n >= 2)\n            {\n              r[0] = (unsigned char) (wc >> 8);\n              r[1] = (unsigned char) wc;\n              return 2;\n            }\n          else\n            return RET_TOOSMALL;\n        }\n      else if (wc < 0x110000)\n        {\n          if (n >= 4)\n            {\n              ucs4_t wc1 = 0xd800 + ((wc - 0x10000) >> 10);\n              ucs4_t wc2 = 0xdc00 + ((wc - 0x10000) & 0x3ff);\n              r[0] = (unsigned char) (wc1 >> 8);\n              r[1] = (unsigned char) wc1;\n              r[2] = (unsigned char) (wc2 >> 8);\n              r[3] = (unsigned char) wc2;\n              return 4;\n            }\n          else\n            return RET_TOOSMALL;\n        }\n    }\n  return RET_ILUNI;\n}",
      "lines": 34,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf16le_mbtowc": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "static int\nutf16le_mbtowc (ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  if (n >= 2)\n    {\n      ucs4_t wc = s[0] + (s[1] << 8);\n      if (wc >= 0xd800 && wc < 0xdc00)\n        {\n          if (n >= 4)\n            {\n              ucs4_t wc2 = s[2] + (s[3] << 8);\n              if (!(wc2 >= 0xdc00 && wc2 < 0xe000))\n                return RET_ILSEQ;\n              *pwc = 0x10000 + ((wc - 0xd800) << 10) + (wc2 - 0xdc00);\n              return 4;\n            }\n        }\n      else if (wc >= 0xdc00 && wc < 0xe000)\n        {\n          return RET_ILSEQ;\n        }\n      else\n        {\n          *pwc = wc;\n          return 2;\n        }\n    }\n  return RET_TOOFEW;\n}",
      "lines": 29,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf16le_wctomb": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "static int\nutf16le_wctomb (unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (!(wc >= 0xd800 && wc < 0xe000))\n    {\n      if (wc < 0x10000)\n        {\n          if (n >= 2)\n            {\n              r[0] = (unsigned char) wc;\n              r[1] = (unsigned char) (wc >> 8);\n              return 2;\n            }\n          else\n            return RET_TOOSMALL;\n        }\n      else if (wc < 0x110000)\n        {\n          if (n >= 4)\n            {\n              ucs4_t wc1 = 0xd800 + ((wc - 0x10000) >> 10);\n              ucs4_t wc2 = 0xdc00 + ((wc - 0x10000) & 0x3ff);\n              r[0] = (unsigned char) wc1;\n              r[1] = (unsigned char) (wc1 >> 8);\n              r[2] = (unsigned char) wc2;\n              r[3] = (unsigned char) (wc2 >> 8);\n              return 4;\n            }\n          else\n            return RET_TOOSMALL;\n        }\n    }\n  return RET_ILUNI;\n}",
      "lines": 34,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf32be_mbtowc": {
      "start_point": [
        204,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "static int\nutf32be_mbtowc (ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  if (n >= 4)\n    {\n      ucs4_t wc = (s[0] << 24) + (s[1] << 16) + (s[2] << 8) + s[3];\n      if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000))\n        {\n          *pwc = wc;\n          return 4;\n        }\n      else\n        return RET_ILSEQ;\n    }\n  return RET_TOOFEW;\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf32be_wctomb": {
      "start_point": [
        221,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "static int\nutf32be_wctomb (unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000))\n    {\n      if (n >= 4)\n        {\n          r[0] = 0;\n          r[1] = (unsigned char) (wc >> 16);\n          r[2] = (unsigned char) (wc >> 8);\n          r[3] = (unsigned char) wc;\n          return 4;\n        }\n      else\n        return RET_TOOSMALL;\n    }\n  return RET_ILUNI;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf32le_mbtowc": {
      "start_point": [
        246,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "static int\nutf32le_mbtowc (ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  if (n >= 4)\n    {\n      ucs4_t wc = s[0] + (s[1] << 8) + (s[2] << 16) + (s[3] << 24);\n      if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000))\n        {\n          *pwc = wc;\n          return 4;\n        }\n      else\n        return RET_ILSEQ;\n    }\n  return RET_TOOFEW;\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf32le_wctomb": {
      "start_point": [
        263,
        0
      ],
      "end_point": [
        280,
        1
      ],
      "content": "static int\nutf32le_wctomb (unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000))\n    {\n      if (n >= 4)\n        {\n          r[0] = (unsigned char) wc;\n          r[1] = (unsigned char) (wc >> 8);\n          r[2] = (unsigned char) (wc >> 16);\n          r[3] = 0;\n          return 4;\n        }\n      else\n        return RET_TOOSMALL;\n    }\n  return RET_ILUNI;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/iconv.in.h": {},
  "libidn/libidn2-2.0.5/unistring/iconveh.h": {},
  "libidn/libidn2-2.0.5/unistring/iconv_close.c": {},
  "libidn/libidn2-2.0.5/unistring/iconv_open-aix.h": {
    "mapping_hash": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static unsigned int\nmapping_hash (register const char *str, register size_t len)\n{\n  static const unsigned char asso_values[] =\n    {\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45,  0,  4, 25,\n       0, 11, 24,  9, 17,  3, 14, 21, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n       3, 45,  1, 45, 45, 45, 45,  0, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45\n    };\n  return len + asso_values[(unsigned char)str[3]+2] + asso_values[(unsigned char)str[len - 1]];\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "mapping_lookup": {
      "start_point": [
        229,
        0
      ],
      "end_point": [
        249,
        1
      ],
      "content": "const struct mapping *\nmapping_lookup (register const char *str, register size_t len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register unsigned int key = mapping_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE)\n        {\n          register int o = mappings[key].standard_name;\n          if (o >= 0)\n            {\n              register const char *s = o + stringpool;\n\n              if (*str == *s && !strcmp (str + 1, s + 1))\n                return &mappings[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "struct mapping",
        "struct",
        "mapping",
        "*\nmapping_lookup (register const char *str, register size_t len)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/iconv_open-hpux.h": {
    "mapping_hash": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static unsigned int\nmapping_hash (register const char *str, register size_t len)\n{\n  static const unsigned char asso_values[] =\n    {\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50,  1,  2,\n      24, 43,  5, 10,  0, 13, 32,  3, 19, 18,\n      50, 50, 50, 50, 50, 50, 50, 50, 50,  5,\n      50, 50, 50, 50, 14,  5,  0, 50, 50,  0,\n      27, 50, 12, 14, 50, 50,  0,  5,  2, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50\n    };\n  return len + asso_values[(unsigned char)str[3]+4] + asso_values[(unsigned char)str[len - 1]];\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "mapping_lookup": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        292,
        1
      ],
      "content": "const struct mapping *\nmapping_lookup (register const char *str, register size_t len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register unsigned int key = mapping_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE)\n        {\n          register int o = mappings[key].standard_name;\n          if (o >= 0)\n            {\n              register const char *s = o + stringpool;\n\n              if (*str == *s && !strcmp (str + 1, s + 1))\n                return &mappings[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "struct mapping",
        "struct",
        "mapping",
        "*\nmapping_lookup (register const char *str, register size_t len)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/iconv_open-irix.h": {
    "mapping_hash": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static unsigned int\nmapping_hash (register const char *str, register size_t len)\n{\n  static const unsigned char asso_values[] =\n    {\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24,  8,  2,\n       5, 12, 11,  0, 10,  9,  8,  7, 24, 24,\n      24, 24, 24, 24, 24, 24, 24,  0, 24,  0,\n      24,  5, 24,  0, 24,  7, 24, 24, 24, 24,\n       7, 24,  1,  0,  8, 24, 24,  0, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24\n    };\n  return len + asso_values[(unsigned char)str[len - 1]] + asso_values[(unsigned char)str[0]];\n}",
      "lines": 34,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "mapping_lookup": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "const struct mapping *\nmapping_lookup (register const char *str, register size_t len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register unsigned int key = mapping_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE)\n        {\n          register int o = mappings[key].standard_name;\n          if (o >= 0)\n            {\n              register const char *s = o + stringpool;\n\n              if (*str == *s && !strcmp (str + 1, s + 1))\n                return &mappings[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "struct mapping",
        "struct",
        "mapping",
        "*\nmapping_lookup (register const char *str, register size_t len)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/iconv_open-osf.h": {
    "mapping_hash": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static unsigned int\nmapping_hash (register const char *str, register size_t len)\n{\n  static const unsigned char asso_values[] =\n    {\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48,  2, 29,\n      24, 34, 31,  0, 15, 14, 10, 13,  2, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48,  7, 48, 48, 48, 48, 48, 48,\n      11, 48,  2,  7, 48, 48, 48,  1, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48\n    };\n  return len + asso_values[(unsigned char)str[3]+3] + asso_values[(unsigned char)str[len - 1]];\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "mapping_lookup": {
      "start_point": [
        251,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "const struct mapping *\nmapping_lookup (register const char *str, register size_t len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register unsigned int key = mapping_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE)\n        {\n          register int o = mappings[key].standard_name;\n          if (o >= 0)\n            {\n              register const char *s = o + stringpool;\n\n              if (*str == *s && !strcmp (str + 1, s + 1))\n                return &mappings[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "struct mapping",
        "struct",
        "mapping",
        "*\nmapping_lookup (register const char *str, register size_t len)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/iconv_open-solaris.h": {
    "mapping_hash": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "static unsigned int\nmapping_hash (register const char *str, register size_t len)\n{\n  static const unsigned char asso_values[] =\n    {\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20,  0,\n       9,  8,  7,  6,  5,  4,  3,  2, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20\n    };\n  register unsigned int hval = len;\n\n  switch (hval)\n    {\n      default:\n        hval += asso_values[(unsigned char)str[9]];\n      /*FALLTHROUGH*/\n      case 9:\n      case 8:\n      case 7:\n      case 6:\n      case 5:\n        break;\n    }\n  return hval;\n}",
      "lines": 48,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "mapping_lookup": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "const struct mapping *\nmapping_lookup (register const char *str, register size_t len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register unsigned int key = mapping_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE)\n        {\n          register int o = mappings[key].standard_name;\n          if (o >= 0)\n            {\n              register const char *s = o + stringpool;\n\n              if (*str == *s && !strcmp (str + 1, s + 1))\n                return &mappings[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "struct mapping",
        "struct",
        "mapping",
        "*\nmapping_lookup (register const char *str, register size_t len)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/iconv_open.c": {},
  "libidn/libidn2-2.0.5/unistring/limits.in.h": {},
  "libidn/libidn2-2.0.5/unistring/localcharset.c": {
    "get_charset_aliases": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        393,
        1
      ],
      "content": "static const char *\nget_charset_aliases (void)\n{\n  const char *cp;\n\n  cp = charset_aliases;\n  if (cp == NULL)\n    {\n#if !(defined DARWIN7 || defined VMS || defined WINDOWS_NATIVE || defined __CYGWIN__ || defined OS2)\n      char *malloc_dir = NULL;\n      const char *dir;\n      const char *base = \"charset.alias\";\n      char *file_name;\n\n      /* Make it possible to override the charset.alias location.  This is\n         necessary for running the testsuite before \"make install\".  */\n      dir = getenv (\"CHARSETALIASDIR\");\n      if (dir == NULL || dir[0] == '\\0')\n        dir = relocate2 (LIBDIR, &malloc_dir);\n\n      /* Concatenate dir and base into freshly allocated file_name.  */\n      {\n        size_t dir_len = strlen (dir);\n        size_t base_len = strlen (base);\n        int add_slash = (dir_len > 0 && !ISSLASH (dir[dir_len - 1]));\n        file_name = (char *) malloc (dir_len + add_slash + base_len + 1);\n        if (file_name != NULL)\n          {\n            memcpy (file_name, dir, dir_len);\n            if (add_slash)\n              file_name[dir_len] = DIRECTORY_SEPARATOR;\n            memcpy (file_name + dir_len + add_slash, base, base_len + 1);\n          }\n      }\n\n      free (malloc_dir);\n\n      if (file_name == NULL)\n        /* Out of memory.  Treat the file as empty.  */\n        cp = \"\";\n      else\n        {\n          int fd;\n\n          /* Open the file.  Reject symbolic links on platforms that support\n             O_NOFOLLOW.  This is a security feature.  Without it, an attacker\n             could retrieve parts of the contents (namely, the tail of the\n             first line that starts with \"* \") of an arbitrary file by placing\n             a symbolic link to that file under the name \"charset.alias\" in\n             some writable directory and defining the environment variable\n             CHARSETALIASDIR to point to that directory.  */\n          fd = open (file_name,\n                     O_RDONLY | (HAVE_WORKING_O_NOFOLLOW ? O_NOFOLLOW : 0));\n          if (fd < 0)\n            /* File not found.  Treat it as empty.  */\n            cp = \"\";\n          else\n            {\n              FILE *fp;\n\n              fp = fdopen (fd, \"r\");\n              if (fp == NULL)\n                {\n                  /* Out of memory.  Treat the file as empty.  */\n                  close (fd);\n                  cp = \"\";\n                }\n              else\n                {\n                  /* Parse the file's contents.  */\n                  char *res_ptr = NULL;\n                  size_t res_size = 0;\n\n                  for (;;)\n                    {\n                      int c;\n                      char buf1[50+1];\n                      char buf2[50+1];\n                      size_t l1, l2;\n                      char *old_res_ptr;\n\n                      c = getc (fp);\n                      if (c == EOF)\n                        break;\n                      if (c == '\\n' || c == ' ' || c == '\\t')\n                        continue;\n                      if (c == '#')\n                        {\n                          /* Skip comment, to end of line.  */\n                          do\n                            c = getc (fp);\n                          while (!(c == EOF || c == '\\n'));\n                          if (c == EOF)\n                            break;\n                          continue;\n                        }\n                      ungetc (c, fp);\n                      if (fscanf (fp, \"%50s %50s\", buf1, buf2) < 2)\n                        break;\n                      l1 = strlen (buf1);\n                      l2 = strlen (buf2);\n                      old_res_ptr = res_ptr;\n                      if (res_size == 0)\n                        {\n                          res_size = l1 + 1 + l2 + 1;\n                          res_ptr = (char *) malloc (res_size + 1);\n                        }\n                      else\n                        {\n                          res_size += l1 + 1 + l2 + 1;\n                          res_ptr = (char *) realloc (res_ptr, res_size + 1);\n                        }\n                      if (res_ptr == NULL)\n                        {\n                          /* Out of memory. */\n                          res_size = 0;\n                          free (old_res_ptr);\n                          break;\n                        }\n                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);\n                      strcpy (res_ptr + res_size - (l2 + 1), buf2);\n                    }\n                  fclose (fp);\n                  if (res_size == 0)\n                    cp = \"\";\n                  else\n                    {\n                      *(res_ptr + res_size) = '\\0';\n                      cp = res_ptr;\n                    }\n                }\n            }\n\n          free (file_name);\n        }\n\n#else\n\n# if defined DARWIN7\n      /* To avoid the trouble of installing a file that is shared by many\n         GNU packages -- many packaging systems have problems with this --,\n         simply inline the aliases here.  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-4\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"ISO8859-13\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"ISO8859-15\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"KOI8-R\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"KOI8-U\" \"\\0\" \"KOI8-U\" \"\\0\"\n           \"CP866\" \"\\0\" \"CP866\" \"\\0\"\n           \"CP949\" \"\\0\" \"CP949\" \"\\0\"\n           \"CP1131\" \"\\0\" \"CP1131\" \"\\0\"\n           \"CP1251\" \"\\0\" \"CP1251\" \"\\0\"\n           \"eucCN\" \"\\0\" \"GB2312\" \"\\0\"\n           \"GB2312\" \"\\0\" \"GB2312\" \"\\0\"\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"eucKR\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"Big5\" \"\\0\" \"BIG5\" \"\\0\"\n           \"Big5HKSCS\" \"\\0\" \"BIG5-HKSCS\" \"\\0\"\n           \"GBK\" \"\\0\" \"GBK\" \"\\0\"\n           \"GB18030\" \"\\0\" \"GB18030\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"ARMSCII-8\" \"\\0\" \"ARMSCII-8\" \"\\0\"\n           \"PT154\" \"\\0\" \"PT154\" \"\\0\"\n         /*\"ISCII-DEV\" \"\\0\" \"?\" \"\\0\"*/\n           \"*\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n\n# if defined VMS\n      /* To avoid the troubles of an extra file charset.alias_vms in the\n         sources of many GNU packages, simply inline the aliases here.  */\n      /* The list of encodings is taken from the OpenVMS 7.3-1 documentation\n         \"Compaq C Run-Time Library Reference Manual for OpenVMS systems\"\n         section 10.7 \"Handling Different Character Sets\".  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-8\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           /* Japanese */\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"DECKANJI\" \"\\0\" \"DEC-KANJI\" \"\\0\"\n           \"SDECKANJI\" \"\\0\" \"EUC-JP\" \"\\0\"\n           /* Chinese */\n           \"eucTW\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"DECHANYU\" \"\\0\" \"DEC-HANYU\" \"\\0\"\n           \"DECHANZI\" \"\\0\" \"GB2312\" \"\\0\"\n           /* Korean */\n           \"DECKOREAN\" \"\\0\" \"EUC-KR\" \"\\0\";\n# endif\n\n# if defined WINDOWS_NATIVE || defined __CYGWIN__\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      cp = \"CP936\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP1361\" \"\\0\" \"JOHAB\" \"\\0\"\n           \"CP20127\" \"\\0\" \"ASCII\" \"\\0\"\n           \"CP20866\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP20936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP21866\" \"\\0\" \"KOI8-RU\" \"\\0\"\n           \"CP28591\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP28592\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP28593\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP28594\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP28595\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP28596\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP28597\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP28598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP28599\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP28605\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP38598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP51932\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP51936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP51949\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP51950\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP54936\" \"\\0\" \"GB18030\" \"\\0\"\n           \"CP65001\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n# if defined OS2\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      /* The list of encodings is taken from \"List of OS/2 Codepages\"\n         by Alex Taylor:\n         <http://altsan.org/os2/toolkits/uls/index.html#codepages>.\n         See also \"IBM Globalization - Code page identifiers\":\n         <http://www-01.ibm.com/software/globalization/cp/cp_cpgid.html>.  */\n      cp = \"CP813\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP878\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP819\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP912\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP913\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP914\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP915\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP916\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP920\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP921\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"CP923\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP954\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP964\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP970\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP1089\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP1208\" \"\\0\" \"UTF-8\" \"\\0\"\n           \"CP1381\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP1386\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP3372\" \"\\0\" \"EUC-JP\" \"\\0\";\n# endif\n#endif\n\n      charset_aliases = cp;\n    }\n\n  return cp;\n}",
      "lines": 262,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nget_charset_aliases (void)",
        "*"
      ]
    },
    "locale_charset": {
      "start_point": [
        404,
        0
      ],
      "end_point": [
        625,
        1
      ],
      "content": "const char *\nlocale_charset (void)\n{\n  const char *codeset;\n  const char *aliases;\n\n#if !(defined WINDOWS_NATIVE || defined OS2)\n\n# if HAVE_LANGINFO_CODESET\n\n  /* Most systems support nl_langinfo (CODESET) nowadays.  */\n  codeset = nl_langinfo (CODESET);\n\n#  ifdef __CYGWIN__\n  /* Cygwin < 1.7 does not have locales.  nl_langinfo (CODESET) always\n     returns \"US-ASCII\".  Return the suffix of the locale name from the\n     environment variables (if present) or the codepage as a number.  */\n  if (codeset != NULL && strcmp (codeset, \"US-ASCII\") == 0)\n    {\n      const char *locale;\n      static char buf[2 + 10 + 1];\n\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n      if (locale != NULL && locale[0] != '\\0')\n        {\n          /* If the locale name contains an encoding after the dot, return\n             it.  */\n          const char *dot = strchr (locale, '.');\n\n          if (dot != NULL)\n            {\n              const char *modifier;\n\n              dot++;\n              /* Look for the possible @... trailer and remove it, if any.  */\n              modifier = strchr (dot, '@');\n              if (modifier == NULL)\n                return dot;\n              if (modifier - dot < sizeof (buf))\n                {\n                  memcpy (buf, dot, modifier - dot);\n                  buf [modifier - dot] = '\\0';\n                  return buf;\n                }\n            }\n        }\n\n      /* The Windows API has a function returning the locale's codepage as a\n         number: GetACP().  This encoding is used by Cygwin, unless the user\n         has set the environment variable CYGWIN=codepage:oem (which very few\n         people do).\n         Output directed to console windows needs to be converted (to\n         GetOEMCP() if the console is using a raster font, or to\n         GetConsoleOutputCP() if it is using a TrueType font).  Cygwin does\n         this conversion transparently (see winsup/cygwin/fhandler_console.cc),\n         converting to GetConsoleOutputCP().  This leads to correct results,\n         except when SetConsoleOutputCP has been called and a raster font is\n         in use.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n      codeset = buf;\n    }\n#  endif\n\n# else\n\n  /* On old systems which lack it, use setlocale or getenv.  */\n  const char *locale = NULL;\n\n  /* But most old systems don't have a complete set of locales.  Some\n     (like SunOS 4 or DJGPP) have only the C locale.  Therefore we don't\n     use setlocale here; it would return \"C\" when it doesn't support the\n     locale name the user has set.  */\n#  if 0\n  locale = setlocale (LC_CTYPE, NULL);\n#  endif\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n    }\n\n  /* On some old systems, one used to set locale = \"iso8859_1\". On others,\n     you set it to \"language_COUNTRY.charset\". In any case, we resolve it\n     through the charset.alias file.  */\n  codeset = locale;\n\n# endif\n\n#elif defined WINDOWS_NATIVE\n\n  static char buf[2 + 10 + 1];\n\n  /* The Windows API has a function returning the locale's codepage as\n     a number, but the value doesn't change according to what the\n     'setlocale' call specified.  So we use it as a last resort, in\n     case the string returned by 'setlocale' doesn't specify the\n     codepage.  */\n  char *current_locale = setlocale (LC_ALL, NULL);\n  char *pdot;\n\n  /* If they set different locales for different categories,\n     'setlocale' will return a semi-colon separated list of locale\n     values.  To make sure we use the correct one, we choose LC_CTYPE.  */\n  if (strchr (current_locale, ';'))\n    current_locale = setlocale (LC_CTYPE, NULL);\n\n  pdot = strrchr (current_locale, '.');\n  if (pdot && 2 + strlen (pdot + 1) + 1 <= sizeof (buf))\n    sprintf (buf, \"CP%s\", pdot + 1);\n  else\n    {\n      /* The Windows API has a function returning the locale's codepage as a\n        number: GetACP().\n        When the output goes to a console window, it needs to be provided in\n        GetOEMCP() encoding if the console is using a raster font, or in\n        GetConsoleOutputCP() encoding if it is using a TrueType font.\n        But in GUI programs and for output sent to files and pipes, GetACP()\n        encoding is the best bet.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n    }\n  codeset = buf;\n\n#elif defined OS2\n\n  const char *locale;\n  static char buf[2 + 10 + 1];\n  ULONG cp[3];\n  ULONG cplen;\n\n  codeset = NULL;\n\n  /* Allow user to override the codeset, as set in the operating system,\n     with standard language environment variables.  */\n  locale = getenv (\"LC_ALL\");\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_CTYPE\");\n      if (locale == NULL || locale[0] == '\\0')\n        locale = getenv (\"LANG\");\n    }\n  if (locale != NULL && locale[0] != '\\0')\n    {\n      /* If the locale name contains an encoding after the dot, return it.  */\n      const char *dot = strchr (locale, '.');\n\n      if (dot != NULL)\n        {\n          const char *modifier;\n\n          dot++;\n          /* Look for the possible @... trailer and remove it, if any.  */\n          modifier = strchr (dot, '@');\n          if (modifier == NULL)\n            return dot;\n          if (modifier - dot < sizeof (buf))\n            {\n              memcpy (buf, dot, modifier - dot);\n              buf [modifier - dot] = '\\0';\n              return buf;\n            }\n        }\n\n      /* For the POSIX locale, don't use the system's codepage.  */\n      if (strcmp (locale, \"C\") == 0 || strcmp (locale, \"POSIX\") == 0)\n        codeset = \"\";\n    }\n\n  if (codeset == NULL)\n    {\n      /* OS/2 has a function returning the locale's codepage as a number.  */\n      if (DosQueryCp (sizeof (cp), cp, &cplen))\n        codeset = \"\";\n      else\n        {\n          sprintf (buf, \"CP%u\", cp[0]);\n          codeset = buf;\n        }\n    }\n\n#endif\n\n  if (codeset == NULL)\n    /* The canonical name cannot be determined.  */\n    codeset = \"\";\n\n  /* Resolve alias. */\n  for (aliases = get_charset_aliases ();\n       *aliases != '\\0';\n       aliases += strlen (aliases) + 1, aliases += strlen (aliases) + 1)\n    if (strcmp (codeset, aliases) == 0\n        || (aliases[0] == '*' && aliases[1] == '\\0'))\n      {\n        codeset = aliases + strlen (aliases) + 1;\n        break;\n      }\n\n  /* Don't return an empty string.  GNU libc and GNU libiconv interpret\n     the empty string as denoting \"the locale's character encoding\",\n     thus GNU libiconv would call this function a second time.  */\n  if (codeset[0] == '\\0')\n    codeset = \"ASCII\";\n\n#ifdef DARWIN7\n  /* Mac OS X sets MB_CUR_MAX to 1 when LC_ALL=C, and \"UTF-8\"\n     (the default codeset) does not work when MB_CUR_MAX is 1.  */\n  if (strcmp (codeset, \"UTF-8\") == 0 && MB_CUR_MAX_L (uselocale (NULL)) <= 1)\n    codeset = \"ASCII\";\n#endif\n\n  return codeset;\n}",
      "lines": 222,
      "depth": 18,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nlocale_charset (void)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/localcharset.h": {},
  "libidn/libidn2-2.0.5/unistring/malloca.c": {
    "mmalloca": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "void *\nmmalloca (size_t n)\n{\n#if HAVE_ALLOCA\n  /* Allocate one more word, that serves as an indicator for malloc()ed\n     memory, so that freea() of an alloca() result is fast.  */\n  size_t nplus = n + HEADER_SIZE;\n\n  if (nplus >= n)\n    {\n      void *p = malloc (nplus);\n\n      if (p != NULL)\n        {\n          size_t slot;\n          union header *h = p;\n\n          p = h + 1;\n\n          /* Put a magic number into the indicator word.  */\n          h->magic.word = MAGIC_NUMBER;\n\n          /* Enter p into the hash table.  */\n          slot = (uintptr_t) p % HASH_TABLE_SIZE;\n          h->next = mmalloca_results[slot];\n          mmalloca_results[slot] = p;\n\n          return p;\n        }\n    }\n  /* Out of memory.  */\n  return NULL;\n#else\n# if !MALLOC_0_IS_NONNULL\n  if (n == 0)\n    n = 1;\n# endif\n  return malloc (n);\n#endif\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "void",
        "*\nmmalloca (size_t n)",
        "*"
      ]
    },
    "NO_SANITIZE_MEMORY": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "void NO_SANITIZE_MEMORY\nfreea (void *p)\n{\n  /* mmalloca() may have returned NULL.  */\n  if (p != NULL)\n    {\n      /* Attempt to quickly distinguish the mmalloca() result - which has\n         a magic indicator word - and the alloca() result - which has an\n         uninitialized indicator word.  It is for this test that sa_increment\n         additional bytes are allocated in the alloca() case.  */\n      if (((int *) p)[-1] == MAGIC_NUMBER)\n        {\n          /* Looks like a mmalloca() result.  To see whether it really is one,\n             perform a lookup in the hash table.  */\n          size_t slot = (uintptr_t) p % HASH_TABLE_SIZE;\n          void **chain = &mmalloca_results[slot];\n          for (; *chain != NULL;)\n            {\n              union header *h = p;\n              if (*chain == p)\n                {\n                  /* Found it.  Remove it from the hash table and free it.  */\n                  union header *p_begin = h - 1;\n                  *chain = p_begin->next;\n                  free (p_begin);\n                  return;\n                }\n              h = *chain;\n              chain = &h[-1].next;\n            }\n        }\n      /* At this point, we know it was not a mmalloca() result.  */\n    }\n}",
      "lines": 34,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/malloca.h": {},
  "libidn/libidn2-2.0.5/unistring/stdbool.in.h": {},
  "libidn/libidn2-2.0.5/unistring/stdint.in.h": {},
  "libidn/libidn2-2.0.5/unistring/striconveh.c": {
    "iconveh_open": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "int\niconveh_open (const char *to_codeset, const char *from_codeset, iconveh_t *cdp)\n{\n  iconv_t cd;\n  iconv_t cd1;\n  iconv_t cd2;\n\n  /* Avoid glibc-2.1 bug with EUC-KR.  */\n# if ((__GLIBC__ == 2 && __GLIBC_MINOR__ <= 1) && !defined __UCLIBC__) \\\n     && !defined _LIBICONV_VERSION\n  if (c_strcasecmp (from_codeset, \"EUC-KR\") == 0\n      || c_strcasecmp (to_codeset, \"EUC-KR\") == 0)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n# endif\n\n  cd = iconv_open (to_codeset, from_codeset);\n\n  if (STRCASEEQ (from_codeset, \"UTF-8\", 'U','T','F','-','8',0,0,0,0))\n    cd1 = (iconv_t)(-1);\n  else\n    {\n      cd1 = iconv_open (\"UTF-8\", from_codeset);\n      if (cd1 == (iconv_t)(-1))\n        {\n          int saved_errno = errno;\n          if (cd != (iconv_t)(-1))\n            iconv_close (cdp->cd);\n          errno = saved_errno;\n          return -1;\n        }\n    }\n\n  if (STRCASEEQ (to_codeset, \"UTF-8\", 'U','T','F','-','8',0,0,0,0)\n# if (((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 2) || __GLIBC__ > 2) \\\n      && !defined __UCLIBC__) \\\n     || _LIBICONV_VERSION >= 0x0105\n      || c_strcasecmp (to_codeset, \"UTF-8//TRANSLIT\") == 0\n# endif\n     )\n    cd2 = (iconv_t)(-1);\n  else\n    {\n      cd2 = iconv_open (to_codeset, \"UTF-8\");\n      if (cd2 == (iconv_t)(-1))\n        {\n          int saved_errno = errno;\n          if (cd1 != (iconv_t)(-1))\n            iconv_close (cd1);\n          if (cd != (iconv_t)(-1))\n            iconv_close (cd);\n          errno = saved_errno;\n          return -1;\n        }\n    }\n\n  cdp->cd = cd;\n  cdp->cd1 = cd1;\n  cdp->cd2 = cd2;\n  return 0;\n}",
      "lines": 63,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "iconveh_close": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "int\niconveh_close (const iconveh_t *cd)\n{\n  if (cd->cd2 != (iconv_t)(-1) && iconv_close (cd->cd2) < 0)\n    {\n      /* Return -1, but preserve the errno from iconv_close.  */\n      int saved_errno = errno;\n      if (cd->cd1 != (iconv_t)(-1))\n        iconv_close (cd->cd1);\n      if (cd->cd != (iconv_t)(-1))\n        iconv_close (cd->cd);\n      errno = saved_errno;\n      return -1;\n    }\n  if (cd->cd1 != (iconv_t)(-1) && iconv_close (cd->cd1) < 0)\n    {\n      /* Return -1, but preserve the errno from iconv_close.  */\n      int saved_errno = errno;\n      if (cd->cd != (iconv_t)(-1))\n        iconv_close (cd->cd);\n      errno = saved_errno;\n      return -1;\n    }\n  if (cd->cd != (iconv_t)(-1) && iconv_close (cd->cd) < 0)\n    return -1;\n  return 0;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "iconv_carefully": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        216,
        1
      ],
      "content": "static size_t\niconv_carefully (iconv_t cd,\n                 const char **inbuf, size_t *inbytesleft,\n                 char **outbuf, size_t *outbytesleft,\n                 bool *incremented)\n{\n  const char *inptr = *inbuf;\n  const char *inptr_end = inptr + *inbytesleft;\n  char *outptr = *outbuf;\n  size_t outsize = *outbytesleft;\n  const char *inptr_before;\n  size_t res;\n\n  do\n    {\n      size_t insize;\n\n      inptr_before = inptr;\n      res = (size_t)(-1);\n\n      for (insize = 1; inptr + insize <= inptr_end; insize++)\n        {\n          res = iconv (cd,\n                       (ICONV_CONST char **) &inptr, &insize,\n                       &outptr, &outsize);\n          if (!(res == (size_t)(-1) && errno == EINVAL))\n            break;\n          /* iconv can eat up a shift sequence but give EINVAL while attempting\n             to convert the first character.  E.g. libiconv does this.  */\n          if (inptr > inptr_before)\n            {\n              res = 0;\n              break;\n            }\n        }\n\n      if (res == 0)\n        {\n          *outbuf = outptr;\n          *outbytesleft = outsize;\n        }\n    }\n  while (res == 0 && inptr < inptr_end);\n\n  *inbuf = inptr;\n  *inbytesleft = inptr_end - inptr;\n  if (res != (size_t)(-1) && res > 0)\n    {\n      /* iconv() has already incremented INPTR.  We cannot go back to a\n         previous INPTR, otherwise the state inside CD would become invalid,\n         if FROM_CODESET is a stateful encoding.  So, tell the caller that\n         *INBUF has already been incremented.  */\n      *incremented = (inptr > inptr_before);\n      errno = EILSEQ;\n      return (size_t)(-1);\n    }\n  else\n    {\n      *incremented = false;\n      return res;\n    }\n}",
      "lines": 62,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "iconv_carefully_1": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "static size_t\niconv_carefully_1 (iconv_t cd,\n                   const char **inbuf, size_t *inbytesleft,\n                   char **outbuf, size_t *outbytesleft,\n                   bool *incremented)\n{\n  const char *inptr_before = *inbuf;\n  const char *inptr = inptr_before;\n  const char *inptr_end = inptr_before + *inbytesleft;\n  char *outptr = *outbuf;\n  size_t outsize = *outbytesleft;\n  size_t res = (size_t)(-1);\n  size_t insize;\n\n  for (insize = 1; inptr_before + insize <= inptr_end; insize++)\n    {\n      inptr = inptr_before;\n      res = iconv (cd,\n                   (ICONV_CONST char **) &inptr, &insize,\n                   &outptr, &outsize);\n      if (!(res == (size_t)(-1) && errno == EINVAL))\n        break;\n      /* iconv can eat up a shift sequence but give EINVAL while attempting\n         to convert the first character.  E.g. libiconv does this.  */\n      if (inptr > inptr_before)\n        {\n          res = 0;\n          break;\n        }\n    }\n\n  *inbuf = inptr;\n  *inbytesleft = inptr_end - inptr;\n# if !defined _LIBICONV_VERSION && !(defined __GLIBC__ && !defined __UCLIBC__)\n  /* Irix iconv() inserts a NUL byte if it cannot convert.\n     NetBSD iconv() inserts a question mark if it cannot convert.\n     Only GNU libiconv and GNU libc are known to prefer to fail rather\n     than doing a lossy conversion.  */\n  if (res != (size_t)(-1) && res > 0)\n    {\n      /* iconv() has already incremented INPTR.  We cannot go back to a\n         previous INPTR, otherwise the state inside CD would become invalid,\n         if FROM_CODESET is a stateful encoding.  So, tell the caller that\n         *INBUF has already been incremented.  */\n      *incremented = (inptr > inptr_before);\n      errno = EILSEQ;\n      return (size_t)(-1);\n    }\n# endif\n\n  if (res != (size_t)(-1))\n    {\n      *outbuf = outptr;\n      *outbytesleft = outsize;\n    }\n  *incremented = false;\n  return res;\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "utf8conv_carefully": {
      "start_point": [
        291,
        0
      ],
      "end_point": [
        355,
        1
      ],
      "content": "static size_t\nutf8conv_carefully (bool one_character_only,\n                    const char **inbuf, size_t *inbytesleft,\n                    char **outbuf, size_t *outbytesleft,\n                    bool *incremented)\n{\n  const char *inptr = *inbuf;\n  size_t insize = *inbytesleft;\n  char *outptr = *outbuf;\n  size_t outsize = *outbytesleft;\n  size_t res;\n\n  res = 0;\n  do\n    {\n      ucs4_t uc;\n      int n;\n      int m;\n\n      n = u8_mbtoucr (&uc, (const uint8_t *) inptr, insize);\n      if (n < 0)\n        {\n          errno = (n == -2 ? EINVAL : EILSEQ);\n          n = u8_mbtouc (&uc, (const uint8_t *) inptr, insize);\n          inptr += n;\n          insize -= n;\n          res = (size_t)(-1);\n          *incremented = true;\n          break;\n        }\n      if (outsize == 0)\n        {\n          errno = E2BIG;\n          res = (size_t)(-1);\n          *incremented = false;\n          break;\n        }\n      m = u8_uctomb ((uint8_t *) outptr, uc, outsize);\n      if (m == -2)\n        {\n          errno = E2BIG;\n          res = (size_t)(-1);\n          *incremented = false;\n          break;\n        }\n      inptr += n;\n      insize -= n;\n      if (m == -1)\n        {\n          errno = EILSEQ;\n          res = (size_t)(-1);\n          *incremented = true;\n          break;\n        }\n      outptr += m;\n      outsize -= m;\n    }\n  while (!one_character_only && insize > 0);\n\n  *inbuf = inptr;\n  *inbytesleft = insize;\n  *outbuf = outptr;\n  *outbytesleft = outsize;\n  return res;\n}",
      "lines": 65,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "mem_cd_iconveh_internal": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        1022,
        1
      ],
      "content": "static int\nmem_cd_iconveh_internal (const char *src, size_t srclen,\n                         iconv_t cd, iconv_t cd1, iconv_t cd2,\n                         enum iconv_ilseq_handler handler,\n                         size_t extra_alloc,\n                         size_t *offsets,\n                         char **resultp, size_t *lengthp)\n{\n  /* When a conversion error occurs, we cannot start using CD1 and CD2 at\n     this point: FROM_CODESET may be a stateful encoding like ISO-2022-KR.\n     Instead, we have to start afresh from the beginning of SRC.  */\n  /* Use a temporary buffer, so that for small strings, a single malloc()\n     call will be sufficient.  */\n# define tmpbufsize 4096\n  /* The alignment is needed when converting e.g. to glibc's WCHAR_T or\n     libiconv's UCS-4-INTERNAL encoding.  */\n  union { unsigned int align; char buf[tmpbufsize]; } tmp;\n# define tmpbuf tmp.buf\n\n  char *initial_result;\n  char *result;\n  size_t allocated;\n  size_t length;\n  size_t last_length = (size_t)(-1); /* only needed if offsets != NULL */\n\n  if (*resultp != NULL && *lengthp >= sizeof (tmpbuf))\n    {\n      initial_result = *resultp;\n      allocated = *lengthp;\n    }\n  else\n    {\n      initial_result = tmpbuf;\n      allocated = sizeof (tmpbuf);\n    }\n  result = initial_result;\n\n  /* Test whether a direct conversion is possible at all.  */\n  if (cd == (iconv_t)(-1))\n    goto indirectly;\n\n  if (offsets != NULL)\n    {\n      size_t i;\n\n      for (i = 0; i < srclen; i++)\n        offsets[i] = (size_t)(-1);\n\n      last_length = (size_t)(-1);\n    }\n  length = 0;\n\n  /* First, try a direct conversion, and see whether a conversion error\n     occurs at all.  */\n  {\n    const char *inptr = src;\n    size_t insize = srclen;\n\n    /* Avoid glibc-2.1 bug and Solaris 2.7-2.9 bug.  */\n# if defined _LIBICONV_VERSION \\\n     || !(((__GLIBC__ == 2 && __GLIBC_MINOR__ <= 1) && !defined __UCLIBC__) \\\n          || defined __sun)\n    /* Set to the initial state.  */\n    iconv (cd, NULL, NULL, NULL, NULL);\n# endif\n\n    while (insize > 0)\n      {\n        char *outptr = result + length;\n        size_t outsize = allocated - extra_alloc - length;\n        bool incremented;\n        size_t res;\n        bool grow;\n\n        if (offsets != NULL)\n          {\n            if (length != last_length) /* ensure that offset[] be increasing */\n              {\n                offsets[inptr - src] = length;\n                last_length = length;\n              }\n            res = iconv_carefully_1 (cd,\n                                     &inptr, &insize,\n                                     &outptr, &outsize,\n                                     &incremented);\n          }\n        else\n          /* Use iconv_carefully instead of iconv here, because:\n             - If TO_CODESET is UTF-8, we can do the error handling in this\n               loop, no need for a second loop,\n             - With iconv() implementations other than GNU libiconv and GNU\n               libc, if we use iconv() in a big swoop, checking for an E2BIG\n               return, we lose the number of irreversible conversions.  */\n          res = iconv_carefully (cd,\n                                 &inptr, &insize,\n                                 &outptr, &outsize,\n                                 &incremented);\n\n        length = outptr - result;\n        grow = (length + extra_alloc > allocated / 2);\n        if (res == (size_t)(-1))\n          {\n            if (errno == E2BIG)\n              grow = true;\n            else if (errno == EINVAL)\n              break;\n            else if (errno == EILSEQ && handler != iconveh_error)\n              {\n                if (cd2 == (iconv_t)(-1))\n                  {\n                    /* TO_CODESET is UTF-8.  */\n                    /* Error handling can produce up to 1 byte of output.  */\n                    if (length + 1 + extra_alloc > allocated)\n                      {\n                        char *memory;\n\n                        allocated = 2 * allocated;\n                        if (length + 1 + extra_alloc > allocated)\n                          abort ();\n                        if (result == initial_result)\n                          memory = (char *) malloc (allocated);\n                        else\n                          memory = (char *) realloc (result, allocated);\n                        if (memory == NULL)\n                          {\n                            if (result != initial_result)\n                              free (result);\n                            errno = ENOMEM;\n                            return -1;\n                          }\n                        if (result == initial_result)\n                          memcpy (memory, initial_result, length);\n                        result = memory;\n                        grow = false;\n                      }\n                    /* The input is invalid in FROM_CODESET.  Eat up one byte\n                       and emit a question mark.  */\n                    if (!incremented)\n                      {\n                        if (insize == 0)\n                          abort ();\n                        inptr++;\n                        insize--;\n                      }\n                    result[length] = '?';\n                    length++;\n                  }\n                else\n                  goto indirectly;\n              }\n            else\n              {\n                if (result != initial_result)\n                  {\n                    int saved_errno = errno;\n                    free (result);\n                    errno = saved_errno;\n                  }\n                return -1;\n              }\n          }\n        if (insize == 0)\n          break;\n        if (grow)\n          {\n            char *memory;\n\n            allocated = 2 * allocated;\n            if (result == initial_result)\n              memory = (char *) malloc (allocated);\n            else\n              memory = (char *) realloc (result, allocated);\n            if (memory == NULL)\n              {\n                if (result != initial_result)\n                  free (result);\n                errno = ENOMEM;\n                return -1;\n              }\n            if (result == initial_result)\n              memcpy (memory, initial_result, length);\n            result = memory;\n          }\n      }\n  }\n\n  /* Now get the conversion state back to the initial state.\n     But avoid glibc-2.1 bug and Solaris 2.7 bug.  */\n#if defined _LIBICONV_VERSION \\\n    || !(((__GLIBC__ == 2 && __GLIBC_MINOR__ <= 1) && !defined __UCLIBC__) \\\n         || defined __sun)\n  for (;;)\n    {\n      char *outptr = result + length;\n      size_t outsize = allocated - extra_alloc - length;\n      size_t res;\n\n      res = iconv (cd, NULL, NULL, &outptr, &outsize);\n      length = outptr - result;\n      if (res == (size_t)(-1))\n        {\n          if (errno == E2BIG)\n            {\n              char *memory;\n\n              allocated = 2 * allocated;\n              if (result == initial_result)\n                memory = (char *) malloc (allocated);\n              else\n                memory = (char *) realloc (result, allocated);\n              if (memory == NULL)\n                {\n                  if (result != initial_result)\n                    free (result);\n                  errno = ENOMEM;\n                  return -1;\n                }\n              if (result == initial_result)\n                memcpy (memory, initial_result, length);\n              result = memory;\n            }\n          else\n            {\n              if (result != initial_result)\n                {\n                  int saved_errno = errno;\n                  free (result);\n                  errno = saved_errno;\n                }\n              return -1;\n            }\n        }\n      else\n        break;\n    }\n#endif\n\n  /* The direct conversion succeeded.  */\n  goto done;\n\n indirectly:\n  /* The direct conversion failed.\n     Use a conversion through UTF-8.  */\n  if (offsets != NULL)\n    {\n      size_t i;\n\n      for (i = 0; i < srclen; i++)\n        offsets[i] = (size_t)(-1);\n\n      last_length = (size_t)(-1);\n    }\n  length = 0;\n  {\n    const bool slowly = (offsets != NULL || handler == iconveh_error);\n# define utf8bufsize 4096 /* may also be smaller or larger than tmpbufsize */\n    char utf8buf[utf8bufsize + 1];\n    size_t utf8len = 0;\n    const char *in1ptr = src;\n    size_t in1size = srclen;\n    bool do_final_flush1 = true;\n    bool do_final_flush2 = true;\n\n    /* Avoid glibc-2.1 bug and Solaris 2.7-2.9 bug.  */\n# if defined _LIBICONV_VERSION \\\n     || !(((__GLIBC__ == 2 && __GLIBC_MINOR__ <= 1) && !defined __UCLIBC__) \\\n          || defined __sun)\n    /* Set to the initial state.  */\n    if (cd1 != (iconv_t)(-1))\n      iconv (cd1, NULL, NULL, NULL, NULL);\n    if (cd2 != (iconv_t)(-1))\n      iconv (cd2, NULL, NULL, NULL, NULL);\n# endif\n\n    while (in1size > 0 || do_final_flush1 || utf8len > 0 || do_final_flush2)\n      {\n        char *out1ptr = utf8buf + utf8len;\n        size_t out1size = utf8bufsize - utf8len;\n        bool incremented1;\n        size_t res1;\n        int errno1;\n\n        /* Conversion step 1: from FROM_CODESET to UTF-8.  */\n        if (in1size > 0)\n          {\n            if (offsets != NULL\n                && length != last_length) /* ensure that offset[] be increasing */\n              {\n                offsets[in1ptr - src] = length;\n                last_length = length;\n              }\n            if (cd1 != (iconv_t)(-1))\n              {\n                if (slowly)\n                  res1 = iconv_carefully_1 (cd1,\n                                            &in1ptr, &in1size,\n                                            &out1ptr, &out1size,\n                                            &incremented1);\n                else\n                  res1 = iconv_carefully (cd1,\n                                          &in1ptr, &in1size,\n                                          &out1ptr, &out1size,\n                                          &incremented1);\n              }\n            else\n              {\n                /* FROM_CODESET is UTF-8.  */\n                res1 = utf8conv_carefully (slowly,\n                                           &in1ptr, &in1size,\n                                           &out1ptr, &out1size,\n                                           &incremented1);\n              }\n          }\n        else if (do_final_flush1)\n          {\n            /* Now get the conversion state of CD1 back to the initial state.\n               But avoid glibc-2.1 bug and Solaris 2.7 bug.  */\n# if defined _LIBICONV_VERSION \\\n     || !(((__GLIBC__ == 2 && __GLIBC_MINOR__ <= 1) && !defined __UCLIBC__) \\\n          || defined __sun)\n            if (cd1 != (iconv_t)(-1))\n              res1 = iconv (cd1, NULL, NULL, &out1ptr, &out1size);\n            else\n# endif\n              res1 = 0;\n            do_final_flush1 = false;\n            incremented1 = true;\n          }\n        else\n          {\n            res1 = 0;\n            incremented1 = true;\n          }\n        if (res1 == (size_t)(-1)\n            && !(errno == E2BIG || errno == EINVAL || errno == EILSEQ))\n          {\n            if (result != initial_result)\n              {\n                int saved_errno = errno;\n                free (result);\n                errno = saved_errno;\n              }\n            return -1;\n          }\n        if (res1 == (size_t)(-1)\n            && errno == EILSEQ && handler != iconveh_error)\n          {\n            /* The input is invalid in FROM_CODESET.  Eat up one byte and\n               emit a question mark.  Room for the question mark was allocated\n               at the end of utf8buf.  */\n            if (!incremented1)\n              {\n                if (in1size == 0)\n                  abort ();\n                in1ptr++;\n                in1size--;\n              }\n            *out1ptr++ = '?';\n            res1 = 0;\n          }\n        errno1 = errno;\n        utf8len = out1ptr - utf8buf;\n\n        if (offsets != NULL\n            || in1size == 0\n            || utf8len > utf8bufsize / 2\n            || (res1 == (size_t)(-1) && errno1 == E2BIG))\n          {\n            /* Conversion step 2: from UTF-8 to TO_CODESET.  */\n            const char *in2ptr = utf8buf;\n            size_t in2size = utf8len;\n\n            while (in2size > 0\n                   || (in1size == 0 && !do_final_flush1 && do_final_flush2))\n              {\n                char *out2ptr = result + length;\n                size_t out2size = allocated - extra_alloc - length;\n                bool incremented2;\n                size_t res2;\n                bool grow;\n\n                if (in2size > 0)\n                  {\n                    if (cd2 != (iconv_t)(-1))\n                      res2 = iconv_carefully (cd2,\n                                              &in2ptr, &in2size,\n                                              &out2ptr, &out2size,\n                                              &incremented2);\n                    else\n                      /* TO_CODESET is UTF-8.  */\n                      res2 = utf8conv_carefully (false,\n                                                 &in2ptr, &in2size,\n                                                 &out2ptr, &out2size,\n                                                 &incremented2);\n                  }\n                else /* in1size == 0 && !do_final_flush1\n                        && in2size == 0 && do_final_flush2 */\n                  {\n                    /* Now get the conversion state of CD1 back to the initial\n                       state.  But avoid glibc-2.1 bug and Solaris 2.7 bug.  */\n# if defined _LIBICONV_VERSION \\\n     || !(((__GLIBC__ == 2 && __GLIBC_MINOR__ <= 1) && !defined __UCLIBC__) \\\n          || defined __sun)\n                    if (cd2 != (iconv_t)(-1))\n                      res2 = iconv (cd2, NULL, NULL, &out2ptr, &out2size);\n                    else\n# endif\n                      res2 = 0;\n                    do_final_flush2 = false;\n                    incremented2 = true;\n                  }\n\n                length = out2ptr - result;\n                grow = (length + extra_alloc > allocated / 2);\n                if (res2 == (size_t)(-1))\n                  {\n                    if (errno == E2BIG)\n                      grow = true;\n                    else if (errno == EINVAL)\n                      break;\n                    else if (errno == EILSEQ && handler != iconveh_error)\n                      {\n                        /* Error handling can produce up to 10 bytes of ASCII\n                           output.  But TO_CODESET may be UCS-2, UTF-16 or\n                           UCS-4, so use CD2 here as well.  */\n                        char scratchbuf[10];\n                        size_t scratchlen;\n                        ucs4_t uc;\n                        const char *inptr;\n                        size_t insize;\n                        size_t res;\n\n                        if (incremented2)\n                          {\n                            if (u8_prev (&uc, (const uint8_t *) in2ptr,\n                                         (const uint8_t *) utf8buf)\n                                == NULL)\n                              abort ();\n                          }\n                        else\n                          {\n                            int n;\n                            if (in2size == 0)\n                              abort ();\n                            n = u8_mbtouc_unsafe (&uc, (const uint8_t *) in2ptr,\n                                                  in2size);\n                            in2ptr += n;\n                            in2size -= n;\n                          }\n\n                        if (handler == iconveh_escape_sequence)\n                          {\n                            static char hex[16] = \"0123456789ABCDEF\";\n                            scratchlen = 0;\n                            scratchbuf[scratchlen++] = '\\\\';\n                            if (uc < 0x10000)\n                              scratchbuf[scratchlen++] = 'u';\n                            else\n                              {\n                                scratchbuf[scratchlen++] = 'U';\n                                scratchbuf[scratchlen++] = hex[(uc>>28) & 15];\n                                scratchbuf[scratchlen++] = hex[(uc>>24) & 15];\n                                scratchbuf[scratchlen++] = hex[(uc>>20) & 15];\n                                scratchbuf[scratchlen++] = hex[(uc>>16) & 15];\n                              }\n                            scratchbuf[scratchlen++] = hex[(uc>>12) & 15];\n                            scratchbuf[scratchlen++] = hex[(uc>>8) & 15];\n                            scratchbuf[scratchlen++] = hex[(uc>>4) & 15];\n                            scratchbuf[scratchlen++] = hex[uc & 15];\n                          }\n                        else\n                          {\n                            scratchbuf[0] = '?';\n                            scratchlen = 1;\n                          }\n\n                        inptr = scratchbuf;\n                        insize = scratchlen;\n                        if (cd2 != (iconv_t)(-1))\n                          res = iconv (cd2,\n                                       (ICONV_CONST char **) &inptr, &insize,\n                                       &out2ptr, &out2size);\n                        else\n                          {\n                            /* TO_CODESET is UTF-8.  */\n                            if (out2size >= insize)\n                              {\n                                memcpy (out2ptr, inptr, insize);\n                                out2ptr += insize;\n                                out2size -= insize;\n                                inptr += insize;\n                                insize = 0;\n                                res = 0;\n                              }\n                            else\n                              {\n                                errno = E2BIG;\n                                res = (size_t)(-1);\n                              }\n                          }\n                        length = out2ptr - result;\n                        if (res == (size_t)(-1) && errno == E2BIG)\n                          {\n                            char *memory;\n\n                            allocated = 2 * allocated;\n                            if (length + 1 + extra_alloc > allocated)\n                              abort ();\n                            if (result == initial_result)\n                              memory = (char *) malloc (allocated);\n                            else\n                              memory = (char *) realloc (result, allocated);\n                            if (memory == NULL)\n                              {\n                                if (result != initial_result)\n                                  free (result);\n                                errno = ENOMEM;\n                                return -1;\n                              }\n                            if (result == initial_result)\n                              memcpy (memory, initial_result, length);\n                            result = memory;\n                            grow = false;\n\n                            out2ptr = result + length;\n                            out2size = allocated - extra_alloc - length;\n                            if (cd2 != (iconv_t)(-1))\n                              res = iconv (cd2,\n                                           (ICONV_CONST char **) &inptr,\n                                           &insize,\n                                           &out2ptr, &out2size);\n                            else\n                              {\n                                /* TO_CODESET is UTF-8.  */\n                                if (!(out2size >= insize))\n                                  abort ();\n                                memcpy (out2ptr, inptr, insize);\n                                out2ptr += insize;\n                                out2size -= insize;\n                                inptr += insize;\n                                insize = 0;\n                                res = 0;\n                              }\n                            length = out2ptr - result;\n                          }\n# if !defined _LIBICONV_VERSION && !(defined __GLIBC__ && !defined __UCLIBC__)\n                        /* Irix iconv() inserts a NUL byte if it cannot convert.\n                           NetBSD iconv() inserts a question mark if it cannot\n                           convert.\n                           Only GNU libiconv and GNU libc are known to prefer\n                           to fail rather than doing a lossy conversion.  */\n                        if (res != (size_t)(-1) && res > 0)\n                          {\n                            errno = EILSEQ;\n                            res = (size_t)(-1);\n                          }\n# endif\n                        if (res == (size_t)(-1))\n                          {\n                            /* Failure converting the ASCII replacement.  */\n                            if (result != initial_result)\n                              {\n                                int saved_errno = errno;\n                                free (result);\n                                errno = saved_errno;\n                              }\n                            return -1;\n                          }\n                      }\n                    else\n                      {\n                        if (result != initial_result)\n                          {\n                            int saved_errno = errno;\n                            free (result);\n                            errno = saved_errno;\n                          }\n                        return -1;\n                      }\n                  }\n                if (!(in2size > 0\n                      || (in1size == 0 && !do_final_flush1 && do_final_flush2)))\n                  break;\n                if (grow)\n                  {\n                    char *memory;\n\n                    allocated = 2 * allocated;\n                    if (result == initial_result)\n                      memory = (char *) malloc (allocated);\n                    else\n                      memory = (char *) realloc (result, allocated);\n                    if (memory == NULL)\n                      {\n                        if (result != initial_result)\n                          free (result);\n                        errno = ENOMEM;\n                        return -1;\n                      }\n                    if (result == initial_result)\n                      memcpy (memory, initial_result, length);\n                    result = memory;\n                  }\n              }\n\n            /* Move the remaining bytes to the beginning of utf8buf.  */\n            if (in2size > 0)\n              memmove (utf8buf, in2ptr, in2size);\n            utf8len = in2size;\n          }\n\n        if (res1 == (size_t)(-1))\n          {\n            if (errno1 == EINVAL)\n              in1size = 0;\n            else if (errno1 == EILSEQ)\n              {\n                if (result != initial_result)\n                  free (result);\n                errno = errno1;\n                return -1;\n              }\n          }\n      }\n# undef utf8bufsize\n  }\n\n done:\n  /* Now the final memory allocation.  */\n  if (result == tmpbuf)\n    {\n      size_t memsize = length + extra_alloc;\n\n      if (*resultp != NULL && *lengthp >= memsize)\n        result = *resultp;\n      else\n        {\n          char *memory;\n\n          memory = (char *) malloc (memsize > 0 ? memsize : 1);\n          if (memory != NULL)\n            result = memory;\n          else\n            {\n              errno = ENOMEM;\n              return -1;\n            }\n        }\n      memcpy (result, tmpbuf, length);\n    }\n  else if (result != *resultp && length + extra_alloc < allocated)\n    {\n      /* Shrink the allocated memory if possible.  */\n      size_t memsize = length + extra_alloc;\n      char *memory;\n\n      memory = (char *) realloc (result, memsize > 0 ? memsize : 1);\n      if (memory != NULL)\n        result = memory;\n    }\n  *resultp = result;\n  *lengthp = length;\n  return 0;\n# undef tmpbuf\n# undef tmpbufsize\n}",
      "lines": 666,
      "depth": 27,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mem_cd_iconveh": {
      "start_point": [
        1024,
        0
      ],
      "end_point": [
        1033,
        1
      ],
      "content": "int\nmem_cd_iconveh (const char *src, size_t srclen,\n                const iconveh_t *cd,\n                enum iconv_ilseq_handler handler,\n                size_t *offsets,\n                char **resultp, size_t *lengthp)\n{\n  return mem_cd_iconveh_internal (src, srclen, cd->cd, cd->cd1, cd->cd2,\n                                  handler, 0, offsets, resultp, lengthp);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "str_cd_iconveh": {
      "start_point": [
        1035,
        0
      ],
      "end_point": [
        1065,
        1
      ],
      "content": "char *\nstr_cd_iconveh (const char *src,\n                const iconveh_t *cd,\n                enum iconv_ilseq_handler handler)\n{\n  /* For most encodings, a trailing NUL byte in the input will be converted\n     to a trailing NUL byte in the output.  But not for UTF-7.  So that this\n     function is usable for UTF-7, we have to exclude the NUL byte from the\n     conversion and add it by hand afterwards.  */\n  char *result = NULL;\n  size_t length = 0;\n  int retval = mem_cd_iconveh_internal (src, strlen (src),\n                                        cd->cd, cd->cd1, cd->cd2, handler, 1,\n                                        NULL, &result, &length);\n\n  if (retval < 0)\n    {\n      if (result != NULL)\n        {\n          int saved_errno = errno;\n          free (result);\n          errno = saved_errno;\n        }\n      return NULL;\n    }\n\n  /* Add the terminating NUL byte.  */\n  result[length] = '\\0';\n\n  return result;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "char",
        "*\nstr_cd_iconveh (const char *src,\n                const iconveh_t *cd,\n                enum iconv_ilseq_handler handler)",
        "*"
      ]
    },
    "mem_iconveh": {
      "start_point": [
        1069,
        0
      ],
      "end_point": [
        1151,
        1
      ],
      "content": "int\nmem_iconveh (const char *src, size_t srclen,\n             const char *from_codeset, const char *to_codeset,\n             enum iconv_ilseq_handler handler,\n             size_t *offsets,\n             char **resultp, size_t *lengthp)\n{\n  if (srclen == 0)\n    {\n      /* Nothing to convert.  */\n      *lengthp = 0;\n      return 0;\n    }\n  else if (offsets == NULL && c_strcasecmp (from_codeset, to_codeset) == 0)\n    {\n      char *result;\n\n      if (*resultp != NULL && *lengthp >= srclen)\n        result = *resultp;\n      else\n        {\n          result = (char *) malloc (srclen);\n          if (result == NULL)\n            {\n              errno = ENOMEM;\n              return -1;\n            }\n        }\n      memcpy (result, src, srclen);\n      *resultp = result;\n      *lengthp = srclen;\n      return 0;\n    }\n  else\n    {\n#if HAVE_ICONV\n      iconveh_t cd;\n      char *result;\n      size_t length;\n      int retval;\n\n      if (iconveh_open (to_codeset, from_codeset, &cd) < 0)\n        return -1;\n\n      result = *resultp;\n      length = *lengthp;\n      retval = mem_cd_iconveh (src, srclen, &cd, handler, offsets,\n                               &result, &length);\n\n      if (retval < 0)\n        {\n          /* Close cd, but preserve the errno from str_cd_iconv.  */\n          int saved_errno = errno;\n          iconveh_close (&cd);\n          errno = saved_errno;\n        }\n      else\n        {\n          if (iconveh_close (&cd) < 0)\n            {\n              /* Return -1, but free the allocated memory, and while doing\n                 that, preserve the errno from iconveh_close.  */\n              int saved_errno = errno;\n              if (result != *resultp && result != NULL)\n                free (result);\n              errno = saved_errno;\n              return -1;\n            }\n          *resultp = result;\n          *lengthp = length;\n        }\n      return retval;\n#else\n      /* This is a different error code than if iconv_open existed but didn't\n         support from_codeset and to_codeset, so that the caller can emit\n         an error message such as\n           \"iconv() is not supported. Installing GNU libiconv and\n            then reinstalling this package would fix this.\"  */\n      errno = ENOSYS;\n      return -1;\n#endif\n    }\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "str_iconveh": {
      "start_point": [
        1153,
        0
      ],
      "end_point": [
        1207,
        1
      ],
      "content": "char *\nstr_iconveh (const char *src,\n             const char *from_codeset, const char *to_codeset,\n             enum iconv_ilseq_handler handler)\n{\n  if (*src == '\\0' || c_strcasecmp (from_codeset, to_codeset) == 0)\n    {\n      char *result = strdup (src);\n\n      if (result == NULL)\n        errno = ENOMEM;\n      return result;\n    }\n  else\n    {\n#if HAVE_ICONV\n      iconveh_t cd;\n      char *result;\n\n      if (iconveh_open (to_codeset, from_codeset, &cd) < 0)\n        return NULL;\n\n      result = str_cd_iconveh (src, &cd, handler);\n\n      if (result == NULL)\n        {\n          /* Close cd, but preserve the errno from str_cd_iconv.  */\n          int saved_errno = errno;\n          iconveh_close (&cd);\n          errno = saved_errno;\n        }\n      else\n        {\n          if (iconveh_close (&cd) < 0)\n            {\n              /* Return NULL, but free the allocated memory, and while doing\n                 that, preserve the errno from iconveh_close.  */\n              int saved_errno = errno;\n              free (result);\n              errno = saved_errno;\n              return NULL;\n            }\n        }\n      return result;\n#else\n      /* This is a different error code than if iconv_open existed but didn't\n         support from_codeset and to_codeset, so that the caller can emit\n         an error message such as\n           \"iconv() is not supported. Installing GNU libiconv and\n            then reinstalling this package would fix this.\"  */\n      errno = ENOSYS;\n      return NULL;\n#endif\n    }\n}",
      "lines": 55,
      "depth": 14,
      "decorators": [
        "char",
        "*\nstr_iconveh (const char *src,\n             const char *from_codeset, const char *to_codeset,\n             enum iconv_ilseq_handler handler)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/striconveh.h": {},
  "libidn/libidn2-2.0.5/unistring/striconveha.c": {
    "uniconv_register_autodetect": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "int\nuniconv_register_autodetect (const char *name,\n                             const char * const *try_in_order)\n{\n  size_t namelen;\n  size_t listlen;\n  size_t memneed;\n  size_t i;\n  char *memory;\n  struct autodetect_alias *new_alias;\n  char *new_name;\n  const char **new_try_in_order;\n\n  /* The TRY_IN_ORDER list must not be empty.  */\n  if (try_in_order[0] == NULL)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  /* We must deep-copy NAME and TRY_IN_ORDER, because they may be allocated\n     with dynamic extent.  */\n  namelen = strlen (name) + 1;\n  memneed = sizeof (struct autodetect_alias) + namelen + sizeof (char *);\n  for (i = 0; try_in_order[i] != NULL; i++)\n    memneed += sizeof (char *) + strlen (try_in_order[i]) + 1;\n  listlen = i;\n\n  memory = (char *) malloc (memneed);\n  if (memory != NULL)\n    {\n      new_alias = (struct autodetect_alias *) memory;\n      memory += sizeof (struct autodetect_alias);\n\n      new_try_in_order = (const char **) memory;\n      memory += (listlen + 1) * sizeof (char *);\n\n      new_name = (char *) memory;\n      memcpy (new_name, name, namelen);\n      memory += namelen;\n\n      for (i = 0; i < listlen; i++)\n        {\n          size_t len = strlen (try_in_order[i]) + 1;\n          memcpy (memory, try_in_order[i], len);\n          new_try_in_order[i] = (const char *) memory;\n          memory += len;\n        }\n      new_try_in_order[i] = NULL;\n\n      /* Now insert the new alias.  */\n      new_alias->name = new_name;\n      new_alias->encodings_to_try = new_try_in_order;\n      new_alias->next = NULL;\n      /* FIXME: Not multithread-safe.  */\n      *autodetect_list_end = new_alias;\n      autodetect_list_end = &new_alias->next;\n      return 0;\n    }\n  else\n    {\n      errno = ENOMEM;\n      return -1;\n    }\n}",
      "lines": 65,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "mem_iconveha_notranslit": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "static int\nmem_iconveha_notranslit (const char *src, size_t srclen,\n                         const char *from_codeset, const char *to_codeset,\n                         enum iconv_ilseq_handler handler,\n                         size_t *offsets,\n                         char **resultp, size_t *lengthp)\n{\n  int retval = mem_iconveh (src, srclen, from_codeset, to_codeset, handler,\n                            offsets, resultp, lengthp);\n  if (retval >= 0 || errno != EINVAL)\n    return retval;\n  else\n    {\n      struct autodetect_alias *alias;\n\n      /* Unsupported from_codeset or to_codeset. Check whether the caller\n         requested autodetection.  */\n      for (alias = autodetect_list; alias != NULL; alias = alias->next)\n        if (strcmp (from_codeset, alias->name) == 0)\n          {\n            const char * const *encodings;\n\n            if (handler != iconveh_error)\n              {\n                /* First try all encodings without any forgiving.  */\n                encodings = alias->encodings_to_try;\n                do\n                  {\n                    retval = mem_iconveha_notranslit (src, srclen,\n                                                      *encodings, to_codeset,\n                                                      iconveh_error, offsets,\n                                                      resultp, lengthp);\n                    if (!(retval < 0 && errno == EILSEQ))\n                      return retval;\n                    encodings++;\n                  }\n                while (*encodings != NULL);\n              }\n\n            encodings = alias->encodings_to_try;\n            do\n              {\n                retval = mem_iconveha_notranslit (src, srclen,\n                                                  *encodings, to_codeset,\n                                                  handler, offsets,\n                                                  resultp, lengthp);\n                if (!(retval < 0 && errno == EILSEQ))\n                  return retval;\n                encodings++;\n              }\n            while (*encodings != NULL);\n\n            /* Return the last call's result.  */\n            return -1;\n          }\n\n      /* It wasn't an autodetection name.  */\n      errno = EINVAL;\n      return -1;\n    }\n}",
      "lines": 61,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mem_iconveha": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "int\nmem_iconveha (const char *src, size_t srclen,\n              const char *from_codeset, const char *to_codeset,\n              bool transliterate,\n              enum iconv_ilseq_handler handler,\n              size_t *offsets,\n              char **resultp, size_t *lengthp)\n{\n  if (srclen == 0)\n    {\n      /* Nothing to convert.  */\n      *lengthp = 0;\n      return 0;\n    }\n\n  /* When using GNU libc >= 2.2 or GNU libiconv >= 1.5,\n     we want to use transliteration.  */\n#if (((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 2) || __GLIBC__ > 2) \\\n     && !defined __UCLIBC__) \\\n    || _LIBICONV_VERSION >= 0x0105\n  if (transliterate)\n    {\n      int retval;\n      size_t len = strlen (to_codeset);\n      char *to_codeset_suffixed = (char *) malloca (len + 10 + 1);\n      memcpy (to_codeset_suffixed, to_codeset, len);\n      memcpy (to_codeset_suffixed + len, \"//TRANSLIT\", 10 + 1);\n\n      retval = mem_iconveha_notranslit (src, srclen,\n                                        from_codeset, to_codeset_suffixed,\n                                        handler, offsets, resultp, lengthp);\n\n      freea (to_codeset_suffixed);\n\n      return retval;\n    }\n  else\n#endif\n    return mem_iconveha_notranslit (src, srclen,\n                                    from_codeset, to_codeset,\n                                    handler, offsets, resultp, lengthp);\n}",
      "lines": 42,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "str_iconveha_notranslit": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "static char *\nstr_iconveha_notranslit (const char *src,\n                         const char *from_codeset, const char *to_codeset,\n                         enum iconv_ilseq_handler handler)\n{\n  char *result = str_iconveh (src, from_codeset, to_codeset, handler);\n\n  if (result != NULL || errno != EINVAL)\n    return result;\n  else\n    {\n      struct autodetect_alias *alias;\n\n      /* Unsupported from_codeset or to_codeset. Check whether the caller\n         requested autodetection.  */\n      for (alias = autodetect_list; alias != NULL; alias = alias->next)\n        if (strcmp (from_codeset, alias->name) == 0)\n          {\n            const char * const *encodings;\n\n            if (handler != iconveh_error)\n              {\n                /* First try all encodings without any forgiving.  */\n                encodings = alias->encodings_to_try;\n                do\n                  {\n                    result = str_iconveha_notranslit (src,\n                                                      *encodings, to_codeset,\n                                                      iconveh_error);\n                    if (!(result == NULL && errno == EILSEQ))\n                      return result;\n                    encodings++;\n                  }\n                while (*encodings != NULL);\n              }\n\n            encodings = alias->encodings_to_try;\n            do\n              {\n                result = str_iconveha_notranslit (src,\n                                                  *encodings, to_codeset,\n                                                  handler);\n                if (!(result == NULL && errno == EILSEQ))\n                  return result;\n                encodings++;\n              }\n            while (*encodings != NULL);\n\n            /* Return the last call's result.  */\n            return NULL;\n          }\n\n      /* It wasn't an autodetection name.  */\n      errno = EINVAL;\n      return NULL;\n    }\n}",
      "lines": 57,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nstr_iconveha_notranslit (const char *src,\n                         const char *from_codeset, const char *to_codeset,\n                         enum iconv_ilseq_handler handler)",
        "*"
      ]
    },
    "str_iconveha": {
      "start_point": [
        322,
        0
      ],
      "end_point": [
        360,
        1
      ],
      "content": "char *\nstr_iconveha (const char *src,\n              const char *from_codeset, const char *to_codeset,\n              bool transliterate,\n              enum iconv_ilseq_handler handler)\n{\n  if (*src == '\\0' || c_strcasecmp (from_codeset, to_codeset) == 0)\n    {\n      char *result = strdup (src);\n\n      if (result == NULL)\n        errno = ENOMEM;\n      return result;\n    }\n\n  /* When using GNU libc >= 2.2 or GNU libiconv >= 1.5,\n     we want to use transliteration.  */\n#if (((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 2) || __GLIBC__ > 2) \\\n     && !defined __UCLIBC__) \\\n    || _LIBICONV_VERSION >= 0x0105\n  if (transliterate)\n    {\n      char *result;\n      size_t len = strlen (to_codeset);\n      char *to_codeset_suffixed = (char *) malloca (len + 10 + 1);\n      memcpy (to_codeset_suffixed, to_codeset, len);\n      memcpy (to_codeset_suffixed + len, \"//TRANSLIT\", 10 + 1);\n\n      result = str_iconveha_notranslit (src, from_codeset, to_codeset_suffixed,\n                                        handler);\n\n      freea (to_codeset_suffixed);\n\n      return result;\n    }\n  else\n#endif\n    return str_iconveha_notranslit (src, from_codeset, to_codeset, handler);\n}",
      "lines": 39,
      "depth": 13,
      "decorators": [
        "char",
        "*\nstr_iconveha (const char *src,\n              const char *from_codeset, const char *to_codeset,\n              bool transliterate,\n              enum iconv_ilseq_handler handler)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/striconveha.h": {},
  "libidn/libidn2-2.0.5/unistring/sys_types.in.h": {},
  "libidn/libidn2-2.0.5/unistring/uniconv.in.h": {},
  "libidn/libidn2-2.0.5/unistring/unictype.in.h": {},
  "libidn/libidn2-2.0.5/unistring/uninorm.in.h": {},
  "libidn/libidn2-2.0.5/unistring/unistr.in.h": {
    "u8_mbtouc_unsafe": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "static inline int\nu8_mbtouc_unsafe (ucs4_t *puc, const uint8_t *s, size_t n)\n{\n  uint8_t c = *s;\n\n  if (c < 0x80)\n    {\n      *puc = c;\n      return 1;\n    }\n  else\n    return u8_mbtouc_unsafe_aux (puc, s, n);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u16_mbtouc_unsafe": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "static inline int\nu16_mbtouc_unsafe (ucs4_t *puc, const uint16_t *s, size_t n)\n{\n  uint16_t c = *s;\n\n  if (c < 0xd800 || c >= 0xe000)\n    {\n      *puc = c;\n      return 1;\n    }\n  else\n    return u16_mbtouc_unsafe_aux (puc, s, n);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u32_mbtouc_unsafe": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "static inline int\nu32_mbtouc_unsafe (ucs4_t *puc,\n                   const uint32_t *s, size_t n _GL_UNUSED_PARAMETER)\n{\n  uint32_t c = *s;\n\n  if (c < 0xd800 || (c >= 0xe000 && c < 0x110000))\n    *puc = c;\n  else\n    /* invalid multibyte character */\n    *puc = 0xfffd;\n  return 1;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u8_mbtouc": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "static inline int\nu8_mbtouc (ucs4_t *puc, const uint8_t *s, size_t n)\n{\n  uint8_t c = *s;\n\n  if (c < 0x80)\n    {\n      *puc = c;\n      return 1;\n    }\n  else\n    return u8_mbtouc_aux (puc, s, n);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u16_mbtouc": {
      "start_point": [
        248,
        0
      ],
      "end_point": [
        260,
        1
      ],
      "content": "static inline int\nu16_mbtouc (ucs4_t *puc, const uint16_t *s, size_t n)\n{\n  uint16_t c = *s;\n\n  if (c < 0xd800 || c >= 0xe000)\n    {\n      *puc = c;\n      return 1;\n    }\n  else\n    return u16_mbtouc_aux (puc, s, n);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u32_mbtouc": {
      "start_point": [
        269,
        0
      ],
      "end_point": [
        280,
        1
      ],
      "content": "static inline int\nu32_mbtouc (ucs4_t *puc, const uint32_t *s, size_t n _GL_UNUSED_PARAMETER)\n{\n  uint32_t c = *s;\n\n  if (c < 0xd800 || (c >= 0xe000 && c < 0x110000))\n    *puc = c;\n  else\n    /* invalid multibyte character */\n    *puc = 0xfffd;\n  return 1;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u8_uctomb": {
      "start_point": [
        321,
        0
      ],
      "end_point": [
        331,
        1
      ],
      "content": "static inline int\nu8_uctomb (uint8_t *s, ucs4_t uc, int n)\n{\n  if (uc < 0x80 && n > 0)\n    {\n      s[0] = uc;\n      return 1;\n    }\n  else\n    return u8_uctomb_aux (s, uc, n);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u16_uctomb": {
      "start_point": [
        343,
        0
      ],
      "end_point": [
        353,
        1
      ],
      "content": "static inline int\nu16_uctomb (uint16_t *s, ucs4_t uc, int n)\n{\n  if (uc < 0xd800 && n > 0)\n    {\n      s[0] = uc;\n      return 1;\n    }\n  else\n    return u16_uctomb_aux (s, uc, n);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u32_uctomb": {
      "start_point": [
        362,
        0
      ],
      "end_point": [
        377,
        1
      ],
      "content": "static inline int\nu32_uctomb (uint32_t *s, ucs4_t uc, int n)\n{\n  if (uc < 0xd800 || (uc >= 0xe000 && uc < 0x110000))\n    {\n      if (n > 0)\n        {\n          *s = uc;\n          return 1;\n        }\n      else\n        return -2;\n    }\n  else\n    return -1;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/unitypes.in.h": {},
  "libidn/libidn2-2.0.5/unistring/unused-parameter.h": {},
  "libidn/libidn2-2.0.5/unistring/verify.h": {},
  "libidn/libidn2-2.0.5/unistring/warn-on-use.h": {},
  "libidn/libidn2-2.0.5/unistring/xalloc-oversized.h": {},
  "libidn/libidn2-2.0.5/unistring/uniconv/u-strconv-from-enc.h": {
    "FUNC": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "UNIT *\nFUNC (const char *string,\n      const char *fromcode,\n      enum iconv_ilseq_handler handler)\n{\n  UNIT *result;\n  size_t length;\n\n  result =\n    U_CONV_FROM_ENCODING (fromcode, handler,\n                          string, strlen (string) + 1, NULL,\n                          NULL, &length);\n  if (result == NULL)\n    return NULL;\n  /* Verify the result has exactly one NUL unit, at the end.  */\n  if (!(length > 0 && result[length-1] == 0\n        && U_STRLEN (result) == length-1))\n    {\n      free (result);\n      errno = EILSEQ;\n      return NULL;\n    }\n  return result;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "UNIT",
        "*\nFUNC (const char *string,\n      const char *fromcode,\n      enum iconv_ilseq_handler handler)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/uniconv/u8-conv-from-enc.c": {
    "u8_conv_from_encoding": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "uint8_t *\nu8_conv_from_encoding (const char *fromcode,\n                       enum iconv_ilseq_handler handler,\n                       const char *src, size_t srclen,\n                       size_t *offsets,\n                       uint8_t *resultbuf, size_t *lengthp)\n{\n  if (STRCASEEQ (fromcode, \"UTF-8\", 'U','T','F','-','8',0,0,0,0))\n    {\n      /* Conversion from UTF-8 to UTF-8.  No need to go through iconv().  */\n      uint8_t *result;\n\n      if (u8_check ((const uint8_t *) src, srclen))\n        {\n          errno = EILSEQ;\n          return NULL;\n        }\n\n      if (offsets != NULL)\n        {\n          size_t i;\n\n          for (i = 0; i < srclen; )\n            {\n              int count = u8_mblen ((const uint8_t *) src + i, srclen - i);\n              /* We can rely on count > 0 because of the previous u8_check.  */\n              if (count <= 0)\n                abort ();\n              offsets[i] = i;\n              i++;\n              while (--count > 0)\n                offsets[i++] = (size_t)(-1);\n            }\n        }\n\n      /* Memory allocation.  */\n      if (resultbuf != NULL && *lengthp >= srclen)\n        result = resultbuf;\n      else\n        {\n          result = (uint8_t *) malloc (srclen > 0 ? srclen : 1);\n          if (result == NULL)\n            {\n              errno = ENOMEM;\n              return NULL;\n            }\n        }\n\n      memcpy ((char *) result, src, srclen);\n      *lengthp = srclen;\n      return result;\n    }\n  else\n    {\n      char *result = (char *) resultbuf;\n      size_t length = *lengthp;\n\n      if (mem_iconveha (src, srclen, fromcode, \"UTF-8\", true, handler,\n                        offsets, &result, &length) < 0)\n        return NULL;\n\n      if (result == NULL) /* when (resultbuf == NULL && length == 0)  */\n        {\n          result = (char *) malloc (1);\n          if (result == NULL)\n            {\n              errno = ENOMEM;\n              return NULL;\n            }\n        }\n      *lengthp = length;\n      return (uint8_t *) result;\n    }\n}",
      "lines": 74,
      "depth": 17,
      "decorators": [
        "uint8_t",
        "*\nu8_conv_from_encoding (const char *fromcode,\n                       enum iconv_ilseq_handler handler,\n                       const char *src, size_t srclen,\n                       size_t *offsets,\n                       uint8_t *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/uniconv/u8-strconv-from-enc.c": {},
  "libidn/libidn2-2.0.5/unistring/uniconv/u8-strconv-from-locale.c": {
    "u8_strconv_from_locale": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "uint8_t *\nu8_strconv_from_locale (const char *string)\n{\n  const char *encoding = locale_charset ();\n  return u8_strconv_from_encoding (string, encoding, iconveh_question_mark);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "uint8_t",
        "*\nu8_strconv_from_locale (const char *string)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/uniconv/u8-strconv-to-enc.c": {
    "u8_strconv_to_encoding": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "char *\nu8_strconv_to_encoding (const uint8_t *string,\n                        const char *tocode,\n                        enum iconv_ilseq_handler handler)\n{\n  char *result;\n  size_t length;\n\n  if (STRCASEEQ (tocode, \"UTF-8\", 'U','T','F','-','8',0,0,0,0))\n    {\n      /* Conversion from UTF-8 to UTF-8.  No need to go through iconv().  */\n      length = u8_strlen (string) + 1;\n      if (u8_check (string, length))\n        {\n          errno = EILSEQ;\n          return NULL;\n        }\n      result = (char *) malloc (length);\n      if (result == NULL)\n        {\n          errno = ENOMEM;\n          return NULL;\n        }\n      memcpy (result, (const char *) string, length);\n      return result;\n    }\n  else\n    {\n      result = NULL;\n      length = 0;\n      if (mem_iconveha ((const char *) string, u8_strlen (string) + 1,\n                        \"UTF-8\", tocode,\n                        handler == iconveh_question_mark, handler,\n                        NULL, &result, &length) < 0)\n        return NULL;\n      /* Verify the result has exactly one NUL byte, at the end.  */\n      if (!(length > 0 && result[length-1] == '\\0'\n            && strlen (result) == length-1))\n        {\n          free (result);\n          errno = EILSEQ;\n          return NULL;\n        }\n      return result;\n    }\n}",
      "lines": 46,
      "depth": 14,
      "decorators": [
        "char",
        "*\nu8_strconv_to_encoding (const uint8_t *string,\n                        const char *tocode,\n                        enum iconv_ilseq_handler handler)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/uniconv/u8-strconv-to-locale.c": {
    "u8_strconv_to_locale": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "char *\nu8_strconv_to_locale (const uint8_t *string)\n{\n  const char *encoding = locale_charset ();\n  return u8_strconv_to_encoding (string, encoding, iconveh_question_mark);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nu8_strconv_to_locale (const uint8_t *string)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/unictype/bidi_of.c": {
    "uc_bidi_class": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nuc_bidi_class (ucs4_t uc)\n{\n  unsigned int index1 = uc >> bidi_category_header_0;\n  if (index1 < bidi_category_header_1)\n    {\n      int lookup1 = u_bidi_category.level1[index1];\n      if (lookup1 >= 0)\n        {\n          unsigned int index2 = (uc >> bidi_category_header_2) & bidi_category_header_3;\n          int lookup2 = u_bidi_category.level2[lookup1 + index2];\n          if (lookup2 >= 0)\n            {\n              unsigned int index3 = ((uc & bidi_category_header_4) + lookup2) * 5;\n              /* level3 contains 5-bit values, packed into 16-bit words.  */\n              unsigned int lookup3 =\n                ((u_bidi_category.level3[index3>>4]\n                  | ((unsigned int) u_bidi_category.level3[(index3>>4)+1] << 16))\n                 >> (index3 % 16))\n                & 0x1f;\n\n              return lookup3;\n            }\n        }\n    }\n  return UC_BIDI_L;\n}",
      "lines": 27,
      "depth": 23,
      "decorators": [
        "int"
      ]
    },
    "uc_bidi_category": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "int\nuc_bidi_category (ucs4_t uc)\n{\n  return uc_bidi_class (uc);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/unictype/bidi_of.h": {},
  "libidn/libidn2-2.0.5/unistring/unictype/bitmap.h": {
    "bitmap_lookup": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "static inline int\nbitmap_lookup (const void *table, ucs4_t uc)\n{\n  unsigned int index1 = uc >> header_0;\n  if (index1 < ((const int *) table)[0])\n    {\n      int lookup1 = ((const int *) table)[1 + index1];\n      if (lookup1 >= 0)\n        {\n          unsigned int index2 = (uc >> header_2) & header_3;\n          int lookup2 = ((const short *) table)[lookup1 + index2];\n          if (lookup2 >= 0)\n            {\n              unsigned int index3 = (uc >> 5) & header_4;\n              unsigned int lookup3 = ((const int *) table)[lookup2 + index3];\n\n              return (lookup3 >> (uc & 0x1f)) & 1;\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 22,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/unictype/categ_M.c": {},
  "libidn/libidn2-2.0.5/unistring/unictype/categ_M.h": {},
  "libidn/libidn2-2.0.5/unistring/unictype/categ_none.c": {
    "always_false": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "static bool\nalways_false (ucs4_t uc, uint32_t bitmask)\n{\n  return false;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/unictype/categ_of.c": {
    "lookup_withtable": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static inline int\nlookup_withtable (ucs4_t uc)\n{\n  unsigned int index1 = uc >> category_header_0;\n  if (index1 < category_header_1)\n    {\n      int lookup1 = u_category.level1[index1];\n      if (lookup1 >= 0)\n        {\n          unsigned int index2 = (uc >> category_header_2) & category_header_3;\n          int lookup2 = u_category.level2[lookup1 + index2];\n          if (lookup2 >= 0)\n            {\n              unsigned int index3 = ((uc & category_header_4) + lookup2) * 5;\n              /* level3 contains 5-bit values, packed into 16-bit words.  */\n              unsigned int lookup3 =\n                ((u_category.level3[index3>>4]\n                  | ((unsigned int) u_category.level3[(index3>>4)+1] << 16))\n                 >> (index3 % 16))\n                & 0x1f;\n\n              return lookup3;\n            }\n        }\n      return 29; /* = log2(UC_CATEGORY_MASK_Cn) */\n    }\n  return -1;\n}",
      "lines": 28,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "uc_is_general_category_withtable": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "bool\nuc_is_general_category_withtable (ucs4_t uc, uint32_t bitmask)\n{\n  int bit = lookup_withtable (uc);\n\n  if (bit >= 0)\n    return ((bitmask >> bit) & 1);\n  else\n    return false;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "uc_general_category": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "uc_general_category_t\nuc_general_category (ucs4_t uc)\n{\n  int bit = lookup_withtable (uc);\n  uc_general_category_t result;\n\n  if (bit >= 0)\n    {\n      result.bitmask = 1 << bit;\n      result.generic = 1;\n      result.lookup.lookup_fn = &uc_is_general_category_withtable;\n      return result;\n    }\n  else\n    return _UC_CATEGORY_NONE;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "uc_general_category_t"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/unictype/categ_of.h": {},
  "libidn/libidn2-2.0.5/unistring/unictype/categ_test.c": {
    "uc_is_general_category": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "bool\nuc_is_general_category (ucs4_t uc, uc_general_category_t category)\n{\n  if (category.generic)\n    return category.lookup.lookup_fn (uc, category.bitmask);\n  else\n    return bitmap_lookup (category.lookup.table, uc);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/unictype/combiningclass.c": {
    "uc_combining_class": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nuc_combining_class (ucs4_t uc)\n{\n  unsigned int index1 = uc >> combclass_header_0;\n  if (index1 < combclass_header_1)\n    {\n      int lookup1 = u_combclass.level1[index1];\n      if (lookup1 >= 0)\n        {\n          unsigned int index2 = (uc >> combclass_header_2) & combclass_header_3;\n          int lookup2 = u_combclass.level2[lookup1 + index2];\n          if (lookup2 >= 0)\n            {\n              unsigned int index3 = (uc & combclass_header_4);\n              unsigned int lookup3 = u_combclass.level3[lookup2 + index3];\n\n              return lookup3;\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/unictype/combiningclass.h": {},
  "libidn/libidn2-2.0.5/unistring/unictype/joiningtype_of.c": {
    "uc_joining_type": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\nuc_joining_type (ucs4_t uc)\n{\n  unsigned int index1 = uc >> joining_type_header_0;\n  if (index1 < joining_type_header_1)\n    {\n      int lookup1 = u_joining_type.level1[index1];\n      if (lookup1 >= 0)\n        {\n          unsigned int index2 = (uc >> joining_type_header_2) & joining_type_header_3;\n          int lookup2 = u_joining_type.level2[lookup1 + index2];\n          if (lookup2 >= 0)\n            {\n              unsigned int index3 = (uc & joining_type_header_4) + lookup2;\n              /* level3 contains 4-bit values.  */\n              unsigned int lookup3 =\n                (u_joining_type.level3[index3>>1] >> ((index3 % 2) * 4))\n                & 0x0f;\n\n              if (lookup3 != 0x0f)\n                return lookup3;\n            }\n        }\n    }\n  if (uc_is_general_category_withtable\n       (uc, UC_CATEGORY_MASK_Mn | UC_CATEGORY_MASK_Me | UC_CATEGORY_MASK_Cf))\n    return UC_JOINING_TYPE_T;\n  return UC_JOINING_TYPE_U;\n}",
      "lines": 29,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/unictype/joiningtype_of.h": {},
  "libidn/libidn2-2.0.5/unistring/unictype/scripts.c": {
    "uc_script": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "const uc_script_t *\nuc_script (ucs4_t uc)\n{\n  unsigned int index1 = uc >> script_header_0;\n  if (index1 < script_header_1)\n    {\n      int lookup1 = u_script.level1[index1];\n      if (lookup1 >= 0)\n        {\n          unsigned int index2 = (uc >> script_header_2) & script_header_3;\n          int lookup2 = u_script.level2[lookup1 + index2];\n          if (lookup2 >= 0)\n            {\n              unsigned int index3 = (uc & script_header_4);\n              unsigned char lookup3 = u_script.level3[lookup2 + index3];\n\n              if (lookup3 != 0xff)\n                return &scripts[lookup3];\n            }\n        }\n    }\n  return NULL;\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "const",
        "const",
        "uc_script_t",
        "*\nuc_script (ucs4_t uc)",
        "*"
      ]
    },
    "uc_script_byname": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "const uc_script_t *\nuc_script_byname (const char *script_name)\n{\n  const struct named_script *found;\n\n  found = uc_script_lookup (script_name, strlen (script_name));\n  if (found != NULL)\n    return &scripts[found->index];\n  else\n    return NULL;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "const",
        "const",
        "uc_script_t",
        "*\nuc_script_byname (const char *script_name)",
        "*"
      ]
    },
    "uc_is_script": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "bool\nuc_is_script (ucs4_t uc, const uc_script_t *script)\n{\n  return uc_script (uc) == script;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    },
    "uc_all_scripts": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "void\nuc_all_scripts (const uc_script_t **scriptsp, size_t *countp)\n{\n  *scriptsp = scripts;\n  *countp = sizeof (scripts) / sizeof (scripts[0]);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/unictype/scripts.h": {},
  "libidn/libidn2-2.0.5/unistring/unictype/scripts_byname.h": {
    "scripts_hash": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "static unsigned int\nscripts_hash (register const char *str, register size_t len)\n{\n  static const unsigned char asso_values[] =\n    {\n      200, 200, 200, 200, 200, 200, 200, 200, 200, 200,\n      200, 200, 200, 200, 200, 200, 200, 200, 200, 200,\n      200, 200, 200, 200, 200, 200, 200, 200, 200, 200,\n      200, 200, 200, 200, 200, 200, 200, 200, 200, 200,\n      200, 200, 200, 200, 200, 200, 200, 200, 200, 200,\n      200, 200, 200, 200, 200, 200, 200, 200, 200, 200,\n      200, 200, 200, 200, 200,   5,   2,  19,  31,  12,\n      200,  24,  46,   4,  51,  42,   7,   4,   2,  16,\n       35, 200,  71,  16,  10,  32,  51,  30, 200,   2,\n      200, 200, 200, 200, 200,  34, 200,   5,  57,  50,\n       64,  12,  44,  18,  36,   9,  19,  40,  31,   4,\n        2,   2,  75, 200,   9,  73,  38,  33,  41,  10,\n      200,  24, 200, 200, 200, 200, 200, 200, 200, 200,\n      200, 200, 200, 200, 200, 200, 200, 200, 200, 200,\n      200, 200, 200, 200, 200, 200, 200, 200, 200, 200,\n      200, 200, 200, 200, 200, 200, 200, 200, 200, 200,\n      200, 200, 200, 200, 200, 200, 200, 200, 200, 200,\n      200, 200, 200, 200, 200, 200, 200, 200, 200, 200,\n      200, 200, 200, 200, 200, 200, 200, 200, 200, 200,\n      200, 200, 200, 200, 200, 200, 200, 200, 200, 200,\n      200, 200, 200, 200, 200, 200, 200, 200, 200, 200,\n      200, 200, 200, 200, 200, 200, 200, 200, 200, 200,\n      200, 200, 200, 200, 200, 200, 200, 200, 200, 200,\n      200, 200, 200, 200, 200, 200, 200, 200, 200, 200,\n      200, 200, 200, 200, 200, 200, 200, 200, 200, 200,\n      200, 200, 200, 200, 200, 200\n    };\n  register unsigned int hval = len;\n\n  switch (hval)\n    {\n      default:\n        hval += asso_values[(unsigned char)str[7]];\n      /*FALLTHROUGH*/\n      case 7:\n      case 6:\n      case 5:\n        hval += asso_values[(unsigned char)str[4]];\n      /*FALLTHROUGH*/\n      case 4:\n      case 3:\n        hval += asso_values[(unsigned char)str[2]];\n      /*FALLTHROUGH*/\n      case 2:\n      case 1:\n        hval += asso_values[(unsigned char)str[0]];\n        break;\n    }\n  return hval;\n}",
      "lines": 55,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "uc_script_lookup": {
      "start_point": [
        662,
        0
      ],
      "end_point": [
        682,
        1
      ],
      "content": "const struct named_script *\nuc_script_lookup (register const char *str, register size_t len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register unsigned int key = scripts_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE)\n        {\n          register int o = script_names[key].name;\n          if (o >= 0)\n            {\n              register const char *s = o + script_stringpool;\n\n              if (*str == *s && !strcmp (str + 1, s + 1))\n                return &script_names[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "struct named_script",
        "struct",
        "named_script",
        "*\nuc_script_lookup (register const char *str, register size_t len)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/uninorm/canonical-decomposition.c": {
    "uc_canonical_decomposition": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "int\nuc_canonical_decomposition (ucs4_t uc, ucs4_t *decomposition)\n{\n  if (uc >= 0xAC00 && uc < 0xD7A4)\n    {\n      /* Hangul syllable.  See Unicode standard, chapter 3, section\n         \"Hangul Syllable Decomposition\",  See also the clarification at\n         <http://www.unicode.org/versions/Unicode5.1.0/>, section\n         \"Clarification of Hangul Jamo Handling\".  */\n      unsigned int t;\n\n      uc -= 0xAC00;\n      t = uc % 28;\n\n      if (t == 0)\n        {\n          unsigned int v, l;\n\n          uc = uc / 28;\n          v = uc % 21;\n          l = uc / 21;\n\n          decomposition[0] = 0x1100 + l;\n          decomposition[1] = 0x1161 + v;\n          return 2;\n        }\n      else\n        {\n#if 1 /* Return the pairwise decomposition, not the full decomposition.  */\n          decomposition[0] = 0xAC00 + uc - t; /* = 0xAC00 + (l * 21 + v) * 28; */\n          decomposition[1] = 0x11A7 + t;\n          return 2;\n#else\n          unsigned int v, l;\n\n          uc = uc / 28;\n          v = uc % 21;\n          l = uc / 21;\n\n          decomposition[0] = 0x1100 + l;\n          decomposition[1] = 0x1161 + v;\n          decomposition[2] = 0x11A7 + t;\n          return 3;\n#endif\n        }\n    }\n  else if (uc < 0x110000)\n    {\n      unsigned short entry = decomp_index (uc);\n      /* An entry of (unsigned short)(-1) denotes an absent entry.\n         Otherwise, bit 15 of the entry tells whether the decomposition\n         is a canonical one.  */\n      if (entry < 0x8000)\n        {\n          const unsigned char *p;\n          unsigned int element;\n          unsigned int length;\n\n          p = &gl_uninorm_decomp_chars_table[3 * entry];\n          element = (p[0] << 16) | (p[1] << 8) | p[2];\n          /* The first element has 5 bits for the decomposition type.  */\n          if (((element >> 18) & 0x1f) != UC_DECOMP_CANONICAL)\n            abort ();\n          length = 1;\n          for (;;)\n            {\n              /* Every element has an 18 bits wide Unicode code point.  */\n              *decomposition = element & 0x3ffff;\n              /* Bit 23 tells whether there are more elements,  */\n              if ((element & (1 << 23)) == 0)\n                break;\n              p += 3;\n              element = (p[0] << 16) | (p[1] << 8) | p[2];\n              decomposition++;\n              length++;\n            }\n          return length;\n        }\n    }\n  return -1;\n}",
      "lines": 81,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/uninorm/composition-table.h": {
    "gl_uninorm_compose_hash": {
      "start_point": [
        20,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static unsigned int\ngl_uninorm_compose_hash (register const char *str, register size_t len)\n{\n  static const unsigned short asso_values[] =\n    {\n         7,    1,    0,    3,   58,  132,  531,   62,    4,   33,\n       117,  268,  476,  135,  509,  481,  103,  265,  249,  495,\n        61,  124,  336,  409,  703,  241,  435,  462,  738, 1566,\n        48,   13,  901,  766,  322,  635,  192,  621,  846,   13,\n       337,   65,  161,  130,  103,   28,  255,  640,  133,  342,\n       172,   52, 1566,  818,  201,   34,  695,   50,   31, 1566,\n        16,   35,  438,  139,   63,   89,  272,    2,  588,  167,\n        12,  375,  289,   61,   44,  548,  431,  452,  395,  180,\n       794,  853,  362,  561,  456,  202,  677,  360,  195,  300,\n       572,  715, 1566,  291, 1566,  276,  814,   26,  634,  579,\n       270,   98,  423,  415,  323,   42,  862,  657,  559,  324,\n       262,  124,  863, 1566,  251,  538,  236,  133,   47,  406,\n       691,  219,  590,    5,   56,   83, 1566,    1, 1566, 1566,\n        65,   39, 1566, 1566,   37,   35, 1566, 1566, 1566, 1566,\n      1566, 1566, 1566, 1566,    4,  527,   18, 1566,    0,  849,\n      1566,  781, 1566,  572,   59,   73, 1566,  204, 1566,  417,\n       618,  511,   20, 1566, 1566,  708,  167, 1566,  855,  685,\n      1566,  333,   73,  136,   71,  625,  611,  523,   12,  311,\n        11,  649,   10,  505,   62,  482, 1566,  113, 1566,  126,\n         7,  476, 1566,  614,  853,    1,   41,  560,  553,  261,\n       104,  719,  668,  854,   19,   10,    9,  728,   31, 1566,\n       442, 1566,  749,  313,   12,    0,  659,    3, 1566,  329,\n        37, 1566, 1566, 1566,   44, 1566,  847, 1566,   33,    4,\n        23,    1,   33,   24,  757,    4, 1566, 1566, 1566,    3,\n        93,   73,   72, 1566,  824,   20,   17, 1566,    0, 1566,\n      1566, 1566,   77,   46,  460, 1566, 1566\n    };\n  return asso_values[(unsigned char)str[5]+1] + asso_values[(unsigned char)str[2]] + asso_values[(unsigned char)str[1]];\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "gl_uninorm_compose_lookup": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        2196,
        1
      ],
      "content": "const struct composition_rule *\ngl_uninorm_compose_lookup (register const char *str, register size_t len)\n{\n  static const unsigned char lengthtable[] =\n    {\n       0,  6,  6,  0,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  0,  6,  6,\n       6,  6,  6,  6,  6,  0,  6,  6,  6,  6,  6,  6,  6,  6,\n       0,  6,  6,  6,  6,  6,  6,  6,  6,  0,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  0,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  0,\n       6,  6,  6,  0,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  0,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  0,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  0,  6,  6,  0,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  0,  6,  6,  0,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  0,  6,  6,  6,  6,  6,  6,  0,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       0,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  0,  6,  6,\n       0,  6,  0,  6,  0,  6,  6,  6,  6,  0,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n       6,  6,  6,  6,  6,  6,  6,  0,  6,  6,  6,  6,  0,  6,\n       6,  6,  0,  6,  0,  6,  6,  6,  6,  0,  6,  6,  0,  6,\n       6,  6,  0,  6,  0,  0,  0,  6,  0,  6,  0,  6,  6,  6,\n       6,  0,  6,  6,  6,  6,  6,  0,  6,  0,  6,  0,  0,  6,\n       6,  6,  6,  0,  6,  0,  0,  6,  6,  0,  6,  6,  6,  0,\n       6,  0,  0,  0,  6,  0,  6,  6,  0,  6,  6,  0,  0,  0,\n       0,  6,  0,  0,  0,  0,  0,  0,  0,  0,  6,  0,  6,  0,\n       0,  0,  0,  0,  6,  6,  0,  0,  0,  0,  6,  6,  6,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  6,  6,\n       0,  0,  0,  0,  0,  0,  6,  6,  0,  6,  6,  6,  0,  6,\n       0,  6,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  6,\n       6,  0,  0,  0,  6,  0,  0,  6,  6,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  6,  0,  0,  0,  6,  6,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  6,  0,  0,  0,  0,  0,  0,\n       0,  6,  6,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  6,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  6,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  6,  0,  0,  0,  0,  0,  6,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  6,\n       0,  0,  0,  6,  0,  0,  0,  0,  0,  6,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  6,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  6,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  6,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  6,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  6,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n       0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  6\n    };\n  static const struct composition_rule wordlist[] =\n    {\n      {\"\"},\n#line 581 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\002\\000\\003\\001\", 0x1eae},\n#line 583 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\002\\000\\003\\000\", 0x1eb0},\n      {\"\"},\n#line 582 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\003\\000\\003\\001\", 0x1eaf},\n#line 584 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\003\\000\\003\\000\", 0x1eb1},\n#line 566 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\177\\000\\003\\007\", 0x1e9b},\n#line 247 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\370\\000\\003\\001\", 0x01ff},\n#line 421 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\347\\000\\003\\001\", 0x1e09},\n#line 99 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000C\\000\\003\\001\", 0x0106},\n#line 459 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\357\\000\\003\\001\", 0x1e2f},\n#line 243 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\345\\000\\003\\001\", 0x01fb},\n#line 101 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000C\\000\\003\\002\", 0x0108},\n#line 103 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000C\\000\\003\\007\", 0x010a},\n#line 662 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\001\\000\\003\\001\", 0x1f05},\n#line 660 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\001\\000\\003\\000\", 0x1f03},\n#line 664 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\001\\000\\003B\", 0x1f07},\n#line 669 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\010\\000\\003\\001\", 0x1f0c},\n#line 667 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\010\\000\\003\\000\", 0x1f0a},\n#line 671 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\010\\000\\003B\", 0x1f0e},\n#line 661 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\000\\000\\003\\001\", 0x1f04},\n#line 659 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\000\\000\\003\\000\", 0x1f02},\n#line 663 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\000\\000\\003B\", 0x1f06},\n#line 442 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000F\\000\\003\\007\", 0x1e1e},\n#line 860 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\316\\000\\003E\", 0x1ff4},\n#line 766 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\002\\000\\003E\", 0x1f82},\n#line 765 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\001\\000\\003E\", 0x1f81},\n#line 489 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\365\\000\\003\\001\", 0x1e4d},\n#line 767 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\003\\000\\003E\", 0x1f83},\n#line 772 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\010\\000\\003E\", 0x1f88},\n#line 245 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\346\\000\\003\\001\", 0x01fd},\n#line 515 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001a\\000\\003\\007\", 0x1e67},\n#line 764 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\000\\000\\003E\", 0x1f80},\n#line 67 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003\\001\", 0x00e1},\n#line 66 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003\\000\", 0x00e0},\n#line 818 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\266\\000\\003E\", 0x1fb7},\n#line 68 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003\\002\", 0x00e2},\n#line 279 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003\\007\", 0x0227},\n#line 787 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037'\\000\\003E\", 0x1f97},\n#line 746 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037a\\000\\003\\001\", 0x1f65},\n#line 744 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037a\\000\\003\\000\", 0x1f63},\n#line 748 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037a\\000\\003B\", 0x1f67},\n#line 862 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\366\\000\\003E\", 0x1ff7},\n#line 533 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001i\\000\\003\\001\", 0x1e79},\n#line 215 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\334\\000\\003\\001\", 0x01d7},\n#line 219 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\334\\000\\003\\000\", 0x01db},\n#line 670 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\011\\000\\003\\001\", 0x1f0d},\n#line 668 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\011\\000\\003\\000\", 0x1f0b},\n#line 672 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\011\\000\\003B\", 0x1f0f},\n#line 78 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000i\\000\\003\\001\", 0x00ed},\n#line 77 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000i\\000\\003\\000\", 0x00ec},\n#line 797 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037a\\000\\003E\", 0x1fa1},\n#line 79 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000i\\000\\003\\002\", 0x00ee},\n#line 793 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037-\\000\\003E\", 0x1f9d},\n#line 138 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000J\\000\\003\\002\", 0x0134},\n#line 754 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037i\\000\\003\\001\", 0x1f6d},\n#line 752 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037i\\000\\003\\000\", 0x1f6b},\n#line 756 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037i\\000\\003B\", 0x1f6f},\n#line 773 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\011\\000\\003E\", 0x1f89},\n#line 587 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\002\\000\\003\\003\", 0x1eb4},\n#line 491 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\365\\000\\003\\010\", 0x1e4f},\n#line 624 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\036\\315\\000\\003\\002\", 0x1ed9},\n#line 588 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\003\\000\\003\\003\", 0x1eb5},\n#line 714 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0379\\000\\003\\001\", 0x1f3d},\n#line 712 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0379\\000\\003\\000\", 0x1f3b},\n#line 716 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0379\\000\\003B\", 0x1f3f},\n#line 70 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003\\010\", 0x00e4},\n#line 805 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037i\\000\\003E\", 0x1fa9},\n#line 52 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\003\\001\", 0x00cd},\n#line 51 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\003\\000\", 0x00cc},\n#line 623 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\036\\314\\000\\003\\002\", 0x1ed8},\n#line 53 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\003\\002\", 0x00ce},\n#line 137 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\003\\007\", 0x0130},\n#line 884 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000<\\000\\0038\", 0x226e},\n#line 728 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037I\\000\\003\\001\", 0x1f4d},\n#line 726 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037I\\000\\003\\000\", 0x1f4b},\n#line 721 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037@\\000\\003\\001\", 0x1f44},\n#line 719 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037@\\000\\003\\000\", 0x1f42},\n#line 698 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037)\\000\\003\\001\", 0x1f2d},\n#line 696 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037)\\000\\003\\000\", 0x1f2b},\n#line 700 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037)\\000\\003B\", 0x1f2f},\n#line 858 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037|\\000\\003E\", 0x1ff2},\n#line 80 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000i\\000\\003\\010\", 0x00ef},\n#line 768 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\004\\000\\003E\", 0x1f84},\n#line 216 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\374\\000\\003\\001\", 0x01d8},\n#line 220 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\374\\000\\003\\000\", 0x01dc},\n#line 826 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\256\\000\\003E\", 0x1fc4},\n#line 771 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\007\\000\\003E\", 0x1f87},\n#line 816 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\254\\000\\003E\", 0x1fb4},\n#line 328 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004:\\000\\003\\001\", 0x045c},\n#line 789 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037)\\000\\003E\", 0x1f99},\n#line 69 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003\\003\", 0x00e3},\n#line 881 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000=\\000\\0038\", 0x2260},\n#line 360 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004C\\000\\003\\010\", 0x04f1},\n#line 342 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\331\\000\\003\\010\", 0x04db},\n#line 96 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003\\006\", 0x0103},\n#line 41 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003\\001\", 0x00c1},\n#line 40 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003\\000\", 0x00c0},\n#line 98 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003(\", 0x0105},\n#line 42 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003\\002\", 0x00c2},\n#line 278 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003\\007\", 0x0226},\n#line 54 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\003\\010\", 0x00cf},\n#line 722 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037A\\000\\003\\001\", 0x1f45},\n#line 720 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037A\\000\\003\\000\", 0x1f43},\n#line 363 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004'\\000\\003\\010\", 0x04f4},\n#line 74 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003\\001\", 0x00e9},\n#line 73 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003\\000\", 0x00e8},\n#line 130 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000i\\000\\003\\003\", 0x0129},\n#line 75 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003\\002\", 0x00ea},\n#line 114 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003\\007\", 0x0117},\n#line 326 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0043\\000\\003\\001\", 0x0453},\n#line 134 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000i\\000\\003\\006\", 0x012d},\n#line 537 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000v\\000\\003\\003\", 0x1e7d},\n#line 605 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\036\\270\\000\\003\\002\", 0x1ec6},\n#line 136 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000i\\000\\003(\", 0x012f},\n#line 354 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\351\\000\\003\\010\", 0x04eb},\n#line 677 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\020\\000\\003\\001\", 0x1f14},\n#line 675 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\020\\000\\003\\000\", 0x1f12},\n#line 585 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\002\\000\\003\\011\", 0x1eb2},\n#line 355 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004-\\000\\003\\010\", 0x04ec},\n#line 377 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0113\\000\\011<\", 0x0934},\n#line 586 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\003\\000\\003\\011\", 0x1eb3},\n#line 330 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004C\\000\\003\\006\", 0x045e},\n#line 801 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037e\\000\\003E\", 0x1fa5},\n#line 353 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\350\\000\\003\\010\", 0x04ea},\n#line 346 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0047\\000\\003\\010\", 0x04df},\n#line 129 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\003\\003\", 0x0128},\n#line 441 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\002)\\000\\003\\006\", 0x1e1d},\n#line 792 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037,\\000\\003E\", 0x1f9c},\n#line 44 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003\\010\", 0x00c4},\n#line 133 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\003\\006\", 0x012c},\n#line 83 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003\\001\", 0x00f3},\n#line 82 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003\\000\", 0x00f2},\n#line 135 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\003(\", 0x012e},\n#line 84 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003\\002\", 0x00f4},\n#line 287 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003\\007\", 0x022f},\n#line 249 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003\\017\", 0x0201},\n#line 234 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\353\\000\\003\\004\", 0x01ed},\n#line 76 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003\\010\", 0x00eb},\n#line 351 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\036\\000\\003\\010\", 0x04e6},\n#line 88 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003\\001\", 0x00fa},\n#line 87 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003\\000\", 0x00f9},\n#line 774 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\012\\000\\003E\", 0x1f8a},\n#line 89 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003\\002\", 0x00fb},\n#line 105 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000C\\000\\003\\014\", 0x010c},\n#line 224 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\002'\\000\\003\\004\", 0x01e1},\n#line 705 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0370\\000\\003\\001\", 0x1f34},\n#line 703 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0370\\000\\003\\000\", 0x1f32},\n#line 707 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0370\\000\\003B\", 0x1f36},\n#line 811 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037o\\000\\003E\", 0x1faf},\n#line 570 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003\\011\", 0x1ea3},\n#line 282 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\326\\000\\003\\004\", 0x022a},\n#line 257 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000i\\000\\003\\017\", 0x0209},\n#line 236 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\002\\222\\000\\003\\014\", 0x01ef},\n#line 43 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003\\003\", 0x00c3},\n#line 791 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037+\\000\\003E\", 0x1f9b},\n#line 283 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\366\\000\\003\\004\", 0x022b},\n#line 769 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\005\\000\\003E\", 0x1f85},\n#line 95 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003\\006\", 0x0102},\n#line 285 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\365\\000\\003\\004\", 0x022d},\n#line 777 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\015\\000\\003E\", 0x1f8d},\n#line 97 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003(\", 0x0104},\n#line 226 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\346\\000\\003\\004\", 0x01e3},\n#line 596 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003\\003\", 0x1ebd},\n#line 86 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003\\010\", 0x00f6},\n#line 94 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003\\004\", 0x0101},\n#line 608 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000i\\000\\003\\011\", 0x1ec9},\n#line 112 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003\\006\", 0x0115},\n#line 206 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003\\014\", 0x01ce},\n#line 397 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\015\\331\\000\\015\\317\", 0x0ddc},\n#line 116 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003(\", 0x0119},\n#line 256 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\003\\017\", 0x0208},\n#line 222 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\344\\000\\003\\004\", 0x01df},\n#line 90 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003\\010\", 0x00fc},\n#line 48 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003\\001\", 0x00c9},\n#line 47 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003\\000\", 0x00c8},\n#line 213 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\334\\000\\003\\004\", 0x01d5},\n#line 49 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003\\002\", 0x00ca},\n#line 113 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003\\007\", 0x0116},\n#line 217 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\334\\000\\003\\014\", 0x01d9},\n#line 221 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\304\\000\\003\\004\", 0x01de},\n#line 132 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000i\\000\\003\\004\", 0x012b},\n#line 399 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\015\\331\\000\\015\\337\", 0x0dde},\n#line 315 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\025\\000\\003\\000\", 0x0400},\n#line 208 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000i\\000\\003\\014\", 0x01d0},\n#line 607 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\003\\011\", 0x1ec8},\n#line 790 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037*\\000\\003E\", 0x1f9a},\n#line 57 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003\\001\", 0x00d3},\n#line 56 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003\\000\", 0x00d2},\n#line 85 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003\\003\", 0x00f5},\n#line 58 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003\\002\", 0x00d4},\n#line 286 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003\\007\", 0x022e},\n#line 358 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004C\\000\\003\\004\", 0x04ef},\n#line 157 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003\\006\", 0x014f},\n#line 337 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\020\\000\\003\\010\", 0x04d2},\n#line 963 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\357\\0000\\231\", 0x30f7},\n#line 232 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003(\", 0x01eb},\n#line 933 \"./uninorm/composition-table.gperf\"\n      {\"\\0000{\\0000\\231\", 0x307c},\n#line 179 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003\\003\", 0x0169},\n#line 248 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003\\017\", 0x0200},\n#line 131 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\003\\004\", 0x012a},\n#line 376 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0110\\000\\011<\", 0x0931},\n#line 183 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003\\006\", 0x016d},\n#line 207 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\003\\014\", 0x01cf},\n#line 935 \"./uninorm/composition-table.gperf\"\n      {\"\\0000F\\0000\\231\", 0x3094},\n#line 189 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003(\", 0x0173},\n#line 550 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000X\\000\\003\\007\", 0x1e8a},\n#line 50 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003\\010\", 0x00cb},\n#line 253 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003\\017\", 0x0205},\n#line 62 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003\\001\", 0x00da},\n#line 61 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003\\000\", 0x00d9},\n#line 934 \"./uninorm/composition-table.gperf\"\n      {\"\\0000{\\0000\\232\", 0x307d},\n#line 63 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003\\002\", 0x00db},\n#line 569 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003\\011\", 0x1ea2},\n#line 469 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0367\\000\\003\\004\", 0x1e39},\n#line 316 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\025\\000\\003\\010\", 0x0401},\n#line 214 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\374\\000\\003\\004\", 0x01d6},\n#line 784 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037$\\000\\003E\", 0x1f94},\n#line 921 \"./uninorm/composition-table.gperf\"\n      {\"\\0000a\\0000\\231\", 0x3062},\n#line 218 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\374\\000\\003\\014\", 0x01da},\n#line 60 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003\\010\", 0x00d6},\n#line 365 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004+\\000\\003\\010\", 0x04f8},\n#line 594 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003\\011\", 0x1ebb},\n#line 335 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\020\\000\\003\\006\", 0x04d0},\n#line 338 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0040\\000\\003\\010\", 0x04d3},\n#line 568 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003#\", 0x1ea1},\n#line 91 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000y\\000\\003\\001\", 0x00fd},\n#line 650 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000y\\000\\003\\000\", 0x1ef3},\n#line 93 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003\\004\", 0x0100},\n#line 193 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000y\\000\\003\\002\", 0x0177},\n#line 555 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000y\\000\\003\\007\", 0x1e8f},\n#line 205 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003\\014\", 0x01cd},\n#line 595 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003\\003\", 0x1ebc},\n#line 949 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\304\\0000\\231\", 0x30c5},\n#line 261 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003\\017\", 0x020d},\n#line 552 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000X\\000\\003\\010\", 0x1e8c},\n#line 111 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003\\006\", 0x0114},\n#line 110 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003\\004\", 0x0113},\n#line 967 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\375\\0000\\231\", 0x30fe},\n#line 115 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003(\", 0x0118},\n#line 118 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003\\014\", 0x011b},\n#line 610 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000i\\000\\003#\", 0x1ecb},\n#line 64 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003\\010\", 0x00dc},\n#line 269 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003\\017\", 0x0215},\n#line 339 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\025\\000\\003\\006\", 0x04d6},\n#line 59 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003\\003\", 0x00d5},\n#line 539 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000v\\000\\003#\", 0x1e7f},\n#line 519 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000t\\000\\003\\007\", 0x1e6b},\n#line 614 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003\\011\", 0x1ecf},\n#line 156 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003\\006\", 0x014e},\n#line 434 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\022\\000\\003\\001\", 0x1e16},\n#line 432 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\022\\000\\003\\000\", 0x1e14},\n#line 231 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003(\", 0x01ea},\n#line 336 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0040\\000\\003\\006\", 0x04d1},\n#line 684 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\031\\000\\003\\001\", 0x1f1d},\n#line 682 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\031\\000\\003\\000\", 0x1f1b},\n#line 275 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000t\\000\\003&\", 0x021b},\n#line 638 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003\\011\", 0x1ee7},\n#line 161 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000r\\000\\003\\001\", 0x0155},\n#line 92 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000y\\000\\003\\010\", 0x00ff},\n#line 609 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\003#\", 0x1eca},\n#line 824 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037t\\000\\003E\", 0x1fc2},\n#line 501 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000r\\000\\003\\007\", 0x1e59},\n#line 155 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003\\004\", 0x014d},\n#line 966 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\362\\0000\\231\", 0x30fa},\n#line 965 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\361\\0000\\231\", 0x30f9},\n#line 210 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003\\014\", 0x01d2},\n#line 178 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003\\003\", 0x0168},\n#line 420 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\307\\000\\003\\001\", 0x1e08},\n#line 149 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000n\\000\\003\\001\", 0x0144},\n#line 241 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000n\\000\\003\\000\", 0x01f9},\n#line 182 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003\\006\", 0x016c},\n#line 181 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003\\004\", 0x016b},\n#line 481 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000n\\000\\003\\007\", 0x1e45},\n#line 188 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003(\", 0x0172},\n#line 212 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003\\014\", 0x01d4},\n#line 563 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000t\\000\\003\\010\", 0x1e97},\n#line 252 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003\\017\", 0x0204},\n#line 678 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\021\\000\\003\\001\", 0x1f15},\n#line 676 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\021\\000\\003\\000\", 0x1f13},\n#line 794 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037.\\000\\003E\", 0x1f9e},\n#line 423 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000d\\000\\003\\007\", 0x1e0b},\n#line 251 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003\\021\", 0x0203},\n#line 414 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000B\\000\\003\\007\", 0x1e02},\n#line 656 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000y\\000\\003\\003\", 0x1ef9},\n#line 964 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\360\\0000\\231\", 0x30f8},\n#line 393 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\015F\\000\\015>\", 0x0d4a},\n#line 810 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037n\\000\\003E\", 0x1fae},\n#line 567 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003#\", 0x1ea0},\n#line 969 \"./uninorm/composition-table.gperf\"\n      {\"\\001\\020\\233\\001\\020\\272\", 0x1109c},\n#line 260 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003\\017\", 0x020c},\n#line 593 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003\\011\", 0x1eba},\n#line 344 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0046\\000\\003\\010\", 0x04dd},\n#line 775 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\013\\000\\003E\", 0x1f8b},\n#line 332 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004u\\000\\003\\017\", 0x0477},\n#line 800 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037d\\000\\003E\", 0x1fa4},\n#line 951 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\310\\0000\\231\", 0x30c9},\n#line 592 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003#\", 0x1eb9},\n#line 259 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000i\\000\\003\\021\", 0x020b},\n#line 127 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000H\\000\\003\\002\", 0x0124},\n#line 446 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000H\\000\\003\\007\", 0x1e22},\n#line 71 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003\\012\", 0x00e5},\n#line 727 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037H\\000\\003\\001\", 0x1f4c},\n#line 725 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037H\\000\\003\\000\", 0x1f4a},\n#line 613 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003\\011\", 0x1ece},\n#line 945 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\273\\0000\\231\", 0x30bc},\n#line 109 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003\\004\", 0x0112},\n#line 65 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Y\\000\\003\\001\", 0x00dd},\n#line 649 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Y\\000\\003\\000\", 0x1ef2},\n#line 117 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003\\014\", 0x011a},\n#line 192 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Y\\000\\003\\002\", 0x0176},\n#line 554 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Y\\000\\003\\007\", 0x1e8e},\n#line 268 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003\\017\", 0x0214},\n#line 739 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037Y\\000\\003\\001\", 0x1f5d},\n#line 738 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037Y\\000\\003\\000\", 0x1f5b},\n#line 740 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037Y\\000\\003B\", 0x1f5f},\n#line 925 \"./uninorm/composition-table.gperf\"\n      {\"\\0000o\\0000\\231\", 0x3070},\n#line 258 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\003\\021\", 0x020a},\n#line 946 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\275\\0000\\231\", 0x30be},\n#line 154 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003\\004\", 0x014c},\n#line 488 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\325\\000\\003\\001\", 0x1e4c},\n#line 334 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0046\\000\\003\\006\", 0x04c2},\n#line 209 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003\\014\", 0x01d1},\n#line 612 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003#\", 0x1ecd},\n#line 532 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001h\\000\\003\\001\", 0x1e78},\n#line 929 \"./uninorm/composition-table.gperf\"\n      {\"\\0000u\\0000\\231\", 0x3076},\n#line 637 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003\\011\", 0x1ee6},\n#line 81 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000n\\000\\003\\003\", 0x00f1},\n#line 938 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\255\\0000\\231\", 0x30ae},\n#line 450 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000H\\000\\003\\010\", 0x1e26},\n#line 926 \"./uninorm/composition-table.gperf\"\n      {\"\\0000o\\0000\\232\", 0x3071},\n#line 475 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000m\\000\\003\\001\", 0x1e3f},\n#line 636 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003#\", 0x1ee5},\n#line 128 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000h\\000\\003\\002\", 0x0125},\n#line 447 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000h\\000\\003\\007\", 0x1e23},\n#line 477 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000m\\000\\003\\007\", 0x1e41},\n#line 753 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037h\\000\\003\\001\", 0x1f6c},\n#line 751 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037h\\000\\003\\000\", 0x1f6a},\n#line 755 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037h\\000\\003B\", 0x1f6e},\n#line 930 \"./uninorm/composition-table.gperf\"\n      {\"\\0000u\\0000\\232\", 0x3077},\n#line 194 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Y\\000\\003\\010\", 0x0178},\n#line 180 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003\\004\", 0x016a},\n#line 395 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\015F\\000\\015W\", 0x0d4c},\n#line 654 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000y\\000\\003\\011\", 0x1ef7},\n#line 211 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003\\014\", 0x01d3},\n#line 250 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003\\021\", 0x0202},\n#line 46 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000C\\000\\003'\", 0x00c7},\n#line 782 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\\"\\000\\003E\", 0x1f92},\n#line 804 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037h\\000\\003E\", 0x1fa8},\n#line 809 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037m\\000\\003E\", 0x1fad},\n#line 697 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037(\\000\\003\\001\", 0x1f2c},\n#line 695 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037(\\000\\003\\000\", 0x1f2a},\n#line 699 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037(\\000\\003B\", 0x1f2e},\n#line 490 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\325\\000\\003\\010\", 0x1e4e},\n#line 255 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003\\021\", 0x0207},\n#line 706 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0371\\000\\003\\001\", 0x1f35},\n#line 704 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0371\\000\\003\\000\", 0x1f33},\n#line 708 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0371\\000\\003B\", 0x1f37},\n#line 291 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000y\\000\\003\\004\", 0x0233},\n#line 962 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\246\\0000\\231\", 0x30f4},\n#line 437 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003-\", 0x1e19},\n#line 265 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000r\\000\\003\\017\", 0x0211},\n#line 788 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037(\\000\\003E\", 0x1f98},\n#line 451 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000h\\000\\003\\010\", 0x1e27},\n#line 45 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003\\012\", 0x00c5},\n#line 655 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Y\\000\\003\\003\", 0x1ef8},\n#line 591 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003#\", 0x1eb8},\n#line 542 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000W\\000\\003\\001\", 0x1e82},\n#line 540 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000W\\000\\003\\000\", 0x1e80},\n#line 160 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000R\\000\\003\\001\", 0x0154},\n#line 190 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000W\\000\\003\\002\", 0x0174},\n#line 546 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000W\\000\\003\\007\", 0x1e86},\n#line 912 \"./uninorm/composition-table.gperf\"\n      {\"\\0000O\\0000\\231\", 0x3050},\n#line 500 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000R\\000\\003\\007\", 0x1e58},\n#line 878 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"C\\000\\0038\", 0x2244},\n#line 872 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\003\\000\\0038\", 0x2204},\n#line 873 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\010\\000\\0038\", 0x2209},\n#line 893 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"{\\000\\0038\", 0x2281},\n#line 177 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000t\\000\\003\\014\", 0x0165},\n#line 611 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003#\", 0x1ecc},\n#line 263 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003\\021\", 0x020f},\n#line 468 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0366\\000\\003\\004\", 0x1e38},\n#line 238 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000G\\000\\003\\001\", 0x01f4},\n#line 908 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\264\\000\\0038\", 0x22ec},\n#line 906 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\262\\000\\0038\", 0x22ea},\n#line 119 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000G\\000\\003\\002\", 0x011c},\n#line 123 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000G\\000\\003\\007\", 0x0120},\n#line 288 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\002.\\000\\003\\004\", 0x0230},\n#line 877 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"<\\000\\0038\", 0x2241},\n#line 271 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003\\021\", 0x0217},\n#line 905 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\222\\000\\0038\", 0x22e3},\n#line 457 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000i\\000\\0030\", 0x1e2d},\n#line 898 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\242\\000\\0038\", 0x22ac},\n#line 165 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000r\\000\\003\\014\", 0x0159},\n#line 915 \"./uninorm/composition-table.gperf\"\n      {\"\\0000U\\0000\\231\", 0x3056},\n#line 531 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003-\", 0x1e77},\n#line 936 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\235\\0000\\231\", 0x309e},\n#line 331 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004t\\000\\003\\017\", 0x0476},\n#line 882 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"a\\000\\0038\", 0x2262},\n#line 440 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\002(\\000\\003\\006\", 0x1e1c},\n#line 544 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000W\\000\\003\\010\", 0x1e84},\n#line 635 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003#\", 0x1ee4},\n#line 148 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000N\\000\\003\\001\", 0x0143},\n#line 240 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000N\\000\\003\\000\", 0x01f8},\n#line 153 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000n\\000\\003\\014\", 0x0148},\n#line 375 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\011(\\000\\011<\", 0x0929},\n#line 480 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000N\\000\\003\\007\", 0x1e44},\n#line 897 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\207\\000\\0038\", 0x2289},\n#line 185 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003\\012\", 0x016f},\n#line 896 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\206\\000\\0038\", 0x2288},\n#line 456 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000I\\000\\0030\", 0x1e2c},\n#line 895 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\203\\000\\0038\", 0x2285},\n#line 108 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000d\\000\\003\\014\", 0x010f},\n#line 543 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000w\\000\\003\\001\", 0x1e83},\n#line 541 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000w\\000\\003\\000\", 0x1e81},\n#line 523 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000t\\000\\0031\", 0x1e6f},\n#line 191 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000w\\000\\003\\002\", 0x0175},\n#line 547 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000w\\000\\003\\007\", 0x1e87},\n#line 652 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000y\\000\\003#\", 0x1ef5},\n#line 890 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"v\\000\\0038\", 0x2278},\n#line 297 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\237\\000\\003\\001\", 0x038c},\n#line 863 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\237\\000\\003\\000\", 0x1ff8},\n#line 239 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000g\\000\\003\\001\", 0x01f5},\n#line 254 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003\\021\", 0x0206},\n#line 653 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Y\\000\\003\\011\", 0x1ef6},\n#line 120 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000g\\000\\003\\002\", 0x011d},\n#line 124 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000g\\000\\003\\007\", 0x0121},\n#line 343 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\026\\000\\003\\010\", 0x04dc},\n#line 902 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"|\\000\\0038\", 0x22e0},\n#line 436 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003-\", 0x1e18},\n#line 507 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000r\\000\\0031\", 0x1e5f},\n#line 276 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000H\\000\\003\\014\", 0x021e},\n#line 494 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001L\\000\\003\\001\", 0x1e52},\n#line 492 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001L\\000\\003\\000\", 0x1e50},\n#line 443 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000f\\000\\003\\007\", 0x1e1f},\n#line 521 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000t\\000\\003#\", 0x1e6d},\n#line 262 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003\\021\", 0x020e},\n#line 894 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\202\\000\\0038\", 0x2284},\n#line 142 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000L\\000\\003\\001\", 0x0139},\n#line 290 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Y\\000\\003\\004\", 0x0232},\n#line 803 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037g\\000\\003E\", 0x1fa7},\n#line 485 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000n\\000\\0031\", 0x1e49},\n#line 281 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\003'\", 0x0229},\n#line 927 \"./uninorm/composition-table.gperf\"\n      {\"\\0000r\\0000\\231\", 0x3073},\n#line 121 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000G\\000\\003\\006\", 0x011e},\n#line 313 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\322\\000\\003\\001\", 0x03d3},\n#line 545 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000w\\000\\003\\010\", 0x1e85},\n#line 439 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000e\\000\\0030\", 0x1e1b},\n#line 802 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037f\\000\\003E\", 0x1fa6},\n#line 427 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000d\\000\\0031\", 0x1e0f},\n#line 503 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000r\\000\\003#\", 0x1e5b},\n#line 418 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000B\\000\\0031\", 0x1e06},\n#line 284 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\325\\000\\003\\004\", 0x022c},\n#line 495 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001M\\000\\003\\001\", 0x1e53},\n#line 493 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001M\\000\\003\\000\", 0x1e51},\n#line 903 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"}\\000\\0038\", 0x22e1},\n#line 333 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\026\\000\\003\\006\", 0x04c1},\n#line 928 \"./uninorm/composition-table.gperf\"\n      {\"\\0000r\\0000\\232\", 0x3074},\n#line 270 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003\\021\", 0x0216},\n#line 474 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000M\\000\\003\\001\", 0x1e3e},\n#line 55 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000N\\000\\003\\003\", 0x00d1},\n#line 483 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000n\\000\\003#\", 0x1e47},\n#line 922 \"./uninorm/composition-table.gperf\"\n      {\"\\0000d\\0000\\231\", 0x3065},\n#line 476 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000M\\000\\003\\007\", 0x1e40},\n#line 530 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003-\", 0x1e76},\n#line 277 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000h\\000\\003\\014\", 0x021f},\n#line 364 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004G\\000\\003\\010\", 0x04f5},\n#line 518 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000T\\000\\003\\007\", 0x1e6a},\n#line 920 \"./uninorm/composition-table.gperf\"\n      {\"\\0000_\\0000\\231\", 0x3060},\n#line 425 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000d\\000\\003#\", 0x1e0d},\n#line 887 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"e\\000\\0038\", 0x2271},\n#line 416 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000B\\000\\003#\", 0x1e04},\n#line 264 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000R\\000\\003\\017\", 0x0210},\n#line 844 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\376\\000\\003\\001\", 0x1fde},\n#line 843 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\376\\000\\003\\000\", 0x1fdd},\n#line 845 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\376\\000\\003B\", 0x1fdf},\n#line 274 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000T\\000\\003&\", 0x021a},\n#line 184 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003\\012\", 0x016e},\n#line 314 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\322\\000\\003\\010\", 0x03d4},\n#line 310 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\277\\000\\003\\001\", 0x03cc},\n#line 761 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\277\\000\\003\\000\", 0x1f78},\n#line 723 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\237\\000\\003\\023\", 0x1f48},\n#line 529 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\0030\", 0x1e75},\n#line 919 \"./uninorm/composition-table.gperf\"\n      {\"\\0000]\\0000\\231\", 0x305e},\n#line 122 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000g\\000\\003\\006\", 0x011f},\n#line 306 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\271\\000\\003\\001\", 0x03af},\n#line 760 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\271\\000\\003\\000\", 0x1f76},\n#line 838 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\271\\000\\003B\", 0x1fd6},\n#line 448 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000H\\000\\003#\", 0x1e24},\n#line 833 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\277\\000\\003\\001\", 0x1fce},\n#line 832 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\277\\000\\003\\000\", 0x1fcd},\n#line 834 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\277\\000\\003B\", 0x1fcf},\n#line 917 \"./uninorm/composition-table.gperf\"\n      {\"\\0000Y\\0000\\231\", 0x305a},\n#line 319 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\032\\000\\003\\001\", 0x040c},\n#line 565 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000y\\000\\003\\012\", 0x1e99},\n#line 885 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000>\\000\\0038\", 0x226f},\n#line 435 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\023\\000\\003\\001\", 0x1e17},\n#line 433 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\023\\000\\003\\000\", 0x1e15},\n#line 525 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000t\\000\\003-\", 0x1e71},\n#line 651 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Y\\000\\003#\", 0x1ef4},\n#line 345 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\027\\000\\003\\010\", 0x04de},\n#line 776 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\014\\000\\003E\", 0x1f8c},\n#line 562 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000h\\000\\0031\", 0x1e96},\n#line 941 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\263\\0000\\231\", 0x30b4},\n#line 164 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000R\\000\\003\\014\", 0x0158},\n#line 956 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\325\\0000\\231\", 0x30d6},\n#line 779 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\017\\000\\003E\", 0x1f8f},\n#line 267 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000r\\000\\003\\021\", 0x0213},\n#line 305 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\267\\000\\003\\001\", 0x03ae},\n#line 759 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\267\\000\\003\\000\", 0x1f74},\n#line 827 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\267\\000\\003B\", 0x1fc6},\n#line 280 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\003'\", 0x0228},\n#line 626 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\241\\000\\003\\001\", 0x1edb},\n#line 628 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\241\\000\\003\\000\", 0x1edd},\n#line 444 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000G\\000\\003\\004\", 0x1e20},\n#line 924 \"./uninorm/composition-table.gperf\"\n      {\"\\0000h\\0000\\231\", 0x3069},\n#line 438 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000E\\000\\0030\", 0x1e1a},\n#line 227 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000G\\000\\003\\014\", 0x01e6},\n#line 308 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\271\\000\\003\\010\", 0x03ca},\n#line 957 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\325\\0000\\232\", 0x30d7},\n#line 825 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\267\\000\\003E\", 0x1fc3},\n#line 960 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\333\\0000\\231\", 0x30dc},\n#line 449 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000h\\000\\003#\", 0x1e25},\n#line 479 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000m\\000\\003#\", 0x1e43},\n#line 487 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000n\\000\\003-\", 0x1e4b},\n#line 937 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\253\\0000\\231\", 0x30ac},\n#line 303 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\261\\000\\003\\001\", 0x03ac},\n#line 757 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\261\\000\\003\\000\", 0x1f70},\n#line 817 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\261\\000\\003B\", 0x1fb6},\n#line 352 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004>\\000\\003\\010\", 0x04e7},\n#line 293 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\221\\000\\003\\001\", 0x0386},\n#line 821 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\221\\000\\003\\000\", 0x1fba},\n#line 431 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000d\\000\\003-\", 0x1e13},\n#line 606 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\036\\271\\000\\003\\002\", 0x1ec7},\n#line 778 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\016\\000\\003E\", 0x1f8e},\n#line 961 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\333\\0000\\232\", 0x30dd},\n#line 362 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004C\\000\\003\\013\", 0x04f3},\n#line 152 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000N\\000\\003\\014\", 0x0147},\n#line 815 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\261\\000\\003E\", 0x1fb3},\n#line 879 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"E\\000\\0038\", 0x2247},\n#line 717 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\277\\000\\003\\023\", 0x1f40},\n#line 506 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000R\\000\\0031\", 0x1e5e},\n#line 822 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\221\\000\\003E\", 0x1fbc},\n#line 356 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004M\\000\\003\\010\", 0x04ed},\n#line 724 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\237\\000\\003\\024\", 0x1f49},\n#line 167 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000s\\000\\003\\001\", 0x015b},\n#line 701 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\271\\000\\003\\023\", 0x1f30},\n#line 835 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\271\\000\\003\\006\", 0x1fd0},\n#line 169 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000s\\000\\003\\002\", 0x015d},\n#line 509 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000s\\000\\003\\007\", 0x1e61},\n#line 977 \"./uninorm/composition-table.gperf\"\n      {\"\\001\\024\\271\\001\\024\\275\", 0x114be},\n#line 528 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\0030\", 0x1e74},\n#line 916 \"./uninorm/composition-table.gperf\"\n      {\"\\0000W\\0000\\231\", 0x3058},\n#line 317 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\023\\000\\003\\001\", 0x0403},\n#line 445 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000g\\000\\003\\004\", 0x1e21},\n#line 460 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000K\\000\\003\\001\", 0x1e30},\n#line 770 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\006\\000\\003E\", 0x1f86},\n#line 228 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000g\\000\\003\\014\", 0x01e7},\n#line 273 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000s\\000\\003&\", 0x0219},\n#line 548 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000W\\000\\003#\", 0x1e88},\n#line 244 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\306\\000\\003\\001\", 0x01fc},\n#line 502 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000R\\000\\003#\", 0x1e5a},\n#line 580 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\036\\241\\000\\003\\002\", 0x1ead},\n#line 311 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\305\\000\\003\\001\", 0x03cd},\n#line 762 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\305\\000\\003\\000\", 0x1f7a},\n#line 851 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\305\\000\\003B\", 0x1fe6},\n#line 143 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000l\\000\\003\\001\", 0x013a},\n#line 242 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\305\\000\\003\\001\", 0x01fa},\n#line 166 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000S\\000\\003\\001\", 0x015a},\n#line 685 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\267\\000\\003\\023\", 0x1f20},\n#line 632 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\241\\000\\003\\003\", 0x1ee1},\n#line 168 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000S\\000\\003\\002\", 0x015c},\n#line 508 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000S\\000\\003\\007\", 0x1e60},\n#line 146 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000L\\000\\003\\014\", 0x013d},\n#line 484 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000N\\000\\0031\", 0x1e48},\n#line 296 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\231\\000\\003\\001\", 0x038a},\n#line 842 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\231\\000\\003\\000\", 0x1fda},\n#line 512 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001Z\\000\\003\\007\", 0x1e64},\n#line 828 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\306\\000\\003E\", 0x1fc7},\n#line 195 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Z\\000\\003\\001\", 0x0179},\n#line 175 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000t\\000\\003'\", 0x0163},\n#line 272 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000S\\000\\003&\", 0x0218},\n#line 556 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Z\\000\\003\\002\", 0x1e90},\n#line 197 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Z\\000\\003\\007\", 0x017b},\n#line 808 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037l\\000\\003E\", 0x1fac},\n      {\"\"},\n#line 100 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000c\\000\\003\\001\", 0x0107},\n#line 657 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\261\\000\\003\\023\", 0x1f00},\n#line 812 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\261\\000\\003\\006\", 0x1fb0},\n#line 102 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000c\\000\\003\\002\", 0x0109},\n#line 104 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000c\\000\\003\\007\", 0x010b},\n#line 665 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\221\\000\\003\\023\", 0x1f08},\n#line 819 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\221\\000\\003\\006\", 0x1fb8},\n      {\"\"},\n#line 482 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000N\\000\\003#\", 0x1e46},\n#line 163 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000r\\000\\003'\", 0x0157},\n#line 309 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\305\\000\\003\\010\", 0x03cb},\n#line 196 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000z\\000\\003\\001\", 0x017a},\n#line 176 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000T\\000\\003\\014\", 0x0164},\n#line 422 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000D\\000\\003\\007\", 0x1e0a},\n#line 557 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000z\\000\\003\\002\", 0x1e91},\n#line 198 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000z\\000\\003\\007\", 0x017c},\n      {\"\"},\n#line 718 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\277\\000\\003\\024\", 0x1f41},\n#line 799 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037c\\000\\003E\", 0x1fa3},\n#line 549 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000w\\000\\003#\", 0x1e89},\n#line 151 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000n\\000\\003'\", 0x0146},\n#line 159 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003\\013\", 0x0151},\n#line 301 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\231\\000\\003\\010\", 0x03aa},\n#line 702 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\271\\000\\003\\024\", 0x1f31},\n#line 470 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000L\\000\\0031\", 0x1e3a},\n      {\"\"},\n#line 640 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\260\\000\\003\\001\", 0x1ee9},\n#line 642 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\260\\000\\003\\000\", 0x1eeb},\n#line 429 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000d\\000\\003'\", 0x1e11},\n#line 923 \"./uninorm/composition-table.gperf\"\n      {\"\\0000f\\0000\\231\", 0x3067},\n#line 187 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003\\013\", 0x0171},\n#line 836 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\271\\000\\003\\004\", 0x1fd1},\n#line 266 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000R\\000\\003\\021\", 0x0212},\n#line 625 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\240\\000\\003\\001\", 0x1eda},\n#line 627 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\240\\000\\003\\000\", 0x1edc},\n#line 590 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\036\\241\\000\\003\\006\", 0x1eb7},\n#line 318 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\006\\000\\003\\010\", 0x0407},\n#line 888 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"r\\000\\0038\", 0x2274},\n#line 729 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\305\\000\\003\\023\", 0x1f50},\n#line 846 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\305\\000\\003\\006\", 0x1fe0},\n#line 639 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\257\\000\\003\\001\", 0x1ee8},\n#line 641 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\257\\000\\003\\000\", 0x1eea},\n      {\"\"},\n#line 630 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\241\\000\\003\\011\", 0x1edf},\n#line 466 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000L\\000\\003#\", 0x1e36},\n#line 517 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\036c\\000\\003\\007\", 0x1e69},\n#line 686 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\267\\000\\003\\024\", 0x1f21},\n#line 452 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000H\\000\\003'\", 0x1e28},\n#line 954 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\322\\0000\\231\", 0x30d3},\n#line 522 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000T\\000\\0031\", 0x1e6e},\n#line 709 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\231\\000\\003\\023\", 0x1f38},\n#line 840 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\231\\000\\003\\006\", 0x1fd8},\n#line 856 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\241\\000\\003\\024\", 0x1fec},\n#line 366 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004K\\000\\003\\010\", 0x04f9},\n#line 874 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\013\\000\\0038\", 0x220c},\n#line 235 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\267\\000\\003\\014\", 0x01ee},\n#line 886 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"d\\000\\0038\", 0x2270},\n      {\"\"},\n#line 911 \"./uninorm/composition-table.gperf\"\n      {\"\\0000M\\0000\\231\", 0x304e},\n#line 415 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000b\\000\\003\\007\", 0x1e03},\n#line 785 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037%\\000\\003E\", 0x1f95},\n      {\"\"},\n#line 955 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\322\\0000\\232\", 0x30d4},\n#line 394 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\015G\\000\\015>\", 0x0d4b},\n#line 658 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\261\\000\\003\\024\", 0x1f01},\n#line 478 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000M\\000\\003#\", 0x1e42},\n#line 304 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\265\\000\\003\\001\", 0x03ad},\n#line 758 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\265\\000\\003\\000\", 0x1f72},\n#line 666 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\221\\000\\003\\024\", 0x1f09},\n#line 520 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000T\\000\\003#\", 0x1e6c},\n#line 975 \"./uninorm/composition-table.gperf\"\n      {\"\\001\\024\\271\\001\\024\\272\", 0x114bb},\n#line 486 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000N\\000\\003-\", 0x1e4a},\n#line 813 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\261\\000\\003\\004\", 0x1fb1},\n#line 798 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037b\\000\\003E\", 0x1fa2},\n#line 783 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037#\\000\\003E\", 0x1f93},\n#line 880 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"H\\000\\0038\", 0x2249},\n#line 820 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\221\\000\\003\\004\", 0x1fb9},\n#line 158 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003\\013\", 0x0150},\n#line 461 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000k\\000\\003\\001\", 0x1e31},\n#line 795 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037/\\000\\003E\", 0x1f9f},\n#line 246 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\330\\000\\003\\001\", 0x01fe},\n#line 453 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000h\\000\\003'\", 0x1e29},\n#line 947 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\277\\0000\\231\", 0x30c0},\n#line 579 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\036\\240\\000\\003\\002\", 0x1eac},\n#line 646 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\260\\000\\003\\003\", 0x1eef},\n#line 300 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\312\\000\\003\\001\", 0x0390},\n#line 837 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\312\\000\\003\\000\", 0x1fd2},\n#line 839 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\312\\000\\003B\", 0x1fd7},\n#line 944 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\271\\0000\\231\", 0x30ba},\n#line 597 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\312\\000\\003\\001\", 0x1ebe},\n#line 599 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\312\\000\\003\\000\", 0x1ec0},\n#line 631 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\240\\000\\003\\003\", 0x1ee0},\n#line 849 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\301\\000\\003\\023\", 0x1fe4},\n#line 408 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\033<\\000\\0335\", 0x1b3d},\n#line 173 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000s\\000\\003\\014\", 0x0161},\n#line 564 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000w\\000\\003\\012\", 0x1e98},\n#line 807 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037k\\000\\003E\", 0x1fab},\n#line 907 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\263\\000\\0038\", 0x22eb},\n#line 645 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\257\\000\\003\\003\", 0x1eee},\n#line 186 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003\\013\", 0x0170},\n#line 516 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\036b\\000\\003\\007\", 0x1e68},\n#line 730 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\305\\000\\003\\024\", 0x1f51},\n#line 299 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\251\\000\\003\\001\", 0x038f},\n#line 864 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\251\\000\\003\\000\", 0x1ffa},\n#line 229 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000K\\000\\003\\014\", 0x01e8},\n#line 535 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001k\\000\\003\\010\", 0x1e7b},\n#line 225 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\306\\000\\003\\004\", 0x01e2},\n#line 472 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000L\\000\\003-\", 0x1e3c},\n#line 407 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\033:\\000\\0335\", 0x1b3b},\n#line 847 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\305\\000\\003\\004\", 0x1fe1},\n#line 403 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\033\\011\\000\\0335\", 0x1b0a},\n#line 943 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\267\\0000\\231\", 0x30b8},\n      {\"\"},\n#line 710 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\231\\000\\003\\024\", 0x1f39},\n#line 865 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\251\\000\\003E\", 0x1ffc},\n#line 147 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000l\\000\\003\\014\", 0x013e},\n#line 551 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000x\\000\\003\\007\", 0x1e8b},\n#line 172 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000S\\000\\003\\014\", 0x0160},\n#line 634 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\241\\000\\003#\", 0x1ee3},\n#line 901 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\253\\000\\0038\", 0x22af},\n#line 162 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000R\\000\\003'\", 0x0156},\n#line 841 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\231\\000\\003\\004\", 0x1fd9},\n#line 713 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0378\\000\\003\\001\", 0x1f3c},\n#line 711 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0378\\000\\003\\000\", 0x1f3a},\n#line 715 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0378\\000\\003B\", 0x1f3e},\n#line 298 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\245\\000\\003\\001\", 0x038e},\n#line 855 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\245\\000\\003\\000\", 0x1fea},\n#line 673 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\265\\000\\003\\023\", 0x1f10},\n#line 199 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Z\\000\\003\\014\", 0x017d},\n#line 940 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\261\\0000\\231\", 0x30b2},\n#line 683 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\030\\000\\003\\001\", 0x1f1c},\n#line 681 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037\\030\\000\\003\\000\", 0x1f1a},\n#line 524 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000T\\000\\003-\", 0x1e70},\n#line 125 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000G\\000\\003'\", 0x0122},\n#line 513 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001[\\000\\003\\007\", 0x1e65},\n#line 106 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000c\\000\\003\\014\", 0x010d},\n#line 312 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\311\\000\\003\\001\", 0x03ce},\n#line 763 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\311\\000\\003\\000\", 0x1f7c},\n#line 861 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\311\\000\\003B\", 0x1ff6},\n#line 402 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\033\\007\\000\\0335\", 0x1b08},\n#line 359 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004#\\000\\003\\010\", 0x04f0},\n#line 464 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000K\\000\\0031\", 0x1e34},\n#line 589 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\036\\240\\000\\003\\006\", 0x1eb6},\n#line 644 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\260\\000\\003\\011\", 0x1eed},\n#line 107 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000D\\000\\003\\014\", 0x010e},\n#line 553 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000x\\000\\003\\010\", 0x1e8d},\n#line 200 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000z\\000\\003\\014\", 0x017e},\n#line 603 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\312\\000\\003\\003\", 0x1ec4},\n#line 859 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\311\\000\\003E\", 0x1ff3},\n#line 458 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\317\\000\\003\\001\", 0x1e2e},\n#line 629 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\240\\000\\003\\011\", 0x1ede},\n#line 511 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000s\\000\\003#\", 0x1e63},\n#line 471 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000l\\000\\0031\", 0x1e3b},\n#line 150 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000N\\000\\003'\", 0x0145},\n#line 910 \"./uninorm/composition-table.gperf\"\n      {\"\\0000K\\0000\\231\", 0x304c},\n#line 850 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\301\\000\\003\\024\", 0x1fe5},\n#line 536 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000V\\000\\003\\003\", 0x1e7c},\n#line 643 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\257\\000\\003\\011\", 0x1eec},\n#line 302 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\245\\000\\003\\010\", 0x03ab},\n#line 950 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\306\\0000\\231\", 0x30c7},\n#line 368 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\006'\\000\\006T\", 0x0623},\n#line 462 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000K\\000\\003#\", 0x1e32},\n      {\"\"},\n#line 749 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\251\\000\\003\\023\", 0x1f68},\n#line 341 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\330\\000\\003\\010\", 0x04da},\n#line 560 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Z\\000\\0031\", 0x1e94},\n#line 504 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\036Z\\000\\003\\004\", 0x1e5c},\n#line 914 \"./uninorm/composition-table.gperf\"\n      {\"\\0000S\\0000\\231\", 0x3054},\n#line 329 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0048\\000\\003\\000\", 0x045d},\n#line 321 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004#\\000\\003\\006\", 0x040e},\n#line 615 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\324\\000\\003\\001\", 0x1ed0},\n#line 617 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\324\\000\\003\\000\", 0x1ed2},\n#line 467 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000l\\000\\003#\", 0x1e37},\n#line 126 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000g\\000\\003'\", 0x0123},\n#line 510 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000S\\000\\003#\", 0x1e62},\n#line 527 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003$\", 0x1e73},\n#line 320 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\030\\000\\003\\000\", 0x040d},\n      {\"\"},\n#line 598 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\352\\000\\003\\001\", 0x1ebf},\n#line 600 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\352\\000\\003\\000\", 0x1ec1},\n      {\"\"},\n#line 426 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000D\\000\\0031\", 0x1e0e},\n#line 327 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004V\\000\\003\\010\", 0x0457},\n#line 561 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000z\\000\\0031\", 0x1e95},\n#line 378 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\011\\307\\000\\011\\276\", 0x09cb},\n#line 558 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000Z\\000\\003#\", 0x1e92},\n#line 289 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\002/\\000\\003\\004\", 0x0231},\n#line 853 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\245\\000\\003\\006\", 0x1fe8},\n#line 972 \"./uninorm/composition-table.gperf\"\n      {\"\\001\\0212\\001\\021'\", 0x1112f},\n#line 144 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000L\\000\\003'\", 0x013b},\n#line 674 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\265\\000\\003\\024\", 0x1f11},\n#line 371 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\006J\\000\\006T\", 0x0626},\n#line 891 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"w\\000\\0038\", 0x2279},\n#line 690 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037!\\000\\003\\001\", 0x1f25},\n#line 688 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037!\\000\\003\\000\", 0x1f23},\n#line 692 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037!\\000\\003B\", 0x1f27},\n#line 381 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\013G\\000\\013>\", 0x0b4b},\n#line 741 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\311\\000\\003\\023\", 0x1f60},\n#line 295 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\227\\000\\003\\001\", 0x0389},\n#line 830 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\227\\000\\003\\000\", 0x1fca},\n#line 350 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0048\\000\\003\\010\", 0x04e5},\n#line 424 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000D\\000\\003#\", 0x1e0c},\n#line 968 \"./uninorm/composition-table.gperf\"\n      {\"\\001\\020\\231\\001\\020\\272\", 0x1109a},\n#line 559 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000z\\000\\003#\", 0x1e93},\n      {\"\"},\n#line 781 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037!\\000\\003E\", 0x1f91},\n#line 601 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\312\\000\\003\\011\", 0x1ec2},\n      {\"\"},\n#line 349 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\030\\000\\003\\010\", 0x04e4},\n#line 401 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\033\\005\\000\\0335\", 0x1b06},\n#line 831 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\227\\000\\003E\", 0x1fcc},\n#line 978 \"./uninorm/composition-table.gperf\"\n      {\"\\001\\025\\270\\001\\025\\257\", 0x115ba},\n#line 405 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\033\\015\\000\\0335\", 0x1b0e},\n#line 230 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000k\\000\\003\\014\", 0x01e9},\n#line 174 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000T\\000\\003'\", 0x0162},\n#line 496 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000P\\000\\003\\001\", 0x1e54},\n#line 410 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\033?\\000\\0335\", 0x1b41},\n      {\"\"},\n#line 648 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\260\\000\\003#\", 0x1ef1},\n#line 498 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000P\\000\\003\\007\", 0x1e56},\n#line 948 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\301\\0000\\231\", 0x30c2},\n#line 733 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037P\\000\\003\\001\", 0x1f54},\n#line 731 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037P\\000\\003\\000\", 0x1f52},\n#line 735 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037P\\000\\003B\", 0x1f56},\n      {\"\"},\n#line 633 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\240\\000\\003#\", 0x1ee2},\n#line 750 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\251\\000\\003\\024\", 0x1f69},\n#line 419 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000b\\000\\0031\", 0x1e07},\n#line 621 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\324\\000\\003\\003\", 0x1ed6},\n#line 323 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0048\\000\\003\\006\", 0x0439},\n#line 868 \"./uninorm/composition-table.gperf\"\n      {\"\\000!\\224\\000\\0038\", 0x21ae},\n#line 939 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\257\\0000\\231\", 0x30b0},\n#line 647 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\257\\000\\003#\", 0x1ef0},\n#line 514 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001`\\000\\003\\007\", 0x1e66},\n#line 866 \"./uninorm/composition-table.gperf\"\n      {\"\\000!\\220\\000\\0038\", 0x219a},\n#line 473 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000l\\000\\003-\", 0x1e3d},\n#line 604 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\352\\000\\003\\003\", 0x1ec5},\n#line 322 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\030\\000\\003\\006\", 0x0419},\n#line 883 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"M\\000\\0038\", 0x226d},\n#line 357 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004#\\000\\003\\004\", 0x04ee},\n      {\"\"},\n#line 745 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037`\\000\\003\\001\", 0x1f64},\n#line 743 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037`\\000\\003\\000\", 0x1f62},\n#line 747 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037`\\000\\003B\", 0x1f66},\n#line 526 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003$\", 0x1e72},\n#line 616 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\364\\000\\003\\001\", 0x1ed1},\n#line 618 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\364\\000\\003\\000\", 0x1ed3},\n#line 417 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000b\\000\\003#\", 0x1e05},\n#line 867 \"./uninorm/composition-table.gperf\"\n      {\"\\000!\\222\\000\\0038\", 0x219b},\n#line 737 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\245\\000\\003\\024\", 0x1f59},\n#line 465 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000k\\000\\0031\", 0x1e35},\n      {\"\"},\n#line 382 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\013G\\000\\013W\", 0x0b4c},\n#line 796 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037`\\000\\003E\", 0x1fa0},\n      {\"\"},\n#line 942 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\265\\0000\\231\", 0x30b6},\n      {\"\"},\n#line 854 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\245\\000\\003\\004\", 0x1fe9},\n      {\"\"},\n#line 693 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\227\\000\\003\\023\", 0x1f28},\n#line 742 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\311\\000\\003\\024\", 0x1f61},\n#line 869 \"./uninorm/composition-table.gperf\"\n      {\"\\000!\\320\\000\\0038\", 0x21cd},\n#line 387 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\014F\\000\\014V\", 0x0c48},\n      {\"\"},\n#line 430 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000D\\000\\003-\", 0x1e12},\n#line 958 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\330\\0000\\231\", 0x30d9},\n#line 294 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\225\\000\\003\\001\", 0x0388},\n#line 829 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\225\\000\\003\\000\", 0x1fc8},\n#line 572 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\342\\000\\003\\001\", 0x1ea5},\n#line 574 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\342\\000\\003\\000\", 0x1ea7},\n#line 463 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000k\\000\\003#\", 0x1e33},\n#line 307 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\313\\000\\003\\001\", 0x03b0},\n#line 848 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\313\\000\\003\\000\", 0x1fe2},\n#line 852 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\313\\000\\003B\", 0x1fe7},\n#line 571 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\302\\000\\003\\001\", 0x1ea4},\n#line 573 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\302\\000\\003\\000\", 0x1ea6},\n#line 292 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\250\\000\\003\\001\", 0x0385},\n#line 857 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\250\\000\\003\\000\", 0x1fed},\n#line 823 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\250\\000\\003B\", 0x1fc1},\n#line 959 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\330\\0000\\232\", 0x30da},\n#line 734 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037Q\\000\\003\\001\", 0x1f55},\n#line 732 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037Q\\000\\003\\000\", 0x1f53},\n#line 736 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037Q\\000\\003B\", 0x1f57},\n#line 202 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000o\\000\\003\\033\", 0x01a1},\n#line 497 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000p\\000\\003\\001\", 0x1e55},\n#line 786 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037&\\000\\003E\", 0x1f96},\n#line 139 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000j\\000\\003\\002\", 0x0135},\n#line 619 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\324\\000\\003\\011\", 0x1ed4},\n#line 499 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000p\\000\\003\\007\", 0x1e57},\n      {\"\"},\n#line 538 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000V\\000\\003#\", 0x1e7e},\n#line 324 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0045\\000\\003\\000\", 0x0450},\n#line 204 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000u\\000\\003\\033\", 0x01b0},\n#line 413 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000a\\000\\003%\", 0x1e01},\n      {\"\"},\n#line 602 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\352\\000\\003\\011\", 0x1ec3},\n#line 171 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000s\\000\\003'\", 0x015f},\n#line 931 \"./uninorm/composition-table.gperf\"\n      {\"\\0000x\\0000\\231\", 0x3079},\n      {\"\"},\n#line 348 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0048\\000\\003\\004\", 0x04e3},\n      {\"\"},\n#line 806 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037j\\000\\003E\", 0x1faa},\n#line 814 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037p\\000\\003E\", 0x1fb2},\n#line 622 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\364\\000\\003\\003\", 0x1ed7},\n#line 233 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001\\352\\000\\003\\004\", 0x01ec},\n      {\"\"},\n#line 140 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000K\\000\\003'\", 0x0136},\n#line 347 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004\\030\\000\\003\\004\", 0x04e2},\n      {\"\"},\n#line 505 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\036[\\000\\003\\004\", 0x1e5d},\n#line 534 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\001j\\000\\003\\010\", 0x1e7a},\n#line 932 \"./uninorm/composition-table.gperf\"\n      {\"\\0000x\\0000\\232\", 0x307a},\n      {\"\"},\n#line 904 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\221\\000\\0038\", 0x22e2},\n      {\"\"}, {\"\"}, {\"\"},\n#line 145 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000l\\000\\003'\", 0x013c},\n      {\"\"},\n#line 170 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000S\\000\\003'\", 0x015e},\n      {\"\"},\n#line 918 \"./uninorm/composition-table.gperf\"\n      {\"\\0000[\\0000\\231\", 0x305c},\n#line 694 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\227\\000\\003\\024\", 0x1f29},\n#line 325 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0045\\000\\003\\010\", 0x0451},\n#line 889 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"s\\000\\0038\", 0x2275},\n      {\"\"},\n#line 578 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\342\\000\\003\\003\", 0x1eab},\n#line 679 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\225\\000\\003\\023\", 0x1f18},\n#line 689 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037 \\000\\003\\001\", 0x1f24},\n#line 687 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037 \\000\\003\\000\", 0x1f22},\n#line 691 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037 \\000\\003B\", 0x1f26},\n      {\"\"},\n#line 577 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\302\\000\\003\\003\", 0x1eaa},\n      {\"\"},\n#line 952 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\317\\0000\\231\", 0x30d0},\n      {\"\"}, {\"\"},\n#line 72 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000c\\000\\003'\", 0x00e7},\n#line 970 \"./uninorm/composition-table.gperf\"\n      {\"\\001\\020\\245\\001\\020\\272\", 0x110ab},\n#line 201 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000O\\000\\003\\033\", 0x01a0},\n#line 780 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\037 \\000\\003E\", 0x1f90},\n      {\"\"},\n#line 406 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\033\\021\\000\\0335\", 0x1b12},\n      {\"\"}, {\"\"},\n#line 404 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\033\\013\\000\\0335\", 0x1b0c},\n#line 428 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000D\\000\\003'\", 0x1e10},\n      {\"\"},\n#line 953 \"./uninorm/composition-table.gperf\"\n      {\"\\0000\\317\\0000\\232\", 0x30d1},\n#line 411 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\033B\\000\\0335\", 0x1b43},\n#line 454 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000H\\000\\003.\", 0x1e2a},\n      {\"\"},\n#line 340 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\0045\\000\\003\\006\", 0x04d7},\n      {\"\"}, {\"\"}, {\"\"},\n#line 412 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000A\\000\\003%\", 0x1e00},\n      {\"\"},\n#line 971 \"./uninorm/composition-table.gperf\"\n      {\"\\001\\0211\\001\\021'\", 0x1112e},\n#line 383 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\013\\222\\000\\013\\327\", 0x0b94},\n      {\"\"},\n#line 203 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000U\\000\\003\\033\", 0x01af},\n#line 620 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\364\\000\\003\\011\", 0x1ed5},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 379 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\011\\307\\000\\011\\327\", 0x09cc},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 892 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"z\\000\\0038\", 0x2280},\n      {\"\"},\n#line 388 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\014\\277\\000\\014\\325\", 0x0cc0},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 455 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000h\\000\\003.\", 0x1e2b},\n#line 576 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\342\\000\\003\\011\", 0x1ea9},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 680 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\003\\225\\000\\003\\024\", 0x1f19},\n#line 575 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000\\302\\000\\003\\011\", 0x1ea8},\n#line 223 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\002&\\000\\003\\004\", 0x01e0},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 396 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\015\\331\\000\\015\\312\", 0x0dda},\n#line 876 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"%\\000\\0038\", 0x2226},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 367 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\006'\\000\\006S\", 0x0622},\n#line 141 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000k\\000\\003'\", 0x0137},\n      {\"\"},\n#line 380 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\013G\\000\\013V\", 0x0b48},\n#line 237 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\000j\\000\\003\\014\", 0x01f0},\n#line 385 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\013\\307\\000\\013\\276\", 0x0bcb},\n      {\"\"},\n#line 875 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"#\\000\\0038\", 0x2224},\n      {\"\"},\n#line 973 \"./uninorm/composition-table.gperf\"\n      {\"\\001\\023G\\001\\023>\", 0x1134b},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"},\n#line 909 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\265\\000\\0038\", 0x22ed},\n#line 369 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\006H\\000\\006T\", 0x0624},\n      {\"\"}, {\"\"}, {\"\"},\n#line 398 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\015\\334\\000\\015\\312\", 0x0ddd},\n      {\"\"}, {\"\"},\n#line 390 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\014\\306\\000\\014\\326\", 0x0cc8},\n#line 391 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\014\\306\\000\\014\\302\", 0x0cca},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"},\n#line 389 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\014\\306\\000\\014\\325\", 0x0cc7},\n      {\"\"}, {\"\"}, {\"\"},\n#line 913 \"./uninorm/composition-table.gperf\"\n      {\"\\0000Q\\0000\\231\", 0x3052},\n#line 372 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\006\\325\\000\\006T\", 0x06c0},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"},\n#line 900 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\251\\000\\0038\", 0x22ae},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 974 \"./uninorm/composition-table.gperf\"\n      {\"\\001\\023G\\001\\023W\", 0x1134c},\n#line 976 \"./uninorm/composition-table.gperf\"\n      {\"\\001\\024\\271\\001\\024\\260\", 0x114bc},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 409 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\033>\\000\\0335\", 0x1b40},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 392 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\014\\312\\000\\014\\325\", 0x0ccb},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"},\n#line 361 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\004#\\000\\003\\013\", 0x04f2},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 374 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\006\\322\\000\\006T\", 0x06d3},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 979 \"./uninorm/composition-table.gperf\"\n      {\"\\001\\025\\271\\001\\025\\257\", 0x115bb},\n      {\"\"}, {\"\"}, {\"\"},\n#line 370 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\006'\\000\\006U\", 0x0625},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 899 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\\"\\250\\000\\0038\", 0x22ad},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"},\n#line 871 \"./uninorm/composition-table.gperf\"\n      {\"\\000!\\322\\000\\0038\", 0x21cf},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"},\n#line 384 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\013\\306\\000\\013\\276\", 0x0bca},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 373 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\006\\301\\000\\006T\", 0x06c2},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 400 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\020%\\000\\020.\", 0x1026},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 386 \"./uninorm/composition-table.gperf\"\n      {\"\\000\\013\\306\\000\\013\\327\", 0x0bcc},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n      {\"\"}, {\"\"}, {\"\"},\n#line 870 \"./uninorm/composition-table.gperf\"\n      {\"\\000!\\324\\000\\0038\", 0x21ce}\n    };\n\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register unsigned int key = gl_uninorm_compose_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE)\n        if (len == lengthtable[key])\n          {\n            register const char *s = wordlist[key].codes;\n\n            if (*str == *s && !memcmp (str + 1, s + 1, len - 1))\n              return &wordlist[key];\n          }\n    }\n  return 0;\n}",
      "lines": 2142,
      "depth": 15,
      "decorators": [
        "const",
        "const",
        "struct composition_rule",
        "struct",
        "composition_rule",
        "*\ngl_uninorm_compose_lookup (register const char *str, register size_t len)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/uninorm/composition.c": {
    "uc_composition": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "ucs4_t\nuc_composition (ucs4_t uc1, ucs4_t uc2)\n{\n  if (uc1 < 0x12000 && uc2 < 0x12000)\n    {\n      if (uc2 >= 0x1161 && uc2 < 0x1161 + 21\n          && uc1 >= 0x1100 && uc1 < 0x1100 + 19)\n        {\n          /* Hangul: Combine single letter L and single letter V to form\n             two-letter syllable LV.  */\n          return 0xAC00 + ((uc1 - 0x1100) * 21 + (uc2 - 0x1161)) * 28;\n        }\n      else if (uc2 > 0x11A7 && uc2 < 0x11A7 + 28\n               && uc1 >= 0xAC00 && uc1 < 0xD7A4 && ((uc1 - 0xAC00) % 28) == 0)\n        {\n          /* Hangul: Combine two-letter syllable LV with single-letter T\n             to form three-letter syllable LVT.  */\n          return uc1 + (uc2 - 0x11A7);\n        }\n      else\n        {\n#if 0\n          unsigned int uc = MUL1 * uc1 * MUL2 * uc2;\n          unsigned int index1 = uc >> composition_header_0;\n          if (index1 < composition_header_1)\n            {\n              int lookup1 = u_composition.level1[index1];\n              if (lookup1 >= 0)\n                {\n                  unsigned int index2 = (uc >> composition_header_2) & composition_header_3;\n                  int lookup2 = u_composition.level2[lookup1 + index2];\n                  if (lookup2 >= 0)\n                    {\n                      unsigned int index3 = (uc & composition_header_4);\n                      unsigned int lookup3 = u_composition.level3[lookup2 + index3];\n                      if ((lookup3 >> 16) == uc2)\n                        return lookup3 & ((1U << 16) - 1);\n                    }\n                }\n            }\n#else\n          char codes[6];\n          const struct composition_rule *rule;\n\n          codes[0] = (uc1 >> 16) & 0xff;\n          codes[1] = (uc1 >> 8) & 0xff;\n          codes[2] = uc1 & 0xff;\n          codes[3] = (uc2 >> 16) & 0xff;\n          codes[4] = (uc2 >> 8) & 0xff;\n          codes[5] = uc2 & 0xff;\n\n          rule = gl_uninorm_compose_lookup (codes, 6);\n          if (rule != NULL)\n            return rule->combined;\n#endif\n        }\n    }\n  return 0;\n}",
      "lines": 59,
      "depth": 22,
      "decorators": [
        "ucs4_t"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/uninorm/decompose-internal.c": {},
  "libidn/libidn2-2.0.5/unistring/uninorm/decompose-internal.h": {},
  "libidn/libidn2-2.0.5/unistring/uninorm/decomposition-table.c": {},
  "libidn/libidn2-2.0.5/unistring/uninorm/decomposition-table.h": {
    "decomp_index": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static inline unsigned short\ndecomp_index (ucs4_t uc)\n{\n  unsigned int index1 = uc >> decomp_header_0;\n  if (index1 < decomp_header_1)\n    {\n      int lookup1 = gl_uninorm_decomp_index_table.level1[index1];\n      if (lookup1 >= 0)\n        {\n          unsigned int index2 = (uc >> decomp_header_2) & decomp_header_3;\n          int lookup2 = gl_uninorm_decomp_index_table.level2[lookup1 + index2];\n          if (lookup2 >= 0)\n            {\n              unsigned int index3 = uc & decomp_header_4;\n              return gl_uninorm_decomp_index_table.level3[lookup2 + index3];\n            }\n        }\n    }\n  return (unsigned short)(-1);\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "unsigned short",
        "unsigned",
        "short"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/uninorm/decomposition-table1.h": {},
  "libidn/libidn2-2.0.5/unistring/uninorm/decomposition-table2.h": {},
  "libidn/libidn2-2.0.5/unistring/uninorm/nfc.c": {},
  "libidn/libidn2-2.0.5/unistring/uninorm/nfd.c": {},
  "libidn/libidn2-2.0.5/unistring/uninorm/normalize-internal.h": {},
  "libidn/libidn2-2.0.5/unistring/uninorm/u-normalize-internal.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        388,
        1
      ],
      "content": "UNIT *\nFUNC (uninorm_t nf, const UNIT *s, size_t n,\n      UNIT *resultbuf, size_t *lengthp)\n{\n  int (*decomposer) (ucs4_t uc, ucs4_t *decomposition) = nf->decomposer;\n  ucs4_t (*composer) (ucs4_t uc1, ucs4_t uc2) = nf->composer;\n\n  /* The result being accumulated.  */\n  UNIT *result;\n  size_t length;\n  size_t allocated;\n  /* The buffer for sorting.  */\n  #define SORTBUF_PREALLOCATED 64\n  struct ucs4_with_ccc sortbuf_preallocated[2 * SORTBUF_PREALLOCATED];\n  struct ucs4_with_ccc *sortbuf; /* array of size 2 * sortbuf_allocated */\n  size_t sortbuf_allocated;\n  size_t sortbuf_count;\n\n  /* Initialize the accumulator.  */\n  if (resultbuf == NULL)\n    {\n      result = NULL;\n      allocated = 0;\n    }\n  else\n    {\n      result = resultbuf;\n      allocated = *lengthp;\n    }\n  length = 0;\n\n  /* Initialize the buffer for sorting.  */\n  sortbuf = sortbuf_preallocated;\n  sortbuf_allocated = SORTBUF_PREALLOCATED;\n  sortbuf_count = 0;\n\n  {\n    const UNIT *s_end = s + n;\n\n    for (;;)\n      {\n        int count;\n        ucs4_t decomposed[UC_DECOMPOSITION_MAX_LENGTH];\n        int decomposed_count;\n        int i;\n\n        if (s < s_end)\n          {\n            /* Fetch the next character.  */\n            count = U_MBTOUC_UNSAFE (&decomposed[0], s, s_end - s);\n            decomposed_count = 1;\n\n            /* Decompose it, recursively.\n               It would be possible to precompute the recursive decomposition\n               and store it in a table.  But this would significantly increase\n               the size of the decomposition tables, because for example for\n               U+1FC1 the recursive canonical decomposition and the recursive\n               compatibility decomposition are different.  */\n            {\n              int curr;\n\n              for (curr = 0; curr < decomposed_count; )\n                {\n                  /* Invariant: decomposed[0..curr-1] is fully decomposed, i.e.\n                     all elements are atomic.  */\n                  ucs4_t curr_decomposed[UC_DECOMPOSITION_MAX_LENGTH];\n                  int curr_decomposed_count;\n\n                  curr_decomposed_count = decomposer (decomposed[curr], curr_decomposed);\n                  if (curr_decomposed_count >= 0)\n                    {\n                      /* Move curr_decomposed[0..curr_decomposed_count-1] over\n                         decomposed[curr], making room.  It's not worth using\n                         memcpy() here, since the counts are so small.  */\n                      int shift = curr_decomposed_count - 1;\n\n                      if (shift < 0)\n                        abort ();\n                      if (shift > 0)\n                        {\n                          int j;\n\n                          decomposed_count += shift;\n                          if (decomposed_count > UC_DECOMPOSITION_MAX_LENGTH)\n                            abort ();\n                          for (j = decomposed_count - 1 - shift; j > curr; j--)\n                            decomposed[j + shift] = decomposed[j];\n                        }\n                      for (; shift >= 0; shift--)\n                        decomposed[curr + shift] = curr_decomposed[shift];\n                    }\n                  else\n                    {\n                      /* decomposed[curr] is atomic.  */\n                      curr++;\n                    }\n                }\n            }\n          }\n        else\n          {\n            count = 0;\n            decomposed_count = 0;\n          }\n\n        i = 0;\n        for (;;)\n          {\n            ucs4_t uc;\n            int ccc;\n\n            if (s < s_end)\n              {\n                /* Fetch the next character from the decomposition.  */\n                if (i == decomposed_count)\n                  break;\n                uc = decomposed[i];\n                ccc = uc_combining_class (uc);\n              }\n            else\n              {\n                /* End of string reached.  */\n                uc = 0;\n                ccc = 0;\n              }\n\n            if (ccc == 0)\n              {\n                size_t j;\n\n                /* Apply the canonical ordering algorithm to the accumulated\n                   sequence of characters.  */\n                if (sortbuf_count > 1)\n                  gl_uninorm_decompose_merge_sort_inplace (sortbuf, sortbuf_count,\n                                                           sortbuf + sortbuf_count);\n\n                if (composer != NULL)\n                  {\n                    /* Attempt to combine decomposed characters, as specified\n                       in the Unicode Standard Annex #15 \"Unicode Normalization\n                       Forms\".  We need to check\n                         1. whether the first accumulated character is a\n                            \"starter\" (i.e. has ccc = 0).  This is usually the\n                            case.  But when the string starts with a\n                            non-starter, the sortbuf also starts with a\n                            non-starter.  Btw, this check could also be\n                            omitted, because the composition table has only\n                            entries (code1, code2) for which code1 is a\n                            starter; if the first accumulated character is not\n                            a starter, no lookup will succeed.\n                         2. If the sortbuf has more than one character, check\n                            for each of these characters that are not \"blocked\"\n                            from the starter (i.e. have a ccc that is higher\n                            than the ccc of the previous character) whether it\n                            can be combined with the first character.\n                         3. If only one character is left in sortbuf, check\n                            whether it can be combined with the next character\n                            (also a starter).  */\n                    if (sortbuf_count > 0 && sortbuf[0].ccc == 0)\n                      {\n                        for (j = 1; j < sortbuf_count; )\n                          {\n                            if (sortbuf[j].ccc > sortbuf[j - 1].ccc)\n                              {\n                                ucs4_t combined =\n                                  composer (sortbuf[0].code, sortbuf[j].code);\n                                if (combined)\n                                  {\n                                    size_t k;\n\n                                    sortbuf[0].code = combined;\n                                    /* sortbuf[0].ccc = 0, still valid.  */\n                                    for (k = j + 1; k < sortbuf_count; k++)\n                                      sortbuf[k - 1] = sortbuf[k];\n                                    sortbuf_count--;\n                                    continue;\n                                  }\n                              }\n                            j++;\n                          }\n                        if (s < s_end && sortbuf_count == 1)\n                          {\n                            ucs4_t combined =\n                              composer (sortbuf[0].code, uc);\n                            if (combined)\n                              {\n                                uc = combined;\n                                ccc = 0;\n                                /* uc could be further combined with subsequent\n                                   characters.  So don't put it into sortbuf[0] in\n                                   this round, only in the next round.  */\n                                sortbuf_count = 0;\n                              }\n                          }\n                      }\n                  }\n\n                for (j = 0; j < sortbuf_count; j++)\n                  {\n                    ucs4_t muc = sortbuf[j].code;\n\n                    /* Append muc to the result accumulator.  */\n                    if (length < allocated)\n                      {\n                        int ret =\n                          U_UCTOMB (result + length, muc, allocated - length);\n                        if (ret == -1)\n                          {\n                            errno = EINVAL;\n                            goto fail;\n                          }\n                        if (ret >= 0)\n                          {\n                            length += ret;\n                            goto done_appending;\n                          }\n                      }\n                    {\n                      size_t old_allocated = allocated;\n                      size_t new_allocated = 2 * old_allocated;\n                      if (new_allocated < 64)\n                        new_allocated = 64;\n                      if (new_allocated < old_allocated) /* integer overflow? */\n                        abort ();\n                      {\n                        UNIT *larger_result;\n                        if (result == NULL)\n                          {\n                            larger_result =\n                              (UNIT *) malloc (new_allocated * sizeof (UNIT));\n                            if (larger_result == NULL)\n                              {\n                                errno = ENOMEM;\n                                goto fail;\n                              }\n                          }\n                        else if (result == resultbuf)\n                          {\n                            larger_result =\n                              (UNIT *) malloc (new_allocated * sizeof (UNIT));\n                            if (larger_result == NULL)\n                              {\n                                errno = ENOMEM;\n                                goto fail;\n                              }\n                            U_CPY (larger_result, resultbuf, length);\n                          }\n                        else\n                          {\n                            larger_result =\n                              (UNIT *) realloc (result, new_allocated * sizeof (UNIT));\n                            if (larger_result == NULL)\n                              {\n                                errno = ENOMEM;\n                                goto fail;\n                              }\n                          }\n                        result = larger_result;\n                        allocated = new_allocated;\n                        {\n                          int ret =\n                            U_UCTOMB (result + length, muc, allocated - length);\n                          if (ret == -1)\n                            {\n                              errno = EINVAL;\n                              goto fail;\n                            }\n                          if (ret < 0)\n                            abort ();\n                          length += ret;\n                          goto done_appending;\n                        }\n                      }\n                    }\n                   done_appending: ;\n                  }\n\n                /* sortbuf is now empty.  */\n                sortbuf_count = 0;\n              }\n\n            if (!(s < s_end))\n              /* End of string reached.  */\n              break;\n\n            /* Append (uc, ccc) to sortbuf.  */\n            if (sortbuf_count == sortbuf_allocated)\n              {\n                struct ucs4_with_ccc *new_sortbuf;\n\n                sortbuf_allocated = 2 * sortbuf_allocated;\n                if (sortbuf_allocated < sortbuf_count) /* integer overflow? */\n                  abort ();\n                new_sortbuf =\n                  (struct ucs4_with_ccc *) malloc (2 * sortbuf_allocated * sizeof (struct ucs4_with_ccc));\n                if (new_sortbuf == NULL)\n                  {\n                    errno = ENOMEM;\n                    goto fail;\n                  }\n                memcpy (new_sortbuf, sortbuf,\n                        sortbuf_count * sizeof (struct ucs4_with_ccc));\n                if (sortbuf != sortbuf_preallocated)\n                  free (sortbuf);\n                sortbuf = new_sortbuf;\n              }\n            sortbuf[sortbuf_count].code = uc;\n            sortbuf[sortbuf_count].ccc = ccc;\n            sortbuf_count++;\n\n            i++;\n          }\n\n        if (!(s < s_end))\n          /* End of string reached.  */\n          break;\n\n        s += count;\n      }\n  }\n\n  if (length == 0)\n    {\n      if (result == NULL)\n        {\n          /* Return a non-NULL value.  NULL means error.  */\n          result = (UNIT *) malloc (1);\n          if (result == NULL)\n            {\n              errno = ENOMEM;\n              goto fail;\n            }\n        }\n    }\n  else if (result != resultbuf && length < allocated)\n    {\n      /* Shrink the allocated memory if possible.  */\n      UNIT *memory;\n\n      memory = (UNIT *) realloc (result, length * sizeof (UNIT));\n      if (memory != NULL)\n        result = memory;\n    }\n\n  if (sortbuf_count > 0)\n    abort ();\n  if (sortbuf != sortbuf_preallocated)\n    free (sortbuf);\n\n  *lengthp = length;\n  return result;\n\n fail:\n  {\n    int saved_errno = errno;\n    if (sortbuf != sortbuf_preallocated)\n      free (sortbuf);\n    if (result != resultbuf)\n      free (result);\n    errno = saved_errno;\n  }\n  return NULL;\n}",
      "lines": 363,
      "depth": 25,
      "decorators": [
        "UNIT",
        "*\nFUNC (uninorm_t nf, const UNIT *s, size_t n,\n      UNIT *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/uninorm/u32-normalize.c": {},
  "libidn/libidn2-2.0.5/unistring/unistr/u-cpy-alloc.h": {
    "FUNC": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "UNIT *\nFUNC (const UNIT *s, size_t n)\n{\n  UNIT *dest;\n\n  dest = (UNIT *) malloc (n > 0 ? n * sizeof (UNIT) : 1);\n  if (dest != NULL)\n    {\n#if 0\n      UNIT *destptr = dest;\n\n      for (; n > 0; n--)\n        *destptr++ = *s++;\n#else\n      memcpy ((char *) dest, (const char *) s, n * sizeof (UNIT));\n#endif\n    }\n  return dest;\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "UNIT",
        "*\nFUNC (const UNIT *s, size_t n)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/unistr/u-cpy.h": {
    "FUNC": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "UNIT *\nFUNC (UNIT *dest, const UNIT *src, size_t n)\n{\n#if 0\n  UNIT *destptr = dest;\n\n  for (; n > 0; n--)\n    *destptr++ = *src++;\n#else\n  memcpy ((char *) dest, (const char *) src, n * sizeof (UNIT));\n#endif\n  return dest;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "UNIT",
        "*\nFUNC (UNIT *dest, const UNIT *src, size_t n)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/unistr/u-strlen.h": {
    "FUNC": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "size_t\nFUNC (const UNIT *s)\n{\n  const UNIT *ptr;\n\n  for (ptr = s; *ptr != 0; ptr++)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/unistr/u32-cpy-alloc.c": {},
  "libidn/libidn2-2.0.5/unistring/unistr/u32-cpy.c": {},
  "libidn/libidn2-2.0.5/unistring/unistr/u32-mbtouc-unsafe.c": {
    "u32_mbtouc_unsafe": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "int\nu32_mbtouc_unsafe (ucs4_t *puc, const uint32_t *s, size_t n)\n{\n  uint32_t c = *s;\n\n  if (c < 0xd800 || (c >= 0xe000 && c < 0x110000))\n    *puc = c;\n  else\n    /* invalid multibyte character */\n    *puc = 0xfffd;\n  return 1;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/unistr/u32-strlen.c": {},
  "libidn/libidn2-2.0.5/unistring/unistr/u32-to-u8.c": {
    "FUNC": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "DST_UNIT *\nFUNC (const SRC_UNIT *s, size_t n, DST_UNIT *resultbuf, size_t *lengthp)\n{\n  const SRC_UNIT *s_end = s + n;\n  /* Output string accumulator.  */\n  DST_UNIT *result;\n  size_t allocated;\n  size_t length;\n\n  if (resultbuf != NULL)\n    {\n      result = resultbuf;\n      allocated = *lengthp;\n    }\n  else\n    {\n      result = NULL;\n      allocated = 0;\n    }\n  length = 0;\n  /* Invariants:\n     result is either == resultbuf or == NULL or malloc-allocated.\n     If length > 0, then result != NULL.  */\n\n  while (s < s_end)\n    {\n      ucs4_t uc;\n      int count;\n\n      /* Fetch a Unicode character from the input string.  */\n      uc = *s++;\n      /* No need to call the safe variant u32_mbtouc, because\n         u8_uctomb will verify uc anyway.  */\n\n      /* Store it in the output string.  */\n      count = u8_uctomb (result + length, uc, allocated - length);\n      if (count == -1)\n        {\n          if (!(result == resultbuf || result == NULL))\n            free (result);\n          errno = EILSEQ;\n          return NULL;\n        }\n      if (count == -2)\n        {\n          DST_UNIT *memory;\n\n          allocated = (allocated > 0 ? 2 * allocated : 12);\n          if (length + 6 > allocated)\n            allocated = length + 6;\n          if (result == resultbuf || result == NULL)\n            memory = (DST_UNIT *) malloc (allocated * sizeof (DST_UNIT));\n          else\n            memory =\n              (DST_UNIT *) realloc (result, allocated * sizeof (DST_UNIT));\n\n          if (memory == NULL)\n            {\n              if (!(result == resultbuf || result == NULL))\n                free (result);\n              errno = ENOMEM;\n              return NULL;\n            }\n          if (result == resultbuf && length > 0)\n            memcpy ((char *) memory, (char *) result,\n                    length * sizeof (DST_UNIT));\n          result = memory;\n          count = u8_uctomb (result + length, uc, allocated - length);\n          if (count < 0)\n            abort ();\n        }\n      length += count;\n    }\n\n  if (length == 0)\n    {\n      if (result == NULL)\n        {\n          /* Return a non-NULL value.  NULL means error.  */\n          result = (DST_UNIT *) malloc (1);\n          if (result == NULL)\n            {\n              errno = ENOMEM;\n              return NULL;\n            }\n        }\n    }\n  else if (result != resultbuf && length < allocated)\n    {\n      /* Shrink the allocated memory if possible.  */\n      DST_UNIT *memory;\n\n      memory = (DST_UNIT *) realloc (result, length * sizeof (DST_UNIT));\n      if (memory != NULL)\n        result = memory;\n    }\n\n  *lengthp = length;\n  return result;\n}",
      "lines": 100,
      "depth": 16,
      "decorators": [
        "DST_UNIT",
        "*\nFUNC (const SRC_UNIT *s, size_t n, DST_UNIT *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/unistr/u32-uctomb.c": {
    "u32_uctomb": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\nu32_uctomb (uint32_t *s, ucs4_t uc, int n)\n{\n  if (uc < 0xd800 || (uc >= 0xe000 && uc < 0x110000))\n    {\n      if (n > 0)\n        {\n          *s = uc;\n          return 1;\n        }\n      else\n        return -2;\n    }\n  else\n    return -1;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/unistr/u8-check.c": {
    "u8_check": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "const uint8_t *\nu8_check (const uint8_t *s, size_t n)\n{\n  const uint8_t *s_end = s + n;\n\n  while (s < s_end)\n    {\n      /* Keep in sync with unistr.h and u8-mbtouc-aux.c.  */\n      uint8_t c = *s;\n\n      if (c < 0x80)\n        {\n          s++;\n          continue;\n        }\n      if (c >= 0xc2)\n        {\n          if (c < 0xe0)\n            {\n              if (s + 2 <= s_end\n                  && (s[1] ^ 0x80) < 0x40)\n                {\n                  s += 2;\n                  continue;\n                }\n            }\n          else if (c < 0xf0)\n            {\n              if (s + 3 <= s_end\n                  && (s[1] ^ 0x80) < 0x40 && (s[2] ^ 0x80) < 0x40\n                  && (c >= 0xe1 || s[1] >= 0xa0)\n                  && (c != 0xed || s[1] < 0xa0))\n                {\n                  s += 3;\n                  continue;\n                }\n            }\n          else if (c < 0xf8)\n            {\n              if (s + 4 <= s_end\n                  && (s[1] ^ 0x80) < 0x40 && (s[2] ^ 0x80) < 0x40\n                  && (s[3] ^ 0x80) < 0x40\n                  && (c >= 0xf1 || s[1] >= 0x90)\n                  && (c < 0xf4 || (c == 0xf4 && s[1] < 0x90)))\n                {\n                  s += 4;\n                  continue;\n                }\n            }\n        }\n      /* invalid or incomplete multibyte character */\n      return s;\n    }\n  return NULL;\n}",
      "lines": 55,
      "depth": 22,
      "decorators": [
        "const",
        "const",
        "uint8_t",
        "*\nu8_check (const uint8_t *s, size_t n)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/unistr/u8-mblen.c": {
    "u8_mblen": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nu8_mblen (const uint8_t *s, size_t n)\n{\n  if (n > 0)\n    {\n      /* Keep in sync with unistr.h and u8-mbtouc-aux.c.  */\n      uint8_t c = *s;\n\n      if (c < 0x80)\n        return (c != 0 ? 1 : 0);\n      if (c >= 0xc2)\n        {\n          if (c < 0xe0)\n            {\n              if (n >= 2\n                  && (s[1] ^ 0x80) < 0x40)\n                return 2;\n            }\n          else if (c < 0xf0)\n            {\n              if (n >= 3\n                  && (s[1] ^ 0x80) < 0x40 && (s[2] ^ 0x80) < 0x40\n                  && (c >= 0xe1 || s[1] >= 0xa0)\n                  && (c != 0xed || s[1] < 0xa0))\n                return 3;\n            }\n          else if (c < 0xf8)\n            {\n              if (n >= 4\n                  && (s[1] ^ 0x80) < 0x40 && (s[2] ^ 0x80) < 0x40\n                  && (s[3] ^ 0x80) < 0x40\n                  && (c >= 0xf1 || s[1] >= 0x90)\n                  && (c < 0xf4 || (c == 0xf4 && s[1] < 0x90)))\n                return 4;\n            }\n        }\n    }\n  /* invalid or incomplete multibyte character */\n  return -1;\n}",
      "lines": 40,
      "depth": 22,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/unistr/u8-mbtouc-aux.c": {
    "u8_mbtouc_aux": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "int\nu8_mbtouc_aux (ucs4_t *puc, const uint8_t *s, size_t n)\n{\n  uint8_t c = *s;\n\n  if (c >= 0xc2)\n    {\n      if (c < 0xe0)\n        {\n          if (n >= 2)\n            {\n              if ((s[1] ^ 0x80) < 0x40)\n                {\n                  *puc = ((unsigned int) (c & 0x1f) << 6)\n                         | (unsigned int) (s[1] ^ 0x80);\n                  return 2;\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              return 1;\n            }\n        }\n      else if (c < 0xf0)\n        {\n          if (n >= 3)\n            {\n              if ((s[1] ^ 0x80) < 0x40)\n                {\n                  if ((s[2] ^ 0x80) < 0x40)\n                    {\n                      if ((c >= 0xe1 || s[1] >= 0xa0)\n                          && (c != 0xed || s[1] < 0xa0))\n                        {\n                          *puc = ((unsigned int) (c & 0x0f) << 12)\n                                 | ((unsigned int) (s[1] ^ 0x80) << 6)\n                                 | (unsigned int) (s[2] ^ 0x80);\n                          return 3;\n                        }\n                      /* invalid multibyte character */\n                      *puc = 0xfffd;\n                      return 3;\n                    }\n                  /* invalid multibyte character */\n                  *puc = 0xfffd;\n                  return 2;\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              if (n == 1 || (s[1] ^ 0x80) >= 0x40)\n                return 1;\n              else\n                return 2;\n            }\n        }\n      else if (c < 0xf8)\n        {\n          if (n >= 4)\n            {\n              if ((s[1] ^ 0x80) < 0x40)\n                {\n                  if ((s[2] ^ 0x80) < 0x40)\n                    {\n                      if ((s[3] ^ 0x80) < 0x40)\n                        {\n                          if ((c >= 0xf1 || s[1] >= 0x90)\n                              && (c < 0xf4 || (c == 0xf4 && s[1] < 0x90)))\n                            {\n                              *puc = ((unsigned int) (c & 0x07) << 18)\n                                     | ((unsigned int) (s[1] ^ 0x80) << 12)\n                                     | ((unsigned int) (s[2] ^ 0x80) << 6)\n                                     | (unsigned int) (s[3] ^ 0x80);\n                              return 4;\n                            }\n                          /* invalid multibyte character */\n                          *puc = 0xfffd;\n                          return 4;\n                        }\n                      /* invalid multibyte character */\n                      *puc = 0xfffd;\n                      return 3;\n                    }\n                  /* invalid multibyte character */\n                  *puc = 0xfffd;\n                  return 2;\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              if (n == 1 || (s[1] ^ 0x80) >= 0x40)\n                return 1;\n              else if (n == 2 || (s[2] ^ 0x80) >= 0x40)\n                return 2;\n              else\n                return 3;\n            }\n        }\n    }\n  /* invalid multibyte character */\n  *puc = 0xfffd;\n  return 1;\n}",
      "lines": 112,
      "depth": 30,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/unistr/u8-mbtouc-unsafe-aux.c": {
    "u8_mbtouc_unsafe_aux": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "int\nu8_mbtouc_unsafe_aux (ucs4_t *puc, const uint8_t *s, size_t n)\n{\n  uint8_t c = *s;\n\n  if (c >= 0xc2)\n    {\n      if (c < 0xe0)\n        {\n          if (n >= 2)\n            {\n              if ((s[1] ^ 0x80) < 0x40)\n                {\n                  *puc = ((unsigned int) (c & 0x1f) << 6)\n                         | (unsigned int) (s[1] ^ 0x80);\n                  return 2;\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              return 1;\n            }\n        }\n      else if (c < 0xf0)\n        {\n          if (n >= 3)\n            {\n              if ((s[1] ^ 0x80) < 0x40)\n                {\n                  if ((s[2] ^ 0x80) < 0x40)\n                    {\n                      if ((c >= 0xe1 || s[1] >= 0xa0)\n                          && (c != 0xed || s[1] < 0xa0))\n                        {\n                          *puc = ((unsigned int) (c & 0x0f) << 12)\n                                 | ((unsigned int) (s[1] ^ 0x80) << 6)\n                                 | (unsigned int) (s[2] ^ 0x80);\n                          return 3;\n                        }\n                      /* invalid multibyte character */\n                      *puc = 0xfffd;\n                      return 3;\n                    }\n                  /* invalid multibyte character */\n                  *puc = 0xfffd;\n                  return 2;\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              if (n == 1 || (s[1] ^ 0x80) >= 0x40)\n                return 1;\n              else\n                return 2;\n            }\n        }\n      else if (c < 0xf8)\n        {\n          if (n >= 4)\n            {\n              if ((s[1] ^ 0x80) < 0x40)\n                {\n                  if ((s[2] ^ 0x80) < 0x40)\n                    {\n                      if ((s[3] ^ 0x80) < 0x40)\n                        {\n                          if ((c >= 0xf1 || s[1] >= 0x90)\n                              && (c < 0xf4 || (c == 0xf4 && s[1] < 0x90))\n                             )\n                            {\n                              *puc = ((unsigned int) (c & 0x07) << 18)\n                                     | ((unsigned int) (s[1] ^ 0x80) << 12)\n                                     | ((unsigned int) (s[2] ^ 0x80) << 6)\n                                     | (unsigned int) (s[3] ^ 0x80);\n                              return 4;\n                            }\n                          /* invalid multibyte character */\n                          *puc = 0xfffd;\n                          return 4;\n                        }\n                      /* invalid multibyte character */\n                      *puc = 0xfffd;\n                      return 3;\n                    }\n                  /* invalid multibyte character */\n                  *puc = 0xfffd;\n                  return 2;\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              if (n == 1 || (s[1] ^ 0x80) >= 0x40)\n                return 1;\n              else if (n == 2 || (s[2] ^ 0x80) >= 0x40)\n                return 2;\n              else\n                return 3;\n            }\n        }\n    }\n  /* invalid multibyte character */\n  *puc = 0xfffd;\n  return 1;\n}",
      "lines": 113,
      "depth": 30,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/unistr/u8-mbtouc-unsafe.c": {
    "u8_mbtouc_unsafe": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "int\nu8_mbtouc_unsafe (ucs4_t *puc, const uint8_t *s, size_t n)\n{\n  uint8_t c = *s;\n\n  if (c < 0x80)\n    {\n      *puc = c;\n      return 1;\n    }\n  else if (c >= 0xc2)\n    {\n      if (c < 0xe0)\n        {\n          if (n >= 2)\n            {\n              if ((s[1] ^ 0x80) < 0x40)\n                {\n                  *puc = ((unsigned int) (c & 0x1f) << 6)\n                         | (unsigned int) (s[1] ^ 0x80);\n                  return 2;\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              return 1;\n            }\n        }\n      else if (c < 0xf0)\n        {\n          if (n >= 3)\n            {\n              if ((s[1] ^ 0x80) < 0x40)\n                {\n                  if ((s[2] ^ 0x80) < 0x40)\n                    {\n                      if ((c >= 0xe1 || s[1] >= 0xa0)\n                          && (c != 0xed || s[1] < 0xa0))\n                        {\n                          *puc = ((unsigned int) (c & 0x0f) << 12)\n                                 | ((unsigned int) (s[1] ^ 0x80) << 6)\n                                 | (unsigned int) (s[2] ^ 0x80);\n                          return 3;\n                        }\n                      /* invalid multibyte character */\n                      *puc = 0xfffd;\n                      return 3;\n                    }\n                  /* invalid multibyte character */\n                  *puc = 0xfffd;\n                  return 2;\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              if (n == 1 || (s[1] ^ 0x80) >= 0x40)\n                return 1;\n              else\n                return 2;\n            }\n        }\n      else if (c < 0xf8)\n        {\n          if (n >= 4)\n            {\n              if ((s[1] ^ 0x80) < 0x40)\n                {\n                  if ((s[2] ^ 0x80) < 0x40)\n                    {\n                      if ((s[3] ^ 0x80) < 0x40)\n                        {\n                          if ((c >= 0xf1 || s[1] >= 0x90)\n                              && (c < 0xf4 || (c == 0xf4 && s[1] < 0x90))\n                             )\n                            {\n                              *puc = ((unsigned int) (c & 0x07) << 18)\n                                     | ((unsigned int) (s[1] ^ 0x80) << 12)\n                                     | ((unsigned int) (s[2] ^ 0x80) << 6)\n                                     | (unsigned int) (s[3] ^ 0x80);\n                              return 4;\n                            }\n                          /* invalid multibyte character */\n                          *puc = 0xfffd;\n                          return 4;\n                        }\n                      /* invalid multibyte character */\n                      *puc = 0xfffd;\n                      return 3;\n                    }\n                  /* invalid multibyte character */\n                  *puc = 0xfffd;\n                  return 2;\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              if (n == 1 || (s[1] ^ 0x80) >= 0x40)\n                return 1;\n              else if (n == 2 || (s[2] ^ 0x80) >= 0x40)\n                return 2;\n              else\n                return 3;\n            }\n        }\n    }\n  /* invalid multibyte character */\n  *puc = 0xfffd;\n  return 1;\n}",
      "lines": 118,
      "depth": 31,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/unistr/u8-mbtouc.c": {
    "u8_mbtouc": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "int\nu8_mbtouc (ucs4_t *puc, const uint8_t *s, size_t n)\n{\n  uint8_t c = *s;\n\n  if (c < 0x80)\n    {\n      *puc = c;\n      return 1;\n    }\n  else if (c >= 0xc2)\n    {\n      if (c < 0xe0)\n        {\n          if (n >= 2)\n            {\n              if ((s[1] ^ 0x80) < 0x40)\n                {\n                  *puc = ((unsigned int) (c & 0x1f) << 6)\n                         | (unsigned int) (s[1] ^ 0x80);\n                  return 2;\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              return 1;\n            }\n        }\n      else if (c < 0xf0)\n        {\n          if (n >= 3)\n            {\n              if ((s[1] ^ 0x80) < 0x40)\n                {\n                  if ((s[2] ^ 0x80) < 0x40)\n                    {\n                      if ((c >= 0xe1 || s[1] >= 0xa0)\n                          && (c != 0xed || s[1] < 0xa0))\n                        {\n                          *puc = ((unsigned int) (c & 0x0f) << 12)\n                                 | ((unsigned int) (s[1] ^ 0x80) << 6)\n                                 | (unsigned int) (s[2] ^ 0x80);\n                          return 3;\n                        }\n                      /* invalid multibyte character */\n                      *puc = 0xfffd;\n                      return 3;\n                    }\n                  /* invalid multibyte character */\n                  *puc = 0xfffd;\n                  return 2;\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              if (n == 1 || (s[1] ^ 0x80) >= 0x40)\n                return 1;\n              else\n                return 2;\n            }\n        }\n      else if (c < 0xf8)\n        {\n          if (n >= 4)\n            {\n              if ((s[1] ^ 0x80) < 0x40)\n                {\n                  if ((s[2] ^ 0x80) < 0x40)\n                    {\n                      if ((s[3] ^ 0x80) < 0x40)\n                        {\n                          if ((c >= 0xf1 || s[1] >= 0x90)\n                              && (c < 0xf4 || (c == 0xf4 && s[1] < 0x90)))\n                            {\n                              *puc = ((unsigned int) (c & 0x07) << 18)\n                                     | ((unsigned int) (s[1] ^ 0x80) << 12)\n                                     | ((unsigned int) (s[2] ^ 0x80) << 6)\n                                     | (unsigned int) (s[3] ^ 0x80);\n                              return 4;\n                            }\n                          /* invalid multibyte character */\n                          *puc = 0xfffd;\n                          return 4;\n                        }\n                      /* invalid multibyte character */\n                      *puc = 0xfffd;\n                      return 3;\n                    }\n                  /* invalid multibyte character */\n                  *puc = 0xfffd;\n                  return 2;\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              if (n == 1 || (s[1] ^ 0x80) >= 0x40)\n                return 1;\n              else if (n == 2 || (s[2] ^ 0x80) >= 0x40)\n                return 2;\n              else\n                return 3;\n            }\n        }\n    }\n  /* invalid multibyte character */\n  *puc = 0xfffd;\n  return 1;\n}",
      "lines": 117,
      "depth": 31,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/unistr/u8-mbtoucr.c": {
    "u8_mbtoucr": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "int\nu8_mbtoucr (ucs4_t *puc, const uint8_t *s, size_t n)\n{\n  uint8_t c = *s;\n\n  if (c < 0x80)\n    {\n      *puc = c;\n      return 1;\n    }\n  else if (c >= 0xc2)\n    {\n      if (c < 0xe0)\n        {\n          if (n >= 2)\n            {\n              if ((s[1] ^ 0x80) < 0x40)\n                {\n                  *puc = ((unsigned int) (c & 0x1f) << 6)\n                         | (unsigned int) (s[1] ^ 0x80);\n                  return 2;\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              return -2;\n            }\n        }\n      else if (c < 0xf0)\n        {\n          if (n >= 2)\n            {\n              if ((s[1] ^ 0x80) < 0x40\n                  && (c >= 0xe1 || s[1] >= 0xa0)\n                  && (c != 0xed || s[1] < 0xa0))\n                {\n                  if (n >= 3)\n                    {\n                      if ((s[2] ^ 0x80) < 0x40)\n                        {\n                          *puc = ((unsigned int) (c & 0x0f) << 12)\n                                 | ((unsigned int) (s[1] ^ 0x80) << 6)\n                                 | (unsigned int) (s[2] ^ 0x80);\n                          return 3;\n                        }\n                      /* invalid multibyte character */\n                    }\n                  else\n                    {\n                      /* incomplete multibyte character */\n                      *puc = 0xfffd;\n                      return -2;\n                    }\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              return -2;\n            }\n        }\n      else if (c < 0xf8)\n        {\n          if (n >= 2)\n            {\n              if ((s[1] ^ 0x80) < 0x40\n                  && (c >= 0xf1 || s[1] >= 0x90)\n                  && (c < 0xf4 || (c == 0xf4 && s[1] < 0x90)))\n                {\n                  if (n >= 3)\n                    {\n                      if ((s[2] ^ 0x80) < 0x40)\n                        {\n                          if (n >= 4)\n                            {\n                              if ((s[3] ^ 0x80) < 0x40)\n                                {\n                                  *puc = ((unsigned int) (c & 0x07) << 18)\n                                         | ((unsigned int) (s[1] ^ 0x80) << 12)\n                                         | ((unsigned int) (s[2] ^ 0x80) << 6)\n                                         | (unsigned int) (s[3] ^ 0x80);\n                                  return 4;\n                                }\n                              /* invalid multibyte character */\n                            }\n                          else\n                            {\n                              /* incomplete multibyte character */\n                              *puc = 0xfffd;\n                              return -2;\n                            }\n                        }\n                      /* invalid multibyte character */\n                    }\n                  else\n                    {\n                      /* incomplete multibyte character */\n                      *puc = 0xfffd;\n                      return -2;\n                    }\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              return -2;\n            }\n        }\n    }\n  /* invalid multibyte character */\n  *puc = 0xfffd;\n  return -1;\n}",
      "lines": 120,
      "depth": 33,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/unistr/u8-prev.c": {
    "u8_prev": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "const uint8_t *\nu8_prev (ucs4_t *puc, const uint8_t *s, const uint8_t *start)\n{\n  /* Keep in sync with unistr.h and u8-mbtouc-aux.c.  */\n  if (s != start)\n    {\n      uint8_t c_1 = s[-1];\n\n      if (c_1 < 0x80)\n        {\n          *puc = c_1;\n          return s - 1;\n        }\n      if ((c_1 ^ 0x80) < 0x40)\n        if (s - 1 != start)\n          {\n            uint8_t c_2 = s[-2];\n\n            if (c_2 >= 0xc2 && c_2 < 0xe0)\n              {\n                *puc = ((unsigned int) (c_2 & 0x1f) << 6)\n                       | (unsigned int) (c_1 ^ 0x80);\n                return s - 2;\n              }\n            if ((c_2 ^ 0x80) < 0x40)\n              if (s - 2 != start)\n                {\n                  uint8_t c_3 = s[-3];\n\n                  if (c_3 >= 0xe0 && c_3 < 0xf0\n                      && (c_3 >= 0xe1 || c_2 >= 0xa0)\n                      && (c_3 != 0xed || c_2 < 0xa0))\n                    {\n                      *puc = ((unsigned int) (c_3 & 0x0f) << 12)\n                             | ((unsigned int) (c_2 ^ 0x80) << 6)\n                             | (unsigned int) (c_1 ^ 0x80);\n                      return s - 3;\n                    }\n                  if ((c_3 ^ 0x80) < 0x40)\n                    if (s - 3 != start)\n                      {\n                        uint8_t c_4 = s[-4];\n\n                        if (c_4 >= 0xf0 && c_4 < 0xf8\n                            && (c_4 >= 0xf1 || c_3 >= 0x90)\n                            && (c_4 < 0xf4 || (c_4 == 0xf4 && c_3 < 0x90)))\n                          {\n                            *puc = ((unsigned int) (c_4 & 0x07) << 18)\n                                   | ((unsigned int) (c_3 ^ 0x80) << 12)\n                                   | ((unsigned int) (c_2 ^ 0x80) << 6)\n                                   | (unsigned int) (c_1 ^ 0x80);\n                            return s - 4;\n                          }\n                      }\n                }\n          }\n    }\n  return NULL;\n}",
      "lines": 59,
      "depth": 26,
      "decorators": [
        "const",
        "const",
        "uint8_t",
        "*\nu8_prev (ucs4_t *puc, const uint8_t *s, const uint8_t *start)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/unistr/u8-strlen.c": {
    "u8_strlen": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "size_t\nu8_strlen (const uint8_t *s)\n{\n  return strlen ((const char *) s);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "size_t"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/unistr/u8-to-u32.c": {
    "FUNC": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "DST_UNIT *\nFUNC (const SRC_UNIT *s, size_t n, DST_UNIT *resultbuf, size_t *lengthp)\n{\n  const SRC_UNIT *s_end = s + n;\n  /* Output string accumulator.  */\n  DST_UNIT *result;\n  size_t allocated;\n  size_t length;\n\n  if (resultbuf != NULL)\n    {\n      result = resultbuf;\n      allocated = *lengthp;\n    }\n  else\n    {\n      result = NULL;\n      allocated = 0;\n    }\n  length = 0;\n  /* Invariants:\n     result is either == resultbuf or == NULL or malloc-allocated.\n     If length > 0, then result != NULL.  */\n\n  while (s < s_end)\n    {\n      ucs4_t uc;\n      int count;\n\n      /* Fetch a Unicode character from the input string.  */\n      count = u8_mbtoucr (&uc, s, s_end - s);\n      if (count < 0)\n        {\n          if (!(result == resultbuf || result == NULL))\n            free (result);\n          errno = EILSEQ;\n          return NULL;\n        }\n      s += count;\n\n      /* Store it in the output string.  */\n      if (length + 1 > allocated)\n        {\n          DST_UNIT *memory;\n\n          allocated = (allocated > 0 ? 2 * allocated : 12);\n          if (length + 1 > allocated)\n            allocated = length + 1;\n          if (result == resultbuf || result == NULL)\n            memory = (DST_UNIT *) malloc (allocated * sizeof (DST_UNIT));\n          else\n            memory =\n              (DST_UNIT *) realloc (result, allocated * sizeof (DST_UNIT));\n\n          if (memory == NULL)\n            {\n              if (!(result == resultbuf || result == NULL))\n                free (result);\n              errno = ENOMEM;\n              return NULL;\n            }\n          if (result == resultbuf && length > 0)\n            memcpy ((char *) memory, (char *) result,\n                    length * sizeof (DST_UNIT));\n          result = memory;\n        }\n      result[length++] = uc;\n    }\n\n  if (length == 0)\n    {\n      if (result == NULL)\n        {\n          /* Return a non-NULL value.  NULL means error.  */\n          result = (DST_UNIT *) malloc (1);\n          if (result == NULL)\n            {\n              errno = ENOMEM;\n              return NULL;\n            }\n        }\n    }\n  else if (result != resultbuf && length < allocated)\n    {\n      /* Shrink the allocated memory if possible.  */\n      DST_UNIT *memory;\n\n      memory = (DST_UNIT *) realloc (result, length * sizeof (DST_UNIT));\n      if (memory != NULL)\n        result = memory;\n    }\n\n  *lengthp = length;\n  return result;\n}",
      "lines": 95,
      "depth": 16,
      "decorators": [
        "DST_UNIT",
        "*\nFUNC (const SRC_UNIT *s, size_t n, DST_UNIT *resultbuf, size_t *lengthp)",
        "*"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/unistr/u8-uctomb-aux.c": {
    "u8_uctomb_aux": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "int\nu8_uctomb_aux (uint8_t *s, ucs4_t uc, int n)\n{\n  int count;\n\n  if (uc < 0x80)\n    /* The case n >= 1 is already handled by the caller.  */\n    return -2;\n  else if (uc < 0x800)\n    count = 2;\n  else if (uc < 0x10000)\n    {\n      if (uc < 0xd800 || uc >= 0xe000)\n        count = 3;\n      else\n        return -1;\n    }\n  else if (uc < 0x110000)\n    count = 4;\n  else\n    return -1;\n\n  if (n < count)\n    return -2;\n\n  switch (count) /* note: code falls through cases! */\n    {\n    case 4: s[3] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0x10000;\n      FALLTHROUGH;\n    case 3: s[2] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0x800;\n      FALLTHROUGH;\n    case 2: s[1] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0xc0;\n  /*case 1:*/ s[0] = uc;\n    }\n  return count;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libidn/libidn2-2.0.5/unistring/unistr/u8-uctomb.c": {
    "u8_uctomb": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "int\nu8_uctomb (uint8_t *s, ucs4_t uc, int n)\n{\n  if (uc < 0x80)\n    {\n      if (n > 0)\n        {\n          s[0] = uc;\n          return 1;\n        }\n      /* else return -2, below.  */\n    }\n  else\n    {\n      int count;\n\n      if (uc < 0x800)\n        count = 2;\n      else if (uc < 0x10000)\n        {\n          if (uc < 0xd800 || uc >= 0xe000)\n            count = 3;\n          else\n            return -1;\n        }\n      else if (uc < 0x110000)\n        count = 4;\n      else\n        return -1;\n\n      if (n >= count)\n        {\n          switch (count) /* note: code falls through cases! */\n            {\n            case 4: s[3] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0x10000;\n            case 3: s[2] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0x800;\n            case 2: s[1] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0xc0;\n          /*case 1:*/ s[0] = uc;\n            }\n          return count;\n        }\n    }\n  return -2;\n}",
      "lines": 44,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  }
}