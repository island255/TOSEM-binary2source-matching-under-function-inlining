{
  "texinfo/texinfo-6.5/system.h": {},
  "texinfo/texinfo-6.5/contrib/deref.c": {
    "main": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n\tFILE *fp;\n\n\tMe = argv[0];\n\n\tif (argc == 1)\n\t\tprocess(stdin);\n\telse\n\t\tfor (argc--, argv++; *argv != NULL; argc--, argv++) {\n\t\t\tif (argv[0][0] == '-' && argv[0][1] == '\\0') {\n\t\t\t\tName = \"stdin\";\n\t\t\t\tLine = 0;\n\t\t\t\tprocess(stdin);\n\t\t\t} else if ((fp = fopen(*argv, \"r\")) != NULL) {\n\t\t\t\tName = *argv;\n\t\t\t\tLine = 0;\n\t\t\t\tprocess(fp);\n\t\t\t\tfclose(fp);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"%s: can not open: %s\\n\",\n\t\t\t\t\t*argv, strerror(errno));\n\t\t\t\tErrs++;\n\t\t\t}\n\t\t}\n\treturn Errs != 0;\n}",
      "lines": 28,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "isref": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "int\nisref(char *cp)\n{\n\tif (strncmp(cp, \"@ref{\", 5) == 0)\n\t\treturn 5;\n\tif (strncmp(cp, \"@xref{\", 6) == 0)\n\t\treturn 6;\n\tif (strncmp(cp, \"@pxref{\", 7) == 0)\n\t\treturn 7;\n\treturn 0;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "process": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "void\nprocess(FILE *fp)\n{\n\tchar buf[BUFSIZ];\n\tchar *cp;\n\tint count;\n\n\twhile (fgets(buf, sizeof buf, fp) != NULL) {\n\t\tLine++;\n\t\tcp = strchr(buf, '@');\n\t\tif (cp == NULL) {\n\t\t\tfputs(buf, stdout);\n\t\t\tcontinue;\n\t\t}\n\t\tdo {\n\t\t\tcount = isref(cp);\n\t\t\tif (count == 0) {\n\t\t\t\tcp++;\n\t\t\t\tcp = strchr(cp, '@');\n\t\t\t\tif (cp == NULL) {\n\t\t\t\t\tfputs(buf, stdout);\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* got one */\n\t\t\trepair(buf, cp, count);\n\t\t\tbreak;\n\t\t} while (cp != NULL);\n\tnext: ;\n\t}\n}",
      "lines": 32,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "repair": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "void\nrepair(char *line, char *ref, int toffset)\n{\n\tint braces = 1;\t\t/* have seen first left brace */\n\tchar *cp;\n\n\tref += toffset;\n\n\t/* output line up to and including left brace in reference */\n\tfor (cp = line; cp <= ref; cp++)\n\t\tputchar(*cp);\n\n\t/* output node name */\n\tfor (; *cp && *cp != '}' && *cp != ',' && *cp != '\\n'; cp++)\n\t\tputchar(*cp);\n\n\tif (*cp != '}')\t{\t/* could have been one arg xref */\n\t\t/* skip to matching right brace */\n\t\tfor (; braces > 0; cp++) {\n\t\t\tswitch (*cp) {\n\t\t\tcase '@':\n\t\t\t\tcp++;\t/* blindly skip next character */\n\t\t\t\tbreak;\n\t\t\tcase '{':\n\t\t\t\tbraces++;\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tbraces--;\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\tcase '\\0':\n\t\t\t\tErrs++;\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"%s: %s: %d: mismatched braces\\n\",\n\t\t\t\t\tMe, Name, Line);\n\t\t\t\tgoto out;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tout:\n\t\t;\n\t}\n\n\tputchar('}');\n\tif (*cp == '}')\n\t\tcp++;\n\n\t/* now the rest of the line */\n\tfor (; *cp; cp++)\n\t\tputchar(*cp);\n\treturn;\n}",
      "lines": 53,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "strerror": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "char *\nstrerror(int errno)\n{\n\tstatic char buf[100];\n\textern int sys_nerr;\n\textern char *sys_errlist[];\n\n\tif (errno < sys_nerr && errno >= 0)\n\t\treturn sys_errlist[errno];\n\n\tsprintf(buf, \"unknown error %d\", errno);\n\treturn buf;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "char",
        "*\nstrerror(int errno)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/alloca.in.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/arg-nonnull.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/argz.c": {
    "argz_append": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "error_t\nargz_append (char **argz, size_t *argz_len, const char *buf, size_t buf_len)\n{\n  size_t new_argz_len = *argz_len + buf_len;\n  char *new_argz = realloc (*argz, new_argz_len);\n  if (new_argz)\n    {\n      memcpy (new_argz + *argz_len, buf, buf_len);\n      *argz = new_argz;\n      *argz_len = new_argz_len;\n      return 0;\n    }\n  else\n    return ENOMEM;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "error_t"
      ]
    },
    "argz_add": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "error_t\nargz_add (char **argz, size_t *argz_len, const char *str)\n{\n  return argz_append (argz, argz_len, str, strlen (str) + 1);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "error_t"
      ]
    },
    "argz_add_sep": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "error_t\nargz_add_sep (char **argz, size_t *argz_len, const char *string, int delim)\n{\n  size_t nlen = strlen (string) + 1;\n\n  if (nlen > 1)\n    {\n      const char *rp;\n      char *wp;\n\n      *argz = (char *) realloc (*argz, *argz_len + nlen);\n      if (*argz == NULL)\n        return ENOMEM;\n\n      wp = *argz + *argz_len;\n      rp = string;\n      do\n        if (*rp == delim)\n          {\n            if (wp > *argz && wp[-1] != '\\0')\n              *wp++ = '\\0';\n            else\n              --nlen;\n          }\n        else\n          *wp++ = *rp;\n      while (*rp++ != '\\0');\n\n      *argz_len += nlen;\n    }\n\n  return 0;\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "error_t"
      ]
    },
    "argz_create_sep": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "error_t\nargz_create_sep (const char *string, int delim, char **argz, size_t *len)\n{\n  size_t nlen = strlen (string) + 1;\n\n  if (nlen > 1)\n    {\n      const char *rp;\n      char *wp;\n\n      *argz = (char *) malloc (nlen);\n      if (*argz == NULL)\n        return ENOMEM;\n\n      rp = string;\n      wp = *argz;\n      do\n        if (*rp == delim)\n          {\n            if (wp > *argz && wp[-1] != '\\0')\n              *wp++ = '\\0';\n            else\n              --nlen;\n          }\n        else\n          *wp++ = *rp;\n      while (*rp++ != '\\0');\n\n      if (nlen == 0)\n        {\n          free (*argz);\n          *argz = NULL;\n          *len = 0;\n        }\n\n      *len = nlen;\n    }\n  else\n    {\n      *argz = NULL;\n      *len = 0;\n    }\n\n  return 0;\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "error_t"
      ]
    },
    "argz_insert": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "error_t\nargz_insert (char **argz, size_t *argz_len, char *before, const char *entry)\n{\n  if (! before)\n    return argz_add (argz, argz_len, entry);\n\n  if (before < *argz || before >= *argz + *argz_len)\n    return EINVAL;\n\n  if (before > *argz)\n    /* Make sure before is actually the beginning of an entry.  */\n    while (before[-1])\n      before--;\n\n  {\n    size_t after_before = *argz_len - (before - *argz);\n    size_t entry_len = strlen  (entry) + 1;\n    size_t new_argz_len = *argz_len + entry_len;\n    char *new_argz = realloc (*argz, new_argz_len);\n\n    if (new_argz)\n      {\n        before = new_argz + (before - *argz);\n        memmove (before + entry_len, before, after_before);\n        memmove (before, entry, entry_len);\n        *argz = new_argz;\n        *argz_len = new_argz_len;\n        return 0;\n      }\n    else\n      return ENOMEM;\n  }\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "error_t"
      ]
    },
    "argz_next": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "char *\nargz_next (const char *argz, size_t argz_len, const char *entry)\n{\n  if (entry)\n    {\n      if (entry < argz + argz_len)\n        entry = strchr (entry, '\\0') + 1;\n\n      return entry >= argz + argz_len ? NULL : (char *) entry;\n    }\n  else\n    if (argz_len > 0)\n      return (char *) argz;\n    else\n      return NULL;\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "char",
        "*\nargz_next (const char *argz, size_t argz_len, const char *entry)",
        "*"
      ]
    },
    "argz_stringify": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "void\nargz_stringify (char *argz, size_t len, int sep)\n{\n  if (len > 0)\n    while (1)\n      {\n        size_t part_len = strnlen (argz, len);\n        argz += part_len;\n        len -= part_len;\n        if (len-- <= 1)         /* includes final '\\0' we want to stop at */\n          break;\n        *argz++ = sep;\n      }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "argz_count": {
      "start_point": [
        215,
        0
      ],
      "end_point": [
        227,
        1
      ],
      "content": "size_t\nargz_count (const char *argz, size_t len)\n{\n  size_t count = 0;\n  while (len > 0)\n    {\n      size_t part_len = strlen (argz);\n      argz += part_len + 1;\n      len -= part_len + 1;\n      count++;\n    }\n  return count;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "size_t"
      ]
    },
    "argz_extract": {
      "start_point": [
        232,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "void\nargz_extract (const char *argz, size_t len, char **argv)\n{\n  while (len > 0)\n    {\n      size_t part_len = strlen (argz);\n      *argv++ = (char *) argz;\n      argz += part_len + 1;\n      len -= part_len + 1;\n    }\n  *argv = 0;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "argz_create": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        274,
        1
      ],
      "content": "error_t\nargz_create (char *const argv[], char **argz, size_t *len)\n{\n  int argc;\n  size_t tlen = 0;\n  char *const *ap;\n  char *p;\n\n  for (argc = 0; argv[argc] != NULL; ++argc)\n    tlen += strlen (argv[argc]) + 1;\n\n  if (tlen == 0)\n    *argz = NULL;\n  else\n    {\n      *argz = malloc (tlen);\n      if (*argz == NULL)\n        return ENOMEM;\n\n      for (p = *argz, ap = argv; *ap; ++ap, ++p)\n        p = stpcpy (p, *ap);\n    }\n  *len = tlen;\n\n  return 0;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "error_t"
      ]
    },
    "argz_delete": {
      "start_point": [
        278,
        0
      ],
      "end_point": [
        293,
        1
      ],
      "content": "void\nargz_delete (char **argz, size_t *argz_len, char *entry)\n{\n  if (entry)\n    /* Get rid of the old value for NAME.  */\n    {\n      size_t entry_len = strlen (entry) + 1;\n      *argz_len -= entry_len;\n      memmove (entry, entry + entry_len, *argz_len - (entry - *argz));\n      if (*argz_len == 0)\n        {\n          free (*argz);\n          *argz = 0;\n        }\n    }\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "str_append": {
      "start_point": [
        299,
        0
      ],
      "end_point": [
        316,
        1
      ],
      "content": "static void\nstr_append (char **to, size_t *to_len, const char *buf, const size_t buf_len)\n{\n  size_t new_len = *to_len + buf_len;\n  char *new_to = realloc (*to, new_len + 1);\n\n  if (new_to)\n    {\n      *((char *) mempcpy (new_to + *to_len, buf, buf_len)) = '\\0';\n      *to = new_to;\n      *to_len = new_len;\n    }\n  else\n    {\n      free (*to);\n      *to = 0;\n    }\n}",
      "lines": 18,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "argz_replace": {
      "start_point": [
        321,
        0
      ],
      "end_point": [
        405,
        1
      ],
      "content": "error_t\nargz_replace (char **argz, size_t *argz_len, const char *str, const char *with,\n                unsigned *replace_count)\n{\n  error_t err = 0;\n\n  if (str && *str)\n    {\n      char *arg = 0;\n      char *src = *argz;\n      size_t src_len = *argz_len;\n      char *dst = 0;\n      size_t dst_len = 0;\n      int delayed_copy = 1;     /* True while we've avoided copying anything.  */\n      size_t str_len = strlen (str), with_len = strlen (with);\n\n      while (!err && (arg = argz_next (src, src_len, arg)))\n        {\n          char *match = strstr (arg, str);\n          if (match)\n            {\n              char *from = match + str_len;\n              size_t to_len = match - arg;\n              char *to = strndup (arg, to_len);\n\n              while (to && from)\n                {\n                  str_append (&to, &to_len, with, with_len);\n                  if (to)\n                    {\n                      match = strstr (from, str);\n                      if (match)\n                        {\n                          str_append (&to, &to_len, from, match - from);\n                          from = match + str_len;\n                        }\n                      else\n                        {\n                          str_append (&to, &to_len, from, strlen (from));\n                          from = 0;\n                        }\n                    }\n                }\n\n              if (to)\n                {\n                  if (delayed_copy)\n                    /* We avoided copying SRC to DST until we found a match;\n                       now that we've done so, copy everything from the start\n                       of SRC.  */\n                    {\n                      if (arg > src)\n                        err = argz_append (&dst, &dst_len, src, (arg - src));\n                      delayed_copy = 0;\n                    }\n                  if (! err)\n                    err = argz_add (&dst, &dst_len, to);\n                  free (to);\n                }\n              else\n                err = ENOMEM;\n\n              if (replace_count)\n                (*replace_count)++;\n            }\n          else if (! delayed_copy)\n            err = argz_add (&dst, &dst_len, arg);\n        }\n\n      if (! err)\n        {\n          if (! delayed_copy)\n            /* We never found any instances of str.  */\n            {\n              free (src);\n              *argz = dst;\n              *argz_len = dst_len;\n            }\n        }\n      else if (dst_len > 0)\n        free (dst);\n    }\n\n  return err;\n}",
      "lines": 85,
      "depth": 20,
      "decorators": [
        "error_t"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/argz.in.h": {
    "__NTH": [
      {
        "start_point": [
          136,
          0
        ],
        "end_point": [
          149,
          1
        ],
        "content": "__extern_inline char *\n__NTH (argz_next (const char *__argz, size_t __argz_len,\n                    const char *__entry))\n{\n  if (__entry)\n    {\n      if (__entry < __argz + __argz_len)\n        __entry = strchr (__entry, '\\0') + 1;\n\n      return __entry >= __argz + __argz_len ? (char *) NULL : (char *) __entry;\n    }\n  else\n    return __argz_len > 0 ? (char *) __argz : 0;\n}",
        "lines": 14,
        "depth": 12,
        "decorators": [
          "__extern_inline",
          "char",
          "char",
          "*\n__NTH (argz_next (const char *__argz, size_t __argz_len,\n                    const char *__entry))",
          "*"
        ]
      },
      {
        "start_point": [
          150,
          0
        ],
        "end_point": [
          155,
          1
        ],
        "content": "__extern_inline char *\n__NTH (argz_next (const char *__argz, size_t __argz_len,\n                  const char *__entry))\n{\n  return argz_next (__argz, __argz_len, __entry);\n}",
        "lines": 6,
        "depth": 10,
        "decorators": [
          "__extern_inline",
          "char",
          "char",
          "*\n__NTH (argz_next (const char *__argz, size_t __argz_len,\n                  const char *__entry))",
          "*"
        ]
      }
    ]
  },
  "texinfo/texinfo-6.5/gnulib/lib/asnprintf.c": {
    "asnprintf": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "char *\nasnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)\n{\n  va_list args;\n  char *result;\n\n  va_start (args, format);\n  result = vasnprintf (resultbuf, lengthp, format, args);\n  va_end (args);\n  return result;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "char",
        "*\nasnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/asprintf.c": {
    "asprintf": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nasprintf (char **resultp, const char *format, ...)\n{\n  va_list args;\n  int result;\n\n  va_start (args, format);\n  result = vasprintf (resultp, format, args);\n  va_end (args);\n  return result;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/basename-lgpl.c": {
    "last_component": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "char *\nlast_component (char const *name)\n{\n  char const *base = name + FILE_SYSTEM_PREFIX_LEN (name);\n  char const *p;\n  bool saw_slash = false;\n\n  while (ISSLASH (*base))\n    base++;\n\n  for (p = base; *p; p++)\n    {\n      if (ISSLASH (*p))\n        saw_slash = true;\n      else if (saw_slash)\n        {\n          base = p;\n          saw_slash = false;\n        }\n    }\n\n  return (char *) base;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "char",
        "*\nlast_component (char const *name)",
        "*"
      ]
    },
    "base_len": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "size_t\nbase_len (char const *name)\n{\n  size_t len;\n  size_t prefix_len = FILE_SYSTEM_PREFIX_LEN (name);\n\n  for (len = strlen (name);  1 < len && ISSLASH (name[len - 1]);  len--)\n    continue;\n\n  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && len == 1\n      && ISSLASH (name[0]) && ISSLASH (name[1]) && ! name[2])\n    return 2;\n\n  if (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE && prefix_len\n      && len == prefix_len && ISSLASH (name[prefix_len]))\n    return prefix_len + 1;\n\n  return len;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/btowc.c": {
    "btowc": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "wint_t\nbtowc (int c)\n{\n  if (c != EOF)\n    {\n      char buf[1];\n      wchar_t wc;\n\n      buf[0] = c;\n      if (mbtowc (&wc, buf, 1) >= 0)\n        return wc;\n    }\n  return WEOF;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "wint_t"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/c++defs.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/dirname-lgpl.c": {
    "dir_len": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "size_t\ndir_len (char const *file)\n{\n  size_t prefix_length = FILE_SYSTEM_PREFIX_LEN (file);\n  size_t length;\n\n  /* Advance prefix_length beyond important leading slashes.  */\n  prefix_length += (prefix_length != 0\n                    ? (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                       && ISSLASH (file[prefix_length]))\n                    : (ISSLASH (file[0])\n                       ? ((DOUBLE_SLASH_IS_DISTINCT_ROOT\n                           && ISSLASH (file[1]) && ! ISSLASH (file[2])\n                           ? 2 : 1))\n                       : 0));\n\n  /* Strip the basename and any redundant slashes before it.  */\n  for (length = last_component (file) - file;\n       prefix_length < length; length--)\n    if (! ISSLASH (file[length - 1]))\n      break;\n  return length;\n}",
      "lines": 23,
      "depth": 17,
      "decorators": [
        "size_t"
      ]
    },
    "mdir_name": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "char *\nmdir_name (char const *file)\n{\n  size_t length = dir_len (file);\n  bool append_dot = (length == 0\n                     || (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                         && length == FILE_SYSTEM_PREFIX_LEN (file)\n                         && file[2] != '\\0' && ! ISSLASH (file[2])));\n  char *dir = malloc (length + append_dot + 1);\n  if (!dir)\n    return NULL;\n  memcpy (dir, file, length);\n  if (append_dot)\n    dir[length++] = '.';\n  dir[length] = '\\0';\n  return dir;\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "char",
        "*\nmdir_name (char const *file)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/dirname.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/dosname.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/errno.in.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/error.c": {
    "is_open": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "static int\nis_open (int fd)\n{\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows: The initial state of unassigned standard file\n     descriptors is that they are open but point to an INVALID_HANDLE_VALUE.\n     There is no fcntl, and the gnulib replacement fcntl does not support\n     F_GETFL.  */\n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n# else\n#  ifndef F_GETFL\n#   error Please port fcntl to your platform\n#  endif\n  return 0 <= fcntl (fd, F_GETFL);\n# endif\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "flush_stdout": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "static void\nflush_stdout (void)\n{\n#if !_LIBC\n  int stdout_fd;\n\n# if GNULIB_FREOPEN_SAFER\n  /* Use of gnulib's freopen-safer module normally ensures that\n       fileno (stdout) == 1\n     whenever stdout is open.  */\n  stdout_fd = STDOUT_FILENO;\n# else\n  /* POSIX states that fileno (stdout) after fclose is unspecified.  But in\n     practice it is not a problem, because stdout is statically allocated and\n     the fd of a FILE stream is stored as a field in its allocated memory.  */\n  stdout_fd = fileno (stdout);\n# endif\n  /* POSIX states that fflush (stdout) after fclose is unspecified; it\n     is safe in glibc, but not on all other platforms.  fflush (NULL)\n     is always defined, but too draconian.  */\n  if (0 <= stdout_fd && is_open (stdout_fd))\n#endif\n    fflush (stdout);\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_errno_message": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        202,
        1
      ],
      "content": "static void\nprint_errno_message (int errnum)\n{\n  char const *s;\n\n#if _LIBC || GNULIB_STRERROR_R_POSIX || defined HAVE_STRERROR_R\n  char errbuf[1024];\n# if _LIBC || (!GNULIB_STRERROR_R_POSIX && STRERROR_R_CHAR_P)\n  s = __strerror_r (errnum, errbuf, sizeof errbuf);\n# else\n  if (__strerror_r (errnum, errbuf, sizeof errbuf) == 0)\n    s = errbuf;\n  else\n    s = 0;\n# endif\n#else\n  s = strerror (errnum);\n#endif\n\n#if !_LIBC\n  if (! s)\n    s = _(\"Unknown system error\");\n#endif\n\n#if _LIBC\n  __fxprintf (NULL, \": %s\", s);\n#else\n  fprintf (stderr, \": %s\", s);\n#endif\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "error_tail": {
      "start_point": [
        205,
        42
      ],
      "end_point": [
        286,
        1
      ],
      "content": "char *message, va_list args)\n{\n#if _LIBC\n  if (_IO_fwide (stderr, 0) > 0)\n    {\n      size_t len = strlen (message) + 1;\n      wchar_t *wmessage = NULL;\n      mbstate_t st;\n      size_t res;\n      const char *tmp;\n      bool use_malloc = false;\n\n      while (1)\n        {\n          if (__libc_use_alloca (len * sizeof (wchar_t)))\n            wmessage = (wchar_t *) alloca (len * sizeof (wchar_t));\n          else\n            {\n              if (!use_malloc)\n                wmessage = NULL;\n\n              wchar_t *p = (wchar_t *) realloc (wmessage,\n                                                len * sizeof (wchar_t));\n              if (p == NULL)\n                {\n                  free (wmessage);\n                  fputws_unlocked (L\"out of memory\\n\", stderr);\n                  return;\n                }\n              wmessage = p;\n              use_malloc = true;\n            }\n\n          memset (&st, '\\0', sizeof (st));\n          tmp = message;\n\n          res = mbsrtowcs (wmessage, &tmp, len, &st);\n          if (res != len)\n            break;\n\n          if (__builtin_expect (len >= SIZE_MAX / sizeof (wchar_t) / 2, 0))\n            {\n              /* This really should not happen if everything is fine.  */\n              res = (size_t) -1;\n              break;\n            }\n\n          len *= 2;\n        }\n\n      if (res == (size_t) -1)\n        {\n          /* The string cannot be converted.  */\n          if (use_malloc)\n            {\n              free (wmessage);\n              use_malloc = false;\n            }\n          wmessage = (wchar_t *) L\"???\";\n        }\n\n      __vfwprintf (stderr, wmessage, args);\n\n      if (use_malloc)\n        free (wmessage);\n    }\n  else\n#endif\n    vfprintf (stderr, message, args);\n\n  ++error_message_count;\n  if (errnum)\n    print_errno_message (errnum);\n#if _LIBC\n  __fxprintf (NULL, \"\\n\");\n#else\n  putc ('\\n', stderr);\n#endif\n  fflush (stderr);\n  if (status)\n    exit (status);\n}",
      "lines": 82,
      "depth": 18,
      "decorators": null
    },
    "error": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        331,
        1
      ],
      "content": "void\nerror (int status, int errnum, const char *message, ...)\n{\n  va_list args;\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s: \", program_name);\n#else\n      fprintf (stderr, \"%s: \", program_name);\n#endif\n    }\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n  va_end (args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "error_at_line": {
      "start_point": [
        337,
        0
      ],
      "end_point": [
        402,
        1
      ],
      "content": "void\nerror_at_line (int status, int errnum, const char *file_name,\n               unsigned int line_number, const char *message, ...)\n{\n  va_list args;\n\n  if (error_one_per_line)\n    {\n      static const char *old_file_name;\n      static unsigned int old_line_number;\n\n      if (old_line_number == line_number\n          && (file_name == old_file_name\n              || (old_file_name != NULL\n                  && file_name != NULL\n                  && strcmp (old_file_name, file_name) == 0)))\n\n        /* Simply return and print nothing.  */\n        return;\n\n      old_file_name = file_name;\n      old_line_number = line_number;\n    }\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s:\", program_name);\n#else\n      fprintf (stderr, \"%s:\", program_name);\n#endif\n    }\n\n#if _LIBC\n  __fxprintf (NULL, file_name != NULL ? \"%s:%u: \" : \" \",\n              file_name, line_number);\n#else\n  fprintf (stderr, file_name != NULL ? \"%s:%u: \" : \" \",\n           file_name, line_number);\n#endif\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n  va_end (args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 66,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/error.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/exitfail.c": {},
  "texinfo/texinfo-6.5/gnulib/lib/exitfail.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/float+.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/float.c": {},
  "texinfo/texinfo-6.5/gnulib/lib/float.in.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/getopt-cdefs.in.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/getopt-core.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/getopt-ext.h": {
    "struct": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "__BEGIN_DECLS\n\n/* Describe the long-named options requested by the application.\n   The LONG_OPTIONS argument to getopt_long or getopt_long_only is a vector\n   of 'struct option' terminated by an element containing a name which is\n   zero.\n\n   The field 'has_arg' is:\n   no_argument\t\t(or 0) if the option does not take an argument,\n   required_argument\t(or 1) if the option requires an argument,\n   optional_argument \t(or 2) if the option takes an optional argument.\n\n   If the field 'flag' is not NULL, it points to a variable that is set\n   to the value given in the field 'val' when the option is found, but\n   left unchanged if the option is not found.\n\n   To have a long-named option do something other than set an 'int' to\n   a compiled-in constant, such as set a value from 'optarg', set the\n   option's 'flag' field to zero and its 'val' field to a nonzero\n   value (the equivalent single-letter option character, if there is\n   one).  For long options that have a zero 'flag' field, 'getopt'\n   returns the contents of the 'val' field.  */\n\nstruct option\n{\n  const char *name;\n  /* has_arg can't be an enum because some compilers complain about\n     type mismatches in all the code that assumes it is an int.  */\n  int has_arg;\n  int *flag;\n  int val;\n}",
      "lines": 32,
      "depth": 5,
      "decorators": null
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/getopt-pfx-core.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/getopt-pfx-ext.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/getopt.c": {
    "exchange": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "static void\nexchange (char **argv, struct _getopt_data *d)\n{\n  int bottom = d->__first_nonopt;\n  int middle = d->__last_nonopt;\n  int top = d->optind;\n  char *tem;\n\n  /* Exchange the shorter segment with the far end of the longer segment.\n     That puts the shorter segment into the right place.\n     It leaves the longer segment in the right place overall,\n     but it consists of two parts that need to be swapped next.  */\n\n  while (top > middle && middle > bottom)\n    {\n      if (top - middle > middle - bottom)\n\t{\n\t  /* Bottom segment is the short one.  */\n\t  int len = middle - bottom;\n\t  int i;\n\n\t  /* Swap it with the top part of the top segment.  */\n\t  for (i = 0; i < len; i++)\n\t    {\n\t      tem = argv[bottom + i];\n\t      argv[bottom + i] = argv[top - (middle - bottom) + i];\n\t      argv[top - (middle - bottom) + i] = tem;\n\t    }\n\t  /* Exclude the moved bottom segment from further swapping.  */\n\t  top -= len;\n\t}\n      else\n\t{\n\t  /* Top segment is the short one.  */\n\t  int len = top - middle;\n\t  int i;\n\n\t  /* Swap it with the bottom part of the bottom segment.  */\n\t  for (i = 0; i < len; i++)\n\t    {\n\t      tem = argv[bottom + i];\n\t      argv[bottom + i] = argv[middle + i];\n\t      argv[middle + i] = tem;\n\t    }\n\t  /* Exclude the moved top segment from further swapping.  */\n\t  bottom += len;\n\t}\n    }\n\n  /* Update records for the slots the non-options now occupy.  */\n\n  d->__first_nonopt += (d->optind - d->__last_nonopt);\n  d->__last_nonopt = d->optind;\n}",
      "lines": 54,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "process_long_option": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        375,
        1
      ],
      "content": "static int\nprocess_long_option (int argc, char **argv, const char *optstring,\n\t\t     const struct option *longopts, int *longind,\n\t\t     int long_only, struct _getopt_data *d,\n\t\t     int print_errors, const char *prefix)\n{\n  char *nameend;\n  size_t namelen;\n  const struct option *p;\n  const struct option *pfound = NULL;\n  int n_options;\n  int option_index;\n\n  for (nameend = d->__nextchar; *nameend && *nameend != '='; nameend++)\n    /* Do nothing.  */ ;\n  namelen = nameend - d->__nextchar;\n\n  /* First look for an exact match, counting the options as a side\n     effect.  */\n  for (p = longopts, n_options = 0; p->name; p++, n_options++)\n    if (!strncmp (p->name, d->__nextchar, namelen)\n\t&& namelen == strlen (p->name))\n      {\n\t/* Exact match found.  */\n\tpfound = p;\n\toption_index = n_options;\n\tbreak;\n      }\n\n  if (pfound == NULL)\n    {\n      /* Didn't find an exact match, so look for abbreviations.  */\n      unsigned char *ambig_set = NULL;\n      int ambig_malloced = 0;\n      int ambig_fallback = 0;\n      int indfound = -1;\n\n      for (p = longopts, option_index = 0; p->name; p++, option_index++)\n\tif (!strncmp (p->name, d->__nextchar, namelen))\n\t  {\n\t    if (pfound == NULL)\n\t      {\n\t\t/* First nonexact match found.  */\n\t\tpfound = p;\n\t\tindfound = option_index;\n\t      }\n\t    else if (long_only\n\t\t     || pfound->has_arg != p->has_arg\n\t\t     || pfound->flag != p->flag\n\t\t     || pfound->val != p->val)\n\t      {\n\t\t/* Second or later nonexact match found.  */\n\t\tif (!ambig_fallback)\n\t\t  {\n\t\t    if (!print_errors)\n\t\t      /* Don't waste effort tracking the ambig set if\n\t\t\t we're not going to print it anyway.  */\n\t\t      ambig_fallback = 1;\n\t\t    else if (!ambig_set)\n\t\t      {\n\t\t\tif (__libc_use_alloca (n_options))\n\t\t\t  ambig_set = alloca (n_options);\n\t\t\telse if ((ambig_set = malloc (n_options)) == NULL)\n\t\t\t  /* Fall back to simpler error message.  */\n\t\t\t  ambig_fallback = 1;\n\t\t\telse\n\t\t\t  ambig_malloced = 1;\n\n\t\t\tif (ambig_set)\n\t\t\t  {\n\t\t\t    memset (ambig_set, 0, n_options);\n\t\t\t    ambig_set[indfound] = 1;\n\t\t\t  }\n\t\t      }\n\t\t    if (ambig_set)\n\t\t      ambig_set[option_index] = 1;\n\t\t  }\n\t      }\n\t  }\n\n      if (ambig_set || ambig_fallback)\n\t{\n\t  if (print_errors)\n\t    {\n\t      if (ambig_fallback)\n\t\tfprintf (stderr, _(\"%s: option '%s%s' is ambiguous\\n\"),\n\t\t\t argv[0], prefix, d->__nextchar);\n\t      else\n\t\t{\n\t\t  flockfile (stderr);\n\t\t  fprintf (stderr,\n\t\t\t   _(\"%s: option '%s%s' is ambiguous; possibilities:\"),\n\t\t\t   argv[0], prefix, d->__nextchar);\n\n\t\t  for (option_index = 0; option_index < n_options; option_index++)\n\t\t    if (ambig_set[option_index])\n\t\t      fprintf (stderr, \" '%s%s'\",\n\t\t\t       prefix, longopts[option_index].name);\n\n\t\t  /* This must use 'fprintf' even though it's only\n\t\t     printing a single character, so that it goes through\n\t\t     __fxprintf_nocancel when compiled as part of glibc.  */\n\t\t  fprintf (stderr, \"\\n\");\n\t\t  funlockfile (stderr);\n\t\t}\n\t    }\n\t  if (ambig_malloced)\n\t    free (ambig_set);\n\t  d->__nextchar += strlen (d->__nextchar);\n\t  d->optind++;\n\t  d->optopt = 0;\n\t  return '?';\n\t}\n\n      option_index = indfound;\n    }\n\n  if (pfound == NULL)\n    {\n      /* Can't find it as a long option.  If this is not getopt_long_only,\n\t or the option starts with '--' or is not a valid short option,\n\t then it's an error.  */\n      if (!long_only || argv[d->optind][1] == '-'\n\t  || strchr (optstring, *d->__nextchar) == NULL)\n\t{\n\t  if (print_errors)\n\t    fprintf (stderr, _(\"%s: unrecognized option '%s%s'\\n\"),\n\t\t     argv[0], prefix, d->__nextchar);\n\n\t  d->__nextchar = NULL;\n\t  d->optind++;\n\t  d->optopt = 0;\n\t  return '?';\n\t}\n\n      /* Otherwise interpret it as a short option.  */\n      return -1;\n    }\n\n  /* We have found a matching long option.  Consume it.  */\n  d->optind++;\n  d->__nextchar = NULL;\n  if (*nameend)\n    {\n      /* Don't test has_arg with >, because some C compilers don't\n\t allow it to be used on enums.  */\n      if (pfound->has_arg)\n\td->optarg = nameend + 1;\n      else\n\t{\n\t  if (print_errors)\n\t    fprintf (stderr,\n\t\t     _(\"%s: option '%s%s' doesn't allow an argument\\n\"),\n\t\t     argv[0], prefix, pfound->name);\n\n\t  d->optopt = pfound->val;\n\t  return '?';\n\t}\n    }\n  else if (pfound->has_arg == 1)\n    {\n      if (d->optind < argc)\n\td->optarg = argv[d->optind++];\n      else\n\t{\n\t  if (print_errors)\n\t    fprintf (stderr,\n\t\t     _(\"%s: option '%s%s' requires an argument\\n\"),\n\t\t     argv[0], prefix, pfound->name);\n\n\t  d->optopt = pfound->val;\n\t  return optstring[0] == ':' ? ':' : '?';\n\t}\n    }\n\n  if (longind != NULL)\n    *longind = option_index;\n  if (pfound->flag)\n    {\n      *(pfound->flag) = pfound->val;\n      return 0;\n    }\n  return pfound->val;\n}",
      "lines": 184,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_getopt_initialize": {
      "start_point": [
        379,
        0
      ],
      "end_point": [
        411,
        1
      ],
      "content": "static const char *\n_getopt_initialize (int argc _GL_UNUSED,\n\t\t    char **argv _GL_UNUSED, const char *optstring,\n\t\t    struct _getopt_data *d, int posixly_correct)\n{\n  /* Start processing options with ARGV-element 1 (since ARGV-element 0\n     is the program name); the sequence of previously skipped\n     non-option ARGV-elements is empty.  */\n  if (d->optind == 0)\n    d->optind = 1;\n\n  d->__first_nonopt = d->__last_nonopt = d->optind;\n  d->__nextchar = NULL;\n\n  /* Determine how to handle the ordering of options and nonoptions.  */\n  if (optstring[0] == '-')\n    {\n      d->__ordering = RETURN_IN_ORDER;\n      ++optstring;\n    }\n  else if (optstring[0] == '+')\n    {\n      d->__ordering = REQUIRE_ORDER;\n      ++optstring;\n    }\n  else if (posixly_correct || !!getenv (\"POSIXLY_CORRECT\"))\n    d->__ordering = REQUIRE_ORDER;\n  else\n    d->__ordering = PERMUTE;\n\n  d->__initialized = 1;\n  return optstring;\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\n_getopt_initialize (int argc _GL_UNUSED,\n\t\t    char **argv _GL_UNUSED, const char *optstring,\n\t\t    struct _getopt_data *d, int posixly_correct)",
        "*"
      ]
    },
    "_getopt_internal_r": {
      "start_point": [
        469,
        0
      ],
      "end_point": [
        699,
        1
      ],
      "content": "int\n_getopt_internal_r (int argc, char **argv, const char *optstring,\n\t\t    const struct option *longopts, int *longind,\n\t\t    int long_only, struct _getopt_data *d, int posixly_correct)\n{\n  int print_errors = d->opterr;\n\n  if (argc < 1)\n    return -1;\n\n  d->optarg = NULL;\n\n  if (d->optind == 0 || !d->__initialized)\n    optstring = _getopt_initialize (argc, argv, optstring, d, posixly_correct);\n  else if (optstring[0] == '-' || optstring[0] == '+')\n    optstring++;\n\n  if (optstring[0] == ':')\n    print_errors = 0;\n\n  /* Test whether ARGV[optind] points to a non-option argument.  */\n#define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0')\n\n  if (d->__nextchar == NULL || *d->__nextchar == '\\0')\n    {\n      /* Advance to the next ARGV-element.  */\n\n      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been\n\t moved back by the user (who may also have changed the arguments).  */\n      if (d->__last_nonopt > d->optind)\n\td->__last_nonopt = d->optind;\n      if (d->__first_nonopt > d->optind)\n\td->__first_nonopt = d->optind;\n\n      if (d->__ordering == PERMUTE)\n\t{\n\t  /* If we have just processed some options following some non-options,\n\t     exchange them so that the options come first.  */\n\n\t  if (d->__first_nonopt != d->__last_nonopt\n\t      && d->__last_nonopt != d->optind)\n\t    exchange (argv, d);\n\t  else if (d->__last_nonopt != d->optind)\n\t    d->__first_nonopt = d->optind;\n\n\t  /* Skip any additional non-options\n\t     and extend the range of non-options previously skipped.  */\n\n\t  while (d->optind < argc && NONOPTION_P)\n\t    d->optind++;\n\t  d->__last_nonopt = d->optind;\n\t}\n\n      /* The special ARGV-element '--' means premature end of options.\n\t Skip it like a null option,\n\t then exchange with previous non-options as if it were an option,\n\t then skip everything else like a non-option.  */\n\n      if (d->optind != argc && !strcmp (argv[d->optind], \"--\"))\n\t{\n\t  d->optind++;\n\n\t  if (d->__first_nonopt != d->__last_nonopt\n\t      && d->__last_nonopt != d->optind)\n\t    exchange (argv, d);\n\t  else if (d->__first_nonopt == d->__last_nonopt)\n\t    d->__first_nonopt = d->optind;\n\t  d->__last_nonopt = argc;\n\n\t  d->optind = argc;\n\t}\n\n      /* If we have done all the ARGV-elements, stop the scan\n\t and back over any non-options that we skipped and permuted.  */\n\n      if (d->optind == argc)\n\t{\n\t  /* Set the next-arg-index to point at the non-options\n\t     that we previously skipped, so the caller will digest them.  */\n\t  if (d->__first_nonopt != d->__last_nonopt)\n\t    d->optind = d->__first_nonopt;\n\t  return -1;\n\t}\n\n      /* If we have come to a non-option and did not permute it,\n\t either stop the scan or describe it to the caller and pass it by.  */\n\n      if (NONOPTION_P)\n\t{\n\t  if (d->__ordering == REQUIRE_ORDER)\n\t    return -1;\n\t  d->optarg = argv[d->optind++];\n\t  return 1;\n\t}\n\n      /* We have found another option-ARGV-element.\n\t Check whether it might be a long option.  */\n      if (longopts)\n\t{\n\t  if (argv[d->optind][1] == '-')\n\t    {\n\t      /* \"--foo\" is always a long option.  The special option\n\t\t \"--\" was handled above.  */\n\t      d->__nextchar = argv[d->optind] + 2;\n\t      return process_long_option (argc, argv, optstring, longopts,\n\t\t\t\t\t  longind, long_only, d,\n\t\t\t\t\t  print_errors, \"--\");\n\t    }\n\n\t  /* If long_only and the ARGV-element has the form \"-f\",\n\t     where f is a valid short option, don't consider it an\n\t     abbreviated form of a long option that starts with f.\n\t     Otherwise there would be no way to give the -f short\n\t     option.\n\n\t     On the other hand, if there's a long option \"fubar\" and\n\t     the ARGV-element is \"-fu\", do consider that an\n\t     abbreviation of the long option, just like \"--fu\", and\n\t     not \"-f\" with arg \"u\".\n\n\t     This distinction seems to be the most useful approach.  */\n\t  if (long_only && (argv[d->optind][2]\n\t\t\t    || !strchr (optstring, argv[d->optind][1])))\n\t    {\n\t      int code;\n\t      d->__nextchar = argv[d->optind] + 1;\n\t      code = process_long_option (argc, argv, optstring, longopts,\n\t\t\t\t\t  longind, long_only, d,\n\t\t\t\t\t  print_errors, \"-\");\n\t      if (code != -1)\n\t\treturn code;\n\t    }\n\t}\n\n      /* It is not a long option.  Skip the initial punctuation.  */\n      d->__nextchar = argv[d->optind] + 1;\n    }\n\n  /* Look at and handle the next short option-character.  */\n\n  {\n    char c = *d->__nextchar++;\n    const char *temp = strchr (optstring, c);\n\n    /* Increment 'optind' when we start to process its last character.  */\n    if (*d->__nextchar == '\\0')\n      ++d->optind;\n\n    if (temp == NULL || c == ':' || c == ';')\n      {\n\tif (print_errors)\n\t  fprintf (stderr, _(\"%s: invalid option -- '%c'\\n\"), argv[0], c);\n\td->optopt = c;\n\treturn '?';\n      }\n\n    /* Convenience. Treat POSIX -W foo same as long option --foo */\n    if (temp[0] == 'W' && temp[1] == ';' && longopts != NULL)\n      {\n\t/* This is an option that requires an argument.  */\n\tif (*d->__nextchar != '\\0')\n\t  d->optarg = d->__nextchar;\n\telse if (d->optind == argc)\n\t  {\n\t    if (print_errors)\n\t      fprintf (stderr,\n\t\t       _(\"%s: option requires an argument -- '%c'\\n\"),\n\t\t       argv[0], c);\n\n\t    d->optopt = c;\n\t    if (optstring[0] == ':')\n\t      c = ':';\n\t    else\n\t      c = '?';\n\t    return c;\n\t  }\n\telse\n\t  d->optarg = argv[d->optind];\n\n\td->__nextchar = d->optarg;\n\td->optarg = NULL;\n\treturn process_long_option (argc, argv, optstring, longopts, longind,\n\t\t\t\t    0 /* long_only */, d, print_errors, \"-W \");\n      }\n    if (temp[1] == ':')\n      {\n\tif (temp[2] == ':')\n\t  {\n\t    /* This is an option that accepts an argument optionally.  */\n\t    if (*d->__nextchar != '\\0')\n\t      {\n\t\td->optarg = d->__nextchar;\n\t\td->optind++;\n\t      }\n\t    else\n\t      d->optarg = NULL;\n\t    d->__nextchar = NULL;\n\t  }\n\telse\n\t  {\n\t    /* This is an option that requires an argument.  */\n\t    if (*d->__nextchar != '\\0')\n\t      {\n\t\td->optarg = d->__nextchar;\n\t\t/* If we end this ARGV-element by taking the rest as an arg,\n\t\t   we must advance to the next element now.  */\n\t\td->optind++;\n\t      }\n\t    else if (d->optind == argc)\n\t      {\n\t\tif (print_errors)\n\t\t  fprintf (stderr,\n\t\t\t   _(\"%s: option requires an argument -- '%c'\\n\"),\n\t\t\t   argv[0], c);\n\n\t\td->optopt = c;\n\t\tif (optstring[0] == ':')\n\t\t  c = ':';\n\t\telse\n\t\t  c = '?';\n\t      }\n\t    else\n\t      /* We already incremented 'optind' once;\n\t\t increment it again when taking next ARGV-elt as argument.  */\n\t      d->optarg = argv[d->optind++];\n\t    d->__nextchar = NULL;\n\t  }\n      }\n    return c;\n  }\n}",
      "lines": 231,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "_getopt_internal": {
      "start_point": [
        701,
        0
      ],
      "end_point": [
        720,
        1
      ],
      "content": "int\n_getopt_internal (int argc, char **argv, const char *optstring,\n\t\t  const struct option *longopts, int *longind, int long_only,\n\t\t  int posixly_correct)\n{\n  int result;\n\n  getopt_data.optind = optind;\n  getopt_data.opterr = opterr;\n\n  result = _getopt_internal_r (argc, argv, optstring, longopts,\n\t\t\t       longind, long_only, &getopt_data,\n\t\t\t       posixly_correct);\n\n  optind = getopt_data.optind;\n  optarg = getopt_data.optarg;\n  optopt = getopt_data.optopt;\n\n  return result;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        747,
        0
      ],
      "end_point": [
        808,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n\n      c = getopt (argc, argv, \"abc:d:0123456789\");\n      if (c == -1)\n\tbreak;\n\n      switch (c)\n\t{\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9':\n\t  if (digit_optind != 0 && digit_optind != this_option_optind)\n\t    printf (\"digits occur in two different argv-elements.\\n\");\n\t  digit_optind = this_option_optind;\n\t  printf (\"option %c\\n\", c);\n\t  break;\n\n\tcase 'a':\n\t  printf (\"option a\\n\");\n\t  break;\n\n\tcase 'b':\n\t  printf (\"option b\\n\");\n\t  break;\n\n\tcase 'c':\n\t  printf (\"option c with value '%s'\\n\", optarg);\n\t  break;\n\n\tcase '?':\n\t  break;\n\n\tdefault:\n\t  printf (\"?? getopt returned character code 0%o ??\\n\", c);\n\t}\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n\tprintf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/getopt.in.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/getopt1.c": {
    "getopt_long": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\ngetopt_long (int argc, char *__getopt_argv_const *argv, const char *options,\n\t     const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n\t\t\t   opt_index, 0, 0);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_r": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "int\n_getopt_long_r (int argc, char **argv, const char *options,\n\t\tconst struct option *long_options, int *opt_index,\n\t\tstruct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n\t\t\t     0, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "getopt_long_only": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\ngetopt_long_only (int argc, char *__getopt_argv_const *argv,\n\t\t  const char *options,\n\t\t  const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n\t\t\t   opt_index, 1, 0);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_only_r": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\n_getopt_long_only_r (int argc, char **argv, const char *options,\n\t\t     const struct option *long_options, int *opt_index,\n\t\t     struct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n\t\t\t     1, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n      int option_index = 0;\n      static const struct option long_options[] =\n      {\n\t{\"add\", 1, 0, 0},\n\t{\"append\", 0, 0, 0},\n\t{\"delete\", 1, 0, 0},\n\t{\"verbose\", 0, 0, 0},\n\t{\"create\", 0, 0, 0},\n\t{\"file\", 1, 0, 0},\n\t{0, 0, 0, 0}\n      };\n\n      c = getopt_long (argc, argv, \"abc:d:0123456789\",\n\t\t       long_options, &option_index);\n      if (c == -1)\n\tbreak;\n\n      switch (c)\n\t{\n\tcase 0:\n\t  printf (\"option %s\", long_options[option_index].name);\n\t  if (optarg)\n\t    printf (\" with arg %s\", optarg);\n\t  printf (\"\\n\");\n\t  break;\n\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9':\n\t  if (digit_optind != 0 && digit_optind != this_option_optind)\n\t    printf (\"digits occur in two different argv-elements.\\n\");\n\t  digit_optind = this_option_optind;\n\t  printf (\"option %c\\n\", c);\n\t  break;\n\n\tcase 'a':\n\t  printf (\"option a\\n\");\n\t  break;\n\n\tcase 'b':\n\t  printf (\"option b\\n\");\n\t  break;\n\n\tcase 'c':\n\t  printf (\"option c with value '%s'\\n\", optarg);\n\t  break;\n\n\tcase 'd':\n\t  printf (\"option d with value '%s'\\n\", optarg);\n\t  break;\n\n\tcase '?':\n\t  break;\n\n\tdefault:\n\t  printf (\"?? getopt returned character code 0%o ??\\n\", c);\n\t}\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n\tprintf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 85,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/getopt_int.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/getprogname.c": {
    "getprogname": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "char const *\ngetprogname (void)\n{\n# if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME                /* glibc, BeOS */\n  /* https://www.gnu.org/software/libc/manual/html_node/Error-Messages.html */\n  return program_invocation_short_name;\n# elif HAVE_DECL_PROGRAM_INVOCATION_NAME                    /* glibc, BeOS */\n  /* https://www.gnu.org/software/libc/manual/html_node/Error-Messages.html */\n  return last_component (program_invocation_name);\n# elif HAVE_GETEXECNAME                                     /* Solaris */\n  /* http://docs.oracle.com/cd/E19253-01/816-5168/6mbb3hrb1/index.html */\n  const char *p = getexecname ();\n  if (!p)\n    p = \"?\";\n  return last_component (p);\n# elif HAVE_DECL___ARGV                                     /* mingw, MSVC */\n  /* https://msdn.microsoft.com/en-us/library/dn727674.aspx */\n  const char *p = __argv && __argv[0] ? __argv[0] : \"?\";\n  return last_component (p);\n# elif HAVE_VAR___PROGNAME                                  /* OpenBSD, QNX */\n  /* http://man.openbsd.org/style.9 */\n  /* http://www.qnx.de/developers/docs/6.5.0/index.jsp?topic=%2Fcom.qnx.doc.neutrino_lib_ref%2Fp%2F__progname.html */\n  /* Be careful to declare this only when we absolutely need it\n     (OpenBSD 5.1), rather than when it's available.  Otherwise,\n     its mere declaration makes program_invocation_short_name\n     malfunction (have zero length) with Fedora 25's glibc.  */\n  extern char *__progname;\n  const char *p = __progname;\n  return p && p[0] ? p : \"?\";\n# elif _AIX                                                 /* AIX */\n  /* Idea by Bastien ROUCARI\u00c3\u0088S,\n     http://lists.gnu.org/archive/html/bug-gnulib/2010-12/msg00095.html\n     Reference: http://\n   ibm.biz/knowctr#ssw_aix_53/com.ibm.aix.basetechref/doc/basetrf1/getprocs.htm\n  */\n  static char *p;\n  static int first = 1;\n  if (first)\n    {\n      first = 0;\n      pid_t pid = getpid ();\n      struct procentry64 procs;\n      p = (0 < getprocs64 (&procs, sizeof procs, NULL, 0, &pid, 1)\n           ? strdup (procs.pi_comm)\n           : NULL);\n      if (!p)\n        p = \"?\";\n    }\n  return p;\n# elif defined __hpux\n  static char *p;\n  static int first = 1;\n  if (first)\n    {\n      first = 0;\n      pid_t pid = getpid ();\n      struct pst_status status;\n      p = (0 < pstat_getproc (&status, sizeof status, 0, pid)\n           ? strdup (status.pst_ucomm)\n           : NULL);\n      if (!p)\n        p = \"?\";\n    }\n  return p;\n# elif __MVS__                                              /* z/OS */\n  /* https://www.ibm.com/support/knowledgecenter/SSLTBW_2.1.0/com.ibm.zos.v2r1.bpxbd00/rtwgetp.htm */\n  static char *p = \"?\";\n  static int first = 1;\n  if (first)\n    {\n      pid_t pid = getpid ();\n      int token;\n      W_PSPROC buf;\n      first = 0;\n      memset (&buf, 0, sizeof(buf));\n      buf.ps_cmdptr    = (char *) malloc (buf.ps_cmdlen    = PS_CMDBLEN_LONG);\n      buf.ps_conttyptr = (char *) malloc (buf.ps_conttylen = PS_CONTTYBLEN);\n      buf.ps_pathptr   = (char *) malloc (buf.ps_pathlen   = PS_PATHBLEN);\n      if (buf.ps_cmdptr && buf.ps_conttyptr && buf.ps_pathptr)\n        {\n          for (token = 0; token >= 0;\n               token = w_getpsent (token, &buf, sizeof(buf)))\n            {\n              if (token > 0 && buf.ps_pid == pid)\n                {\n                  char *s = strdup (last_component (buf.ps_pathptr));\n                  if (s)\n                    p = s;\n                  break;\n                }\n            }\n        }\n      free (buf.ps_cmdptr);\n      free (buf.ps_conttyptr);\n      free (buf.ps_pathptr);\n    }\n  return p;\n# elif defined __sgi                                        /* IRIX */\n  char filename[50];\n  int fd;\n\n  sprintf (filename, \"/proc/pinfo/%d\", (int) getpid ());\n  fd = open (filename, O_RDONLY);\n  if (0 <= fd)\n    {\n      prpsinfo_t buf;\n      int ioctl_ok = 0 <= ioctl (fd, PIOCPSINFO, &buf);\n      close (fd);\n      if (ioctl_ok)\n        {\n          char *name = buf.pr_fname;\n          char *namesize = sizeof buf.pr_fname;\n          char *namenul = memchr (name, '\\0', namesize);\n          size_t namelen = namenul ? namenul - name : namesize;\n          char *namecopy = malloc (namelen + 1);\n          if (namecopy)\n            {\n              namecopy[namelen] = 0;\n              return memcpy (namecopy, name, namelen);\n            }\n        }\n    }\n  return NULL;\n# else\n#  error \"getprogname module not ported to this OS\"\n# endif\n}",
      "lines": 127,
      "depth": 26,
      "decorators": [
        "char",
        "const",
        "const",
        "*\ngetprogname (void)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/getprogname.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/gettext.h": {
    "pgettext_aux": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "static const char *\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)\n{\n  const char *translation = dcgettext (domain, msg_ctxt_id, category);\n  if (translation == msg_ctxt_id)\n    return msgid;\n  else\n    return translation;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)",
        "*"
      ]
    },
    "npgettext_aux": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "static const char *\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)\n{\n  const char *translation =\n    dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n  if (translation == msg_ctxt_id || translation == msgid_plural)\n    return (n == 1 ? msgid : msgid_plural);\n  else\n    return translation;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)",
        "*"
      ]
    },
    "dcpgettext_expr": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "static const char *\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      int found_translation;\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcgettext (domain, msg_ctxt_id, category);\n      found_translation = (translation != msg_ctxt_id);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (found_translation)\n        return translation;\n    }\n  return msgid;\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)",
        "*"
      ]
    },
    "dcnpgettext_expr": {
      "start_point": [
        257,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "static const char *\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      int found_translation;\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n      found_translation = !(translation == msg_ctxt_id || translation == msgid_plural);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (found_translation)\n        return translation;\n    }\n  return (n == 1 ? msgid : msgid_plural);\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/hard-locale.c": {
    "hard_locale": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "bool\nhard_locale (int category)\n{\n  bool hard = true;\n  char const *p = setlocale (category, NULL);\n\n  if (p)\n    {\n      if (2 <= GLIBC_VERSION)\n        {\n          if (strcmp (p, \"C\") == 0 || strcmp (p, \"POSIX\") == 0)\n            hard = false;\n        }\n      else\n        {\n          char *locale = strdup (p);\n          if (locale)\n            {\n              /* Temporarily set the locale to the \"C\" and \"POSIX\" locales\n                 to find their names, so that we can determine whether one\n                 or the other is the caller's locale.  */\n              if (((p = setlocale (category, \"C\"))\n                   && strcmp (p, locale) == 0)\n                  || ((p = setlocale (category, \"POSIX\"))\n                      && strcmp (p, locale) == 0))\n                hard = false;\n\n              /* Restore the caller's locale.  */\n              setlocale (category, locale);\n              free (locale);\n            }\n        }\n    }\n\n  return hard;\n}",
      "lines": 36,
      "depth": 19,
      "decorators": [
        "bool"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/hard-locale.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/intprops.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/iswblank.c": {
    "iswblank": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        25,
        1
      ],
      "content": "int\niswblank (wint_t wc)\n{\n  return wc == ' ' || wc == '\\t';\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/itold.c": {
    "_Qp_itoq": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "void\n_Qp_itoq (long double *result, int a)\n{\n  /* Convert from 'int' to 'double', then from 'double' to 'long double'.  */\n  *result = (double) a;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/langinfo.in.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/limits.in.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/localcharset.c": {
    "get_charset_aliases": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        384,
        1
      ],
      "content": "static const char *\nget_charset_aliases (void)\n{\n  const char *cp;\n\n  cp = charset_aliases;\n  if (cp == NULL)\n    {\n#if !(defined DARWIN7 || defined VMS || defined WINDOWS_NATIVE || defined __CYGWIN__ || defined OS2)\n      char *malloc_dir = NULL;\n      const char *dir;\n      const char *base = \"charset.alias\";\n      char *file_name;\n\n      /* Make it possible to override the charset.alias location.  This is\n         necessary for running the testsuite before \"make install\".  */\n      dir = getenv (\"CHARSETALIASDIR\");\n      if (dir == NULL || dir[0] == '\\0')\n        dir = relocate2 (LIBDIR, &malloc_dir);\n\n      /* Concatenate dir and base into freshly allocated file_name.  */\n      {\n        size_t dir_len = strlen (dir);\n        size_t base_len = strlen (base);\n        int add_slash = (dir_len > 0 && !ISSLASH (dir[dir_len - 1]));\n        file_name = (char *) malloc (dir_len + add_slash + base_len + 1);\n        if (file_name != NULL)\n          {\n            memcpy (file_name, dir, dir_len);\n            if (add_slash)\n              file_name[dir_len] = DIRECTORY_SEPARATOR;\n            memcpy (file_name + dir_len + add_slash, base, base_len + 1);\n          }\n      }\n\n      free (malloc_dir);\n\n      if (file_name == NULL)\n        /* Out of memory.  Treat the file as empty.  */\n        cp = \"\";\n      else\n        {\n          int fd;\n\n          /* Open the file.  Reject symbolic links on platforms that support\n             O_NOFOLLOW.  This is a security feature.  Without it, an attacker\n             could retrieve parts of the contents (namely, the tail of the\n             first line that starts with \"* \") of an arbitrary file by placing\n             a symbolic link to that file under the name \"charset.alias\" in\n             some writable directory and defining the environment variable\n             CHARSETALIASDIR to point to that directory.  */\n          fd = open (file_name,\n                     O_RDONLY | (HAVE_WORKING_O_NOFOLLOW ? O_NOFOLLOW : 0));\n          if (fd < 0)\n            /* File not found.  Treat it as empty.  */\n            cp = \"\";\n          else\n            {\n              FILE *fp;\n\n              fp = fdopen (fd, \"r\");\n              if (fp == NULL)\n                {\n                  /* Out of memory.  Treat the file as empty.  */\n                  close (fd);\n                  cp = \"\";\n                }\n              else\n                {\n                  /* Parse the file's contents.  */\n                  char *res_ptr = NULL;\n                  size_t res_size = 0;\n\n                  for (;;)\n                    {\n                      int c;\n                      char buf1[50+1];\n                      char buf2[50+1];\n                      size_t l1, l2;\n                      char *old_res_ptr;\n\n                      c = getc (fp);\n                      if (c == EOF)\n                        break;\n                      if (c == '\\n' || c == ' ' || c == '\\t')\n                        continue;\n                      if (c == '#')\n                        {\n                          /* Skip comment, to end of line.  */\n                          do\n                            c = getc (fp);\n                          while (!(c == EOF || c == '\\n'));\n                          if (c == EOF)\n                            break;\n                          continue;\n                        }\n                      ungetc (c, fp);\n                      if (fscanf (fp, \"%50s %50s\", buf1, buf2) < 2)\n                        break;\n                      l1 = strlen (buf1);\n                      l2 = strlen (buf2);\n                      old_res_ptr = res_ptr;\n                      if (res_size == 0)\n                        {\n                          res_size = l1 + 1 + l2 + 1;\n                          res_ptr = (char *) malloc (res_size + 1);\n                        }\n                      else\n                        {\n                          res_size += l1 + 1 + l2 + 1;\n                          res_ptr = (char *) realloc (res_ptr, res_size + 1);\n                        }\n                      if (res_ptr == NULL)\n                        {\n                          /* Out of memory. */\n                          res_size = 0;\n                          free (old_res_ptr);\n                          break;\n                        }\n                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);\n                      strcpy (res_ptr + res_size - (l2 + 1), buf2);\n                    }\n                  fclose (fp);\n                  if (res_size == 0)\n                    cp = \"\";\n                  else\n                    {\n                      *(res_ptr + res_size) = '\\0';\n                      cp = res_ptr;\n                    }\n                }\n            }\n\n          free (file_name);\n        }\n\n#else\n\n# if defined DARWIN7\n      /* To avoid the trouble of installing a file that is shared by many\n         GNU packages -- many packaging systems have problems with this --,\n         simply inline the aliases here.  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-4\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"ISO8859-13\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"ISO8859-15\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"KOI8-R\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"KOI8-U\" \"\\0\" \"KOI8-U\" \"\\0\"\n           \"CP866\" \"\\0\" \"CP866\" \"\\0\"\n           \"CP949\" \"\\0\" \"CP949\" \"\\0\"\n           \"CP1131\" \"\\0\" \"CP1131\" \"\\0\"\n           \"CP1251\" \"\\0\" \"CP1251\" \"\\0\"\n           \"eucCN\" \"\\0\" \"GB2312\" \"\\0\"\n           \"GB2312\" \"\\0\" \"GB2312\" \"\\0\"\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"eucKR\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"Big5\" \"\\0\" \"BIG5\" \"\\0\"\n           \"Big5HKSCS\" \"\\0\" \"BIG5-HKSCS\" \"\\0\"\n           \"GBK\" \"\\0\" \"GBK\" \"\\0\"\n           \"GB18030\" \"\\0\" \"GB18030\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"ARMSCII-8\" \"\\0\" \"ARMSCII-8\" \"\\0\"\n           \"PT154\" \"\\0\" \"PT154\" \"\\0\"\n         /*\"ISCII-DEV\" \"\\0\" \"?\" \"\\0\"*/\n           \"*\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n\n# if defined VMS\n      /* To avoid the troubles of an extra file charset.alias_vms in the\n         sources of many GNU packages, simply inline the aliases here.  */\n      /* The list of encodings is taken from the OpenVMS 7.3-1 documentation\n         \"Compaq C Run-Time Library Reference Manual for OpenVMS systems\"\n         section 10.7 \"Handling Different Character Sets\".  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-8\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           /* Japanese */\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"DECKANJI\" \"\\0\" \"DEC-KANJI\" \"\\0\"\n           \"SDECKANJI\" \"\\0\" \"EUC-JP\" \"\\0\"\n           /* Chinese */\n           \"eucTW\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"DECHANYU\" \"\\0\" \"DEC-HANYU\" \"\\0\"\n           \"DECHANZI\" \"\\0\" \"GB2312\" \"\\0\"\n           /* Korean */\n           \"DECKOREAN\" \"\\0\" \"EUC-KR\" \"\\0\";\n# endif\n\n# if defined WINDOWS_NATIVE || defined __CYGWIN__\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      cp = \"CP936\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP1361\" \"\\0\" \"JOHAB\" \"\\0\"\n           \"CP20127\" \"\\0\" \"ASCII\" \"\\0\"\n           \"CP20866\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP20936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP21866\" \"\\0\" \"KOI8-RU\" \"\\0\"\n           \"CP28591\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP28592\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP28593\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP28594\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP28595\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP28596\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP28597\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP28598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP28599\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP28605\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP38598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP51932\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP51936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP51949\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP51950\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP54936\" \"\\0\" \"GB18030\" \"\\0\"\n           \"CP65001\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n# if defined OS2\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      /* The list of encodings is taken from \"List of OS/2 Codepages\"\n         by Alex Taylor:\n         <http://altsan.org/os2/toolkits/uls/index.html#codepages>.\n         See also \"IBM Globalization - Code page identifiers\":\n         <http://www-01.ibm.com/software/globalization/cp/cp_cpgid.html>.  */\n      cp = \"CP813\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP878\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP819\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP912\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP913\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP914\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP915\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP916\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP920\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP921\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"CP923\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP954\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP964\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP970\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP1089\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP1208\" \"\\0\" \"UTF-8\" \"\\0\"\n           \"CP1381\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP1386\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP3372\" \"\\0\" \"EUC-JP\" \"\\0\";\n# endif\n#endif\n\n      charset_aliases = cp;\n    }\n\n  return cp;\n}",
      "lines": 262,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nget_charset_aliases (void)",
        "*"
      ]
    },
    "locale_charset": {
      "start_point": [
        395,
        0
      ],
      "end_point": [
        616,
        1
      ],
      "content": "const char *\nlocale_charset (void)\n{\n  const char *codeset;\n  const char *aliases;\n\n#if !(defined WINDOWS_NATIVE || defined OS2)\n\n# if HAVE_LANGINFO_CODESET\n\n  /* Most systems support nl_langinfo (CODESET) nowadays.  */\n  codeset = nl_langinfo (CODESET);\n\n#  ifdef __CYGWIN__\n  /* Cygwin < 1.7 does not have locales.  nl_langinfo (CODESET) always\n     returns \"US-ASCII\".  Return the suffix of the locale name from the\n     environment variables (if present) or the codepage as a number.  */\n  if (codeset != NULL && strcmp (codeset, \"US-ASCII\") == 0)\n    {\n      const char *locale;\n      static char buf[2 + 10 + 1];\n\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n      if (locale != NULL && locale[0] != '\\0')\n        {\n          /* If the locale name contains an encoding after the dot, return\n             it.  */\n          const char *dot = strchr (locale, '.');\n\n          if (dot != NULL)\n            {\n              const char *modifier;\n\n              dot++;\n              /* Look for the possible @... trailer and remove it, if any.  */\n              modifier = strchr (dot, '@');\n              if (modifier == NULL)\n                return dot;\n              if (modifier - dot < sizeof (buf))\n                {\n                  memcpy (buf, dot, modifier - dot);\n                  buf [modifier - dot] = '\\0';\n                  return buf;\n                }\n            }\n        }\n\n      /* The Windows API has a function returning the locale's codepage as a\n         number: GetACP().  This encoding is used by Cygwin, unless the user\n         has set the environment variable CYGWIN=codepage:oem (which very few\n         people do).\n         Output directed to console windows needs to be converted (to\n         GetOEMCP() if the console is using a raster font, or to\n         GetConsoleOutputCP() if it is using a TrueType font).  Cygwin does\n         this conversion transparently (see winsup/cygwin/fhandler_console.cc),\n         converting to GetConsoleOutputCP().  This leads to correct results,\n         except when SetConsoleOutputCP has been called and a raster font is\n         in use.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n      codeset = buf;\n    }\n#  endif\n\n# else\n\n  /* On old systems which lack it, use setlocale or getenv.  */\n  const char *locale = NULL;\n\n  /* But most old systems don't have a complete set of locales.  Some\n     (like SunOS 4 or DJGPP) have only the C locale.  Therefore we don't\n     use setlocale here; it would return \"C\" when it doesn't support the\n     locale name the user has set.  */\n#  if 0\n  locale = setlocale (LC_CTYPE, NULL);\n#  endif\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n    }\n\n  /* On some old systems, one used to set locale = \"iso8859_1\". On others,\n     you set it to \"language_COUNTRY.charset\". In any case, we resolve it\n     through the charset.alias file.  */\n  codeset = locale;\n\n# endif\n\n#elif defined WINDOWS_NATIVE\n\n  static char buf[2 + 10 + 1];\n\n  /* The Windows API has a function returning the locale's codepage as\n     a number, but the value doesn't change according to what the\n     'setlocale' call specified.  So we use it as a last resort, in\n     case the string returned by 'setlocale' doesn't specify the\n     codepage.  */\n  char *current_locale = setlocale (LC_ALL, NULL);\n  char *pdot;\n\n  /* If they set different locales for different categories,\n     'setlocale' will return a semi-colon separated list of locale\n     values.  To make sure we use the correct one, we choose LC_CTYPE.  */\n  if (strchr (current_locale, ';'))\n    current_locale = setlocale (LC_CTYPE, NULL);\n\n  pdot = strrchr (current_locale, '.');\n  if (pdot && 2 + strlen (pdot + 1) + 1 <= sizeof (buf))\n    sprintf (buf, \"CP%s\", pdot + 1);\n  else\n    {\n      /* The Windows API has a function returning the locale's codepage as a\n        number: GetACP().\n        When the output goes to a console window, it needs to be provided in\n        GetOEMCP() encoding if the console is using a raster font, or in\n        GetConsoleOutputCP() encoding if it is using a TrueType font.\n        But in GUI programs and for output sent to files and pipes, GetACP()\n        encoding is the best bet.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n    }\n  codeset = buf;\n\n#elif defined OS2\n\n  const char *locale;\n  static char buf[2 + 10 + 1];\n  ULONG cp[3];\n  ULONG cplen;\n\n  codeset = NULL;\n\n  /* Allow user to override the codeset, as set in the operating system,\n     with standard language environment variables.  */\n  locale = getenv (\"LC_ALL\");\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_CTYPE\");\n      if (locale == NULL || locale[0] == '\\0')\n        locale = getenv (\"LANG\");\n    }\n  if (locale != NULL && locale[0] != '\\0')\n    {\n      /* If the locale name contains an encoding after the dot, return it.  */\n      const char *dot = strchr (locale, '.');\n\n      if (dot != NULL)\n        {\n          const char *modifier;\n\n          dot++;\n          /* Look for the possible @... trailer and remove it, if any.  */\n          modifier = strchr (dot, '@');\n          if (modifier == NULL)\n            return dot;\n          if (modifier - dot < sizeof (buf))\n            {\n              memcpy (buf, dot, modifier - dot);\n              buf [modifier - dot] = '\\0';\n              return buf;\n            }\n        }\n\n      /* For the POSIX locale, don't use the system's codepage.  */\n      if (strcmp (locale, \"C\") == 0 || strcmp (locale, \"POSIX\") == 0)\n        codeset = \"\";\n    }\n\n  if (codeset == NULL)\n    {\n      /* OS/2 has a function returning the locale's codepage as a number.  */\n      if (DosQueryCp (sizeof (cp), cp, &cplen))\n        codeset = \"\";\n      else\n        {\n          sprintf (buf, \"CP%u\", cp[0]);\n          codeset = buf;\n        }\n    }\n\n#endif\n\n  if (codeset == NULL)\n    /* The canonical name cannot be determined.  */\n    codeset = \"\";\n\n  /* Resolve alias. */\n  for (aliases = get_charset_aliases ();\n       *aliases != '\\0';\n       aliases += strlen (aliases) + 1, aliases += strlen (aliases) + 1)\n    if (strcmp (codeset, aliases) == 0\n        || (aliases[0] == '*' && aliases[1] == '\\0'))\n      {\n        codeset = aliases + strlen (aliases) + 1;\n        break;\n      }\n\n  /* Don't return an empty string.  GNU libc and GNU libiconv interpret\n     the empty string as denoting \"the locale's character encoding\",\n     thus GNU libiconv would call this function a second time.  */\n  if (codeset[0] == '\\0')\n    codeset = \"ASCII\";\n\n#ifdef DARWIN7\n  /* Mac OS X sets MB_CUR_MAX to 1 when LC_ALL=C, and \"UTF-8\"\n     (the default codeset) does not work when MB_CUR_MAX is 1.  */\n  if (strcmp (codeset, \"UTF-8\") == 0 && MB_CUR_MAX_L (uselocale (NULL)) <= 1)\n    codeset = \"ASCII\";\n#endif\n\n  return codeset;\n}",
      "lines": 222,
      "depth": 18,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nlocale_charset (void)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/localcharset.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/locale.in.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/localeconv.c": {
    "localeconv": [
      {
        "start_point": [
          26,
          0
        ],
        "end_point": [
          60,
          1
        ],
        "content": "struct lconv *\nlocaleconv (void)\n{\n  static struct lconv result;\n# undef lconv\n# undef localeconv\n  struct lconv *sys_result = localeconv ();\n\n  result.decimal_point = sys_result->decimal_point;\n  result.thousands_sep = sys_result->thousands_sep;\n  result.grouping = sys_result->grouping;\n  result.mon_decimal_point = sys_result->mon_decimal_point;\n  result.mon_thousands_sep = sys_result->mon_thousands_sep;\n  result.mon_grouping = sys_result->mon_grouping;\n  result.positive_sign = sys_result->positive_sign;\n  result.negative_sign = sys_result->negative_sign;\n  result.currency_symbol = sys_result->currency_symbol;\n  result.frac_digits = sys_result->frac_digits;\n  result.p_cs_precedes = sys_result->p_cs_precedes;\n  result.p_sign_posn = sys_result->p_sign_posn;\n  result.p_sep_by_space = sys_result->p_sep_by_space;\n  result.n_cs_precedes = sys_result->n_cs_precedes;\n  result.n_sign_posn = sys_result->n_sign_posn;\n  result.n_sep_by_space = sys_result->n_sep_by_space;\n  result.int_curr_symbol = sys_result->int_curr_symbol;\n  result.int_frac_digits = sys_result->int_frac_digits;\n  result.int_p_cs_precedes = sys_result->p_cs_precedes;\n  result.int_p_sign_posn = sys_result->p_sign_posn;\n  result.int_p_sep_by_space = sys_result->p_sep_by_space;\n  result.int_n_cs_precedes = sys_result->n_cs_precedes;\n  result.int_n_sign_posn = sys_result->n_sign_posn;\n  result.int_n_sep_by_space = sys_result->n_sep_by_space;\n\n  return &result;\n}",
        "lines": 35,
        "depth": 7,
        "decorators": [
          "struct lconv",
          "struct",
          "lconv",
          "*\nlocaleconv (void)",
          "*"
        ]
      },
      {
        "start_point": [
          68,
          0
        ],
        "end_point": [
          100,
          1
        ],
        "content": "struct lconv *\nlocaleconv (void)\n{\n  static /*const*/ struct lconv result =\n    {\n      /* decimal_point */ \".\",\n      /* thousands_sep */ \"\",\n      /* grouping */ \"\",\n      /* mon_decimal_point */ \"\",\n      /* mon_thousands_sep */ \"\",\n      /* mon_grouping */ \"\",\n      /* positive_sign */ \"\",\n      /* negative_sign */ \"\",\n      /* currency_symbol */ \"\",\n      /* frac_digits */ CHAR_MAX,\n      /* p_cs_precedes */ CHAR_MAX,\n      /* p_sign_posn */ CHAR_MAX,\n      /* p_sep_by_space */ CHAR_MAX,\n      /* n_cs_precedes */ CHAR_MAX,\n      /* n_sign_posn */ CHAR_MAX,\n      /* n_sep_by_space */ CHAR_MAX,\n      /* int_curr_symbol */ \"\",\n      /* int_frac_digits */ CHAR_MAX,\n      /* int_p_cs_precedes */ CHAR_MAX,\n      /* int_p_sign_posn */ CHAR_MAX,\n      /* int_p_sep_by_space */ CHAR_MAX,\n      /* int_n_cs_precedes */ CHAR_MAX,\n      /* int_n_sign_posn */ CHAR_MAX,\n      /* int_n_sep_by_space */ CHAR_MAX\n    };\n\n  return &result;\n}",
        "lines": 33,
        "depth": 7,
        "decorators": [
          "struct lconv",
          "struct",
          "lconv",
          "*\nlocaleconv (void)",
          "*"
        ]
      }
    ]
  },
  "texinfo/texinfo-6.5/gnulib/lib/malloc.c": {
    "rpl_malloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void *\nrpl_malloc (size_t n)\n{\n  void *result;\n\n#if NEED_MALLOC_GNU\n  if (n == 0)\n    n = 1;\n#endif\n\n  result = malloc (n);\n\n#if !HAVE_MALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "void",
        "*\nrpl_malloc (size_t n)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/malloca.c": {
    "mmalloca": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "void *\nmmalloca (size_t n)\n{\n#if HAVE_ALLOCA\n  /* Allocate one more word, that serves as an indicator for malloc()ed\n     memory, so that freea() of an alloca() result is fast.  */\n  size_t nplus = n + HEADER_SIZE;\n\n  if (nplus >= n)\n    {\n      void *p = malloc (nplus);\n\n      if (p != NULL)\n        {\n          size_t slot;\n          union header *h = p;\n\n          p = h + 1;\n\n          /* Put a magic number into the indicator word.  */\n          h->magic.word = MAGIC_NUMBER;\n\n          /* Enter p into the hash table.  */\n          slot = (uintptr_t) p % HASH_TABLE_SIZE;\n          h->next = mmalloca_results[slot];\n          mmalloca_results[slot] = p;\n\n          return p;\n        }\n    }\n  /* Out of memory.  */\n  return NULL;\n#else\n# if !MALLOC_0_IS_NONNULL\n  if (n == 0)\n    n = 1;\n# endif\n  return malloc (n);\n#endif\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "void",
        "*\nmmalloca (size_t n)",
        "*"
      ]
    },
    "freea": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "void\nfreea (void *p)\n{\n  /* mmalloca() may have returned NULL.  */\n  if (p != NULL)\n    {\n      /* Attempt to quickly distinguish the mmalloca() result - which has\n         a magic indicator word - and the alloca() result - which has an\n         uninitialized indicator word.  It is for this test that sa_increment\n         additional bytes are allocated in the alloca() case.  */\n      if (((int *) p)[-1] == MAGIC_NUMBER)\n        {\n          /* Looks like a mmalloca() result.  To see whether it really is one,\n             perform a lookup in the hash table.  */\n          size_t slot = (uintptr_t) p % HASH_TABLE_SIZE;\n          void **chain = &mmalloca_results[slot];\n          for (; *chain != NULL;)\n            {\n              union header *h = p;\n              if (*chain == p)\n                {\n                  /* Found it.  Remove it from the hash table and free it.  */\n                  union header *p_begin = h - 1;\n                  *chain = p_begin->next;\n                  free (p_begin);\n                  return;\n                }\n              h = *chain;\n              chain = &h[-1].next;\n            }\n        }\n      /* At this point, we know it was not a mmalloca() result.  */\n    }\n}",
      "lines": 34,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/malloca.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/mbchar.c": {},
  "texinfo/texinfo-6.5/gnulib/lib/mbchar.h": {
    "mb_width_aux": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "MBCHAR_INLINE int\nmb_width_aux (wint_t wc)\n{\n  int w = wcwidth (wc);\n  /* For unprintable characters, arbitrarily return 0 for control characters\n     and MB_UNPRINTABLE_WIDTH otherwise.  */\n  return (w >= 0 ? w : iswcntrl (wc) ? 0 : MB_UNPRINTABLE_WIDTH);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "MBCHAR_INLINE",
        "int",
        "int"
      ]
    },
    "mb_copy": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        279,
        1
      ],
      "content": "MBCHAR_INLINE void\nmb_copy (mbchar_t *new_mbc, const mbchar_t *old_mbc)\n{\n  if (old_mbc->ptr == &old_mbc->buf[0])\n    {\n      memcpy (&new_mbc->buf[0], &old_mbc->buf[0], old_mbc->bytes);\n      new_mbc->ptr = &new_mbc->buf[0];\n    }\n  else\n    new_mbc->ptr = old_mbc->ptr;\n  new_mbc->bytes = old_mbc->bytes;\n  if ((new_mbc->wc_valid = old_mbc->wc_valid))\n    new_mbc->wc = old_mbc->wc;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "MBCHAR_INLINE",
        "void",
        "void"
      ]
    },
    "is_basic": [
      {
        "start_point": [
          314,
          0
        ],
        "end_point": [
          319,
          1
        ],
        "content": "MBCHAR_INLINE bool\nis_basic (char c)\n{\n  return (is_basic_table [(unsigned char) c >> 5] >> ((unsigned char) c & 31))\n         & 1;\n}",
        "lines": 6,
        "depth": 12,
        "decorators": [
          "MBCHAR_INLINE",
          "bool",
          "bool"
        ]
      },
      {
        "start_point": [
          323,
          0
        ],
        "end_point": [
          353,
          1
        ],
        "content": "MBCHAR_INLINE bool\nis_basic (char c)\n{\n  switch (c)\n    {\n    case '\\t': case '\\v': case '\\f':\n    case ' ': case '!': case '\"': case '#': case '%':\n    case '&': case '\\'': case '(': case ')': case '*':\n    case '+': case ',': case '-': case '.': case '/':\n    case '0': case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9':\n    case ':': case ';': case '<': case '=': case '>':\n    case '?':\n    case 'A': case 'B': case 'C': case 'D': case 'E':\n    case 'F': case 'G': case 'H': case 'I': case 'J':\n    case 'K': case 'L': case 'M': case 'N': case 'O':\n    case 'P': case 'Q': case 'R': case 'S': case 'T':\n    case 'U': case 'V': case 'W': case 'X': case 'Y':\n    case 'Z':\n    case '[': case '\\\\': case ']': case '^': case '_':\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'i': case 'j':\n    case 'k': case 'l': case 'm': case 'n': case 'o':\n    case 'p': case 'q': case 'r': case 's': case 't':\n    case 'u': case 'v': case 'w': case 'x': case 'y':\n    case 'z': case '{': case '|': case '}': case '~':\n      return 1;\n    default:\n      return 0;\n    }\n}",
        "lines": 31,
        "depth": 7,
        "decorators": [
          "MBCHAR_INLINE",
          "bool",
          "bool"
        ]
      }
    ]
  },
  "texinfo/texinfo-6.5/gnulib/lib/mbiter.c": {},
  "texinfo/texinfo-6.5/gnulib/lib/mbiter.h": {
    "mbiter_multi_next": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "MBITER_INLINE void\nmbiter_multi_next (struct mbiter_multi *iter)\n{\n  if (iter->next_done)\n    return;\n  if (iter->in_shift)\n    goto with_shift;\n  /* Handle most ASCII characters quickly, without calling mbrtowc().  */\n  if (is_basic (*iter->cur.ptr))\n    {\n      /* These characters are part of the basic character set.  ISO C 99\n         guarantees that their wide character code is identical to their\n         char code.  */\n      iter->cur.bytes = 1;\n      iter->cur.wc = *iter->cur.ptr;\n      iter->cur.wc_valid = true;\n    }\n  else\n    {\n      assert (mbsinit (&iter->state));\n      iter->in_shift = true;\n    with_shift:\n      iter->cur.bytes = mbrtowc (&iter->cur.wc, iter->cur.ptr,\n                                 iter->limit - iter->cur.ptr, &iter->state);\n      if (iter->cur.bytes == (size_t) -1)\n        {\n          /* An invalid multibyte sequence was encountered.  */\n          iter->cur.bytes = 1;\n          iter->cur.wc_valid = false;\n          /* Whether to set iter->in_shift = false and reset iter->state\n             or not is not very important; the string is bogus anyway.  */\n        }\n      else if (iter->cur.bytes == (size_t) -2)\n        {\n          /* An incomplete multibyte character at the end.  */\n          iter->cur.bytes = iter->limit - iter->cur.ptr;\n          iter->cur.wc_valid = false;\n          /* Whether to set iter->in_shift = false and reset iter->state\n             or not is not important; the string end is reached anyway.  */\n        }\n      else\n        {\n          if (iter->cur.bytes == 0)\n            {\n              /* A null wide character was encountered.  */\n              iter->cur.bytes = 1;\n              assert (*iter->cur.ptr == '\\0');\n              assert (iter->cur.wc == 0);\n            }\n          iter->cur.wc_valid = true;\n\n          /* When in the initial state, we can go back treating ASCII\n             characters more quickly.  */\n          if (mbsinit (&iter->state))\n            iter->in_shift = false;\n        }\n    }\n  iter->next_done = true;\n}",
      "lines": 59,
      "depth": 17,
      "decorators": [
        "MBITER_INLINE",
        "void",
        "void"
      ]
    },
    "mbiter_multi_reloc": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "MBITER_INLINE void\nmbiter_multi_reloc (struct mbiter_multi *iter, ptrdiff_t ptrdiff)\n{\n  iter->cur.ptr += ptrdiff;\n  iter->limit += ptrdiff;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "MBITER_INLINE",
        "void",
        "void"
      ]
    },
    "mbiter_multi_copy": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "MBITER_INLINE void\nmbiter_multi_copy (struct mbiter_multi *new_iter, const struct mbiter_multi *old_iter)\n{\n  new_iter->limit = old_iter->limit;\n  if ((new_iter->in_shift = old_iter->in_shift))\n    memcpy (&new_iter->state, &old_iter->state, sizeof (mbstate_t));\n  else\n    memset (&new_iter->state, 0, sizeof (mbstate_t));\n  new_iter->next_done = old_iter->next_done;\n  mb_copy (&new_iter->cur, &old_iter->cur);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "MBITER_INLINE",
        "void",
        "void"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/mbrtowc.c": {
    "mbrtowc": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        332,
        1
      ],
      "content": "size_t\nmbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n  char *pstate = (char *)ps;\n\n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n\n  if (n == 0)\n    return (size_t)(-2);\n\n  /* Here n > 0.  */\n\n  if (pstate == NULL)\n    pstate = internal_state;\n\n  {\n    size_t nstate = pstate[0];\n    char buf[4];\n    const char *p;\n    size_t m;\n\n    switch (nstate)\n      {\n      case 0:\n        p = s;\n        m = n;\n        break;\n      case 3:\n        buf[2] = pstate[3];\n        FALLTHROUGH;\n      case 2:\n        buf[1] = pstate[2];\n        FALLTHROUGH;\n      case 1:\n        buf[0] = pstate[1];\n        p = buf;\n        m = nstate;\n        buf[m++] = s[0];\n        if (n >= 2 && m < 4)\n          {\n            buf[m++] = s[1];\n            if (n >= 3 && m < 4)\n              buf[m++] = s[2];\n          }\n        break;\n      default:\n        errno = EINVAL;\n        return (size_t)(-1);\n      }\n\n    /* Here m > 0.  */\n\n# if __GLIBC__ || defined __UCLIBC__\n    /* Work around bug <http://sourceware.org/bugzilla/show_bug.cgi?id=9674> */\n    mbtowc (NULL, NULL, 0);\n# endif\n    {\n      int res = mbtowc (pwc, p, m);\n\n      if (res >= 0)\n        {\n          if (pwc != NULL && ((*pwc == 0) != (res == 0)))\n            abort ();\n          if (nstate >= (res > 0 ? res : 1))\n            abort ();\n          res -= nstate;\n          pstate[0] = 0;\n          return res;\n        }\n\n      /* mbtowc does not distinguish between invalid and incomplete multibyte\n         sequences.  But mbrtowc needs to make this distinction.\n         There are two possible approaches:\n           - Use iconv() and its return value.\n           - Use built-in knowledge about the possible encodings.\n         Given the low quality of implementation of iconv() on the systems that\n         lack mbrtowc(), we use the second approach.\n         The possible encodings are:\n           - 8-bit encodings,\n           - EUC-JP, EUC-KR, GB2312, EUC-TW, BIG5, GB18030, SJIS,\n           - UTF-8.\n         Use specialized code for each.  */\n      if (m >= 4 || m >= MB_CUR_MAX)\n        goto invalid;\n      /* Here MB_CUR_MAX > 1 and 0 < m < 4.  */\n      {\n        const char *encoding = locale_charset ();\n\n        if (STREQ_OPT (encoding, \"UTF-8\", 'U', 'T', 'F', '-', '8', 0, 0, 0, 0))\n          {\n            /* Cf. unistr/u8-mblen.c.  */\n            unsigned char c = (unsigned char) p[0];\n\n            if (c >= 0xc2)\n              {\n                if (c < 0xe0)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                  }\n                else if (c < 0xf0)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                    if (m == 2)\n                      {\n                        unsigned char c2 = (unsigned char) p[1];\n\n                        if ((c2 ^ 0x80) < 0x40\n                            && (c >= 0xe1 || c2 >= 0xa0)\n                            && (c != 0xed || c2 < 0xa0))\n                          goto incomplete;\n                      }\n                  }\n                else if (c <= 0xf4)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                    else /* m == 2 || m == 3 */\n                      {\n                        unsigned char c2 = (unsigned char) p[1];\n\n                        if ((c2 ^ 0x80) < 0x40\n                            && (c >= 0xf1 || c2 >= 0x90)\n                            && (c < 0xf4 || (c == 0xf4 && c2 < 0x90)))\n                          {\n                            if (m == 2)\n                              goto incomplete;\n                            else /* m == 3 */\n                              {\n                                unsigned char c3 = (unsigned char) p[2];\n\n                                if ((c3 ^ 0x80) < 0x40)\n                                  goto incomplete;\n                              }\n                          }\n                      }\n                  }\n              }\n            goto invalid;\n          }\n\n        /* As a reference for this code, you can use the GNU libiconv\n           implementation.  Look for uses of the RET_TOOFEW macro.  */\n\n        if (STREQ_OPT (encoding,\n                       \"EUC-JP\", 'E', 'U', 'C', '-', 'J', 'P', 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0xa1 && c < 0xff) || c == 0x8e || c == 0x8f)\n                  goto incomplete;\n              }\n            if (m == 2)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c == 0x8f)\n                  {\n                    unsigned char c2 = (unsigned char) p[1];\n\n                    if (c2 >= 0xa1 && c2 < 0xff)\n                      goto incomplete;\n                  }\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"EUC-KR\", 'E', 'U', 'C', '-', 'K', 'R', 0, 0, 0)\n            || STREQ_OPT (encoding,\n                          \"GB2312\", 'G', 'B', '2', '3', '1', '2', 0, 0, 0)\n            || STREQ_OPT (encoding,\n                          \"BIG5\", 'B', 'I', 'G', '5', 0, 0, 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c >= 0xa1 && c < 0xff)\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"EUC-TW\", 'E', 'U', 'C', '-', 'T', 'W', 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0xa1 && c < 0xff) || c == 0x8e)\n                  goto incomplete;\n              }\n            else /* m == 2 || m == 3 */\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c == 0x8e)\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"GB18030\", 'G', 'B', '1', '8', '0', '3', '0', 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0x90 && c <= 0xe3) || (c >= 0xf8 && c <= 0xfe))\n                  goto incomplete;\n              }\n            else /* m == 2 || m == 3 */\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c >= 0x90 && c <= 0xe3)\n                  {\n                    unsigned char c2 = (unsigned char) p[1];\n\n                    if (c2 >= 0x30 && c2 <= 0x39)\n                      {\n                        if (m == 2)\n                          goto incomplete;\n                        else /* m == 3 */\n                          {\n                            unsigned char c3 = (unsigned char) p[2];\n\n                            if (c3 >= 0x81 && c3 <= 0xfe)\n                              goto incomplete;\n                          }\n                      }\n                  }\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding, \"SJIS\", 'S', 'J', 'I', 'S', 0, 0, 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0x81 && c <= 0x9f) || (c >= 0xe0 && c <= 0xea)\n                    || (c >= 0xf0 && c <= 0xf9))\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n\n        /* An unknown multibyte encoding.  */\n        goto incomplete;\n      }\n\n     incomplete:\n      {\n        size_t k = nstate;\n        /* Here 0 <= k < m < 4.  */\n        pstate[++k] = s[0];\n        if (k < m)\n          {\n            pstate[++k] = s[1];\n            if (k < m)\n              pstate[++k] = s[2];\n          }\n        if (k != m)\n          abort ();\n      }\n      pstate[0] = m;\n      return (size_t)(-2);\n\n     invalid:\n      errno = EILSEQ;\n      /* The conversion state is undefined, says POSIX.  */\n      return (size_t)(-1);\n    }\n  }\n}",
      "lines": 284,
      "depth": 25,
      "decorators": [
        "size_t"
      ]
    },
    "rpl_mbrtowc": {
      "start_point": [
        339,
        0
      ],
      "end_point": [
        411,
        1
      ],
      "content": "size_t\nrpl_mbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n  size_t ret;\n  wchar_t wc;\n\n# if MBRTOWC_NULL_ARG2_BUG || MBRTOWC_RETVAL_BUG || MBRTOWC_EMPTY_INPUT_BUG\n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n# endif\n\n# if MBRTOWC_EMPTY_INPUT_BUG\n  if (n == 0)\n    return (size_t) -2;\n# endif\n\n  if (! pwc)\n    pwc = &wc;\n\n# if MBRTOWC_RETVAL_BUG\n  {\n    static mbstate_t internal_state;\n\n    /* Override mbrtowc's internal state.  We cannot call mbsinit() on the\n       hidden internal state, but we can call it on our variable.  */\n    if (ps == NULL)\n      ps = &internal_state;\n\n    if (!mbsinit (ps))\n      {\n        /* Parse the rest of the multibyte character byte for byte.  */\n        size_t count = 0;\n        for (; n > 0; s++, n--)\n          {\n            ret = mbrtowc (&wc, s, 1, ps);\n\n            if (ret == (size_t)(-1))\n              return (size_t)(-1);\n            count++;\n            if (ret != (size_t)(-2))\n              {\n                /* The multibyte character has been completed.  */\n                *pwc = wc;\n                return (wc == 0 ? 0 : count);\n              }\n          }\n        return (size_t)(-2);\n      }\n  }\n# endif\n\n  ret = mbrtowc (pwc, s, n, ps);\n\n# if MBRTOWC_NUL_RETVAL_BUG\n  if (ret < (size_t) -2 && !*pwc)\n    return 0;\n# endif\n\n# if C_LOCALE_MAYBE_EILSEQ\n  if ((size_t) -2 <= ret && n != 0 && ! hard_locale (LC_CTYPE))\n    {\n      unsigned char uc = *s;\n      *pwc = uc;\n      return 1;\n    }\n# endif\n\n  return ret;\n}",
      "lines": 73,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/mbscasecmp.c": {
    "mbscasecmp": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "int\nmbscasecmp (const char *s1, const char *s2)\n{\n  if (s1 == s2)\n    return 0;\n\n  /* Be careful not to look at the entire extent of s1 or s2 until needed.\n     This is useful because when two strings differ, the difference is\n     most often already in the very few first characters.  */\n  if (MB_CUR_MAX > 1)\n    {\n      mbui_iterator_t iter1;\n      mbui_iterator_t iter2;\n\n      mbui_init (iter1, s1);\n      mbui_init (iter2, s2);\n\n      while (mbui_avail (iter1) && mbui_avail (iter2))\n        {\n          int cmp = mb_casecmp (mbui_cur (iter1), mbui_cur (iter2));\n\n          if (cmp != 0)\n            return cmp;\n\n          mbui_advance (iter1);\n          mbui_advance (iter2);\n        }\n      if (mbui_avail (iter1))\n        /* s2 terminated before s1.  */\n        return 1;\n      if (mbui_avail (iter2))\n        /* s1 terminated before s2.  */\n        return -1;\n      return 0;\n    }\n  else\n    {\n      const unsigned char *p1 = (const unsigned char *) s1;\n      const unsigned char *p2 = (const unsigned char *) s2;\n      unsigned char c1, c2;\n\n      do\n        {\n          c1 = TOLOWER (*p1);\n          c2 = TOLOWER (*p2);\n\n          if (c1 == '\\0')\n            break;\n\n          ++p1;\n          ++p2;\n        }\n      while (c1 == c2);\n\n      if (UCHAR_MAX <= INT_MAX)\n        return c1 - c2;\n      else\n        /* On machines where 'char' and 'int' are types of the same size, the\n           difference of two 'unsigned char' values - including the sign bit -\n           doesn't fit in an 'int'.  */\n        return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n    }\n}",
      "lines": 63,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/mbschr.c": {
    "mbschr": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "char *\nmbschr (const char *string, int c)\n{\n  if (MB_CUR_MAX > 1\n      /* Optimization: We know that ASCII characters < 0x30 don't occur as\n         part of multibyte characters longer than 1 byte.  Hence, if c < 0x30,\n         the faster unibyte loop can be used.  */\n      && (unsigned char) c >= 0x30)\n    {\n      mbui_iterator_t iter;\n\n      for (mbui_init (iter, string);; mbui_advance (iter))\n        {\n          if (!mbui_avail (iter))\n            goto notfound;\n          if (mb_len (mbui_cur (iter)) == 1\n              && (unsigned char) * mbui_cur_ptr (iter) == (unsigned char) c)\n            break;\n        }\n      return (char *) mbui_cur_ptr (iter);\n     notfound:\n      return NULL;\n    }\n  else\n    return strchr (string, c);\n}",
      "lines": 26,
      "depth": 15,
      "decorators": [
        "char",
        "*\nmbschr (const char *string, int c)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/mbsinit.c": {
    "mbsinit": [
      {
        "start_point": [
          43,
          0
        ],
        "end_point": [
          49,
          1
        ],
        "content": "int\nmbsinit (const mbstate_t *ps)\n{\n  const char *pstate = (const char *)ps;\n\n  return pstate == NULL || pstate[0] == 0;\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          53,
          0
        ],
        "end_point": [
          70,
          1
        ],
        "content": "int\nmbsinit (const mbstate_t *ps)\n{\n# if (defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__\n  /* Native Windows.  */\n#  ifdef __MINGW32__\n  /* On mingw, 'mbstate_t' is defined as 'int'.  */\n  return ps == NULL || *ps == 0;\n#  else\n  /* MSVC defines 'mbstate_t' as an 8-byte struct; the first 4-bytes matter.  */\n  return ps == NULL || *(const unsigned int *)ps == 0;\n#  endif\n# else\n  /* Minix, HP-UX 11.00, Solaris 2.6, Interix, ...  */\n  /* Maybe this definition works, maybe not...  */\n  return ps == NULL || *(const char *)ps == 0;\n# endif\n}",
        "lines": 18,
        "depth": 13,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "texinfo/texinfo-6.5/gnulib/lib/mbslen.c": {
    "mbslen": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "size_t\nmbslen (const char *string)\n{\n  if (MB_CUR_MAX > 1)\n    {\n      size_t count;\n      mbui_iterator_t iter;\n\n      count = 0;\n      for (mbui_init (iter, string); mbui_avail (iter); mbui_advance (iter))\n        count++;\n\n      return count;\n    }\n  else\n    return strlen (string);\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/mbsncasecmp.c": {
    "mbsncasecmp": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "int\nmbsncasecmp (const char *s1, const char *s2, size_t n)\n{\n  if (s1 == s2 || n == 0)\n    return 0;\n\n  /* Be careful not to look at the entire extent of s1 or s2 until needed.\n     This is useful because when two strings differ, the difference is\n     most often already in the very few first characters.  */\n  if (MB_CUR_MAX > 1)\n    {\n      mbui_iterator_t iter1;\n      mbui_iterator_t iter2;\n\n      mbui_init (iter1, s1);\n      mbui_init (iter2, s2);\n\n      while (mbui_avail (iter1) && mbui_avail (iter2))\n        {\n          int cmp = mb_casecmp (mbui_cur (iter1), mbui_cur (iter2));\n\n          if (cmp != 0)\n            return cmp;\n\n          if (--n == 0)\n            return 0;\n\n          mbui_advance (iter1);\n          mbui_advance (iter2);\n        }\n      if (mbui_avail (iter1))\n        /* s2 terminated before s1 and n.  */\n        return 1;\n      if (mbui_avail (iter2))\n        /* s1 terminated before s2 and n.  */\n        return -1;\n      return 0;\n    }\n  else\n    {\n      const unsigned char *p1 = (const unsigned char *) s1;\n      const unsigned char *p2 = (const unsigned char *) s2;\n      unsigned char c1, c2;\n\n      for (; ; p1++, p2++)\n        {\n          c1 = TOLOWER (*p1);\n          c2 = TOLOWER (*p2);\n\n          if (--n == 0 || c1 == '\\0' || c1 != c2)\n            break;\n        }\n\n      if (UCHAR_MAX <= INT_MAX)\n        return c1 - c2;\n      else\n        /* On machines where 'char' and 'int' are types of the same size, the\n           difference of two 'unsigned char' values - including the sign bit -\n           doesn't fit in an 'int'.  */\n        return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n    }\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/mbsstr.c": {
    "knuth_morris_pratt_multibyte": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "static bool\nknuth_morris_pratt_multibyte (const char *haystack, const char *needle,\n                              const char **resultp)\n{\n  size_t m = mbslen (needle);\n  mbchar_t *needle_mbchars;\n  size_t *table;\n\n  /* Allocate room for needle_mbchars and the table.  */\n  void *memory = nmalloca (m, sizeof (mbchar_t) + sizeof (size_t));\n  void *table_memory;\n  if (memory == NULL)\n    return false;\n  needle_mbchars = memory;\n  table_memory = needle_mbchars + m;\n  table = table_memory;\n\n  /* Fill needle_mbchars.  */\n  {\n    mbui_iterator_t iter;\n    size_t j;\n\n    j = 0;\n    for (mbui_init (iter, needle); mbui_avail (iter); mbui_advance (iter), j++)\n      mb_copy (&needle_mbchars[j], &mbui_cur (iter));\n  }\n\n  /* Fill the table.\n     For 0 < i < m:\n       0 < table[i] <= i is defined such that\n       forall 0 < x < table[i]: needle[x..i-1] != needle[0..i-1-x],\n       and table[i] is as large as possible with this property.\n     This implies:\n     1) For 0 < i < m:\n          If table[i] < i,\n          needle[table[i]..i-1] = needle[0..i-1-table[i]].\n     2) For 0 < i < m:\n          rhaystack[0..i-1] == needle[0..i-1]\n          and exists h, i <= h < m: rhaystack[h] != needle[h]\n          implies\n          forall 0 <= x < table[i]: rhaystack[x..x+m-1] != needle[0..m-1].\n     table[0] remains uninitialized.  */\n  {\n    size_t i, j;\n\n    /* i = 1: Nothing to verify for x = 0.  */\n    table[1] = 1;\n    j = 0;\n\n    for (i = 2; i < m; i++)\n      {\n        /* Here: j = i-1 - table[i-1].\n           The inequality needle[x..i-1] != needle[0..i-1-x] is known to hold\n           for x < table[i-1], by induction.\n           Furthermore, if j>0: needle[i-1-j..i-2] = needle[0..j-1].  */\n        mbchar_t *b = &needle_mbchars[i - 1];\n\n        for (;;)\n          {\n            /* Invariants: The inequality needle[x..i-1] != needle[0..i-1-x]\n               is known to hold for x < i-1-j.\n               Furthermore, if j>0: needle[i-1-j..i-2] = needle[0..j-1].  */\n            if (mb_equal (*b, needle_mbchars[j]))\n              {\n                /* Set table[i] := i-1-j.  */\n                table[i] = i - ++j;\n                break;\n              }\n            /* The inequality needle[x..i-1] != needle[0..i-1-x] also holds\n               for x = i-1-j, because\n                 needle[i-1] != needle[j] = needle[i-1-x].  */\n            if (j == 0)\n              {\n                /* The inequality holds for all possible x.  */\n                table[i] = i;\n                break;\n              }\n            /* The inequality needle[x..i-1] != needle[0..i-1-x] also holds\n               for i-1-j < x < i-1-j+table[j], because for these x:\n                 needle[x..i-2]\n                 = needle[x-(i-1-j)..j-1]\n                 != needle[0..j-1-(x-(i-1-j))]  (by definition of table[j])\n                    = needle[0..i-2-x],\n               hence needle[x..i-1] != needle[0..i-1-x].\n               Furthermore\n                 needle[i-1-j+table[j]..i-2]\n                 = needle[table[j]..j-1]\n                 = needle[0..j-1-table[j]]  (by definition of table[j]).  */\n            j = j - table[j];\n          }\n        /* Here: j = i - table[i].  */\n      }\n  }\n\n  /* Search, using the table to accelerate the processing.  */\n  {\n    size_t j;\n    mbui_iterator_t rhaystack;\n    mbui_iterator_t phaystack;\n\n    *resultp = NULL;\n    j = 0;\n    mbui_init (rhaystack, haystack);\n    mbui_init (phaystack, haystack);\n    /* Invariant: phaystack = rhaystack + j.  */\n    while (mbui_avail (phaystack))\n      if (mb_equal (needle_mbchars[j], mbui_cur (phaystack)))\n        {\n          j++;\n          mbui_advance (phaystack);\n          if (j == m)\n            {\n              /* The entire needle has been found.  */\n              *resultp = mbui_cur_ptr (rhaystack);\n              break;\n            }\n        }\n      else if (j > 0)\n        {\n          /* Found a match of needle[0..j-1], mismatch at needle[j].  */\n          size_t count = table[j];\n          j -= count;\n          for (; count > 0; count--)\n            {\n              if (!mbui_avail (rhaystack))\n                abort ();\n              mbui_advance (rhaystack);\n            }\n        }\n      else\n        {\n          /* Found a mismatch at needle[0] already.  */\n          if (!mbui_avail (rhaystack))\n            abort ();\n          mbui_advance (rhaystack);\n          mbui_advance (phaystack);\n        }\n  }\n\n  freea (memory);\n  return true;\n}",
      "lines": 142,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "mbsstr": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        383,
        1
      ],
      "content": "char *\nmbsstr (const char *haystack, const char *needle)\n{\n  /* Be careful not to look at the entire extent of haystack or needle\n     until needed.  This is useful because of these two cases:\n       - haystack may be very long, and a match of needle found early,\n       - needle may be very long, and not even a short initial segment of\n         needle may be found in haystack.  */\n  if (MB_CUR_MAX > 1)\n    {\n      mbui_iterator_t iter_needle;\n\n      mbui_init (iter_needle, needle);\n      if (mbui_avail (iter_needle))\n        {\n          /* Minimizing the worst-case complexity:\n             Let n = mbslen(haystack), m = mbslen(needle).\n             The na\u00c3\u00afve algorithm is O(n*m) worst-case.\n             The Knuth-Morris-Pratt algorithm is O(n) worst-case but it needs a\n             memory allocation.\n             To achieve linear complexity and yet amortize the cost of the\n             memory allocation, we activate the Knuth-Morris-Pratt algorithm\n             only once the na\u00c3\u00afve algorithm has already run for some time; more\n             precisely, when\n               - the outer loop count is >= 10,\n               - the average number of comparisons per outer loop is >= 5,\n               - the total number of comparisons is >= m.\n             But we try it only once.  If the memory allocation attempt failed,\n             we don't retry it.  */\n          bool try_kmp = true;\n          size_t outer_loop_count = 0;\n          size_t comparison_count = 0;\n          size_t last_ccount = 0;                  /* last comparison count */\n          mbui_iterator_t iter_needle_last_ccount; /* = needle + last_ccount */\n\n          mbui_iterator_t iter_haystack;\n\n          mbui_init (iter_needle_last_ccount, needle);\n          mbui_init (iter_haystack, haystack);\n          for (;; mbui_advance (iter_haystack))\n            {\n              if (!mbui_avail (iter_haystack))\n                /* No match.  */\n                return NULL;\n\n              /* See whether it's advisable to use an asymptotically faster\n                 algorithm.  */\n              if (try_kmp\n                  && outer_loop_count >= 10\n                  && comparison_count >= 5 * outer_loop_count)\n                {\n                  /* See if needle + comparison_count now reaches the end of\n                     needle.  */\n                  size_t count = comparison_count - last_ccount;\n                  for (;\n                       count > 0 && mbui_avail (iter_needle_last_ccount);\n                       count--)\n                    mbui_advance (iter_needle_last_ccount);\n                  last_ccount = comparison_count;\n                  if (!mbui_avail (iter_needle_last_ccount))\n                    {\n                      /* Try the Knuth-Morris-Pratt algorithm.  */\n                      const char *result;\n                      bool success =\n                        knuth_morris_pratt_multibyte (haystack, needle,\n                                                      &result);\n                      if (success)\n                        return (char *) result;\n                      try_kmp = false;\n                    }\n                }\n\n              outer_loop_count++;\n              comparison_count++;\n              if (mb_equal (mbui_cur (iter_haystack), mbui_cur (iter_needle)))\n                /* The first character matches.  */\n                {\n                  mbui_iterator_t rhaystack;\n                  mbui_iterator_t rneedle;\n\n                  memcpy (&rhaystack, &iter_haystack, sizeof (mbui_iterator_t));\n                  mbui_advance (rhaystack);\n\n                  mbui_init (rneedle, needle);\n                  if (!mbui_avail (rneedle))\n                    abort ();\n                  mbui_advance (rneedle);\n\n                  for (;; mbui_advance (rhaystack), mbui_advance (rneedle))\n                    {\n                      if (!mbui_avail (rneedle))\n                        /* Found a match.  */\n                        return (char *) mbui_cur_ptr (iter_haystack);\n                      if (!mbui_avail (rhaystack))\n                        /* No match.  */\n                        return NULL;\n                      comparison_count++;\n                      if (!mb_equal (mbui_cur (rhaystack), mbui_cur (rneedle)))\n                        /* Nothing in this round.  */\n                        break;\n                    }\n                }\n            }\n        }\n      else\n        return (char *) haystack;\n    }\n  else\n    {\n      if (*needle != '\\0')\n        {\n          /* Minimizing the worst-case complexity:\n             Let n = strlen(haystack), m = strlen(needle).\n             The na\u00c3\u00afve algorithm is O(n*m) worst-case.\n             The Knuth-Morris-Pratt algorithm is O(n) worst-case but it needs a\n             memory allocation.\n             To achieve linear complexity and yet amortize the cost of the\n             memory allocation, we activate the Knuth-Morris-Pratt algorithm\n             only once the na\u00c3\u00afve algorithm has already run for some time; more\n             precisely, when\n               - the outer loop count is >= 10,\n               - the average number of comparisons per outer loop is >= 5,\n               - the total number of comparisons is >= m.\n             But we try it only once.  If the memory allocation attempt failed,\n             we don't retry it.  */\n          bool try_kmp = true;\n          size_t outer_loop_count = 0;\n          size_t comparison_count = 0;\n          size_t last_ccount = 0;                  /* last comparison count */\n          const char *needle_last_ccount = needle; /* = needle + last_ccount */\n\n          /* Speed up the following searches of needle by caching its first\n             character.  */\n          char b = *needle++;\n\n          for (;; haystack++)\n            {\n              if (*haystack == '\\0')\n                /* No match.  */\n                return NULL;\n\n              /* See whether it's advisable to use an asymptotically faster\n                 algorithm.  */\n              if (try_kmp\n                  && outer_loop_count >= 10\n                  && comparison_count >= 5 * outer_loop_count)\n                {\n                  /* See if needle + comparison_count now reaches the end of\n                     needle.  */\n                  if (needle_last_ccount != NULL)\n                    {\n                      needle_last_ccount +=\n                        strnlen (needle_last_ccount,\n                                 comparison_count - last_ccount);\n                      if (*needle_last_ccount == '\\0')\n                        needle_last_ccount = NULL;\n                      last_ccount = comparison_count;\n                    }\n                  if (needle_last_ccount == NULL)\n                    {\n                      /* Try the Knuth-Morris-Pratt algorithm.  */\n                      const unsigned char *result;\n                      bool success =\n                        knuth_morris_pratt ((const unsigned char *) haystack,\n                                            (const unsigned char *) (needle - 1),\n                                            strlen (needle - 1),\n                                            &result);\n                      if (success)\n                        return (char *) result;\n                      try_kmp = false;\n                    }\n                }\n\n              outer_loop_count++;\n              comparison_count++;\n              if (*haystack == b)\n                /* The first character matches.  */\n                {\n                  const char *rhaystack = haystack + 1;\n                  const char *rneedle = needle;\n\n                  for (;; rhaystack++, rneedle++)\n                    {\n                      if (*rneedle == '\\0')\n                        /* Found a match.  */\n                        return (char *) haystack;\n                      if (*rhaystack == '\\0')\n                        /* No match.  */\n                        return NULL;\n                      comparison_count++;\n                      if (*rhaystack != *rneedle)\n                        /* Nothing in this round.  */\n                        break;\n                    }\n                }\n            }\n        }\n      else\n        return (char *) haystack;\n    }\n}",
      "lines": 201,
      "depth": 20,
      "decorators": [
        "char",
        "*\nmbsstr (const char *haystack, const char *needle)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/mbswidth.c": {
    "mbswidth": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nmbswidth (const char *string, int flags)\n{\n  return mbsnwidth (string, strlen (string), flags);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "mbsnwidth": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "int\nmbsnwidth (const char *string, size_t nbytes, int flags)\n{\n  const char *p = string;\n  const char *plimit = p + nbytes;\n  int width;\n\n  width = 0;\n  if (MB_CUR_MAX > 1)\n    {\n      while (p < plimit)\n        switch (*p)\n          {\n            case ' ': case '!': case '\"': case '#': case '%':\n            case '&': case '\\'': case '(': case ')': case '*':\n            case '+': case ',': case '-': case '.': case '/':\n            case '0': case '1': case '2': case '3': case '4':\n            case '5': case '6': case '7': case '8': case '9':\n            case ':': case ';': case '<': case '=': case '>':\n            case '?':\n            case 'A': case 'B': case 'C': case 'D': case 'E':\n            case 'F': case 'G': case 'H': case 'I': case 'J':\n            case 'K': case 'L': case 'M': case 'N': case 'O':\n            case 'P': case 'Q': case 'R': case 'S': case 'T':\n            case 'U': case 'V': case 'W': case 'X': case 'Y':\n            case 'Z':\n            case '[': case '\\\\': case ']': case '^': case '_':\n            case 'a': case 'b': case 'c': case 'd': case 'e':\n            case 'f': case 'g': case 'h': case 'i': case 'j':\n            case 'k': case 'l': case 'm': case 'n': case 'o':\n            case 'p': case 'q': case 'r': case 's': case 't':\n            case 'u': case 'v': case 'w': case 'x': case 'y':\n            case 'z': case '{': case '|': case '}': case '~':\n              /* These characters are printable ASCII characters.  */\n              p++;\n              width++;\n              break;\n            default:\n              /* If we have a multibyte sequence, scan it up to its end.  */\n              {\n                mbstate_t mbstate;\n                memset (&mbstate, 0, sizeof mbstate);\n                do\n                  {\n                    wchar_t wc;\n                    size_t bytes;\n                    int w;\n\n                    bytes = mbrtowc (&wc, p, plimit - p, &mbstate);\n\n                    if (bytes == (size_t) -1)\n                      /* An invalid multibyte sequence was encountered.  */\n                      {\n                        if (!(flags & MBSW_REJECT_INVALID))\n                          {\n                            p++;\n                            width++;\n                            break;\n                          }\n                        else\n                          return -1;\n                      }\n\n                    if (bytes == (size_t) -2)\n                      /* An incomplete multibyte character at the end.  */\n                      {\n                        if (!(flags & MBSW_REJECT_INVALID))\n                          {\n                            p = plimit;\n                            width++;\n                            break;\n                          }\n                        else\n                          return -1;\n                      }\n\n                    if (bytes == 0)\n                      /* A null wide character was encountered.  */\n                      bytes = 1;\n\n                    w = wcwidth (wc);\n                    if (w >= 0)\n                      /* A printable multibyte character.  */\n                      {\n                        if (w > INT_MAX - width)\n                          goto overflow;\n                        width += w;\n                      }\n                    else\n                      /* An unprintable multibyte character.  */\n                      if (!(flags & MBSW_REJECT_UNPRINTABLE))\n                        {\n                          if (!iswcntrl (wc))\n                            {\n                              if (width == INT_MAX)\n                                goto overflow;\n                              width++;\n                            }\n                        }\n                      else\n                        return -1;\n\n                    p += bytes;\n                  }\n                while (! mbsinit (&mbstate));\n              }\n              break;\n          }\n      return width;\n    }\n\n  while (p < plimit)\n    {\n      unsigned char c = (unsigned char) *p++;\n\n      if (isprint (c))\n        {\n          if (width == INT_MAX)\n            goto overflow;\n          width++;\n        }\n      else if (!(flags & MBSW_REJECT_UNPRINTABLE))\n        {\n          if (!iscntrl (c))\n            {\n              if (width == INT_MAX)\n                goto overflow;\n              width++;\n            }\n        }\n      else\n        return -1;\n    }\n  return width;\n\n overflow:\n  return INT_MAX;\n}",
      "lines": 138,
      "depth": 20,
      "decorators": [
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/mbswidth.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/mbtowc-impl.h": {
    "mbtowc": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nmbtowc (wchar_t *pwc, const char *s, size_t n)\n{\n  if (s == NULL)\n    return 0;\n  else\n    {\n      mbstate_t state;\n      wchar_t wc;\n      size_t result;\n\n      memset (&state, 0, sizeof (mbstate_t));\n      result = mbrtowc (&wc, s, n, &state);\n      if (result == (size_t)-1 || result == (size_t)-2)\n        {\n          errno = EILSEQ;\n          return -1;\n        }\n      if (pwc != NULL)\n        *pwc = wc;\n      return (wc == 0 ? 0 : result);\n    }\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/mbtowc.c": {},
  "texinfo/texinfo-6.5/gnulib/lib/mbuiter.c": {},
  "texinfo/texinfo-6.5/gnulib/lib/mbuiter.h": {
    "mbuiter_multi_next": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "MBUITER_INLINE void\nmbuiter_multi_next (struct mbuiter_multi *iter)\n{\n  if (iter->next_done)\n    return;\n  if (iter->in_shift)\n    goto with_shift;\n  /* Handle most ASCII characters quickly, without calling mbrtowc().  */\n  if (is_basic (*iter->cur.ptr))\n    {\n      /* These characters are part of the basic character set.  ISO C 99\n         guarantees that their wide character code is identical to their\n         char code.  */\n      iter->cur.bytes = 1;\n      iter->cur.wc = *iter->cur.ptr;\n      iter->cur.wc_valid = true;\n    }\n  else\n    {\n      assert (mbsinit (&iter->state));\n      iter->in_shift = true;\n    with_shift:\n      iter->cur.bytes = mbrtowc (&iter->cur.wc, iter->cur.ptr,\n                                 strnlen1 (iter->cur.ptr, MB_CUR_MAX),\n                                 &iter->state);\n      if (iter->cur.bytes == (size_t) -1)\n        {\n          /* An invalid multibyte sequence was encountered.  */\n          iter->cur.bytes = 1;\n          iter->cur.wc_valid = false;\n          /* Whether to set iter->in_shift = false and reset iter->state\n             or not is not very important; the string is bogus anyway.  */\n        }\n      else if (iter->cur.bytes == (size_t) -2)\n        {\n          /* An incomplete multibyte character at the end.  */\n          iter->cur.bytes = strlen (iter->cur.ptr);\n          iter->cur.wc_valid = false;\n          /* Whether to set iter->in_shift = false and reset iter->state\n             or not is not important; the string end is reached anyway.  */\n        }\n      else\n        {\n          if (iter->cur.bytes == 0)\n            {\n              /* A null wide character was encountered.  */\n              iter->cur.bytes = 1;\n              assert (*iter->cur.ptr == '\\0');\n              assert (iter->cur.wc == 0);\n            }\n          iter->cur.wc_valid = true;\n\n          /* When in the initial state, we can go back treating ASCII\n             characters more quickly.  */\n          if (mbsinit (&iter->state))\n            iter->in_shift = false;\n        }\n    }\n  iter->next_done = true;\n}",
      "lines": 60,
      "depth": 17,
      "decorators": [
        "MBUITER_INLINE",
        "void",
        "void"
      ]
    },
    "mbuiter_multi_reloc": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "MBUITER_INLINE void\nmbuiter_multi_reloc (struct mbuiter_multi *iter, ptrdiff_t ptrdiff)\n{\n  iter->cur.ptr += ptrdiff;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "MBUITER_INLINE",
        "void",
        "void"
      ]
    },
    "mbuiter_multi_copy": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "MBUITER_INLINE void\nmbuiter_multi_copy (struct mbuiter_multi *new_iter, const struct mbuiter_multi *old_iter)\n{\n  if ((new_iter->in_shift = old_iter->in_shift))\n    memcpy (&new_iter->state, &old_iter->state, sizeof (mbstate_t));\n  else\n    memset (&new_iter->state, 0, sizeof (mbstate_t));\n  new_iter->next_done = old_iter->next_done;\n  mb_copy (&new_iter->cur, &old_iter->cur);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "MBUITER_INLINE",
        "void",
        "void"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/memchr.c": {
    "__memchr": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "void *\n__memchr (void const *s, int c_in, size_t n)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned reg_char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;\n       --n, ++char_ptr)\n    if (*char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will test a\n     longword at a time.  The tricky part is testing if *any of the four*\n     bytes in the longword in question are equal to c.  We first use an xor\n     with repeated_c.  This reduces the task to testing whether *any of the\n     four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     So, the test whether any byte in longword1 is zero is equivalent to\n     testing whether tmp is nonzero.  */\n\n  while (n >= sizeof (longword))\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n      n -= sizeof (longword);\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that either n < sizeof (longword), or one of the\n     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian\n     machines, we could determine the first such byte without any further\n     memory accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.  Choose code\n     that works in both cases.  */\n\n  for (; n > 0; --n, ++char_ptr)\n    {\n      if (*char_ptr == c)\n        return (void *) char_ptr;\n    }\n\n  return NULL;\n}",
      "lines": 112,
      "depth": 14,
      "decorators": [
        "void",
        "*\n__memchr (void const *s, int c_in, size_t n)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/mempcpy.c": {
    "mempcpy": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "void *\nmempcpy (void *dest, const void *src, size_t n)\n{\n  return (char *) memcpy (dest, src, n) + n;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nmempcpy (void *dest, const void *src, size_t n)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/memrchr.c": {
    "__memrchr": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "void *\n__memrchr (void const *s, int c_in, size_t n)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned reg_char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the last few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s + n;\n       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;\n       --n)\n    if (*--char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will test a\n     longword at a time.  The tricky part is testing if *any of the four*\n     bytes in the longword in question are equal to c.  We first use an xor\n     with repeated_c.  This reduces the task to testing whether *any of the\n     four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     So, the test whether any byte in longword1 is zero is equivalent to\n     testing whether tmp is nonzero.  */\n\n  while (n >= sizeof (longword))\n    {\n      longword longword1 = *--longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        {\n          longword_ptr++;\n          break;\n        }\n      n -= sizeof (longword);\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that either n < sizeof (longword), or one of the\n     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian\n     machines, we could determine the first such byte without any further\n     memory accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.  Choose code\n     that works in both cases.  */\n\n  while (n-- > 0)\n    {\n      if (*--char_ptr == c)\n        return (void *) char_ptr;\n    }\n\n  return NULL;\n}",
      "lines": 114,
      "depth": 14,
      "decorators": [
        "void",
        "*\n__memrchr (void const *s, int c_in, size_t n)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/msvc-inval.c": {
    "gl_msvc_invalid_parameter_handler": [
      {
        "start_point": [
          30,
          0
        ],
        "end_point": [
          37,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n}",
        "lines": 8,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          47,
          0
        ],
        "end_point": [
          55,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 9,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          96,
          0
        ],
        "end_point": [
          110,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  struct gl_msvc_inval_per_thread *current = gl_msvc_inval_current ();\n  if (current->restart_valid)\n    longjmp (current->restart, 1);\n  else\n    /* An invalid parameter notification from outside the gnulib code.\n       Give the caller a chance to intervene.  */\n    RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      }
    ],
    "gl_msvc_inval_current": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "struct gl_msvc_inval_per_thread *\ngl_msvc_inval_current (void)\n{\n  if (!tls_initialized)\n    {\n      tls_index = TlsAlloc ();\n      tls_initialized = 1;\n    }\n  if (tls_index == TLS_OUT_OF_INDEXES)\n    /* TlsAlloc had failed.  */\n    return &not_per_thread;\n  else\n    {\n      struct gl_msvc_inval_per_thread *pointer =\n        (struct gl_msvc_inval_per_thread *) TlsGetValue (tls_index);\n      if (pointer == NULL)\n        {\n          /* First call.  Allocate a new 'struct gl_msvc_inval_per_thread'.  */\n          pointer =\n            (struct gl_msvc_inval_per_thread *)\n            malloc (sizeof (struct gl_msvc_inval_per_thread));\n          if (pointer == NULL)\n            /* Could not allocate memory.  Use the global storage.  */\n            pointer = &not_per_thread;\n          TlsSetValue (tls_index, pointer);\n        }\n      return pointer;\n    }\n}",
      "lines": 29,
      "depth": 15,
      "decorators": [
        "struct gl_msvc_inval_per_thread",
        "struct",
        "gl_msvc_inval_per_thread",
        "*\ngl_msvc_inval_current (void)",
        "*"
      ]
    },
    "gl_msvc_inval_ensure_handler": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "void\ngl_msvc_inval_ensure_handler (void)\n{\n  if (gl_msvc_inval_initialized == 0)\n    {\n      _set_invalid_parameter_handler (gl_msvc_invalid_parameter_handler);\n      gl_msvc_inval_initialized = 1;\n    }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/msvc-inval.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/msvc-nothrow.c": {
    "_gl_nothrow_get_osfhandle": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        41,
        5
      ],
      "content": "intptr_t\n_gl_nothrow_get_osfhandle (int fd)\n{\n  intptr_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _get_osfhandle (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "intptr_t"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/msvc-nothrow.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/nl_langinfo.c": {
    "ctype_codeset": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static char *\nctype_codeset (void)\n{\n  static char buf[2 + 10 + 1];\n  char const *locale = setlocale (LC_CTYPE, NULL);\n  char *codeset = buf;\n  size_t codesetlen;\n  codeset[0] = '\\0';\n\n  if (locale && locale[0])\n    {\n      /* If the locale name contains an encoding after the dot, return it.  */\n      char *dot = strchr (locale, '.');\n\n      if (dot)\n        {\n          /* Look for the possible @... trailer and remove it, if any.  */\n          char *codeset_start = dot + 1;\n          char const *modifier = strchr (codeset_start, '@');\n\n          if (! modifier)\n            codeset = codeset_start;\n          else\n            {\n              codesetlen = modifier - codeset_start;\n              if (codesetlen < sizeof buf)\n                {\n                  codeset = memcpy (buf, codeset_start, codesetlen);\n                  codeset[codesetlen] = '\\0';\n                }\n            }\n        }\n    }\n\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* If setlocale is successful, it returns the number of the\n     codepage, as a string.  Otherwise, fall back on Windows API\n     GetACP, which returns the locale's codepage as a number (although\n     this doesn't change according to what the 'setlocale' call specified).\n     Either way, prepend \"CP\" to make it a valid codeset name.  */\n  codesetlen = strlen (codeset);\n  if (0 < codesetlen && codesetlen < sizeof buf - 2)\n    memmove (buf + 2, codeset, codesetlen + 1);\n  else\n    sprintf (buf + 2, \"%u\", GetACP ());\n  codeset = memcpy (buf, \"CP\", 2);\n#endif\n  return codeset;\n}",
      "lines": 49,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nctype_codeset (void)",
        "*"
      ]
    },
    "rpl_nl_langinfo": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "char *\nrpl_nl_langinfo (nl_item item)\n{\n  switch (item)\n    {\n# if GNULIB_defined_CODESET\n    case CODESET:\n      return ctype_codeset ();\n# endif\n# if GNULIB_defined_T_FMT_AMPM\n    case T_FMT_AMPM:\n      return (char *) \"%I:%M:%S %p\";\n# endif\n# if GNULIB_defined_ERA\n    case ERA:\n      /* The format is not standardized.  In glibc it is a sequence of strings\n         of the form \"direction:offset:start_date:end_date:era_name:era_format\"\n         with an empty string at the end.  */\n      return (char *) \"\";\n    case ERA_D_FMT:\n      /* The %Ex conversion in strftime behaves like %x if the locale does not\n         have an alternative time format.  */\n      item = D_FMT;\n      break;\n    case ERA_D_T_FMT:\n      /* The %Ec conversion in strftime behaves like %c if the locale does not\n         have an alternative time format.  */\n      item = D_T_FMT;\n      break;\n    case ERA_T_FMT:\n      /* The %EX conversion in strftime behaves like %X if the locale does not\n         have an alternative time format.  */\n      item = T_FMT;\n      break;\n    case ALT_DIGITS:\n      /* The format is not standardized.  In glibc it is a sequence of 10\n         strings, appended in memory.  */\n      return (char *) \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n# endif\n# if GNULIB_defined_YESEXPR || !FUNC_NL_LANGINFO_YESEXPR_WORKS\n    case YESEXPR:\n      return (char *) \"^[yY]\";\n    case NOEXPR:\n      return (char *) \"^[nN]\";\n# endif\n    default:\n      break;\n    }\n  return nl_langinfo (item);\n}",
      "lines": 50,
      "depth": 11,
      "decorators": [
        "char",
        "*\nrpl_nl_langinfo (nl_item item)",
        "*"
      ]
    },
    "nl_langinfo": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        318,
        1
      ],
      "content": "char *\nnl_langinfo (nl_item item)\n{\n  static char nlbuf[100];\n  struct tm tmm = { 0 };\n\n  switch (item)\n    {\n    /* nl_langinfo items of the LC_CTYPE category */\n    case CODESET:\n      {\n        char *codeset = ctype_codeset ();\n        if (*codeset)\n          return codeset;\n      }\n# ifdef __BEOS__\n      return (char *) \"UTF-8\";\n# else\n      return (char *) \"ISO-8859-1\";\n# endif\n    /* nl_langinfo items of the LC_NUMERIC category */\n    case RADIXCHAR:\n      return localeconv () ->decimal_point;\n    case THOUSEP:\n      return localeconv () ->thousands_sep;\n    case GROUPING:\n      return localeconv () ->grouping;\n    /* nl_langinfo items of the LC_TIME category.\n       TODO: Really use the locale.  */\n    case D_T_FMT:\n    case ERA_D_T_FMT:\n      return (char *) \"%a %b %e %H:%M:%S %Y\";\n    case D_FMT:\n    case ERA_D_FMT:\n      return (char *) \"%m/%d/%y\";\n    case T_FMT:\n    case ERA_T_FMT:\n      return (char *) \"%H:%M:%S\";\n    case T_FMT_AMPM:\n      return (char *) \"%I:%M:%S %p\";\n    case AM_STR:\n      if (!strftime (nlbuf, sizeof nlbuf, \"%p\", &tmm))\n        return (char *) \"AM\";\n      return nlbuf;\n    case PM_STR:\n      tmm.tm_hour = 12;\n      if (!strftime (nlbuf, sizeof nlbuf, \"%p\", &tmm))\n        return (char *) \"PM\";\n      return nlbuf;\n    case DAY_1:\n    case DAY_2:\n    case DAY_3:\n    case DAY_4:\n    case DAY_5:\n    case DAY_6:\n    case DAY_7:\n      {\n        static char const days[][sizeof \"Wednesday\"] = {\n          \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\",\n          \"Friday\", \"Saturday\"\n        };\n        tmm.tm_wday = item - DAY_1;\n        if (!strftime (nlbuf, sizeof nlbuf, \"%A\", &tmm))\n          return (char *) days[item - DAY_1];\n        return nlbuf;\n      }\n    case ABDAY_1:\n    case ABDAY_2:\n    case ABDAY_3:\n    case ABDAY_4:\n    case ABDAY_5:\n    case ABDAY_6:\n    case ABDAY_7:\n      {\n        static char const abdays[][sizeof \"Sun\"] = {\n          \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"\n        };\n        tmm.tm_wday = item - ABDAY_1;\n        if (!strftime (nlbuf, sizeof nlbuf, \"%a\", &tmm))\n          return (char *) abdays[item - ABDAY_1];\n        return nlbuf;\n      }\n    case MON_1:\n    case MON_2:\n    case MON_3:\n    case MON_4:\n    case MON_5:\n    case MON_6:\n    case MON_7:\n    case MON_8:\n    case MON_9:\n    case MON_10:\n    case MON_11:\n    case MON_12:\n      {\n        static char const months[][sizeof \"September\"] = {\n          \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\",\n          \"September\", \"October\", \"November\", \"December\"\n        };\n        tmm.tm_mon = item - MON_1;\n        if (!strftime (nlbuf, sizeof nlbuf, \"%B\", &tmm))\n          return (char *) months[item - MON_1];\n        return nlbuf;\n      }\n    case ABMON_1:\n    case ABMON_2:\n    case ABMON_3:\n    case ABMON_4:\n    case ABMON_5:\n    case ABMON_6:\n    case ABMON_7:\n    case ABMON_8:\n    case ABMON_9:\n    case ABMON_10:\n    case ABMON_11:\n    case ABMON_12:\n      {\n        static char const abmonths[][sizeof \"Jan\"] = {\n          \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\",\n          \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n        };\n        tmm.tm_mon = item - ABMON_1;\n        if (!strftime (nlbuf, sizeof nlbuf, \"%b\", &tmm))\n          return (char *) abmonths[item - ABMON_1];\n        return nlbuf;\n      }\n    case ERA:\n      return (char *) \"\";\n    case ALT_DIGITS:\n      return (char *) \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n    /* nl_langinfo items of the LC_MONETARY category.  */\n    case CRNCYSTR:\n      return localeconv () ->currency_symbol;\n    case INT_CURR_SYMBOL:\n      return localeconv () ->int_curr_symbol;\n    case MON_DECIMAL_POINT:\n      return localeconv () ->mon_decimal_point;\n    case MON_THOUSANDS_SEP:\n      return localeconv () ->mon_thousands_sep;\n    case MON_GROUPING:\n      return localeconv () ->mon_grouping;\n    case POSITIVE_SIGN:\n      return localeconv () ->positive_sign;\n    case NEGATIVE_SIGN:\n      return localeconv () ->negative_sign;\n    case FRAC_DIGITS:\n      return & localeconv () ->frac_digits;\n    case INT_FRAC_DIGITS:\n      return & localeconv () ->int_frac_digits;\n    case P_CS_PRECEDES:\n      return & localeconv () ->p_cs_precedes;\n    case N_CS_PRECEDES:\n      return & localeconv () ->n_cs_precedes;\n    case P_SEP_BY_SPACE:\n      return & localeconv () ->p_sep_by_space;\n    case N_SEP_BY_SPACE:\n      return & localeconv () ->n_sep_by_space;\n    case P_SIGN_POSN:\n      return & localeconv () ->p_sign_posn;\n    case N_SIGN_POSN:\n      return & localeconv () ->n_sign_posn;\n    /* nl_langinfo items of the LC_MESSAGES category\n       TODO: Really use the locale. */\n    case YESEXPR:\n      return (char *) \"^[yY]\";\n    case NOEXPR:\n      return (char *) \"^[nN]\";\n    default:\n      return (char *) \"\";\n    }\n}",
      "lines": 171,
      "depth": 13,
      "decorators": [
        "char",
        "*\nnl_langinfo (nl_item item)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/printf-args.c": {
    "PRINTF_FETCHARGS": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "int\nPRINTF_FETCHARGS (va_list args, arguments *a)\n{\n  size_t i;\n  argument *ap;\n\n  for (i = 0, ap = &a->arg[0]; i < a->count; i++, ap++)\n    switch (ap->type)\n      {\n      case TYPE_SCHAR:\n        ap->a.a_schar = va_arg (args, /*signed char*/ int);\n        break;\n      case TYPE_UCHAR:\n        ap->a.a_uchar = va_arg (args, /*unsigned char*/ int);\n        break;\n      case TYPE_SHORT:\n        ap->a.a_short = va_arg (args, /*short*/ int);\n        break;\n      case TYPE_USHORT:\n        ap->a.a_ushort = va_arg (args, /*unsigned short*/ int);\n        break;\n      case TYPE_INT:\n        ap->a.a_int = va_arg (args, int);\n        break;\n      case TYPE_UINT:\n        ap->a.a_uint = va_arg (args, unsigned int);\n        break;\n      case TYPE_LONGINT:\n        ap->a.a_longint = va_arg (args, long int);\n        break;\n      case TYPE_ULONGINT:\n        ap->a.a_ulongint = va_arg (args, unsigned long int);\n        break;\n#if HAVE_LONG_LONG_INT\n      case TYPE_LONGLONGINT:\n        ap->a.a_longlongint = va_arg (args, long long int);\n        break;\n      case TYPE_ULONGLONGINT:\n        ap->a.a_ulonglongint = va_arg (args, unsigned long long int);\n        break;\n#endif\n      case TYPE_DOUBLE:\n        ap->a.a_double = va_arg (args, double);\n        break;\n      case TYPE_LONGDOUBLE:\n        ap->a.a_longdouble = va_arg (args, long double);\n        break;\n      case TYPE_CHAR:\n        ap->a.a_char = va_arg (args, int);\n        break;\n#if HAVE_WINT_T\n      case TYPE_WIDE_CHAR:\n        /* Although ISO C 99 7.24.1.(2) says that wint_t is \"unchanged by\n           default argument promotions\", this is not the case in mingw32,\n           where wint_t is 'unsigned short'.  */\n        ap->a.a_wide_char =\n          (sizeof (wint_t) < sizeof (int)\n           ? (wint_t) va_arg (args, int)\n           : va_arg (args, wint_t));\n        break;\n#endif\n      case TYPE_STRING:\n        ap->a.a_string = va_arg (args, const char *);\n        /* A null pointer is an invalid argument for \"%s\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_string == NULL)\n          ap->a.a_string = \"(NULL)\";\n        break;\n#if HAVE_WCHAR_T\n      case TYPE_WIDE_STRING:\n        ap->a.a_wide_string = va_arg (args, const wchar_t *);\n        /* A null pointer is an invalid argument for \"%ls\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_wide_string == NULL)\n          {\n            static const wchar_t wide_null_string[] =\n              {\n                (wchar_t)'(',\n                (wchar_t)'N', (wchar_t)'U', (wchar_t)'L', (wchar_t)'L',\n                (wchar_t)')',\n                (wchar_t)0\n              };\n            ap->a.a_wide_string = wide_null_string;\n          }\n        break;\n#endif\n      case TYPE_POINTER:\n        ap->a.a_pointer = va_arg (args, void *);\n        break;\n      case TYPE_COUNT_SCHAR_POINTER:\n        ap->a.a_count_schar_pointer = va_arg (args, signed char *);\n        break;\n      case TYPE_COUNT_SHORT_POINTER:\n        ap->a.a_count_short_pointer = va_arg (args, short *);\n        break;\n      case TYPE_COUNT_INT_POINTER:\n        ap->a.a_count_int_pointer = va_arg (args, int *);\n        break;\n      case TYPE_COUNT_LONGINT_POINTER:\n        ap->a.a_count_longint_pointer = va_arg (args, long int *);\n        break;\n#if HAVE_LONG_LONG_INT\n      case TYPE_COUNT_LONGLONGINT_POINTER:\n        ap->a.a_count_longlongint_pointer = va_arg (args, long long int *);\n        break;\n#endif\n#if ENABLE_UNISTDIO\n      /* The unistdio extensions.  */\n      case TYPE_U8_STRING:\n        ap->a.a_u8_string = va_arg (args, const uint8_t *);\n        /* A null pointer is an invalid argument for \"%U\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u8_string == NULL)\n          {\n            static const uint8_t u8_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u8_string = u8_null_string;\n          }\n        break;\n      case TYPE_U16_STRING:\n        ap->a.a_u16_string = va_arg (args, const uint16_t *);\n        /* A null pointer is an invalid argument for \"%lU\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u16_string == NULL)\n          {\n            static const uint16_t u16_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u16_string = u16_null_string;\n          }\n        break;\n      case TYPE_U32_STRING:\n        ap->a.a_u32_string = va_arg (args, const uint32_t *);\n        /* A null pointer is an invalid argument for \"%llU\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u32_string == NULL)\n          {\n            static const uint32_t u32_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u32_string = u32_null_string;\n          }\n        break;\n#endif\n      default:\n        /* Unknown type.  */\n        return -1;\n      }\n  return 0;\n}",
      "lines": 153,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/printf-args.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/printf-parse.c": {
    "PRINTF_PARSE": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        631,
        1
      ],
      "content": "int\nPRINTF_PARSE (const CHAR_T *format, DIRECTIVES *d, arguments *a)\n{\n  const CHAR_T *cp = format;    /* pointer into format */\n  size_t arg_posn = 0;          /* number of regular arguments consumed */\n  size_t d_allocated;           /* allocated elements of d->dir */\n  size_t a_allocated;           /* allocated elements of a->arg */\n  size_t max_width_length = 0;\n  size_t max_precision_length = 0;\n\n  d->count = 0;\n  d_allocated = N_DIRECT_ALLOC_DIRECTIVES;\n  d->dir = d->direct_alloc_dir;\n\n  a->count = 0;\n  a_allocated = N_DIRECT_ALLOC_ARGUMENTS;\n  a->arg = a->direct_alloc_arg;\n\n#define REGISTER_ARG(_index_,_type_) \\\n  {                                                                     \\\n    size_t n = (_index_);                                               \\\n    if (n >= a_allocated)                                               \\\n      {                                                                 \\\n        size_t memory_size;                                             \\\n        argument *memory;                                               \\\n                                                                        \\\n        a_allocated = xtimes (a_allocated, 2);                          \\\n        if (a_allocated <= n)                                           \\\n          a_allocated = xsum (n, 1);                                    \\\n        memory_size = xtimes (a_allocated, sizeof (argument));          \\\n        if (size_overflow_p (memory_size))                              \\\n          /* Overflow, would lead to out of memory.  */                 \\\n          goto out_of_memory;                                           \\\n        memory = (argument *) (a->arg != a->direct_alloc_arg            \\\n                               ? realloc (a->arg, memory_size)          \\\n                               : malloc (memory_size));                 \\\n        if (memory == NULL)                                             \\\n          /* Out of memory.  */                                         \\\n          goto out_of_memory;                                           \\\n        if (a->arg == a->direct_alloc_arg)                              \\\n          memcpy (memory, a->arg, a->count * sizeof (argument));        \\\n        a->arg = memory;                                                \\\n      }                                                                 \\\n    while (a->count <= n)                                               \\\n      a->arg[a->count++].type = TYPE_NONE;                              \\\n    if (a->arg[n].type == TYPE_NONE)                                    \\\n      a->arg[n].type = (_type_);                                        \\\n    else if (a->arg[n].type != (_type_))                                \\\n      /* Ambiguous type for positional argument.  */                    \\\n      goto error;                                                       \\\n  }\n\n  while (*cp != '\\0')\n    {\n      CHAR_T c = *cp++;\n      if (c == '%')\n        {\n          size_t arg_index = ARG_NONE;\n          DIRECTIVE *dp = &d->dir[d->count]; /* pointer to next directive */\n\n          /* Initialize the next directive.  */\n          dp->dir_start = cp - 1;\n          dp->flags = 0;\n          dp->width_start = NULL;\n          dp->width_end = NULL;\n          dp->width_arg_index = ARG_NONE;\n          dp->precision_start = NULL;\n          dp->precision_end = NULL;\n          dp->precision_arg_index = ARG_NONE;\n          dp->arg_index = ARG_NONE;\n\n          /* Test for positional argument.  */\n          if (*cp >= '0' && *cp <= '9')\n            {\n              const CHAR_T *np;\n\n              for (np = cp; *np >= '0' && *np <= '9'; np++)\n                ;\n              if (*np == '$')\n                {\n                  size_t n = 0;\n\n                  for (np = cp; *np >= '0' && *np <= '9'; np++)\n                    n = xsum (xtimes (n, 10), *np - '0');\n                  if (n == 0)\n                    /* Positional argument 0.  */\n                    goto error;\n                  if (size_overflow_p (n))\n                    /* n too large, would lead to out of memory later.  */\n                    goto error;\n                  arg_index = n - 1;\n                  cp = np + 1;\n                }\n            }\n\n          /* Read the flags.  */\n          for (;;)\n            {\n              if (*cp == '\\'')\n                {\n                  dp->flags |= FLAG_GROUP;\n                  cp++;\n                }\n              else if (*cp == '-')\n                {\n                  dp->flags |= FLAG_LEFT;\n                  cp++;\n                }\n              else if (*cp == '+')\n                {\n                  dp->flags |= FLAG_SHOWSIGN;\n                  cp++;\n                }\n              else if (*cp == ' ')\n                {\n                  dp->flags |= FLAG_SPACE;\n                  cp++;\n                }\n              else if (*cp == '#')\n                {\n                  dp->flags |= FLAG_ALT;\n                  cp++;\n                }\n              else if (*cp == '0')\n                {\n                  dp->flags |= FLAG_ZERO;\n                  cp++;\n                }\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n              else if (*cp == 'I')\n                {\n                  dp->flags |= FLAG_LOCALIZED;\n                  cp++;\n                }\n#endif\n              else\n                break;\n            }\n\n          /* Parse the field width.  */\n          if (*cp == '*')\n            {\n              dp->width_start = cp;\n              cp++;\n              dp->width_end = cp;\n              if (max_width_length < 1)\n                max_width_length = 1;\n\n              /* Test for positional argument.  */\n              if (*cp >= '0' && *cp <= '9')\n                {\n                  const CHAR_T *np;\n\n                  for (np = cp; *np >= '0' && *np <= '9'; np++)\n                    ;\n                  if (*np == '$')\n                    {\n                      size_t n = 0;\n\n                      for (np = cp; *np >= '0' && *np <= '9'; np++)\n                        n = xsum (xtimes (n, 10), *np - '0');\n                      if (n == 0)\n                        /* Positional argument 0.  */\n                        goto error;\n                      if (size_overflow_p (n))\n                        /* n too large, would lead to out of memory later.  */\n                        goto error;\n                      dp->width_arg_index = n - 1;\n                      cp = np + 1;\n                    }\n                }\n              if (dp->width_arg_index == ARG_NONE)\n                {\n                  dp->width_arg_index = arg_posn++;\n                  if (dp->width_arg_index == ARG_NONE)\n                    /* arg_posn wrapped around.  */\n                    goto error;\n                }\n              REGISTER_ARG (dp->width_arg_index, TYPE_INT);\n            }\n          else if (*cp >= '0' && *cp <= '9')\n            {\n              size_t width_length;\n\n              dp->width_start = cp;\n              for (; *cp >= '0' && *cp <= '9'; cp++)\n                ;\n              dp->width_end = cp;\n              width_length = dp->width_end - dp->width_start;\n              if (max_width_length < width_length)\n                max_width_length = width_length;\n            }\n\n          /* Parse the precision.  */\n          if (*cp == '.')\n            {\n              cp++;\n              if (*cp == '*')\n                {\n                  dp->precision_start = cp - 1;\n                  cp++;\n                  dp->precision_end = cp;\n                  if (max_precision_length < 2)\n                    max_precision_length = 2;\n\n                  /* Test for positional argument.  */\n                  if (*cp >= '0' && *cp <= '9')\n                    {\n                      const CHAR_T *np;\n\n                      for (np = cp; *np >= '0' && *np <= '9'; np++)\n                        ;\n                      if (*np == '$')\n                        {\n                          size_t n = 0;\n\n                          for (np = cp; *np >= '0' && *np <= '9'; np++)\n                            n = xsum (xtimes (n, 10), *np - '0');\n                          if (n == 0)\n                            /* Positional argument 0.  */\n                            goto error;\n                          if (size_overflow_p (n))\n                            /* n too large, would lead to out of memory\n                               later.  */\n                            goto error;\n                          dp->precision_arg_index = n - 1;\n                          cp = np + 1;\n                        }\n                    }\n                  if (dp->precision_arg_index == ARG_NONE)\n                    {\n                      dp->precision_arg_index = arg_posn++;\n                      if (dp->precision_arg_index == ARG_NONE)\n                        /* arg_posn wrapped around.  */\n                        goto error;\n                    }\n                  REGISTER_ARG (dp->precision_arg_index, TYPE_INT);\n                }\n              else\n                {\n                  size_t precision_length;\n\n                  dp->precision_start = cp - 1;\n                  for (; *cp >= '0' && *cp <= '9'; cp++)\n                    ;\n                  dp->precision_end = cp;\n                  precision_length = dp->precision_end - dp->precision_start;\n                  if (max_precision_length < precision_length)\n                    max_precision_length = precision_length;\n                }\n            }\n\n          {\n            arg_type type;\n\n            /* Parse argument type/size specifiers.  */\n            {\n              int flags = 0;\n\n              for (;;)\n                {\n                  if (*cp == 'h')\n                    {\n                      flags |= (1 << (flags & 1));\n                      cp++;\n                    }\n                  else if (*cp == 'L')\n                    {\n                      flags |= 4;\n                      cp++;\n                    }\n                  else if (*cp == 'l')\n                    {\n                      flags += 8;\n                      cp++;\n                    }\n                  else if (*cp == 'j')\n                    {\n                      if (sizeof (intmax_t) > sizeof (long))\n                        {\n                          /* intmax_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (intmax_t) > sizeof (int))\n                        {\n                          /* intmax_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n                  else if (*cp == 'z' || *cp == 'Z')\n                    {\n                      /* 'z' is standardized in ISO C 99, but glibc uses 'Z'\n                         because the warning facility in gcc-2.95.2 understands\n                         only 'Z' (see gcc-2.95.2/gcc/c-common.c:1784).  */\n                      if (sizeof (size_t) > sizeof (long))\n                        {\n                          /* size_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (size_t) > sizeof (int))\n                        {\n                          /* size_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n                  else if (*cp == 't')\n                    {\n                      if (sizeof (ptrdiff_t) > sizeof (long))\n                        {\n                          /* ptrdiff_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (ptrdiff_t) > sizeof (int))\n                        {\n                          /* ptrdiff_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n#if defined __APPLE__ && defined __MACH__\n                  /* On Mac OS X 10.3, PRIdMAX is defined as \"qd\".\n                     We cannot change it to \"lld\" because PRIdMAX must also\n                     be understood by the system's printf routines.  */\n                  else if (*cp == 'q')\n                    {\n                      if (64 / 8 > sizeof (long))\n                        {\n                          /* int64_t = long long */\n                          flags += 16;\n                        }\n                      else\n                        {\n                          /* int64_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n#endif\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                  /* On native Windows, PRIdMAX is defined as \"I64d\".\n                     We cannot change it to \"lld\" because PRIdMAX must also\n                     be understood by the system's printf routines.  */\n                  else if (*cp == 'I' && cp[1] == '6' && cp[2] == '4')\n                    {\n                      if (64 / 8 > sizeof (long))\n                        {\n                          /* __int64 = long long */\n                          flags += 16;\n                        }\n                      else\n                        {\n                          /* __int64 = long */\n                          flags += 8;\n                        }\n                      cp += 3;\n                    }\n#endif\n                  else\n                    break;\n                }\n\n              /* Read the conversion character.  */\n              c = *cp++;\n              switch (c)\n                {\n                case 'd': case 'i':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_LONGLONGINT;\n                  else\n#endif\n                  /* If 'long long' exists and is the same as 'long', we parse\n                     \"lld\" into TYPE_LONGINT.  */\n                  if (flags >= 8)\n                    type = TYPE_LONGINT;\n                  else if (flags & 2)\n                    type = TYPE_SCHAR;\n                  else if (flags & 1)\n                    type = TYPE_SHORT;\n                  else\n                    type = TYPE_INT;\n                  break;\n                case 'o': case 'u': case 'x': case 'X':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_ULONGLONGINT;\n                  else\n#endif\n                  /* If 'unsigned long long' exists and is the same as\n                     'unsigned long', we parse \"llu\" into TYPE_ULONGINT.  */\n                  if (flags >= 8)\n                    type = TYPE_ULONGINT;\n                  else if (flags & 2)\n                    type = TYPE_UCHAR;\n                  else if (flags & 1)\n                    type = TYPE_USHORT;\n                  else\n                    type = TYPE_UINT;\n                  break;\n                case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                case 'a': case 'A':\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_LONGDOUBLE;\n                  else\n                    type = TYPE_DOUBLE;\n                  break;\n                case 'c':\n                  if (flags >= 8)\n#if HAVE_WINT_T\n                    type = TYPE_WIDE_CHAR;\n#else\n                    goto error;\n#endif\n                  else\n                    type = TYPE_CHAR;\n                  break;\n#if HAVE_WINT_T\n                case 'C':\n                  type = TYPE_WIDE_CHAR;\n                  c = 'c';\n                  break;\n#endif\n                case 's':\n                  if (flags >= 8)\n#if HAVE_WCHAR_T\n                    type = TYPE_WIDE_STRING;\n#else\n                    goto error;\n#endif\n                  else\n                    type = TYPE_STRING;\n                  break;\n#if HAVE_WCHAR_T\n                case 'S':\n                  type = TYPE_WIDE_STRING;\n                  c = 's';\n                  break;\n#endif\n                case 'p':\n                  type = TYPE_POINTER;\n                  break;\n                case 'n':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_COUNT_LONGLONGINT_POINTER;\n                  else\n#endif\n                  /* If 'long long' exists and is the same as 'long', we parse\n                     \"lln\" into TYPE_COUNT_LONGINT_POINTER.  */\n                  if (flags >= 8)\n                    type = TYPE_COUNT_LONGINT_POINTER;\n                  else if (flags & 2)\n                    type = TYPE_COUNT_SCHAR_POINTER;\n                  else if (flags & 1)\n                    type = TYPE_COUNT_SHORT_POINTER;\n                  else\n                    type = TYPE_COUNT_INT_POINTER;\n                  break;\n#if ENABLE_UNISTDIO\n                /* The unistdio extensions.  */\n                case 'U':\n                  if (flags >= 16)\n                    type = TYPE_U32_STRING;\n                  else if (flags >= 8)\n                    type = TYPE_U16_STRING;\n                  else\n                    type = TYPE_U8_STRING;\n                  break;\n#endif\n                case '%':\n                  type = TYPE_NONE;\n                  break;\n                default:\n                  /* Unknown conversion character.  */\n                  goto error;\n                }\n            }\n\n            if (type != TYPE_NONE)\n              {\n                dp->arg_index = arg_index;\n                if (dp->arg_index == ARG_NONE)\n                  {\n                    dp->arg_index = arg_posn++;\n                    if (dp->arg_index == ARG_NONE)\n                      /* arg_posn wrapped around.  */\n                      goto error;\n                  }\n                REGISTER_ARG (dp->arg_index, type);\n              }\n            dp->conversion = c;\n            dp->dir_end = cp;\n          }\n\n          d->count++;\n          if (d->count >= d_allocated)\n            {\n              size_t memory_size;\n              DIRECTIVE *memory;\n\n              d_allocated = xtimes (d_allocated, 2);\n              memory_size = xtimes (d_allocated, sizeof (DIRECTIVE));\n              if (size_overflow_p (memory_size))\n                /* Overflow, would lead to out of memory.  */\n                goto out_of_memory;\n              memory = (DIRECTIVE *) (d->dir != d->direct_alloc_dir\n                                      ? realloc (d->dir, memory_size)\n                                      : malloc (memory_size));\n              if (memory == NULL)\n                /* Out of memory.  */\n                goto out_of_memory;\n              if (d->dir == d->direct_alloc_dir)\n                memcpy (memory, d->dir, d->count * sizeof (DIRECTIVE));\n              d->dir = memory;\n            }\n        }\n#if CHAR_T_ONLY_ASCII\n      else if (!c_isascii (c))\n        {\n          /* Non-ASCII character.  Not supported.  */\n          goto error;\n        }\n#endif\n    }\n  d->dir[d->count].dir_start = cp;\n\n  d->max_width_length = max_width_length;\n  d->max_precision_length = max_precision_length;\n  return 0;\n\nerror:\n  if (a->arg != a->direct_alloc_arg)\n    free (a->arg);\n  if (d->dir != d->direct_alloc_dir)\n    free (d->dir);\n  errno = EINVAL;\n  return -1;\n\nout_of_memory:\n  if (a->arg != a->direct_alloc_arg)\n    free (a->arg);\n  if (d->dir != d->direct_alloc_dir)\n    free (d->dir);\n  errno = ENOMEM;\n  return -1;\n}",
      "lines": 551,
      "depth": 24,
      "decorators": [
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/printf-parse.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/regcomp.c": {
    "re_compile_pattern": {
      "start_point": [
        215,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "const char *\nre_compile_pattern (const char *pattern, size_t length,\n\t\t    struct re_pattern_buffer *bufp)\n{\n  reg_errcode_t ret;\n\n  /* And GNU code determines whether or not to get register information\n     by passing null for the REGS argument to re_match, etc., not by\n     setting no_sub, unless RE_NO_SUB is set.  */\n  bufp->no_sub = !!(re_syntax_options & RE_NO_SUB);\n\n  /* Match anchors at newline.  */\n  bufp->newline_anchor = 1;\n\n  ret = re_compile_internal (bufp, pattern, length, re_syntax_options);\n\n  if (!ret)\n    return NULL;\n  return gettext (__re_error_msgid + __re_error_msgid_idx[(int) ret]);\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nre_compile_pattern (const char *pattern, size_t length,\n\t\t    struct re_pattern_buffer *bufp)",
        "*"
      ]
    },
    "re_set_syntax": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "reg_syntax_t\nre_set_syntax (reg_syntax_t syntax)\n{\n  reg_syntax_t ret = re_syntax_options;\n\n  re_syntax_options = syntax;\n  return ret;\n}",
      "lines": 8,
      "depth": 5,
      "decorators": [
        "reg_syntax_t"
      ]
    },
    "re_compile_fastmap": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "int\nre_compile_fastmap (struct re_pattern_buffer *bufp)\n{\n  re_dfa_t *dfa = bufp->buffer;\n  char *fastmap = bufp->fastmap;\n\n  memset (fastmap, '\\0', sizeof (char) * SBC_MAX);\n  re_compile_fastmap_iter (bufp, dfa->init_state, fastmap);\n  if (dfa->init_state != dfa->init_state_word)\n    re_compile_fastmap_iter (bufp, dfa->init_state_word, fastmap);\n  if (dfa->init_state != dfa->init_state_nl)\n    re_compile_fastmap_iter (bufp, dfa->init_state_nl, fastmap);\n  if (dfa->init_state != dfa->init_state_begbuf)\n    re_compile_fastmap_iter (bufp, dfa->init_state_begbuf, fastmap);\n  bufp->fastmap_accurate = 1;\n  return 0;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "re_set_fastmap": {
      "start_point": [
        287,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "static inline void\n__attribute__ ((always_inline))\nre_set_fastmap (char *fastmap, bool icase, int ch)\n{\n  fastmap[ch] = 1;\n  if (icase)\n    fastmap[tolower (ch)] = 1;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "re_compile_fastmap_iter": {
      "start_point": [
        299,
        0
      ],
      "end_point": [
        427,
        1
      ],
      "content": "static void\nre_compile_fastmap_iter (regex_t *bufp, const re_dfastate_t *init_state,\n\t\t\t char *fastmap)\n{\n  re_dfa_t *dfa = bufp->buffer;\n  Idx node_cnt;\n  bool icase = (dfa->mb_cur_max == 1 && (bufp->syntax & RE_ICASE));\n  for (node_cnt = 0; node_cnt < init_state->nodes.nelem; ++node_cnt)\n    {\n      Idx node = init_state->nodes.elems[node_cnt];\n      re_token_type_t type = dfa->nodes[node].type;\n\n      if (type == CHARACTER)\n\t{\n\t  re_set_fastmap (fastmap, icase, dfa->nodes[node].opr.c);\n#ifdef RE_ENABLE_I18N\n\t  if ((bufp->syntax & RE_ICASE) && dfa->mb_cur_max > 1)\n\t    {\n\t      unsigned char buf[MB_LEN_MAX];\n\t      unsigned char *p;\n\t      wchar_t wc;\n\t      mbstate_t state;\n\n\t      p = buf;\n\t      *p++ = dfa->nodes[node].opr.c;\n\t      while (++node < dfa->nodes_len\n\t\t     &&\tdfa->nodes[node].type == CHARACTER\n\t\t     && dfa->nodes[node].mb_partial)\n\t\t*p++ = dfa->nodes[node].opr.c;\n\t      memset (&state, '\\0', sizeof (state));\n\t      if (__mbrtowc (&wc, (const char *) buf, p - buf,\n\t\t\t     &state) == p - buf\n\t\t  && (__wcrtomb ((char *) buf, __towlower (wc), &state)\n\t\t      != (size_t) -1))\n\t\tre_set_fastmap (fastmap, false, buf[0]);\n\t    }\n#endif\n\t}\n      else if (type == SIMPLE_BRACKET)\n\t{\n\t  int i, ch;\n\t  for (i = 0, ch = 0; i < BITSET_WORDS; ++i)\n\t    {\n\t      int j;\n\t      bitset_word_t w = dfa->nodes[node].opr.sbcset[i];\n\t      for (j = 0; j < BITSET_WORD_BITS; ++j, ++ch)\n\t\tif (w & ((bitset_word_t) 1 << j))\n\t\t  re_set_fastmap (fastmap, icase, ch);\n\t    }\n\t}\n#ifdef RE_ENABLE_I18N\n      else if (type == COMPLEX_BRACKET)\n\t{\n\t  re_charset_t *cset = dfa->nodes[node].opr.mbcset;\n\t  Idx i;\n\n# ifdef _LIBC\n\t  /* See if we have to try all bytes which start multiple collation\n\t     elements.\n\t     e.g. In da_DK, we want to catch 'a' since \"aa\" is a valid\n\t\t  collation element, and don't catch 'b' since 'b' is\n\t\t  the only collation element which starts from 'b' (and\n\t\t  it is caught by SIMPLE_BRACKET).  */\n\t      if (_NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES) != 0\n\t\t  && (cset->ncoll_syms || cset->nranges))\n\t\t{\n\t\t  const int32_t *table = (const int32_t *)\n\t\t    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n\t\t  for (i = 0; i < SBC_MAX; ++i)\n\t\t    if (table[i] < 0)\n\t\t      re_set_fastmap (fastmap, icase, i);\n\t\t}\n# endif /* _LIBC */\n\n\t  /* See if we have to start the match at all multibyte characters,\n\t     i.e. where we would not find an invalid sequence.  This only\n\t     applies to multibyte character sets; for single byte character\n\t     sets, the SIMPLE_BRACKET again suffices.  */\n\t  if (dfa->mb_cur_max > 1\n\t      && (cset->nchar_classes || cset->non_match || cset->nranges\n# ifdef _LIBC\n\t\t  || cset->nequiv_classes\n# endif /* _LIBC */\n\t\t ))\n\t    {\n\t      unsigned char c = 0;\n\t      do\n\t\t{\n\t\t  mbstate_t mbs;\n\t\t  memset (&mbs, 0, sizeof (mbs));\n\t\t  if (__mbrtowc (NULL, (char *) &c, 1, &mbs) == (size_t) -2)\n\t\t    re_set_fastmap (fastmap, false, (int) c);\n\t\t}\n\t      while (++c != 0);\n\t    }\n\n\t  else\n\t    {\n\t      /* ... Else catch all bytes which can start the mbchars.  */\n\t      for (i = 0; i < cset->nmbchars; ++i)\n\t\t{\n\t\t  char buf[256];\n\t\t  mbstate_t state;\n\t\t  memset (&state, '\\0', sizeof (state));\n\t\t  if (__wcrtomb (buf, cset->mbchars[i], &state) != (size_t) -1)\n\t\t    re_set_fastmap (fastmap, icase, *(unsigned char *) buf);\n\t\t  if ((bufp->syntax & RE_ICASE) && dfa->mb_cur_max > 1)\n\t\t    {\n\t\t      if (__wcrtomb (buf, __towlower (cset->mbchars[i]), &state)\n\t\t\t  != (size_t) -1)\n\t\t\tre_set_fastmap (fastmap, false, *(unsigned char *) buf);\n\t\t    }\n\t\t}\n\t    }\n\t}\n#endif /* RE_ENABLE_I18N */\n      else if (type == OP_PERIOD\n#ifdef RE_ENABLE_I18N\n\t       || type == OP_UTF8_PERIOD\n#endif /* RE_ENABLE_I18N */\n\t       || type == END_OF_RE)\n\t{\n\t  memset (fastmap, '\\1', sizeof (char) * SBC_MAX);\n\t  if (type == END_OF_RE)\n\t    bufp->can_be_null = 1;\n\t  return;\n\t}\n    }\n}",
      "lines": 129,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "regcomp": {
      "start_point": [
        465,
        0
      ],
      "end_point": [
        516,
        1
      ],
      "content": "int\nregcomp (regex_t *_Restrict_ preg, const char *_Restrict_ pattern, int cflags)\n{\n  reg_errcode_t ret;\n  reg_syntax_t syntax = ((cflags & REG_EXTENDED) ? RE_SYNTAX_POSIX_EXTENDED\n\t\t\t : RE_SYNTAX_POSIX_BASIC);\n\n  preg->buffer = NULL;\n  preg->allocated = 0;\n  preg->used = 0;\n\n  /* Try to allocate space for the fastmap.  */\n  preg->fastmap = re_malloc (char, SBC_MAX);\n  if (BE (preg->fastmap == NULL, 0))\n    return REG_ESPACE;\n\n  syntax |= (cflags & REG_ICASE) ? RE_ICASE : 0;\n\n  /* If REG_NEWLINE is set, newlines are treated differently.  */\n  if (cflags & REG_NEWLINE)\n    { /* REG_NEWLINE implies neither . nor [^...] match newline.  */\n      syntax &= ~RE_DOT_NEWLINE;\n      syntax |= RE_HAT_LISTS_NOT_NEWLINE;\n      /* It also changes the matching behavior.  */\n      preg->newline_anchor = 1;\n    }\n  else\n    preg->newline_anchor = 0;\n  preg->no_sub = !!(cflags & REG_NOSUB);\n  preg->translate = NULL;\n\n  ret = re_compile_internal (preg, pattern, strlen (pattern), syntax);\n\n  /* POSIX doesn't distinguish between an unmatched open-group and an\n     unmatched close-group: both are REG_EPAREN.  */\n  if (ret == REG_ERPAREN)\n    ret = REG_EPAREN;\n\n  /* We have already checked preg->fastmap != NULL.  */\n  if (BE (ret == REG_NOERROR, 1))\n    /* Compute the fastmap now, since regexec cannot modify the pattern\n       buffer.  This function never fails in this implementation.  */\n    (void) re_compile_fastmap (preg);\n  else\n    {\n      /* Some error occurred while compiling the expression.  */\n      re_free (preg->fastmap);\n      preg->fastmap = NULL;\n    }\n\n  return (int) ret;\n}",
      "lines": 52,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "regerror": {
      "start_point": [
        524,
        0
      ],
      "end_point": [
        556,
        1
      ],
      "content": "size_t\nregerror (int errcode, const regex_t *_Restrict_ preg, char *_Restrict_ errbuf,\n\t  size_t errbuf_size)\n{\n  const char *msg;\n  size_t msg_size;\n\n  if (BE (errcode < 0\n\t  || errcode >= (int) (sizeof (__re_error_msgid_idx)\n\t\t\t       / sizeof (__re_error_msgid_idx[0])), 0))\n    /* Only error codes returned by the rest of the code should be passed\n       to this routine.  If we are given anything else, or if other regex\n       code generates an invalid error code, then the program has a bug.\n       Dump core so we can fix it.  */\n    abort ();\n\n  msg = gettext (__re_error_msgid + __re_error_msgid_idx[errcode]);\n\n  msg_size = strlen (msg) + 1; /* Includes the null.  */\n\n  if (BE (errbuf_size != 0, 1))\n    {\n      size_t cpy_size = msg_size;\n      if (BE (msg_size > errbuf_size, 0))\n\t{\n\t  cpy_size = errbuf_size - 1;\n\t  errbuf[cpy_size] = '\\0';\n\t}\n      memcpy (errbuf, msg, cpy_size);\n    }\n\n  return msg_size;\n}",
      "lines": 33,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    },
    "free_dfa_content": {
      "start_point": [
        591,
        0
      ],
      "end_point": [
        636,
        1
      ],
      "content": "static void\nfree_dfa_content (re_dfa_t *dfa)\n{\n  Idx i, j;\n\n  if (dfa->nodes)\n    for (i = 0; i < dfa->nodes_len; ++i)\n      free_token (dfa->nodes + i);\n  re_free (dfa->nexts);\n  for (i = 0; i < dfa->nodes_len; ++i)\n    {\n      if (dfa->eclosures != NULL)\n\tre_node_set_free (dfa->eclosures + i);\n      if (dfa->inveclosures != NULL)\n\tre_node_set_free (dfa->inveclosures + i);\n      if (dfa->edests != NULL)\n\tre_node_set_free (dfa->edests + i);\n    }\n  re_free (dfa->edests);\n  re_free (dfa->eclosures);\n  re_free (dfa->inveclosures);\n  re_free (dfa->nodes);\n\n  if (dfa->state_table)\n    for (i = 0; i <= dfa->state_hash_mask; ++i)\n      {\n\tstruct re_state_table_entry *entry = dfa->state_table + i;\n\tfor (j = 0; j < entry->num; ++j)\n\t  {\n\t    re_dfastate_t *state = entry->array[j];\n\t    free_state (state);\n\t  }\n\tre_free (entry->array);\n      }\n  re_free (dfa->state_table);\n#ifdef RE_ENABLE_I18N\n  if (dfa->sb_char != utf8_sb_map)\n    re_free (dfa->sb_char);\n#endif\n  re_free (dfa->subexp_map);\n#ifdef DEBUG\n  re_free (dfa->re_str);\n#endif\n\n  re_free (dfa);\n}",
      "lines": 46,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "regfree": {
      "start_point": [
        641,
        0
      ],
      "end_point": [
        658,
        1
      ],
      "content": "void\nregfree (regex_t *preg)\n{\n  re_dfa_t *dfa = preg->buffer;\n  if (BE (dfa != NULL, 1))\n    {\n      lock_fini (dfa->lock);\n      free_dfa_content (dfa);\n    }\n  preg->buffer = NULL;\n  preg->allocated = 0;\n\n  re_free (preg->fastmap);\n  preg->fastmap = NULL;\n\n  re_free (preg->translate);\n  preg->translate = NULL;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "re_comp": {
      "start_point": [
        676,
        0
      ],
      "end_point": [
        720,
        1
      ],
      "content": "weak_function\n# endif\nre_comp (const char *s)\n{\n  reg_errcode_t ret;\n  char *fastmap;\n\n  if (!s)\n    {\n      if (!re_comp_buf.buffer)\n\treturn gettext (\"No previous regular expression\");\n      return 0;\n    }\n\n  if (re_comp_buf.buffer)\n    {\n      fastmap = re_comp_buf.fastmap;\n      re_comp_buf.fastmap = NULL;\n      __regfree (&re_comp_buf);\n      memset (&re_comp_buf, '\\0', sizeof (re_comp_buf));\n      re_comp_buf.fastmap = fastmap;\n    }\n\n  if (re_comp_buf.fastmap == NULL)\n    {\n      re_comp_buf.fastmap = (char *) malloc (SBC_MAX);\n      if (re_comp_buf.fastmap == NULL)\n\treturn (char *) gettext (__re_error_msgid\n\t\t\t\t + __re_error_msgid_idx[(int) REG_ESPACE]);\n    }\n\n  /* Since 're_exec' always passes NULL for the 'regs' argument, we\n     don't need to initialize the pattern buffer fields which affect it.  */\n\n  /* Match anchors at newlines.  */\n  re_comp_buf.newline_anchor = 1;\n\n  ret = re_compile_internal (&re_comp_buf, s, strlen (s), re_syntax_options);\n\n  if (!ret)\n    return NULL;\n\n  /* Yes, we're discarding 'const' here if !HAVE_LIBINTL.  */\n  return (char *) gettext (__re_error_msgid + __re_error_msgid_idx[(int) ret]);\n}",
      "lines": 45,
      "depth": 14,
      "decorators": [
        "weak_function",
        "# endif",
        "# endif"
      ]
    },
    "free_mem": {
      "start_point": [
        723,
        0
      ],
      "end_point": [
        726,
        1
      ],
      "content": "libc_freeres_fn (free_mem)\n{\n  __regfree (&re_comp_buf);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": null
    },
    "re_compile_internal": {
      "start_point": [
        735,
        0
      ],
      "end_point": [
        831,
        1
      ],
      "content": "static reg_errcode_t\nre_compile_internal (regex_t *preg, const char * pattern, size_t length,\n\t\t     reg_syntax_t syntax)\n{\n  reg_errcode_t err = REG_NOERROR;\n  re_dfa_t *dfa;\n  re_string_t regexp;\n\n  /* Initialize the pattern buffer.  */\n  preg->fastmap_accurate = 0;\n  preg->syntax = syntax;\n  preg->not_bol = preg->not_eol = 0;\n  preg->used = 0;\n  preg->re_nsub = 0;\n  preg->can_be_null = 0;\n  preg->regs_allocated = REGS_UNALLOCATED;\n\n  /* Initialize the dfa.  */\n  dfa = preg->buffer;\n  if (BE (preg->allocated < sizeof (re_dfa_t), 0))\n    {\n      /* If zero allocated, but buffer is non-null, try to realloc\n\t enough space.  This loses if buffer's address is bogus, but\n\t that is the user's responsibility.  If ->buffer is NULL this\n\t is a simple allocation.  */\n      dfa = re_realloc (preg->buffer, re_dfa_t, 1);\n      if (dfa == NULL)\n\treturn REG_ESPACE;\n      preg->allocated = sizeof (re_dfa_t);\n      preg->buffer = dfa;\n    }\n  preg->used = sizeof (re_dfa_t);\n\n  err = init_dfa (dfa, length);\n  if (BE (err == REG_NOERROR && lock_init (dfa->lock) != 0, 0))\n    err = REG_ESPACE;\n  if (BE (err != REG_NOERROR, 0))\n    {\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n      return err;\n    }\n#ifdef DEBUG\n  /* Note: length+1 will not overflow since it is checked in init_dfa.  */\n  dfa->re_str = re_malloc (char, length + 1);\n  strncpy (dfa->re_str, pattern, length + 1);\n#endif\n\n  err = re_string_construct (&regexp, pattern, length, preg->translate,\n\t\t\t     (syntax & RE_ICASE) != 0, dfa);\n  if (BE (err != REG_NOERROR, 0))\n    {\n    re_compile_internal_free_return:\n      free_workarea_compile (preg);\n      re_string_destruct (&regexp);\n      lock_fini (dfa->lock);\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n      return err;\n    }\n\n  /* Parse the regular expression, and build a structure tree.  */\n  preg->re_nsub = 0;\n  dfa->str_tree = parse (&regexp, preg, syntax, &err);\n  if (BE (dfa->str_tree == NULL, 0))\n    goto re_compile_internal_free_return;\n\n  /* Analyze the tree and create the nfa.  */\n  err = analyze (preg);\n  if (BE (err != REG_NOERROR, 0))\n    goto re_compile_internal_free_return;\n\n#ifdef RE_ENABLE_I18N\n  /* If possible, do searching in single byte encoding to speed things up.  */\n  if (dfa->is_utf8 && !(syntax & RE_ICASE) && preg->translate == NULL)\n    optimize_utf8 (dfa);\n#endif\n\n  /* Then create the initial state of the dfa.  */\n  err = create_initial_state (dfa);\n\n  /* Release work areas.  */\n  free_workarea_compile (preg);\n  re_string_destruct (&regexp);\n\n  if (BE (err != REG_NOERROR, 0))\n    {\n      lock_fini (dfa->lock);\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n    }\n\n  return err;\n}",
      "lines": 97,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "init_dfa": {
      "start_point": [
        836,
        0
      ],
      "end_point": [
        930,
        1
      ],
      "content": "static reg_errcode_t\ninit_dfa (re_dfa_t *dfa, size_t pat_len)\n{\n  __re_size_t table_size;\n#ifndef _LIBC\n  const char *codeset_name;\n#endif\n#ifdef RE_ENABLE_I18N\n  size_t max_i18n_object_size = MAX (sizeof (wchar_t), sizeof (wctype_t));\n#else\n  size_t max_i18n_object_size = 0;\n#endif\n  size_t max_object_size =\n    MAX (sizeof (struct re_state_table_entry),\n\t MAX (sizeof (re_token_t),\n\t      MAX (sizeof (re_node_set),\n\t\t   MAX (sizeof (regmatch_t),\n\t\t\tmax_i18n_object_size))));\n\n  memset (dfa, '\\0', sizeof (re_dfa_t));\n\n  /* Force allocation of str_tree_storage the first time.  */\n  dfa->str_tree_storage_idx = BIN_TREE_STORAGE_SIZE;\n\n  /* Avoid overflows.  The extra \"/ 2\" is for the table_size doubling\n     calculation below, and for similar doubling calculations\n     elsewhere.  And it's <= rather than <, because some of the\n     doubling calculations add 1 afterwards.  */\n  if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) / 2 <= pat_len, 0))\n    return REG_ESPACE;\n\n  dfa->nodes_alloc = pat_len + 1;\n  dfa->nodes = re_malloc (re_token_t, dfa->nodes_alloc);\n\n  /*  table_size = 2 ^ ceil(log pat_len) */\n  for (table_size = 1; ; table_size <<= 1)\n    if (table_size > pat_len)\n      break;\n\n  dfa->state_table = calloc (sizeof (struct re_state_table_entry), table_size);\n  dfa->state_hash_mask = table_size - 1;\n\n  dfa->mb_cur_max = MB_CUR_MAX;\n#ifdef _LIBC\n  if (dfa->mb_cur_max == 6\n      && strcmp (_NL_CURRENT (LC_CTYPE, _NL_CTYPE_CODESET_NAME), \"UTF-8\") == 0)\n    dfa->is_utf8 = 1;\n  dfa->map_notascii = (_NL_CURRENT_WORD (LC_CTYPE, _NL_CTYPE_MAP_TO_NONASCII)\n\t\t       != 0);\n#else\n  codeset_name = nl_langinfo (CODESET);\n  if ((codeset_name[0] == 'U' || codeset_name[0] == 'u')\n      && (codeset_name[1] == 'T' || codeset_name[1] == 't')\n      && (codeset_name[2] == 'F' || codeset_name[2] == 'f')\n      && strcmp (codeset_name + 3 + (codeset_name[3] == '-'), \"8\") == 0)\n    dfa->is_utf8 = 1;\n\n  /* We check exhaustively in the loop below if this charset is a\n     superset of ASCII.  */\n  dfa->map_notascii = 0;\n#endif\n\n#ifdef RE_ENABLE_I18N\n  if (dfa->mb_cur_max > 1)\n    {\n      if (dfa->is_utf8)\n\tdfa->sb_char = (re_bitset_ptr_t) utf8_sb_map;\n      else\n\t{\n\t  int i, j, ch;\n\n\t  dfa->sb_char = (re_bitset_ptr_t) calloc (sizeof (bitset_t), 1);\n\t  if (BE (dfa->sb_char == NULL, 0))\n\t    return REG_ESPACE;\n\n\t  /* Set the bits corresponding to single byte chars.  */\n\t  for (i = 0, ch = 0; i < BITSET_WORDS; ++i)\n\t    for (j = 0; j < BITSET_WORD_BITS; ++j, ++ch)\n\t      {\n\t\twint_t wch = __btowc (ch);\n\t\tif (wch != WEOF)\n\t\t  dfa->sb_char[i] |= (bitset_word_t) 1 << j;\n# ifndef _LIBC\n\t\tif (isascii (ch) && wch != ch)\n\t\t  dfa->map_notascii = 1;\n# endif\n\t      }\n\t}\n    }\n#endif\n\n  if (BE (dfa->nodes == NULL || dfa->state_table == NULL, 0))\n    return REG_ESPACE;\n  return REG_NOERROR;\n}",
      "lines": 95,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "init_word_char": {
      "start_point": [
        936,
        0
      ],
      "end_point": [
        980,
        1
      ],
      "content": "static void\ninternal_function\ninit_word_char (re_dfa_t *dfa)\n{\n  int i = 0;\n  int j;\n  int ch = 0;\n  dfa->word_ops_used = 1;\n  if (BE (dfa->map_notascii == 0, 1))\n    {\n      bitset_word_t bits0 = 0x00000000;\n      bitset_word_t bits1 = 0x03ff0000;\n      bitset_word_t bits2 = 0x87fffffe;\n      bitset_word_t bits3 = 0x07fffffe;\n      if (BITSET_WORD_BITS == 64)\n\t{\n\t  dfa->word_char[0] = bits1 << 31 << 1 | bits0;\n\t  dfa->word_char[1] = bits3 << 31 << 1 | bits2;\n\t  i = 2;\n\t}\n      else if (BITSET_WORD_BITS == 32)\n\t{\n\t  dfa->word_char[0] = bits0;\n\t  dfa->word_char[1] = bits1;\n\t  dfa->word_char[2] = bits2;\n\t  dfa->word_char[3] = bits3;\n\t  i = 4;\n\t}\n      else\n        goto general_case;\n      ch = 128;\n\n      if (BE (dfa->is_utf8, 1))\n\t{\n\t  memset (&dfa->word_char[i], '\\0', (SBC_MAX - ch) / 8);\n\t  return;\n\t}\n    }\n\n general_case:\n  for (; i < BITSET_WORDS; ++i)\n    for (j = 0; j < BITSET_WORD_BITS; ++j, ++ch)\n      if (isalnum (ch) || ch == '_')\n\tdfa->word_char[i] |= (bitset_word_t) 1 << j;\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "free_workarea_compile": {
      "start_point": [
        984,
        0
      ],
      "end_point": [
        999,
        1
      ],
      "content": "static void\nfree_workarea_compile (regex_t *preg)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_storage_t *storage, *next;\n  for (storage = dfa->str_tree_storage; storage; storage = next)\n    {\n      next = storage->next;\n      re_free (storage);\n    }\n  dfa->str_tree_storage = NULL;\n  dfa->str_tree_storage_idx = BIN_TREE_STORAGE_SIZE;\n  dfa->str_tree = NULL;\n  re_free (dfa->org_indices);\n  dfa->org_indices = NULL;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_initial_state": {
      "start_point": [
        1003,
        0
      ],
      "end_point": [
        1081,
        1
      ],
      "content": "static reg_errcode_t\ncreate_initial_state (re_dfa_t *dfa)\n{\n  Idx first, i;\n  reg_errcode_t err;\n  re_node_set init_nodes;\n\n  /* Initial states have the epsilon closure of the node which is\n     the first node of the regular expression.  */\n  first = dfa->str_tree->first->node_idx;\n  dfa->init_node = first;\n  err = re_node_set_init_copy (&init_nodes, dfa->eclosures + first);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n\n  /* The back-references which are in initial states can epsilon transit,\n     since in this case all of the subexpressions can be null.\n     Then we add epsilon closures of the nodes which are the next nodes of\n     the back-references.  */\n  if (dfa->nbackref > 0)\n    for (i = 0; i < init_nodes.nelem; ++i)\n      {\n\tIdx node_idx = init_nodes.elems[i];\n\tre_token_type_t type = dfa->nodes[node_idx].type;\n\n\tIdx clexp_idx;\n\tif (type != OP_BACK_REF)\n\t  continue;\n\tfor (clexp_idx = 0; clexp_idx < init_nodes.nelem; ++clexp_idx)\n\t  {\n\t    re_token_t *clexp_node;\n\t    clexp_node = dfa->nodes + init_nodes.elems[clexp_idx];\n\t    if (clexp_node->type == OP_CLOSE_SUBEXP\n\t\t&& clexp_node->opr.idx == dfa->nodes[node_idx].opr.idx)\n\t      break;\n\t  }\n\tif (clexp_idx == init_nodes.nelem)\n\t  continue;\n\n\tif (type == OP_BACK_REF)\n\t  {\n\t    Idx dest_idx = dfa->edests[node_idx].elems[0];\n\t    if (!re_node_set_contains (&init_nodes, dest_idx))\n\t      {\n\t\treg_errcode_t merge_err\n                  = re_node_set_merge (&init_nodes, dfa->eclosures + dest_idx);\n\t\tif (merge_err != REG_NOERROR)\n\t\t  return merge_err;\n\t\ti = 0;\n\t      }\n\t  }\n      }\n\n  /* It must be the first time to invoke acquire_state.  */\n  dfa->init_state = re_acquire_state_context (&err, dfa, &init_nodes, 0);\n  /* We don't check ERR here, since the initial state must not be NULL.  */\n  if (BE (dfa->init_state == NULL, 0))\n    return err;\n  if (dfa->init_state->has_constraint)\n    {\n      dfa->init_state_word = re_acquire_state_context (&err, dfa, &init_nodes,\n\t\t\t\t\t\t       CONTEXT_WORD);\n      dfa->init_state_nl = re_acquire_state_context (&err, dfa, &init_nodes,\n\t\t\t\t\t\t     CONTEXT_NEWLINE);\n      dfa->init_state_begbuf = re_acquire_state_context (&err, dfa,\n\t\t\t\t\t\t\t &init_nodes,\n\t\t\t\t\t\t\t CONTEXT_NEWLINE\n\t\t\t\t\t\t\t | CONTEXT_BEGBUF);\n      if (BE (dfa->init_state_word == NULL || dfa->init_state_nl == NULL\n\t      || dfa->init_state_begbuf == NULL, 0))\n\treturn err;\n    }\n  else\n    dfa->init_state_word = dfa->init_state_nl\n      = dfa->init_state_begbuf = dfa->init_state;\n\n  re_node_set_free (&init_nodes);\n  return REG_NOERROR;\n}",
      "lines": 79,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "optimize_utf8": {
      "start_point": [
        1088,
        0
      ],
      "end_point": [
        1162,
        1
      ],
      "content": "static void\noptimize_utf8 (re_dfa_t *dfa)\n{\n  Idx node;\n  int i;\n  bool mb_chars = false;\n  bool has_period = false;\n\n  for (node = 0; node < dfa->nodes_len; ++node)\n    switch (dfa->nodes[node].type)\n      {\n      case CHARACTER:\n\tif (dfa->nodes[node].opr.c >= ASCII_CHARS)\n\t  mb_chars = true;\n\tbreak;\n      case ANCHOR:\n\tswitch (dfa->nodes[node].opr.ctx_type)\n\t  {\n\t  case LINE_FIRST:\n\t  case LINE_LAST:\n\t  case BUF_FIRST:\n\t  case BUF_LAST:\n\t    break;\n\t  default:\n\t    /* Word anchors etc. cannot be handled.  It's okay to test\n\t       opr.ctx_type since constraints (for all DFA nodes) are\n\t       created by ORing one or more opr.ctx_type values.  */\n\t    return;\n\t  }\n\tbreak;\n      case OP_PERIOD:\n\thas_period = true;\n\tbreak;\n      case OP_BACK_REF:\n      case OP_ALT:\n      case END_OF_RE:\n      case OP_DUP_ASTERISK:\n      case OP_OPEN_SUBEXP:\n      case OP_CLOSE_SUBEXP:\n\tbreak;\n      case COMPLEX_BRACKET:\n\treturn;\n      case SIMPLE_BRACKET:\n\t/* Just double check.  */\n\t{\n\t  int rshift = (ASCII_CHARS % BITSET_WORD_BITS == 0\n\t\t\t? 0\n\t\t\t: BITSET_WORD_BITS - ASCII_CHARS % BITSET_WORD_BITS);\n\t  for (i = ASCII_CHARS / BITSET_WORD_BITS; i < BITSET_WORDS; ++i)\n\t    {\n\t      if (dfa->nodes[node].opr.sbcset[i] >> rshift != 0)\n\t\treturn;\n\t      rshift = 0;\n\t    }\n\t}\n\tbreak;\n      default:\n\tabort ();\n      }\n\n  if (mb_chars || has_period)\n    for (node = 0; node < dfa->nodes_len; ++node)\n      {\n\tif (dfa->nodes[node].type == CHARACTER\n\t    && dfa->nodes[node].opr.c >= ASCII_CHARS)\n\t  dfa->nodes[node].mb_partial = 0;\n\telse if (dfa->nodes[node].type == OP_PERIOD)\n\t  dfa->nodes[node].type = OP_UTF8_PERIOD;\n      }\n\n  /* The search can be in single byte locale.  */\n  dfa->mb_cur_max = 1;\n  dfa->is_utf8 = 0;\n  dfa->has_mb_node = dfa->nbackref > 0 || has_period;\n}",
      "lines": 75,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "analyze": {
      "start_point": [
        1168,
        0
      ],
      "end_point": [
        1226,
        1
      ],
      "content": "static reg_errcode_t\nanalyze (regex_t *preg)\n{\n  re_dfa_t *dfa = preg->buffer;\n  reg_errcode_t ret;\n\n  /* Allocate arrays.  */\n  dfa->nexts = re_malloc (Idx, dfa->nodes_alloc);\n  dfa->org_indices = re_malloc (Idx, dfa->nodes_alloc);\n  dfa->edests = re_malloc (re_node_set, dfa->nodes_alloc);\n  dfa->eclosures = re_malloc (re_node_set, dfa->nodes_alloc);\n  if (BE (dfa->nexts == NULL || dfa->org_indices == NULL || dfa->edests == NULL\n\t  || dfa->eclosures == NULL, 0))\n    return REG_ESPACE;\n\n  dfa->subexp_map = re_malloc (Idx, preg->re_nsub);\n  if (dfa->subexp_map != NULL)\n    {\n      Idx i;\n      for (i = 0; i < preg->re_nsub; i++)\n\tdfa->subexp_map[i] = i;\n      preorder (dfa->str_tree, optimize_subexps, dfa);\n      for (i = 0; i < preg->re_nsub; i++)\n\tif (dfa->subexp_map[i] != i)\n\t  break;\n      if (i == preg->re_nsub)\n\t{\n\t  free (dfa->subexp_map);\n\t  dfa->subexp_map = NULL;\n\t}\n    }\n\n  ret = postorder (dfa->str_tree, lower_subexps, preg);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n  ret = postorder (dfa->str_tree, calc_first, dfa);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n  preorder (dfa->str_tree, calc_next, dfa);\n  ret = preorder (dfa->str_tree, link_nfa_nodes, dfa);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n  ret = calc_eclosure (dfa);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n\n  /* We only need this during the prune_impossible_nodes pass in regexec.c;\n     skip it if p_i_n will not run, as calc_inveclosure can be quadratic.  */\n  if ((!preg->no_sub && preg->re_nsub > 0 && dfa->has_plural_match)\n      || dfa->nbackref)\n    {\n      dfa->inveclosures = re_malloc (re_node_set, dfa->nodes_len);\n      if (BE (dfa->inveclosures == NULL, 0))\n\treturn REG_ESPACE;\n      ret = calc_inveclosure (dfa);\n    }\n\n  return ret;\n}",
      "lines": 59,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "postorder": {
      "start_point": [
        1231,
        0
      ],
      "end_point": [
        1261,
        1
      ],
      "content": "static reg_errcode_t\npostorder (bin_tree_t *root, reg_errcode_t (fn (void *, bin_tree_t *)),\n\t   void *extra)\n{\n  bin_tree_t *node, *prev;\n\n  for (node = root; ; )\n    {\n      /* Descend down the tree, preferably to the left (or to the right\n\t if that's the only child).  */\n      while (node->left || node->right)\n\tif (node->left)\n\t  node = node->left;\n\telse\n\t  node = node->right;\n\n      do\n\t{\n\t  reg_errcode_t err = fn (extra, node);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t  if (node->parent == NULL)\n\t    return REG_NOERROR;\n\t  prev = node;\n\t  node = node->parent;\n\t}\n      /* Go up while we have a node that is reached from the right.  */\n      while (node->right == prev || node->right == NULL);\n      node = node->right;\n    }\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "preorder": {
      "start_point": [
        1263,
        0
      ],
      "end_point": [
        1291,
        1
      ],
      "content": "static reg_errcode_t\npreorder (bin_tree_t *root, reg_errcode_t (fn (void *, bin_tree_t *)),\n\t  void *extra)\n{\n  bin_tree_t *node;\n\n  for (node = root; ; )\n    {\n      reg_errcode_t err = fn (extra, node);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n\n      /* Go to the left node, or up and to the right.  */\n      if (node->left)\n\tnode = node->left;\n      else\n\t{\n\t  bin_tree_t *prev = NULL;\n\t  while (node->right == prev || node->right == NULL)\n\t    {\n\t      prev = node;\n\t      node = node->parent;\n\t      if (!node)\n\t\treturn REG_NOERROR;\n\t    }\n\t  node = node->right;\n\t}\n    }\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "optimize_subexps": {
      "start_point": [
        1296,
        0
      ],
      "end_point": [
        1323,
        1
      ],
      "content": "static reg_errcode_t\noptimize_subexps (void *extra, bin_tree_t *node)\n{\n  re_dfa_t *dfa = (re_dfa_t *) extra;\n\n  if (node->token.type == OP_BACK_REF && dfa->subexp_map)\n    {\n      int idx = node->token.opr.idx;\n      node->token.opr.idx = dfa->subexp_map[idx];\n      dfa->used_bkref_map |= 1 << node->token.opr.idx;\n    }\n\n  else if (node->token.type == SUBEXP\n\t   && node->left && node->left->token.type == SUBEXP)\n    {\n      Idx other_idx = node->left->token.opr.idx;\n\n      node->left = node->left->left;\n      if (node->left)\n\tnode->left->parent = node;\n\n      dfa->subexp_map[other_idx] = dfa->subexp_map[node->token.opr.idx];\n      if (other_idx < BITSET_WORD_BITS)\n\tdfa->used_bkref_map &= ~((bitset_word_t) 1 << other_idx);\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "lower_subexps": {
      "start_point": [
        1327,
        0
      ],
      "end_point": [
        1347,
        1
      ],
      "content": "static reg_errcode_t\nlower_subexps (void *extra, bin_tree_t *node)\n{\n  regex_t *preg = (regex_t *) extra;\n  reg_errcode_t err = REG_NOERROR;\n\n  if (node->left && node->left->token.type == SUBEXP)\n    {\n      node->left = lower_subexp (&err, preg, node->left);\n      if (node->left)\n\tnode->left->parent = node;\n    }\n  if (node->right && node->right->token.type == SUBEXP)\n    {\n      node->right = lower_subexp (&err, preg, node->right);\n      if (node->right)\n\tnode->right->parent = node;\n    }\n\n  return err;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "lower_subexp": {
      "start_point": [
        1349,
        0
      ],
      "end_point": [
        1382,
        1
      ],
      "content": "static bin_tree_t *\nlower_subexp (reg_errcode_t *err, regex_t *preg, bin_tree_t *node)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *body = node->left;\n  bin_tree_t *op, *cls, *tree1, *tree;\n\n  if (preg->no_sub\n      /* We do not optimize empty subexpressions, because otherwise we may\n\t have bad CONCAT nodes with NULL children.  This is obviously not\n\t very common, so we do not lose much.  An example that triggers\n\t this case is the sed \"script\" /\\(\\)/x.  */\n      && node->left != NULL\n      && (node->token.opr.idx >= BITSET_WORD_BITS\n\t  || !(dfa->used_bkref_map\n\t       & ((bitset_word_t) 1 << node->token.opr.idx))))\n    return node->left;\n\n  /* Convert the SUBEXP node to the concatenation of an\n     OP_OPEN_SUBEXP, the contents, and an OP_CLOSE_SUBEXP.  */\n  op = create_tree (dfa, NULL, NULL, OP_OPEN_SUBEXP);\n  cls = create_tree (dfa, NULL, NULL, OP_CLOSE_SUBEXP);\n  tree1 = body ? create_tree (dfa, body, cls, CONCAT) : cls;\n  tree = create_tree (dfa, op, tree1, CONCAT);\n  if (BE (tree == NULL || tree1 == NULL || op == NULL || cls == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n\n  op->token.opr.idx = cls->token.opr.idx = node->token.opr.idx;\n  op->token.opt_subexp = cls->token.opt_subexp = node->token.opt_subexp;\n  return tree;\n}",
      "lines": 34,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nlower_subexp (reg_errcode_t *err, regex_t *preg, bin_tree_t *node)",
        "*"
      ]
    },
    "calc_first": {
      "start_point": [
        1386,
        0
      ],
      "end_point": [
        1405,
        1
      ],
      "content": "static reg_errcode_t\ncalc_first (void *extra, bin_tree_t *node)\n{\n  re_dfa_t *dfa = (re_dfa_t *) extra;\n  if (node->token.type == CONCAT)\n    {\n      node->first = node->left->first;\n      node->node_idx = node->left->node_idx;\n    }\n  else\n    {\n      node->first = node;\n      node->node_idx = re_dfa_add_node (dfa, node->token);\n      if (BE (node->node_idx == -1, 0))\n\treturn REG_ESPACE;\n      if (node->token.type == ANCHOR)\n\tdfa->nodes[node->node_idx].constraint = node->token.opr.ctx_type;\n    }\n  return REG_NOERROR;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "calc_next": {
      "start_point": [
        1408,
        0
      ],
      "end_point": [
        1428,
        1
      ],
      "content": "static reg_errcode_t\ncalc_next (void *extra, bin_tree_t *node)\n{\n  switch (node->token.type)\n    {\n    case OP_DUP_ASTERISK:\n      node->left->next = node;\n      break;\n    case CONCAT:\n      node->left->next = node->right->first;\n      node->right->next = node->next;\n      break;\n    default:\n      if (node->left)\n\tnode->left->next = node->next;\n      if (node->right)\n\tnode->right->next = node->next;\n      break;\n    }\n  return REG_NOERROR;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "link_nfa_nodes": {
      "start_point": [
        1431,
        0
      ],
      "end_point": [
        1485,
        1
      ],
      "content": "static reg_errcode_t\nlink_nfa_nodes (void *extra, bin_tree_t *node)\n{\n  re_dfa_t *dfa = (re_dfa_t *) extra;\n  Idx idx = node->node_idx;\n  reg_errcode_t err = REG_NOERROR;\n\n  switch (node->token.type)\n    {\n    case CONCAT:\n      break;\n\n    case END_OF_RE:\n      assert (node->next == NULL);\n      break;\n\n    case OP_DUP_ASTERISK:\n    case OP_ALT:\n      {\n\tIdx left, right;\n\tdfa->has_plural_match = 1;\n\tif (node->left != NULL)\n\t  left = node->left->first->node_idx;\n\telse\n\t  left = node->next->node_idx;\n\tif (node->right != NULL)\n\t  right = node->right->first->node_idx;\n\telse\n\t  right = node->next->node_idx;\n\tassert (left > -1);\n\tassert (right > -1);\n\terr = re_node_set_init_2 (dfa->edests + idx, left, right);\n      }\n      break;\n\n    case ANCHOR:\n    case OP_OPEN_SUBEXP:\n    case OP_CLOSE_SUBEXP:\n      err = re_node_set_init_1 (dfa->edests + idx, node->next->node_idx);\n      break;\n\n    case OP_BACK_REF:\n      dfa->nexts[idx] = node->next->node_idx;\n      if (node->token.type == OP_BACK_REF)\n\terr = re_node_set_init_1 (dfa->edests + idx, dfa->nexts[idx]);\n      break;\n\n    default:\n      assert (!IS_EPSILON_NODE (node->token.type));\n      dfa->nexts[idx] = node->next->node_idx;\n      break;\n    }\n\n  return err;\n}",
      "lines": 55,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "duplicate_node_closure": {
      "start_point": [
        1491,
        0
      ],
      "end_point": [
        1594,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nduplicate_node_closure (re_dfa_t *dfa, Idx top_org_node, Idx top_clone_node,\n\t\t\tIdx root_node, unsigned int init_constraint)\n{\n  Idx org_node, clone_node;\n  bool ok;\n  unsigned int constraint = init_constraint;\n  for (org_node = top_org_node, clone_node = top_clone_node;;)\n    {\n      Idx org_dest, clone_dest;\n      if (dfa->nodes[org_node].type == OP_BACK_REF)\n\t{\n\t  /* If the back reference epsilon-transit, its destination must\n\t     also have the constraint.  Then duplicate the epsilon closure\n\t     of the destination of the back reference, and store it in\n\t     edests of the back reference.  */\n\t  org_dest = dfa->nexts[org_node];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (BE (clone_dest == -1, 0))\n\t    return REG_ESPACE;\n\t  dfa->nexts[clone_node] = dfa->nexts[org_node];\n\t  ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (BE (! ok, 0))\n\t    return REG_ESPACE;\n\t}\n      else if (dfa->edests[org_node].nelem == 0)\n\t{\n\t  /* In case of the node can't epsilon-transit, don't duplicate the\n\t     destination and store the original destination as the\n\t     destination of the node.  */\n\t  dfa->nexts[clone_node] = dfa->nexts[org_node];\n\t  break;\n\t}\n      else if (dfa->edests[org_node].nelem == 1)\n\t{\n\t  /* In case of the node can epsilon-transit, and it has only one\n\t     destination.  */\n\t  org_dest = dfa->edests[org_node].elems[0];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t  /* If the node is root_node itself, it means the epsilon closure\n\t     has a loop.  Then tie it to the destination of the root_node.  */\n\t  if (org_node == root_node && clone_node != org_node)\n\t    {\n\t      ok = re_node_set_insert (dfa->edests + clone_node, org_dest);\n\t      if (BE (! ok, 0))\n\t        return REG_ESPACE;\n\t      break;\n\t    }\n\t  /* In case the node has another constraint, append it.  */\n\t  constraint |= dfa->nodes[org_node].constraint;\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (BE (clone_dest == -1, 0))\n\t    return REG_ESPACE;\n\t  ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (BE (! ok, 0))\n\t    return REG_ESPACE;\n\t}\n      else /* dfa->edests[org_node].nelem == 2 */\n\t{\n\t  /* In case of the node can epsilon-transit, and it has two\n\t     destinations. In the bin_tree_t and DFA, that's '|' and '*'.   */\n\t  org_dest = dfa->edests[org_node].elems[0];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t  /* Search for a duplicated node which satisfies the constraint.  */\n\t  clone_dest = search_duplicated_node (dfa, org_dest, constraint);\n\t  if (clone_dest == -1)\n\t    {\n\t      /* There is no such duplicated node, create a new one.  */\n\t      reg_errcode_t err;\n\t      clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t      if (BE (clone_dest == -1, 0))\n\t\treturn REG_ESPACE;\n\t      ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t      if (BE (! ok, 0))\n\t\treturn REG_ESPACE;\n\t      err = duplicate_node_closure (dfa, org_dest, clone_dest,\n\t\t\t\t\t    root_node, constraint);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t  else\n\t    {\n\t      /* There is a duplicated node which satisfies the constraint,\n\t\t use it to avoid infinite loop.  */\n\t      ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t      if (BE (! ok, 0))\n\t\treturn REG_ESPACE;\n\t    }\n\n\t  org_dest = dfa->edests[org_node].elems[1];\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (BE (clone_dest == -1, 0))\n\t    return REG_ESPACE;\n\t  ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (BE (! ok, 0))\n\t    return REG_ESPACE;\n\t}\n      org_node = org_dest;\n      clone_node = clone_dest;\n    }\n  return REG_NOERROR;\n}",
      "lines": 104,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "search_duplicated_node": {
      "start_point": [
        1599,
        0
      ],
      "end_point": [
        1611,
        1
      ],
      "content": "static Idx\nsearch_duplicated_node (const re_dfa_t *dfa, Idx org_node,\n\t\t\tunsigned int constraint)\n{\n  Idx idx;\n  for (idx = dfa->nodes_len - 1; dfa->nodes[idx].duplicated && idx > 0; --idx)\n    {\n      if (org_node == dfa->org_indices[idx]\n\t  && constraint == dfa->nodes[idx].constraint)\n\treturn idx; /* Found.  */\n    }\n  return -1; /* Not found.  */\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "Idx"
      ]
    },
    "duplicate_node": {
      "start_point": [
        1617,
        0
      ],
      "end_point": [
        1631,
        1
      ],
      "content": "static Idx\nduplicate_node (re_dfa_t *dfa, Idx org_idx, unsigned int constraint)\n{\n  Idx dup_idx = re_dfa_add_node (dfa, dfa->nodes[org_idx]);\n  if (BE (dup_idx != -1, 1))\n    {\n      dfa->nodes[dup_idx].constraint = constraint;\n      dfa->nodes[dup_idx].constraint |= dfa->nodes[org_idx].constraint;\n      dfa->nodes[dup_idx].duplicated = 1;\n\n      /* Store the index of the original node.  */\n      dfa->org_indices[dup_idx] = org_idx;\n    }\n  return dup_idx;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "Idx"
      ]
    },
    "calc_inveclosure": {
      "start_point": [
        1633,
        0
      ],
      "end_point": [
        1653,
        1
      ],
      "content": "static reg_errcode_t\ncalc_inveclosure (re_dfa_t *dfa)\n{\n  Idx src, idx;\n  bool ok;\n  for (idx = 0; idx < dfa->nodes_len; ++idx)\n    re_node_set_init_empty (dfa->inveclosures + idx);\n\n  for (src = 0; src < dfa->nodes_len; ++src)\n    {\n      Idx *elems = dfa->eclosures[src].elems;\n      for (idx = 0; idx < dfa->eclosures[src].nelem; ++idx)\n\t{\n\t  ok = re_node_set_insert_last (dfa->inveclosures + elems[idx], src);\n\t  if (BE (! ok, 0))\n\t    return REG_ESPACE;\n\t}\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "calc_eclosure": {
      "start_point": [
        1657,
        0
      ],
      "end_point": [
        1698,
        1
      ],
      "content": "static reg_errcode_t\ncalc_eclosure (re_dfa_t *dfa)\n{\n  Idx node_idx;\n  bool incomplete;\n#ifdef DEBUG\n  assert (dfa->nodes_len > 0);\n#endif\n  incomplete = false;\n  /* For each nodes, calculate epsilon closure.  */\n  for (node_idx = 0; ; ++node_idx)\n    {\n      reg_errcode_t err;\n      re_node_set eclosure_elem;\n      if (node_idx == dfa->nodes_len)\n\t{\n\t  if (!incomplete)\n\t    break;\n\t  incomplete = false;\n\t  node_idx = 0;\n\t}\n\n#ifdef DEBUG\n      assert (dfa->eclosures[node_idx].nelem != -1);\n#endif\n\n      /* If we have already calculated, skip it.  */\n      if (dfa->eclosures[node_idx].nelem != 0)\n\tcontinue;\n      /* Calculate epsilon closure of 'node_idx'.  */\n      err = calc_eclosure_iter (&eclosure_elem, dfa, node_idx, true);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n\n      if (dfa->eclosures[node_idx].nelem == 0)\n\t{\n\t  incomplete = true;\n\t  re_node_set_free (&eclosure_elem);\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 42,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "calc_eclosure_iter": {
      "start_point": [
        1702,
        0
      ],
      "end_point": [
        1776,
        1
      ],
      "content": "static reg_errcode_t\ncalc_eclosure_iter (re_node_set *new_set, re_dfa_t *dfa, Idx node, bool root)\n{\n  reg_errcode_t err;\n  Idx i;\n  re_node_set eclosure;\n  bool ok;\n  bool incomplete = false;\n  err = re_node_set_alloc (&eclosure, dfa->edests[node].nelem + 1);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n\n  /* This indicates that we are calculating this node now.\n     We reference this value to avoid infinite loop.  */\n  dfa->eclosures[node].nelem = -1;\n\n  /* If the current node has constraints, duplicate all nodes\n     since they must inherit the constraints.  */\n  if (dfa->nodes[node].constraint\n      && dfa->edests[node].nelem\n      && !dfa->nodes[dfa->edests[node].elems[0]].duplicated)\n    {\n      err = duplicate_node_closure (dfa, node, node, node,\n\t\t\t\t    dfa->nodes[node].constraint);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n\n  /* Expand each epsilon destination nodes.  */\n  if (IS_EPSILON_NODE(dfa->nodes[node].type))\n    for (i = 0; i < dfa->edests[node].nelem; ++i)\n      {\n\tre_node_set eclosure_elem;\n\tIdx edest = dfa->edests[node].elems[i];\n\t/* If calculating the epsilon closure of 'edest' is in progress,\n\t   return intermediate result.  */\n\tif (dfa->eclosures[edest].nelem == -1)\n\t  {\n\t    incomplete = true;\n\t    continue;\n\t  }\n\t/* If we haven't calculated the epsilon closure of 'edest' yet,\n\t   calculate now. Otherwise use calculated epsilon closure.  */\n\tif (dfa->eclosures[edest].nelem == 0)\n\t  {\n\t    err = calc_eclosure_iter (&eclosure_elem, dfa, edest, false);\n\t    if (BE (err != REG_NOERROR, 0))\n\t      return err;\n\t  }\n\telse\n\t  eclosure_elem = dfa->eclosures[edest];\n\t/* Merge the epsilon closure of 'edest'.  */\n\terr = re_node_set_merge (&eclosure, &eclosure_elem);\n\tif (BE (err != REG_NOERROR, 0))\n\t  return err;\n\t/* If the epsilon closure of 'edest' is incomplete,\n\t   the epsilon closure of this node is also incomplete.  */\n\tif (dfa->eclosures[edest].nelem == 0)\n\t  {\n\t    incomplete = true;\n\t    re_node_set_free (&eclosure_elem);\n\t  }\n      }\n\n  /* An epsilon closure includes itself.  */\n  ok = re_node_set_insert (&eclosure, node);\n  if (BE (! ok, 0))\n    return REG_ESPACE;\n  if (incomplete && !root)\n    dfa->eclosures[node].nelem = 0;\n  else\n    dfa->eclosures[node] = eclosure;\n  *new_set = eclosure;\n  return REG_NOERROR;\n}",
      "lines": 75,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "fetch_token": {
      "start_point": [
        1783,
        0
      ],
      "end_point": [
        1788,
        1
      ],
      "content": "static void\ninternal_function\nfetch_token (re_token_t *result, re_string_t *input, reg_syntax_t syntax)\n{\n  re_string_skip_bytes (input, peek_token (result, input, syntax));\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "internal_function": {
      "start_point": [
        1793,
        0
      ],
      "end_point": [
        2027,
        1
      ],
      "content": "static int\ninternal_function\npeek_token (re_token_t *token, re_string_t *input, reg_syntax_t syntax)\n{\n  unsigned char c;\n\n  if (re_string_eoi (input))\n    {\n      token->type = END_OF_RE;\n      return 0;\n    }\n\n  c = re_string_peek_byte (input, 0);\n  token->opr.c = c;\n\n  token->word_char = 0;\n#ifdef RE_ENABLE_I18N\n  token->mb_partial = 0;\n  if (input->mb_cur_max > 1 &&\n      !re_string_first_byte (input, re_string_cur_idx (input)))\n    {\n      token->type = CHARACTER;\n      token->mb_partial = 1;\n      return 1;\n    }\n#endif\n  if (c == '\\\\')\n    {\n      unsigned char c2;\n      if (re_string_cur_idx (input) + 1 >= re_string_length (input))\n\t{\n\t  token->type = BACK_SLASH;\n\t  return 1;\n\t}\n\n      c2 = re_string_peek_byte_case (input, 1);\n      token->opr.c = c2;\n      token->type = CHARACTER;\n#ifdef RE_ENABLE_I18N\n      if (input->mb_cur_max > 1)\n\t{\n\t  wint_t wc = re_string_wchar_at (input,\n\t\t\t\t\t  re_string_cur_idx (input) + 1);\n\t  token->word_char = IS_WIDE_WORD_CHAR (wc) != 0;\n\t}\n      else\n#endif\n\ttoken->word_char = IS_WORD_CHAR (c2) != 0;\n\n      switch (c2)\n\t{\n\tcase '|':\n\t  if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_NO_BK_VBAR))\n\t    token->type = OP_ALT;\n\t  break;\n\tcase '1': case '2': case '3': case '4': case '5':\n\tcase '6': case '7': case '8': case '9':\n\t  if (!(syntax & RE_NO_BK_REFS))\n\t    {\n\t      token->type = OP_BACK_REF;\n\t      token->opr.idx = c2 - '1';\n\t    }\n\t  break;\n\tcase '<':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_FIRST;\n\t    }\n\t  break;\n\tcase '>':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_LAST;\n\t    }\n\t  break;\n\tcase 'b':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_DELIM;\n\t    }\n\t  break;\n\tcase 'B':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = NOT_WORD_DELIM;\n\t    }\n\t  break;\n\tcase 'w':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_WORD;\n\t  break;\n\tcase 'W':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_NOTWORD;\n\t  break;\n\tcase 's':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_SPACE;\n\t  break;\n\tcase 'S':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_NOTSPACE;\n\t  break;\n\tcase '`':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = BUF_FIRST;\n\t    }\n\t  break;\n\tcase '\\'':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = BUF_LAST;\n\t    }\n\t  break;\n\tcase '(':\n\t  if (!(syntax & RE_NO_BK_PARENS))\n\t    token->type = OP_OPEN_SUBEXP;\n\t  break;\n\tcase ')':\n\t  if (!(syntax & RE_NO_BK_PARENS))\n\t    token->type = OP_CLOSE_SUBEXP;\n\t  break;\n\tcase '+':\n\t  if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_BK_PLUS_QM))\n\t    token->type = OP_DUP_PLUS;\n\t  break;\n\tcase '?':\n\t  if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_BK_PLUS_QM))\n\t    token->type = OP_DUP_QUESTION;\n\t  break;\n\tcase '{':\n\t  if ((syntax & RE_INTERVALS) && (!(syntax & RE_NO_BK_BRACES)))\n\t    token->type = OP_OPEN_DUP_NUM;\n\t  break;\n\tcase '}':\n\t  if ((syntax & RE_INTERVALS) && (!(syntax & RE_NO_BK_BRACES)))\n\t    token->type = OP_CLOSE_DUP_NUM;\n\t  break;\n\tdefault:\n\t  break;\n\t}\n      return 2;\n    }\n\n  token->type = CHARACTER;\n#ifdef RE_ENABLE_I18N\n  if (input->mb_cur_max > 1)\n    {\n      wint_t wc = re_string_wchar_at (input, re_string_cur_idx (input));\n      token->word_char = IS_WIDE_WORD_CHAR (wc) != 0;\n    }\n  else\n#endif\n    token->word_char = IS_WORD_CHAR (token->opr.c);\n\n  switch (c)\n    {\n    case '\\n':\n      if (syntax & RE_NEWLINE_ALT)\n\ttoken->type = OP_ALT;\n      break;\n    case '|':\n      if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_NO_BK_VBAR))\n\ttoken->type = OP_ALT;\n      break;\n    case '*':\n      token->type = OP_DUP_ASTERISK;\n      break;\n    case '+':\n      if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_BK_PLUS_QM))\n\ttoken->type = OP_DUP_PLUS;\n      break;\n    case '?':\n      if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_BK_PLUS_QM))\n\ttoken->type = OP_DUP_QUESTION;\n      break;\n    case '{':\n      if ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))\n\ttoken->type = OP_OPEN_DUP_NUM;\n      break;\n    case '}':\n      if ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))\n\ttoken->type = OP_CLOSE_DUP_NUM;\n      break;\n    case '(':\n      if (syntax & RE_NO_BK_PARENS)\n\ttoken->type = OP_OPEN_SUBEXP;\n      break;\n    case ')':\n      if (syntax & RE_NO_BK_PARENS)\n\ttoken->type = OP_CLOSE_SUBEXP;\n      break;\n    case '[':\n      token->type = OP_OPEN_BRACKET;\n      break;\n    case '.':\n      token->type = OP_PERIOD;\n      break;\n    case '^':\n      if (!(syntax & (RE_CONTEXT_INDEP_ANCHORS | RE_CARET_ANCHORS_HERE)) &&\n\t  re_string_cur_idx (input) != 0)\n\t{\n\t  char prev = re_string_peek_byte (input, -1);\n\t  if (!(syntax & RE_NEWLINE_ALT) || prev != '\\n')\n\t    break;\n\t}\n      token->type = ANCHOR;\n      token->opr.ctx_type = LINE_FIRST;\n      break;\n    case '$':\n      if (!(syntax & RE_CONTEXT_INDEP_ANCHORS) &&\n\t  re_string_cur_idx (input) + 1 != re_string_length (input))\n\t{\n\t  re_token_t next;\n\t  re_string_skip_bytes (input, 1);\n\t  peek_token (&next, input, syntax);\n\t  re_string_skip_bytes (input, -1);\n\t  if (next.type != OP_ALT && next.type != OP_CLOSE_SUBEXP)\n\t    break;\n\t}\n      token->type = ANCHOR;\n      token->opr.ctx_type = LINE_LAST;\n      break;\n    default:\n      break;\n    }\n  return 1;\n}",
      "lines": 235,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "peek_token_bracket": {
      "start_point": [
        2032,
        0
      ],
      "end_point": [
        2113,
        1
      ],
      "content": "static int\ninternal_function\npeek_token_bracket (re_token_t *token, re_string_t *input, reg_syntax_t syntax)\n{\n  unsigned char c;\n  if (re_string_eoi (input))\n    {\n      token->type = END_OF_RE;\n      return 0;\n    }\n  c = re_string_peek_byte (input, 0);\n  token->opr.c = c;\n\n#ifdef RE_ENABLE_I18N\n  if (input->mb_cur_max > 1 &&\n      !re_string_first_byte (input, re_string_cur_idx (input)))\n    {\n      token->type = CHARACTER;\n      return 1;\n    }\n#endif /* RE_ENABLE_I18N */\n\n  if (c == '\\\\' && (syntax & RE_BACKSLASH_ESCAPE_IN_LISTS)\n      && re_string_cur_idx (input) + 1 < re_string_length (input))\n    {\n      /* In this case, '\\' escape a character.  */\n      unsigned char c2;\n      re_string_skip_bytes (input, 1);\n      c2 = re_string_peek_byte (input, 0);\n      token->opr.c = c2;\n      token->type = CHARACTER;\n      return 1;\n    }\n  if (c == '[') /* '[' is a special char in a bracket exps.  */\n    {\n      unsigned char c2;\n      int token_len;\n      if (re_string_cur_idx (input) + 1 < re_string_length (input))\n\tc2 = re_string_peek_byte (input, 1);\n      else\n\tc2 = 0;\n      token->opr.c = c2;\n      token_len = 2;\n      switch (c2)\n\t{\n\tcase '.':\n\t  token->type = OP_OPEN_COLL_ELEM;\n\t  break;\n\tcase '=':\n\t  token->type = OP_OPEN_EQUIV_CLASS;\n\t  break;\n\tcase ':':\n\t  if (syntax & RE_CHAR_CLASSES)\n\t    {\n\t      token->type = OP_OPEN_CHAR_CLASS;\n\t      break;\n\t    }\n\t  /* else fall through.  */\n\tdefault:\n\t  token->type = CHARACTER;\n\t  token->opr.c = c;\n\t  token_len = 1;\n\t  break;\n\t}\n      return token_len;\n    }\n  switch (c)\n    {\n    case '-':\n      token->type = OP_CHARSET_RANGE;\n      break;\n    case ']':\n      token->type = OP_CLOSE_BRACKET;\n      break;\n    case '^':\n      token->type = OP_NON_MATCH_LIST;\n      break;\n    default:\n      token->type = CHARACTER;\n    }\n  return 1;\n}",
      "lines": 82,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "parse": {
      "start_point": [
        2129,
        0
      ],
      "end_point": [
        2152,
        1
      ],
      "content": "static bin_tree_t *\nparse (re_string_t *regexp, regex_t *preg, reg_syntax_t syntax,\n       reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *eor, *root;\n  re_token_t current_token;\n  dfa->syntax = syntax;\n  fetch_token (&current_token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n  tree = parse_reg_exp (regexp, preg, &current_token, syntax, 0, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n  eor = create_tree (dfa, NULL, NULL, END_OF_RE);\n  if (tree != NULL)\n    root = create_tree (dfa, tree, eor, CONCAT);\n  else\n    root = eor;\n  if (BE (eor == NULL || root == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n  return root;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse (re_string_t *regexp, regex_t *preg, reg_syntax_t syntax,\n       reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_reg_exp": {
      "start_point": [
        2163,
        0
      ],
      "end_point": [
        2201,
        1
      ],
      "content": "static bin_tree_t *\nparse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *branch = NULL;\n  bitset_word_t initial_bkref_map = dfa->completed_bkref_map;\n  tree = parse_branch (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n\n  while (token->type == OP_ALT)\n    {\n      fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n      if (token->type != OP_ALT && token->type != END_OF_RE\n\t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n\t{\n\t  bitset_word_t accumulated_bkref_map = dfa->completed_bkref_map;\n\t  dfa->completed_bkref_map = initial_bkref_map;\n\t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n\t  if (BE (*err != REG_NOERROR && branch == NULL, 0))\n\t    {\n\t      if (tree != NULL)\n\t\tpostorder (tree, free_tree, NULL);\n\t      return NULL;\n\t    }\n\t  dfa->completed_bkref_map |= accumulated_bkref_map;\n\t}\n      else\n\tbranch = NULL;\n      tree = create_tree (dfa, tree, branch, OP_ALT);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n    }\n  return tree;\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_branch": {
      "start_point": [
        2212,
        0
      ],
      "end_point": [
        2249,
        1
      ],
      "content": "static bin_tree_t *\nparse_branch (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t      reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  bin_tree_t *tree, *expr;\n  re_dfa_t *dfa = preg->buffer;\n  tree = parse_expression (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n\n  while (token->type != OP_ALT && token->type != END_OF_RE\n\t && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n    {\n      expr = parse_expression (regexp, preg, token, syntax, nest, err);\n      if (BE (*err != REG_NOERROR && expr == NULL, 0))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  return NULL;\n\t}\n      if (tree != NULL && expr != NULL)\n\t{\n\t  bin_tree_t *newtree = create_tree (dfa, tree, expr, CONCAT);\n\t  if (newtree == NULL)\n\t    {\n\t      postorder (expr, free_tree, NULL);\n\t      postorder (tree, free_tree, NULL);\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t  tree = newtree;\n\t}\n      else if (tree == NULL)\n\ttree = expr;\n      /* Otherwise expr == NULL, we don't need to create new tree.  */\n    }\n  return tree;\n}",
      "lines": 38,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_branch (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t      reg_syntax_t syntax, Idx nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_expression": {
      "start_point": [
        2257,
        0
      ],
      "end_point": [
        2472,
        1
      ],
      "content": "static bin_tree_t *\nparse_expression (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t\t  reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree;\n  switch (token->type)\n    {\n    case CHARACTER:\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n#ifdef RE_ENABLE_I18N\n      if (dfa->mb_cur_max > 1)\n\t{\n\t  while (!re_string_eoi (regexp)\n\t\t && !re_string_first_byte (regexp, re_string_cur_idx (regexp)))\n\t    {\n\t      bin_tree_t *mbc_remain;\n\t      fetch_token (token, regexp, syntax);\n\t      mbc_remain = create_token_tree (dfa, NULL, NULL, token);\n\t      tree = create_tree (dfa, tree, mbc_remain, CONCAT);\n\t      if (BE (mbc_remain == NULL || tree == NULL, 0))\n\t\t{\n\t\t  *err = REG_ESPACE;\n\t\t  return NULL;\n\t\t}\n\t    }\n\t}\n#endif\n      break;\n    case OP_OPEN_SUBEXP:\n      tree = parse_sub_exp (regexp, preg, token, syntax, nest + 1, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n    case OP_OPEN_BRACKET:\n      tree = parse_bracket_exp (regexp, dfa, token, syntax, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n    case OP_BACK_REF:\n      if (!BE (dfa->completed_bkref_map & (1 << token->opr.idx), 1))\n\t{\n\t  *err = REG_ESUBREG;\n\t  return NULL;\n\t}\n      dfa->used_bkref_map |= 1 << token->opr.idx;\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      ++dfa->nbackref;\n      dfa->has_mb_node = 1;\n      break;\n    case OP_OPEN_DUP_NUM:\n      if (syntax & RE_CONTEXT_INVALID_DUP)\n\t{\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n      /* FALLTHROUGH */\n    case OP_DUP_ASTERISK:\n    case OP_DUP_PLUS:\n    case OP_DUP_QUESTION:\n      if (syntax & RE_CONTEXT_INVALID_OPS)\n\t{\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n      else if (syntax & RE_CONTEXT_INDEP_OPS)\n\t{\n\t  fetch_token (token, regexp, syntax);\n\t  return parse_expression (regexp, preg, token, syntax, nest, err);\n\t}\n      /* else fall through  */\n    case OP_CLOSE_SUBEXP:\n      if ((token->type == OP_CLOSE_SUBEXP) &&\n\t  !(syntax & RE_UNMATCHED_RIGHT_PAREN_ORD))\n\t{\n\t  *err = REG_ERPAREN;\n\t  return NULL;\n\t}\n      /* else fall through  */\n    case OP_CLOSE_DUP_NUM:\n      /* We treat it as a normal character.  */\n\n      /* Then we can these characters as normal characters.  */\n      token->type = CHARACTER;\n      /* mb_partial and word_char bits should be initialized already\n\t by peek_token.  */\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      break;\n    case ANCHOR:\n      if ((token->opr.ctx_type\n\t   & (WORD_DELIM | NOT_WORD_DELIM | WORD_FIRST | WORD_LAST))\n\t  && dfa->word_ops_used == 0)\n\tinit_word_char (dfa);\n      if (token->opr.ctx_type == WORD_DELIM\n\t  || token->opr.ctx_type == NOT_WORD_DELIM)\n\t{\n\t  bin_tree_t *tree_first, *tree_last;\n\t  if (token->opr.ctx_type == WORD_DELIM)\n\t    {\n\t      token->opr.ctx_type = WORD_FIRST;\n\t      tree_first = create_token_tree (dfa, NULL, NULL, token);\n\t      token->opr.ctx_type = WORD_LAST;\n\t    }\n\t  else\n\t    {\n\t      token->opr.ctx_type = INSIDE_WORD;\n\t      tree_first = create_token_tree (dfa, NULL, NULL, token);\n\t      token->opr.ctx_type = INSIDE_NOTWORD;\n\t    }\n\t  tree_last = create_token_tree (dfa, NULL, NULL, token);\n\t  tree = create_tree (dfa, tree_first, tree_last, OP_ALT);\n\t  if (BE (tree_first == NULL || tree_last == NULL || tree == NULL, 0))\n\t    {\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t}\n      else\n\t{\n\t  tree = create_token_tree (dfa, NULL, NULL, token);\n\t  if (BE (tree == NULL, 0))\n\t    {\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t}\n      /* We must return here, since ANCHORs can't be followed\n\t by repetition operators.\n\t eg. RE\"^*\" is invalid or \"<ANCHOR(^)><CHAR(*)>\",\n\t     it must not be \"<ANCHOR(^)><REPEAT(*)>\".  */\n      fetch_token (token, regexp, syntax);\n      return tree;\n    case OP_PERIOD:\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      if (dfa->mb_cur_max > 1)\n\tdfa->has_mb_node = 1;\n      break;\n    case OP_WORD:\n    case OP_NOTWORD:\n      tree = build_charclass_op (dfa, regexp->trans,\n\t\t\t\t \"alnum\",\n\t\t\t\t \"_\",\n\t\t\t\t token->type == OP_NOTWORD, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n    case OP_SPACE:\n    case OP_NOTSPACE:\n      tree = build_charclass_op (dfa, regexp->trans,\n\t\t\t\t \"space\",\n\t\t\t\t \"\",\n\t\t\t\t token->type == OP_NOTSPACE, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n    case OP_ALT:\n    case END_OF_RE:\n      return NULL;\n    case BACK_SLASH:\n      *err = REG_EESCAPE;\n      return NULL;\n    default:\n      /* Must not happen?  */\n#ifdef DEBUG\n      assert (0);\n#endif\n      return NULL;\n    }\n  fetch_token (token, regexp, syntax);\n\n  while (token->type == OP_DUP_ASTERISK || token->type == OP_DUP_PLUS\n\t || token->type == OP_DUP_QUESTION || token->type == OP_OPEN_DUP_NUM)\n    {\n      bin_tree_t *dup_tree = parse_dup_op (tree, regexp, dfa, token,\n\t\t\t\t\t   syntax, err);\n      if (BE (*err != REG_NOERROR && dup_tree == NULL, 0))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  return NULL;\n\t}\n      tree = dup_tree;\n      /* In BRE consecutive duplications are not allowed.  */\n      if ((syntax & RE_CONTEXT_INVALID_DUP)\n\t  && (token->type == OP_DUP_ASTERISK\n\t      || token->type == OP_OPEN_DUP_NUM))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n    }\n\n  return tree;\n}",
      "lines": 216,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_expression (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t\t  reg_syntax_t syntax, Idx nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_sub_exp": {
      "start_point": [
        2481,
        0
      ],
      "end_point": [
        2519,
        1
      ],
      "content": "static bin_tree_t *\nparse_sub_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree;\n  size_t cur_nsub;\n  cur_nsub = preg->re_nsub++;\n\n  fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n\n  /* The subexpression may be a null string.  */\n  if (token->type == OP_CLOSE_SUBEXP)\n    tree = NULL;\n  else\n    {\n      tree = parse_reg_exp (regexp, preg, token, syntax, nest, err);\n      if (BE (*err == REG_NOERROR && token->type != OP_CLOSE_SUBEXP, 0))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  *err = REG_EPAREN;\n\t}\n      if (BE (*err != REG_NOERROR, 0))\n\treturn NULL;\n    }\n\n  if (cur_nsub <= '9' - '1')\n    dfa->completed_bkref_map |= 1 << cur_nsub;\n\n  tree = create_tree (dfa, tree, NULL, SUBEXP);\n  if (BE (tree == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n  tree->token.opr.idx = cur_nsub;\n  return tree;\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_sub_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_dup_op": {
      "start_point": [
        2523,
        0
      ],
      "end_point": [
        2667,
        1
      ],
      "content": "static bin_tree_t *\nparse_dup_op (bin_tree_t *elem, re_string_t *regexp, re_dfa_t *dfa,\n\t      re_token_t *token, reg_syntax_t syntax, reg_errcode_t *err)\n{\n  bin_tree_t *tree = NULL, *old_tree = NULL;\n  Idx i, start, end, start_idx = re_string_cur_idx (regexp);\n  re_token_t start_token = *token;\n\n  if (token->type == OP_OPEN_DUP_NUM)\n    {\n      end = 0;\n      start = fetch_number (regexp, token, syntax);\n      if (start == -1)\n\t{\n\t  if (token->type == CHARACTER && token->opr.c == ',')\n\t    start = 0; /* We treat \"{,m}\" as \"{0,m}\".  */\n\t  else\n\t    {\n\t      *err = REG_BADBR; /* <re>{} is invalid.  */\n\t      return NULL;\n\t    }\n\t}\n      if (BE (start != -2, 1))\n\t{\n\t  /* We treat \"{n}\" as \"{n,n}\".  */\n\t  end = ((token->type == OP_CLOSE_DUP_NUM) ? start\n\t\t : ((token->type == CHARACTER && token->opr.c == ',')\n\t\t    ? fetch_number (regexp, token, syntax) : -2));\n\t}\n      if (BE (start == -2 || end == -2, 0))\n\t{\n\t  /* Invalid sequence.  */\n\t  if (BE (!(syntax & RE_INVALID_INTERVAL_ORD), 0))\n\t    {\n\t      if (token->type == END_OF_RE)\n\t\t*err = REG_EBRACE;\n\t      else\n\t\t*err = REG_BADBR;\n\n\t      return NULL;\n\t    }\n\n\t  /* If the syntax bit is set, rollback.  */\n\t  re_string_set_index (regexp, start_idx);\n\t  *token = start_token;\n\t  token->type = CHARACTER;\n\t  /* mb_partial and word_char bits should be already initialized by\n\t     peek_token.  */\n\t  return elem;\n\t}\n\n      if (BE ((end != -1 && start > end)\n\t      || token->type != OP_CLOSE_DUP_NUM, 0))\n\t{\n\t  /* First number greater than second.  */\n\t  *err = REG_BADBR;\n\t  return NULL;\n\t}\n\n      if (BE (RE_DUP_MAX < (end == -1 ? start : end), 0))\n\t{\n\t  *err = REG_ESIZE;\n\t  return NULL;\n\t}\n    }\n  else\n    {\n      start = (token->type == OP_DUP_PLUS) ? 1 : 0;\n      end = (token->type == OP_DUP_QUESTION) ? 1 : -1;\n    }\n\n  fetch_token (token, regexp, syntax);\n\n  if (BE (elem == NULL, 0))\n    return NULL;\n  if (BE (start == 0 && end == 0, 0))\n    {\n      postorder (elem, free_tree, NULL);\n      return NULL;\n    }\n\n  /* Extract \"<re>{n,m}\" to \"<re><re>...<re><re>{0,<m-n>}\".  */\n  if (BE (start > 0, 0))\n    {\n      tree = elem;\n      for (i = 2; i <= start; ++i)\n\t{\n\t  elem = duplicate_tree (elem, dfa);\n\t  tree = create_tree (dfa, tree, elem, CONCAT);\n\t  if (BE (elem == NULL || tree == NULL, 0))\n\t    goto parse_dup_op_espace;\n\t}\n\n      if (start == end)\n\treturn tree;\n\n      /* Duplicate ELEM before it is marked optional.  */\n      elem = duplicate_tree (elem, dfa);\n      if (BE (elem == NULL, 0))\n        goto parse_dup_op_espace;\n      old_tree = tree;\n    }\n  else\n    old_tree = NULL;\n\n  if (elem->token.type == SUBEXP)\n    {\n      uintptr_t subidx = elem->token.opr.idx;\n      postorder (elem, mark_opt_subexp, (void *) subidx);\n    }\n\n  tree = create_tree (dfa, elem, NULL,\n\t\t      (end == -1 ? OP_DUP_ASTERISK : OP_ALT));\n  if (BE (tree == NULL, 0))\n    goto parse_dup_op_espace;\n\n/* From gnulib's \"intprops.h\":\n   True if the arithmetic type T is signed.  */\n#define TYPE_SIGNED(t) (! ((t) 0 < (t) -1))\n\n  /* This loop is actually executed only when end != -1,\n     to rewrite <re>{0,n} as (<re>(<re>...<re>?)?)?...  We have\n     already created the start+1-th copy.  */\n  if (TYPE_SIGNED (Idx) || end != -1)\n    for (i = start + 2; i <= end; ++i)\n      {\n\telem = duplicate_tree (elem, dfa);\n\ttree = create_tree (dfa, tree, elem, CONCAT);\n\tif (BE (elem == NULL || tree == NULL, 0))\n\t  goto parse_dup_op_espace;\n\n\ttree = create_tree (dfa, tree, NULL, OP_ALT);\n\tif (BE (tree == NULL, 0))\n\t  goto parse_dup_op_espace;\n      }\n\n  if (old_tree)\n    tree = create_tree (dfa, old_tree, tree, CONCAT);\n\n  return tree;\n\n parse_dup_op_espace:\n  *err = REG_ESPACE;\n  return NULL;\n}",
      "lines": 145,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_dup_op (bin_tree_t *elem, re_string_t *regexp, re_dfa_t *dfa,\n\t      re_token_t *token, reg_syntax_t syntax, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_byte": {
      "start_point": [
        2679,
        0
      ],
      "end_point": [
        2684,
        1
      ],
      "content": "static wint_t\nparse_byte (unsigned char b, re_charset_t *mbcset)\n{\n  wint_t wc = __btowc (b);\n  return wc == WEOF && !mbcset ? b : wc;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "wint_t"
      ]
    },
    "start_elem": {
      "start_point": [
        2707,
        23
      ],
      "end_point": [
        2810,
        1
      ],
      "content": "bracket_elem_t *end_elem)\n# endif /* not RE_ENABLE_I18N */\n{\n  unsigned int start_ch, end_ch;\n  /* Equivalence Classes and Character Classes can't be a range start/end.  */\n  if (BE (start_elem->type == EQUIV_CLASS || start_elem->type == CHAR_CLASS\n\t  || end_elem->type == EQUIV_CLASS || end_elem->type == CHAR_CLASS,\n\t  0))\n    return REG_ERANGE;\n\n  /* We can handle no multi character collating elements without libc\n     support.  */\n  if (BE ((start_elem->type == COLL_SYM\n\t   && strlen ((char *) start_elem->opr.name) > 1)\n\t  || (end_elem->type == COLL_SYM\n\t      && strlen ((char *) end_elem->opr.name) > 1), 0))\n    return REG_ECOLLATE;\n\n# ifdef RE_ENABLE_I18N\n  {\n    wchar_t wc;\n    wint_t start_wc;\n    wint_t end_wc;\n\n    start_ch = ((start_elem->type == SB_CHAR) ? start_elem->opr.ch\n\t\t: ((start_elem->type == COLL_SYM) ? start_elem->opr.name[0]\n\t\t   : 0));\n    end_ch = ((end_elem->type == SB_CHAR) ? end_elem->opr.ch\n\t      : ((end_elem->type == COLL_SYM) ? end_elem->opr.name[0]\n\t\t : 0));\n    start_wc = ((start_elem->type == SB_CHAR || start_elem->type == COLL_SYM)\n\t\t? parse_byte (start_ch, mbcset) : start_elem->opr.wch);\n    end_wc = ((end_elem->type == SB_CHAR || end_elem->type == COLL_SYM)\n\t      ? parse_byte (end_ch, mbcset) : end_elem->opr.wch);\n    if (start_wc == WEOF || end_wc == WEOF)\n      return REG_ECOLLATE;\n    else if (BE ((syntax & RE_NO_EMPTY_RANGES) && start_wc > end_wc, 0))\n      return REG_ERANGE;\n\n    /* Got valid collation sequence values, add them as a new entry.\n       However, for !_LIBC we have no collation elements: if the\n       character set is single byte, the single byte character set\n       that we build below suffices.  parse_bracket_exp passes\n       no MBCSET if dfa->mb_cur_max == 1.  */\n    if (mbcset)\n      {\n\t/* Check the space of the arrays.  */\n\tif (BE (*range_alloc == mbcset->nranges, 0))\n\t  {\n\t    /* There is not enough space, need realloc.  */\n\t    wchar_t *new_array_start, *new_array_end;\n\t    Idx new_nranges;\n\n\t    /* +1 in case of mbcset->nranges is 0.  */\n\t    new_nranges = 2 * mbcset->nranges + 1;\n\t    /* Use realloc since mbcset->range_starts and mbcset->range_ends\n\t       are NULL if *range_alloc == 0.  */\n\t    new_array_start = re_realloc (mbcset->range_starts, wchar_t,\n\t\t\t\t\t  new_nranges);\n\t    new_array_end = re_realloc (mbcset->range_ends, wchar_t,\n\t\t\t\t\tnew_nranges);\n\n\t    if (BE (new_array_start == NULL || new_array_end == NULL, 0))\n\t      {\n\t\tre_free (new_array_start);\n\t\tre_free (new_array_end);\n\t\treturn REG_ESPACE;\n\t      }\n\n\t    mbcset->range_starts = new_array_start;\n\t    mbcset->range_ends = new_array_end;\n\t    *range_alloc = new_nranges;\n\t  }\n\n\tmbcset->range_starts[mbcset->nranges] = start_wc;\n\tmbcset->range_ends[mbcset->nranges++] = end_wc;\n      }\n\n    /* Build the table for single byte characters.  */\n    for (wc = 0; wc < SBC_MAX; ++wc)\n      {\n\tif (start_wc <= wc && wc <= end_wc)\n\t  bitset_set (sbcset, wc);\n      }\n  }\n# else /* not RE_ENABLE_I18N */\n  {\n    unsigned int ch;\n    start_ch = ((start_elem->type == SB_CHAR ) ? start_elem->opr.ch\n\t\t: ((start_elem->type == COLL_SYM) ? start_elem->opr.name[0]\n\t\t   : 0));\n    end_ch = ((end_elem->type == SB_CHAR ) ? end_elem->opr.ch\n\t      : ((end_elem->type == COLL_SYM) ? end_elem->opr.name[0]\n\t\t : 0));\n    if (start_ch > end_ch)\n      return REG_ERANGE;\n    /* Build the table for single byte characters.  */\n    for (ch = 0; ch < SBC_MAX; ++ch)\n      if (start_ch <= ch  && ch <= end_ch)\n\tbitset_set (sbcset, ch);\n  }\n# endif /* not RE_ENABLE_I18N */\n  return REG_NOERROR;\n}",
      "lines": 104,
      "depth": 16,
      "decorators": null
    },
    "parse_bracket_exp": {
      "start_point": [
        2843,
        0
      ],
      "end_point": [
        3388,
        1
      ],
      "content": "static bin_tree_t *\nparse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,\n\t\t   reg_syntax_t syntax, reg_errcode_t *err)\n{\n#ifdef _LIBC\n  const unsigned char *collseqmb;\n  const char *collseqwc;\n  uint32_t nrules;\n  int32_t table_size;\n  const int32_t *symb_table;\n  const unsigned char *extra;\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Seek the collating symbol entry corresponding to NAME.\n     Return the index of the symbol in the SYMB_TABLE,\n     or -1 if not found.  */\n\n  auto inline int32_t\n  __attribute__ ((always_inline))\n  seek_collating_symbol_entry (const unsigned char *name, size_t name_len)\n    {\n      int32_t elem;\n\n      for (elem = 0; elem < table_size; elem++)\n\tif (symb_table[2 * elem] != 0)\n\t  {\n\t    int32_t idx = symb_table[2 * elem + 1];\n\t    /* Skip the name of collating element name.  */\n\t    idx += 1 + extra[idx];\n\t    if (/* Compare the length of the name.  */\n\t\tname_len == extra[idx]\n\t\t/* Compare the name.  */\n\t\t&& memcmp (name, &extra[idx + 1], name_len) == 0)\n\t      /* Yep, this is the entry.  */\n\t      return elem;\n\t  }\n      return -1;\n    }\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Look up the collation sequence value of BR_ELEM.\n     Return the value if succeeded, UINT_MAX otherwise.  */\n\n  auto inline unsigned int\n  __attribute__ ((always_inline))\n  lookup_collation_sequence_value (bracket_elem_t *br_elem)\n    {\n      if (br_elem->type == SB_CHAR)\n\t{\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    return collseqmb[br_elem->opr.ch];\n\t  else\n\t    {\n\t      wint_t wc = __btowc (br_elem->opr.ch);\n\t      return __collseq_table_lookup (collseqwc, wc);\n\t    }\n\t}\n      else if (br_elem->type == MB_CHAR)\n\t{\n\t  if (nrules != 0)\n\t    return __collseq_table_lookup (collseqwc, br_elem->opr.wch);\n\t}\n      else if (br_elem->type == COLL_SYM)\n\t{\n\t  size_t sym_name_len = strlen ((char *) br_elem->opr.name);\n\t  if (nrules != 0)\n\t    {\n\t      int32_t elem, idx;\n\t      elem = seek_collating_symbol_entry (br_elem->opr.name,\n\t\t\t\t\t\t  sym_name_len);\n\t      if (elem != -1)\n\t\t{\n\t\t  /* We found the entry.  */\n\t\t  idx = symb_table[2 * elem + 1];\n\t\t  /* Skip the name of collating element name.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Skip the byte sequence of the collating element.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Adjust for the alignment.  */\n\t\t  idx = (idx + 3) & ~3;\n\t\t  /* Skip the multibyte collation sequence value.  */\n\t\t  idx += sizeof (unsigned int);\n\t\t  /* Skip the wide char sequence of the collating element.  */\n\t\t  idx += sizeof (unsigned int) *\n\t\t    (1 + *(unsigned int *) (extra + idx));\n\t\t  /* Return the collation sequence value.  */\n\t\t  return *(unsigned int *) (extra + idx);\n\t\t}\n\t      else if (sym_name_len == 1)\n\t\t{\n\t\t  /* No valid character.  Match it as a single byte\n\t\t     character.  */\n\t\t  return collseqmb[br_elem->opr.name[0]];\n\t\t}\n\t    }\n\t  else if (sym_name_len == 1)\n\t    return collseqmb[br_elem->opr.name[0]];\n\t}\n      return UINT_MAX;\n    }\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Build the range expression which starts from START_ELEM, and ends\n     at END_ELEM.  The result are written to MBCSET and SBCSET.\n     RANGE_ALLOC is the allocated size of mbcset->range_starts, and\n     mbcset->range_ends, is a pointer argument since we may\n     update it.  */\n\n  auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_range_exp (bitset_t sbcset, re_charset_t *mbcset, int *range_alloc,\n\t\t   bracket_elem_t *start_elem, bracket_elem_t *end_elem)\n    {\n      unsigned int ch;\n      uint32_t start_collseq;\n      uint32_t end_collseq;\n\n      /* Equivalence Classes and Character Classes can't be a range\n\t start/end.  */\n      if (BE (start_elem->type == EQUIV_CLASS || start_elem->type == CHAR_CLASS\n\t      || end_elem->type == EQUIV_CLASS || end_elem->type == CHAR_CLASS,\n\t      0))\n\treturn REG_ERANGE;\n\n      /* FIXME: Implement rational ranges here, too.  */\n      start_collseq = lookup_collation_sequence_value (start_elem);\n      end_collseq = lookup_collation_sequence_value (end_elem);\n      /* Check start/end collation sequence values.  */\n      if (BE (start_collseq == UINT_MAX || end_collseq == UINT_MAX, 0))\n\treturn REG_ECOLLATE;\n      if (BE ((syntax & RE_NO_EMPTY_RANGES) && start_collseq > end_collseq, 0))\n\treturn REG_ERANGE;\n\n      /* Got valid collation sequence values, add them as a new entry.\n\t However, if we have no collation elements, and the character set\n\t is single byte, the single byte character set that we\n\t build below suffices. */\n      if (nrules > 0 || dfa->mb_cur_max > 1)\n\t{\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*range_alloc == mbcset->nranges, 0))\n\t    {\n\t      /* There is not enough space, need realloc.  */\n\t      uint32_t *new_array_start;\n\t      uint32_t *new_array_end;\n\t      Idx new_nranges;\n\n\t      /* +1 in case of mbcset->nranges is 0.  */\n\t      new_nranges = 2 * mbcset->nranges + 1;\n\t      new_array_start = re_realloc (mbcset->range_starts, uint32_t,\n\t\t\t\t\t    new_nranges);\n\t      new_array_end = re_realloc (mbcset->range_ends, uint32_t,\n\t\t\t\t\t  new_nranges);\n\n\t      if (BE (new_array_start == NULL || new_array_end == NULL, 0))\n\t\treturn REG_ESPACE;\n\n\t      mbcset->range_starts = new_array_start;\n\t      mbcset->range_ends = new_array_end;\n\t      *range_alloc = new_nranges;\n\t    }\n\n\t  mbcset->range_starts[mbcset->nranges] = start_collseq;\n\t  mbcset->range_ends[mbcset->nranges++] = end_collseq;\n\t}\n\n      /* Build the table for single byte characters.  */\n      for (ch = 0; ch < SBC_MAX; ch++)\n\t{\n\t  uint32_t ch_collseq;\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    ch_collseq = collseqmb[ch];\n\t  else\n\t    ch_collseq = __collseq_table_lookup (collseqwc, __btowc (ch));\n\t  if (start_collseq <= ch_collseq && ch_collseq <= end_collseq)\n\t    bitset_set (sbcset, ch);\n\t}\n      return REG_NOERROR;\n    }\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Build the collating element which is represented by NAME.\n     The result are written to MBCSET and SBCSET.\n     COLL_SYM_ALLOC is the allocated size of mbcset->coll_sym, is a\n     pointer argument since we may update it.  */\n\n  auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_collating_symbol (bitset_t sbcset, re_charset_t *mbcset,\n\t\t\t  Idx *coll_sym_alloc, const unsigned char *name)\n    {\n      int32_t elem, idx;\n      size_t name_len = strlen ((const char *) name);\n      if (nrules != 0)\n\t{\n\t  elem = seek_collating_symbol_entry (name, name_len);\n\t  if (elem != -1)\n\t    {\n\t      /* We found the entry.  */\n\t      idx = symb_table[2 * elem + 1];\n\t      /* Skip the name of collating element name.  */\n\t      idx += 1 + extra[idx];\n\t    }\n\t  else if (name_len == 1)\n\t    {\n\t      /* No valid character, treat it as a normal\n\t\t character.  */\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t  else\n\t    return REG_ECOLLATE;\n\n\t  /* Got valid collation sequence, add it as a new entry.  */\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*coll_sym_alloc == mbcset->ncoll_syms, 0))\n\t    {\n\t      /* Not enough, realloc it.  */\n\t      /* +1 in case of mbcset->ncoll_syms is 0.  */\n\t      Idx new_coll_sym_alloc = 2 * mbcset->ncoll_syms + 1;\n\t      /* Use realloc since mbcset->coll_syms is NULL\n\t\t if *alloc == 0.  */\n\t      int32_t *new_coll_syms = re_realloc (mbcset->coll_syms, int32_t,\n\t\t\t\t\t\t   new_coll_sym_alloc);\n\t      if (BE (new_coll_syms == NULL, 0))\n\t\treturn REG_ESPACE;\n\t      mbcset->coll_syms = new_coll_syms;\n\t      *coll_sym_alloc = new_coll_sym_alloc;\n\t    }\n\t  mbcset->coll_syms[mbcset->ncoll_syms++] = idx;\n\t  return REG_NOERROR;\n\t}\n      else\n\t{\n\t  if (BE (name_len != 1, 0))\n\t    return REG_ECOLLATE;\n\t  else\n\t    {\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t}\n    }\n#endif\n\n  re_token_t br_token;\n  re_bitset_ptr_t sbcset;\n#ifdef RE_ENABLE_I18N\n  re_charset_t *mbcset;\n  Idx coll_sym_alloc = 0, range_alloc = 0, mbchar_alloc = 0;\n  Idx equiv_class_alloc = 0, char_class_alloc = 0;\n#endif /* not RE_ENABLE_I18N */\n  bool non_match = false;\n  bin_tree_t *work_tree;\n  int token_len;\n  bool first_round = true;\n#ifdef _LIBC\n  collseqmb = (const unsigned char *)\n    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQMB);\n  nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n  if (nrules)\n    {\n      /*\n      if (MB_CUR_MAX > 1)\n      */\n      collseqwc = _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQWC);\n      table_size = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_SYMB_HASH_SIZEMB);\n      symb_table = (const int32_t *) _NL_CURRENT (LC_COLLATE,\n\t\t\t\t\t\t  _NL_COLLATE_SYMB_TABLEMB);\n      extra = (const unsigned char *) _NL_CURRENT (LC_COLLATE,\n\t\t\t\t\t\t   _NL_COLLATE_SYMB_EXTRAMB);\n    }\n#endif\n  sbcset = (re_bitset_ptr_t) calloc (sizeof (bitset_t), 1);\n#ifdef RE_ENABLE_I18N\n  mbcset = (re_charset_t *) calloc (sizeof (re_charset_t), 1);\n#endif /* RE_ENABLE_I18N */\n#ifdef RE_ENABLE_I18N\n  if (BE (sbcset == NULL || mbcset == NULL, 0))\n#else\n  if (BE (sbcset == NULL, 0))\n#endif /* RE_ENABLE_I18N */\n    {\n      re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n      re_free (mbcset);\n#endif\n      *err = REG_ESPACE;\n      return NULL;\n    }\n\n  token_len = peek_token_bracket (token, regexp, syntax);\n  if (BE (token->type == END_OF_RE, 0))\n    {\n      *err = REG_BADPAT;\n      goto parse_bracket_exp_free_return;\n    }\n  if (token->type == OP_NON_MATCH_LIST)\n    {\n#ifdef RE_ENABLE_I18N\n      mbcset->non_match = 1;\n#endif /* not RE_ENABLE_I18N */\n      non_match = true;\n      if (syntax & RE_HAT_LISTS_NOT_NEWLINE)\n\tbitset_set (sbcset, '\\n');\n      re_string_skip_bytes (regexp, token_len); /* Skip a token.  */\n      token_len = peek_token_bracket (token, regexp, syntax);\n      if (BE (token->type == END_OF_RE, 0))\n\t{\n\t  *err = REG_BADPAT;\n\t  goto parse_bracket_exp_free_return;\n\t}\n    }\n\n  /* We treat the first ']' as a normal character.  */\n  if (token->type == OP_CLOSE_BRACKET)\n    token->type = CHARACTER;\n\n  while (1)\n    {\n      bracket_elem_t start_elem, end_elem;\n      unsigned char start_name_buf[BRACKET_NAME_BUF_SIZE];\n      unsigned char end_name_buf[BRACKET_NAME_BUF_SIZE];\n      reg_errcode_t ret;\n      int token_len2 = 0;\n      bool is_range_exp = false;\n      re_token_t token2;\n\n      start_elem.opr.name = start_name_buf;\n      start_elem.type = COLL_SYM;\n      ret = parse_bracket_element (&start_elem, regexp, token, token_len, dfa,\n\t\t\t\t   syntax, first_round);\n      if (BE (ret != REG_NOERROR, 0))\n\t{\n\t  *err = ret;\n\t  goto parse_bracket_exp_free_return;\n\t}\n      first_round = false;\n\n      /* Get information about the next token.  We need it in any case.  */\n      token_len = peek_token_bracket (token, regexp, syntax);\n\n      /* Do not check for ranges if we know they are not allowed.  */\n      if (start_elem.type != CHAR_CLASS && start_elem.type != EQUIV_CLASS)\n\t{\n\t  if (BE (token->type == END_OF_RE, 0))\n\t    {\n\t      *err = REG_EBRACK;\n\t      goto parse_bracket_exp_free_return;\n\t    }\n\t  if (token->type == OP_CHARSET_RANGE)\n\t    {\n\t      re_string_skip_bytes (regexp, token_len); /* Skip '-'.  */\n\t      token_len2 = peek_token_bracket (&token2, regexp, syntax);\n\t      if (BE (token2.type == END_OF_RE, 0))\n\t\t{\n\t\t  *err = REG_EBRACK;\n\t\t  goto parse_bracket_exp_free_return;\n\t\t}\n\t      if (token2.type == OP_CLOSE_BRACKET)\n\t\t{\n\t\t  /* We treat the last '-' as a normal character.  */\n\t\t  re_string_skip_bytes (regexp, -token_len);\n\t\t  token->type = CHARACTER;\n\t\t}\n\t      else\n\t\tis_range_exp = true;\n\t    }\n\t}\n\n      if (is_range_exp == true)\n\t{\n\t  end_elem.opr.name = end_name_buf;\n\t  end_elem.type = COLL_SYM;\n\t  ret = parse_bracket_element (&end_elem, regexp, &token2, token_len2,\n\t\t\t\t       dfa, syntax, true);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t    {\n\t      *err = ret;\n\t      goto parse_bracket_exp_free_return;\n\t    }\n\n\t  token_len = peek_token_bracket (token, regexp, syntax);\n\n#ifdef _LIBC\n\t  *err = build_range_exp (sbcset, mbcset, &range_alloc,\n\t\t\t\t  &start_elem, &end_elem);\n#else\n# ifdef RE_ENABLE_I18N\n\t  *err = build_range_exp (syntax, sbcset,\n\t\t\t\t  dfa->mb_cur_max > 1 ? mbcset : NULL,\n\t\t\t\t  &range_alloc, &start_elem, &end_elem);\n# else\n\t  *err = build_range_exp (syntax, sbcset, &start_elem, &end_elem);\n# endif\n#endif /* RE_ENABLE_I18N */\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    goto parse_bracket_exp_free_return;\n\t}\n      else\n\t{\n\t  switch (start_elem.type)\n\t    {\n\t    case SB_CHAR:\n\t      bitset_set (sbcset, start_elem.opr.ch);\n\t      break;\n#ifdef RE_ENABLE_I18N\n\t    case MB_CHAR:\n\t      /* Check whether the array has enough space.  */\n\t      if (BE (mbchar_alloc == mbcset->nmbchars, 0))\n\t\t{\n\t\t  wchar_t *new_mbchars;\n\t\t  /* Not enough, realloc it.  */\n\t\t  /* +1 in case of mbcset->nmbchars is 0.  */\n\t\t  mbchar_alloc = 2 * mbcset->nmbchars + 1;\n\t\t  /* Use realloc since array is NULL if *alloc == 0.  */\n\t\t  new_mbchars = re_realloc (mbcset->mbchars, wchar_t,\n\t\t\t\t\t    mbchar_alloc);\n\t\t  if (BE (new_mbchars == NULL, 0))\n\t\t    goto parse_bracket_exp_espace;\n\t\t  mbcset->mbchars = new_mbchars;\n\t\t}\n\t      mbcset->mbchars[mbcset->nmbchars++] = start_elem.opr.wch;\n\t      break;\n#endif /* RE_ENABLE_I18N */\n\t    case EQUIV_CLASS:\n\t      *err = build_equiv_class (sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t\t\tmbcset, &equiv_class_alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t\t\tstart_elem.opr.name);\n\t      if (BE (*err != REG_NOERROR, 0))\n\t\tgoto parse_bracket_exp_free_return;\n\t      break;\n\t    case COLL_SYM:\n\t      *err = build_collating_symbol (sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t\t\t     mbcset, &coll_sym_alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t\t\t     start_elem.opr.name);\n\t      if (BE (*err != REG_NOERROR, 0))\n\t\tgoto parse_bracket_exp_free_return;\n\t      break;\n\t    case CHAR_CLASS:\n\t      *err = build_charclass (regexp->trans, sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t\t      mbcset, &char_class_alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t\t      (const char *) start_elem.opr.name,\n\t\t\t\t      syntax);\n\t      if (BE (*err != REG_NOERROR, 0))\n\t       goto parse_bracket_exp_free_return;\n\t      break;\n\t    default:\n\t      assert (0);\n\t      break;\n\t    }\n\t}\n      if (BE (token->type == END_OF_RE, 0))\n\t{\n\t  *err = REG_EBRACK;\n\t  goto parse_bracket_exp_free_return;\n\t}\n      if (token->type == OP_CLOSE_BRACKET)\n\tbreak;\n    }\n\n  re_string_skip_bytes (regexp, token_len); /* Skip a token.  */\n\n  /* If it is non-matching list.  */\n  if (non_match)\n    bitset_not (sbcset);\n\n#ifdef RE_ENABLE_I18N\n  /* Ensure only single byte characters are set.  */\n  if (dfa->mb_cur_max > 1)\n    bitset_mask (sbcset, dfa->sb_char);\n\n  if (mbcset->nmbchars || mbcset->ncoll_syms || mbcset->nequiv_classes\n      || mbcset->nranges || (dfa->mb_cur_max > 1 && (mbcset->nchar_classes\n\t\t\t\t\t\t     || mbcset->non_match)))\n    {\n      bin_tree_t *mbc_tree;\n      int sbc_idx;\n      /* Build a tree for complex bracket.  */\n      dfa->has_mb_node = 1;\n      br_token.type = COMPLEX_BRACKET;\n      br_token.opr.mbcset = mbcset;\n      mbc_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n      if (BE (mbc_tree == NULL, 0))\n\tgoto parse_bracket_exp_espace;\n      for (sbc_idx = 0; sbc_idx < BITSET_WORDS; ++sbc_idx)\n\tif (sbcset[sbc_idx])\n\t  break;\n      /* If there are no bits set in sbcset, there is no point\n\t of having both SIMPLE_BRACKET and COMPLEX_BRACKET.  */\n      if (sbc_idx < BITSET_WORDS)\n\t{\n\t  /* Build a tree for simple bracket.  */\n\t  br_token.type = SIMPLE_BRACKET;\n\t  br_token.opr.sbcset = sbcset;\n\t  work_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n\t  if (BE (work_tree == NULL, 0))\n\t    goto parse_bracket_exp_espace;\n\n\t  /* Then join them by ALT node.  */\n\t  work_tree = create_tree (dfa, work_tree, mbc_tree, OP_ALT);\n\t  if (BE (work_tree == NULL, 0))\n\t    goto parse_bracket_exp_espace;\n\t}\n      else\n\t{\n\t  re_free (sbcset);\n\t  work_tree = mbc_tree;\n\t}\n    }\n  else\n#endif /* not RE_ENABLE_I18N */\n    {\n#ifdef RE_ENABLE_I18N\n      free_charset (mbcset);\n#endif\n      /* Build a tree for simple bracket.  */\n      br_token.type = SIMPLE_BRACKET;\n      br_token.opr.sbcset = sbcset;\n      work_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n      if (BE (work_tree == NULL, 0))\n\tgoto parse_bracket_exp_espace;\n    }\n  return work_tree;\n\n parse_bracket_exp_espace:\n  *err = REG_ESPACE;\n parse_bracket_exp_free_return:\n  re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n  free_charset (mbcset);\n#endif /* RE_ENABLE_I18N */\n  return NULL;\n}",
      "lines": 546,
      "depth": 25,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,\n\t\t   reg_syntax_t syntax, reg_errcode_t *err)",
        "*"
      ]
    },
    "seek_collating_symbol_entry": {
      "start_point": [
        2860,
        2
      ],
      "end_point": [
        2880,
        5
      ],
      "content": "auto inline int32_t\n  __attribute__ ((always_inline))\n  seek_collating_symbol_entry (const unsigned char *name, size_t name_len)\n    {\n      int32_t elem;\n\n      for (elem = 0; elem < table_size; elem++)\n\tif (symb_table[2 * elem] != 0)\n\t  {\n\t    int32_t idx = symb_table[2 * elem + 1];\n\t    /* Skip the name of collating element name.  */\n\t    idx += 1 + extra[idx];\n\t    if (/* Compare the length of the name.  */\n\t\tname_len == extra[idx]\n\t\t/* Compare the name.  */\n\t\t&& memcmp (name, &extra[idx + 1], name_len) == 0)\n\t      /* Yep, this is the entry.  */\n\t      return elem;\n\t  }\n      return -1;\n    }",
      "lines": 21,
      "depth": 15,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "int32_t",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "lookup_collation_sequence_value": {
      "start_point": [
        2886,
        2
      ],
      "end_point": [
        2945,
        5
      ],
      "content": "auto inline unsigned int\n  __attribute__ ((always_inline))\n  lookup_collation_sequence_value (bracket_elem_t *br_elem)\n    {\n      if (br_elem->type == SB_CHAR)\n\t{\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    return collseqmb[br_elem->opr.ch];\n\t  else\n\t    {\n\t      wint_t wc = __btowc (br_elem->opr.ch);\n\t      return __collseq_table_lookup (collseqwc, wc);\n\t    }\n\t}\n      else if (br_elem->type == MB_CHAR)\n\t{\n\t  if (nrules != 0)\n\t    return __collseq_table_lookup (collseqwc, br_elem->opr.wch);\n\t}\n      else if (br_elem->type == COLL_SYM)\n\t{\n\t  size_t sym_name_len = strlen ((char *) br_elem->opr.name);\n\t  if (nrules != 0)\n\t    {\n\t      int32_t elem, idx;\n\t      elem = seek_collating_symbol_entry (br_elem->opr.name,\n\t\t\t\t\t\t  sym_name_len);\n\t      if (elem != -1)\n\t\t{\n\t\t  /* We found the entry.  */\n\t\t  idx = symb_table[2 * elem + 1];\n\t\t  /* Skip the name of collating element name.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Skip the byte sequence of the collating element.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Adjust for the alignment.  */\n\t\t  idx = (idx + 3) & ~3;\n\t\t  /* Skip the multibyte collation sequence value.  */\n\t\t  idx += sizeof (unsigned int);\n\t\t  /* Skip the wide char sequence of the collating element.  */\n\t\t  idx += sizeof (unsigned int) *\n\t\t    (1 + *(unsigned int *) (extra + idx));\n\t\t  /* Return the collation sequence value.  */\n\t\t  return *(unsigned int *) (extra + idx);\n\t\t}\n\t      else if (sym_name_len == 1)\n\t\t{\n\t\t  /* No valid character.  Match it as a single byte\n\t\t     character.  */\n\t\t  return collseqmb[br_elem->opr.name[0]];\n\t\t}\n\t    }\n\t  else if (sym_name_len == 1)\n\t    return collseqmb[br_elem->opr.name[0]];\n\t}\n      return UINT_MAX;\n    }",
      "lines": 60,
      "depth": 22,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "unsigned int",
        "unsigned",
        "int",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "build_range_exp": {
      "start_point": [
        2954,
        2
      ],
      "end_point": [
        3027,
        5
      ],
      "content": "auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_range_exp (bitset_t sbcset, re_charset_t *mbcset, int *range_alloc,\n\t\t   bracket_elem_t *start_elem, bracket_elem_t *end_elem)\n    {\n      unsigned int ch;\n      uint32_t start_collseq;\n      uint32_t end_collseq;\n\n      /* Equivalence Classes and Character Classes can't be a range\n\t start/end.  */\n      if (BE (start_elem->type == EQUIV_CLASS || start_elem->type == CHAR_CLASS\n\t      || end_elem->type == EQUIV_CLASS || end_elem->type == CHAR_CLASS,\n\t      0))\n\treturn REG_ERANGE;\n\n      /* FIXME: Implement rational ranges here, too.  */\n      start_collseq = lookup_collation_sequence_value (start_elem);\n      end_collseq = lookup_collation_sequence_value (end_elem);\n      /* Check start/end collation sequence values.  */\n      if (BE (start_collseq == UINT_MAX || end_collseq == UINT_MAX, 0))\n\treturn REG_ECOLLATE;\n      if (BE ((syntax & RE_NO_EMPTY_RANGES) && start_collseq > end_collseq, 0))\n\treturn REG_ERANGE;\n\n      /* Got valid collation sequence values, add them as a new entry.\n\t However, if we have no collation elements, and the character set\n\t is single byte, the single byte character set that we\n\t build below suffices. */\n      if (nrules > 0 || dfa->mb_cur_max > 1)\n\t{\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*range_alloc == mbcset->nranges, 0))\n\t    {\n\t      /* There is not enough space, need realloc.  */\n\t      uint32_t *new_array_start;\n\t      uint32_t *new_array_end;\n\t      Idx new_nranges;\n\n\t      /* +1 in case of mbcset->nranges is 0.  */\n\t      new_nranges = 2 * mbcset->nranges + 1;\n\t      new_array_start = re_realloc (mbcset->range_starts, uint32_t,\n\t\t\t\t\t    new_nranges);\n\t      new_array_end = re_realloc (mbcset->range_ends, uint32_t,\n\t\t\t\t\t  new_nranges);\n\n\t      if (BE (new_array_start == NULL || new_array_end == NULL, 0))\n\t\treturn REG_ESPACE;\n\n\t      mbcset->range_starts = new_array_start;\n\t      mbcset->range_ends = new_array_end;\n\t      *range_alloc = new_nranges;\n\t    }\n\n\t  mbcset->range_starts[mbcset->nranges] = start_collseq;\n\t  mbcset->range_ends[mbcset->nranges++] = end_collseq;\n\t}\n\n      /* Build the table for single byte characters.  */\n      for (ch = 0; ch < SBC_MAX; ch++)\n\t{\n\t  uint32_t ch_collseq;\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    ch_collseq = collseqmb[ch];\n\t  else\n\t    ch_collseq = __collseq_table_lookup (collseqwc, __btowc (ch));\n\t  if (start_collseq <= ch_collseq && ch_collseq <= end_collseq)\n\t    bitset_set (sbcset, ch);\n\t}\n      return REG_NOERROR;\n    }",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "reg_errcode_t",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "build_collating_symbol": {
      "start_point": [
        3035,
        2
      ],
      "end_point": [
        3091,
        5
      ],
      "content": "auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_collating_symbol (bitset_t sbcset, re_charset_t *mbcset,\n\t\t\t  Idx *coll_sym_alloc, const unsigned char *name)\n    {\n      int32_t elem, idx;\n      size_t name_len = strlen ((const char *) name);\n      if (nrules != 0)\n\t{\n\t  elem = seek_collating_symbol_entry (name, name_len);\n\t  if (elem != -1)\n\t    {\n\t      /* We found the entry.  */\n\t      idx = symb_table[2 * elem + 1];\n\t      /* Skip the name of collating element name.  */\n\t      idx += 1 + extra[idx];\n\t    }\n\t  else if (name_len == 1)\n\t    {\n\t      /* No valid character, treat it as a normal\n\t\t character.  */\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t  else\n\t    return REG_ECOLLATE;\n\n\t  /* Got valid collation sequence, add it as a new entry.  */\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*coll_sym_alloc == mbcset->ncoll_syms, 0))\n\t    {\n\t      /* Not enough, realloc it.  */\n\t      /* +1 in case of mbcset->ncoll_syms is 0.  */\n\t      Idx new_coll_sym_alloc = 2 * mbcset->ncoll_syms + 1;\n\t      /* Use realloc since mbcset->coll_syms is NULL\n\t\t if *alloc == 0.  */\n\t      int32_t *new_coll_syms = re_realloc (mbcset->coll_syms, int32_t,\n\t\t\t\t\t\t   new_coll_sym_alloc);\n\t      if (BE (new_coll_syms == NULL, 0))\n\t\treturn REG_ESPACE;\n\t      mbcset->coll_syms = new_coll_syms;\n\t      *coll_sym_alloc = new_coll_sym_alloc;\n\t    }\n\t  mbcset->coll_syms[mbcset->ncoll_syms++] = idx;\n\t  return REG_NOERROR;\n\t}\n      else\n\t{\n\t  if (BE (name_len != 1, 0))\n\t    return REG_ECOLLATE;\n\t  else\n\t    {\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t}\n    }",
      "lines": 57,
      "depth": 12,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "reg_errcode_t",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "parse_bracket_element": {
      "start_point": [
        3392,
        0
      ],
      "end_point": [
        3426,
        1
      ],
      "content": "static reg_errcode_t\nparse_bracket_element (bracket_elem_t *elem, re_string_t *regexp,\n\t\t       re_token_t *token, int token_len, re_dfa_t *dfa,\n\t\t       reg_syntax_t syntax, bool accept_hyphen)\n{\n#ifdef RE_ENABLE_I18N\n  int cur_char_size;\n  cur_char_size = re_string_char_size_at (regexp, re_string_cur_idx (regexp));\n  if (cur_char_size > 1)\n    {\n      elem->type = MB_CHAR;\n      elem->opr.wch = re_string_wchar_at (regexp, re_string_cur_idx (regexp));\n      re_string_skip_bytes (regexp, cur_char_size);\n      return REG_NOERROR;\n    }\n#endif /* RE_ENABLE_I18N */\n  re_string_skip_bytes (regexp, token_len); /* Skip a token.  */\n  if (token->type == OP_OPEN_COLL_ELEM || token->type == OP_OPEN_CHAR_CLASS\n      || token->type == OP_OPEN_EQUIV_CLASS)\n    return parse_bracket_symbol (elem, regexp, token);\n  if (BE (token->type == OP_CHARSET_RANGE, 0) && !accept_hyphen)\n    {\n      /* A '-' must only appear as anything but a range indicator before\n\t the closing bracket.  Everything else is an error.  */\n      re_token_t token2;\n      (void) peek_token_bracket (&token2, regexp, syntax);\n      if (token2.type != OP_CLOSE_BRACKET)\n\t/* The actual error value is not standardized since this whole\n\t   case is undefined.  But ERANGE makes good sense.  */\n\treturn REG_ERANGE;\n    }\n  elem->type = SB_CHAR;\n  elem->opr.ch = token->opr.c;\n  return REG_NOERROR;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "parse_bracket_symbol": {
      "start_point": [
        3432,
        0
      ],
      "end_point": [
        3471,
        1
      ],
      "content": "static reg_errcode_t\nparse_bracket_symbol (bracket_elem_t *elem, re_string_t *regexp,\n\t\t      re_token_t *token)\n{\n  unsigned char ch, delim = token->opr.c;\n  int i = 0;\n  if (re_string_eoi(regexp))\n    return REG_EBRACK;\n  for (;; ++i)\n    {\n      if (i >= BRACKET_NAME_BUF_SIZE)\n\treturn REG_EBRACK;\n      if (token->type == OP_OPEN_CHAR_CLASS)\n\tch = re_string_fetch_byte_case (regexp);\n      else\n\tch = re_string_fetch_byte (regexp);\n      if (re_string_eoi(regexp))\n\treturn REG_EBRACK;\n      if (ch == delim && re_string_peek_byte (regexp, 0) == ']')\n\tbreak;\n      elem->opr.name[i] = ch;\n    }\n  re_string_skip_bytes (regexp, 1);\n  elem->opr.name[i] = '\\0';\n  switch (token->type)\n    {\n    case OP_OPEN_COLL_ELEM:\n      elem->type = COLL_SYM;\n      break;\n    case OP_OPEN_EQUIV_CLASS:\n      elem->type = EQUIV_CLASS;\n      break;\n    case OP_OPEN_CHAR_CLASS:\n      elem->type = CHAR_CLASS;\n      break;\n    default:\n      break;\n    }\n  return REG_NOERROR;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "build_charclass": {
      "start_point": [
        3579,
        9
      ],
      "end_point": [
        3653,
        1
      ],
      "content": "char *class_name, reg_syntax_t syntax)\n#endif /* not RE_ENABLE_I18N */\n{\n  int i;\n  const char *name = class_name;\n\n  /* In case of REG_ICASE \"upper\" and \"lower\" match the both of\n     upper and lower cases.  */\n  if ((syntax & RE_ICASE)\n      && (strcmp (name, \"upper\") == 0 || strcmp (name, \"lower\") == 0))\n    name = \"alpha\";\n\n#ifdef RE_ENABLE_I18N\n  /* Check the space of the arrays.  */\n  if (BE (*char_class_alloc == mbcset->nchar_classes, 0))\n    {\n      /* Not enough, realloc it.  */\n      /* +1 in case of mbcset->nchar_classes is 0.  */\n      Idx new_char_class_alloc = 2 * mbcset->nchar_classes + 1;\n      /* Use realloc since array is NULL if *alloc == 0.  */\n      wctype_t *new_char_classes = re_realloc (mbcset->char_classes, wctype_t,\n\t\t\t\t\t       new_char_class_alloc);\n      if (BE (new_char_classes == NULL, 0))\n\treturn REG_ESPACE;\n      mbcset->char_classes = new_char_classes;\n      *char_class_alloc = new_char_class_alloc;\n    }\n  mbcset->char_classes[mbcset->nchar_classes++] = __wctype (name);\n#endif /* RE_ENABLE_I18N */\n\n#define BUILD_CHARCLASS_LOOP(ctype_func)\t\\\n  do {\t\t\t\t\t\t\\\n    if (BE (trans != NULL, 0))\t\t\t\\\n      {\t\t\t\t\t\t\\\n\tfor (i = 0; i < SBC_MAX; ++i)\t\t\\\n\t  if (ctype_func (i))\t\t\t\\\n\t    bitset_set (sbcset, trans[i]);\t\\\n      }\t\t\t\t\t\t\\\n    else\t\t\t\t\t\\\n      {\t\t\t\t\t\t\\\n\tfor (i = 0; i < SBC_MAX; ++i)\t\t\\\n\t  if (ctype_func (i))\t\t\t\\\n\t    bitset_set (sbcset, i);\t\t\\\n      }\t\t\t\t\t\t\\\n  } while (0)\n\n  if (strcmp (name, \"alnum\") == 0)\n    BUILD_CHARCLASS_LOOP (isalnum);\n  else if (strcmp (name, \"cntrl\") == 0)\n    BUILD_CHARCLASS_LOOP (iscntrl);\n  else if (strcmp (name, \"lower\") == 0)\n    BUILD_CHARCLASS_LOOP (islower);\n  else if (strcmp (name, \"space\") == 0)\n    BUILD_CHARCLASS_LOOP (isspace);\n  else if (strcmp (name, \"alpha\") == 0)\n    BUILD_CHARCLASS_LOOP (isalpha);\n  else if (strcmp (name, \"digit\") == 0)\n    BUILD_CHARCLASS_LOOP (isdigit);\n  else if (strcmp (name, \"print\") == 0)\n    BUILD_CHARCLASS_LOOP (isprint);\n  else if (strcmp (name, \"upper\") == 0)\n    BUILD_CHARCLASS_LOOP (isupper);\n  else if (strcmp (name, \"blank\") == 0)\n    BUILD_CHARCLASS_LOOP (isblank);\n  else if (strcmp (name, \"graph\") == 0)\n    BUILD_CHARCLASS_LOOP (isgraph);\n  else if (strcmp (name, \"punct\") == 0)\n    BUILD_CHARCLASS_LOOP (ispunct);\n  else if (strcmp (name, \"xdigit\") == 0)\n    BUILD_CHARCLASS_LOOP (isxdigit);\n  else\n    return REG_ECTYPE;\n\n  return REG_NOERROR;\n}",
      "lines": 75,
      "depth": 20,
      "decorators": null
    },
    "build_charclass_op": {
      "start_point": [
        3655,
        0
      ],
      "end_point": [
        3759,
        1
      ],
      "content": "static bin_tree_t *\nbuild_charclass_op (re_dfa_t *dfa, RE_TRANSLATE_TYPE trans,\n\t\t    const char *class_name,\n\t\t    const char *extra, bool non_match,\n\t\t    reg_errcode_t *err)\n{\n  re_bitset_ptr_t sbcset;\n#ifdef RE_ENABLE_I18N\n  re_charset_t *mbcset;\n  Idx alloc = 0;\n#endif /* not RE_ENABLE_I18N */\n  reg_errcode_t ret;\n  re_token_t br_token;\n  bin_tree_t *tree;\n\n  sbcset = (re_bitset_ptr_t) calloc (sizeof (bitset_t), 1);\n  if (BE (sbcset == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n#ifdef RE_ENABLE_I18N\n  mbcset = (re_charset_t *) calloc (sizeof (re_charset_t), 1);\n  if (BE (mbcset == NULL, 0))\n    {\n      re_free (sbcset);\n      *err = REG_ESPACE;\n      return NULL;\n    }\n  mbcset->non_match = non_match;\n#endif /* RE_ENABLE_I18N */\n\n  /* We don't care the syntax in this case.  */\n  ret = build_charclass (trans, sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t mbcset, &alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t class_name, 0);\n\n  if (BE (ret != REG_NOERROR, 0))\n    {\n      re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n      free_charset (mbcset);\n#endif /* RE_ENABLE_I18N */\n      *err = ret;\n      return NULL;\n    }\n  /* \\w match '_' also.  */\n  for (; *extra; extra++)\n    bitset_set (sbcset, *extra);\n\n  /* If it is non-matching list.  */\n  if (non_match)\n    bitset_not (sbcset);\n\n#ifdef RE_ENABLE_I18N\n  /* Ensure only single byte characters are set.  */\n  if (dfa->mb_cur_max > 1)\n    bitset_mask (sbcset, dfa->sb_char);\n#endif\n\n  /* Build a tree for simple bracket.  */\n#if defined GCC_LINT || defined lint\n  memset (&br_token, 0, sizeof br_token);\n#endif\n  br_token.type = SIMPLE_BRACKET;\n  br_token.opr.sbcset = sbcset;\n  tree = create_token_tree (dfa, NULL, NULL, &br_token);\n  if (BE (tree == NULL, 0))\n    goto build_word_op_espace;\n\n#ifdef RE_ENABLE_I18N\n  if (dfa->mb_cur_max > 1)\n    {\n      bin_tree_t *mbc_tree;\n      /* Build a tree for complex bracket.  */\n      br_token.type = COMPLEX_BRACKET;\n      br_token.opr.mbcset = mbcset;\n      dfa->has_mb_node = 1;\n      mbc_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n      if (BE (mbc_tree == NULL, 0))\n\tgoto build_word_op_espace;\n      /* Then join them by ALT node.  */\n      tree = create_tree (dfa, tree, mbc_tree, OP_ALT);\n      if (BE (mbc_tree != NULL, 1))\n\treturn tree;\n    }\n  else\n    {\n      free_charset (mbcset);\n      return tree;\n    }\n#else /* not RE_ENABLE_I18N */\n  return tree;\n#endif /* not RE_ENABLE_I18N */\n\n build_word_op_espace:\n  re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n  free_charset (mbcset);\n#endif /* RE_ENABLE_I18N */\n  *err = REG_ESPACE;\n  return NULL;\n}",
      "lines": 105,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nbuild_charclass_op (re_dfa_t *dfa, RE_TRANSLATE_TYPE trans,\n\t\t    const char *class_name,\n\t\t    const char *extra, bool non_match,\n\t\t    reg_errcode_t *err)",
        "*"
      ]
    },
    "fetch_number": {
      "start_point": [
        3767,
        0
      ],
      "end_point": [
        3787,
        1
      ],
      "content": "static Idx\nfetch_number (re_string_t *input, re_token_t *token, reg_syntax_t syntax)\n{\n  Idx num = -1;\n  unsigned char c;\n  while (1)\n    {\n      fetch_token (token, input, syntax);\n      c = token->opr.c;\n      if (BE (token->type == END_OF_RE, 0))\n\treturn -2;\n      if (token->type == OP_CLOSE_DUP_NUM || c == ',')\n\tbreak;\n      num = ((token->type != CHARACTER || c < '0' || '9' < c || num == -2)\n\t     ? -2\n\t     : num == -1\n\t     ? c - '0'\n\t     : MIN (RE_DUP_MAX + 1, num * 10 + c - '0'));\n    }\n  return num;\n}",
      "lines": 21,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "Idx"
      ]
    },
    "free_charset": {
      "start_point": [
        3790,
        0
      ],
      "end_point": [
        3802,
        1
      ],
      "content": "static void\nfree_charset (re_charset_t *cset)\n{\n  re_free (cset->mbchars);\n# ifdef _LIBC\n  re_free (cset->coll_syms);\n  re_free (cset->equiv_classes);\n  re_free (cset->range_starts);\n  re_free (cset->range_ends);\n# endif\n  re_free (cset->char_classes);\n  re_free (cset);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_tree": {
      "start_point": [
        3809,
        0
      ],
      "end_point": [
        3819,
        1
      ],
      "content": "static bin_tree_t *\ncreate_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t     re_token_type_t type)\n{\n  re_token_t t;\n#if defined GCC_LINT || defined lint\n  memset (&t, 0, sizeof t);\n#endif\n  t.type = type;\n  return create_token_tree (dfa, left, right, &t);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\ncreate_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t     re_token_type_t type)",
        "*"
      ]
    },
    "create_token_tree": {
      "start_point": [
        3821,
        0
      ],
      "end_point": [
        3853,
        1
      ],
      "content": "static bin_tree_t *\ncreate_token_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t\t   const re_token_t *token)\n{\n  bin_tree_t *tree;\n  if (BE (dfa->str_tree_storage_idx == BIN_TREE_STORAGE_SIZE, 0))\n    {\n      bin_tree_storage_t *storage = re_malloc (bin_tree_storage_t, 1);\n\n      if (storage == NULL)\n\treturn NULL;\n      storage->next = dfa->str_tree_storage;\n      dfa->str_tree_storage = storage;\n      dfa->str_tree_storage_idx = 0;\n    }\n  tree = &dfa->str_tree_storage->data[dfa->str_tree_storage_idx++];\n\n  tree->parent = NULL;\n  tree->left = left;\n  tree->right = right;\n  tree->token = *token;\n  tree->token.duplicated = 0;\n  tree->token.opt_subexp = 0;\n  tree->first = NULL;\n  tree->next = NULL;\n  tree->node_idx = -1;\n\n  if (left != NULL)\n    left->parent = tree;\n  if (right != NULL)\n    right->parent = tree;\n  return tree;\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\ncreate_token_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t\t   const re_token_t *token)",
        "*"
      ]
    },
    "mark_opt_subexp": {
      "start_point": [
        3858,
        0
      ],
      "end_point": [
        3866,
        1
      ],
      "content": "static reg_errcode_t\nmark_opt_subexp (void *extra, bin_tree_t *node)\n{\n  Idx idx = (uintptr_t) extra;\n  if (node->token.type == SUBEXP && node->token.opr.idx == idx)\n    node->token.opt_subexp = 1;\n\n  return REG_NOERROR;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "free_token": {
      "start_point": [
        3870,
        0
      ],
      "end_point": [
        3880,
        1
      ],
      "content": "static void\nfree_token (re_token_t *node)\n{\n#ifdef RE_ENABLE_I18N\n  if (node->type == COMPLEX_BRACKET && node->duplicated == 0)\n    free_charset (node->opr.mbcset);\n  else\n#endif /* RE_ENABLE_I18N */\n    if (node->type == SIMPLE_BRACKET && node->duplicated == 0)\n      re_free (node->opr.sbcset);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "free_tree": {
      "start_point": [
        3885,
        0
      ],
      "end_point": [
        3890,
        1
      ],
      "content": "static reg_errcode_t\nfree_tree (void *extra, bin_tree_t *node)\n{\n  free_token (&node->token);\n  return REG_NOERROR;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "duplicate_tree": {
      "start_point": [
        3898,
        0
      ],
      "end_point": [
        3936,
        1
      ],
      "content": "static bin_tree_t *\nduplicate_tree (const bin_tree_t *root, re_dfa_t *dfa)\n{\n  const bin_tree_t *node;\n  bin_tree_t *dup_root;\n  bin_tree_t **p_new = &dup_root, *dup_node = root->parent;\n\n  for (node = root; ; )\n    {\n      /* Create a new tree and link it back to the current parent.  */\n      *p_new = create_token_tree (dfa, NULL, NULL, &node->token);\n      if (*p_new == NULL)\n\treturn NULL;\n      (*p_new)->parent = dup_node;\n      (*p_new)->token.duplicated = 1;\n      dup_node = *p_new;\n\n      /* Go to the left node, or up and to the right.  */\n      if (node->left)\n\t{\n\t  node = node->left;\n\t  p_new = &dup_node->left;\n\t}\n      else\n\t{\n\t  const bin_tree_t *prev = NULL;\n\t  while (node->right == prev || node->right == NULL)\n\t    {\n\t      prev = node;\n\t      node = node->parent;\n\t      dup_node = dup_node->parent;\n\t      if (!node)\n\t\treturn dup_root;\n\t    }\n\t  node = node->right;\n\t  p_new = &dup_node->right;\n\t}\n    }\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nduplicate_tree (const bin_tree_t *root, re_dfa_t *dfa)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/regex.c": {},
  "texinfo/texinfo-6.5/gnulib/lib/regex.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/regexec.c": {
    "regexec": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "int\nregexec (const regex_t *_Restrict_ preg, const char *_Restrict_ string,\n\t size_t nmatch, regmatch_t pmatch[], int eflags)\n{\n  reg_errcode_t err;\n  Idx start, length;\n  re_dfa_t *dfa = preg->buffer;\n\n  if (eflags & ~(REG_NOTBOL | REG_NOTEOL | REG_STARTEND))\n    return REG_BADPAT;\n\n  if (eflags & REG_STARTEND)\n    {\n      start = pmatch[0].rm_so;\n      length = pmatch[0].rm_eo;\n    }\n  else\n    {\n      start = 0;\n      length = strlen (string);\n    }\n\n  lock_lock (dfa->lock);\n  if (preg->no_sub)\n    err = re_search_internal (preg, string, length, start, length,\n\t\t\t      length, 0, NULL, eflags);\n  else\n    err = re_search_internal (preg, string, length, start, length,\n\t\t\t      length, nmatch, pmatch, eflags);\n  lock_unlock (dfa->lock);\n  return err != REG_NOERROR;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "__compat_regexec": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "int\nattribute_compat_text_section\n__compat_regexec (const regex_t *_Restrict_ preg,\n\t\t  const char *_Restrict_ string, size_t nmatch,\n\t\t  regmatch_t pmatch[], int eflags)\n{\n  return regexec (preg, string, nmatch, pmatch,\n\t\t  eflags & (REG_NOTBOL | REG_NOTEOL));\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "int",
        "attribute_compat_text_section",
        "attribute_compat_text_section"
      ]
    },
    "re_match": {
      "start_point": [
        302,
        0
      ],
      "end_point": [
        307,
        1
      ],
      "content": "regoff_t\nre_match (struct re_pattern_buffer *bufp, const char *string, Idx length,\n\t  Idx start, struct re_registers *regs)\n{\n  return re_search_stub (bufp, string, length, start, 0, length, regs, true);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "regoff_t"
      ]
    },
    "re_search": {
      "start_point": [
        312,
        0
      ],
      "end_point": [
        318,
        1
      ],
      "content": "regoff_t\nre_search (struct re_pattern_buffer *bufp, const char *string, Idx length,\n\t   Idx start, regoff_t range, struct re_registers *regs)\n{\n  return re_search_stub (bufp, string, length, start, range, length, regs,\n\t\t\t false);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "regoff_t"
      ]
    },
    "re_match_2": {
      "start_point": [
        323,
        0
      ],
      "end_point": [
        330,
        1
      ],
      "content": "regoff_t\nre_match_2 (struct re_pattern_buffer *bufp, const char *string1, Idx length1,\n\t    const char *string2, Idx length2, Idx start,\n\t    struct re_registers *regs, Idx stop)\n{\n  return re_search_2_stub (bufp, string1, length1, string2, length2,\n\t\t\t   start, 0, regs, stop, true);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "regoff_t"
      ]
    },
    "re_search_2": {
      "start_point": [
        335,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "regoff_t\nre_search_2 (struct re_pattern_buffer *bufp, const char *string1, Idx length1,\n\t     const char *string2, Idx length2, Idx start, regoff_t range,\n\t     struct re_registers *regs, Idx stop)\n{\n  return re_search_2_stub (bufp, string1, length1, string2, length2,\n\t\t\t   start, range, regs, stop, false);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "regoff_t"
      ]
    },
    "re_search_2_stub": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        389,
        1
      ],
      "content": "static regoff_t\ninternal_function\nre_search_2_stub (struct re_pattern_buffer *bufp, const char *string1,\n\t\t  Idx length1, const char *string2, Idx length2, Idx start,\n\t\t  regoff_t range, struct re_registers *regs,\n\t\t  Idx stop, bool ret_len)\n{\n  const char *str;\n  regoff_t rval;\n  Idx len;\n  char *s = NULL;\n\n  if (BE ((length1 < 0 || length2 < 0 || stop < 0\n           || INT_ADD_WRAPV (length1, length2, &len)),\n          0))\n    return -2;\n\n  /* Concatenate the strings.  */\n  if (length2 > 0)\n    if (length1 > 0)\n      {\n\ts = re_malloc (char, len);\n\n\tif (BE (s == NULL, 0))\n\t  return -2;\n#ifdef _LIBC\n\tmemcpy (__mempcpy (s, string1, length1), string2, length2);\n#else\n\tmemcpy (s, string1, length1);\n\tmemcpy (s + length1, string2, length2);\n#endif\n\tstr = s;\n      }\n    else\n      str = string2;\n  else\n    str = string1;\n\n  rval = re_search_stub (bufp, str, len, start, range, stop, regs,\n\t\t\t ret_len);\n  re_free (s);\n  return rval;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "regoff_t",
        "internal_function",
        "internal_function"
      ]
    },
    "re_search_stub": {
      "start_point": [
        396,
        0
      ],
      "end_point": [
        484,
        1
      ],
      "content": "static regoff_t\ninternal_function\nre_search_stub (struct re_pattern_buffer *bufp, const char *string, Idx length,\n\t\tIdx start, regoff_t range, Idx stop, struct re_registers *regs,\n\t\tbool ret_len)\n{\n  reg_errcode_t result;\n  regmatch_t *pmatch;\n  Idx nregs;\n  regoff_t rval;\n  int eflags = 0;\n  re_dfa_t *dfa = bufp->buffer;\n  Idx last_start = start + range;\n\n  /* Check for out-of-range.  */\n  if (BE (start < 0 || start > length, 0))\n    return -1;\n  if (BE (length < last_start || (0 <= range && last_start < start), 0))\n    last_start = length;\n  else if (BE (last_start < 0 || (range < 0 && start <= last_start), 0))\n    last_start = 0;\n\n  lock_lock (dfa->lock);\n\n  eflags |= (bufp->not_bol) ? REG_NOTBOL : 0;\n  eflags |= (bufp->not_eol) ? REG_NOTEOL : 0;\n\n  /* Compile fastmap if we haven't yet.  */\n  if (start < last_start && bufp->fastmap != NULL && !bufp->fastmap_accurate)\n    re_compile_fastmap (bufp);\n\n  if (BE (bufp->no_sub, 0))\n    regs = NULL;\n\n  /* We need at least 1 register.  */\n  if (regs == NULL)\n    nregs = 1;\n  else if (BE (bufp->regs_allocated == REGS_FIXED\n\t       && regs->num_regs <= bufp->re_nsub, 0))\n    {\n      nregs = regs->num_regs;\n      if (BE (nregs < 1, 0))\n\t{\n\t  /* Nothing can be copied to regs.  */\n\t  regs = NULL;\n\t  nregs = 1;\n\t}\n    }\n  else\n    nregs = bufp->re_nsub + 1;\n  pmatch = re_malloc (regmatch_t, nregs);\n  if (BE (pmatch == NULL, 0))\n    {\n      rval = -2;\n      goto out;\n    }\n\n  result = re_search_internal (bufp, string, length, start, last_start, stop,\n\t\t\t       nregs, pmatch, eflags);\n\n  rval = 0;\n\n  /* I hope we needn't fill their regs with -1's when no match was found.  */\n  if (result != REG_NOERROR)\n    rval = result == REG_NOMATCH ? -1 : -2;\n  else if (regs != NULL)\n    {\n      /* If caller wants register contents data back, copy them.  */\n      bufp->regs_allocated = re_copy_regs (regs, pmatch, nregs,\n\t\t\t\t\t   bufp->regs_allocated);\n      if (BE (bufp->regs_allocated == REGS_UNALLOCATED, 0))\n\trval = -2;\n    }\n\n  if (BE (rval == 0, 1))\n    {\n      if (ret_len)\n\t{\n\t  assert (pmatch[0].rm_so == start);\n\t  rval = pmatch[0].rm_eo - start;\n\t}\n      else\n\trval = pmatch[0].rm_so;\n    }\n  re_free (pmatch);\n out:\n  lock_unlock (dfa->lock);\n  return rval;\n}",
      "lines": 89,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "regoff_t",
        "internal_function",
        "internal_function"
      ]
    },
    "re_copy_regs": {
      "start_point": [
        486,
        0
      ],
      "end_point": [
        550,
        1
      ],
      "content": "static unsigned\ninternal_function\nre_copy_regs (struct re_registers *regs, regmatch_t *pmatch, Idx nregs,\n\t      int regs_allocated)\n{\n  int rval = REGS_REALLOCATE;\n  Idx i;\n  Idx need_regs = nregs + 1;\n  /* We need one extra element beyond 'num_regs' for the '-1' marker GNU code\n     uses.  */\n\n  /* Have the register data arrays been allocated?  */\n  if (regs_allocated == REGS_UNALLOCATED)\n    { /* No.  So allocate them with malloc.  */\n      regs->start = re_malloc (regoff_t, need_regs);\n      if (BE (regs->start == NULL, 0))\n\treturn REGS_UNALLOCATED;\n      regs->end = re_malloc (regoff_t, need_regs);\n      if (BE (regs->end == NULL, 0))\n\t{\n\t  re_free (regs->start);\n\t  return REGS_UNALLOCATED;\n\t}\n      regs->num_regs = need_regs;\n    }\n  else if (regs_allocated == REGS_REALLOCATE)\n    { /* Yes.  If we need more elements than were already\n\t allocated, reallocate them.  If we need fewer, just\n\t leave it alone.  */\n      if (BE (need_regs > regs->num_regs, 0))\n\t{\n\t  regoff_t *new_start = re_realloc (regs->start, regoff_t, need_regs);\n\t  regoff_t *new_end;\n\t  if (BE (new_start == NULL, 0))\n\t    return REGS_UNALLOCATED;\n\t  new_end = re_realloc (regs->end, regoff_t, need_regs);\n\t  if (BE (new_end == NULL, 0))\n\t    {\n\t      re_free (new_start);\n\t      return REGS_UNALLOCATED;\n\t    }\n\t  regs->start = new_start;\n\t  regs->end = new_end;\n\t  regs->num_regs = need_regs;\n\t}\n    }\n  else\n    {\n      assert (regs_allocated == REGS_FIXED);\n      /* This function may not be called with REGS_FIXED and nregs too big.  */\n      assert (regs->num_regs >= nregs);\n      rval = REGS_FIXED;\n    }\n\n  /* Copy the regs.  */\n  for (i = 0; i < nregs; ++i)\n    {\n      regs->start[i] = pmatch[i].rm_so;\n      regs->end[i] = pmatch[i].rm_eo;\n    }\n  for ( ; i < regs->num_regs; ++i)\n    regs->start[i] = regs->end[i] = -1;\n\n  return rval;\n}",
      "lines": 65,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "unsigned\ninternal_function",
        "unsigned",
        "internal_function"
      ]
    },
    "re_set_registers": {
      "start_point": [
        565,
        0
      ],
      "end_point": [
        582,
        1
      ],
      "content": "void\nre_set_registers (struct re_pattern_buffer *bufp, struct re_registers *regs,\n\t\t  __re_size_t num_regs, regoff_t *starts, regoff_t *ends)\n{\n  if (num_regs)\n    {\n      bufp->regs_allocated = REGS_REALLOCATE;\n      regs->num_regs = num_regs;\n      regs->start = starts;\n      regs->end = ends;\n    }\n  else\n    {\n      bufp->regs_allocated = REGS_UNALLOCATED;\n      regs->num_regs = 0;\n      regs->start = regs->end = NULL;\n    }\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "re_exec": {
      "start_point": [
        593,
        0
      ],
      "end_point": [
        598,
        1
      ],
      "content": "weak_function\n# endif\nre_exec (const char *s)\n{\n  return 0 == regexec (&re_comp_buf, s, 0, NULL, 0);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "weak_function",
        "# endif",
        "# endif"
      ]
    },
    "re_search_internal": {
      "start_point": [
        613,
        33
      ],
      "end_point": [
        944,
        1
      ],
      "content": "internal_function\nre_search_internal (const regex_t *preg, const char *string, Idx length,\n\t\t    Idx start, Idx last_start, Idx stop, size_t nmatch,\n\t\t    regmatch_t pmatch[], int eflags)\n{\n  reg_errcode_t err;\n  const re_dfa_t *dfa = preg->buffer;\n  Idx left_lim, right_lim;\n  int incr;\n  bool fl_longest_match;\n  int match_kind;\n  Idx match_first;\n  Idx match_last = -1;\n  Idx extra_nmatch;\n  bool sb;\n  int ch;\n#if defined _LIBC || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L)\n  re_match_context_t mctx = { .dfa = dfa };\n#else\n  re_match_context_t mctx;\n#endif\n  char *fastmap = ((preg->fastmap != NULL && preg->fastmap_accurate\n\t\t    && start != last_start && !preg->can_be_null)\n\t\t   ? preg->fastmap : NULL);\n  RE_TRANSLATE_TYPE t = preg->translate;\n\n#if !(defined _LIBC || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L))\n  memset (&mctx, '\\0', sizeof (re_match_context_t));\n  mctx.dfa = dfa;\n#endif\n\n  extra_nmatch = (nmatch > preg->re_nsub) ? nmatch - (preg->re_nsub + 1) : 0;\n  nmatch -= extra_nmatch;\n\n  /* Check if the DFA haven't been compiled.  */\n  if (BE (preg->used == 0 || dfa->init_state == NULL\n\t  || dfa->init_state_word == NULL || dfa->init_state_nl == NULL\n\t  || dfa->init_state_begbuf == NULL, 0))\n    return REG_NOMATCH;\n\n#ifdef DEBUG\n  /* We assume front-end functions already check them.  */\n  assert (0 <= last_start && last_start <= length);\n#endif\n\n  /* If initial states with non-begbuf contexts have no elements,\n     the regex must be anchored.  If preg->newline_anchor is set,\n     we'll never use init_state_nl, so do not check it.  */\n  if (dfa->init_state->nodes.nelem == 0\n      && dfa->init_state_word->nodes.nelem == 0\n      && (dfa->init_state_nl->nodes.nelem == 0\n\t  || !preg->newline_anchor))\n    {\n      if (start != 0 && last_start != 0)\n        return REG_NOMATCH;\n      start = last_start = 0;\n    }\n\n  /* We must check the longest matching, if nmatch > 0.  */\n  fl_longest_match = (nmatch != 0 || dfa->nbackref);\n\n  err = re_string_allocate (&mctx.input, string, length, dfa->nodes_len + 1,\n\t\t\t    preg->translate, (preg->syntax & RE_ICASE) != 0,\n\t\t\t    dfa);\n  if (BE (err != REG_NOERROR, 0))\n    goto free_return;\n  mctx.input.stop = stop;\n  mctx.input.raw_stop = stop;\n  mctx.input.newline_anchor = preg->newline_anchor;\n\n  err = match_ctx_init (&mctx, eflags, dfa->nbackref * 2);\n  if (BE (err != REG_NOERROR, 0))\n    goto free_return;\n\n  /* We will log all the DFA states through which the dfa pass,\n     if nmatch > 1, or this dfa has \"multibyte node\", which is a\n     back-reference or a node which can accept multibyte character or\n     multi character collating element.  */\n  if (nmatch > 1 || dfa->has_mb_node)\n    {\n      /* Avoid overflow.  */\n      if (BE ((MIN (IDX_MAX, SIZE_MAX / sizeof (re_dfastate_t *))\n               <= mctx.input.bufs_len), 0))\n\t{\n\t  err = REG_ESPACE;\n\t  goto free_return;\n\t}\n\n      mctx.state_log = re_malloc (re_dfastate_t *, mctx.input.bufs_len + 1);\n      if (BE (mctx.state_log == NULL, 0))\n\t{\n\t  err = REG_ESPACE;\n\t  goto free_return;\n\t}\n    }\n  else\n    mctx.state_log = NULL;\n\n  match_first = start;\n  mctx.input.tip_context = (eflags & REG_NOTBOL) ? CONTEXT_BEGBUF\n\t\t\t   : CONTEXT_NEWLINE | CONTEXT_BEGBUF;\n\n  /* Check incrementally whether the input string matches.  */\n  incr = (last_start < start) ? -1 : 1;\n  left_lim = (last_start < start) ? last_start : start;\n  right_lim = (last_start < start) ? start : last_start;\n  sb = dfa->mb_cur_max == 1;\n  match_kind =\n    (fastmap\n     ? ((sb || !(preg->syntax & RE_ICASE || t) ? 4 : 0)\n\t| (start <= last_start ? 2 : 0)\n\t| (t != NULL ? 1 : 0))\n     : 8);\n\n  for (;; match_first += incr)\n    {\n      err = REG_NOMATCH;\n      if (match_first < left_lim || right_lim < match_first)\n\tgoto free_return;\n\n      /* Advance as rapidly as possible through the string, until we\n\t find a plausible place to start matching.  This may be done\n\t with varying efficiency, so there are various possibilities:\n\t only the most common of them are specialized, in order to\n\t save on code size.  We use a switch statement for speed.  */\n      switch (match_kind)\n\t{\n\tcase 8:\n\t  /* No fastmap.  */\n\t  break;\n\n\tcase 7:\n\t  /* Fastmap with single-byte translation, match forward.  */\n\t  while (BE (match_first < right_lim, 1)\n\t\t && !fastmap[t[(unsigned char) string[match_first]]])\n\t    ++match_first;\n\t  goto forward_match_found_start_or_reached_end;\n\n\tcase 6:\n\t  /* Fastmap without translation, match forward.  */\n\t  while (BE (match_first < right_lim, 1)\n\t\t && !fastmap[(unsigned char) string[match_first]])\n\t    ++match_first;\n\n\tforward_match_found_start_or_reached_end:\n\t  if (BE (match_first == right_lim, 0))\n\t    {\n\t      ch = match_first >= length\n\t\t       ? 0 : (unsigned char) string[match_first];\n\t      if (!fastmap[t ? t[ch] : ch])\n\t\tgoto free_return;\n\t    }\n\t  break;\n\n\tcase 4:\n\tcase 5:\n\t  /* Fastmap without multi-byte translation, match backwards.  */\n\t  while (match_first >= left_lim)\n\t    {\n\t      ch = match_first >= length\n\t\t       ? 0 : (unsigned char) string[match_first];\n\t      if (fastmap[t ? t[ch] : ch])\n\t\tbreak;\n\t      --match_first;\n\t    }\n\t  if (match_first < left_lim)\n\t    goto free_return;\n\t  break;\n\n\tdefault:\n\t  /* In this case, we can't determine easily the current byte,\n\t     since it might be a component byte of a multibyte\n\t     character.  Then we use the constructed buffer instead.  */\n\t  for (;;)\n\t    {\n\t      /* If MATCH_FIRST is out of the valid range, reconstruct the\n\t\t buffers.  */\n\t      __re_size_t offset = match_first - mctx.input.raw_mbs_idx;\n\t      if (BE (offset >= (__re_size_t) mctx.input.valid_raw_len, 0))\n\t\t{\n\t\t  err = re_string_reconstruct (&mctx.input, match_first,\n\t\t\t\t\t       eflags);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    goto free_return;\n\n\t\t  offset = match_first - mctx.input.raw_mbs_idx;\n\t\t}\n\t      /* If MATCH_FIRST is out of the buffer, leave it as '\\0'.\n\t\t Note that MATCH_FIRST must not be smaller than 0.  */\n\t      ch = (match_first >= length\n\t\t    ? 0 : re_string_byte_at (&mctx.input, offset));\n\t      if (fastmap[ch])\n\t\tbreak;\n\t      match_first += incr;\n\t      if (match_first < left_lim || match_first > right_lim)\n\t\t{\n\t\t  err = REG_NOMATCH;\n\t\t  goto free_return;\n\t\t}\n\t    }\n\t  break;\n\t}\n\n      /* Reconstruct the buffers so that the matcher can assume that\n\t the matching starts from the beginning of the buffer.  */\n      err = re_string_reconstruct (&mctx.input, match_first, eflags);\n      if (BE (err != REG_NOERROR, 0))\n\tgoto free_return;\n\n#ifdef RE_ENABLE_I18N\n     /* Don't consider this char as a possible match start if it part,\n\tyet isn't the head, of a multibyte character.  */\n      if (!sb && !re_string_first_byte (&mctx.input, 0))\n\tcontinue;\n#endif\n\n      /* It seems to be appropriate one, then use the matcher.  */\n      /* We assume that the matching starts from 0.  */\n      mctx.state_log_top = mctx.nbkref_ents = mctx.max_mb_elem_len = 0;\n      match_last = check_matching (&mctx, fl_longest_match,\n\t\t\t\t   start <= last_start ? &match_first : NULL);\n      if (match_last != -1)\n\t{\n\t  if (BE (match_last == -2, 0))\n\t    {\n\t      err = REG_ESPACE;\n\t      goto free_return;\n\t    }\n\t  else\n\t    {\n\t      mctx.match_last = match_last;\n\t      if ((!preg->no_sub && nmatch > 1) || dfa->nbackref)\n\t\t{\n\t\t  re_dfastate_t *pstate = mctx.state_log[match_last];\n\t\t  mctx.last_node = check_halt_state_context (&mctx, pstate,\n\t\t\t\t\t\t\t     match_last);\n\t\t}\n\t      if ((!preg->no_sub && nmatch > 1 && dfa->has_plural_match)\n\t\t  || dfa->nbackref)\n\t\t{\n\t\t  err = prune_impossible_nodes (&mctx);\n\t\t  if (err == REG_NOERROR)\n\t\t    break;\n\t\t  if (BE (err != REG_NOMATCH, 0))\n\t\t    goto free_return;\n\t\t  match_last = -1;\n\t\t}\n\t      else\n\t\tbreak; /* We found a match.  */\n\t    }\n\t}\n\n      match_ctx_clean (&mctx);\n    }\n\n#ifdef DEBUG\n  assert (match_last != -1);\n  assert (err == REG_NOERROR);\n#endif\n\n  /* Set pmatch[] if we need.  */\n  if (nmatch > 0)\n    {\n      Idx reg_idx;\n\n      /* Initialize registers.  */\n      for (reg_idx = 1; reg_idx < nmatch; ++reg_idx)\n\tpmatch[reg_idx].rm_so = pmatch[reg_idx].rm_eo = -1;\n\n      /* Set the points where matching start/end.  */\n      pmatch[0].rm_so = 0;\n      pmatch[0].rm_eo = mctx.match_last;\n      /* FIXME: This function should fail if mctx.match_last exceeds\n\t the maximum possible regoff_t value.  We need a new error\n\t code REG_OVERFLOW.  */\n\n      if (!preg->no_sub && nmatch > 1)\n\t{\n\t  err = set_regs (preg, &mctx, nmatch, pmatch,\n\t\t\t  dfa->has_plural_match && dfa->nbackref > 0);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto free_return;\n\t}\n\n      /* At last, add the offset to each register, since we slid\n\t the buffers so that we could assume that the matching starts\n\t from 0.  */\n      for (reg_idx = 0; reg_idx < nmatch; ++reg_idx)\n\tif (pmatch[reg_idx].rm_so != -1)\n\t  {\n#ifdef RE_ENABLE_I18N\n\t    if (BE (mctx.input.offsets_needed != 0, 0))\n\t      {\n\t\tpmatch[reg_idx].rm_so =\n\t\t  (pmatch[reg_idx].rm_so == mctx.input.valid_len\n\t\t   ? mctx.input.valid_raw_len\n\t\t   : mctx.input.offsets[pmatch[reg_idx].rm_so]);\n\t\tpmatch[reg_idx].rm_eo =\n\t\t  (pmatch[reg_idx].rm_eo == mctx.input.valid_len\n\t\t   ? mctx.input.valid_raw_len\n\t\t   : mctx.input.offsets[pmatch[reg_idx].rm_eo]);\n\t      }\n#else\n\t    assert (mctx.input.offsets_needed == 0);\n#endif\n\t    pmatch[reg_idx].rm_so += match_first;\n\t    pmatch[reg_idx].rm_eo += match_first;\n\t  }\n      for (reg_idx = 0; reg_idx < extra_nmatch; ++reg_idx)\n\t{\n\t  pmatch[nmatch + reg_idx].rm_so = -1;\n\t  pmatch[nmatch + reg_idx].rm_eo = -1;\n\t}\n\n      if (dfa->subexp_map)\n\tfor (reg_idx = 0; reg_idx + 1 < nmatch; reg_idx++)\n\t  if (dfa->subexp_map[reg_idx] != reg_idx)\n\t    {\n\t      pmatch[reg_idx + 1].rm_so\n\t\t= pmatch[dfa->subexp_map[reg_idx] + 1].rm_so;\n\t      pmatch[reg_idx + 1].rm_eo\n\t\t= pmatch[dfa->subexp_map[reg_idx] + 1].rm_eo;\n\t    }\n    }\n\n free_return:\n  re_free (mctx.state_log);\n  if (dfa->nbackref)\n    match_ctx_free (&mctx);\n  re_string_destruct (&mctx.input);\n  return err;\n}",
      "lines": 332,
      "depth": 18,
      "decorators": [
        "internal_function"
      ]
    },
    "prune_impossible_nodes": {
      "start_point": [
        947,
        18
      ],
      "end_point": [
        1036,
        1
      ],
      "content": "__attribute_warn_unused_result__\nprune_impossible_nodes (re_match_context_t *mctx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx halt_node, match_last;\n  reg_errcode_t ret;\n  re_dfastate_t **sifted_states;\n  re_dfastate_t **lim_states = NULL;\n  re_sift_context_t sctx;\n#ifdef DEBUG\n  assert (mctx->state_log != NULL);\n#endif\n  match_last = mctx->match_last;\n  halt_node = mctx->last_node;\n\n  /* Avoid overflow.  */\n  if (BE (MIN (IDX_MAX, SIZE_MAX / sizeof (re_dfastate_t *)) <= match_last, 0))\n    return REG_ESPACE;\n\n  sifted_states = re_malloc (re_dfastate_t *, match_last + 1);\n  if (BE (sifted_states == NULL, 0))\n    {\n      ret = REG_ESPACE;\n      goto free_return;\n    }\n  if (dfa->nbackref)\n    {\n      lim_states = re_malloc (re_dfastate_t *, match_last + 1);\n      if (BE (lim_states == NULL, 0))\n\t{\n\t  ret = REG_ESPACE;\n\t  goto free_return;\n\t}\n      while (1)\n\t{\n\t  memset (lim_states, '\\0',\n\t\t  sizeof (re_dfastate_t *) * (match_last + 1));\n\t  sift_ctx_init (&sctx, sifted_states, lim_states, halt_node,\n\t\t\t match_last);\n\t  ret = sift_states_backward (mctx, &sctx);\n\t  re_node_set_free (&sctx.limits);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t      goto free_return;\n\t  if (sifted_states[0] != NULL || lim_states[0] != NULL)\n\t    break;\n\t  do\n\t    {\n\t      --match_last;\n\t      if (match_last < 0)\n\t\t{\n\t\t  ret = REG_NOMATCH;\n\t\t  goto free_return;\n\t\t}\n\t    } while (mctx->state_log[match_last] == NULL\n\t\t     || !mctx->state_log[match_last]->halt);\n\t  halt_node = check_halt_state_context (mctx,\n\t\t\t\t\t\tmctx->state_log[match_last],\n\t\t\t\t\t\tmatch_last);\n\t}\n      ret = merge_state_array (dfa, sifted_states, lim_states,\n\t\t\t       match_last + 1);\n      re_free (lim_states);\n      lim_states = NULL;\n      if (BE (ret != REG_NOERROR, 0))\n\tgoto free_return;\n    }\n  else\n    {\n      sift_ctx_init (&sctx, sifted_states, lim_states, halt_node, match_last);\n      ret = sift_states_backward (mctx, &sctx);\n      re_node_set_free (&sctx.limits);\n      if (BE (ret != REG_NOERROR, 0))\n\tgoto free_return;\n      if (sifted_states[0] == NULL)\n\t{\n\t  ret = REG_NOMATCH;\n\t  goto free_return;\n\t}\n    }\n  re_free (mctx->state_log);\n  mctx->state_log = sifted_states;\n  sifted_states = NULL;\n  mctx->last_node = halt_node;\n  mctx->match_last = match_last;\n  ret = REG_NOERROR;\n free_return:\n  re_free (sifted_states);\n  re_free (lim_states);\n  return ret;\n}",
      "lines": 90,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "acquire_init_state_context": {
      "start_point": [
        1043,
        32
      ],
      "end_point": [
        1073,
        1
      ],
      "content": "internal_function\nacquire_init_state_context (reg_errcode_t *err, const re_match_context_t *mctx,\n\t\t\t    Idx idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  if (dfa->init_state->has_constraint)\n    {\n      unsigned int context;\n      context = re_string_context_at (&mctx->input, idx - 1, mctx->eflags);\n      if (IS_WORD_CONTEXT (context))\n\treturn dfa->init_state_word;\n      else if (IS_ORDINARY_CONTEXT (context))\n\treturn dfa->init_state;\n      else if (IS_BEGBUF_CONTEXT (context) && IS_NEWLINE_CONTEXT (context))\n\treturn dfa->init_state_begbuf;\n      else if (IS_NEWLINE_CONTEXT (context))\n\treturn dfa->init_state_nl;\n      else if (IS_BEGBUF_CONTEXT (context))\n\t{\n\t  /* It is relatively rare case, then calculate on demand.  */\n\t  return re_acquire_state_context (err, dfa,\n\t\t\t\t\t   dfa->init_state->entrance_nodes,\n\t\t\t\t\t   context);\n\t}\n      else\n\t/* Must not happen?  */\n\treturn dfa->init_state;\n    }\n  else\n    return dfa->init_state;\n}",
      "lines": 31,
      "depth": 16,
      "decorators": [
        "internal_function"
      ]
    },
    "check_matching": {
      "start_point": [
        1085,
        18
      ],
      "end_point": [
        1213,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncheck_matching (re_match_context_t *mctx, bool fl_longest_match,\n\t\tIdx *p_match_first)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx match = 0;\n  Idx match_last = -1;\n  Idx cur_str_idx = re_string_cur_idx (&mctx->input);\n  re_dfastate_t *cur_state;\n  bool at_init_state = p_match_first != NULL;\n  Idx next_start_idx = cur_str_idx;\n\n  err = REG_NOERROR;\n  cur_state = acquire_init_state_context (&err, mctx, cur_str_idx);\n  /* An initial state must not be NULL (invalid).  */\n  if (BE (cur_state == NULL, 0))\n    {\n      assert (err == REG_ESPACE);\n      return -2;\n    }\n\n  if (mctx->state_log != NULL)\n    {\n      mctx->state_log[cur_str_idx] = cur_state;\n\n      /* Check OP_OPEN_SUBEXP in the initial state in case that we use them\n\t later.  E.g. Processing back references.  */\n      if (BE (dfa->nbackref, 0))\n\t{\n\t  at_init_state = false;\n\t  err = check_subexp_matching_top (mctx, &cur_state->nodes, 0);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\n\t  if (cur_state->has_backref)\n\t    {\n\t      err = transit_state_bkref (mctx, &cur_state->nodes);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t}\n    }\n\n  /* If the RE accepts NULL string.  */\n  if (BE (cur_state->halt, 0))\n    {\n      if (!cur_state->has_constraint\n\t  || check_halt_state_context (mctx, cur_state, cur_str_idx))\n\t{\n\t  if (!fl_longest_match)\n\t    return cur_str_idx;\n\t  else\n\t    {\n\t      match_last = cur_str_idx;\n\t      match = 1;\n\t    }\n\t}\n    }\n\n  while (!re_string_eoi (&mctx->input))\n    {\n      re_dfastate_t *old_state = cur_state;\n      Idx next_char_idx = re_string_cur_idx (&mctx->input) + 1;\n\n      if ((BE (next_char_idx >= mctx->input.bufs_len, 0)\n\t   && mctx->input.bufs_len < mctx->input.len)\n\t  || (BE (next_char_idx >= mctx->input.valid_len, 0)\n\t      && mctx->input.valid_len < mctx->input.len))\n\t{\n\t  err = extend_buffers (mctx, next_char_idx + 1);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      assert (err == REG_ESPACE);\n\t      return -2;\n\t    }\n\t}\n\n      cur_state = transit_state (&err, mctx, cur_state);\n      if (mctx->state_log != NULL)\n\tcur_state = merge_state_with_log (&err, mctx, cur_state);\n\n      if (cur_state == NULL)\n\t{\n\t  /* Reached the invalid state or an error.  Try to recover a valid\n\t     state using the state log, if available and if we have not\n\t     already found a valid (even if not the longest) match.  */\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return -2;\n\n\t  if (mctx->state_log == NULL\n\t      || (match && !fl_longest_match)\n\t      || (cur_state = find_recover_state (&err, mctx)) == NULL)\n\t    break;\n\t}\n\n      if (BE (at_init_state, 0))\n\t{\n\t  if (old_state == cur_state)\n\t    next_start_idx = next_char_idx;\n\t  else\n\t    at_init_state = false;\n\t}\n\n      if (cur_state->halt)\n\t{\n\t  /* Reached a halt state.\n\t     Check the halt state can satisfy the current context.  */\n\t  if (!cur_state->has_constraint\n\t      || check_halt_state_context (mctx, cur_state,\n\t\t\t\t\t   re_string_cur_idx (&mctx->input)))\n\t    {\n\t      /* We found an appropriate halt state.  */\n\t      match_last = re_string_cur_idx (&mctx->input);\n\t      match = 1;\n\n\t      /* We found a match, do not modify match_first below.  */\n\t      p_match_first = NULL;\n\t      if (!fl_longest_match)\n\t\tbreak;\n\t    }\n\t}\n    }\n\n  if (p_match_first)\n    *p_match_first += next_start_idx;\n\n  return match_last;\n}",
      "lines": 129,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "check_halt_node_context": {
      "start_point": [
        1217,
        0
      ],
      "end_point": [
        1230,
        1
      ],
      "content": "static bool\ninternal_function\ncheck_halt_node_context (const re_dfa_t *dfa, Idx node, unsigned int context)\n{\n  re_token_type_t type = dfa->nodes[node].type;\n  unsigned int constraint = dfa->nodes[node].constraint;\n  if (type != END_OF_RE)\n    return false;\n  if (!constraint)\n    return true;\n  if (NOT_SATISFY_NEXT_CONSTRAINT (constraint, context))\n    return false;\n  return true;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool",
        "internal_function",
        "internal_function"
      ]
    },
    "check_halt_state_context": {
      "start_point": [
        1236,
        0
      ],
      "end_point": [
        1251,
        1
      ],
      "content": "static Idx\ninternal_function\ncheck_halt_state_context (const re_match_context_t *mctx,\n\t\t\t  const re_dfastate_t *state, Idx idx)\n{\n  Idx i;\n  unsigned int context;\n#ifdef DEBUG\n  assert (state->halt);\n#endif\n  context = re_string_context_at (&mctx->input, idx, mctx->eflags);\n  for (i = 0; i < state->nodes.nelem; ++i)\n    if (check_halt_node_context (mctx->dfa, state->nodes.elems[i], context))\n      return state->nodes.elems[i];\n  return 0;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "proceed_next_node": {
      "start_point": [
        1258,
        0
      ],
      "end_point": [
        1358,
        1
      ],
      "content": "static Idx\ninternal_function\nproceed_next_node (const re_match_context_t *mctx, Idx nregs, regmatch_t *regs,\n\t\t   Idx *pidx, Idx node, re_node_set *eps_via_nodes,\n\t\t   struct re_fail_stack_t *fs)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx i;\n  bool ok;\n  if (IS_EPSILON_NODE (dfa->nodes[node].type))\n    {\n      re_node_set *cur_nodes = &mctx->state_log[*pidx]->nodes;\n      re_node_set *edests = &dfa->edests[node];\n      Idx dest_node;\n      ok = re_node_set_insert (eps_via_nodes, node);\n      if (BE (! ok, 0))\n\treturn -2;\n      /* Pick up a valid destination, or return -1 if none\n\t is found.  */\n      for (dest_node = -1, i = 0; i < edests->nelem; ++i)\n\t{\n\t  Idx candidate = edests->elems[i];\n\t  if (!re_node_set_contains (cur_nodes, candidate))\n\t    continue;\n          if (dest_node == -1)\n\t    dest_node = candidate;\n\n\t  else\n\t    {\n\t      /* In order to avoid infinite loop like \"(a*)*\", return the second\n\t\t epsilon-transition if the first was already considered.  */\n\t      if (re_node_set_contains (eps_via_nodes, dest_node))\n\t\treturn candidate;\n\n\t      /* Otherwise, push the second epsilon-transition on the fail stack.  */\n\t      else if (fs != NULL\n\t\t       && push_fail_stack (fs, *pidx, candidate, nregs, regs,\n\t\t\t\t\t   eps_via_nodes))\n\t\treturn -2;\n\n\t      /* We know we are going to exit.  */\n\t      break;\n\t    }\n\t}\n      return dest_node;\n    }\n  else\n    {\n      Idx naccepted = 0;\n      re_token_type_t type = dfa->nodes[node].type;\n\n#ifdef RE_ENABLE_I18N\n      if (dfa->nodes[node].accept_mb)\n\tnaccepted = check_node_accept_bytes (dfa, node, &mctx->input, *pidx);\n      else\n#endif /* RE_ENABLE_I18N */\n      if (type == OP_BACK_REF)\n\t{\n\t  Idx subexp_idx = dfa->nodes[node].opr.idx + 1;\n\t  naccepted = regs[subexp_idx].rm_eo - regs[subexp_idx].rm_so;\n\t  if (fs != NULL)\n\t    {\n\t      if (regs[subexp_idx].rm_so == -1 || regs[subexp_idx].rm_eo == -1)\n\t\treturn -1;\n\t      else if (naccepted)\n\t\t{\n\t\t  char *buf = (char *) re_string_get_buffer (&mctx->input);\n\t\t  if (memcmp (buf + regs[subexp_idx].rm_so, buf + *pidx,\n\t\t\t      naccepted) != 0)\n\t\t    return -1;\n\t\t}\n\t    }\n\n\t  if (naccepted == 0)\n\t    {\n\t      Idx dest_node;\n\t      ok = re_node_set_insert (eps_via_nodes, node);\n\t      if (BE (! ok, 0))\n\t\treturn -2;\n\t      dest_node = dfa->edests[node].elems[0];\n\t      if (re_node_set_contains (&mctx->state_log[*pidx]->nodes,\n\t\t\t\t\tdest_node))\n\t\treturn dest_node;\n\t    }\n\t}\n\n      if (naccepted != 0\n\t  || check_node_accept (mctx, dfa->nodes + node, *pidx))\n\t{\n\t  Idx dest_node = dfa->nexts[node];\n\t  *pidx = (naccepted == 0) ? *pidx + 1 : *pidx + naccepted;\n\t  if (fs && (*pidx > mctx->match_last || mctx->state_log[*pidx] == NULL\n\t\t     || !re_node_set_contains (&mctx->state_log[*pidx]->nodes,\n\t\t\t\t\t       dest_node)))\n\t    return -1;\n\t  re_node_set_empty (eps_via_nodes);\n\t  return dest_node;\n\t}\n    }\n  return -1;\n}",
      "lines": 101,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "push_fail_stack": {
      "start_point": [
        1361,
        18
      ],
      "end_point": [
        1385,
        1
      ],
      "content": "__attribute_warn_unused_result__\npush_fail_stack (struct re_fail_stack_t *fs, Idx str_idx, Idx dest_node,\n\t\t Idx nregs, regmatch_t *regs, re_node_set *eps_via_nodes)\n{\n  reg_errcode_t err;\n  Idx num = fs->num++;\n  if (fs->num == fs->alloc)\n    {\n      struct re_fail_stack_ent_t *new_array;\n      new_array = realloc (fs->stack, (sizeof (struct re_fail_stack_ent_t)\n\t\t\t\t       * fs->alloc * 2));\n      if (new_array == NULL)\n\treturn REG_ESPACE;\n      fs->alloc *= 2;\n      fs->stack = new_array;\n    }\n  fs->stack[num].idx = str_idx;\n  fs->stack[num].node = dest_node;\n  fs->stack[num].regs = re_malloc (regmatch_t, nregs);\n  if (fs->stack[num].regs == NULL)\n    return REG_ESPACE;\n  memcpy (fs->stack[num].regs, regs, sizeof (regmatch_t) * nregs);\n  err = re_node_set_init_copy (&fs->stack[num].eps_via_nodes, eps_via_nodes);\n  return err;\n}",
      "lines": 25,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "pop_fail_stack": {
      "start_point": [
        1387,
        0
      ],
      "end_point": [
        1400,
        1
      ],
      "content": "static Idx\ninternal_function\npop_fail_stack (struct re_fail_stack_t *fs, Idx *pidx, Idx nregs,\n\t\tregmatch_t *regs, re_node_set *eps_via_nodes)\n{\n  Idx num = --fs->num;\n  assert (num >= 0);\n  *pidx = fs->stack[num].idx;\n  memcpy (regs, fs->stack[num].regs, sizeof (regmatch_t) * nregs);\n  re_node_set_free (eps_via_nodes);\n  re_free (fs->stack[num].regs);\n  *eps_via_nodes = fs->stack[num].eps_via_nodes;\n  return fs->stack[num].node;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "set_regs": {
      "start_point": [
        1408,
        18
      ],
      "end_point": [
        1512,
        1
      ],
      "content": "__attribute_warn_unused_result__\nset_regs (const regex_t *preg, const re_match_context_t *mctx, size_t nmatch,\n\t  regmatch_t *pmatch, bool fl_backtrack)\n{\n  const re_dfa_t *dfa = preg->buffer;\n  Idx idx, cur_node;\n  re_node_set eps_via_nodes;\n  struct re_fail_stack_t *fs;\n  struct re_fail_stack_t fs_body = { 0, 2, NULL };\n  regmatch_t *prev_idx_match;\n  bool prev_idx_match_malloced = false;\n\n#ifdef DEBUG\n  assert (nmatch > 1);\n  assert (mctx->state_log != NULL);\n#endif\n  if (fl_backtrack)\n    {\n      fs = &fs_body;\n      fs->stack = re_malloc (struct re_fail_stack_ent_t, fs->alloc);\n      if (fs->stack == NULL)\n\treturn REG_ESPACE;\n    }\n  else\n    fs = NULL;\n\n  cur_node = dfa->init_node;\n  re_node_set_init_empty (&eps_via_nodes);\n\n  if (__libc_use_alloca (nmatch * sizeof (regmatch_t)))\n    prev_idx_match = (regmatch_t *) alloca (nmatch * sizeof (regmatch_t));\n  else\n    {\n      prev_idx_match = re_malloc (regmatch_t, nmatch);\n      if (prev_idx_match == NULL)\n\t{\n\t  free_fail_stack_return (fs);\n\t  return REG_ESPACE;\n\t}\n      prev_idx_match_malloced = true;\n    }\n  memcpy (prev_idx_match, pmatch, sizeof (regmatch_t) * nmatch);\n\n  for (idx = pmatch[0].rm_so; idx <= pmatch[0].rm_eo ;)\n    {\n      update_regs (dfa, pmatch, prev_idx_match, cur_node, idx, nmatch);\n\n      if (idx == pmatch[0].rm_eo && cur_node == mctx->last_node)\n\t{\n\t  Idx reg_idx;\n\t  if (fs)\n\t    {\n\t      for (reg_idx = 0; reg_idx < nmatch; ++reg_idx)\n\t\tif (pmatch[reg_idx].rm_so > -1 && pmatch[reg_idx].rm_eo == -1)\n\t\t  break;\n\t      if (reg_idx == nmatch)\n\t\t{\n\t\t  re_node_set_free (&eps_via_nodes);\n\t\t  if (prev_idx_match_malloced)\n\t\t    re_free (prev_idx_match);\n\t\t  return free_fail_stack_return (fs);\n\t\t}\n\t      cur_node = pop_fail_stack (fs, &idx, nmatch, pmatch,\n\t\t\t\t\t &eps_via_nodes);\n\t    }\n\t  else\n\t    {\n\t      re_node_set_free (&eps_via_nodes);\n\t      if (prev_idx_match_malloced)\n\t\tre_free (prev_idx_match);\n\t      return REG_NOERROR;\n\t    }\n\t}\n\n      /* Proceed to next node.  */\n      cur_node = proceed_next_node (mctx, nmatch, pmatch, &idx, cur_node,\n\t\t\t\t    &eps_via_nodes, fs);\n\n      if (BE (cur_node < 0, 0))\n\t{\n\t  if (BE (cur_node == -2, 0))\n\t    {\n\t      re_node_set_free (&eps_via_nodes);\n\t      if (prev_idx_match_malloced)\n\t\tre_free (prev_idx_match);\n\t      free_fail_stack_return (fs);\n\t      return REG_ESPACE;\n\t    }\n\t  if (fs)\n\t    cur_node = pop_fail_stack (fs, &idx, nmatch, pmatch,\n\t\t\t\t       &eps_via_nodes);\n\t  else\n\t    {\n\t      re_node_set_free (&eps_via_nodes);\n\t      if (prev_idx_match_malloced)\n\t\tre_free (prev_idx_match);\n\t      return REG_NOMATCH;\n\t    }\n\t}\n    }\n  re_node_set_free (&eps_via_nodes);\n  if (prev_idx_match_malloced)\n    re_free (prev_idx_match);\n  return free_fail_stack_return (fs);\n}",
      "lines": 105,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "free_fail_stack_return": {
      "start_point": [
        1514,
        0
      ],
      "end_point": [
        1529,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nfree_fail_stack_return (struct re_fail_stack_t *fs)\n{\n  if (fs)\n    {\n      Idx fs_idx;\n      for (fs_idx = 0; fs_idx < fs->num; ++fs_idx)\n\t{\n\t  re_node_set_free (&fs->stack[fs_idx].eps_via_nodes);\n\t  re_free (fs->stack[fs_idx].regs);\n\t}\n      re_free (fs->stack);\n    }\n  return REG_NOERROR;\n}",
      "lines": 16,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "update_regs": {
      "start_point": [
        1531,
        0
      ],
      "end_point": [
        1578,
        1
      ],
      "content": "static void\ninternal_function\nupdate_regs (const re_dfa_t *dfa, regmatch_t *pmatch,\n\t     regmatch_t *prev_idx_match, Idx cur_node, Idx cur_idx, Idx nmatch)\n{\n  int type = dfa->nodes[cur_node].type;\n  if (type == OP_OPEN_SUBEXP)\n    {\n      Idx reg_num = dfa->nodes[cur_node].opr.idx + 1;\n\n      /* We are at the first node of this sub expression.  */\n      if (reg_num < nmatch)\n\t{\n\t  pmatch[reg_num].rm_so = cur_idx;\n\t  pmatch[reg_num].rm_eo = -1;\n\t}\n    }\n  else if (type == OP_CLOSE_SUBEXP)\n    {\n      Idx reg_num = dfa->nodes[cur_node].opr.idx + 1;\n      if (reg_num < nmatch)\n\t{\n\t  /* We are at the last node of this sub expression.  */\n\t  if (pmatch[reg_num].rm_so < cur_idx)\n\t    {\n\t      pmatch[reg_num].rm_eo = cur_idx;\n\t      /* This is a non-empty match or we are not inside an optional\n\t\t subexpression.  Accept this right away.  */\n\t      memcpy (prev_idx_match, pmatch, sizeof (regmatch_t) * nmatch);\n\t    }\n\t  else\n\t    {\n\t      if (dfa->nodes[cur_node].opt_subexp\n\t\t  && prev_idx_match[reg_num].rm_so != -1)\n\t\t/* We transited through an empty match for an optional\n\t\t   subexpression, like (a?)*, and this is not the subexp's\n\t\t   first match.  Copy back the old content of the registers\n\t\t   so that matches of an inner subexpression are undone as\n\t\t   well, like in ((a?))*.  */\n\t\tmemcpy (pmatch, prev_idx_match, sizeof (regmatch_t) * nmatch);\n\t      else\n\t\t/* We completed a subexpression, but it may be part of\n\t\t   an optional one, so do not update PREV_IDX_MATCH.  */\n\t\tpmatch[reg_num].rm_eo = cur_idx;\n\t    }\n\t}\n    }\n}",
      "lines": 48,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "sift_states_backward": {
      "start_point": [
        1603,
        0
      ],
      "end_point": [
        1659,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nsift_states_backward (const re_match_context_t *mctx, re_sift_context_t *sctx)\n{\n  reg_errcode_t err;\n  int null_cnt = 0;\n  Idx str_idx = sctx->last_str_idx;\n  re_node_set cur_dest;\n\n#ifdef DEBUG\n  assert (mctx->state_log != NULL && mctx->state_log[str_idx] != NULL);\n#endif\n\n  /* Build sifted state_log[str_idx].  It has the nodes which can epsilon\n     transit to the last_node and the last_node itself.  */\n  err = re_node_set_init_1 (&cur_dest, sctx->last_node);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n  err = update_cur_sifted_state (mctx, sctx, str_idx, &cur_dest);\n  if (BE (err != REG_NOERROR, 0))\n    goto free_return;\n\n  /* Then check each states in the state_log.  */\n  while (str_idx > 0)\n    {\n      /* Update counters.  */\n      null_cnt = (sctx->sifted_states[str_idx] == NULL) ? null_cnt + 1 : 0;\n      if (null_cnt > mctx->max_mb_elem_len)\n\t{\n\t  memset (sctx->sifted_states, '\\0',\n\t\t  sizeof (re_dfastate_t *) * str_idx);\n\t  re_node_set_free (&cur_dest);\n\t  return REG_NOERROR;\n\t}\n      re_node_set_empty (&cur_dest);\n      --str_idx;\n\n      if (mctx->state_log[str_idx])\n\t{\n\t  err = build_sifted_states (mctx, sctx, str_idx, &cur_dest);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto free_return;\n\t}\n\n      /* Add all the nodes which satisfy the following conditions:\n\t - It can epsilon transit to a node in CUR_DEST.\n\t - It is in CUR_SRC.\n\t And update state_log.  */\n      err = update_cur_sifted_state (mctx, sctx, str_idx, &cur_dest);\n      if (BE (err != REG_NOERROR, 0))\n\tgoto free_return;\n    }\n  err = REG_NOERROR;\n free_return:\n  re_node_set_free (&cur_dest);\n  return err;\n}",
      "lines": 57,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "build_sifted_states": {
      "start_point": [
        1662,
        18
      ],
      "end_point": [
        1719,
        1
      ],
      "content": "__attribute_warn_unused_result__\nbuild_sifted_states (const re_match_context_t *mctx, re_sift_context_t *sctx,\n\t\t     Idx str_idx, re_node_set *cur_dest)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  const re_node_set *cur_src = &mctx->state_log[str_idx]->non_eps_nodes;\n  Idx i;\n\n  /* Then build the next sifted state.\n     We build the next sifted state on 'cur_dest', and update\n     'sifted_states[str_idx]' with 'cur_dest'.\n     Note:\n     'cur_dest' is the sifted state from 'state_log[str_idx + 1]'.\n     'cur_src' points the node_set of the old 'state_log[str_idx]'\n     (with the epsilon nodes pre-filtered out).  */\n  for (i = 0; i < cur_src->nelem; i++)\n    {\n      Idx prev_node = cur_src->elems[i];\n      int naccepted = 0;\n      bool ok;\n\n#ifdef DEBUG\n      re_token_type_t type = dfa->nodes[prev_node].type;\n      assert (!IS_EPSILON_NODE (type));\n#endif\n#ifdef RE_ENABLE_I18N\n      /* If the node may accept \"multi byte\".  */\n      if (dfa->nodes[prev_node].accept_mb)\n\tnaccepted = sift_states_iter_mb (mctx, sctx, prev_node,\n\t\t\t\t\t str_idx, sctx->last_str_idx);\n#endif /* RE_ENABLE_I18N */\n\n      /* We don't check backreferences here.\n\t See update_cur_sifted_state().  */\n      if (!naccepted\n\t  && check_node_accept (mctx, dfa->nodes + prev_node, str_idx)\n\t  && STATE_NODE_CONTAINS (sctx->sifted_states[str_idx + 1],\n\t\t\t\t  dfa->nexts[prev_node]))\n\tnaccepted = 1;\n\n      if (naccepted == 0)\n\tcontinue;\n\n      if (sctx->limits.nelem)\n\t{\n\t  Idx to_idx = str_idx + naccepted;\n\t  if (check_dst_limits (mctx, &sctx->limits,\n\t\t\t\tdfa->nexts[prev_node], to_idx,\n\t\t\t\tprev_node, str_idx))\n\t    continue;\n\t}\n      ok = re_node_set_insert (cur_dest, prev_node);\n      if (BE (! ok, 0))\n\treturn REG_ESPACE;\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "clean_state_log_if_needed": {
      "start_point": [
        1723,
        0
      ],
      "end_point": [
        1747,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nclean_state_log_if_needed (re_match_context_t *mctx, Idx next_state_log_idx)\n{\n  Idx top = mctx->state_log_top;\n\n  if ((next_state_log_idx >= mctx->input.bufs_len\n       && mctx->input.bufs_len < mctx->input.len)\n      || (next_state_log_idx >= mctx->input.valid_len\n\t  && mctx->input.valid_len < mctx->input.len))\n    {\n      reg_errcode_t err;\n      err = extend_buffers (mctx, next_state_log_idx + 1);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n\n  if (top < next_state_log_idx)\n    {\n      memset (mctx->state_log + top + 1, '\\0',\n\t      sizeof (re_dfastate_t *) * (next_state_log_idx - top));\n      mctx->state_log_top = next_state_log_idx;\n    }\n  return REG_NOERROR;\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "merge_state_array": {
      "start_point": [
        1749,
        0
      ],
      "end_point": [
        1774,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nmerge_state_array (const re_dfa_t *dfa, re_dfastate_t **dst,\n\t\t   re_dfastate_t **src, Idx num)\n{\n  Idx st_idx;\n  reg_errcode_t err;\n  for (st_idx = 0; st_idx < num; ++st_idx)\n    {\n      if (dst[st_idx] == NULL)\n\tdst[st_idx] = src[st_idx];\n      else if (src[st_idx] != NULL)\n\t{\n\t  re_node_set merged_set;\n\t  err = re_node_set_init_union (&merged_set, &dst[st_idx]->nodes,\n\t\t\t\t\t&src[st_idx]->nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t  dst[st_idx] = re_acquire_state (&err, dfa, &merged_set);\n\t  re_node_set_free (&merged_set);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 26,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "update_cur_sifted_state": {
      "start_point": [
        1776,
        0
      ],
      "end_point": [
        1822,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nupdate_cur_sifted_state (const re_match_context_t *mctx,\n\t\t\t re_sift_context_t *sctx, Idx str_idx,\n\t\t\t re_node_set *dest_nodes)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err = REG_NOERROR;\n  const re_node_set *candidates;\n  candidates = ((mctx->state_log[str_idx] == NULL) ? NULL\n\t\t: &mctx->state_log[str_idx]->nodes);\n\n  if (dest_nodes->nelem == 0)\n    sctx->sifted_states[str_idx] = NULL;\n  else\n    {\n      if (candidates)\n\t{\n\t  /* At first, add the nodes which can epsilon transit to a node in\n\t     DEST_NODE.  */\n\t  err = add_epsilon_src_nodes (dfa, dest_nodes, candidates);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\n\t  /* Then, check the limitations in the current sift_context.  */\n\t  if (sctx->limits.nelem)\n\t    {\n\t      err = check_subexp_limits (dfa, dest_nodes, candidates, &sctx->limits,\n\t\t\t\t\t mctx->bkref_ents, str_idx);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t}\n\n      sctx->sifted_states[str_idx] = re_acquire_state (&err, dfa, dest_nodes);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n\n  if (candidates && mctx->state_log[str_idx]->has_backref)\n    {\n      err = sift_states_bkref (mctx, sctx, str_idx, candidates);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n  return REG_NOERROR;\n}",
      "lines": 47,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "add_epsilon_src_nodes": {
      "start_point": [
        1825,
        18
      ],
      "end_point": [
        1851,
        1
      ],
      "content": "__attribute_warn_unused_result__\nadd_epsilon_src_nodes (const re_dfa_t *dfa, re_node_set *dest_nodes,\n\t\t       const re_node_set *candidates)\n{\n  reg_errcode_t err = REG_NOERROR;\n  Idx i;\n\n  re_dfastate_t *state = re_acquire_state (&err, dfa, dest_nodes);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n\n  if (!state->inveclosure.alloc)\n    {\n      err = re_node_set_alloc (&state->inveclosure, dest_nodes->nelem);\n      if (BE (err != REG_NOERROR, 0))\n\treturn REG_ESPACE;\n      for (i = 0; i < dest_nodes->nelem; i++)\n\t{\n\t  err = re_node_set_merge (&state->inveclosure,\n\t\t\t\t   dfa->inveclosures + dest_nodes->elems[i]);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return REG_ESPACE;\n\t}\n    }\n  return re_node_set_add_intersect (dest_nodes, candidates,\n\t\t\t\t    &state->inveclosure);\n}",
      "lines": 27,
      "depth": 14,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "sub_epsilon_src_nodes": {
      "start_point": [
        1853,
        0
      ],
      "end_point": [
        1900,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nsub_epsilon_src_nodes (const re_dfa_t *dfa, Idx node, re_node_set *dest_nodes,\n\t\t       const re_node_set *candidates)\n{\n    Idx ecl_idx;\n    reg_errcode_t err;\n    re_node_set *inv_eclosure = dfa->inveclosures + node;\n    re_node_set except_nodes;\n    re_node_set_init_empty (&except_nodes);\n    for (ecl_idx = 0; ecl_idx < inv_eclosure->nelem; ++ecl_idx)\n      {\n\tIdx cur_node = inv_eclosure->elems[ecl_idx];\n\tif (cur_node == node)\n\t  continue;\n\tif (IS_EPSILON_NODE (dfa->nodes[cur_node].type))\n\t  {\n\t    Idx edst1 = dfa->edests[cur_node].elems[0];\n\t    Idx edst2 = ((dfa->edests[cur_node].nelem > 1)\n\t\t\t ? dfa->edests[cur_node].elems[1] : -1);\n\t    if ((!re_node_set_contains (inv_eclosure, edst1)\n\t\t && re_node_set_contains (dest_nodes, edst1))\n\t\t|| (edst2 > 0\n\t\t    && !re_node_set_contains (inv_eclosure, edst2)\n\t\t    && re_node_set_contains (dest_nodes, edst2)))\n\t      {\n\t\terr = re_node_set_add_intersect (&except_nodes, candidates,\n\t\t\t\t\t\t dfa->inveclosures + cur_node);\n\t\tif (BE (err != REG_NOERROR, 0))\n\t\t  {\n\t\t    re_node_set_free (&except_nodes);\n\t\t    return err;\n\t\t  }\n\t      }\n\t  }\n      }\n    for (ecl_idx = 0; ecl_idx < inv_eclosure->nelem; ++ecl_idx)\n      {\n\tIdx cur_node = inv_eclosure->elems[ecl_idx];\n\tif (!re_node_set_contains (&except_nodes, cur_node))\n\t  {\n\t    Idx idx = re_node_set_contains (dest_nodes, cur_node) - 1;\n\t    re_node_set_remove_at (dest_nodes, idx);\n\t  }\n      }\n    re_node_set_free (&except_nodes);\n    return REG_NOERROR;\n}",
      "lines": 48,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "check_dst_limits": {
      "start_point": [
        1902,
        0
      ],
      "end_point": [
        1936,
        1
      ],
      "content": "static bool\ninternal_function\ncheck_dst_limits (const re_match_context_t *mctx, const re_node_set *limits,\n\t\t  Idx dst_node, Idx dst_idx, Idx src_node, Idx src_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx lim_idx, src_pos, dst_pos;\n\n  Idx dst_bkref_idx = search_cur_bkref_entry (mctx, dst_idx);\n  Idx src_bkref_idx = search_cur_bkref_entry (mctx, src_idx);\n  for (lim_idx = 0; lim_idx < limits->nelem; ++lim_idx)\n    {\n      Idx subexp_idx;\n      struct re_backref_cache_entry *ent;\n      ent = mctx->bkref_ents + limits->elems[lim_idx];\n      subexp_idx = dfa->nodes[ent->node].opr.idx;\n\n      dst_pos = check_dst_limits_calc_pos (mctx, limits->elems[lim_idx],\n\t\t\t\t\t   subexp_idx, dst_node, dst_idx,\n\t\t\t\t\t   dst_bkref_idx);\n      src_pos = check_dst_limits_calc_pos (mctx, limits->elems[lim_idx],\n\t\t\t\t\t   subexp_idx, src_node, src_idx,\n\t\t\t\t\t   src_bkref_idx);\n\n      /* In case of:\n\t <src> <dst> ( <subexp> )\n\t ( <subexp> ) <src> <dst>\n\t ( <subexp1> <src> <subexp2> <dst> <subexp3> )  */\n      if (src_pos == dst_pos)\n\tcontinue; /* This is unrelated limitation.  */\n      else\n\treturn true;\n    }\n  return false;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool",
        "internal_function",
        "internal_function"
      ]
    },
    "check_dst_limits_calc_pos_1": {
      "start_point": [
        1938,
        0
      ],
      "end_point": [
        2018,
        1
      ],
      "content": "static int\ninternal_function\ncheck_dst_limits_calc_pos_1 (const re_match_context_t *mctx, int boundaries,\n\t\t\t     Idx subexp_idx, Idx from_node, Idx bkref_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  const re_node_set *eclosures = dfa->eclosures + from_node;\n  Idx node_idx;\n\n  /* Else, we are on the boundary: examine the nodes on the epsilon\n     closure.  */\n  for (node_idx = 0; node_idx < eclosures->nelem; ++node_idx)\n    {\n      Idx node = eclosures->elems[node_idx];\n      switch (dfa->nodes[node].type)\n\t{\n\tcase OP_BACK_REF:\n\t  if (bkref_idx != -1)\n\t    {\n\t      struct re_backref_cache_entry *ent = mctx->bkref_ents + bkref_idx;\n\t      do\n\t\t{\n\t\t  Idx dst;\n\t\t  int cpos;\n\n\t\t  if (ent->node != node)\n\t\t    continue;\n\n\t\t  if (subexp_idx < BITSET_WORD_BITS\n\t\t      && !(ent->eps_reachable_subexps_map\n\t\t\t   & ((bitset_word_t) 1 << subexp_idx)))\n\t\t    continue;\n\n\t\t  /* Recurse trying to reach the OP_OPEN_SUBEXP and\n\t\t     OP_CLOSE_SUBEXP cases below.  But, if the\n\t\t     destination node is the same node as the source\n\t\t     node, don't recurse because it would cause an\n\t\t     infinite loop: a regex that exhibits this behavior\n\t\t     is ()\\1*\\1*  */\n\t\t  dst = dfa->edests[node].elems[0];\n\t\t  if (dst == from_node)\n\t\t    {\n\t\t      if (boundaries & 1)\n\t\t\treturn -1;\n\t\t      else /* if (boundaries & 2) */\n\t\t\treturn 0;\n\t\t    }\n\n\t\t  cpos =\n\t\t    check_dst_limits_calc_pos_1 (mctx, boundaries, subexp_idx,\n\t\t\t\t\t\t dst, bkref_idx);\n\t\t  if (cpos == -1 /* && (boundaries & 1) */)\n\t\t    return -1;\n\t\t  if (cpos == 0 && (boundaries & 2))\n\t\t    return 0;\n\n\t\t  if (subexp_idx < BITSET_WORD_BITS)\n\t\t    ent->eps_reachable_subexps_map\n\t\t      &= ~((bitset_word_t) 1 << subexp_idx);\n\t\t}\n\t      while (ent++->more);\n\t    }\n\t  break;\n\n\tcase OP_OPEN_SUBEXP:\n\t  if ((boundaries & 1) && subexp_idx == dfa->nodes[node].opr.idx)\n\t    return -1;\n\t  break;\n\n\tcase OP_CLOSE_SUBEXP:\n\t  if ((boundaries & 2) && subexp_idx == dfa->nodes[node].opr.idx)\n\t    return 0;\n\t  break;\n\n\tdefault:\n\t    break;\n\t}\n    }\n\n  return (boundaries & 2) ? 1 : 0;\n}",
      "lines": 81,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "check_dst_limits_calc_pos": {
      "start_point": [
        2020,
        0
      ],
      "end_point": [
        2045,
        1
      ],
      "content": "static int\ninternal_function\ncheck_dst_limits_calc_pos (const re_match_context_t *mctx, Idx limit,\n\t\t\t   Idx subexp_idx, Idx from_node, Idx str_idx,\n\t\t\t   Idx bkref_idx)\n{\n  struct re_backref_cache_entry *lim = mctx->bkref_ents + limit;\n  int boundaries;\n\n  /* If we are outside the range of the subexpression, return -1 or 1.  */\n  if (str_idx < lim->subexp_from)\n    return -1;\n\n  if (lim->subexp_to < str_idx)\n    return 1;\n\n  /* If we are within the subexpression, return 0.  */\n  boundaries = (str_idx == lim->subexp_from);\n  boundaries |= (str_idx == lim->subexp_to) << 1;\n  if (boundaries == 0)\n    return 0;\n\n  /* Else, examine epsilon closure.  */\n  return check_dst_limits_calc_pos_1 (mctx, boundaries, subexp_idx,\n\t\t\t\t      from_node, bkref_idx);\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "check_subexp_limits": {
      "start_point": [
        2050,
        0
      ],
      "end_point": [
        2136,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ncheck_subexp_limits (const re_dfa_t *dfa, re_node_set *dest_nodes,\n\t\t     const re_node_set *candidates, re_node_set *limits,\n\t\t     struct re_backref_cache_entry *bkref_ents, Idx str_idx)\n{\n  reg_errcode_t err;\n  Idx node_idx, lim_idx;\n\n  for (lim_idx = 0; lim_idx < limits->nelem; ++lim_idx)\n    {\n      Idx subexp_idx;\n      struct re_backref_cache_entry *ent;\n      ent = bkref_ents + limits->elems[lim_idx];\n\n      if (str_idx <= ent->subexp_from || ent->str_idx < str_idx)\n\tcontinue; /* This is unrelated limitation.  */\n\n      subexp_idx = dfa->nodes[ent->node].opr.idx;\n      if (ent->subexp_to == str_idx)\n\t{\n\t  Idx ops_node = -1;\n\t  Idx cls_node = -1;\n\t  for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)\n\t    {\n\t      Idx node = dest_nodes->elems[node_idx];\n\t      re_token_type_t type = dfa->nodes[node].type;\n\t      if (type == OP_OPEN_SUBEXP\n\t\t  && subexp_idx == dfa->nodes[node].opr.idx)\n\t\tops_node = node;\n\t      else if (type == OP_CLOSE_SUBEXP\n\t\t       && subexp_idx == dfa->nodes[node].opr.idx)\n\t\tcls_node = node;\n\t    }\n\n\t  /* Check the limitation of the open subexpression.  */\n\t  /* Note that (ent->subexp_to = str_idx != ent->subexp_from).  */\n\t  if (ops_node >= 0)\n\t    {\n\t      err = sub_epsilon_src_nodes (dfa, ops_node, dest_nodes,\n\t\t\t\t\t   candidates);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\n\t  /* Check the limitation of the close subexpression.  */\n\t  if (cls_node >= 0)\n\t    for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)\n\t      {\n\t\tIdx node = dest_nodes->elems[node_idx];\n\t\tif (!re_node_set_contains (dfa->inveclosures + node,\n\t\t\t\t\t   cls_node)\n\t\t    && !re_node_set_contains (dfa->eclosures + node,\n\t\t\t\t\t      cls_node))\n\t\t  {\n\t\t    /* It is against this limitation.\n\t\t       Remove it form the current sifted state.  */\n\t\t    err = sub_epsilon_src_nodes (dfa, node, dest_nodes,\n\t\t\t\t\t\t candidates);\n\t\t    if (BE (err != REG_NOERROR, 0))\n\t\t      return err;\n\t\t    --node_idx;\n\t\t  }\n\t      }\n\t}\n      else /* (ent->subexp_to != str_idx)  */\n\t{\n\t  for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)\n\t    {\n\t      Idx node = dest_nodes->elems[node_idx];\n\t      re_token_type_t type = dfa->nodes[node].type;\n\t      if (type == OP_CLOSE_SUBEXP || type == OP_OPEN_SUBEXP)\n\t\t{\n\t\t  if (subexp_idx != dfa->nodes[node].opr.idx)\n\t\t    continue;\n\t\t  /* It is against this limitation.\n\t\t     Remove it form the current sifted state.  */\n\t\t  err = sub_epsilon_src_nodes (dfa, node, dest_nodes,\n\t\t\t\t\t       candidates);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    return err;\n\t\t}\n\t    }\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 87,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "sift_states_bkref": {
      "start_point": [
        2139,
        18
      ],
      "end_point": [
        2234,
        1
      ],
      "content": "__attribute_warn_unused_result__\nsift_states_bkref (const re_match_context_t *mctx, re_sift_context_t *sctx,\n\t\t   Idx str_idx, const re_node_set *candidates)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx node_idx, node;\n  re_sift_context_t local_sctx;\n  Idx first_idx = search_cur_bkref_entry (mctx, str_idx);\n\n  if (first_idx == -1)\n    return REG_NOERROR;\n\n  local_sctx.sifted_states = NULL; /* Mark that it hasn't been initialized.  */\n\n  for (node_idx = 0; node_idx < candidates->nelem; ++node_idx)\n    {\n      Idx enabled_idx;\n      re_token_type_t type;\n      struct re_backref_cache_entry *entry;\n      node = candidates->elems[node_idx];\n      type = dfa->nodes[node].type;\n      /* Avoid infinite loop for the REs like \"()\\1+\".  */\n      if (node == sctx->last_node && str_idx == sctx->last_str_idx)\n\tcontinue;\n      if (type != OP_BACK_REF)\n\tcontinue;\n\n      entry = mctx->bkref_ents + first_idx;\n      enabled_idx = first_idx;\n      do\n\t{\n\t  Idx subexp_len;\n\t  Idx to_idx;\n\t  Idx dst_node;\n\t  bool ok;\n\t  re_dfastate_t *cur_state;\n\n\t  if (entry->node != node)\n\t    continue;\n\t  subexp_len = entry->subexp_to - entry->subexp_from;\n\t  to_idx = str_idx + subexp_len;\n\t  dst_node = (subexp_len ? dfa->nexts[node]\n\t\t      : dfa->edests[node].elems[0]);\n\n\t  if (to_idx > sctx->last_str_idx\n\t      || sctx->sifted_states[to_idx] == NULL\n\t      || !STATE_NODE_CONTAINS (sctx->sifted_states[to_idx], dst_node)\n\t      || check_dst_limits (mctx, &sctx->limits, node,\n\t\t\t\t   str_idx, dst_node, to_idx))\n\t    continue;\n\n\t  if (local_sctx.sifted_states == NULL)\n\t    {\n\t      local_sctx = *sctx;\n\t      err = re_node_set_init_copy (&local_sctx.limits, &sctx->limits);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  local_sctx.last_node = node;\n\t  local_sctx.last_str_idx = str_idx;\n\t  ok = re_node_set_insert (&local_sctx.limits, enabled_idx);\n\t  if (BE (! ok, 0))\n\t    {\n\t      err = REG_ESPACE;\n\t      goto free_return;\n\t    }\n\t  cur_state = local_sctx.sifted_states[str_idx];\n\t  err = sift_states_backward (mctx, &local_sctx);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto free_return;\n\t  if (sctx->limited_states != NULL)\n\t    {\n\t      err = merge_state_array (dfa, sctx->limited_states,\n\t\t\t\t       local_sctx.sifted_states,\n\t\t\t\t       str_idx + 1);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  local_sctx.sifted_states[str_idx] = cur_state;\n\t  re_node_set_remove (&local_sctx.limits, enabled_idx);\n\n\t  /* mctx->bkref_ents may have changed, reload the pointer.  */\n\t  entry = mctx->bkref_ents + enabled_idx;\n\t}\n      while (enabled_idx++, entry++->more);\n    }\n  err = REG_NOERROR;\n free_return:\n  if (local_sctx.sifted_states != NULL)\n    {\n      re_node_set_free (&local_sctx.limits);\n    }\n\n  return err;\n}",
      "lines": 96,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "sift_states_iter_mb": {
      "start_point": [
        2238,
        0
      ],
      "end_point": [
        2257,
        1
      ],
      "content": "static int\ninternal_function\nsift_states_iter_mb (const re_match_context_t *mctx, re_sift_context_t *sctx,\n\t\t     Idx node_idx, Idx str_idx, Idx max_str_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  int naccepted;\n  /* Check the node can accept \"multi byte\".  */\n  naccepted = check_node_accept_bytes (dfa, node_idx, &mctx->input, str_idx);\n  if (naccepted > 0 && str_idx + naccepted <= max_str_idx &&\n      !STATE_NODE_CONTAINS (sctx->sifted_states[str_idx + naccepted],\n\t\t\t    dfa->nexts[node_idx]))\n    /* The node can't accept the \"multi byte\", or the\n       destination was already thrown away, then the node\n       could't accept the current input \"multi byte\".   */\n    naccepted = 0;\n  /* Otherwise, it is sure that the node could accept\n     'naccepted' bytes input.  */\n  return naccepted;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "transit_state": {
      "start_point": [
        2269,
        18
      ],
      "end_point": [
        2323,
        1
      ],
      "content": "__attribute_warn_unused_result__\ntransit_state (reg_errcode_t *err, re_match_context_t *mctx,\n\t       re_dfastate_t *state)\n{\n  re_dfastate_t **trtable;\n  unsigned char ch;\n\n#ifdef RE_ENABLE_I18N\n  /* If the current state can accept multibyte.  */\n  if (BE (state->accept_mb, 0))\n    {\n      *err = transit_state_mb (mctx, state);\n      if (BE (*err != REG_NOERROR, 0))\n\treturn NULL;\n    }\n#endif /* RE_ENABLE_I18N */\n\n  /* Then decide the next state with the single byte.  */\n#if 0\n  if (0)\n    /* don't use transition table  */\n    return transit_state_sb (err, mctx, state);\n#endif\n\n  /* Use transition table  */\n  ch = re_string_fetch_byte (&mctx->input);\n  for (;;)\n    {\n      trtable = state->trtable;\n      if (BE (trtable != NULL, 1))\n\treturn trtable[ch];\n\n      trtable = state->word_trtable;\n      if (BE (trtable != NULL, 1))\n\t{\n\t  unsigned int context;\n\t  context\n\t    = re_string_context_at (&mctx->input,\n\t\t\t\t    re_string_cur_idx (&mctx->input) - 1,\n\t\t\t\t    mctx->eflags);\n\t  if (IS_WORD_CONTEXT (context))\n\t    return trtable[ch + SBC_MAX];\n\t  else\n\t    return trtable[ch];\n\t}\n\n      if (!build_trtable (mctx->dfa, state))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n\n      /* Retry, we now have a transition table.  */\n    }\n}",
      "lines": 55,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "merge_state_with_log": {
      "start_point": [
        2326,
        0
      ],
      "end_point": [
        2400,
        1
      ],
      "content": "static re_dfastate_t *\ninternal_function\nmerge_state_with_log (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t      re_dfastate_t *next_state)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx cur_idx = re_string_cur_idx (&mctx->input);\n\n  if (cur_idx > mctx->state_log_top)\n    {\n      mctx->state_log[cur_idx] = next_state;\n      mctx->state_log_top = cur_idx;\n    }\n  else if (mctx->state_log[cur_idx] == 0)\n    {\n      mctx->state_log[cur_idx] = next_state;\n    }\n  else\n    {\n      re_dfastate_t *pstate;\n      unsigned int context;\n      re_node_set next_nodes, *log_nodes, *table_nodes = NULL;\n      /* If (state_log[cur_idx] != 0), it implies that cur_idx is\n\t the destination of a multibyte char/collating element/\n\t back reference.  Then the next state is the union set of\n\t these destinations and the results of the transition table.  */\n      pstate = mctx->state_log[cur_idx];\n      log_nodes = pstate->entrance_nodes;\n      if (next_state != NULL)\n\t{\n\t  table_nodes = next_state->entrance_nodes;\n\t  *err = re_node_set_init_union (&next_nodes, table_nodes,\n\t\t\t\t\t     log_nodes);\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    return NULL;\n\t}\n      else\n\tnext_nodes = *log_nodes;\n      /* Note: We already add the nodes of the initial state,\n\t then we don't need to add them here.  */\n\n      context = re_string_context_at (&mctx->input,\n\t\t\t\t      re_string_cur_idx (&mctx->input) - 1,\n\t\t\t\t      mctx->eflags);\n      next_state = mctx->state_log[cur_idx]\n\t= re_acquire_state_context (err, dfa, &next_nodes, context);\n      /* We don't need to check errors here, since the return value of\n\t this function is next_state and ERR is already set.  */\n\n      if (table_nodes != NULL)\n\tre_node_set_free (&next_nodes);\n    }\n\n  if (BE (dfa->nbackref, 0) && next_state != NULL)\n    {\n      /* Check OP_OPEN_SUBEXP in the current state in case that we use them\n\t later.  We must check them here, since the back references in the\n\t next state might use them.  */\n      *err = check_subexp_matching_top (mctx, &next_state->nodes,\n\t\t\t\t\tcur_idx);\n      if (BE (*err != REG_NOERROR, 0))\n\treturn NULL;\n\n      /* If the next state has back references.  */\n      if (next_state->has_backref)\n\t{\n\t  *err = transit_state_bkref (mctx, &next_state->nodes);\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    return NULL;\n\t  next_state = mctx->state_log[cur_idx];\n\t}\n    }\n\n  return next_state;\n}",
      "lines": 75,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\ninternal_function\nmerge_state_with_log (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t      re_dfastate_t *next_state)",
        "*",
        "internal_function",
        "internal_function"
      ]
    },
    "find_recover_state": {
      "start_point": [
        2405,
        0
      ],
      "end_point": [
        2427,
        1
      ],
      "content": "static re_dfastate_t *\ninternal_function\nfind_recover_state (reg_errcode_t *err, re_match_context_t *mctx)\n{\n  re_dfastate_t *cur_state;\n  do\n    {\n      Idx max = mctx->state_log_top;\n      Idx cur_str_idx = re_string_cur_idx (&mctx->input);\n\n      do\n\t{\n\t  if (++cur_str_idx > max)\n\t    return NULL;\n\t  re_string_skip_bytes (&mctx->input, 1);\n\t}\n      while (mctx->state_log[cur_str_idx] == NULL);\n\n      cur_state = merge_state_with_log (err, mctx, NULL);\n    }\n  while (*err == REG_NOERROR && cur_state == NULL);\n  return cur_state;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\ninternal_function\nfind_recover_state (reg_errcode_t *err, re_match_context_t *mctx)",
        "*",
        "internal_function",
        "internal_function"
      ]
    },
    "check_subexp_matching_top": {
      "start_point": [
        2436,
        0
      ],
      "end_point": [
        2464,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ncheck_subexp_matching_top (re_match_context_t *mctx, re_node_set *cur_nodes,\n\t\t\t   Idx str_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx node_idx;\n  reg_errcode_t err;\n\n  /* TODO: This isn't efficient.\n\t   Because there might be more than one nodes whose types are\n\t   OP_OPEN_SUBEXP and whose index is SUBEXP_IDX, we must check all\n\t   nodes.\n\t   E.g. RE: (a){2}  */\n  for (node_idx = 0; node_idx < cur_nodes->nelem; ++node_idx)\n    {\n      Idx node = cur_nodes->elems[node_idx];\n      if (dfa->nodes[node].type == OP_OPEN_SUBEXP\n\t  && dfa->nodes[node].opr.idx < BITSET_WORD_BITS\n\t  && (dfa->used_bkref_map\n\t      & ((bitset_word_t) 1 << dfa->nodes[node].opr.idx)))\n\t{\n\t  err = match_ctx_add_subtop (mctx, node, str_idx);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 29,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "transit_state_sb": {
      "start_point": [
        2470,
        0
      ],
      "end_point": [
        2505,
        1
      ],
      "content": "static re_dfastate_t *\ntransit_state_sb (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t  re_dfastate_t *state)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  re_node_set next_nodes;\n  re_dfastate_t *next_state;\n  Idx node_cnt, cur_str_idx = re_string_cur_idx (&mctx->input);\n  unsigned int context;\n\n  *err = re_node_set_alloc (&next_nodes, state->nodes.nelem + 1);\n  if (BE (*err != REG_NOERROR, 0))\n    return NULL;\n  for (node_cnt = 0; node_cnt < state->nodes.nelem; ++node_cnt)\n    {\n      Idx cur_node = state->nodes.elems[node_cnt];\n      if (check_node_accept (mctx, dfa->nodes + cur_node, cur_str_idx))\n\t{\n\t  *err = re_node_set_merge (&next_nodes,\n\t\t\t\t    dfa->eclosures + dfa->nexts[cur_node]);\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return NULL;\n\t    }\n\t}\n    }\n  context = re_string_context_at (&mctx->input, cur_str_idx, mctx->eflags);\n  next_state = re_acquire_state_context (err, dfa, &next_nodes, context);\n  /* We don't need to check errors here, since the return value of\n     this function is next_state and ERR is already set.  */\n\n  re_node_set_free (&next_nodes);\n  re_string_skip_bytes (&mctx->input, 1);\n  return next_state;\n}",
      "lines": 36,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\ntransit_state_sb (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t  re_dfastate_t *state)",
        "*"
      ]
    },
    "transit_state_mb": {
      "start_point": [
        2509,
        0
      ],
      "end_point": [
        2577,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ntransit_state_mb (re_match_context_t *mctx, re_dfastate_t *pstate)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx i;\n\n  for (i = 0; i < pstate->nodes.nelem; ++i)\n    {\n      re_node_set dest_nodes, *new_nodes;\n      Idx cur_node_idx = pstate->nodes.elems[i];\n      int naccepted;\n      Idx dest_idx;\n      unsigned int context;\n      re_dfastate_t *dest_state;\n\n      if (!dfa->nodes[cur_node_idx].accept_mb)\n\tcontinue;\n\n      if (dfa->nodes[cur_node_idx].constraint)\n\t{\n\t  context = re_string_context_at (&mctx->input,\n\t\t\t\t\t  re_string_cur_idx (&mctx->input),\n\t\t\t\t\t  mctx->eflags);\n\t  if (NOT_SATISFY_NEXT_CONSTRAINT (dfa->nodes[cur_node_idx].constraint,\n\t\t\t\t\t   context))\n\t    continue;\n\t}\n\n      /* How many bytes the node can accept?  */\n      naccepted = check_node_accept_bytes (dfa, cur_node_idx, &mctx->input,\n\t\t\t\t\t   re_string_cur_idx (&mctx->input));\n      if (naccepted == 0)\n\tcontinue;\n\n      /* The node can accepts 'naccepted' bytes.  */\n      dest_idx = re_string_cur_idx (&mctx->input) + naccepted;\n      mctx->max_mb_elem_len = ((mctx->max_mb_elem_len < naccepted) ? naccepted\n\t\t\t       : mctx->max_mb_elem_len);\n      err = clean_state_log_if_needed (mctx, dest_idx);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n#ifdef DEBUG\n      assert (dfa->nexts[cur_node_idx] != -1);\n#endif\n      new_nodes = dfa->eclosures + dfa->nexts[cur_node_idx];\n\n      dest_state = mctx->state_log[dest_idx];\n      if (dest_state == NULL)\n\tdest_nodes = *new_nodes;\n      else\n\t{\n\t  err = re_node_set_init_union (&dest_nodes,\n\t\t\t\t\tdest_state->entrance_nodes, new_nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n      context = re_string_context_at (&mctx->input, dest_idx - 1,\n\t\t\t\t      mctx->eflags);\n      mctx->state_log[dest_idx]\n\t= re_acquire_state_context (&err, dfa, &dest_nodes, context);\n      if (dest_state != NULL)\n\tre_node_set_free (&dest_nodes);\n      if (BE (mctx->state_log[dest_idx] == NULL && err != REG_NOERROR, 0))\n\treturn err;\n    }\n  return REG_NOERROR;\n}",
      "lines": 69,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "transit_state_bkref": {
      "start_point": [
        2580,
        0
      ],
      "end_point": [
        2686,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ntransit_state_bkref (re_match_context_t *mctx, const re_node_set *nodes)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx i;\n  Idx cur_str_idx = re_string_cur_idx (&mctx->input);\n\n  for (i = 0; i < nodes->nelem; ++i)\n    {\n      Idx dest_str_idx, prev_nelem, bkc_idx;\n      Idx node_idx = nodes->elems[i];\n      unsigned int context;\n      const re_token_t *node = dfa->nodes + node_idx;\n      re_node_set *new_dest_nodes;\n\n      /* Check whether 'node' is a backreference or not.  */\n      if (node->type != OP_BACK_REF)\n\tcontinue;\n\n      if (node->constraint)\n\t{\n\t  context = re_string_context_at (&mctx->input, cur_str_idx,\n\t\t\t\t\t  mctx->eflags);\n\t  if (NOT_SATISFY_NEXT_CONSTRAINT (node->constraint, context))\n\t    continue;\n\t}\n\n      /* 'node' is a backreference.\n\t Check the substring which the substring matched.  */\n      bkc_idx = mctx->nbkref_ents;\n      err = get_subexp (mctx, node_idx, cur_str_idx);\n      if (BE (err != REG_NOERROR, 0))\n\tgoto free_return;\n\n      /* And add the epsilon closures (which is 'new_dest_nodes') of\n\t the backreference to appropriate state_log.  */\n#ifdef DEBUG\n      assert (dfa->nexts[node_idx] != -1);\n#endif\n      for (; bkc_idx < mctx->nbkref_ents; ++bkc_idx)\n\t{\n\t  Idx subexp_len;\n\t  re_dfastate_t *dest_state;\n\t  struct re_backref_cache_entry *bkref_ent;\n\t  bkref_ent = mctx->bkref_ents + bkc_idx;\n\t  if (bkref_ent->node != node_idx || bkref_ent->str_idx != cur_str_idx)\n\t    continue;\n\t  subexp_len = bkref_ent->subexp_to - bkref_ent->subexp_from;\n\t  new_dest_nodes = (subexp_len == 0\n\t\t\t    ? dfa->eclosures + dfa->edests[node_idx].elems[0]\n\t\t\t    : dfa->eclosures + dfa->nexts[node_idx]);\n\t  dest_str_idx = (cur_str_idx + bkref_ent->subexp_to\n\t\t\t  - bkref_ent->subexp_from);\n\t  context = re_string_context_at (&mctx->input, dest_str_idx - 1,\n\t\t\t\t\t  mctx->eflags);\n\t  dest_state = mctx->state_log[dest_str_idx];\n\t  prev_nelem = ((mctx->state_log[cur_str_idx] == NULL) ? 0\n\t\t\t: mctx->state_log[cur_str_idx]->nodes.nelem);\n\t  /* Add 'new_dest_node' to state_log.  */\n\t  if (dest_state == NULL)\n\t    {\n\t      mctx->state_log[dest_str_idx]\n\t\t= re_acquire_state_context (&err, dfa, new_dest_nodes,\n\t\t\t\t\t    context);\n\t      if (BE (mctx->state_log[dest_str_idx] == NULL\n\t\t      && err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  else\n\t    {\n\t      re_node_set dest_nodes;\n\t      err = re_node_set_init_union (&dest_nodes,\n\t\t\t\t\t    dest_state->entrance_nodes,\n\t\t\t\t\t    new_dest_nodes);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\t{\n\t\t  re_node_set_free (&dest_nodes);\n\t\t  goto free_return;\n\t\t}\n\t      mctx->state_log[dest_str_idx]\n\t\t= re_acquire_state_context (&err, dfa, &dest_nodes, context);\n\t      re_node_set_free (&dest_nodes);\n\t      if (BE (mctx->state_log[dest_str_idx] == NULL\n\t\t      && err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  /* We need to check recursively if the backreference can epsilon\n\t     transit.  */\n\t  if (subexp_len == 0\n\t      && mctx->state_log[cur_str_idx]->nodes.nelem > prev_nelem)\n\t    {\n\t      err = check_subexp_matching_top (mctx, new_dest_nodes,\n\t\t\t\t\t       cur_str_idx);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t      err = transit_state_bkref (mctx, new_dest_nodes);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t}\n    }\n  err = REG_NOERROR;\n free_return:\n  return err;\n}",
      "lines": 107,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "get_subexp": {
      "start_point": [
        2695,
        18
      ],
      "end_point": [
        2836,
        1
      ],
      "content": "__attribute_warn_unused_result__\nget_subexp (re_match_context_t *mctx, Idx bkref_node, Idx bkref_str_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx subexp_num, sub_top_idx;\n  const char *buf = (const char *) re_string_get_buffer (&mctx->input);\n  /* Return if we have already checked BKREF_NODE at BKREF_STR_IDX.  */\n  Idx cache_idx = search_cur_bkref_entry (mctx, bkref_str_idx);\n  if (cache_idx != -1)\n    {\n      const struct re_backref_cache_entry *entry\n\t= mctx->bkref_ents + cache_idx;\n      do\n\tif (entry->node == bkref_node)\n\t  return REG_NOERROR; /* We already checked it.  */\n      while (entry++->more);\n    }\n\n  subexp_num = dfa->nodes[bkref_node].opr.idx;\n\n  /* For each sub expression  */\n  for (sub_top_idx = 0; sub_top_idx < mctx->nsub_tops; ++sub_top_idx)\n    {\n      reg_errcode_t err;\n      re_sub_match_top_t *sub_top = mctx->sub_tops[sub_top_idx];\n      re_sub_match_last_t *sub_last;\n      Idx sub_last_idx, sl_str, bkref_str_off;\n\n      if (dfa->nodes[sub_top->node].opr.idx != subexp_num)\n\tcontinue; /* It isn't related.  */\n\n      sl_str = sub_top->str_idx;\n      bkref_str_off = bkref_str_idx;\n      /* At first, check the last node of sub expressions we already\n\t evaluated.  */\n      for (sub_last_idx = 0; sub_last_idx < sub_top->nlasts; ++sub_last_idx)\n\t{\n\t  regoff_t sl_str_diff;\n\t  sub_last = sub_top->lasts[sub_last_idx];\n\t  sl_str_diff = sub_last->str_idx - sl_str;\n\t  /* The matched string by the sub expression match with the substring\n\t     at the back reference?  */\n\t  if (sl_str_diff > 0)\n\t    {\n\t      if (BE (bkref_str_off + sl_str_diff > mctx->input.valid_len, 0))\n\t\t{\n\t\t  /* Not enough chars for a successful match.  */\n\t\t  if (bkref_str_off + sl_str_diff > mctx->input.len)\n\t\t    break;\n\n\t\t  err = clean_state_log_if_needed (mctx,\n\t\t\t\t\t\t   bkref_str_off\n\t\t\t\t\t\t   + sl_str_diff);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    return err;\n\t\t  buf = (const char *) re_string_get_buffer (&mctx->input);\n\t\t}\n\t      if (memcmp (buf + bkref_str_off, buf + sl_str, sl_str_diff) != 0)\n\t\t/* We don't need to search this sub expression any more.  */\n\t\tbreak;\n\t    }\n\t  bkref_str_off += sl_str_diff;\n\t  sl_str += sl_str_diff;\n\t  err = get_subexp_sub (mctx, sub_top, sub_last, bkref_node,\n\t\t\t\tbkref_str_idx);\n\n\t  /* Reload buf, since the preceding call might have reallocated\n\t     the buffer.  */\n\t  buf = (const char *) re_string_get_buffer (&mctx->input);\n\n\t  if (err == REG_NOMATCH)\n\t    continue;\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n\n      if (sub_last_idx < sub_top->nlasts)\n\tcontinue;\n      if (sub_last_idx > 0)\n\t++sl_str;\n      /* Then, search for the other last nodes of the sub expression.  */\n      for (; sl_str <= bkref_str_idx; ++sl_str)\n\t{\n\t  Idx cls_node;\n\t  regoff_t sl_str_off;\n\t  const re_node_set *nodes;\n\t  sl_str_off = sl_str - sub_top->str_idx;\n\t  /* The matched string by the sub expression match with the substring\n\t     at the back reference?  */\n\t  if (sl_str_off > 0)\n\t    {\n\t      if (BE (bkref_str_off >= mctx->input.valid_len, 0))\n\t\t{\n\t\t  /* If we are at the end of the input, we cannot match.  */\n\t\t  if (bkref_str_off >= mctx->input.len)\n\t\t    break;\n\n\t\t  err = extend_buffers (mctx, bkref_str_off + 1);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    return err;\n\n\t\t  buf = (const char *) re_string_get_buffer (&mctx->input);\n\t\t}\n\t      if (buf [bkref_str_off++] != buf[sl_str - 1])\n\t\tbreak; /* We don't need to search this sub expression\n\t\t\t  any more.  */\n\t    }\n\t  if (mctx->state_log[sl_str] == NULL)\n\t    continue;\n\t  /* Does this state have a ')' of the sub expression?  */\n\t  nodes = &mctx->state_log[sl_str]->nodes;\n\t  cls_node = find_subexp_node (dfa, nodes, subexp_num,\n\t\t\t\t       OP_CLOSE_SUBEXP);\n\t  if (cls_node == -1)\n\t    continue; /* No.  */\n\t  if (sub_top->path == NULL)\n\t    {\n\t      sub_top->path = calloc (sizeof (state_array_t),\n\t\t\t\t      sl_str - sub_top->str_idx + 1);\n\t      if (sub_top->path == NULL)\n\t\treturn REG_ESPACE;\n\t    }\n\t  /* Can the OP_OPEN_SUBEXP node arrive the OP_CLOSE_SUBEXP node\n\t     in the current context?  */\n\t  err = check_arrival (mctx, sub_top->path, sub_top->node,\n\t\t\t       sub_top->str_idx, cls_node, sl_str,\n\t\t\t       OP_CLOSE_SUBEXP);\n\t  if (err == REG_NOMATCH)\n\t      continue;\n\t  if (BE (err != REG_NOERROR, 0))\n\t      return err;\n\t  sub_last = match_ctx_add_sublast (sub_top, cls_node, sl_str);\n\t  if (BE (sub_last == NULL, 0))\n\t    return REG_ESPACE;\n\t  err = get_subexp_sub (mctx, sub_top, sub_last, bkref_node,\n\t\t\t\tbkref_str_idx);\n\t  if (err == REG_NOMATCH)\n\t    continue;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 142,
      "depth": 18,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "get_subexp_sub": {
      "start_point": [
        2844,
        0
      ],
      "end_point": [
        2863,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nget_subexp_sub (re_match_context_t *mctx, const re_sub_match_top_t *sub_top,\n\t\tre_sub_match_last_t *sub_last, Idx bkref_node, Idx bkref_str)\n{\n  reg_errcode_t err;\n  Idx to_idx;\n  /* Can the subexpression arrive the back reference?  */\n  err = check_arrival (mctx, &sub_last->path, sub_last->node,\n\t\t       sub_last->str_idx, bkref_node, bkref_str,\n\t\t       OP_OPEN_SUBEXP);\n  if (err != REG_NOERROR)\n    return err;\n  err = match_ctx_add_entry (mctx, bkref_node, bkref_str, sub_top->str_idx,\n\t\t\t     sub_last->str_idx);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n  to_idx = bkref_str + sub_last->str_idx - sub_top->str_idx;\n  return clean_state_log_if_needed (mctx, to_idx);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "find_subexp_node": {
      "start_point": [
        2873,
        0
      ],
      "end_point": [
        2888,
        1
      ],
      "content": "static Idx\ninternal_function\nfind_subexp_node (const re_dfa_t *dfa, const re_node_set *nodes,\n\t\t  Idx subexp_idx, int type)\n{\n  Idx cls_idx;\n  for (cls_idx = 0; cls_idx < nodes->nelem; ++cls_idx)\n    {\n      Idx cls_node = nodes->elems[cls_idx];\n      const re_token_t *node = dfa->nodes + cls_node;\n      if (node->type == type\n\t  && node->opr.idx == subexp_idx)\n\treturn cls_node;\n    }\n  return -1;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "check_arrival": {
      "start_point": [
        2896,
        18
      ],
      "end_point": [
        3050,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncheck_arrival (re_match_context_t *mctx, state_array_t *path, Idx top_node,\n\t       Idx top_str, Idx last_node, Idx last_str, int type)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err = REG_NOERROR;\n  Idx subexp_num, backup_cur_idx, str_idx, null_cnt;\n  re_dfastate_t *cur_state = NULL;\n  re_node_set *cur_nodes, next_nodes;\n  re_dfastate_t **backup_state_log;\n  unsigned int context;\n\n  subexp_num = dfa->nodes[top_node].opr.idx;\n  /* Extend the buffer if we need.  */\n  if (BE (path->alloc < last_str + mctx->max_mb_elem_len + 1, 0))\n    {\n      re_dfastate_t **new_array;\n      Idx old_alloc = path->alloc;\n      Idx incr_alloc = last_str + mctx->max_mb_elem_len + 1;\n      Idx new_alloc;\n      if (BE (IDX_MAX - old_alloc < incr_alloc, 0))\n\treturn REG_ESPACE;\n      new_alloc = old_alloc + incr_alloc;\n      if (BE (SIZE_MAX / sizeof (re_dfastate_t *) < new_alloc, 0))\n\treturn REG_ESPACE;\n      new_array = re_realloc (path->array, re_dfastate_t *, new_alloc);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      path->array = new_array;\n      path->alloc = new_alloc;\n      memset (new_array + old_alloc, '\\0',\n\t      sizeof (re_dfastate_t *) * (path->alloc - old_alloc));\n    }\n\n  str_idx = path->next_idx ? path->next_idx : top_str;\n\n  /* Temporary modify MCTX.  */\n  backup_state_log = mctx->state_log;\n  backup_cur_idx = mctx->input.cur_idx;\n  mctx->state_log = path->array;\n  mctx->input.cur_idx = str_idx;\n\n  /* Setup initial node set.  */\n  context = re_string_context_at (&mctx->input, str_idx - 1, mctx->eflags);\n  if (str_idx == top_str)\n    {\n      err = re_node_set_init_1 (&next_nodes, top_node);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n      err = check_arrival_expand_ecl (dfa, &next_nodes, subexp_num, type);\n      if (BE (err != REG_NOERROR, 0))\n\t{\n\t  re_node_set_free (&next_nodes);\n\t  return err;\n\t}\n    }\n  else\n    {\n      cur_state = mctx->state_log[str_idx];\n      if (cur_state && cur_state->has_backref)\n\t{\n\t  err = re_node_set_init_copy (&next_nodes, &cur_state->nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n      else\n\tre_node_set_init_empty (&next_nodes);\n    }\n  if (str_idx == top_str || (cur_state && cur_state->has_backref))\n    {\n      if (next_nodes.nelem)\n\t{\n\t  err = expand_bkref_cache (mctx, &next_nodes, str_idx,\n\t\t\t\t    subexp_num, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      cur_state = re_acquire_state_context (&err, dfa, &next_nodes, context);\n      if (BE (cur_state == NULL && err != REG_NOERROR, 0))\n\t{\n\t  re_node_set_free (&next_nodes);\n\t  return err;\n\t}\n      mctx->state_log[str_idx] = cur_state;\n    }\n\n  for (null_cnt = 0; str_idx < last_str && null_cnt <= mctx->max_mb_elem_len;)\n    {\n      re_node_set_empty (&next_nodes);\n      if (mctx->state_log[str_idx + 1])\n\t{\n\t  err = re_node_set_merge (&next_nodes,\n\t\t\t\t   &mctx->state_log[str_idx + 1]->nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      if (cur_state)\n\t{\n\t  err = check_arrival_add_next_nodes (mctx, str_idx,\n\t\t\t\t\t      &cur_state->non_eps_nodes,\n\t\t\t\t\t      &next_nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      ++str_idx;\n      if (next_nodes.nelem)\n\t{\n\t  err = check_arrival_expand_ecl (dfa, &next_nodes, subexp_num, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t  err = expand_bkref_cache (mctx, &next_nodes, str_idx,\n\t\t\t\t    subexp_num, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      context = re_string_context_at (&mctx->input, str_idx - 1, mctx->eflags);\n      cur_state = re_acquire_state_context (&err, dfa, &next_nodes, context);\n      if (BE (cur_state == NULL && err != REG_NOERROR, 0))\n\t{\n\t  re_node_set_free (&next_nodes);\n\t  return err;\n\t}\n      mctx->state_log[str_idx] = cur_state;\n      null_cnt = cur_state == NULL ? null_cnt + 1 : 0;\n    }\n  re_node_set_free (&next_nodes);\n  cur_nodes = (mctx->state_log[last_str] == NULL ? NULL\n\t       : &mctx->state_log[last_str]->nodes);\n  path->next_idx = str_idx;\n\n  /* Fix MCTX.  */\n  mctx->state_log = backup_state_log;\n  mctx->input.cur_idx = backup_cur_idx;\n\n  /* Then check the current node set has the node LAST_NODE.  */\n  if (cur_nodes != NULL && re_node_set_contains (cur_nodes, last_node))\n    return REG_NOERROR;\n\n  return REG_NOMATCH;\n}",
      "lines": 155,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "check_arrival_add_next_nodes": {
      "start_point": [
        3061,
        18
      ],
      "end_point": [
        3133,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncheck_arrival_add_next_nodes (re_match_context_t *mctx, Idx str_idx,\n\t\t\t      re_node_set *cur_nodes, re_node_set *next_nodes)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  bool ok;\n  Idx cur_idx;\n#ifdef RE_ENABLE_I18N\n  reg_errcode_t err = REG_NOERROR;\n#endif\n  re_node_set union_set;\n  re_node_set_init_empty (&union_set);\n  for (cur_idx = 0; cur_idx < cur_nodes->nelem; ++cur_idx)\n    {\n      int naccepted = 0;\n      Idx cur_node = cur_nodes->elems[cur_idx];\n#ifdef DEBUG\n      re_token_type_t type = dfa->nodes[cur_node].type;\n      assert (!IS_EPSILON_NODE (type));\n#endif\n#ifdef RE_ENABLE_I18N\n      /* If the node may accept \"multi byte\".  */\n      if (dfa->nodes[cur_node].accept_mb)\n\t{\n\t  naccepted = check_node_accept_bytes (dfa, cur_node, &mctx->input,\n\t\t\t\t\t       str_idx);\n\t  if (naccepted > 1)\n\t    {\n\t      re_dfastate_t *dest_state;\n\t      Idx next_node = dfa->nexts[cur_node];\n\t      Idx next_idx = str_idx + naccepted;\n\t      dest_state = mctx->state_log[next_idx];\n\t      re_node_set_empty (&union_set);\n\t      if (dest_state)\n\t\t{\n\t\t  err = re_node_set_merge (&union_set, &dest_state->nodes);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    {\n\t\t      re_node_set_free (&union_set);\n\t\t      return err;\n\t\t    }\n\t\t}\n\t      ok = re_node_set_insert (&union_set, next_node);\n\t      if (BE (! ok, 0))\n\t\t{\n\t\t  re_node_set_free (&union_set);\n\t\t  return REG_ESPACE;\n\t\t}\n\t      mctx->state_log[next_idx] = re_acquire_state (&err, dfa,\n\t\t\t\t\t\t\t    &union_set);\n\t      if (BE (mctx->state_log[next_idx] == NULL\n\t\t      && err != REG_NOERROR, 0))\n\t\t{\n\t\t  re_node_set_free (&union_set);\n\t\t  return err;\n\t\t}\n\t    }\n\t}\n#endif /* RE_ENABLE_I18N */\n      if (naccepted\n\t  || check_node_accept (mctx, dfa->nodes + cur_node, str_idx))\n\t{\n\t  ok = re_node_set_insert (next_nodes, dfa->nexts[cur_node]);\n\t  if (BE (! ok, 0))\n\t    {\n\t      re_node_set_free (&union_set);\n\t      return REG_ESPACE;\n\t    }\n\t}\n    }\n  re_node_set_free (&union_set);\n  return REG_NOERROR;\n}",
      "lines": 73,
      "depth": 18,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "check_arrival_expand_ecl": {
      "start_point": [
        3141,
        0
      ],
      "end_point": [
        3188,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ncheck_arrival_expand_ecl (const re_dfa_t *dfa, re_node_set *cur_nodes,\n\t\t\t  Idx ex_subexp, int type)\n{\n  reg_errcode_t err;\n  Idx idx, outside_node;\n  re_node_set new_nodes;\n#ifdef DEBUG\n  assert (cur_nodes->nelem);\n#endif\n  err = re_node_set_alloc (&new_nodes, cur_nodes->nelem);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n  /* Create a new node set NEW_NODES with the nodes which are epsilon\n     closures of the node in CUR_NODES.  */\n\n  for (idx = 0; idx < cur_nodes->nelem; ++idx)\n    {\n      Idx cur_node = cur_nodes->elems[idx];\n      const re_node_set *eclosure = dfa->eclosures + cur_node;\n      outside_node = find_subexp_node (dfa, eclosure, ex_subexp, type);\n      if (outside_node == -1)\n\t{\n\t  /* There are no problematic nodes, just merge them.  */\n\t  err = re_node_set_merge (&new_nodes, eclosure);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&new_nodes);\n\t      return err;\n\t    }\n\t}\n      else\n\t{\n\t  /* There are problematic nodes, re-calculate incrementally.  */\n\t  err = check_arrival_expand_ecl_sub (dfa, &new_nodes, cur_node,\n\t\t\t\t\t      ex_subexp, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&new_nodes);\n\t      return err;\n\t    }\n\t}\n    }\n  re_node_set_free (cur_nodes);\n  *cur_nodes = new_nodes;\n  return REG_NOERROR;\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "check_arrival_expand_ecl_sub": {
      "start_point": [
        3195,
        18
      ],
      "end_point": [
        3232,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncheck_arrival_expand_ecl_sub (const re_dfa_t *dfa, re_node_set *dst_nodes,\n\t\t\t      Idx target, Idx ex_subexp, int type)\n{\n  Idx cur_node;\n  for (cur_node = target; !re_node_set_contains (dst_nodes, cur_node);)\n    {\n      bool ok;\n\n      if (dfa->nodes[cur_node].type == type\n\t  && dfa->nodes[cur_node].opr.idx == ex_subexp)\n\t{\n\t  if (type == OP_CLOSE_SUBEXP)\n\t    {\n\t      ok = re_node_set_insert (dst_nodes, cur_node);\n\t      if (BE (! ok, 0))\n\t\treturn REG_ESPACE;\n\t    }\n\t  break;\n\t}\n      ok = re_node_set_insert (dst_nodes, cur_node);\n      if (BE (! ok, 0))\n\treturn REG_ESPACE;\n      if (dfa->edests[cur_node].nelem == 0)\n\tbreak;\n      if (dfa->edests[cur_node].nelem == 2)\n\t{\n\t  reg_errcode_t err;\n\t  err = check_arrival_expand_ecl_sub (dfa, dst_nodes,\n\t\t\t\t\t      dfa->edests[cur_node].elems[1],\n\t\t\t\t\t      ex_subexp, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n      cur_node = dfa->edests[cur_node].elems[0];\n    }\n  return REG_NOERROR;\n}",
      "lines": 38,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "expand_bkref_cache": {
      "start_point": [
        3240,
        18
      ],
      "end_point": [
        3323,
        1
      ],
      "content": "__attribute_warn_unused_result__\nexpand_bkref_cache (re_match_context_t *mctx, re_node_set *cur_nodes,\n\t\t    Idx cur_str, Idx subexp_num, int type)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx cache_idx_start = search_cur_bkref_entry (mctx, cur_str);\n  struct re_backref_cache_entry *ent;\n\n  if (cache_idx_start == -1)\n    return REG_NOERROR;\n\n restart:\n  ent = mctx->bkref_ents + cache_idx_start;\n  do\n    {\n      Idx to_idx, next_node;\n\n      /* Is this entry ENT is appropriate?  */\n      if (!re_node_set_contains (cur_nodes, ent->node))\n\tcontinue; /* No.  */\n\n      to_idx = cur_str + ent->subexp_to - ent->subexp_from;\n      /* Calculate the destination of the back reference, and append it\n\t to MCTX->STATE_LOG.  */\n      if (to_idx == cur_str)\n\t{\n\t  /* The backreference did epsilon transit, we must re-check all the\n\t     node in the current state.  */\n\t  re_node_set new_dests;\n\t  reg_errcode_t err2, err3;\n\t  next_node = dfa->edests[ent->node].elems[0];\n\t  if (re_node_set_contains (cur_nodes, next_node))\n\t    continue;\n\t  err = re_node_set_init_1 (&new_dests, next_node);\n\t  err2 = check_arrival_expand_ecl (dfa, &new_dests, subexp_num, type);\n\t  err3 = re_node_set_merge (cur_nodes, &new_dests);\n\t  re_node_set_free (&new_dests);\n\t  if (BE (err != REG_NOERROR || err2 != REG_NOERROR\n\t\t  || err3 != REG_NOERROR, 0))\n\t    {\n\t      err = (err != REG_NOERROR ? err\n\t\t     : (err2 != REG_NOERROR ? err2 : err3));\n\t      return err;\n\t    }\n\t  /* TODO: It is still inefficient...  */\n\t  goto restart;\n\t}\n      else\n\t{\n\t  re_node_set union_set;\n\t  next_node = dfa->nexts[ent->node];\n\t  if (mctx->state_log[to_idx])\n\t    {\n\t      bool ok;\n\t      if (re_node_set_contains (&mctx->state_log[to_idx]->nodes,\n\t\t\t\t\tnext_node))\n\t\tcontinue;\n\t      err = re_node_set_init_copy (&union_set,\n\t\t\t\t\t   &mctx->state_log[to_idx]->nodes);\n\t      ok = re_node_set_insert (&union_set, next_node);\n\t      if (BE (err != REG_NOERROR || ! ok, 0))\n\t\t{\n\t\t  re_node_set_free (&union_set);\n\t\t  err = err != REG_NOERROR ? err : REG_ESPACE;\n\t\t  return err;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      err = re_node_set_init_1 (&union_set, next_node);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t  mctx->state_log[to_idx] = re_acquire_state (&err, dfa, &union_set);\n\t  re_node_set_free (&union_set);\n\t  if (BE (mctx->state_log[to_idx] == NULL\n\t\t  && err != REG_NOERROR, 0))\n\t    return err;\n\t}\n    }\n  while (ent++->more);\n  return REG_NOERROR;\n}",
      "lines": 84,
      "depth": 17,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "build_trtable": {
      "start_point": [
        3328,
        0
      ],
      "end_point": [
        3559,
        1
      ],
      "content": "static bool\ninternal_function\nbuild_trtable (const re_dfa_t *dfa, re_dfastate_t *state)\n{\n  reg_errcode_t err;\n  Idx i, j;\n  int ch;\n  bool need_word_trtable = false;\n  bitset_word_t elem, mask;\n  bool dests_node_malloced = false;\n  bool dest_states_malloced = false;\n  Idx ndests; /* Number of the destination states from 'state'.  */\n  re_dfastate_t **trtable;\n  re_dfastate_t **dest_states = NULL, **dest_states_word, **dest_states_nl;\n  re_node_set follows, *dests_node;\n  bitset_t *dests_ch;\n  bitset_t acceptable;\n\n  struct dests_alloc\n  {\n    re_node_set dests_node[SBC_MAX];\n    bitset_t dests_ch[SBC_MAX];\n  } *dests_alloc;\n\n  /* We build DFA states which corresponds to the destination nodes\n     from 'state'.  'dests_node[i]' represents the nodes which i-th\n     destination state contains, and 'dests_ch[i]' represents the\n     characters which i-th destination state accepts.  */\n  if (__libc_use_alloca (sizeof (struct dests_alloc)))\n    dests_alloc = (struct dests_alloc *) alloca (sizeof (struct dests_alloc));\n  else\n    {\n      dests_alloc = re_malloc (struct dests_alloc, 1);\n      if (BE (dests_alloc == NULL, 0))\n\treturn false;\n      dests_node_malloced = true;\n    }\n  dests_node = dests_alloc->dests_node;\n  dests_ch = dests_alloc->dests_ch;\n\n  /* Initialize transition table.  */\n  state->word_trtable = state->trtable = NULL;\n\n  /* At first, group all nodes belonging to 'state' into several\n     destinations.  */\n  ndests = group_nodes_into_DFAstates (dfa, state, dests_node, dests_ch);\n  if (BE (ndests <= 0, 0))\n    {\n      if (dests_node_malloced)\n\tfree (dests_alloc);\n      /* Return false in case of an error, true otherwise.  */\n      if (ndests == 0)\n\t{\n\t  state->trtable = (re_dfastate_t **)\n\t    calloc (sizeof (re_dfastate_t *), SBC_MAX);\n          if (BE (state->trtable == NULL, 0))\n            return false;\n\t  return true;\n\t}\n      return false;\n    }\n\n  err = re_node_set_alloc (&follows, ndests + 1);\n  if (BE (err != REG_NOERROR, 0))\n    goto out_free;\n\n  /* Avoid arithmetic overflow in size calculation.  */\n  if (BE ((((SIZE_MAX - (sizeof (re_node_set) + sizeof (bitset_t)) * SBC_MAX)\n\t    / (3 * sizeof (re_dfastate_t *)))\n\t   < ndests),\n\t  0))\n    goto out_free;\n\n  if (__libc_use_alloca ((sizeof (re_node_set) + sizeof (bitset_t)) * SBC_MAX\n\t\t\t + ndests * 3 * sizeof (re_dfastate_t *)))\n    dest_states = (re_dfastate_t **)\n      alloca (ndests * 3 * sizeof (re_dfastate_t *));\n  else\n    {\n      dest_states = (re_dfastate_t **)\n\tmalloc (ndests * 3 * sizeof (re_dfastate_t *));\n      if (BE (dest_states == NULL, 0))\n\t{\nout_free:\n\t  if (dest_states_malloced)\n\t    free (dest_states);\n\t  re_node_set_free (&follows);\n\t  for (i = 0; i < ndests; ++i)\n\t    re_node_set_free (dests_node + i);\n\t  if (dests_node_malloced)\n\t    free (dests_alloc);\n\t  return false;\n\t}\n      dest_states_malloced = true;\n    }\n  dest_states_word = dest_states + ndests;\n  dest_states_nl = dest_states_word + ndests;\n  bitset_empty (acceptable);\n\n  /* Then build the states for all destinations.  */\n  for (i = 0; i < ndests; ++i)\n    {\n      Idx next_node;\n      re_node_set_empty (&follows);\n      /* Merge the follows of this destination states.  */\n      for (j = 0; j < dests_node[i].nelem; ++j)\n\t{\n\t  next_node = dfa->nexts[dests_node[i].elems[j]];\n\t  if (next_node != -1)\n\t    {\n\t      err = re_node_set_merge (&follows, dfa->eclosures + next_node);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto out_free;\n\t    }\n\t}\n      dest_states[i] = re_acquire_state_context (&err, dfa, &follows, 0);\n      if (BE (dest_states[i] == NULL && err != REG_NOERROR, 0))\n\tgoto out_free;\n      /* If the new state has context constraint,\n\t build appropriate states for these contexts.  */\n      if (dest_states[i]->has_constraint)\n\t{\n\t  dest_states_word[i] = re_acquire_state_context (&err, dfa, &follows,\n\t\t\t\t\t\t\t  CONTEXT_WORD);\n\t  if (BE (dest_states_word[i] == NULL && err != REG_NOERROR, 0))\n\t    goto out_free;\n\n\t  if (dest_states[i] != dest_states_word[i] && dfa->mb_cur_max > 1)\n\t    need_word_trtable = true;\n\n\t  dest_states_nl[i] = re_acquire_state_context (&err, dfa, &follows,\n\t\t\t\t\t\t\tCONTEXT_NEWLINE);\n\t  if (BE (dest_states_nl[i] == NULL && err != REG_NOERROR, 0))\n\t    goto out_free;\n\t}\n      else\n\t{\n\t  dest_states_word[i] = dest_states[i];\n\t  dest_states_nl[i] = dest_states[i];\n\t}\n      bitset_merge (acceptable, dests_ch[i]);\n    }\n\n  if (!BE (need_word_trtable, 0))\n    {\n      /* We don't care about whether the following character is a word\n\t character, or we are in a single-byte character set so we can\n\t discern by looking at the character code: allocate a\n\t 256-entry transition table.  */\n      trtable = state->trtable =\n\t(re_dfastate_t **) calloc (sizeof (re_dfastate_t *), SBC_MAX);\n      if (BE (trtable == NULL, 0))\n\tgoto out_free;\n\n      /* For all characters ch...:  */\n      for (i = 0; i < BITSET_WORDS; ++i)\n\tfor (ch = i * BITSET_WORD_BITS, elem = acceptable[i], mask = 1;\n\t     elem;\n\t     mask <<= 1, elem >>= 1, ++ch)\n\t  if (BE (elem & 1, 0))\n\t    {\n\t      /* There must be exactly one destination which accepts\n\t\t character ch.  See group_nodes_into_DFAstates.  */\n\t      for (j = 0; (dests_ch[j][i] & mask) == 0; ++j)\n\t\t;\n\n\t      /* j-th destination accepts the word character ch.  */\n\t      if (dfa->word_char[i] & mask)\n\t\ttrtable[ch] = dest_states_word[j];\n\t      else\n\t\ttrtable[ch] = dest_states[j];\n\t    }\n    }\n  else\n    {\n      /* We care about whether the following character is a word\n\t character, and we are in a multi-byte character set: discern\n\t by looking at the character code: build two 256-entry\n\t transition tables, one starting at trtable[0] and one\n\t starting at trtable[SBC_MAX].  */\n      trtable = state->word_trtable =\n\t(re_dfastate_t **) calloc (sizeof (re_dfastate_t *), 2 * SBC_MAX);\n      if (BE (trtable == NULL, 0))\n\tgoto out_free;\n\n      /* For all characters ch...:  */\n      for (i = 0; i < BITSET_WORDS; ++i)\n\tfor (ch = i * BITSET_WORD_BITS, elem = acceptable[i], mask = 1;\n\t     elem;\n\t     mask <<= 1, elem >>= 1, ++ch)\n\t  if (BE (elem & 1, 0))\n\t    {\n\t      /* There must be exactly one destination which accepts\n\t\t character ch.  See group_nodes_into_DFAstates.  */\n\t      for (j = 0; (dests_ch[j][i] & mask) == 0; ++j)\n\t\t;\n\n\t      /* j-th destination accepts the word character ch.  */\n\t      trtable[ch] = dest_states[j];\n\t      trtable[ch + SBC_MAX] = dest_states_word[j];\n\t    }\n    }\n\n  /* new line */\n  if (bitset_contain (acceptable, NEWLINE_CHAR))\n    {\n      /* The current state accepts newline character.  */\n      for (j = 0; j < ndests; ++j)\n\tif (bitset_contain (dests_ch[j], NEWLINE_CHAR))\n\t  {\n\t    /* k-th destination accepts newline character.  */\n\t    trtable[NEWLINE_CHAR] = dest_states_nl[j];\n\t    if (need_word_trtable)\n\t      trtable[NEWLINE_CHAR + SBC_MAX] = dest_states_nl[j];\n\t    /* There must be only one destination which accepts\n\t       newline.  See group_nodes_into_DFAstates.  */\n\t    break;\n\t  }\n    }\n\n  if (dest_states_malloced)\n    free (dest_states);\n\n  re_node_set_free (&follows);\n  for (i = 0; i < ndests; ++i)\n    re_node_set_free (dests_node + i);\n\n  if (dests_node_malloced)\n    free (dests_alloc);\n\n  return true;\n}",
      "lines": 232,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "bool",
        "internal_function",
        "internal_function"
      ]
    },
    "group_nodes_into_DFAstates": {
      "start_point": [
        3566,
        0
      ],
      "end_point": [
        3748,
        1
      ],
      "content": "static Idx\ninternal_function\ngroup_nodes_into_DFAstates (const re_dfa_t *dfa, const re_dfastate_t *state,\n\t\t\t    re_node_set *dests_node, bitset_t *dests_ch)\n{\n  reg_errcode_t err;\n  bool ok;\n  Idx i, j, k;\n  Idx ndests; /* Number of the destinations from 'state'.  */\n  bitset_t accepts; /* Characters a node can accept.  */\n  const re_node_set *cur_nodes = &state->nodes;\n  bitset_empty (accepts);\n  ndests = 0;\n\n  /* For all the nodes belonging to 'state',  */\n  for (i = 0; i < cur_nodes->nelem; ++i)\n    {\n      re_token_t *node = &dfa->nodes[cur_nodes->elems[i]];\n      re_token_type_t type = node->type;\n      unsigned int constraint = node->constraint;\n\n      /* Enumerate all single byte character this node can accept.  */\n      if (type == CHARACTER)\n\tbitset_set (accepts, node->opr.c);\n      else if (type == SIMPLE_BRACKET)\n\t{\n\t  bitset_merge (accepts, node->opr.sbcset);\n\t}\n      else if (type == OP_PERIOD)\n\t{\n#ifdef RE_ENABLE_I18N\n\t  if (dfa->mb_cur_max > 1)\n\t    bitset_merge (accepts, dfa->sb_char);\n\t  else\n#endif\n\t    bitset_set_all (accepts);\n\t  if (!(dfa->syntax & RE_DOT_NEWLINE))\n\t    bitset_clear (accepts, '\\n');\n\t  if (dfa->syntax & RE_DOT_NOT_NULL)\n\t    bitset_clear (accepts, '\\0');\n\t}\n#ifdef RE_ENABLE_I18N\n      else if (type == OP_UTF8_PERIOD)\n\t{\n\t  if (ASCII_CHARS % BITSET_WORD_BITS == 0)\n\t    memset (accepts, -1, ASCII_CHARS / CHAR_BIT);\n\t  else\n\t    bitset_merge (accepts, utf8_sb_map);\n\t  if (!(dfa->syntax & RE_DOT_NEWLINE))\n\t    bitset_clear (accepts, '\\n');\n\t  if (dfa->syntax & RE_DOT_NOT_NULL)\n\t    bitset_clear (accepts, '\\0');\n\t}\n#endif\n      else\n\tcontinue;\n\n      /* Check the 'accepts' and sift the characters which are not\n\t match it the context.  */\n      if (constraint)\n\t{\n\t  if (constraint & NEXT_NEWLINE_CONSTRAINT)\n\t    {\n\t      bool accepts_newline = bitset_contain (accepts, NEWLINE_CHAR);\n\t      bitset_empty (accepts);\n\t      if (accepts_newline)\n\t\tbitset_set (accepts, NEWLINE_CHAR);\n\t      else\n\t\tcontinue;\n\t    }\n\t  if (constraint & NEXT_ENDBUF_CONSTRAINT)\n\t    {\n\t      bitset_empty (accepts);\n\t      continue;\n\t    }\n\n\t  if (constraint & NEXT_WORD_CONSTRAINT)\n\t    {\n\t      bitset_word_t any_set = 0;\n\t      if (type == CHARACTER && !node->word_char)\n\t\t{\n\t\t  bitset_empty (accepts);\n\t\t  continue;\n\t\t}\n#ifdef RE_ENABLE_I18N\n\t      if (dfa->mb_cur_max > 1)\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= (dfa->word_char[j] | ~dfa->sb_char[j]));\n\t      else\n#endif\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= dfa->word_char[j]);\n\t      if (!any_set)\n\t\tcontinue;\n\t    }\n\t  if (constraint & NEXT_NOTWORD_CONSTRAINT)\n\t    {\n\t      bitset_word_t any_set = 0;\n\t      if (type == CHARACTER && node->word_char)\n\t\t{\n\t\t  bitset_empty (accepts);\n\t\t  continue;\n\t\t}\n#ifdef RE_ENABLE_I18N\n\t      if (dfa->mb_cur_max > 1)\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= ~(dfa->word_char[j] & dfa->sb_char[j]));\n\t      else\n#endif\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= ~dfa->word_char[j]);\n\t      if (!any_set)\n\t\tcontinue;\n\t    }\n\t}\n\n      /* Then divide 'accepts' into DFA states, or create a new\n\t state.  Above, we make sure that accepts is not empty.  */\n      for (j = 0; j < ndests; ++j)\n\t{\n\t  bitset_t intersec; /* Intersection sets, see below.  */\n\t  bitset_t remains;\n\t  /* Flags, see below.  */\n\t  bitset_word_t has_intersec, not_subset, not_consumed;\n\n\t  /* Optimization, skip if this state doesn't accept the character.  */\n\t  if (type == CHARACTER && !bitset_contain (dests_ch[j], node->opr.c))\n\t    continue;\n\n\t  /* Enumerate the intersection set of this state and 'accepts'.  */\n\t  has_intersec = 0;\n\t  for (k = 0; k < BITSET_WORDS; ++k)\n\t    has_intersec |= intersec[k] = accepts[k] & dests_ch[j][k];\n\t  /* And skip if the intersection set is empty.  */\n\t  if (!has_intersec)\n\t    continue;\n\n\t  /* Then check if this state is a subset of 'accepts'.  */\n\t  not_subset = not_consumed = 0;\n\t  for (k = 0; k < BITSET_WORDS; ++k)\n\t    {\n\t      not_subset |= remains[k] = ~accepts[k] & dests_ch[j][k];\n\t      not_consumed |= accepts[k] = accepts[k] & ~dests_ch[j][k];\n\t    }\n\n\t  /* If this state isn't a subset of 'accepts', create a\n\t     new group state, which has the 'remains'. */\n\t  if (not_subset)\n\t    {\n\t      bitset_copy (dests_ch[ndests], remains);\n\t      bitset_copy (dests_ch[j], intersec);\n\t      err = re_node_set_init_copy (dests_node + ndests, &dests_node[j]);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto error_return;\n\t      ++ndests;\n\t    }\n\n\t  /* Put the position in the current group. */\n\t  ok = re_node_set_insert (&dests_node[j], cur_nodes->elems[i]);\n\t  if (BE (! ok, 0))\n\t    goto error_return;\n\n\t  /* If all characters are consumed, go to next node. */\n\t  if (!not_consumed)\n\t    break;\n\t}\n      /* Some characters remain, create a new group. */\n      if (j == ndests)\n\t{\n\t  bitset_copy (dests_ch[ndests], accepts);\n\t  err = re_node_set_init_1 (dests_node + ndests, cur_nodes->elems[i]);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto error_return;\n\t  ++ndests;\n\t  bitset_empty (accepts);\n\t}\n    }\n  return ndests;\n error_return:\n  for (j = 0; j < ndests; ++j)\n    re_node_set_free (dests_node + j);\n  return -1;\n}",
      "lines": 183,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "check_node_accept_bytes": {
      "start_point": [
        3763,
        0
      ],
      "end_point": [
        3990,
        1
      ],
      "content": "static int\ninternal_function\ncheck_node_accept_bytes (const re_dfa_t *dfa, Idx node_idx,\n\t\t\t const re_string_t *input, Idx str_idx)\n{\n  const re_token_t *node = dfa->nodes + node_idx;\n  int char_len, elem_len;\n  Idx i;\n\n  if (BE (node->type == OP_UTF8_PERIOD, 0))\n    {\n      unsigned char c = re_string_byte_at (input, str_idx), d;\n      if (BE (c < 0xc2, 1))\n\treturn 0;\n\n      if (str_idx + 2 > input->len)\n\treturn 0;\n\n      d = re_string_byte_at (input, str_idx + 1);\n      if (c < 0xe0)\n\treturn (d < 0x80 || d > 0xbf) ? 0 : 2;\n      else if (c < 0xf0)\n\t{\n\t  char_len = 3;\n\t  if (c == 0xe0 && d < 0xa0)\n\t    return 0;\n\t}\n      else if (c < 0xf8)\n\t{\n\t  char_len = 4;\n\t  if (c == 0xf0 && d < 0x90)\n\t    return 0;\n\t}\n      else if (c < 0xfc)\n\t{\n\t  char_len = 5;\n\t  if (c == 0xf8 && d < 0x88)\n\t    return 0;\n\t}\n      else if (c < 0xfe)\n\t{\n\t  char_len = 6;\n\t  if (c == 0xfc && d < 0x84)\n\t    return 0;\n\t}\n      else\n\treturn 0;\n\n      if (str_idx + char_len > input->len)\n\treturn 0;\n\n      for (i = 1; i < char_len; ++i)\n\t{\n\t  d = re_string_byte_at (input, str_idx + i);\n\t  if (d < 0x80 || d > 0xbf)\n\t    return 0;\n\t}\n      return char_len;\n    }\n\n  char_len = re_string_char_size_at (input, str_idx);\n  if (node->type == OP_PERIOD)\n    {\n      if (char_len <= 1)\n\treturn 0;\n      /* FIXME: I don't think this if is needed, as both '\\n'\n\t and '\\0' are char_len == 1.  */\n      /* '.' accepts any one character except the following two cases.  */\n      if ((!(dfa->syntax & RE_DOT_NEWLINE) &&\n\t   re_string_byte_at (input, str_idx) == '\\n') ||\n\t  ((dfa->syntax & RE_DOT_NOT_NULL) &&\n\t   re_string_byte_at (input, str_idx) == '\\0'))\n\treturn 0;\n      return char_len;\n    }\n\n  elem_len = re_string_elem_size_at (input, str_idx);\n  if ((elem_len <= 1 && char_len <= 1) || char_len == 0)\n    return 0;\n\n  if (node->type == COMPLEX_BRACKET)\n    {\n      const re_charset_t *cset = node->opr.mbcset;\n# ifdef _LIBC\n      const unsigned char *pin\n\t= ((const unsigned char *) re_string_get_buffer (input) + str_idx);\n      Idx j;\n      uint32_t nrules;\n# endif /* _LIBC */\n      int match_len = 0;\n      wchar_t wc = ((cset->nranges || cset->nchar_classes || cset->nmbchars)\n\t\t    ? re_string_wchar_at (input, str_idx) : 0);\n\n      /* match with multibyte character?  */\n      for (i = 0; i < cset->nmbchars; ++i)\n\tif (wc == cset->mbchars[i])\n\t  {\n\t    match_len = char_len;\n\t    goto check_node_accept_bytes_match;\n\t  }\n      /* match with character_class?  */\n      for (i = 0; i < cset->nchar_classes; ++i)\n\t{\n\t  wctype_t wt = cset->char_classes[i];\n\t  if (__iswctype (wc, wt))\n\t    {\n\t      match_len = char_len;\n\t      goto check_node_accept_bytes_match;\n\t    }\n\t}\n\n# ifdef _LIBC\n      nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n      if (nrules != 0)\n\t{\n\t  unsigned int in_collseq = 0;\n\t  const int32_t *table, *indirect;\n\t  const unsigned char *weights, *extra;\n\t  const char *collseqwc;\n\n\t  /* match with collating_symbol?  */\n\t  if (cset->ncoll_syms)\n\t    extra = (const unsigned char *)\n\t      _NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB);\n\t  for (i = 0; i < cset->ncoll_syms; ++i)\n\t    {\n\t      const unsigned char *coll_sym = extra + cset->coll_syms[i];\n\t      /* Compare the length of input collating element and\n\t\t the length of current collating element.  */\n\t      if (*coll_sym != elem_len)\n\t\tcontinue;\n\t      /* Compare each bytes.  */\n\t      for (j = 0; j < *coll_sym; j++)\n\t\tif (pin[j] != coll_sym[1 + j])\n\t\t  break;\n\t      if (j == *coll_sym)\n\t\t{\n\t\t  /* Match if every bytes is equal.  */\n\t\t  match_len = j;\n\t\t  goto check_node_accept_bytes_match;\n\t\t}\n\t    }\n\n\t  if (cset->nranges)\n\t    {\n\t      if (elem_len <= char_len)\n\t\t{\n\t\t  collseqwc = _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQWC);\n\t\t  in_collseq = __collseq_table_lookup (collseqwc, wc);\n\t\t}\n\t      else\n\t\tin_collseq = find_collation_sequence_value (pin, elem_len);\n\t    }\n\t  /* match with range expression?  */\n\t  /* FIXME: Implement rational ranges here, too.  */\n\t  for (i = 0; i < cset->nranges; ++i)\n\t    if (cset->range_starts[i] <= in_collseq\n\t\t&& in_collseq <= cset->range_ends[i])\n\t      {\n\t\tmatch_len = elem_len;\n\t\tgoto check_node_accept_bytes_match;\n\t      }\n\n\t  /* match with equivalence_class?  */\n\t  if (cset->nequiv_classes)\n\t    {\n\t      const unsigned char *cp = pin;\n\t      table = (const int32_t *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n\t      weights = (const unsigned char *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_WEIGHTMB);\n\t      extra = (const unsigned char *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAMB);\n\t      indirect = (const int32_t *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_INDIRECTMB);\n\t      int32_t idx = findidx (table, indirect, extra, &cp, elem_len);\n\t      if (idx > 0)\n\t\tfor (i = 0; i < cset->nequiv_classes; ++i)\n\t\t  {\n\t\t    int32_t equiv_class_idx = cset->equiv_classes[i];\n\t\t    size_t weight_len = weights[idx & 0xffffff];\n\t\t    if (weight_len == weights[equiv_class_idx & 0xffffff]\n\t\t\t&& (idx >> 24) == (equiv_class_idx >> 24))\n\t\t      {\n\t\t\tIdx cnt = 0;\n\n\t\t\tidx &= 0xffffff;\n\t\t\tequiv_class_idx &= 0xffffff;\n\n\t\t\twhile (cnt <= weight_len\n\t\t\t       && (weights[equiv_class_idx + 1 + cnt]\n\t\t\t\t   == weights[idx + 1 + cnt]))\n\t\t\t  ++cnt;\n\t\t\tif (cnt > weight_len)\n\t\t\t  {\n\t\t\t    match_len = elem_len;\n\t\t\t    goto check_node_accept_bytes_match;\n\t\t\t  }\n\t\t      }\n\t\t  }\n\t    }\n\t}\n      else\n# endif /* _LIBC */\n\t{\n\t  /* match with range expression?  */\n\t  for (i = 0; i < cset->nranges; ++i)\n\t    {\n\t      if (cset->range_starts[i] <= wc && wc <= cset->range_ends[i])\n\t\t{\n\t\t  match_len = char_len;\n\t\t  goto check_node_accept_bytes_match;\n\t\t}\n\t    }\n\t}\n    check_node_accept_bytes_match:\n      if (!cset->non_match)\n\treturn match_len;\n      else\n\t{\n\t  if (match_len > 0)\n\t    return 0;\n\t  else\n\t    return (elem_len > char_len) ? elem_len : char_len;\n\t}\n    }\n  return 0;\n}",
      "lines": 228,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "find_collation_sequence_value": {
      "start_point": [
        3993,
        0
      ],
      "end_point": [
        4050,
        1
      ],
      "content": "static unsigned int\ninternal_function\nfind_collation_sequence_value (const unsigned char *mbs, size_t mbs_len)\n{\n  uint32_t nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n  if (nrules == 0)\n    {\n      if (mbs_len == 1)\n\t{\n\t  /* No valid character.  Match it as a single byte character.  */\n\t  const unsigned char *collseq = (const unsigned char *)\n\t    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQMB);\n\t  return collseq[mbs[0]];\n\t}\n      return UINT_MAX;\n    }\n  else\n    {\n      int32_t idx;\n      const unsigned char *extra = (const unsigned char *)\n\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB);\n      int32_t extrasize = (const unsigned char *)\n\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB + 1) - extra;\n\n      for (idx = 0; idx < extrasize;)\n\t{\n\t  int mbs_cnt;\n\t  bool found = false;\n\t  int32_t elem_mbs_len;\n\t  /* Skip the name of collating element name.  */\n\t  idx = idx + extra[idx] + 1;\n\t  elem_mbs_len = extra[idx++];\n\t  if (mbs_len == elem_mbs_len)\n\t    {\n\t      for (mbs_cnt = 0; mbs_cnt < elem_mbs_len; ++mbs_cnt)\n\t\tif (extra[idx + mbs_cnt] != mbs[mbs_cnt])\n\t\t  break;\n\t      if (mbs_cnt == elem_mbs_len)\n\t\t/* Found the entry.  */\n\t\tfound = true;\n\t    }\n\t  /* Skip the byte sequence of the collating element.  */\n\t  idx += elem_mbs_len;\n\t  /* Adjust for the alignment.  */\n\t  idx = (idx + 3) & ~3;\n\t  /* Skip the collation sequence value.  */\n\t  idx += sizeof (uint32_t);\n\t  /* Skip the wide char sequence of the collating element.  */\n\t  idx = idx + sizeof (uint32_t) * (*(int32_t *) (extra + idx) + 1);\n\t  /* If we found the entry, return the sequence value.  */\n\t  if (found)\n\t    return *(uint32_t *) (extra + idx);\n\t  /* Skip the collation sequence value.  */\n\t  idx += sizeof (uint32_t);\n\t}\n      return UINT_MAX;\n    }\n}",
      "lines": 58,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "check_node_accept": {
      "start_point": [
        4057,
        0
      ],
      "end_point": [
        4103,
        1
      ],
      "content": "static bool\ninternal_function\ncheck_node_accept (const re_match_context_t *mctx, const re_token_t *node,\n\t\t   Idx idx)\n{\n  unsigned char ch;\n  ch = re_string_byte_at (&mctx->input, idx);\n  switch (node->type)\n    {\n    case CHARACTER:\n      if (node->opr.c != ch)\n        return false;\n      break;\n\n    case SIMPLE_BRACKET:\n      if (!bitset_contain (node->opr.sbcset, ch))\n        return false;\n      break;\n\n#ifdef RE_ENABLE_I18N\n    case OP_UTF8_PERIOD:\n      if (ch >= ASCII_CHARS)\n        return false;\n      /* FALLTHROUGH */\n#endif\n    case OP_PERIOD:\n      if ((ch == '\\n' && !(mctx->dfa->syntax & RE_DOT_NEWLINE))\n\t  || (ch == '\\0' && (mctx->dfa->syntax & RE_DOT_NOT_NULL)))\n\treturn false;\n      break;\n\n    default:\n      return false;\n    }\n\n  if (node->constraint)\n    {\n      /* The node has constraints.  Check whether the current context\n\t satisfies the constraints.  */\n      unsigned int context = re_string_context_at (&mctx->input, idx,\n\t\t\t\t\t\t   mctx->eflags);\n      if (NOT_SATISFY_NEXT_CONSTRAINT (node->constraint, context))\n\treturn false;\n    }\n\n  return true;\n}",
      "lines": 47,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bool",
        "internal_function",
        "internal_function"
      ]
    },
    "extend_buffers": {
      "start_point": [
        4108,
        18
      ],
      "end_point": [
        4166,
        1
      ],
      "content": "__attribute_warn_unused_result__\nextend_buffers (re_match_context_t *mctx, int min_len)\n{\n  reg_errcode_t ret;\n  re_string_t *pstr = &mctx->input;\n\n  /* Avoid overflow.  */\n  if (BE (MIN (IDX_MAX, SIZE_MAX / sizeof (re_dfastate_t *)) / 2\n          <= pstr->bufs_len, 0))\n    return REG_ESPACE;\n\n  /* Double the lengths of the buffers, but allocate at least MIN_LEN.  */\n  ret = re_string_realloc_buffers (pstr,\n\t\t\t\t   MAX (min_len,\n\t\t\t\t\tMIN (pstr->len, pstr->bufs_len * 2)));\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n\n  if (mctx->state_log != NULL)\n    {\n      /* And double the length of state_log.  */\n      /* XXX We have no indication of the size of this buffer.  If this\n\t allocation fail we have no indication that the state_log array\n\t does not have the right size.  */\n      re_dfastate_t **new_array = re_realloc (mctx->state_log, re_dfastate_t *,\n\t\t\t\t\t      pstr->bufs_len + 1);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      mctx->state_log = new_array;\n    }\n\n  /* Then reconstruct the buffers.  */\n  if (pstr->icase)\n    {\n#ifdef RE_ENABLE_I18N\n      if (pstr->mb_cur_max > 1)\n\t{\n\t  ret = build_wcs_upper_buffer (pstr);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t    return ret;\n\t}\n      else\n#endif /* RE_ENABLE_I18N  */\n\tbuild_upper_buffer (pstr);\n    }\n  else\n    {\n#ifdef RE_ENABLE_I18N\n      if (pstr->mb_cur_max > 1)\n\tbuild_wcs_buffer (pstr);\n      else\n#endif /* RE_ENABLE_I18N  */\n\t{\n\t  if (pstr->trans != NULL)\n\t    re_string_translate_buffer (pstr);\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 59,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "match_ctx_init": {
      "start_point": [
        4174,
        18
      ],
      "end_point": [
        4202,
        1
      ],
      "content": "__attribute_warn_unused_result__\nmatch_ctx_init (re_match_context_t *mctx, int eflags, Idx n)\n{\n  mctx->eflags = eflags;\n  mctx->match_last = -1;\n  if (n > 0)\n    {\n      /* Avoid overflow.  */\n      size_t max_object_size =\n\tMAX (sizeof (struct re_backref_cache_entry),\n\t     sizeof (re_sub_match_top_t *));\n      if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) < n, 0))\n\treturn REG_ESPACE;\n\n      mctx->bkref_ents = re_malloc (struct re_backref_cache_entry, n);\n      mctx->sub_tops = re_malloc (re_sub_match_top_t *, n);\n      if (BE (mctx->bkref_ents == NULL || mctx->sub_tops == NULL, 0))\n\treturn REG_ESPACE;\n    }\n  /* Already zero-ed by the caller.\n     else\n       mctx->bkref_ents = NULL;\n     mctx->nbkref_ents = 0;\n     mctx->nsub_tops = 0;  */\n  mctx->abkref_ents = n;\n  mctx->max_mb_elem_len = 1;\n  mctx->asub_tops = n;\n  return REG_NOERROR;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "match_ctx_clean": {
      "start_point": [
        4208,
        0
      ],
      "end_point": [
        4234,
        1
      ],
      "content": "static void\ninternal_function\nmatch_ctx_clean (re_match_context_t *mctx)\n{\n  Idx st_idx;\n  for (st_idx = 0; st_idx < mctx->nsub_tops; ++st_idx)\n    {\n      Idx sl_idx;\n      re_sub_match_top_t *top = mctx->sub_tops[st_idx];\n      for (sl_idx = 0; sl_idx < top->nlasts; ++sl_idx)\n\t{\n\t  re_sub_match_last_t *last = top->lasts[sl_idx];\n\t  re_free (last->path.array);\n\t  re_free (last);\n\t}\n      re_free (top->lasts);\n      if (top->path)\n\t{\n\t  re_free (top->path->array);\n\t  re_free (top->path);\n\t}\n      free (top);\n    }\n\n  mctx->nsub_tops = 0;\n  mctx->nbkref_ents = 0;\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "match_ctx_free": {
      "start_point": [
        4238,
        0
      ],
      "end_point": [
        4246,
        1
      ],
      "content": "static void\ninternal_function\nmatch_ctx_free (re_match_context_t *mctx)\n{\n  /* First, free all the memory associated with MCTX->SUB_TOPS.  */\n  match_ctx_clean (mctx);\n  re_free (mctx->sub_tops);\n  re_free (mctx->bkref_ents);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "match_ctx_add_entry": {
      "start_point": [
        4254,
        18
      ],
      "end_point": [
        4297,
        1
      ],
      "content": "__attribute_warn_unused_result__\nmatch_ctx_add_entry (re_match_context_t *mctx, Idx node, Idx str_idx, Idx from,\n\t\t     Idx to)\n{\n  if (mctx->nbkref_ents >= mctx->abkref_ents)\n    {\n      struct re_backref_cache_entry* new_entry;\n      new_entry = re_realloc (mctx->bkref_ents, struct re_backref_cache_entry,\n\t\t\t      mctx->abkref_ents * 2);\n      if (BE (new_entry == NULL, 0))\n\t{\n\t  re_free (mctx->bkref_ents);\n\t  return REG_ESPACE;\n\t}\n      mctx->bkref_ents = new_entry;\n      memset (mctx->bkref_ents + mctx->nbkref_ents, '\\0',\n\t      sizeof (struct re_backref_cache_entry) * mctx->abkref_ents);\n      mctx->abkref_ents *= 2;\n    }\n  if (mctx->nbkref_ents > 0\n      && mctx->bkref_ents[mctx->nbkref_ents - 1].str_idx == str_idx)\n    mctx->bkref_ents[mctx->nbkref_ents - 1].more = 1;\n\n  mctx->bkref_ents[mctx->nbkref_ents].node = node;\n  mctx->bkref_ents[mctx->nbkref_ents].str_idx = str_idx;\n  mctx->bkref_ents[mctx->nbkref_ents].subexp_from = from;\n  mctx->bkref_ents[mctx->nbkref_ents].subexp_to = to;\n\n  /* This is a cache that saves negative results of check_dst_limits_calc_pos.\n     If bit N is clear, means that this entry won't epsilon-transition to\n     an OP_OPEN_SUBEXP or OP_CLOSE_SUBEXP for the N+1-th subexpression.  If\n     it is set, check_dst_limits_calc_pos_1 will recurse and try to find one\n     such node.\n\n     A backreference does not epsilon-transition unless it is empty, so set\n     to all zeros if FROM != TO.  */\n  mctx->bkref_ents[mctx->nbkref_ents].eps_reachable_subexps_map\n    = (from == to ? -1 : 0);\n\n  mctx->bkref_ents[mctx->nbkref_ents++].more = 0;\n  if (mctx->max_mb_elem_len < to - from)\n    mctx->max_mb_elem_len = to - from;\n  return REG_NOERROR;\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "search_cur_bkref_entry": {
      "start_point": [
        4302,
        0
      ],
      "end_point": [
        4320,
        1
      ],
      "content": "static Idx\ninternal_function\nsearch_cur_bkref_entry (const re_match_context_t *mctx, Idx str_idx)\n{\n  Idx left, right, mid, last;\n  last = right = mctx->nbkref_ents;\n  for (left = 0; left < right;)\n    {\n      mid = (left + right) / 2;\n      if (mctx->bkref_ents[mid].str_idx < str_idx)\n\tleft = mid + 1;\n      else\n\tright = mid;\n    }\n  if (left < last && mctx->bkref_ents[left].str_idx == str_idx)\n    return left;\n  else\n    return -1;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "match_ctx_add_subtop": {
      "start_point": [
        4326,
        18
      ],
      "end_point": [
        4350,
        1
      ],
      "content": "__attribute_warn_unused_result__\nmatch_ctx_add_subtop (re_match_context_t *mctx, Idx node, Idx str_idx)\n{\n#ifdef DEBUG\n  assert (mctx->sub_tops != NULL);\n  assert (mctx->asub_tops > 0);\n#endif\n  if (BE (mctx->nsub_tops == mctx->asub_tops, 0))\n    {\n      Idx new_asub_tops = mctx->asub_tops * 2;\n      re_sub_match_top_t **new_array = re_realloc (mctx->sub_tops,\n\t\t\t\t\t\t   re_sub_match_top_t *,\n\t\t\t\t\t\t   new_asub_tops);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      mctx->sub_tops = new_array;\n      mctx->asub_tops = new_asub_tops;\n    }\n  mctx->sub_tops[mctx->nsub_tops] = calloc (1, sizeof (re_sub_match_top_t));\n  if (BE (mctx->sub_tops[mctx->nsub_tops] == NULL, 0))\n    return REG_ESPACE;\n  mctx->sub_tops[mctx->nsub_tops]->node = node;\n  mctx->sub_tops[mctx->nsub_tops++]->str_idx = str_idx;\n  return REG_NOERROR;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "match_ctx_add_sublast": {
      "start_point": [
        4355,
        0
      ],
      "end_point": [
        4380,
        1
      ],
      "content": "static re_sub_match_last_t *\ninternal_function\nmatch_ctx_add_sublast (re_sub_match_top_t *subtop, Idx node, Idx str_idx)\n{\n  re_sub_match_last_t *new_entry;\n  if (BE (subtop->nlasts == subtop->alasts, 0))\n    {\n      Idx new_alasts = 2 * subtop->alasts + 1;\n      re_sub_match_last_t **new_array = re_realloc (subtop->lasts,\n\t\t\t\t\t\t    re_sub_match_last_t *,\n\t\t\t\t\t\t    new_alasts);\n      if (BE (new_array == NULL, 0))\n\treturn NULL;\n      subtop->lasts = new_array;\n      subtop->alasts = new_alasts;\n    }\n  new_entry = calloc (1, sizeof (re_sub_match_last_t));\n  if (BE (new_entry != NULL, 1))\n    {\n      subtop->lasts[subtop->nlasts] = new_entry;\n      new_entry->node = node;\n      new_entry->str_idx = str_idx;\n      ++subtop->nlasts;\n    }\n  return new_entry;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "re_sub_match_last_t",
        "*\ninternal_function\nmatch_ctx_add_sublast (re_sub_match_top_t *subtop, Idx node, Idx str_idx)",
        "*",
        "internal_function",
        "internal_function"
      ]
    },
    "sift_ctx_init": {
      "start_point": [
        4382,
        0
      ],
      "end_point": [
        4392,
        1
      ],
      "content": "static void\ninternal_function\nsift_ctx_init (re_sift_context_t *sctx, re_dfastate_t **sifted_sts,\n\t       re_dfastate_t **limited_sts, Idx last_node, Idx last_str_idx)\n{\n  sctx->sifted_states = sifted_sts;\n  sctx->limited_states = limited_sts;\n  sctx->last_node = last_node;\n  sctx->last_str_idx = last_str_idx;\n  re_node_set_init_empty (&sctx->limits);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/regex_internal.c": {
    "re_string_allocate": {
      "start_point": [
        37,
        18
      ],
      "end_point": [
        60,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_string_allocate (re_string_t *pstr, const char *str, Idx len, Idx init_len,\n\t\t    RE_TRANSLATE_TYPE trans, bool icase, const re_dfa_t *dfa)\n{\n  reg_errcode_t ret;\n  Idx init_buf_len;\n\n  /* Ensure at least one character fits into the buffers.  */\n  if (init_len < dfa->mb_cur_max)\n    init_len = dfa->mb_cur_max;\n  init_buf_len = (len + 1 < init_len) ? len + 1: init_len;\n  re_string_construct_common (str, len, pstr, trans, icase, dfa);\n\n  ret = re_string_realloc_buffers (pstr, init_buf_len);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n\n  pstr->word_char = dfa->word_char;\n  pstr->word_ops_used = dfa->word_ops_used;\n  pstr->mbs = pstr->mbs_allocated ? pstr->mbs : (unsigned char *) str;\n  pstr->valid_len = (pstr->mbs_allocated || dfa->mb_cur_max > 1) ? 0 : len;\n  pstr->valid_raw_len = pstr->valid_len;\n  return REG_NOERROR;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_construct": {
      "start_point": [
        65,
        18
      ],
      "end_point": [
        123,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_string_construct (re_string_t *pstr, const char *str, Idx len,\n\t\t     RE_TRANSLATE_TYPE trans, bool icase, const re_dfa_t *dfa)\n{\n  reg_errcode_t ret;\n  memset (pstr, '\\0', sizeof (re_string_t));\n  re_string_construct_common (str, len, pstr, trans, icase, dfa);\n\n  if (len > 0)\n    {\n      ret = re_string_realloc_buffers (pstr, len + 1);\n      if (BE (ret != REG_NOERROR, 0))\n\treturn ret;\n    }\n  pstr->mbs = pstr->mbs_allocated ? pstr->mbs : (unsigned char *) str;\n\n  if (icase)\n    {\n#ifdef RE_ENABLE_I18N\n      if (dfa->mb_cur_max > 1)\n\t{\n\t  while (1)\n\t    {\n\t      ret = build_wcs_upper_buffer (pstr);\n\t      if (BE (ret != REG_NOERROR, 0))\n\t\treturn ret;\n\t      if (pstr->valid_raw_len >= len)\n\t\tbreak;\n\t      if (pstr->bufs_len > pstr->valid_len + dfa->mb_cur_max)\n\t\tbreak;\n\t      ret = re_string_realloc_buffers (pstr, pstr->bufs_len * 2);\n\t      if (BE (ret != REG_NOERROR, 0))\n\t\treturn ret;\n\t    }\n\t}\n      else\n#endif /* RE_ENABLE_I18N  */\n\tbuild_upper_buffer (pstr);\n    }\n  else\n    {\n#ifdef RE_ENABLE_I18N\n      if (dfa->mb_cur_max > 1)\n\tbuild_wcs_buffer (pstr);\n      else\n#endif /* RE_ENABLE_I18N  */\n\t{\n\t  if (trans != NULL)\n\t    re_string_translate_buffer (pstr);\n\t  else\n\t    {\n\t      pstr->valid_len = pstr->bufs_len;\n\t      pstr->valid_raw_len = pstr->bufs_len;\n\t    }\n\t}\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 59,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_realloc_buffers": {
      "start_point": [
        128,
        18
      ],
      "end_point": [
        164,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_string_realloc_buffers (re_string_t *pstr, Idx new_buf_len)\n{\n#ifdef RE_ENABLE_I18N\n  if (pstr->mb_cur_max > 1)\n    {\n      wint_t *new_wcs;\n\n      /* Avoid overflow in realloc.  */\n      const size_t max_object_size = MAX (sizeof (wint_t), sizeof (Idx));\n      if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) < new_buf_len, 0))\n\treturn REG_ESPACE;\n\n      new_wcs = re_realloc (pstr->wcs, wint_t, new_buf_len);\n      if (BE (new_wcs == NULL, 0))\n\treturn REG_ESPACE;\n      pstr->wcs = new_wcs;\n      if (pstr->offsets != NULL)\n\t{\n\t  Idx *new_offsets = re_realloc (pstr->offsets, Idx, new_buf_len);\n\t  if (BE (new_offsets == NULL, 0))\n\t    return REG_ESPACE;\n\t  pstr->offsets = new_offsets;\n\t}\n    }\n#endif /* RE_ENABLE_I18N  */\n  if (pstr->mbs_allocated)\n    {\n      unsigned char *new_mbs = re_realloc (pstr->mbs, unsigned char,\n\t\t\t\t\t   new_buf_len);\n      if (BE (new_mbs == NULL, 0))\n\treturn REG_ESPACE;\n      pstr->mbs = new_mbs;\n    }\n  pstr->bufs_len = new_buf_len;\n  return REG_NOERROR;\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_construct_common": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "static void\ninternal_function\nre_string_construct_common (const char *str, Idx len, re_string_t *pstr,\n\t\t\t    RE_TRANSLATE_TYPE trans, bool icase,\n\t\t\t    const re_dfa_t *dfa)\n{\n  pstr->raw_mbs = (const unsigned char *) str;\n  pstr->len = len;\n  pstr->raw_len = len;\n  pstr->trans = trans;\n  pstr->icase = icase;\n  pstr->mbs_allocated = (trans != NULL || icase);\n  pstr->mb_cur_max = dfa->mb_cur_max;\n  pstr->is_utf8 = dfa->is_utf8;\n  pstr->map_notascii = dfa->map_notascii;\n  pstr->stop = pstr->len;\n  pstr->raw_stop = pstr->stop;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "build_wcs_buffer": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "static void\ninternal_function\nbuild_wcs_buffer (re_string_t *pstr)\n{\n#ifdef _LIBC\n  unsigned char buf[MB_LEN_MAX];\n  assert (MB_LEN_MAX >= pstr->mb_cur_max);\n#else\n  unsigned char buf[64];\n#endif\n  mbstate_t prev_st;\n  Idx byte_idx, end_idx, remain_len;\n  size_t mbclen;\n\n  /* Build the buffers from pstr->valid_len to either pstr->len or\n     pstr->bufs_len.  */\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n  for (byte_idx = pstr->valid_len; byte_idx < end_idx;)\n    {\n      wchar_t wc;\n      const char *p;\n\n      remain_len = end_idx - byte_idx;\n      prev_st = pstr->cur_state;\n      /* Apply the translation if we need.  */\n      if (BE (pstr->trans != NULL, 0))\n\t{\n\t  int i, ch;\n\n\t  for (i = 0; i < pstr->mb_cur_max && i < remain_len; ++i)\n\t    {\n\t      ch = pstr->raw_mbs [pstr->raw_mbs_idx + byte_idx + i];\n\t      buf[i] = pstr->mbs[byte_idx + i] = pstr->trans[ch];\n\t    }\n\t  p = (const char *) buf;\n\t}\n      else\n\tp = (const char *) pstr->raw_mbs + pstr->raw_mbs_idx + byte_idx;\n      mbclen = __mbrtowc (&wc, p, remain_len, &pstr->cur_state);\n      if (BE (mbclen == (size_t) -1 || mbclen == 0\n\t      || (mbclen == (size_t) -2 && pstr->bufs_len >= pstr->len), 0))\n\t{\n\t  /* We treat these cases as a singlebyte character.  */\n\t  mbclen = 1;\n\t  wc = (wchar_t) pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx];\n\t  if (BE (pstr->trans != NULL, 0))\n\t    wc = pstr->trans[wc];\n\t  pstr->cur_state = prev_st;\n\t}\n      else if (BE (mbclen == (size_t) -2, 0))\n\t{\n\t  /* The buffer doesn't have enough space, finish to build.  */\n\t  pstr->cur_state = prev_st;\n\t  break;\n\t}\n\n      /* Write wide character and padding.  */\n      pstr->wcs[byte_idx++] = wc;\n      /* Write paddings.  */\n      for (remain_len = byte_idx + mbclen - 1; byte_idx < remain_len ;)\n\tpstr->wcs[byte_idx++] = WEOF;\n    }\n  pstr->valid_len = byte_idx;\n  pstr->valid_raw_len = byte_idx;\n}",
      "lines": 65,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "build_wcs_upper_buffer": {
      "start_point": [
        269,
        18
      ],
      "end_point": [
        480,
        1
      ],
      "content": "__attribute_warn_unused_result__\nbuild_wcs_upper_buffer (re_string_t *pstr)\n{\n  mbstate_t prev_st;\n  Idx src_idx, byte_idx, end_idx, remain_len;\n  size_t mbclen;\n#ifdef _LIBC\n  char buf[MB_LEN_MAX];\n  assert (MB_LEN_MAX >= pstr->mb_cur_max);\n#else\n  char buf[64];\n#endif\n\n  byte_idx = pstr->valid_len;\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n\n  /* The following optimization assumes that ASCII characters can be\n     mapped to wide characters with a simple cast.  */\n  if (! pstr->map_notascii && pstr->trans == NULL && !pstr->offsets_needed)\n    {\n      while (byte_idx < end_idx)\n\t{\n\t  wchar_t wc;\n\n\t  if (isascii (pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx])\n\t      && mbsinit (&pstr->cur_state))\n\t    {\n\t      /* In case of a singlebyte character.  */\n\t      pstr->mbs[byte_idx]\n\t\t= toupper (pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx]);\n\t      /* The next step uses the assumption that wchar_t is encoded\n\t\t ASCII-safe: all ASCII values can be converted like this.  */\n\t      pstr->wcs[byte_idx] = (wchar_t) pstr->mbs[byte_idx];\n\t      ++byte_idx;\n\t      continue;\n\t    }\n\n\t  remain_len = end_idx - byte_idx;\n\t  prev_st = pstr->cur_state;\n\t  mbclen = __mbrtowc (&wc,\n\t\t\t      ((const char *) pstr->raw_mbs + pstr->raw_mbs_idx\n\t\t\t       + byte_idx), remain_len, &pstr->cur_state);\n\t  if (BE (mbclen < (size_t) -2, 1))\n\t    {\n\t      wchar_t wcu = __towupper (wc);\n\t      if (wcu != wc)\n\t\t{\n\t\t  size_t mbcdlen;\n\n\t\t  mbcdlen = __wcrtomb (buf, wcu, &prev_st);\n\t\t  if (BE (mbclen == mbcdlen, 1))\n\t\t    memcpy (pstr->mbs + byte_idx, buf, mbclen);\n\t\t  else\n\t\t    {\n\t\t      src_idx = byte_idx;\n\t\t      goto offsets_needed;\n\t\t    }\n\t\t}\n\t      else\n\t\tmemcpy (pstr->mbs + byte_idx,\n\t\t\tpstr->raw_mbs + pstr->raw_mbs_idx + byte_idx, mbclen);\n\t      pstr->wcs[byte_idx++] = wcu;\n\t      /* Write paddings.  */\n\t      for (remain_len = byte_idx + mbclen - 1; byte_idx < remain_len ;)\n\t\tpstr->wcs[byte_idx++] = WEOF;\n\t    }\n\t  else if (mbclen == (size_t) -1 || mbclen == 0\n\t\t   || (mbclen == (size_t) -2 && pstr->bufs_len >= pstr->len))\n\t    {\n\t      /* It is an invalid character, an incomplete character\n\t\t at the end of the string, or '\\0'.  Just use the byte.  */\n\t      int ch = pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx];\n\t      pstr->mbs[byte_idx] = ch;\n\t      /* And also cast it to wide char.  */\n\t      pstr->wcs[byte_idx++] = (wchar_t) ch;\n\t      if (BE (mbclen == (size_t) -1, 0))\n\t\tpstr->cur_state = prev_st;\n\t    }\n\t  else\n\t    {\n\t      /* The buffer doesn't have enough space, finish to build.  */\n\t      pstr->cur_state = prev_st;\n\t      break;\n\t    }\n\t}\n      pstr->valid_len = byte_idx;\n      pstr->valid_raw_len = byte_idx;\n      return REG_NOERROR;\n    }\n  else\n    for (src_idx = pstr->valid_raw_len; byte_idx < end_idx;)\n      {\n\twchar_t wc;\n\tconst char *p;\n      offsets_needed:\n\tremain_len = end_idx - byte_idx;\n\tprev_st = pstr->cur_state;\n\tif (BE (pstr->trans != NULL, 0))\n\t  {\n\t    int i, ch;\n\n\t    for (i = 0; i < pstr->mb_cur_max && i < remain_len; ++i)\n\t      {\n\t\tch = pstr->raw_mbs [pstr->raw_mbs_idx + src_idx + i];\n\t\tbuf[i] = pstr->trans[ch];\n\t      }\n\t    p = (const char *) buf;\n\t  }\n\telse\n\t  p = (const char *) pstr->raw_mbs + pstr->raw_mbs_idx + src_idx;\n\tmbclen = __mbrtowc (&wc, p, remain_len, &pstr->cur_state);\n\tif (BE (mbclen < (size_t) -2, 1))\n\t  {\n\t    wchar_t wcu = __towupper (wc);\n\t    if (wcu != wc)\n\t      {\n\t\tsize_t mbcdlen;\n\n\t\tmbcdlen = wcrtomb ((char *) buf, wcu, &prev_st);\n\t\tif (BE (mbclen == mbcdlen, 1))\n\t\t  memcpy (pstr->mbs + byte_idx, buf, mbclen);\n\t\telse if (mbcdlen != (size_t) -1)\n\t\t  {\n\t\t    size_t i;\n\n\t\t    if (byte_idx + mbcdlen > pstr->bufs_len)\n\t\t      {\n\t\t\tpstr->cur_state = prev_st;\n\t\t\tbreak;\n\t\t      }\n\n\t\t    if (pstr->offsets == NULL)\n\t\t      {\n\t\t\tpstr->offsets = re_malloc (Idx, pstr->bufs_len);\n\n\t\t\tif (pstr->offsets == NULL)\n\t\t\t  return REG_ESPACE;\n\t\t      }\n\t\t    if (!pstr->offsets_needed)\n\t\t      {\n\t\t\tfor (i = 0; i < (size_t) byte_idx; ++i)\n\t\t\t  pstr->offsets[i] = i;\n\t\t\tpstr->offsets_needed = 1;\n\t\t      }\n\n\t\t    memcpy (pstr->mbs + byte_idx, buf, mbcdlen);\n\t\t    pstr->wcs[byte_idx] = wcu;\n\t\t    pstr->offsets[byte_idx] = src_idx;\n\t\t    for (i = 1; i < mbcdlen; ++i)\n\t\t      {\n\t\t\tpstr->offsets[byte_idx + i]\n\t\t\t  = src_idx + (i < mbclen ? i : mbclen - 1);\n\t\t\tpstr->wcs[byte_idx + i] = WEOF;\n\t\t      }\n\t\t    pstr->len += mbcdlen - mbclen;\n\t\t    if (pstr->raw_stop > src_idx)\n\t\t      pstr->stop += mbcdlen - mbclen;\n\t\t    end_idx = (pstr->bufs_len > pstr->len)\n\t\t\t      ? pstr->len : pstr->bufs_len;\n\t\t    byte_idx += mbcdlen;\n\t\t    src_idx += mbclen;\n\t\t    continue;\n\t\t  }\n\t\telse\n\t\t  memcpy (pstr->mbs + byte_idx, p, mbclen);\n\t      }\n\t    else\n\t      memcpy (pstr->mbs + byte_idx, p, mbclen);\n\n\t    if (BE (pstr->offsets_needed != 0, 0))\n\t      {\n\t\tsize_t i;\n\t\tfor (i = 0; i < mbclen; ++i)\n\t\t  pstr->offsets[byte_idx + i] = src_idx + i;\n\t      }\n\t    src_idx += mbclen;\n\n\t    pstr->wcs[byte_idx++] = wcu;\n\t    /* Write paddings.  */\n\t    for (remain_len = byte_idx + mbclen - 1; byte_idx < remain_len ;)\n\t      pstr->wcs[byte_idx++] = WEOF;\n\t  }\n\telse if (mbclen == (size_t) -1 || mbclen == 0\n\t\t || (mbclen == (size_t) -2 && pstr->bufs_len >= pstr->len))\n\t  {\n\t    /* It is an invalid character or '\\0'.  Just use the byte.  */\n\t    int ch = pstr->raw_mbs[pstr->raw_mbs_idx + src_idx];\n\n\t    if (BE (pstr->trans != NULL, 0))\n\t      ch = pstr->trans [ch];\n\t    pstr->mbs[byte_idx] = ch;\n\n\t    if (BE (pstr->offsets_needed != 0, 0))\n\t      pstr->offsets[byte_idx] = src_idx;\n\t    ++src_idx;\n\n\t    /* And also cast it to wide char.  */\n\t    pstr->wcs[byte_idx++] = (wchar_t) ch;\n\t    if (BE (mbclen == (size_t) -1, 0))\n\t      pstr->cur_state = prev_st;\n\t  }\n\telse\n\t  {\n\t    /* The buffer doesn't have enough space, finish to build.  */\n\t    pstr->cur_state = prev_st;\n\t    break;\n\t  }\n      }\n  pstr->valid_len = byte_idx;\n  pstr->valid_raw_len = src_idx;\n  return REG_NOERROR;\n}",
      "lines": 212,
      "depth": 21,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_skip_chars": {
      "start_point": [
        485,
        0
      ],
      "end_point": [
        520,
        1
      ],
      "content": "static Idx\ninternal_function\nre_string_skip_chars (re_string_t *pstr, Idx new_raw_idx, wint_t *last_wc)\n{\n  mbstate_t prev_st;\n  Idx rawbuf_idx;\n  size_t mbclen;\n  wint_t wc = WEOF;\n\n  /* Skip the characters which are not necessary to check.  */\n  for (rawbuf_idx = pstr->raw_mbs_idx + pstr->valid_raw_len;\n       rawbuf_idx < new_raw_idx;)\n    {\n      wchar_t wc2;\n      Idx remain_len = pstr->raw_len - rawbuf_idx;\n      prev_st = pstr->cur_state;\n      mbclen = __mbrtowc (&wc2, (const char *) pstr->raw_mbs + rawbuf_idx,\n\t\t\t  remain_len, &pstr->cur_state);\n      if (BE (mbclen == (size_t) -2 || mbclen == (size_t) -1 || mbclen == 0, 0))\n\t{\n\t  /* We treat these cases as a single byte character.  */\n\t  if (mbclen == 0 || remain_len == 0)\n\t    wc = L'\\0';\n\t  else\n\t    wc = *(unsigned char *) (pstr->raw_mbs + rawbuf_idx);\n\t  mbclen = 1;\n\t  pstr->cur_state = prev_st;\n\t}\n      else\n\twc = wc2;\n      /* Then proceed the next character.  */\n      rawbuf_idx += mbclen;\n    }\n  *last_wc = wc;\n  return rawbuf_idx;\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "build_upper_buffer": {
      "start_point": [
        526,
        0
      ],
      "end_point": [
        542,
        1
      ],
      "content": "static void\ninternal_function\nbuild_upper_buffer (re_string_t *pstr)\n{\n  Idx char_idx, end_idx;\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n\n  for (char_idx = pstr->valid_len; char_idx < end_idx; ++char_idx)\n    {\n      int ch = pstr->raw_mbs[pstr->raw_mbs_idx + char_idx];\n      if (BE (pstr->trans != NULL, 0))\n\tch = pstr->trans[ch];\n      pstr->mbs[char_idx] = toupper (ch);\n    }\n  pstr->valid_len = char_idx;\n  pstr->valid_raw_len = char_idx;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "re_string_translate_buffer": {
      "start_point": [
        546,
        0
      ],
      "end_point": [
        561,
        1
      ],
      "content": "static void\ninternal_function\nre_string_translate_buffer (re_string_t *pstr)\n{\n  Idx buf_idx, end_idx;\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n\n  for (buf_idx = pstr->valid_len; buf_idx < end_idx; ++buf_idx)\n    {\n      int ch = pstr->raw_mbs[pstr->raw_mbs_idx + buf_idx];\n      pstr->mbs[buf_idx] = pstr->trans[ch];\n    }\n\n  pstr->valid_len = buf_idx;\n  pstr->valid_raw_len = buf_idx;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "re_string_reconstruct": {
      "start_point": [
        568,
        18
      ],
      "end_point": [
        828,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_string_reconstruct (re_string_t *pstr, Idx idx, int eflags)\n{\n  Idx offset;\n\n  if (BE (pstr->raw_mbs_idx <= idx, 0))\n    offset = idx - pstr->raw_mbs_idx;\n  else\n    {\n      /* Reset buffer.  */\n#ifdef RE_ENABLE_I18N\n      if (pstr->mb_cur_max > 1)\n\tmemset (&pstr->cur_state, '\\0', sizeof (mbstate_t));\n#endif /* RE_ENABLE_I18N */\n      pstr->len = pstr->raw_len;\n      pstr->stop = pstr->raw_stop;\n      pstr->valid_len = 0;\n      pstr->raw_mbs_idx = 0;\n      pstr->valid_raw_len = 0;\n      pstr->offsets_needed = 0;\n      pstr->tip_context = ((eflags & REG_NOTBOL) ? CONTEXT_BEGBUF\n\t\t\t   : CONTEXT_NEWLINE | CONTEXT_BEGBUF);\n      if (!pstr->mbs_allocated)\n\tpstr->mbs = (unsigned char *) pstr->raw_mbs;\n      offset = idx;\n    }\n\n  if (BE (offset != 0, 1))\n    {\n      /* Should the already checked characters be kept?  */\n      if (BE (offset < pstr->valid_raw_len, 1))\n\t{\n\t  /* Yes, move them to the front of the buffer.  */\n#ifdef RE_ENABLE_I18N\n\t  if (BE (pstr->offsets_needed, 0))\n\t    {\n\t      Idx low = 0, high = pstr->valid_len, mid;\n\t      do\n\t\t{\n\t\t  mid = (high + low) / 2;\n\t\t  if (pstr->offsets[mid] > offset)\n\t\t    high = mid;\n\t\t  else if (pstr->offsets[mid] < offset)\n\t\t    low = mid + 1;\n\t\t  else\n\t\t    break;\n\t\t}\n\t      while (low < high);\n\t      if (pstr->offsets[mid] < offset)\n\t\t++mid;\n\t      pstr->tip_context = re_string_context_at (pstr, mid - 1,\n\t\t\t\t\t\t\teflags);\n\t      /* This can be quite complicated, so handle specially\n\t\t only the common and easy case where the character with\n\t\t different length representation of lower and upper\n\t\t case is present at or after offset.  */\n\t      if (pstr->valid_len > offset\n\t\t  && mid == offset && pstr->offsets[mid] == offset)\n\t\t{\n\t\t  memmove (pstr->wcs, pstr->wcs + offset,\n\t\t\t   (pstr->valid_len - offset) * sizeof (wint_t));\n\t\t  memmove (pstr->mbs, pstr->mbs + offset, pstr->valid_len - offset);\n\t\t  pstr->valid_len -= offset;\n\t\t  pstr->valid_raw_len -= offset;\n\t\t  for (low = 0; low < pstr->valid_len; low++)\n\t\t    pstr->offsets[low] = pstr->offsets[low + offset] - offset;\n\t\t}\n\t      else\n\t\t{\n\t\t  /* Otherwise, just find out how long the partial multibyte\n\t\t     character at offset is and fill it with WEOF/255.  */\n\t\t  pstr->len = pstr->raw_len - idx + offset;\n\t\t  pstr->stop = pstr->raw_stop - idx + offset;\n\t\t  pstr->offsets_needed = 0;\n\t\t  while (mid > 0 && pstr->offsets[mid - 1] == offset)\n\t\t    --mid;\n\t\t  while (mid < pstr->valid_len)\n\t\t    if (pstr->wcs[mid] != WEOF)\n\t\t      break;\n\t\t    else\n\t\t      ++mid;\n\t\t  if (mid == pstr->valid_len)\n\t\t    pstr->valid_len = 0;\n\t\t  else\n\t\t    {\n\t\t      pstr->valid_len = pstr->offsets[mid] - offset;\n\t\t      if (pstr->valid_len)\n\t\t\t{\n\t\t\t  for (low = 0; low < pstr->valid_len; ++low)\n\t\t\t    pstr->wcs[low] = WEOF;\n\t\t\t  memset (pstr->mbs, 255, pstr->valid_len);\n\t\t\t}\n\t\t    }\n\t\t  pstr->valid_raw_len = pstr->valid_len;\n\t\t}\n\t    }\n\t  else\n#endif\n\t    {\n\t      pstr->tip_context = re_string_context_at (pstr, offset - 1,\n\t\t\t\t\t\t\teflags);\n#ifdef RE_ENABLE_I18N\n\t      if (pstr->mb_cur_max > 1)\n\t\tmemmove (pstr->wcs, pstr->wcs + offset,\n\t\t\t (pstr->valid_len - offset) * sizeof (wint_t));\n#endif /* RE_ENABLE_I18N */\n\t      if (BE (pstr->mbs_allocated, 0))\n\t\tmemmove (pstr->mbs, pstr->mbs + offset,\n\t\t\t pstr->valid_len - offset);\n\t      pstr->valid_len -= offset;\n\t      pstr->valid_raw_len -= offset;\n#if defined DEBUG && DEBUG\n\t      assert (pstr->valid_len > 0);\n#endif\n\t    }\n\t}\n      else\n\t{\n#ifdef RE_ENABLE_I18N\n\t  /* No, skip all characters until IDX.  */\n\t  Idx prev_valid_len = pstr->valid_len;\n\n\t  if (BE (pstr->offsets_needed, 0))\n\t    {\n\t      pstr->len = pstr->raw_len - idx + offset;\n\t      pstr->stop = pstr->raw_stop - idx + offset;\n\t      pstr->offsets_needed = 0;\n\t    }\n#endif\n\t  pstr->valid_len = 0;\n#ifdef RE_ENABLE_I18N\n\t  if (pstr->mb_cur_max > 1)\n\t    {\n\t      Idx wcs_idx;\n\t      wint_t wc = WEOF;\n\n\t      if (pstr->is_utf8)\n\t\t{\n\t\t  const unsigned char *raw, *p, *end;\n\n\t\t  /* Special case UTF-8.  Multi-byte chars start with any\n\t\t     byte other than 0x80 - 0xbf.  */\n\t\t  raw = pstr->raw_mbs + pstr->raw_mbs_idx;\n\t\t  end = raw + (offset - pstr->mb_cur_max);\n\t\t  if (end < pstr->raw_mbs)\n\t\t    end = pstr->raw_mbs;\n\t\t  p = raw + offset - 1;\n#ifdef _LIBC\n\t\t  /* We know the wchar_t encoding is UCS4, so for the simple\n\t\t     case, ASCII characters, skip the conversion step.  */\n\t\t  if (isascii (*p) && BE (pstr->trans == NULL, 1))\n\t\t    {\n\t\t      memset (&pstr->cur_state, '\\0', sizeof (mbstate_t));\n\t\t      /* pstr->valid_len = 0; */\n\t\t      wc = (wchar_t) *p;\n\t\t    }\n\t\t  else\n#endif\n\t\t    for (; p >= end; --p)\n\t\t      if ((*p & 0xc0) != 0x80)\n\t\t\t{\n\t\t\t  mbstate_t cur_state;\n\t\t\t  wchar_t wc2;\n\t\t\t  Idx mlen = raw + pstr->len - p;\n\t\t\t  unsigned char buf[6];\n\t\t\t  size_t mbclen;\n\n\t\t\t  const unsigned char *pp = p;\n\t\t\t  if (BE (pstr->trans != NULL, 0))\n\t\t\t    {\n\t\t\t      int i = mlen < 6 ? mlen : 6;\n\t\t\t      while (--i >= 0)\n\t\t\t\tbuf[i] = pstr->trans[p[i]];\n\t\t\t      pp = buf;\n\t\t\t    }\n\t\t\t  /* XXX Don't use mbrtowc, we know which conversion\n\t\t\t     to use (UTF-8 -> UCS4).  */\n\t\t\t  memset (&cur_state, 0, sizeof (cur_state));\n\t\t\t  mbclen = __mbrtowc (&wc2, (const char *) pp, mlen,\n\t\t\t\t\t      &cur_state);\n\t\t\t  if (raw + offset - p <= mbclen\n\t\t\t      && mbclen < (size_t) -2)\n\t\t\t    {\n\t\t\t      memset (&pstr->cur_state, '\\0',\n\t\t\t\t      sizeof (mbstate_t));\n\t\t\t      pstr->valid_len = mbclen - (raw + offset - p);\n\t\t\t      wc = wc2;\n\t\t\t    }\n\t\t\t  break;\n\t\t\t}\n\t\t}\n\n\t      if (wc == WEOF)\n\t\tpstr->valid_len = re_string_skip_chars (pstr, idx, &wc) - idx;\n\t      if (wc == WEOF)\n\t\tpstr->tip_context\n\t\t  = re_string_context_at (pstr, prev_valid_len - 1, eflags);\n\t      else\n\t\tpstr->tip_context = ((BE (pstr->word_ops_used != 0, 0)\n\t\t\t\t      && IS_WIDE_WORD_CHAR (wc))\n\t\t\t\t     ? CONTEXT_WORD\n\t\t\t\t     : ((IS_WIDE_NEWLINE (wc)\n\t\t\t\t\t && pstr->newline_anchor)\n\t\t\t\t\t? CONTEXT_NEWLINE : 0));\n\t      if (BE (pstr->valid_len, 0))\n\t\t{\n\t\t  for (wcs_idx = 0; wcs_idx < pstr->valid_len; ++wcs_idx)\n\t\t    pstr->wcs[wcs_idx] = WEOF;\n\t\t  if (pstr->mbs_allocated)\n\t\t    memset (pstr->mbs, 255, pstr->valid_len);\n\t\t}\n\t      pstr->valid_raw_len = pstr->valid_len;\n\t    }\n\t  else\n#endif /* RE_ENABLE_I18N */\n\t    {\n\t      int c = pstr->raw_mbs[pstr->raw_mbs_idx + offset - 1];\n\t      pstr->valid_raw_len = 0;\n\t      if (pstr->trans)\n\t\tc = pstr->trans[c];\n\t      pstr->tip_context = (bitset_contain (pstr->word_char, c)\n\t\t\t\t   ? CONTEXT_WORD\n\t\t\t\t   : ((IS_NEWLINE (c) && pstr->newline_anchor)\n\t\t\t\t      ? CONTEXT_NEWLINE : 0));\n\t    }\n\t}\n      if (!BE (pstr->mbs_allocated, 0))\n\tpstr->mbs += offset;\n    }\n  pstr->raw_mbs_idx = idx;\n  pstr->len -= offset;\n  pstr->stop -= offset;\n\n  /* Then build the buffers.  */\n#ifdef RE_ENABLE_I18N\n  if (pstr->mb_cur_max > 1)\n    {\n      if (pstr->icase)\n\t{\n\t  reg_errcode_t ret = build_wcs_upper_buffer (pstr);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t    return ret;\n\t}\n      else\n\tbuild_wcs_buffer (pstr);\n    }\n  else\n#endif /* RE_ENABLE_I18N */\n    if (BE (pstr->mbs_allocated, 0))\n      {\n\tif (pstr->icase)\n\t  build_upper_buffer (pstr);\n\telse if (pstr->trans != NULL)\n\t  re_string_translate_buffer (pstr);\n      }\n    else\n      pstr->valid_len = pstr->len;\n\n  pstr->cur_idx = 0;\n  return REG_NOERROR;\n}",
      "lines": 261,
      "depth": 23,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "internal_function": {
      "start_point": [
        831,
        18
      ],
      "end_point": [
        865,
        1
      ],
      "content": "__attribute__ ((pure))\nre_string_peek_byte_case (const re_string_t *pstr, Idx idx)\n{\n  int ch;\n  Idx off;\n\n  /* Handle the common (easiest) cases first.  */\n  if (BE (!pstr->mbs_allocated, 1))\n    return re_string_peek_byte (pstr, idx);\n\n#ifdef RE_ENABLE_I18N\n  if (pstr->mb_cur_max > 1\n      && ! re_string_is_single_byte_char (pstr, pstr->cur_idx + idx))\n    return re_string_peek_byte (pstr, idx);\n#endif\n\n  off = pstr->cur_idx + idx;\n#ifdef RE_ENABLE_I18N\n  if (pstr->offsets_needed)\n    off = pstr->offsets[off];\n#endif\n\n  ch = pstr->raw_mbs[pstr->raw_mbs_idx + off];\n\n#ifdef RE_ENABLE_I18N\n  /* Ensure that e.g. for tr_TR.UTF-8 BACKSLASH DOTLESS SMALL LETTER I\n     this function returns CAPITAL LETTER I instead of first byte of\n     DOTLESS SMALL LETTER I.  The latter would confuse the parser,\n     since peek_byte_case doesn't advance cur_idx in any way.  */\n  if (pstr->offsets_needed && !isascii (ch))\n    return re_string_peek_byte (pstr, idx);\n#endif\n\n  return ch;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": null
    },
    "re_string_fetch_byte_case": {
      "start_point": [
        867,
        0
      ],
      "end_point": [
        903,
        1
      ],
      "content": "static unsigned char\ninternal_function\nre_string_fetch_byte_case (re_string_t *pstr)\n{\n  if (BE (!pstr->mbs_allocated, 1))\n    return re_string_fetch_byte (pstr);\n\n#ifdef RE_ENABLE_I18N\n  if (pstr->offsets_needed)\n    {\n      Idx off;\n      int ch;\n\n      /* For tr_TR.UTF-8 [[:islower:]] there is\n\t [[: CAPITAL LETTER I WITH DOT lower:]] in mbs.  Skip\n\t in that case the whole multi-byte character and return\n\t the original letter.  On the other side, with\n\t [[: DOTLESS SMALL LETTER I return [[:I, as doing\n\t anything else would complicate things too much.  */\n\n      if (!re_string_first_byte (pstr, pstr->cur_idx))\n\treturn re_string_fetch_byte (pstr);\n\n      off = pstr->offsets[pstr->cur_idx];\n      ch = pstr->raw_mbs[pstr->raw_mbs_idx + off];\n\n      if (! isascii (ch))\n\treturn re_string_fetch_byte (pstr);\n\n      re_string_skip_bytes (pstr,\n\t\t\t    re_string_char_size_at (pstr, pstr->cur_idx));\n      return ch;\n    }\n#endif\n\n  return pstr->raw_mbs[pstr->raw_mbs_idx + pstr->cur_idx++];\n}",
      "lines": 37,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char",
        "internal_function",
        "internal_function"
      ]
    },
    "re_string_destruct": {
      "start_point": [
        905,
        0
      ],
      "end_point": [
        915,
        1
      ],
      "content": "static void\ninternal_function\nre_string_destruct (re_string_t *pstr)\n{\n#ifdef RE_ENABLE_I18N\n  re_free (pstr->wcs);\n  re_free (pstr->offsets);\n#endif /* RE_ENABLE_I18N  */\n  if (pstr->mbs_allocated)\n    re_free (pstr->mbs);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "re_string_context_at": {
      "start_point": [
        919,
        0
      ],
      "end_point": [
        960,
        1
      ],
      "content": "static unsigned int\ninternal_function\nre_string_context_at (const re_string_t *input, Idx idx, int eflags)\n{\n  int c;\n  if (BE (idx < 0, 0))\n    /* In this case, we use the value stored in input->tip_context,\n       since we can't know the character in input->mbs[-1] here.  */\n    return input->tip_context;\n  if (BE (idx == input->len, 0))\n    return ((eflags & REG_NOTEOL) ? CONTEXT_ENDBUF\n\t    : CONTEXT_NEWLINE | CONTEXT_ENDBUF);\n#ifdef RE_ENABLE_I18N\n  if (input->mb_cur_max > 1)\n    {\n      wint_t wc;\n      Idx wc_idx = idx;\n      while(input->wcs[wc_idx] == WEOF)\n\t{\n#if defined DEBUG && DEBUG\n\t  /* It must not happen.  */\n\t  assert (wc_idx >= 0);\n#endif\n\t  --wc_idx;\n\t  if (wc_idx < 0)\n\t    return input->tip_context;\n\t}\n      wc = input->wcs[wc_idx];\n      if (BE (input->word_ops_used != 0, 0) && IS_WIDE_WORD_CHAR (wc))\n\treturn CONTEXT_WORD;\n      return (IS_WIDE_NEWLINE (wc) && input->newline_anchor\n\t      ? CONTEXT_NEWLINE : 0);\n    }\n  else\n#endif\n    {\n      c = re_string_byte_at (input, idx);\n      if (bitset_contain (input->word_char, c))\n\treturn CONTEXT_WORD;\n      return IS_NEWLINE (c) && input->newline_anchor ? CONTEXT_NEWLINE : 0;\n    }\n}",
      "lines": 42,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "re_node_set_alloc": {
      "start_point": [
        965,
        18
      ],
      "end_point": [
        974,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_alloc (re_node_set *set, Idx size)\n{\n  set->alloc = size;\n  set->nelem = 0;\n  set->elems = re_malloc (Idx, size);\n  if (BE (set->elems == NULL, 0) && (MALLOC_0_IS_NONNULL || size != 0))\n    return REG_ESPACE;\n  return REG_NOERROR;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_1": {
      "start_point": [
        977,
        18
      ],
      "end_point": [
        990,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_init_1 (re_node_set *set, Idx elem)\n{\n  set->alloc = 1;\n  set->nelem = 1;\n  set->elems = re_malloc (Idx, 1);\n  if (BE (set->elems == NULL, 0))\n    {\n      set->alloc = set->nelem = 0;\n      return REG_ESPACE;\n    }\n  set->elems[0] = elem;\n  return REG_NOERROR;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_2": {
      "start_point": [
        993,
        18
      ],
      "end_point": [
        1020,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_init_2 (re_node_set *set, Idx elem1, Idx elem2)\n{\n  set->alloc = 2;\n  set->elems = re_malloc (Idx, 2);\n  if (BE (set->elems == NULL, 0))\n    return REG_ESPACE;\n  if (elem1 == elem2)\n    {\n      set->nelem = 1;\n      set->elems[0] = elem1;\n    }\n  else\n    {\n      set->nelem = 2;\n      if (elem1 < elem2)\n\t{\n\t  set->elems[0] = elem1;\n\t  set->elems[1] = elem2;\n\t}\n      else\n\t{\n\t  set->elems[0] = elem2;\n\t  set->elems[1] = elem1;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_copy": {
      "start_point": [
        1023,
        18
      ],
      "end_point": [
        1041,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_init_copy (re_node_set *dest, const re_node_set *src)\n{\n  dest->nelem = src->nelem;\n  if (src->nelem > 0)\n    {\n      dest->alloc = dest->nelem;\n      dest->elems = re_malloc (Idx, dest->alloc);\n      if (BE (dest->elems == NULL, 0))\n\t{\n\t  dest->alloc = dest->nelem = 0;\n\t  return REG_ESPACE;\n\t}\n      memcpy (dest->elems, src->elems, src->nelem * sizeof (Idx));\n    }\n  else\n    re_node_set_init_empty (dest);\n  return REG_NOERROR;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_add_intersect": {
      "start_point": [
        1048,
        18
      ],
      "end_point": [
        1133,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_add_intersect (re_node_set *dest, const re_node_set *src1,\n\t\t\t   const re_node_set *src2)\n{\n  Idx i1, i2, is, id, delta, sbase;\n  if (src1->nelem == 0 || src2->nelem == 0)\n    return REG_NOERROR;\n\n  /* We need dest->nelem + 2 * elems_in_intersection; this is a\n     conservative estimate.  */\n  if (src1->nelem + src2->nelem + dest->nelem > dest->alloc)\n    {\n      Idx new_alloc = src1->nelem + src2->nelem + dest->alloc;\n      Idx *new_elems = re_realloc (dest->elems, Idx, new_alloc);\n      if (BE (new_elems == NULL, 0))\n\treturn REG_ESPACE;\n      dest->elems = new_elems;\n      dest->alloc = new_alloc;\n    }\n\n  /* Find the items in the intersection of SRC1 and SRC2, and copy\n     into the top of DEST those that are not already in DEST itself.  */\n  sbase = dest->nelem + src1->nelem + src2->nelem;\n  i1 = src1->nelem - 1;\n  i2 = src2->nelem - 1;\n  id = dest->nelem - 1;\n  for (;;)\n    {\n      if (src1->elems[i1] == src2->elems[i2])\n\t{\n\t  /* Try to find the item in DEST.  Maybe we could binary search?  */\n\t  while (id >= 0 && dest->elems[id] > src1->elems[i1])\n\t    --id;\n\n\t  if (id < 0 || dest->elems[id] != src1->elems[i1])\n            dest->elems[--sbase] = src1->elems[i1];\n\n\t  if (--i1 < 0 || --i2 < 0)\n\t    break;\n\t}\n\n      /* Lower the highest of the two items.  */\n      else if (src1->elems[i1] < src2->elems[i2])\n\t{\n\t  if (--i2 < 0)\n\t    break;\n\t}\n      else\n\t{\n\t  if (--i1 < 0)\n\t    break;\n\t}\n    }\n\n  id = dest->nelem - 1;\n  is = dest->nelem + src1->nelem + src2->nelem - 1;\n  delta = is - sbase + 1;\n\n  /* Now copy.  When DELTA becomes zero, the remaining\n     DEST elements are already in place; this is more or\n     less the same loop that is in re_node_set_merge.  */\n  dest->nelem += delta;\n  if (delta > 0 && id >= 0)\n    for (;;)\n      {\n\tif (dest->elems[is] > dest->elems[id])\n\t  {\n\t    /* Copy from the top.  */\n\t    dest->elems[id + delta--] = dest->elems[is--];\n\t    if (delta == 0)\n\t      break;\n\t  }\n\telse\n\t  {\n\t    /* Slide from the bottom.  */\n\t    dest->elems[id + delta] = dest->elems[id];\n\t    if (--id < 0)\n\t      break;\n\t  }\n      }\n\n  /* Copy remaining SRC elements.  */\n  memcpy (dest->elems, dest->elems + sbase, delta * sizeof (Idx));\n\n  return REG_NOERROR;\n}",
      "lines": 86,
      "depth": 13,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_union": {
      "start_point": [
        1139,
        18
      ],
      "end_point": [
        1186,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_init_union (re_node_set *dest, const re_node_set *src1,\n\t\t\tconst re_node_set *src2)\n{\n  Idx i1, i2, id;\n  if (src1 != NULL && src1->nelem > 0 && src2 != NULL && src2->nelem > 0)\n    {\n      dest->alloc = src1->nelem + src2->nelem;\n      dest->elems = re_malloc (Idx, dest->alloc);\n      if (BE (dest->elems == NULL, 0))\n\treturn REG_ESPACE;\n    }\n  else\n    {\n      if (src1 != NULL && src1->nelem > 0)\n\treturn re_node_set_init_copy (dest, src1);\n      else if (src2 != NULL && src2->nelem > 0)\n\treturn re_node_set_init_copy (dest, src2);\n      else\n\tre_node_set_init_empty (dest);\n      return REG_NOERROR;\n    }\n  for (i1 = i2 = id = 0 ; i1 < src1->nelem && i2 < src2->nelem ;)\n    {\n      if (src1->elems[i1] > src2->elems[i2])\n\t{\n\t  dest->elems[id++] = src2->elems[i2++];\n\t  continue;\n\t}\n      if (src1->elems[i1] == src2->elems[i2])\n\t++i2;\n      dest->elems[id++] = src1->elems[i1++];\n    }\n  if (i1 < src1->nelem)\n    {\n      memcpy (dest->elems + id, src1->elems + i1,\n\t     (src1->nelem - i1) * sizeof (Idx));\n      id += src1->nelem - i1;\n    }\n  else if (i2 < src2->nelem)\n    {\n      memcpy (dest->elems + id, src2->elems + i2,\n\t     (src2->nelem - i2) * sizeof (Idx));\n      id += src2->nelem - i2;\n    }\n  dest->nelem = id;\n  return REG_NOERROR;\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_merge": {
      "start_point": [
        1192,
        18
      ],
      "end_point": [
        1268,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_merge (re_node_set *dest, const re_node_set *src)\n{\n  Idx is, id, sbase, delta;\n  if (src == NULL || src->nelem == 0)\n    return REG_NOERROR;\n  if (dest->alloc < 2 * src->nelem + dest->nelem)\n    {\n      Idx new_alloc = 2 * (src->nelem + dest->alloc);\n      Idx *new_buffer = re_realloc (dest->elems, Idx, new_alloc);\n      if (BE (new_buffer == NULL, 0))\n\treturn REG_ESPACE;\n      dest->elems = new_buffer;\n      dest->alloc = new_alloc;\n    }\n\n  if (BE (dest->nelem == 0, 0))\n    {\n      dest->nelem = src->nelem;\n      memcpy (dest->elems, src->elems, src->nelem * sizeof (Idx));\n      return REG_NOERROR;\n    }\n\n  /* Copy into the top of DEST the items of SRC that are not\n     found in DEST.  Maybe we could binary search in DEST?  */\n  for (sbase = dest->nelem + 2 * src->nelem,\n       is = src->nelem - 1, id = dest->nelem - 1; is >= 0 && id >= 0; )\n    {\n      if (dest->elems[id] == src->elems[is])\n\tis--, id--;\n      else if (dest->elems[id] < src->elems[is])\n\tdest->elems[--sbase] = src->elems[is--];\n      else /* if (dest->elems[id] > src->elems[is]) */\n\t--id;\n    }\n\n  if (is >= 0)\n    {\n      /* If DEST is exhausted, the remaining items of SRC must be unique.  */\n      sbase -= is + 1;\n      memcpy (dest->elems + sbase, src->elems, (is + 1) * sizeof (Idx));\n    }\n\n  id = dest->nelem - 1;\n  is = dest->nelem + 2 * src->nelem - 1;\n  delta = is - sbase + 1;\n  if (delta == 0)\n    return REG_NOERROR;\n\n  /* Now copy.  When DELTA becomes zero, the remaining\n     DEST elements are already in place.  */\n  dest->nelem += delta;\n  for (;;)\n    {\n      if (dest->elems[is] > dest->elems[id])\n\t{\n\t  /* Copy from the top.  */\n\t  dest->elems[id + delta--] = dest->elems[is--];\n\t  if (delta == 0)\n\t    break;\n\t}\n      else\n\t{\n\t  /* Slide from the bottom.  */\n\t  dest->elems[id + delta] = dest->elems[id];\n\t  if (--id < 0)\n\t    {\n\t      /* Copy remaining SRC elements.  */\n\t      memcpy (dest->elems, dest->elems + sbase,\n\t\t      delta * sizeof (Idx));\n\t      break;\n\t    }\n\t}\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 77,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_insert": {
      "start_point": [
        1275,
        18
      ],
      "end_point": [
        1320,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_insert (re_node_set *set, Idx elem)\n{\n  Idx idx;\n  /* In case the set is empty.  */\n  if (set->alloc == 0)\n    return BE (re_node_set_init_1 (set, elem) == REG_NOERROR, 1);\n\n  if (BE (set->nelem, 0) == 0)\n    {\n      /* We already guaranteed above that set->alloc != 0.  */\n      set->elems[0] = elem;\n      ++set->nelem;\n      return true;\n    }\n\n  /* Realloc if we need.  */\n  if (set->alloc == set->nelem)\n    {\n      Idx *new_elems;\n      set->alloc = set->alloc * 2;\n      new_elems = re_realloc (set->elems, Idx, set->alloc);\n      if (BE (new_elems == NULL, 0))\n\treturn false;\n      set->elems = new_elems;\n    }\n\n  /* Move the elements which follows the new element.  Test the\n     first element separately to skip a check in the inner loop.  */\n  if (elem < set->elems[0])\n    {\n      idx = 0;\n      for (idx = set->nelem; idx > 0; idx--)\n\tset->elems[idx] = set->elems[idx - 1];\n    }\n  else\n    {\n      for (idx = set->nelem; set->elems[idx - 1] > elem; idx--)\n\tset->elems[idx] = set->elems[idx - 1];\n    }\n\n  /* Insert the new element.  */\n  set->elems[idx] = elem;\n  ++set->nelem;\n  return true;\n}",
      "lines": 46,
      "depth": 10,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_insert_last": {
      "start_point": [
        1327,
        18
      ],
      "end_point": [
        1344,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_insert_last (re_node_set *set, Idx elem)\n{\n  /* Realloc if we need.  */\n  if (set->alloc == set->nelem)\n    {\n      Idx *new_elems;\n      set->alloc = (set->alloc + 1) * 2;\n      new_elems = re_realloc (set->elems, Idx, set->alloc);\n      if (BE (new_elems == NULL, 0))\n\treturn false;\n      set->elems = new_elems;\n    }\n\n  /* Insert the new element.  */\n  set->elems[set->nelem++] = elem;\n  return true;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "pure": {
      "start_point": [
        1351,
        52
      ],
      "end_point": [
        1360,
        1
      ],
      "content": "re_node_set *set2)\n{\n  Idx i;\n  if (set1 == NULL || set2 == NULL || set1->nelem != set2->nelem)\n    return false;\n  for (i = set1->nelem ; --i >= 0 ; )\n    if (set1->elems[i] != set2->elems[i])\n      return false;\n  return true;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": null
    },
    "re_node_set_remove_at": {
      "start_point": [
        1386,
        0
      ],
      "end_point": [
        1395,
        1
      ],
      "content": "static void\ninternal_function\nre_node_set_remove_at (re_node_set *set, Idx idx)\n{\n  if (idx < 0 || idx >= set->nelem)\n    return;\n  --set->nelem;\n  for (; idx < set->nelem; idx++)\n    set->elems[idx] = set->elems[idx + 1];\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "re_dfa_add_node": {
      "start_point": [
        1401,
        0
      ],
      "end_point": [
        1453,
        1
      ],
      "content": "static Idx\ninternal_function\nre_dfa_add_node (re_dfa_t *dfa, re_token_t token)\n{\n  if (BE (dfa->nodes_len >= dfa->nodes_alloc, 0))\n    {\n      size_t new_nodes_alloc = dfa->nodes_alloc * 2;\n      Idx *new_nexts, *new_indices;\n      re_node_set *new_edests, *new_eclosures;\n      re_token_t *new_nodes;\n\n      /* Avoid overflows in realloc.  */\n      const size_t max_object_size = MAX (sizeof (re_token_t),\n\t\t\t\t\t  MAX (sizeof (re_node_set),\n\t\t\t\t\t       sizeof (Idx)));\n      if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) < new_nodes_alloc, 0))\n\treturn -1;\n\n      new_nodes = re_realloc (dfa->nodes, re_token_t, new_nodes_alloc);\n      if (BE (new_nodes == NULL, 0))\n\treturn -1;\n      dfa->nodes = new_nodes;\n      new_nexts = re_realloc (dfa->nexts, Idx, new_nodes_alloc);\n      new_indices = re_realloc (dfa->org_indices, Idx, new_nodes_alloc);\n      new_edests = re_realloc (dfa->edests, re_node_set, new_nodes_alloc);\n      new_eclosures = re_realloc (dfa->eclosures, re_node_set, new_nodes_alloc);\n      if (BE (new_nexts == NULL || new_indices == NULL\n\t      || new_edests == NULL || new_eclosures == NULL, 0))\n\t{\n\t   re_free (new_nexts);\n\t   re_free (new_indices);\n\t   re_free (new_edests);\n\t   re_free (new_eclosures);\n\t   return -1;\n\t}\n      dfa->nexts = new_nexts;\n      dfa->org_indices = new_indices;\n      dfa->edests = new_edests;\n      dfa->eclosures = new_eclosures;\n      dfa->nodes_alloc = new_nodes_alloc;\n    }\n  dfa->nodes[dfa->nodes_len] = token;\n  dfa->nodes[dfa->nodes_len].constraint = 0;\n#ifdef RE_ENABLE_I18N\n  dfa->nodes[dfa->nodes_len].accept_mb =\n    ((token.type == OP_PERIOD && dfa->mb_cur_max > 1)\n     || token.type == COMPLEX_BRACKET);\n#endif\n  dfa->nexts[dfa->nodes_len] = -1;\n  re_node_set_init_empty (dfa->edests + dfa->nodes_len);\n  re_node_set_init_empty (dfa->eclosures + dfa->nodes_len);\n  return dfa->nodes_len++;\n}",
      "lines": 53,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "calc_state_hash": {
      "start_point": [
        1455,
        0
      ],
      "end_point": [
        1464,
        1
      ],
      "content": "static re_hashval_t\ninternal_function\ncalc_state_hash (const re_node_set *nodes, unsigned int context)\n{\n  re_hashval_t hash = nodes->nelem + context;\n  Idx i;\n  for (i = 0 ; i < nodes->nelem ; i++)\n    hash += nodes->elems[i];\n  return hash;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "re_hashval_t",
        "internal_function",
        "internal_function"
      ]
    },
    "re_acquire_state": {
      "start_point": [
        1476,
        18
      ],
      "end_point": [
        1511,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_acquire_state (reg_errcode_t *err, const re_dfa_t *dfa,\n\t\t  const re_node_set *nodes)\n{\n  re_hashval_t hash;\n  re_dfastate_t *new_state;\n  struct re_state_table_entry *spot;\n  Idx i;\n#if defined GCC_LINT || defined lint\n  /* Suppress bogus uninitialized-variable warnings.  */\n  *err = REG_NOERROR;\n#endif\n  if (BE (nodes->nelem == 0, 0))\n    {\n      *err = REG_NOERROR;\n      return NULL;\n    }\n  hash = calc_state_hash (nodes, 0);\n  spot = dfa->state_table + (hash & dfa->state_hash_mask);\n\n  for (i = 0 ; i < spot->num ; i++)\n    {\n      re_dfastate_t *state = spot->array[i];\n      if (hash != state->hash)\n\tcontinue;\n      if (re_node_set_compare (&state->nodes, nodes))\n\treturn state;\n    }\n\n  /* There are no appropriate state in the dfa, create the new one.  */\n  new_state = create_ci_newstate (dfa, nodes, hash);\n  if (BE (new_state == NULL, 0))\n    *err = REG_ESPACE;\n\n  return new_state;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_acquire_state_context": {
      "start_point": [
        1524,
        18
      ],
      "end_point": [
        1558,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_acquire_state_context (reg_errcode_t *err, const re_dfa_t *dfa,\n\t\t\t  const re_node_set *nodes, unsigned int context)\n{\n  re_hashval_t hash;\n  re_dfastate_t *new_state;\n  struct re_state_table_entry *spot;\n  Idx i;\n#if defined GCC_LINT || defined lint\n  /* Suppress bogus uninitialized-variable warnings.  */\n  *err = REG_NOERROR;\n#endif\n  if (nodes->nelem == 0)\n    {\n      *err = REG_NOERROR;\n      return NULL;\n    }\n  hash = calc_state_hash (nodes, context);\n  spot = dfa->state_table + (hash & dfa->state_hash_mask);\n\n  for (i = 0 ; i < spot->num ; i++)\n    {\n      re_dfastate_t *state = spot->array[i];\n      if (state->hash == hash\n\t  && state->context == context\n\t  && re_node_set_compare (state->entrance_nodes, nodes))\n\treturn state;\n    }\n  /* There are no appropriate state in 'dfa', create the new one.  */\n  new_state = create_cd_newstate (dfa, nodes, context, hash);\n  if (BE (new_state == NULL, 0))\n    *err = REG_ESPACE;\n\n  return new_state;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "register_state": {
      "start_point": [
        1564,
        0
      ],
      "end_point": [
        1598,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nregister_state (const re_dfa_t *dfa, re_dfastate_t *newstate,\n\t\tre_hashval_t hash)\n{\n  struct re_state_table_entry *spot;\n  reg_errcode_t err;\n  Idx i;\n\n  newstate->hash = hash;\n  err = re_node_set_alloc (&newstate->non_eps_nodes, newstate->nodes.nelem);\n  if (BE (err != REG_NOERROR, 0))\n    return REG_ESPACE;\n  for (i = 0; i < newstate->nodes.nelem; i++)\n    {\n      Idx elem = newstate->nodes.elems[i];\n      if (!IS_EPSILON_NODE (dfa->nodes[elem].type))\n\tif (! re_node_set_insert_last (&newstate->non_eps_nodes, elem))\n\t  return REG_ESPACE;\n    }\n\n  spot = dfa->state_table + (hash & dfa->state_hash_mask);\n  if (BE (spot->alloc <= spot->num, 0))\n    {\n      Idx new_alloc = 2 * spot->num + 2;\n      re_dfastate_t **new_array = re_realloc (spot->array, re_dfastate_t *,\n\t\t\t\t\t      new_alloc);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      spot->array = new_array;\n      spot->alloc = new_alloc;\n    }\n  spot->array[spot->num++] = newstate;\n  return REG_NOERROR;\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "free_state": {
      "start_point": [
        1600,
        0
      ],
      "end_point": [
        1614,
        1
      ],
      "content": "static void\nfree_state (re_dfastate_t *state)\n{\n  re_node_set_free (&state->non_eps_nodes);\n  re_node_set_free (&state->inveclosure);\n  if (state->entrance_nodes != &state->nodes)\n    {\n      re_node_set_free (state->entrance_nodes);\n      re_free (state->entrance_nodes);\n    }\n  re_node_set_free (&state->nodes);\n  re_free (state->word_trtable);\n  re_free (state->trtable);\n  re_free (state);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_ci_newstate": {
      "start_point": [
        1620,
        18
      ],
      "end_point": [
        1664,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncreate_ci_newstate (const re_dfa_t *dfa, const re_node_set *nodes,\n\t\t    re_hashval_t hash)\n{\n  Idx i;\n  reg_errcode_t err;\n  re_dfastate_t *newstate;\n\n  newstate = (re_dfastate_t *) calloc (sizeof (re_dfastate_t), 1);\n  if (BE (newstate == NULL, 0))\n    return NULL;\n  err = re_node_set_init_copy (&newstate->nodes, nodes);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      re_free (newstate);\n      return NULL;\n    }\n\n  newstate->entrance_nodes = &newstate->nodes;\n  for (i = 0 ; i < nodes->nelem ; i++)\n    {\n      re_token_t *node = dfa->nodes + nodes->elems[i];\n      re_token_type_t type = node->type;\n      if (type == CHARACTER && !node->constraint)\n\tcontinue;\n#ifdef RE_ENABLE_I18N\n      newstate->accept_mb |= node->accept_mb;\n#endif /* RE_ENABLE_I18N */\n\n      /* If the state has the halt node, the state is a halt state.  */\n      if (type == END_OF_RE)\n\tnewstate->halt = 1;\n      else if (type == OP_BACK_REF)\n\tnewstate->has_backref = 1;\n      else if (type == ANCHOR || node->constraint)\n\tnewstate->has_constraint = 1;\n    }\n  err = register_state (dfa, newstate, hash);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      free_state (newstate);\n      newstate = NULL;\n    }\n  return newstate;\n}",
      "lines": 45,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "create_cd_newstate": {
      "start_point": [
        1670,
        18
      ],
      "end_point": [
        1740,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncreate_cd_newstate (const re_dfa_t *dfa, const re_node_set *nodes,\n\t\t    unsigned int context, re_hashval_t hash)\n{\n  Idx i, nctx_nodes = 0;\n  reg_errcode_t err;\n  re_dfastate_t *newstate;\n\n  newstate = (re_dfastate_t *) calloc (sizeof (re_dfastate_t), 1);\n  if (BE (newstate == NULL, 0))\n    return NULL;\n  err = re_node_set_init_copy (&newstate->nodes, nodes);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      re_free (newstate);\n      return NULL;\n    }\n\n  newstate->context = context;\n  newstate->entrance_nodes = &newstate->nodes;\n\n  for (i = 0 ; i < nodes->nelem ; i++)\n    {\n      re_token_t *node = dfa->nodes + nodes->elems[i];\n      re_token_type_t type = node->type;\n      unsigned int constraint = node->constraint;\n\n      if (type == CHARACTER && !constraint)\n\tcontinue;\n#ifdef RE_ENABLE_I18N\n      newstate->accept_mb |= node->accept_mb;\n#endif /* RE_ENABLE_I18N */\n\n      /* If the state has the halt node, the state is a halt state.  */\n      if (type == END_OF_RE)\n\tnewstate->halt = 1;\n      else if (type == OP_BACK_REF)\n\tnewstate->has_backref = 1;\n\n      if (constraint)\n\t{\n\t  if (newstate->entrance_nodes == &newstate->nodes)\n\t    {\n\t      newstate->entrance_nodes = re_malloc (re_node_set, 1);\n\t      if (BE (newstate->entrance_nodes == NULL, 0))\n\t\t{\n\t\t  free_state (newstate);\n\t\t  return NULL;\n\t\t}\n\t      if (re_node_set_init_copy (newstate->entrance_nodes, nodes)\n\t\t  != REG_NOERROR)\n\t\treturn NULL;\n\t      nctx_nodes = 0;\n\t      newstate->has_constraint = 1;\n\t    }\n\n\t  if (NOT_SATISFY_PREV_CONSTRAINT (constraint,context))\n\t    {\n\t      re_node_set_remove_at (&newstate->nodes, i - nctx_nodes);\n\t      ++nctx_nodes;\n\t    }\n\t}\n    }\n  err = register_state (dfa, newstate, hash);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      free_state (newstate);\n      newstate = NULL;\n    }\n  return  newstate;\n}",
      "lines": 71,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/regex_internal.h": {
    "bitset_set": {
      "start_point": [
        763,
        0
      ],
      "end_point": [
        767,
        1
      ],
      "content": "static void\nbitset_set (bitset_t set, Idx i)\n{\n  set[i / BITSET_WORD_BITS] |= (bitset_word_t) 1 << i % BITSET_WORD_BITS;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_clear": {
      "start_point": [
        769,
        0
      ],
      "end_point": [
        773,
        1
      ],
      "content": "static void\nbitset_clear (bitset_t set, Idx i)\n{\n  set[i / BITSET_WORD_BITS] &= ~ ((bitset_word_t) 1 << i % BITSET_WORD_BITS);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_contain": {
      "start_point": [
        775,
        0
      ],
      "end_point": [
        779,
        1
      ],
      "content": "static bool\nbitset_contain (const bitset_t set, Idx i)\n{\n  return (set[i / BITSET_WORD_BITS] >> i % BITSET_WORD_BITS) & 1;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "bitset_empty": {
      "start_point": [
        781,
        0
      ],
      "end_point": [
        785,
        1
      ],
      "content": "static void\nbitset_empty (bitset_t set)\n{\n  memset (set, '\\0', sizeof (bitset_t));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_set_all": {
      "start_point": [
        787,
        0
      ],
      "end_point": [
        794,
        1
      ],
      "content": "static void\nbitset_set_all (bitset_t set)\n{\n  memset (set, -1, sizeof (bitset_word_t) * (SBC_MAX / BITSET_WORD_BITS));\n  if (SBC_MAX % BITSET_WORD_BITS != 0)\n    set[BITSET_WORDS - 1] =\n      ((bitset_word_t) 1 << SBC_MAX % BITSET_WORD_BITS) - 1;\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_copy": {
      "start_point": [
        796,
        0
      ],
      "end_point": [
        800,
        1
      ],
      "content": "static void\nbitset_copy (bitset_t dest, const bitset_t src)\n{\n  memcpy (dest, src, sizeof (bitset_t));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_not": {
      "start_point": [
        802,
        0
      ],
      "end_point": [
        812,
        1
      ],
      "content": "static void __attribute__ ((unused))\nbitset_not (bitset_t set)\n{\n  int bitset_i;\n  for (bitset_i = 0; bitset_i < SBC_MAX / BITSET_WORD_BITS; ++bitset_i)\n    set[bitset_i] = ~set[bitset_i];\n  if (SBC_MAX % BITSET_WORD_BITS != 0)\n    set[BITSET_WORDS - 1] =\n      ((((bitset_word_t) 1 << SBC_MAX % BITSET_WORD_BITS) - 1)\n       & ~set[BITSET_WORDS - 1]);\n}",
      "lines": 11,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void",
        "__attribute__ ((unused))",
        "__attribute__",
        "(",
        "(unused)",
        "(",
        "unused",
        ")",
        ")"
      ]
    },
    "bitset_merge": {
      "start_point": [
        814,
        0
      ],
      "end_point": [
        820,
        1
      ],
      "content": "static void __attribute__ ((unused))\nbitset_merge (bitset_t dest, const bitset_t src)\n{\n  int bitset_i;\n  for (bitset_i = 0; bitset_i < BITSET_WORDS; ++bitset_i)\n    dest[bitset_i] |= src[bitset_i];\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "__attribute__ ((unused))",
        "__attribute__",
        "(",
        "(unused)",
        "(",
        "unused",
        ")",
        ")"
      ]
    },
    "bitset_mask": {
      "start_point": [
        822,
        0
      ],
      "end_point": [
        828,
        1
      ],
      "content": "static void __attribute__ ((unused))\nbitset_mask (bitset_t dest, const bitset_t src)\n{\n  int bitset_i;\n  for (bitset_i = 0; bitset_i < BITSET_WORDS; ++bitset_i)\n    dest[bitset_i] &= src[bitset_i];\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "__attribute__ ((unused))",
        "__attribute__",
        "(",
        "(unused)",
        "(",
        "unused",
        ")",
        ")"
      ]
    },
    "internal_function": [
      {
        "start_point": [
          833,
          18
        ],
        "end_point": [
          843,
          1
        ],
        "content": "__attribute__ ((pure, unused))\nre_string_char_size_at (const re_string_t *pstr, Idx idx)\n{\n  int byte_idx;\n  if (pstr->mb_cur_max == 1)\n    return 1;\n  for (byte_idx = 1; idx + byte_idx < pstr->valid_len; ++byte_idx)\n    if (pstr->wcs[idx + byte_idx] != WEOF)\n      break;\n  return byte_idx;\n}",
        "lines": 11,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          846,
          18
        ],
        "end_point": [
          852,
          1
        ],
        "content": "__attribute__ ((pure, unused))\nre_string_wchar_at (const re_string_t *pstr, Idx idx)\n{\n  if (pstr->mb_cur_max == 1)\n    return (wint_t) pstr->mbs[idx];\n  return (wint_t) pstr->wcs[idx];\n}",
        "lines": 7,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          859,
          18
        ],
        "end_point": [
          881,
          1
        ],
        "content": "__attribute__ ((pure, unused))\nre_string_elem_size_at (const re_string_t *pstr, Idx idx)\n{\n# ifdef _LIBC\n  const unsigned char *p, *extra;\n  const int32_t *table, *indirect;\n  uint_fast32_t nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n\n  if (nrules != 0)\n    {\n      table = (const int32_t *) _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n      extra = (const unsigned char *)\n\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAMB);\n      indirect = (const int32_t *) _NL_CURRENT (LC_COLLATE,\n\t\t\t\t\t\t_NL_COLLATE_INDIRECTMB);\n      p = pstr->mbs + idx;\n      findidx (table, indirect, extra, &p, pstr->len - idx);\n      return p - pstr->mbs - idx;\n    }\n  else\n# endif /* _LIBC */\n    return 1;\n}",
        "lines": 23,
        "depth": 11,
        "decorators": null
      }
    ]
  },
  "texinfo/texinfo-6.5/gnulib/lib/size_max.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/stdarg.in.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/stdbool.in.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/stddef.in.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/stdint.in.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/stdio.in.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/stdlib.in.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/stpcpy.c": {
    "__stpcpy": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "char *\n__stpcpy (char *dest, const char *src)\n{\n  register char *d = dest;\n  register const char *s = src;\n\n  do\n    *d++ = *s;\n  while (*s++ != '\\0');\n\n  return d - 1;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "char",
        "*\n__stpcpy (char *dest, const char *src)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/str-kmp.h": {
    "knuth_morris_pratt": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "static bool\nknuth_morris_pratt (const UNIT *haystack,\n                    const UNIT *needle, size_t needle_len,\n                    const UNIT **resultp)\n{\n  size_t m = needle_len;\n\n  /* Allocate the table.  */\n  size_t *table = (size_t *) nmalloca (m, sizeof (size_t));\n  if (table == NULL)\n    return false;\n  /* Fill the table.\n     For 0 < i < m:\n       0 < table[i] <= i is defined such that\n       forall 0 < x < table[i]: needle[x..i-1] != needle[0..i-1-x],\n       and table[i] is as large as possible with this property.\n     This implies:\n     1) For 0 < i < m:\n          If table[i] < i,\n          needle[table[i]..i-1] = needle[0..i-1-table[i]].\n     2) For 0 < i < m:\n          rhaystack[0..i-1] == needle[0..i-1]\n          and exists h, i <= h < m: rhaystack[h] != needle[h]\n          implies\n          forall 0 <= x < table[i]: rhaystack[x..x+m-1] != needle[0..m-1].\n     table[0] remains uninitialized.  */\n  {\n    size_t i, j;\n\n    /* i = 1: Nothing to verify for x = 0.  */\n    table[1] = 1;\n    j = 0;\n\n    for (i = 2; i < m; i++)\n      {\n        /* Here: j = i-1 - table[i-1].\n           The inequality needle[x..i-1] != needle[0..i-1-x] is known to hold\n           for x < table[i-1], by induction.\n           Furthermore, if j>0: needle[i-1-j..i-2] = needle[0..j-1].  */\n        UNIT b = CANON_ELEMENT (needle[i - 1]);\n\n        for (;;)\n          {\n            /* Invariants: The inequality needle[x..i-1] != needle[0..i-1-x]\n               is known to hold for x < i-1-j.\n               Furthermore, if j>0: needle[i-1-j..i-2] = needle[0..j-1].  */\n            if (b == CANON_ELEMENT (needle[j]))\n              {\n                /* Set table[i] := i-1-j.  */\n                table[i] = i - ++j;\n                break;\n              }\n            /* The inequality needle[x..i-1] != needle[0..i-1-x] also holds\n               for x = i-1-j, because\n                 needle[i-1] != needle[j] = needle[i-1-x].  */\n            if (j == 0)\n              {\n                /* The inequality holds for all possible x.  */\n                table[i] = i;\n                break;\n              }\n            /* The inequality needle[x..i-1] != needle[0..i-1-x] also holds\n               for i-1-j < x < i-1-j+table[j], because for these x:\n                 needle[x..i-2]\n                 = needle[x-(i-1-j)..j-1]\n                 != needle[0..j-1-(x-(i-1-j))]  (by definition of table[j])\n                    = needle[0..i-2-x],\n               hence needle[x..i-1] != needle[0..i-1-x].\n               Furthermore\n                 needle[i-1-j+table[j]..i-2]\n                 = needle[table[j]..j-1]\n                 = needle[0..j-1-table[j]]  (by definition of table[j]).  */\n            j = j - table[j];\n          }\n        /* Here: j = i - table[i].  */\n      }\n  }\n\n  /* Search, using the table to accelerate the processing.  */\n  {\n    size_t j;\n    const UNIT *rhaystack;\n    const UNIT *phaystack;\n\n    *resultp = NULL;\n    j = 0;\n    rhaystack = haystack;\n    phaystack = haystack;\n    /* Invariant: phaystack = rhaystack + j.  */\n    while (*phaystack != 0)\n      if (CANON_ELEMENT (needle[j]) == CANON_ELEMENT (*phaystack))\n        {\n          j++;\n          phaystack++;\n          if (j == m)\n            {\n              /* The entire needle has been found.  */\n              *resultp = rhaystack;\n              break;\n            }\n        }\n      else if (j > 0)\n        {\n          /* Found a match of needle[0..j-1], mismatch at needle[j].  */\n          rhaystack += table[j];\n          j -= table[j];\n        }\n      else\n        {\n          /* Found a mismatch at needle[0] already.  */\n          rhaystack++;\n          phaystack++;\n        }\n  }\n\n  freea (table);\n  return true;\n}",
      "lines": 118,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/str-two-way.h": {
    "critical_factorization": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "static size_t\ncritical_factorization (const unsigned char *needle, size_t needle_len,\n                        size_t *period)\n{\n  /* Index of last byte of left half, or SIZE_MAX.  */\n  size_t max_suffix, max_suffix_rev;\n  size_t j; /* Index into NEEDLE for current candidate suffix.  */\n  size_t k; /* Offset into current period.  */\n  size_t p; /* Intermediate period.  */\n  unsigned char a, b; /* Current comparison bytes.  */\n\n  /* Special case NEEDLE_LEN of 1 or 2 (all callers already filtered\n     out 0-length needles.  */\n  if (needle_len < 3)\n    {\n      *period = 1;\n      return needle_len - 1;\n    }\n\n  /* Invariants:\n     0 <= j < NEEDLE_LEN - 1\n     -1 <= max_suffix{,_rev} < j (treating SIZE_MAX as if it were signed)\n     min(max_suffix, max_suffix_rev) < global period of NEEDLE\n     1 <= p <= global period of NEEDLE\n     p == global period of the substring NEEDLE[max_suffix{,_rev}+1...j]\n     1 <= k <= p\n  */\n\n  /* Perform lexicographic search.  */\n  max_suffix = SIZE_MAX;\n  j = 0;\n  k = p = 1;\n  while (j + k < needle_len)\n    {\n      a = CANON_ELEMENT (needle[j + k]);\n      b = CANON_ELEMENT (needle[max_suffix + k]);\n      if (a < b)\n        {\n          /* Suffix is smaller, period is entire prefix so far.  */\n          j += k;\n          k = 1;\n          p = j - max_suffix;\n        }\n      else if (a == b)\n        {\n          /* Advance through repetition of the current period.  */\n          if (k != p)\n            ++k;\n          else\n            {\n              j += p;\n              k = 1;\n            }\n        }\n      else /* b < a */\n        {\n          /* Suffix is larger, start over from current location.  */\n          max_suffix = j++;\n          k = p = 1;\n        }\n    }\n  *period = p;\n\n  /* Perform reverse lexicographic search.  */\n  max_suffix_rev = SIZE_MAX;\n  j = 0;\n  k = p = 1;\n  while (j + k < needle_len)\n    {\n      a = CANON_ELEMENT (needle[j + k]);\n      b = CANON_ELEMENT (needle[max_suffix_rev + k]);\n      if (b < a)\n        {\n          /* Suffix is smaller, period is entire prefix so far.  */\n          j += k;\n          k = 1;\n          p = j - max_suffix_rev;\n        }\n      else if (a == b)\n        {\n          /* Advance through repetition of the current period.  */\n          if (k != p)\n            ++k;\n          else\n            {\n              j += p;\n              k = 1;\n            }\n        }\n      else /* a < b */\n        {\n          /* Suffix is larger, start over from current location.  */\n          max_suffix_rev = j++;\n          k = p = 1;\n        }\n    }\n\n  /* Choose the shorter suffix.  Return the index of the first byte of\n     the right half, rather than the last byte of the left half.\n\n     For some examples, 'banana' has two critical factorizations, both\n     exposed by the two lexicographic extreme suffixes of 'anana' and\n     'nana', where both suffixes have a period of 2.  On the other\n     hand, with 'aab' and 'bba', both strings have a single critical\n     factorization of the last byte, with the suffix having a period\n     of 1.  While the maximal lexicographic suffix of 'aab' is 'b',\n     the maximal lexicographic suffix of 'bba' is 'ba', which is not a\n     critical factorization.  Conversely, the maximal reverse\n     lexicographic suffix of 'a' works for 'bba', but not 'ab' for\n     'aab'.  The shorter suffix of the two will always be a critical\n     factorization.  */\n  if (max_suffix_rev + 1 < max_suffix + 1)\n    return max_suffix + 1;\n  *period = p;\n  return max_suffix_rev + 1;\n}",
      "lines": 116,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "two_way_short_needle": {
      "start_point": [
        233,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "static RETURN_TYPE\ntwo_way_short_needle (const unsigned char *haystack, size_t haystack_len,\n                      const unsigned char *needle, size_t needle_len)\n{\n  size_t i; /* Index into current byte of NEEDLE.  */\n  size_t j; /* Index into current window of HAYSTACK.  */\n  size_t period; /* The period of the right half of needle.  */\n  size_t suffix; /* The index of the right half of needle.  */\n\n  /* Factor the needle into two halves, such that the left half is\n     smaller than the global period, and the right half is\n     periodic (with a period as large as NEEDLE_LEN - suffix).  */\n  suffix = critical_factorization (needle, needle_len, &period);\n\n  /* Perform the search.  Each iteration compares the right half\n     first.  */\n  if (CMP_FUNC (needle, needle + period, suffix) == 0)\n    {\n      /* Entire needle is periodic; a mismatch in the left half can\n         only advance by the period, so use memory to avoid rescanning\n         known occurrences of the period in the right half.  */\n      size_t memory = 0;\n      j = 0;\n      while (AVAILABLE (haystack, haystack_len, j, needle_len))\n        {\n          /* Scan for matches in right half.  */\n          i = MAX (suffix, memory);\n          while (i < needle_len && (CANON_ELEMENT (needle[i])\n                                    == CANON_ELEMENT (haystack[i + j])))\n            ++i;\n          if (needle_len <= i)\n            {\n              /* Scan for matches in left half.  */\n              i = suffix - 1;\n              while (memory < i + 1 && (CANON_ELEMENT (needle[i])\n                                        == CANON_ELEMENT (haystack[i + j])))\n                --i;\n              if (i + 1 < memory + 1)\n                return (RETURN_TYPE) (haystack + j);\n              /* No match, so remember how many repetitions of period\n                 on the right half were scanned.  */\n              j += period;\n              memory = needle_len - period;\n            }\n          else\n            {\n              j += i - suffix + 1;\n              memory = 0;\n            }\n        }\n    }\n  else\n    {\n      /* The two halves of needle are distinct; no extra memory is\n         required, and any mismatch results in a maximal shift.  */\n      period = MAX (suffix, needle_len - suffix) + 1;\n      j = 0;\n      while (AVAILABLE (haystack, haystack_len, j, needle_len))\n        {\n          /* Scan for matches in right half.  */\n          i = suffix;\n          while (i < needle_len && (CANON_ELEMENT (needle[i])\n                                    == CANON_ELEMENT (haystack[i + j])))\n            ++i;\n          if (needle_len <= i)\n            {\n              /* Scan for matches in left half.  */\n              i = suffix - 1;\n              while (i != SIZE_MAX && (CANON_ELEMENT (needle[i])\n                                       == CANON_ELEMENT (haystack[i + j])))\n                --i;\n              if (i == SIZE_MAX)\n                return (RETURN_TYPE) (haystack + j);\n              j += period;\n            }\n          else\n            j += i - suffix + 1;\n        }\n    }\n  return NULL;\n}",
      "lines": 81,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "RETURN_TYPE"
      ]
    },
    "two_way_long_needle": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        445,
        1
      ],
      "content": "static RETURN_TYPE\ntwo_way_long_needle (const unsigned char *haystack, size_t haystack_len,\n                     const unsigned char *needle, size_t needle_len)\n{\n  size_t i; /* Index into current byte of NEEDLE.  */\n  size_t j; /* Index into current window of HAYSTACK.  */\n  size_t period; /* The period of the right half of needle.  */\n  size_t suffix; /* The index of the right half of needle.  */\n  size_t shift_table[1U << CHAR_BIT]; /* See below.  */\n\n  /* Factor the needle into two halves, such that the left half is\n     smaller than the global period, and the right half is\n     periodic (with a period as large as NEEDLE_LEN - suffix).  */\n  suffix = critical_factorization (needle, needle_len, &period);\n\n  /* Populate shift_table.  For each possible byte value c,\n     shift_table[c] is the distance from the last occurrence of c to\n     the end of NEEDLE, or NEEDLE_LEN if c is absent from the NEEDLE.\n     shift_table[NEEDLE[NEEDLE_LEN - 1]] contains the only 0.  */\n  for (i = 0; i < 1U << CHAR_BIT; i++)\n    shift_table[i] = needle_len;\n  for (i = 0; i < needle_len; i++)\n    shift_table[CANON_ELEMENT (needle[i])] = needle_len - i - 1;\n\n  /* Perform the search.  Each iteration compares the right half\n     first.  */\n  if (CMP_FUNC (needle, needle + period, suffix) == 0)\n    {\n      /* Entire needle is periodic; a mismatch in the left half can\n         only advance by the period, so use memory to avoid rescanning\n         known occurrences of the period in the right half.  */\n      size_t memory = 0;\n      size_t shift;\n      j = 0;\n      while (AVAILABLE (haystack, haystack_len, j, needle_len))\n        {\n          /* Check the last byte first; if it does not match, then\n             shift to the next possible match location.  */\n          shift = shift_table[CANON_ELEMENT (haystack[j + needle_len - 1])];\n          if (0 < shift)\n            {\n              if (memory && shift < period)\n                {\n                  /* Since needle is periodic, but the last period has\n                     a byte out of place, there can be no match until\n                     after the mismatch.  */\n                  shift = needle_len - period;\n                }\n              memory = 0;\n              j += shift;\n              continue;\n            }\n          /* Scan for matches in right half.  The last byte has\n             already been matched, by virtue of the shift table.  */\n          i = MAX (suffix, memory);\n          while (i < needle_len - 1 && (CANON_ELEMENT (needle[i])\n                                        == CANON_ELEMENT (haystack[i + j])))\n            ++i;\n          if (needle_len - 1 <= i)\n            {\n              /* Scan for matches in left half.  */\n              i = suffix - 1;\n              while (memory < i + 1 && (CANON_ELEMENT (needle[i])\n                                        == CANON_ELEMENT (haystack[i + j])))\n                --i;\n              if (i + 1 < memory + 1)\n                return (RETURN_TYPE) (haystack + j);\n              /* No match, so remember how many repetitions of period\n                 on the right half were scanned.  */\n              j += period;\n              memory = needle_len - period;\n            }\n          else\n            {\n              j += i - suffix + 1;\n              memory = 0;\n            }\n        }\n    }\n  else\n    {\n      /* The two halves of needle are distinct; no extra memory is\n         required, and any mismatch results in a maximal shift.  */\n      size_t shift;\n      period = MAX (suffix, needle_len - suffix) + 1;\n      j = 0;\n      while (AVAILABLE (haystack, haystack_len, j, needle_len))\n        {\n          /* Check the last byte first; if it does not match, then\n             shift to the next possible match location.  */\n          shift = shift_table[CANON_ELEMENT (haystack[j + needle_len - 1])];\n          if (0 < shift)\n            {\n              j += shift;\n              continue;\n            }\n          /* Scan for matches in right half.  The last byte has\n             already been matched, by virtue of the shift table.  */\n          i = suffix;\n          while (i < needle_len - 1 && (CANON_ELEMENT (needle[i])\n                                        == CANON_ELEMENT (haystack[i + j])))\n            ++i;\n          if (needle_len - 1 <= i)\n            {\n              /* Scan for matches in left half.  */\n              i = suffix - 1;\n              while (i != SIZE_MAX && (CANON_ELEMENT (needle[i])\n                                       == CANON_ELEMENT (haystack[i + j])))\n                --i;\n              if (i == SIZE_MAX)\n                return (RETURN_TYPE) (haystack + j);\n              j += period;\n            }\n          else\n            j += i - suffix + 1;\n        }\n    }\n  return NULL;\n}",
      "lines": 119,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "RETURN_TYPE"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/strcasecmp.c": {
    "strcasecmp": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nstrcasecmp (const char *s1, const char *s2)\n{\n  const unsigned char *p1 = (const unsigned char *) s1;\n  const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2)\n    return 0;\n\n  do\n    {\n      c1 = TOLOWER (*p1);\n      c2 = TOLOWER (*p2);\n\n      if (c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/strcasestr.c": {
    "strcasestr": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "char *\nstrcasestr (const char *haystack_start, const char *needle_start)\n{\n  const char *haystack = haystack_start;\n  const char *needle = needle_start;\n  size_t needle_len; /* Length of NEEDLE.  */\n  size_t haystack_len; /* Known minimum length of HAYSTACK.  */\n  bool ok = true; /* True if NEEDLE is prefix of HAYSTACK.  */\n\n  /* Determine length of NEEDLE, and in the process, make sure\n     HAYSTACK is at least as long (no point processing all of a long\n     NEEDLE if HAYSTACK is too short).  */\n  while (*haystack && *needle)\n    {\n      ok &= (TOLOWER ((unsigned char) *haystack)\n             == TOLOWER ((unsigned char) *needle));\n      haystack++;\n      needle++;\n    }\n  if (*needle)\n    return NULL;\n  if (ok)\n    return (char *) haystack_start;\n  needle_len = needle - needle_start;\n  haystack = haystack_start + 1;\n  haystack_len = needle_len - 1;\n\n  /* Perform the search.  Abstract memory is considered to be an array\n     of 'unsigned char' values, not an array of 'char' values.  See\n     ISO C 99 section 6.2.6.1.  */\n  if (needle_len < LONG_NEEDLE_THRESHOLD)\n    return two_way_short_needle ((const unsigned char *) haystack,\n                                 haystack_len,\n                                 (const unsigned char *) needle_start,\n                                 needle_len);\n  return two_way_long_needle ((const unsigned char *) haystack, haystack_len,\n                              (const unsigned char *) needle_start,\n                              needle_len);\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "char",
        "*\nstrcasestr (const char *haystack_start, const char *needle_start)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/strdup.c": {
    "__strdup": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "char *\n__strdup (const char *s)\n{\n  size_t len = strlen (s) + 1;\n  void *new = malloc (len);\n\n  if (new == NULL)\n    return NULL;\n\n  return (char *) memcpy (new, s, len);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "char",
        "*\n__strdup (const char *s)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/streq.h": {
    "streq9": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static inline int\nstreq9 (const char *s1, const char *s2)\n{\n  return strcmp (s1 + 9, s2 + 9) == 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq8": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static inline int\nstreq8 (const char *s1, const char *s2, char s28)\n{\n  if (s1[8] == s28)\n    {\n      if (s28 == 0)\n        return 1;\n      else\n        return streq9 (s1, s2);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq7": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static inline int\nstreq7 (const char *s1, const char *s2, char s27, char s28)\n{\n  if (s1[7] == s27)\n    {\n      if (s27 == 0)\n        return 1;\n      else\n        return streq8 (s1, s2, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq6": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static inline int\nstreq6 (const char *s1, const char *s2, char s26, char s27, char s28)\n{\n  if (s1[6] == s26)\n    {\n      if (s26 == 0)\n        return 1;\n      else\n        return streq7 (s1, s2, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq5": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static inline int\nstreq5 (const char *s1, const char *s2, char s25, char s26, char s27, char s28)\n{\n  if (s1[5] == s25)\n    {\n      if (s25 == 0)\n        return 1;\n      else\n        return streq6 (s1, s2, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq4": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static inline int\nstreq4 (const char *s1, const char *s2, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[4] == s24)\n    {\n      if (s24 == 0)\n        return 1;\n      else\n        return streq5 (s1, s2, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq3": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static inline int\nstreq3 (const char *s1, const char *s2, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[3] == s23)\n    {\n      if (s23 == 0)\n        return 1;\n      else\n        return streq4 (s1, s2, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq2": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static inline int\nstreq2 (const char *s1, const char *s2, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[2] == s22)\n    {\n      if (s22 == 0)\n        return 1;\n      else\n        return streq3 (s1, s2, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq1": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "static inline int\nstreq1 (const char *s1, const char *s2, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[1] == s21)\n    {\n      if (s21 == 0)\n        return 1;\n      else\n        return streq2 (s1, s2, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq0": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "static inline int\nstreq0 (const char *s1, const char *s2, char s20, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[0] == s20)\n    {\n      if (s20 == 0)\n        return 1;\n      else\n        return streq1 (s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/strerror-override.c": {
    "strerror_override": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "const char *\nstrerror_override (int errnum)\n{\n  /* These error messages are taken from glibc/sysdeps/gnu/errlist.c.  */\n  switch (errnum)\n    {\n#if REPLACE_STRERROR_0\n    case 0:\n      return \"Success\";\n#endif\n\n#if GNULIB_defined_ESOCK /* native Windows platforms with older <errno.h> */\n    case EINPROGRESS:\n      return \"Operation now in progress\";\n    case EALREADY:\n      return \"Operation already in progress\";\n    case ENOTSOCK:\n      return \"Socket operation on non-socket\";\n    case EDESTADDRREQ:\n      return \"Destination address required\";\n    case EMSGSIZE:\n      return \"Message too long\";\n    case EPROTOTYPE:\n      return \"Protocol wrong type for socket\";\n    case ENOPROTOOPT:\n      return \"Protocol not available\";\n    case EPROTONOSUPPORT:\n      return \"Protocol not supported\";\n    case EOPNOTSUPP:\n      return \"Operation not supported\";\n    case EAFNOSUPPORT:\n      return \"Address family not supported by protocol\";\n    case EADDRINUSE:\n      return \"Address already in use\";\n    case EADDRNOTAVAIL:\n      return \"Cannot assign requested address\";\n    case ENETDOWN:\n      return \"Network is down\";\n    case ENETUNREACH:\n      return \"Network is unreachable\";\n    case ECONNRESET:\n      return \"Connection reset by peer\";\n    case ENOBUFS:\n      return \"No buffer space available\";\n    case EISCONN:\n      return \"Transport endpoint is already connected\";\n    case ENOTCONN:\n      return \"Transport endpoint is not connected\";\n    case ETIMEDOUT:\n      return \"Connection timed out\";\n    case ECONNREFUSED:\n      return \"Connection refused\";\n    case ELOOP:\n      return \"Too many levels of symbolic links\";\n    case EHOSTUNREACH:\n      return \"No route to host\";\n    case EWOULDBLOCK:\n      return \"Operation would block\";\n#endif\n#if GNULIB_defined_ESTREAMS /* native Windows platforms with older <errno.h> */\n    case ETXTBSY:\n      return \"Text file busy\";\n    case ENODATA:\n      return \"No data available\";\n    case ENOSR:\n      return \"Out of streams resources\";\n    case ENOSTR:\n      return \"Device not a stream\";\n    case ETIME:\n      return \"Timer expired\";\n    case EOTHER:\n      return \"Other error\";\n#endif\n#if GNULIB_defined_EWINSOCK /* native Windows platforms */\n    case ESOCKTNOSUPPORT:\n      return \"Socket type not supported\";\n    case EPFNOSUPPORT:\n      return \"Protocol family not supported\";\n    case ESHUTDOWN:\n      return \"Cannot send after transport endpoint shutdown\";\n    case ETOOMANYREFS:\n      return \"Too many references: cannot splice\";\n    case EHOSTDOWN:\n      return \"Host is down\";\n    case EPROCLIM:\n      return \"Too many processes\";\n    case EUSERS:\n      return \"Too many users\";\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n    case ESTALE:\n      return \"Stale NFS file handle\";\n    case EREMOTE:\n      return \"Object is remote\";\n# if HAVE_WINSOCK2_H\n      /* WSA_INVALID_HANDLE maps to EBADF */\n      /* WSA_NOT_ENOUGH_MEMORY maps to ENOMEM */\n      /* WSA_INVALID_PARAMETER maps to EINVAL */\n    case WSA_OPERATION_ABORTED:\n      return \"Overlapped operation aborted\";\n    case WSA_IO_INCOMPLETE:\n      return \"Overlapped I/O event object not in signaled state\";\n    case WSA_IO_PENDING:\n      return \"Overlapped operations will complete later\";\n      /* WSAEINTR maps to EINTR */\n      /* WSAEBADF maps to EBADF */\n      /* WSAEACCES maps to EACCES */\n      /* WSAEFAULT maps to EFAULT */\n      /* WSAEINVAL maps to EINVAL */\n      /* WSAEMFILE maps to EMFILE */\n      /* WSAEWOULDBLOCK maps to EWOULDBLOCK */\n      /* WSAEINPROGRESS maps to EINPROGRESS */\n      /* WSAEALREADY maps to EALREADY */\n      /* WSAENOTSOCK maps to ENOTSOCK */\n      /* WSAEDESTADDRREQ maps to EDESTADDRREQ */\n      /* WSAEMSGSIZE maps to EMSGSIZE */\n      /* WSAEPROTOTYPE maps to EPROTOTYPE */\n      /* WSAENOPROTOOPT maps to ENOPROTOOPT */\n      /* WSAEPROTONOSUPPORT maps to EPROTONOSUPPORT */\n      /* WSAESOCKTNOSUPPORT is ESOCKTNOSUPPORT */\n      /* WSAEOPNOTSUPP maps to EOPNOTSUPP */\n      /* WSAEPFNOSUPPORT is EPFNOSUPPORT */\n      /* WSAEAFNOSUPPORT maps to EAFNOSUPPORT */\n      /* WSAEADDRINUSE maps to EADDRINUSE */\n      /* WSAEADDRNOTAVAIL maps to EADDRNOTAVAIL */\n      /* WSAENETDOWN maps to ENETDOWN */\n      /* WSAENETUNREACH maps to ENETUNREACH */\n      /* WSAENETRESET maps to ENETRESET */\n      /* WSAECONNABORTED maps to ECONNABORTED */\n      /* WSAECONNRESET maps to ECONNRESET */\n      /* WSAENOBUFS maps to ENOBUFS */\n      /* WSAEISCONN maps to EISCONN */\n      /* WSAENOTCONN maps to ENOTCONN */\n      /* WSAESHUTDOWN is ESHUTDOWN */\n      /* WSAETOOMANYREFS is ETOOMANYREFS */\n      /* WSAETIMEDOUT maps to ETIMEDOUT */\n      /* WSAECONNREFUSED maps to ECONNREFUSED */\n      /* WSAELOOP maps to ELOOP */\n      /* WSAENAMETOOLONG maps to ENAMETOOLONG */\n      /* WSAEHOSTDOWN is EHOSTDOWN */\n      /* WSAEHOSTUNREACH maps to EHOSTUNREACH */\n      /* WSAENOTEMPTY maps to ENOTEMPTY */\n      /* WSAEPROCLIM is EPROCLIM */\n      /* WSAEUSERS is EUSERS */\n      /* WSAEDQUOT is EDQUOT */\n      /* WSAESTALE is ESTALE */\n      /* WSAEREMOTE is EREMOTE */\n    case WSASYSNOTREADY:\n      return \"Network subsystem is unavailable\";\n    case WSAVERNOTSUPPORTED:\n      return \"Winsock.dll version out of range\";\n    case WSANOTINITIALISED:\n      return \"Successful WSAStartup not yet performed\";\n    case WSAEDISCON:\n      return \"Graceful shutdown in progress\";\n    case WSAENOMORE: case WSA_E_NO_MORE:\n      return \"No more results\";\n    case WSAECANCELLED: case WSA_E_CANCELLED:\n      return \"Call was canceled\";\n    case WSAEINVALIDPROCTABLE:\n      return \"Procedure call table is invalid\";\n    case WSAEINVALIDPROVIDER:\n      return \"Service provider is invalid\";\n    case WSAEPROVIDERFAILEDINIT:\n      return \"Service provider failed to initialize\";\n    case WSASYSCALLFAILURE:\n      return \"System call failure\";\n    case WSASERVICE_NOT_FOUND:\n      return \"Service not found\";\n    case WSATYPE_NOT_FOUND:\n      return \"Class type not found\";\n    case WSAEREFUSED:\n      return \"Database query was refused\";\n    case WSAHOST_NOT_FOUND:\n      return \"Host not found\";\n    case WSATRY_AGAIN:\n      return \"Nonauthoritative host not found\";\n    case WSANO_RECOVERY:\n      return \"Nonrecoverable error\";\n    case WSANO_DATA:\n      return \"Valid name, no data record of requested type\";\n      /* WSA_QOS_* omitted */\n# endif\n#endif\n\n#if GNULIB_defined_ENOMSG\n    case ENOMSG:\n      return \"No message of desired type\";\n#endif\n\n#if GNULIB_defined_EIDRM\n    case EIDRM:\n      return \"Identifier removed\";\n#endif\n\n#if GNULIB_defined_ENOLINK\n    case ENOLINK:\n      return \"Link has been severed\";\n#endif\n\n#if GNULIB_defined_EPROTO\n    case EPROTO:\n      return \"Protocol error\";\n#endif\n\n#if GNULIB_defined_EMULTIHOP\n    case EMULTIHOP:\n      return \"Multihop attempted\";\n#endif\n\n#if GNULIB_defined_EBADMSG\n    case EBADMSG:\n      return \"Bad message\";\n#endif\n\n#if GNULIB_defined_EOVERFLOW\n    case EOVERFLOW:\n      return \"Value too large for defined data type\";\n#endif\n\n#if GNULIB_defined_ENOTSUP\n    case ENOTSUP:\n      return \"Not supported\";\n#endif\n\n#if GNULIB_defined_ENETRESET\n    case ENETRESET:\n      return \"Network dropped connection on reset\";\n#endif\n\n#if GNULIB_defined_ECONNABORTED\n    case ECONNABORTED:\n      return \"Software caused connection abort\";\n#endif\n\n#if GNULIB_defined_ESTALE\n    case ESTALE:\n      return \"Stale NFS file handle\";\n#endif\n\n#if GNULIB_defined_EDQUOT\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n#endif\n\n#if GNULIB_defined_ECANCELED\n    case ECANCELED:\n      return \"Operation canceled\";\n#endif\n\n#if GNULIB_defined_EOWNERDEAD\n    case EOWNERDEAD:\n      return \"Owner died\";\n#endif\n\n#if GNULIB_defined_ENOTRECOVERABLE\n    case ENOTRECOVERABLE:\n      return \"State not recoverable\";\n#endif\n\n#if GNULIB_defined_EILSEQ\n    case EILSEQ:\n      return \"Invalid or incomplete multibyte or wide character\";\n#endif\n\n    default:\n      return NULL;\n    }\n}",
      "lines": 269,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nstrerror_override (int errnum)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/strerror-override.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/strerror.c": {},
  "texinfo/texinfo-6.5/gnulib/lib/string.in.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/strings.in.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/stripslash.c": {
    "strip_trailing_slashes": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "bool\nstrip_trailing_slashes (char *file)\n{\n  char *base = last_component (file);\n  char *base_lim;\n  bool had_slash;\n\n  /* last_component returns \"\" for file system roots, but we need to turn\n     \"///\" into \"/\".  */\n  if (! *base)\n    base = file;\n  base_lim = base + base_len (base);\n  had_slash = (*base_lim != '\\0');\n  *base_lim = '\\0';\n  return had_slash;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/strncasecmp.c": {
    "strncasecmp": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nstrncasecmp (const char *s1, const char *s2, size_t n)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2 || n == 0)\n    return 0;\n\n  do\n    {\n      c1 = TOLOWER (*p1);\n      c2 = TOLOWER (*p2);\n\n      if (--n == 0 || c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/strndup.c": {
    "strndup": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "char *\nstrndup (char const *s, size_t n)\n{\n  size_t len = strnlen (s, n);\n  char *new = malloc (len + 1);\n\n  if (new == NULL)\n    return NULL;\n\n  new[len] = '\\0';\n  return memcpy (new, s, len);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "char",
        "*\nstrndup (char const *s, size_t n)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/strnlen.c": {
    "strnlen": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "size_t\nstrnlen (const char *string, size_t maxlen)\n{\n  const char *end = memchr (string, '\\0', maxlen);\n  return end ? (size_t) (end - string) : maxlen;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/strnlen1.c": {
    "strnlen1": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "size_t\nstrnlen1 (const char *string, size_t maxlen)\n{\n  const char *end = (const char *) memchr (string, '\\0', maxlen);\n  if (end != NULL)\n    return end - string + 1;\n  else\n    return maxlen;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "size_t"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/strnlen1.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/strstr.c": {
    "strstr": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "char *\nstrstr (const char *haystack_start, const char *needle_start)\n{\n  const char *haystack = haystack_start;\n  const char *needle = needle_start;\n  size_t needle_len; /* Length of NEEDLE.  */\n  size_t haystack_len; /* Known minimum length of HAYSTACK.  */\n  bool ok = true; /* True if NEEDLE is prefix of HAYSTACK.  */\n\n  /* Determine length of NEEDLE, and in the process, make sure\n     HAYSTACK is at least as long (no point processing all of a long\n     NEEDLE if HAYSTACK is too short).  */\n  while (*haystack && *needle)\n    ok &= *haystack++ == *needle++;\n  if (*needle)\n    return NULL;\n  if (ok)\n    return (char *) haystack_start;\n\n  /* Reduce the size of haystack using strchr, since it has a smaller\n     linear coefficient than the Two-Way algorithm.  */\n  needle_len = needle - needle_start;\n  haystack = strchr (haystack_start + 1, *needle_start);\n  if (!haystack || __builtin_expect (needle_len == 1, 0))\n    return (char *) haystack;\n  needle -= needle_len;\n  haystack_len = (haystack > haystack_start + needle_len ? 1\n                  : needle_len + haystack_start - haystack);\n\n  /* Perform the search.  Abstract memory is considered to be an array\n     of 'unsigned char' values, not an array of 'char' values.  See\n     ISO C 99 section 6.2.6.1.  */\n  if (needle_len < LONG_NEEDLE_THRESHOLD)\n    return two_way_short_needle ((const unsigned char *) haystack,\n                                 haystack_len,\n                                 (const unsigned char *) needle, needle_len);\n  return two_way_long_needle ((const unsigned char *) haystack, haystack_len,\n                              (const unsigned char *) needle, needle_len);\n}",
      "lines": 39,
      "depth": 10,
      "decorators": [
        "char",
        "*\nstrstr (const char *haystack_start, const char *needle_start)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/sys_types.in.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/unistd.c": {},
  "texinfo/texinfo-6.5/gnulib/lib/unistd.in.h": {
    "rpl_environ": {
      "start_point": [
        427,
        0
      ],
      "end_point": [
        431,
        1
      ],
      "content": "_GL_UNISTD_INLINE char ***\nrpl_environ (void)\n{\n  return &environ;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "char",
        "char",
        "***\nrpl_environ (void)",
        "*",
        "**\nrpl_environ (void)",
        "*",
        "*\nrpl_environ (void)",
        "*"
      ]
    },
    "getpagesize": {
      "start_point": [
        894,
        0
      ],
      "end_point": [
        898,
        1
      ],
      "content": "_GL_UNISTD_INLINE int\ngetpagesize ()\n{\n  return _gl_getpagesize ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "int",
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/unitypes.in.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/uniwidth.in.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/vasnprintf.c": {
    "local_strnlen": {
      "start_point": [
        227,
        0
      ],
      "end_point": [
        232,
        1
      ],
      "content": "static size_t\nlocal_strnlen (const char *string, size_t maxlen)\n{\n  const char *end = memchr (string, '\\0', maxlen);\n  return end ? (size_t) (end - string) : maxlen;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "local_wcslen": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "static size_t\nlocal_wcslen (const wchar_t *s)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; *ptr != (wchar_t) 0; ptr++)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "local_wcsnlen": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        274,
        1
      ],
      "content": "static size_t\nlocal_wcsnlen (const wchar_t *s, size_t maxlen)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; maxlen > 0 && *ptr != (wchar_t) 0; ptr++, maxlen--)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "decimal_point_char": {
      "start_point": [
        283,
        0
      ],
      "end_point": [
        302,
        1
      ],
      "content": "static char\ndecimal_point_char (void)\n{\n  const char *point;\n  /* Determine it in a multithread-safe way.  We know nl_langinfo is\n     multithread-safe on glibc systems and Mac OS X systems, but is not required\n     to be multithread-safe by POSIX.  sprintf(), however, is multithread-safe.\n     localeconv() is rarely multithread-safe.  */\n#  if HAVE_NL_LANGINFO && (__GLIBC__ || defined __UCLIBC__ || (defined __APPLE__ && defined __MACH__))\n  point = nl_langinfo (RADIXCHAR);\n#  elif 1\n  char pointbuf[5];\n  sprintf (pointbuf, \"%#.0f\", 1.0);\n  point = &pointbuf[1];\n#  else\n  point = localeconv () -> decimal_point;\n#  endif\n  /* The decimal point is always a single byte: either '.' or ','.  */\n  return (point[0] != '\\0' ? point[0] : '.');\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "is_infinite_or_zero": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "static int\nis_infinite_or_zero (double x)\n{\n  return isnand (x) || x + x == x;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_infinite_or_zerol": {
      "start_point": [
        320,
        0
      ],
      "end_point": [
        324,
        1
      ],
      "content": "static int\nis_infinite_or_zerol (long double x)\n{\n  return isnanl (x) || x + x == x;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "multiply": {
      "start_point": [
        352,
        0
      ],
      "end_point": [
        415,
        1
      ],
      "content": "static void *\nmultiply (mpn_t src1, mpn_t src2, mpn_t *dest)\n{\n  const mp_limb_t *p1;\n  const mp_limb_t *p2;\n  size_t len1;\n  size_t len2;\n\n  if (src1.nlimbs <= src2.nlimbs)\n    {\n      len1 = src1.nlimbs;\n      p1 = src1.limbs;\n      len2 = src2.nlimbs;\n      p2 = src2.limbs;\n    }\n  else\n    {\n      len1 = src2.nlimbs;\n      p1 = src2.limbs;\n      len2 = src1.nlimbs;\n      p2 = src1.limbs;\n    }\n  /* Now 0 <= len1 <= len2.  */\n  if (len1 == 0)\n    {\n      /* src1 or src2 is zero.  */\n      dest->nlimbs = 0;\n      dest->limbs = (mp_limb_t *) malloc (1);\n    }\n  else\n    {\n      /* Here 1 <= len1 <= len2.  */\n      size_t dlen;\n      mp_limb_t *dp;\n      size_t k, i, j;\n\n      dlen = len1 + len2;\n      dp = (mp_limb_t *) malloc (dlen * sizeof (mp_limb_t));\n      if (dp == NULL)\n        return NULL;\n      for (k = len2; k > 0; )\n        dp[--k] = 0;\n      for (i = 0; i < len1; i++)\n        {\n          mp_limb_t digit1 = p1[i];\n          mp_twolimb_t carry = 0;\n          for (j = 0; j < len2; j++)\n            {\n              mp_limb_t digit2 = p2[j];\n              carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n              carry += dp[i + j];\n              dp[i + j] = (mp_limb_t) carry;\n              carry = carry >> GMP_LIMB_BITS;\n            }\n          dp[i + len2] = (mp_limb_t) carry;\n        }\n      /* Normalise.  */\n      while (dlen > 0 && dp[dlen - 1] == 0)\n        dlen--;\n      dest->nlimbs = dlen;\n      dest->limbs = dp;\n    }\n  return dest->limbs;\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nmultiply (mpn_t src1, mpn_t src2, mpn_t *dest)",
        "*"
      ]
    },
    "divide": {
      "start_point": [
        424,
        0
      ],
      "end_point": [
        847,
        1
      ],
      "content": "static void *\ndivide (mpn_t a, mpn_t b, mpn_t *q)\n{\n  /* Algorithm:\n     First normalise a and b: a=[a[m-1],...,a[0]], b=[b[n-1],...,b[0]]\n     with m>=0 and n>0 (in base beta = 2^GMP_LIMB_BITS).\n     If m<n, then q:=0 and r:=a.\n     If m>=n=1, perform a single-precision division:\n       r:=0, j:=m,\n       while j>0 do\n         {Here (q[m-1]*beta^(m-1)+...+q[j]*beta^j) * b[0] + r*beta^j =\n               = a[m-1]*beta^(m-1)+...+a[j]*beta^j und 0<=r<b[0]<beta}\n         j:=j-1, r:=r*beta+a[j], q[j]:=floor(r/b[0]), r:=r-b[0]*q[j].\n       Normalise [q[m-1],...,q[0]], yields q.\n     If m>=n>1, perform a multiple-precision division:\n       We have a/b < beta^(m-n+1).\n       s:=intDsize-1-(highest bit in b[n-1]), 0<=s<intDsize.\n       Shift a and b left by s bits, copying them. r:=a.\n       r=[r[m],...,r[0]], b=[b[n-1],...,b[0]] with b[n-1]>=beta/2.\n       For j=m-n,...,0: {Here 0 <= r < b*beta^(j+1).}\n         Compute q* :\n           q* := floor((r[j+n]*beta+r[j+n-1])/b[n-1]).\n           In case of overflow (q* >= beta) set q* := beta-1.\n           Compute c2 := ((r[j+n]*beta+r[j+n-1]) - q* * b[n-1])*beta + r[j+n-2]\n           and c3 := b[n-2] * q*.\n           {We have 0 <= c2 < 2*beta^2, even 0 <= c2 < beta^2 if no overflow\n            occurred.  Furthermore 0 <= c3 < beta^2.\n            If there was overflow and\n            r[j+n]*beta+r[j+n-1] - q* * b[n-1] >= beta, i.e. c2 >= beta^2,\n            the next test can be skipped.}\n           While c3 > c2, {Here 0 <= c2 < c3 < beta^2}\n             Put q* := q* - 1, c2 := c2 + b[n-1]*beta, c3 := c3 - b[n-2].\n           If q* > 0:\n             Put r := r - b * q* * beta^j. In detail:\n               [r[n+j],...,r[j]] := [r[n+j],...,r[j]] - q* * [b[n-1],...,b[0]].\n               hence: u:=0, for i:=0 to n-1 do\n                              u := u + q* * b[i],\n                              r[j+i]:=r[j+i]-(u mod beta) (+ beta, if carry),\n                              u:=u div beta (+ 1, if carry in subtraction)\n                      r[n+j]:=r[n+j]-u.\n               {Since always u = (q* * [b[i-1],...,b[0]] div beta^i) + 1\n                               < q* + 1 <= beta,\n                the carry u does not overflow.}\n             If a negative carry occurs, put q* := q* - 1\n               and [r[n+j],...,r[j]] := [r[n+j],...,r[j]] + [0,b[n-1],...,b[0]].\n         Set q[j] := q*.\n       Normalise [q[m-n],..,q[0]]; this yields the quotient q.\n       Shift [r[n-1],...,r[0]] right by s bits and normalise; this yields the\n       rest r.\n       The room for q[j] can be allocated at the memory location of r[n+j].\n     Finally, round-to-even:\n       Shift r left by 1 bit.\n       If r > b or if r = b and q[0] is odd, q := q+1.\n   */\n  const mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  const mp_limb_t *b_ptr = b.limbs;\n  size_t b_len = b.nlimbs;\n  mp_limb_t *roomptr;\n  mp_limb_t *tmp_roomptr = NULL;\n  mp_limb_t *q_ptr;\n  size_t q_len;\n  mp_limb_t *r_ptr;\n  size_t r_len;\n\n  /* Allocate room for a_len+2 digits.\n     (Need a_len+1 digits for the real division and 1 more digit for the\n     final rounding of q.)  */\n  roomptr = (mp_limb_t *) malloc ((a_len + 2) * sizeof (mp_limb_t));\n  if (roomptr == NULL)\n    return NULL;\n\n  /* Normalise a.  */\n  while (a_len > 0 && a_ptr[a_len - 1] == 0)\n    a_len--;\n\n  /* Normalise b.  */\n  for (;;)\n    {\n      if (b_len == 0)\n        /* Division by zero.  */\n        abort ();\n      if (b_ptr[b_len - 1] == 0)\n        b_len--;\n      else\n        break;\n    }\n\n  /* Here m = a_len >= 0 and n = b_len > 0.  */\n\n  if (a_len < b_len)\n    {\n      /* m<n: trivial case.  q=0, r := copy of a.  */\n      r_ptr = roomptr;\n      r_len = a_len;\n      memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n      q_ptr = roomptr + a_len;\n      q_len = 0;\n    }\n  else if (b_len == 1)\n    {\n      /* n=1: single precision division.\n         beta^(m-1) <= a < beta^m  ==>  beta^(m-2) <= a/b < beta^m  */\n      r_ptr = roomptr;\n      q_ptr = roomptr + 1;\n      {\n        mp_limb_t den = b_ptr[0];\n        mp_limb_t remainder = 0;\n        const mp_limb_t *sourceptr = a_ptr + a_len;\n        mp_limb_t *destptr = q_ptr + a_len;\n        size_t count;\n        for (count = a_len; count > 0; count--)\n          {\n            mp_twolimb_t num =\n              ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--sourceptr;\n            *--destptr = num / den;\n            remainder = num % den;\n          }\n        /* Normalise and store r.  */\n        if (remainder > 0)\n          {\n            r_ptr[0] = remainder;\n            r_len = 1;\n          }\n        else\n          r_len = 0;\n        /* Normalise q.  */\n        q_len = a_len;\n        if (q_ptr[q_len - 1] == 0)\n          q_len--;\n      }\n    }\n  else\n    {\n      /* n>1: multiple precision division.\n         beta^(m-1) <= a < beta^m, beta^(n-1) <= b < beta^n  ==>\n         beta^(m-n-1) <= a/b < beta^(m-n+1).  */\n      /* Determine s.  */\n      size_t s;\n      {\n        mp_limb_t msd = b_ptr[b_len - 1]; /* = b[n-1], > 0 */\n        /* Determine s = GMP_LIMB_BITS - integer_length (msd).\n           Code copied from gnulib's integer_length.c.  */\n# if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)\n        s = __builtin_clz (msd);\n# else\n#  if defined DBL_EXPBIT0_WORD && defined DBL_EXPBIT0_BIT\n        if (GMP_LIMB_BITS <= DBL_MANT_BIT)\n          {\n            /* Use 'double' operations.\n               Assumes an IEEE 754 'double' implementation.  */\n#   define DBL_EXP_MASK ((DBL_MAX_EXP - DBL_MIN_EXP) | 7)\n#   define DBL_EXP_BIAS (DBL_EXP_MASK / 2 - 1)\n#   define NWORDS \\\n     ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n            union { double value; unsigned int word[NWORDS]; } m;\n\n            /* Use a single integer to floating-point conversion.  */\n            m.value = msd;\n\n            s = GMP_LIMB_BITS\n                - (((m.word[DBL_EXPBIT0_WORD] >> DBL_EXPBIT0_BIT) & DBL_EXP_MASK)\n                   - DBL_EXP_BIAS);\n          }\n        else\n#   undef NWORDS\n#  endif\n          {\n            s = 31;\n            if (msd >= 0x10000)\n              {\n                msd = msd >> 16;\n                s -= 16;\n              }\n            if (msd >= 0x100)\n              {\n                msd = msd >> 8;\n                s -= 8;\n              }\n            if (msd >= 0x10)\n              {\n                msd = msd >> 4;\n                s -= 4;\n              }\n            if (msd >= 0x4)\n              {\n                msd = msd >> 2;\n                s -= 2;\n              }\n            if (msd >= 0x2)\n              {\n                msd = msd >> 1;\n                s -= 1;\n              }\n          }\n# endif\n      }\n      /* 0 <= s < GMP_LIMB_BITS.\n         Copy b, shifting it left by s bits.  */\n      if (s > 0)\n        {\n          tmp_roomptr = (mp_limb_t *) malloc (b_len * sizeof (mp_limb_t));\n          if (tmp_roomptr == NULL)\n            {\n              free (roomptr);\n              return NULL;\n            }\n          {\n            const mp_limb_t *sourceptr = b_ptr;\n            mp_limb_t *destptr = tmp_roomptr;\n            mp_twolimb_t accu = 0;\n            size_t count;\n            for (count = b_len; count > 0; count--)\n              {\n                accu += (mp_twolimb_t) *sourceptr++ << s;\n                *destptr++ = (mp_limb_t) accu;\n                accu = accu >> GMP_LIMB_BITS;\n              }\n            /* accu must be zero, since that was how s was determined.  */\n            if (accu != 0)\n              abort ();\n          }\n          b_ptr = tmp_roomptr;\n        }\n      /* Copy a, shifting it left by s bits, yields r.\n         Memory layout:\n         At the beginning: r = roomptr[0..a_len],\n         at the end: r = roomptr[0..b_len-1], q = roomptr[b_len..a_len]  */\n      r_ptr = roomptr;\n      if (s == 0)\n        {\n          memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n          r_ptr[a_len] = 0;\n        }\n      else\n        {\n          const mp_limb_t *sourceptr = a_ptr;\n          mp_limb_t *destptr = r_ptr;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              accu += (mp_twolimb_t) *sourceptr++ << s;\n              *destptr++ = (mp_limb_t) accu;\n              accu = accu >> GMP_LIMB_BITS;\n            }\n          *destptr++ = (mp_limb_t) accu;\n        }\n      q_ptr = roomptr + b_len;\n      q_len = a_len - b_len + 1; /* q will have m-n+1 limbs */\n      {\n        size_t j = a_len - b_len; /* m-n */\n        mp_limb_t b_msd = b_ptr[b_len - 1]; /* b[n-1] */\n        mp_limb_t b_2msd = b_ptr[b_len - 2]; /* b[n-2] */\n        mp_twolimb_t b_msdd = /* b[n-1]*beta+b[n-2] */\n          ((mp_twolimb_t) b_msd << GMP_LIMB_BITS) | b_2msd;\n        /* Division loop, traversed m-n+1 times.\n           j counts down, b is unchanged, beta/2 <= b[n-1] < beta.  */\n        for (;;)\n          {\n            mp_limb_t q_star;\n            mp_limb_t c1;\n            if (r_ptr[j + b_len] < b_msd) /* r[j+n] < b[n-1] ? */\n              {\n                /* Divide r[j+n]*beta+r[j+n-1] by b[n-1], no overflow.  */\n                mp_twolimb_t num =\n                  ((mp_twolimb_t) r_ptr[j + b_len] << GMP_LIMB_BITS)\n                  | r_ptr[j + b_len - 1];\n                q_star = num / b_msd;\n                c1 = num % b_msd;\n              }\n            else\n              {\n                /* Overflow, hence r[j+n]*beta+r[j+n-1] >= beta*b[n-1].  */\n                q_star = (mp_limb_t)~(mp_limb_t)0; /* q* = beta-1 */\n                /* Test whether r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] >= beta\n                   <==> r[j+n]*beta+r[j+n-1] + b[n-1] >= beta*b[n-1]+beta\n                   <==> b[n-1] < floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta)\n                        {<= beta !}.\n                   If yes, jump directly to the subtraction loop.\n                   (Otherwise, r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] < beta\n                    <==> floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta) = b[n-1] ) */\n                if (r_ptr[j + b_len] > b_msd\n                    || (c1 = r_ptr[j + b_len - 1] + b_msd) < b_msd)\n                  /* r[j+n] >= b[n-1]+1 or\n                     r[j+n] = b[n-1] and the addition r[j+n-1]+b[n-1] gives a\n                     carry.  */\n                  goto subtract;\n              }\n            /* q_star = q*,\n               c1 = (r[j+n]*beta+r[j+n-1]) - q* * b[n-1] (>=0, <beta).  */\n            {\n              mp_twolimb_t c2 = /* c1*beta+r[j+n-2] */\n                ((mp_twolimb_t) c1 << GMP_LIMB_BITS) | r_ptr[j + b_len - 2];\n              mp_twolimb_t c3 = /* b[n-2] * q* */\n                (mp_twolimb_t) b_2msd * (mp_twolimb_t) q_star;\n              /* While c2 < c3, increase c2 and decrease c3.\n                 Consider c3-c2.  While it is > 0, decrease it by\n                 b[n-1]*beta+b[n-2].  Because of b[n-1]*beta+b[n-2] >= beta^2/2\n                 this can happen only twice.  */\n              if (c3 > c2)\n                {\n                  q_star = q_star - 1; /* q* := q* - 1 */\n                  if (c3 - c2 > b_msdd)\n                    q_star = q_star - 1; /* q* := q* - 1 */\n                }\n            }\n            if (q_star > 0)\n              subtract:\n              {\n                /* Subtract r := r - b * q* * beta^j.  */\n                mp_limb_t cr;\n                {\n                  const mp_limb_t *sourceptr = b_ptr;\n                  mp_limb_t *destptr = r_ptr + j;\n                  mp_twolimb_t carry = 0;\n                  size_t count;\n                  for (count = b_len; count > 0; count--)\n                    {\n                      /* Here 0 <= carry <= q*.  */\n                      carry =\n                        carry\n                        + (mp_twolimb_t) q_star * (mp_twolimb_t) *sourceptr++\n                        + (mp_limb_t) ~(*destptr);\n                      /* Here 0 <= carry <= beta*q* + beta-1.  */\n                      *destptr++ = ~(mp_limb_t) carry;\n                      carry = carry >> GMP_LIMB_BITS; /* <= q* */\n                    }\n                  cr = (mp_limb_t) carry;\n                }\n                /* Subtract cr from r_ptr[j + b_len], then forget about\n                   r_ptr[j + b_len].  */\n                if (cr > r_ptr[j + b_len])\n                  {\n                    /* Subtraction gave a carry.  */\n                    q_star = q_star - 1; /* q* := q* - 1 */\n                    /* Add b back.  */\n                    {\n                      const mp_limb_t *sourceptr = b_ptr;\n                      mp_limb_t *destptr = r_ptr + j;\n                      mp_limb_t carry = 0;\n                      size_t count;\n                      for (count = b_len; count > 0; count--)\n                        {\n                          mp_limb_t source1 = *sourceptr++;\n                          mp_limb_t source2 = *destptr;\n                          *destptr++ = source1 + source2 + carry;\n                          carry =\n                            (carry\n                             ? source1 >= (mp_limb_t) ~source2\n                             : source1 > (mp_limb_t) ~source2);\n                        }\n                    }\n                    /* Forget about the carry and about r[j+n].  */\n                  }\n              }\n            /* q* is determined.  Store it as q[j].  */\n            q_ptr[j] = q_star;\n            if (j == 0)\n              break;\n            j--;\n          }\n      }\n      r_len = b_len;\n      /* Normalise q.  */\n      if (q_ptr[q_len - 1] == 0)\n        q_len--;\n# if 0 /* Not needed here, since we need r only to compare it with b/2, and\n          b is shifted left by s bits.  */\n      /* Shift r right by s bits.  */\n      if (s > 0)\n        {\n          mp_limb_t ptr = r_ptr + r_len;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = r_len; count > 0; count--)\n            {\n              accu = (mp_twolimb_t) (mp_limb_t) accu << GMP_LIMB_BITS;\n              accu += (mp_twolimb_t) *--ptr << (GMP_LIMB_BITS - s);\n              *ptr = (mp_limb_t) (accu >> GMP_LIMB_BITS);\n            }\n        }\n# endif\n      /* Normalise r.  */\n      while (r_len > 0 && r_ptr[r_len - 1] == 0)\n        r_len--;\n    }\n  /* Compare r << 1 with b.  */\n  if (r_len > b_len)\n    goto increment_q;\n  {\n    size_t i;\n    for (i = b_len;;)\n      {\n        mp_limb_t r_i =\n          (i <= r_len && i > 0 ? r_ptr[i - 1] >> (GMP_LIMB_BITS - 1) : 0)\n          | (i < r_len ? r_ptr[i] << 1 : 0);\n        mp_limb_t b_i = (i < b_len ? b_ptr[i] : 0);\n        if (r_i > b_i)\n          goto increment_q;\n        if (r_i < b_i)\n          goto keep_q;\n        if (i == 0)\n          break;\n        i--;\n      }\n  }\n  if (q_len > 0 && ((q_ptr[0] & 1) != 0))\n    /* q is odd.  */\n    increment_q:\n    {\n      size_t i;\n      for (i = 0; i < q_len; i++)\n        if (++(q_ptr[i]) != 0)\n          goto keep_q;\n      q_ptr[q_len++] = 1;\n    }\n  keep_q:\n  if (tmp_roomptr != NULL)\n    free (tmp_roomptr);\n  q->limbs = q_ptr;\n  q->nlimbs = q_len;\n  return roomptr;\n}",
      "lines": 424,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndivide (mpn_t a, mpn_t b, mpn_t *q)",
        "*"
      ]
    },
    "convert_to_decimal": {
      "start_point": [
        855,
        0
      ],
      "end_point": [
        901,
        1
      ],
      "content": "static char *\nconvert_to_decimal (mpn_t a, size_t extra_zeroes)\n{\n  mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  /* 0.03345 is slightly larger than log(2)/(9*log(10)).  */\n  size_t c_len = 9 * ((size_t)(a_len * (GMP_LIMB_BITS * 0.03345f)) + 1);\n  char *c_ptr = (char *) malloc (xsum (c_len, extra_zeroes));\n  if (c_ptr != NULL)\n    {\n      char *d_ptr = c_ptr;\n      for (; extra_zeroes > 0; extra_zeroes--)\n        *d_ptr++ = '0';\n      while (a_len > 0)\n        {\n          /* Divide a by 10^9, in-place.  */\n          mp_limb_t remainder = 0;\n          mp_limb_t *ptr = a_ptr + a_len;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              mp_twolimb_t num =\n                ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--ptr;\n              *ptr = num / 1000000000;\n              remainder = num % 1000000000;\n            }\n          /* Store the remainder as 9 decimal digits.  */\n          for (count = 9; count > 0; count--)\n            {\n              *d_ptr++ = '0' + (remainder % 10);\n              remainder = remainder / 10;\n            }\n          /* Normalize a.  */\n          if (a_ptr[a_len - 1] == 0)\n            a_len--;\n        }\n      /* Remove leading zeroes.  */\n      while (d_ptr > c_ptr && d_ptr[-1] == '0')\n        d_ptr--;\n      /* But keep at least one zero.  */\n      if (d_ptr == c_ptr)\n        *d_ptr++ = '0';\n      /* Terminate the string.  */\n      *d_ptr = '\\0';\n    }\n  return c_ptr;\n}",
      "lines": 47,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nconvert_to_decimal (mpn_t a, size_t extra_zeroes)",
        "*"
      ]
    },
    "decode_long_double": {
      "start_point": [
        909,
        0
      ],
      "end_point": [
        987,
        1
      ],
      "content": "static void *\ndecode_long_double (long double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  long double y;\n  size_t i;\n\n  /* Allocate memory for result.  */\n  m.nlimbs = (LDBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n  /* Split into exponential part and mantissa.  */\n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n  /* x = 2^exp * y = 2^(exp - LDBL_MANT_BIT) * (y * 2^LDBL_MANT_BIT), and the\n     latter is an integer.  */\n  /* Convert the mantissa (y * 2^LDBL_MANT_BIT) to a sequence of limbs.\n     I'm not sure whether it's safe to cast a 'long double' value between\n     2^31 and 2^32 to 'unsigned int', therefore play safe and cast only\n     'long double' values between 0 and 2^16 (to 'unsigned int' or 'int',\n     doesn't matter).  */\n#  if (LDBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (LDBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = LDBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#  if 0 /* On FreeBSD 6.1/x86, 'long double' numbers sometimes have excess\n           precision.  */\n  if (!(y == 0.0L))\n    abort ();\n#  endif\n  /* Normalise.  */\n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - LDBL_MANT_BIT;\n  return m.limbs;\n}",
      "lines": 79,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndecode_long_double (long double x, int *ep, mpn_t *mp)",
        "*"
      ]
    },
    "decode_double": {
      "start_point": [
        997,
        0
      ],
      "end_point": [
        1072,
        1
      ],
      "content": "static void *\ndecode_double (double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  double y;\n  size_t i;\n\n  /* Allocate memory for result.  */\n  m.nlimbs = (DBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n  /* Split into exponential part and mantissa.  */\n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n  /* x = 2^exp * y = 2^(exp - DBL_MANT_BIT) * (y * 2^DBL_MANT_BIT), and the\n     latter is an integer.  */\n  /* Convert the mantissa (y * 2^DBL_MANT_BIT) to a sequence of limbs.\n     I'm not sure whether it's safe to cast a 'double' value between\n     2^31 and 2^32 to 'unsigned int', therefore play safe and cast only\n     'double' values between 0 and 2^16 (to 'unsigned int' or 'int',\n     doesn't matter).  */\n#  if (DBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (DBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = DBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n  if (!(y == 0.0))\n    abort ();\n  /* Normalise.  */\n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - DBL_MANT_BIT;\n  return m.limbs;\n}",
      "lines": 76,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndecode_double (double x, int *ep, mpn_t *mp)",
        "*"
      ]
    },
    "scale10_round_decimal_decoded": {
      "start_point": [
        1081,
        0
      ],
      "end_point": [
        1294,
        1
      ],
      "content": "static char *\nscale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)\n{\n  int s;\n  size_t extra_zeroes;\n  unsigned int abs_n;\n  unsigned int abs_s;\n  mp_limb_t *pow5_ptr;\n  size_t pow5_len;\n  unsigned int s_limbs;\n  unsigned int s_bits;\n  mpn_t pow5;\n  mpn_t z;\n  void *z_memory;\n  char *digits;\n\n  if (memory == NULL)\n    return NULL;\n  /* x = 2^e * m, hence\n     y = round (2^e * 10^n * m) = round (2^(e+n) * 5^n * m)\n       = round (2^s * 5^n * m).  */\n  s = e + n;\n  extra_zeroes = 0;\n  /* Factor out a common power of 10 if possible.  */\n  if (s > 0 && n > 0)\n    {\n      extra_zeroes = (s < n ? s : n);\n      s -= extra_zeroes;\n      n -= extra_zeroes;\n    }\n  /* Here y = round (2^s * 5^n * m) * 10^extra_zeroes.\n     Before converting to decimal, we need to compute\n     z = round (2^s * 5^n * m).  */\n  /* Compute 5^|n|, possibly shifted by |s| bits if n and s have the same\n     sign.  2.322 is slightly larger than log(5)/log(2).  */\n  abs_n = (n >= 0 ? n : -n);\n  abs_s = (s >= 0 ? s : -s);\n  pow5_ptr = (mp_limb_t *) malloc (((int)(abs_n * (2.322f / GMP_LIMB_BITS)) + 1\n                                    + abs_s / GMP_LIMB_BITS + 1)\n                                   * sizeof (mp_limb_t));\n  if (pow5_ptr == NULL)\n    {\n      free (memory);\n      return NULL;\n    }\n  /* Initialize with 1.  */\n  pow5_ptr[0] = 1;\n  pow5_len = 1;\n  /* Multiply with 5^|n|.  */\n  if (abs_n > 0)\n    {\n      static mp_limb_t const small_pow5[13 + 1] =\n        {\n          1, 5, 25, 125, 625, 3125, 15625, 78125, 390625, 1953125, 9765625,\n          48828125, 244140625, 1220703125\n        };\n      unsigned int n13;\n      for (n13 = 0; n13 <= abs_n; n13 += 13)\n        {\n          mp_limb_t digit1 = small_pow5[n13 + 13 <= abs_n ? 13 : abs_n - n13];\n          size_t j;\n          mp_twolimb_t carry = 0;\n          for (j = 0; j < pow5_len; j++)\n            {\n              mp_limb_t digit2 = pow5_ptr[j];\n              carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n              pow5_ptr[j] = (mp_limb_t) carry;\n              carry = carry >> GMP_LIMB_BITS;\n            }\n          if (carry > 0)\n            pow5_ptr[pow5_len++] = (mp_limb_t) carry;\n        }\n    }\n  s_limbs = abs_s / GMP_LIMB_BITS;\n  s_bits = abs_s % GMP_LIMB_BITS;\n  if (n >= 0 ? s >= 0 : s <= 0)\n    {\n      /* Multiply with 2^|s|.  */\n      if (s_bits > 0)\n        {\n          mp_limb_t *ptr = pow5_ptr;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = pow5_len; count > 0; count--)\n            {\n              accu += (mp_twolimb_t) *ptr << s_bits;\n              *ptr++ = (mp_limb_t) accu;\n              accu = accu >> GMP_LIMB_BITS;\n            }\n          if (accu > 0)\n            {\n              *ptr = (mp_limb_t) accu;\n              pow5_len++;\n            }\n        }\n      if (s_limbs > 0)\n        {\n          size_t count;\n          for (count = pow5_len; count > 0;)\n            {\n              count--;\n              pow5_ptr[s_limbs + count] = pow5_ptr[count];\n            }\n          for (count = s_limbs; count > 0;)\n            {\n              count--;\n              pow5_ptr[count] = 0;\n            }\n          pow5_len += s_limbs;\n        }\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n        {\n          /* Multiply m with pow5.  No division needed.  */\n          z_memory = multiply (m, pow5, &z);\n        }\n      else\n        {\n          /* Divide m by pow5 and round.  */\n          z_memory = divide (m, pow5, &z);\n        }\n    }\n  else\n    {\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n        {\n          /* n >= 0, s < 0.\n             Multiply m with pow5, then divide by 2^|s|.  */\n          mpn_t numerator;\n          mpn_t denominator;\n          void *tmp_memory;\n          tmp_memory = multiply (m, pow5, &numerator);\n          if (tmp_memory == NULL)\n            {\n              free (pow5_ptr);\n              free (memory);\n              return NULL;\n            }\n          /* Construct 2^|s|.  */\n          {\n            mp_limb_t *ptr = pow5_ptr + pow5_len;\n            size_t i;\n            for (i = 0; i < s_limbs; i++)\n              ptr[i] = 0;\n            ptr[s_limbs] = (mp_limb_t) 1 << s_bits;\n            denominator.limbs = ptr;\n            denominator.nlimbs = s_limbs + 1;\n          }\n          z_memory = divide (numerator, denominator, &z);\n          free (tmp_memory);\n        }\n      else\n        {\n          /* n < 0, s > 0.\n             Multiply m with 2^s, then divide by pow5.  */\n          mpn_t numerator;\n          mp_limb_t *num_ptr;\n          num_ptr = (mp_limb_t *) malloc ((m.nlimbs + s_limbs + 1)\n                                          * sizeof (mp_limb_t));\n          if (num_ptr == NULL)\n            {\n              free (pow5_ptr);\n              free (memory);\n              return NULL;\n            }\n          {\n            mp_limb_t *destptr = num_ptr;\n            {\n              size_t i;\n              for (i = 0; i < s_limbs; i++)\n                *destptr++ = 0;\n            }\n            if (s_bits > 0)\n              {\n                const mp_limb_t *sourceptr = m.limbs;\n                mp_twolimb_t accu = 0;\n                size_t count;\n                for (count = m.nlimbs; count > 0; count--)\n                  {\n                    accu += (mp_twolimb_t) *sourceptr++ << s_bits;\n                    *destptr++ = (mp_limb_t) accu;\n                    accu = accu >> GMP_LIMB_BITS;\n                  }\n                if (accu > 0)\n                  *destptr++ = (mp_limb_t) accu;\n              }\n            else\n              {\n                const mp_limb_t *sourceptr = m.limbs;\n                size_t count;\n                for (count = m.nlimbs; count > 0; count--)\n                  *destptr++ = *sourceptr++;\n              }\n            numerator.limbs = num_ptr;\n            numerator.nlimbs = destptr - num_ptr;\n          }\n          z_memory = divide (numerator, pow5, &z);\n          free (num_ptr);\n        }\n    }\n  free (pow5_ptr);\n  free (memory);\n\n  /* Here y = round (x * 10^n) = z * 10^extra_zeroes.  */\n\n  if (z_memory == NULL)\n    return NULL;\n  digits = convert_to_decimal (z, extra_zeroes);\n  free (z_memory);\n  return digits;\n}",
      "lines": 214,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)",
        "*"
      ]
    },
    "scale10_round_decimal_long_double": {
      "start_point": [
        1303,
        0
      ],
      "end_point": [
        1310,
        1
      ],
      "content": "static char *\nscale10_round_decimal_long_double (long double x, int n)\n{\n  int e IF_LINT(= 0);\n  mpn_t m;\n  void *memory = decode_long_double (x, &e, &m);\n  return scale10_round_decimal_decoded (e, m, memory, n);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_long_double (long double x, int n)",
        "*"
      ]
    },
    "scale10_round_decimal_double": {
      "start_point": [
        1321,
        0
      ],
      "end_point": [
        1328,
        1
      ],
      "content": "static char *\nscale10_round_decimal_double (double x, int n)\n{\n  int e IF_LINT(= 0);\n  mpn_t m;\n  void *memory = decode_double (x, &e, &m);\n  return scale10_round_decimal_decoded (e, m, memory, n);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_double (double x, int n)",
        "*"
      ]
    },
    "floorlog10l": {
      "start_point": [
        1337,
        0
      ],
      "end_point": [
        1419,
        1
      ],
      "content": "static int\nfloorlog10l (long double x)\n{\n  int exp;\n  long double y;\n  double z;\n  double l;\n\n  /* Split into exponential part and mantissa.  */\n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n  if (y == 0.0L)\n    return INT_MIN;\n  if (y < 0.5L)\n    {\n      while (y < (1.0L / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n        {\n          y *= 1.0L * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n          exp -= GMP_LIMB_BITS;\n        }\n      if (y < (1.0L / (1 << 16)))\n        {\n          y *= 1.0L * (1 << 16);\n          exp -= 16;\n        }\n      if (y < (1.0L / (1 << 8)))\n        {\n          y *= 1.0L * (1 << 8);\n          exp -= 8;\n        }\n      if (y < (1.0L / (1 << 4)))\n        {\n          y *= 1.0L * (1 << 4);\n          exp -= 4;\n        }\n      if (y < (1.0L / (1 << 2)))\n        {\n          y *= 1.0L * (1 << 2);\n          exp -= 2;\n        }\n      if (y < (1.0L / (1 << 1)))\n        {\n          y *= 1.0L * (1 << 1);\n          exp -= 1;\n        }\n    }\n  if (!(y >= 0.5L && y < 1.0L))\n    abort ();\n  /* Compute an approximation for l = log2(x) = exp + log2(y).  */\n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n  /* Now 0.95 <= z <= 1.01.  */\n  z = 1 - z;\n  /* log2(1-z) = 1/log(2) * (- z - z^2/2 - z^3/3 - z^4/4 - ...)\n     Four terms are enough to get an approximation with error < 10^-7.  */\n  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n  /* Finally multiply with log(2)/log(10), yields an approximation for\n     log10(x).  */\n  l *= 0.30102999566398119523;\n  /* Round down to the next integer.  */\n  return (int) l + (l < 0 ? -1 : 0);\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "floorlog10": {
      "start_point": [
        1428,
        0
      ],
      "end_point": [
        1510,
        1
      ],
      "content": "static int\nfloorlog10 (double x)\n{\n  int exp;\n  double y;\n  double z;\n  double l;\n\n  /* Split into exponential part and mantissa.  */\n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n  if (y == 0.0)\n    return INT_MIN;\n  if (y < 0.5)\n    {\n      while (y < (1.0 / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n        {\n          y *= 1.0 * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n          exp -= GMP_LIMB_BITS;\n        }\n      if (y < (1.0 / (1 << 16)))\n        {\n          y *= 1.0 * (1 << 16);\n          exp -= 16;\n        }\n      if (y < (1.0 / (1 << 8)))\n        {\n          y *= 1.0 * (1 << 8);\n          exp -= 8;\n        }\n      if (y < (1.0 / (1 << 4)))\n        {\n          y *= 1.0 * (1 << 4);\n          exp -= 4;\n        }\n      if (y < (1.0 / (1 << 2)))\n        {\n          y *= 1.0 * (1 << 2);\n          exp -= 2;\n        }\n      if (y < (1.0 / (1 << 1)))\n        {\n          y *= 1.0 * (1 << 1);\n          exp -= 1;\n        }\n    }\n  if (!(y >= 0.5 && y < 1.0))\n    abort ();\n  /* Compute an approximation for l = log2(x) = exp + log2(y).  */\n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n  /* Now 0.95 <= z <= 1.01.  */\n  z = 1 - z;\n  /* log2(1-z) = 1/log(2) * (- z - z^2/2 - z^3/3 - z^4/4 - ...)\n     Four terms are enough to get an approximation with error < 10^-7.  */\n  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n  /* Finally multiply with log(2)/log(10), yields an approximation for\n     log10(x).  */\n  l *= 0.30102999566398119523;\n  /* Round down to the next integer.  */\n  return (int) l + (l < 0 ? -1 : 0);\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_borderline": {
      "start_point": [
        1516,
        0
      ],
      "end_point": [
        1526,
        1
      ],
      "content": "static int\nis_borderline (const char *digits, size_t precision)\n{\n  for (; precision > 0; precision--, digits++)\n    if (*digits != '0')\n      return 0;\n  if (*digits != '1')\n    return 0;\n  digits++;\n  return *digits == '\\0';\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MAX_ROOM_NEEDED": {
      "start_point": [
        1543,
        0
      ],
      "end_point": [
        1778,
        1
      ],
      "content": "static size_t\nMAX_ROOM_NEEDED (const arguments *ap, size_t arg_index, FCHAR_T conversion,\n                 arg_type type, int flags, size_t width, int has_precision,\n                 size_t precision, int pad_ourselves)\n{\n  size_t tmp_length;\n\n  switch (conversion)\n    {\n    case 'd': case 'i': case 'u':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Multiply by 2, as an estimate for FLAG_GROUP.  */\n      tmp_length = xsum (tmp_length, tmp_length);\n      /* Add 1, to account for a leading sign.  */\n      tmp_length = xsum (tmp_length, 1);\n      break;\n\n    case 'o':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Add 1, to account for a leading sign.  */\n      tmp_length = xsum (tmp_length, 1);\n      break;\n\n    case 'x': case 'X':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Add 2, to account for a leading sign or alternate form.  */\n      tmp_length = xsum (tmp_length, 2);\n      break;\n\n    case 'f': case 'F':\n      if (type == TYPE_LONGDOUBLE)\n        tmp_length =\n          (unsigned int) (LDBL_MAX_EXP\n                          * 0.30103 /* binary -> decimal */\n                          * 2 /* estimate for FLAG_GROUP */\n                         )\n          + 1 /* turn floor into ceil */\n          + 10; /* sign, decimal point etc. */\n      else\n        tmp_length =\n          (unsigned int) (DBL_MAX_EXP\n                          * 0.30103 /* binary -> decimal */\n                          * 2 /* estimate for FLAG_GROUP */\n                         )\n          + 1 /* turn floor into ceil */\n          + 10; /* sign, decimal point etc. */\n      tmp_length = xsum (tmp_length, precision);\n      break;\n\n    case 'e': case 'E': case 'g': case 'G':\n      tmp_length =\n        12; /* sign, decimal point, exponent etc. */\n      tmp_length = xsum (tmp_length, precision);\n      break;\n\n    case 'a': case 'A':\n      if (type == TYPE_LONGDOUBLE)\n        tmp_length =\n          (unsigned int) (LDBL_DIG\n                          * 0.831 /* decimal -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (DBL_DIG\n                          * 0.831 /* decimal -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Account for sign, decimal point etc. */\n      tmp_length = xsum (tmp_length, 12);\n      break;\n\n    case 'c':\n# if HAVE_WINT_T && !WIDE_CHAR_VERSION\n      if (type == TYPE_WIDE_CHAR)\n        tmp_length = MB_CUR_MAX;\n      else\n# endif\n        tmp_length = 1;\n      break;\n\n    case 's':\n# if HAVE_WCHAR_T\n      if (type == TYPE_WIDE_STRING)\n        {\n#  if WIDE_CHAR_VERSION\n          /* ISO C says about %ls in fwprintf:\n               \"If the precision is not specified or is greater than the size\n                of the array, the array shall contain a null wide character.\"\n             So if there is a precision, we must not use wcslen.  */\n          const wchar_t *arg = ap->arg[arg_index].a.a_wide_string;\n\n          if (has_precision)\n            tmp_length = local_wcsnlen (arg, precision);\n          else\n            tmp_length = local_wcslen (arg);\n#  else\n          /* ISO C says about %ls in fprintf:\n               \"If a precision is specified, no more than that many bytes are\n                written (including shift sequences, if any), and the array\n                shall contain a null wide character if, to equal the multibyte\n                character sequence length given by the precision, the function\n                would need to access a wide character one past the end of the\n                array.\"\n             So if there is a precision, we must not use wcslen.  */\n          /* This case has already been handled separately in VASNPRINTF.  */\n          abort ();\n#  endif\n        }\n      else\n# endif\n        {\n# if WIDE_CHAR_VERSION\n          /* ISO C says about %s in fwprintf:\n               \"If the precision is not specified or is greater than the size\n                of the converted array, the converted array shall contain a\n                null wide character.\"\n             So if there is a precision, we must not use strlen.  */\n          /* This case has already been handled separately in VASNPRINTF.  */\n          abort ();\n# else\n          /* ISO C says about %s in fprintf:\n               \"If the precision is not specified or greater than the size of\n                the array, the array shall contain a null character.\"\n             So if there is a precision, we must not use strlen.  */\n          const char *arg = ap->arg[arg_index].a.a_string;\n\n          if (has_precision)\n            tmp_length = local_strnlen (arg, precision);\n          else\n            tmp_length = strlen (arg);\n# endif\n        }\n      break;\n\n    case 'p':\n      tmp_length =\n        (unsigned int) (sizeof (void *) * CHAR_BIT\n                        * 0.25 /* binary -> hexadecimal */\n                       )\n          + 1 /* turn floor into ceil */\n          + 2; /* account for leading 0x */\n      break;\n\n    default:\n      abort ();\n    }\n\n  if (!pad_ourselves)\n    {\n# if ENABLE_UNISTDIO\n      /* Padding considers the number of characters, therefore the number of\n         elements after padding may be\n           > max (tmp_length, width)\n         but is certainly\n           <= tmp_length + width.  */\n      tmp_length = xsum (tmp_length, width);\n# else\n      /* Padding considers the number of elements, says POSIX.  */\n      if (tmp_length < width)\n        tmp_length = width;\n# endif\n    }\n\n  tmp_length = xsum (tmp_length, 1); /* account for trailing NUL */\n\n  return tmp_length;\n}",
      "lines": 236,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "xsum": {
      "start_point": [
        4625,
        16
      ],
      "end_point": [
        5554,
        15
      ],
      "content": "int prefixes[2] IF_LINT (= { 0 });\n                int orig_errno;\n#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif\n\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n#endif\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif\n\n                /* Decide whether to handle the precision ourselves.  */\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif\n\n                /* Decide whether to perform the padding ourselves.  */\n#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif\n\n#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif\n\n                /* Construct the format string for calling snprintf or\n                   sprintf.  */\n                fbp = buf;\n                *fbp++ = '%';\n#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif\n                if (flags & FLAG_LEFT)\n                  *fbp++ = '-';\n                if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';\n                if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';\n                if (flags & FLAG_ALT)\n                  *fbp++ = '#';\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif\n                if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n                if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n\n                switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif\n#endif\n                    FALLTHROUGH;\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }\n#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif\n                  *fbp = dp->conversion;\n#if USE_SNPRINTF\n# if ! (((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif\n\n                /* Construct the arguments for calling snprintf or sprintf.  */\n                prefix_count = 0;\n                if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }\n                if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }\n\n#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif\n\n                orig_errno = errno;\n\n                for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }\n                errno = orig_errno;\n#undef pad_ourselves\n#undef prec_ourselves\n              }",
      "lines": 930,
      "depth": 24,
      "decorators": [
        "int",
        "prefixes[2]",
        "prefixes",
        "[",
        "2",
        "]",
        "IF_LINT (=",
        "IF_LINT",
        "(",
        "=",
        "{ 0 });\n                int orig_errno;\n#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif\n\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n#endif\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif\n\n                /* Decide whether to handle the precision ourselves.  */\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif\n\n                /* Decide whether to perform the padding ourselves.  */\n#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif\n\n#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif\n\n                /* Construct the format string for calling snprintf or\n                   sprintf.  */\n                fbp = buf;\n                *fbp++ = '%';\n#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif\n                if (flags & FLAG_LEFT)\n                  *fbp++ = '-';\n                if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';\n                if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';\n                if (flags & FLAG_ALT)\n                  *fbp++ = '#';\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif\n                if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n                if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n\n                switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif\n#endif\n                    FALLTHROUGH;\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }\n#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif\n                  *fbp = dp->conversion;\n#if USE_SNPRINTF\n# if ! (((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif\n\n                /* Construct the arguments for calling snprintf or sprintf.  */\n                prefix_count = 0;\n                if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }\n                if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }\n\n#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif\n\n                orig_errno = errno;\n\n                for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }\n                errno = orig_errno;\n#undef pad_ourselves\n#undef prec_ourselves\n              }",
        "{",
        "0 });",
        "0",
        "})",
        "}",
        ")",
        ";",
        "int orig_errno;",
        "int",
        "orig_errno",
        ";",
        "#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "size_t tmp_length;",
        "size_t",
        "tmp_length",
        ";",
        "TCHAR_T tmpbuf[700];",
        "TCHAR_T",
        "tmpbuf[700]",
        "tmpbuf",
        "[",
        "700",
        "]",
        ";",
        "TCHAR_T *tmp;",
        "TCHAR_T",
        "*tmp",
        "*",
        "tmp",
        ";",
        "#endif",
        "#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_width = 0;",
        "has_width = 0",
        "has_width",
        "=",
        "0",
        ";",
        "#endif",
        "#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "||",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "USE_MSVC__SNPRINTF",
        "||",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "width = 0;",
        "width = 0",
        "width",
        "=",
        "0",
        ";",
        "if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }",
        "if",
        "(dp->width_start != dp->width_end)",
        "(",
        "dp->width_start != dp->width_end",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        "{\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }",
        "{",
        "if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }",
        "if",
        "(dp->width_arg_index != ARG_NONE)",
        "(",
        "dp->width_arg_index != ARG_NONE",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }",
        "{",
        "int arg;",
        "int",
        "arg",
        ";",
        "if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();",
        "if",
        "(!(a.arg[dp->width_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->width_arg_index].type == TYPE_INT",
        "a.arg[dp->width_arg_index].type",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "arg = a.arg[dp->width_arg_index].a.a_int;",
        "arg = a.arg[dp->width_arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->width_arg_index].a.a_int",
        "a.arg[dp->width_arg_index].a",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "width = arg;",
        "width = arg",
        "width",
        "=",
        "arg",
        ";",
        "if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }",
        "if",
        "(arg < 0)",
        "(",
        "arg < 0",
        "arg",
        "<",
        "0",
        ")",
        "{\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }",
        "{",
        "/* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */",
        "flags |= FLAG_LEFT;",
        "flags |= FLAG_LEFT",
        "flags",
        "|=",
        "FLAG_LEFT",
        ";",
        "width = -width;",
        "width = -width",
        "width",
        "=",
        "-width",
        "-",
        "width",
        ";",
        "}",
        "}",
        "else",
        "{\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }",
        "{",
        "const FCHAR_T *digitp = dp->width_start;",
        "const",
        "const",
        "FCHAR_T",
        "*digitp = dp->width_start",
        "*digitp",
        "*",
        "digitp",
        "=",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);",
        "do",
        "width = xsum (xtimes (width, 10), *digitp++ - '0');",
        "width = xsum (xtimes (width, 10), *digitp++ - '0')",
        "width",
        "=",
        "xsum (xtimes (width, 10), *digitp++ - '0')",
        "xsum",
        "(xtimes (width, 10), *digitp++ - '0')",
        "(",
        "xtimes (width, 10)",
        "xtimes",
        "(width, 10)",
        "(",
        "width",
        ",",
        "10",
        ")",
        ",",
        "*digitp++ - '0'",
        "*digitp++",
        "*",
        "digitp++",
        "digitp",
        "++",
        "-",
        "'0'",
        "'",
        "'",
        ")",
        ";",
        "while",
        "(digitp != dp->width_end)",
        "(",
        "digitp != dp->width_end",
        "digitp",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        ";",
        "}",
        "#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_width = 1;",
        "has_width = 1",
        "has_width",
        "=",
        "1",
        ";",
        "#endif",
        "}",
        "#endif",
        "#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "||",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "USE_MSVC__SNPRINTF",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_precision = 0;",
        "has_precision = 0",
        "has_precision",
        "=",
        "0",
        ";",
        "precision = 6;",
        "precision = 6",
        "precision",
        "=",
        "6",
        ";",
        "if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }",
        "if",
        "(dp->precision_start != dp->precision_end)",
        "(",
        "dp->precision_start != dp->precision_end",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "{\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }",
        "{",
        "if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }",
        "if",
        "(dp->precision_arg_index != ARG_NONE)",
        "(",
        "dp->precision_arg_index != ARG_NONE",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }",
        "{",
        "int arg;",
        "int",
        "arg",
        ";",
        "if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();",
        "if",
        "(!(a.arg[dp->precision_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->precision_arg_index].type == TYPE_INT",
        "a.arg[dp->precision_arg_index].type",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "arg = a.arg[dp->precision_arg_index].a.a_int;",
        "arg = a.arg[dp->precision_arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->precision_arg_index].a.a_int",
        "a.arg[dp->precision_arg_index].a",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "/* \"A negative precision is taken as if the precision\n                            were omitted.\"  */",
        "if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }",
        "if",
        "(arg >= 0)",
        "(",
        "arg >= 0",
        "arg",
        ">=",
        "0",
        ")",
        "{\n                            precision = arg;\n                            has_precision = 1;\n                          }",
        "{",
        "precision = arg;",
        "precision = arg",
        "precision",
        "=",
        "arg",
        ";",
        "has_precision = 1;",
        "has_precision = 1",
        "has_precision",
        "=",
        "1",
        ";",
        "}",
        "}",
        "else",
        "{\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }",
        "{",
        "const FCHAR_T *digitp = dp->precision_start + 1;",
        "const",
        "const",
        "FCHAR_T",
        "*digitp = dp->precision_start + 1",
        "*digitp",
        "*",
        "digitp",
        "=",
        "dp->precision_start + 1",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "+",
        "1",
        ";",
        "precision = 0;",
        "precision = 0",
        "precision",
        "=",
        "0",
        ";",
        "while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');",
        "while",
        "(digitp != dp->precision_end)",
        "(",
        "digitp != dp->precision_end",
        "digitp",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "precision = xsum (xtimes (precision, 10), *digitp++ - '0');",
        "precision = xsum (xtimes (precision, 10), *digitp++ - '0')",
        "precision",
        "=",
        "xsum (xtimes (precision, 10), *digitp++ - '0')",
        "xsum",
        "(xtimes (precision, 10), *digitp++ - '0')",
        "(",
        "xtimes (precision, 10)",
        "xtimes",
        "(precision, 10)",
        "(",
        "precision",
        ",",
        "10",
        ")",
        ",",
        "*digitp++ - '0'",
        "*digitp++",
        "*",
        "digitp++",
        "digitp",
        "++",
        "-",
        "'0'",
        "'",
        "'",
        ")",
        ";",
        "has_precision = 1;",
        "has_precision = 1",
        "has_precision",
        "=",
        "1",
        ";",
        "}",
        "}",
        "#endif",
        "/* Decide whether to handle the precision ourselves.  */",
        "#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif",
        "#if",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }",
        "switch",
        "(dp->conversion)",
        "(",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ")",
        "{\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }",
        "{",
        "case 'd':",
        "case",
        "'d'",
        "'",
        "'",
        ":",
        "case 'i':",
        "case",
        "'i'",
        "'",
        "'",
        ":",
        "case 'u':",
        "case",
        "'u'",
        "'",
        "'",
        ":",
        "case 'o':",
        "case",
        "'o'",
        "'",
        "'",
        ":",
        "case 'x':",
        "case",
        "'x'",
        "'",
        "'",
        ":",
        "case 'X':",
        "case",
        "'X'",
        "'",
        "'",
        ":",
        "case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;",
        "case",
        "'p'",
        "'",
        "'",
        ":",
        "prec_ourselves = has_precision && (precision > 0);",
        "prec_ourselves = has_precision && (precision > 0)",
        "prec_ourselves",
        "=",
        "has_precision && (precision > 0)",
        "has_precision",
        "&&",
        "(precision > 0)",
        "(",
        "precision > 0",
        "precision",
        ">",
        "0",
        ")",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    prec_ourselves = 0;\n                    break;",
        "default",
        ":",
        "prec_ourselves = 0;",
        "prec_ourselves = 0",
        "prec_ourselves",
        "=",
        "0",
        ";",
        "break;",
        "break",
        ";",
        "}",
        "#endif",
        "/* Decide whether to perform the padding ourselves.  */",
        "#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif",
        "#if",
        "!NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)",
        "!NEED_PRINTF_FLAG_LEFTADJUST",
        "!",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "&&",
        "(!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)",
        "(",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        ")",
        "\n",
        "switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }",
        "switch",
        "(dp->conversion)",
        "(",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ")",
        "{\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }",
        "{",
        "# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif",
        "# if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "\n",
        "/* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */",
        "case 'c':",
        "case",
        "'c'",
        "'",
        "'",
        ":",
        "case 's':",
        "case",
        "'s'",
        "'",
        "'",
        ":",
        "# endif",
        "# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif",
        "# if",
        "NEED_PRINTF_FLAG_ZERO",
        "\n",
        "case 'f':",
        "case",
        "'f'",
        "'",
        "'",
        ":",
        "case 'F':",
        "case",
        "'F'",
        "'",
        "'",
        ":",
        "case 'e':",
        "case",
        "'e'",
        "'",
        "'",
        ":",
        "case 'E':",
        "case",
        "'E'",
        "'",
        "'",
        ":",
        "case 'g':",
        "case",
        "'g'",
        "'",
        "'",
        ":",
        "case 'G':",
        "case",
        "'G'",
        "'",
        "'",
        ":",
        "case 'a':",
        "case",
        "'a'",
        "'",
        "'",
        ":",
        "case 'A':",
        "case",
        "'A'",
        "'",
        "'",
        ":",
        "# endif",
        "pad_ourselves = 1;",
        "pad_ourselves = 1",
        "pad_ourselves",
        "=",
        "1",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    pad_ourselves = prec_ourselves;\n                    break;",
        "default",
        ":",
        "pad_ourselves = prec_ourselves;",
        "pad_ourselves = prec_ourselves",
        "pad_ourselves",
        "=",
        "prec_ourselves",
        ";",
        "break;",
        "break",
        ";",
        "}",
        "#endif",
        "#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "/* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */",
        "tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);",
        "tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "tmp_length",
        "=",
        "MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "MAX_ROOM_NEEDED",
        "(&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "(",
        "&a",
        "&",
        "a",
        ",",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        ",",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ",",
        "type",
        ",",
        "flags",
        ",",
        "width",
        ",",
        "has_precision",
        ",",
        "precision",
        ",",
        "pad_ourselves",
        ")",
        ";",
        "if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }",
        "if",
        "(tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))",
        "(",
        "tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T)",
        "tmp_length",
        "<=",
        "sizeof (tmpbuf) / sizeof (TCHAR_T)",
        "sizeof (tmpbuf)",
        "sizeof",
        "(",
        "tmpbuf",
        "tmpbuf",
        ")",
        "/",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "tmp = tmpbuf;",
        "tmp = tmpbuf",
        "tmp",
        "=",
        "tmpbuf",
        ";",
        "else",
        "{\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }",
        "{",
        "size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));",
        "size_t",
        "tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T))",
        "tmp_memsize",
        "=",
        "xtimes (tmp_length, sizeof (TCHAR_T))",
        "xtimes",
        "(tmp_length, sizeof (TCHAR_T))",
        "(",
        "tmp_length",
        ",",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;",
        "if",
        "(size_overflow_p (tmp_memsize))",
        "(",
        "size_overflow_p (tmp_memsize)",
        "size_overflow_p",
        "(tmp_memsize)",
        "(",
        "tmp_memsize",
        ")",
        ")",
        "/* Overflow, would lead to out of memory.  */",
        "goto out_of_memory;",
        "goto",
        "out_of_memory",
        ";",
        "tmp = (TCHAR_T *) malloc (tmp_memsize);",
        "tmp = (TCHAR_T *) malloc (tmp_memsize)",
        "tmp",
        "=",
        "(TCHAR_T *) malloc (tmp_memsize)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "malloc (tmp_memsize)",
        "malloc",
        "(tmp_memsize)",
        "(",
        "tmp_memsize",
        ")",
        ";",
        "if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;",
        "if",
        "(tmp == NULL)",
        "(",
        "tmp == NULL",
        "tmp",
        "==",
        "NULL",
        ")",
        "/* Out of memory.  */",
        "goto out_of_memory;",
        "goto",
        "out_of_memory",
        ";",
        "}",
        "#endif",
        "/* Construct the format string for calling snprintf or\n                   sprintf.  */",
        "fbp = buf;",
        "fbp = buf",
        "fbp",
        "=",
        "buf",
        ";",
        "*fbp++ = '%';",
        "*fbp++ = '%'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'%'",
        "'",
        "'",
        ";",
        "#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif",
        "#if",
        "NEED_PRINTF_FLAG_GROUPING",
        "\n",
        "/* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */",
        "#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';",
        "#else",
        "if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';",
        "if",
        "(flags & FLAG_GROUP)",
        "(",
        "flags & FLAG_GROUP",
        "flags",
        "&",
        "FLAG_GROUP",
        ")",
        "*fbp++ = '\\'';",
        "*fbp++ = '\\''",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'\\''",
        "'",
        "\\'",
        "'",
        ";",
        "#endif",
        "if (flags & FLAG_LEFT)\n                  *fbp++ = '-';",
        "if",
        "(flags & FLAG_LEFT)",
        "(",
        "flags & FLAG_LEFT",
        "flags",
        "&",
        "FLAG_LEFT",
        ")",
        "*fbp++ = '-';",
        "*fbp++ = '-'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'-'",
        "'",
        "'",
        ";",
        "if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';",
        "if",
        "(flags & FLAG_SHOWSIGN)",
        "(",
        "flags & FLAG_SHOWSIGN",
        "flags",
        "&",
        "FLAG_SHOWSIGN",
        ")",
        "*fbp++ = '+';",
        "*fbp++ = '+'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'+'",
        "'",
        "'",
        ";",
        "if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';",
        "if",
        "(flags & FLAG_SPACE)",
        "(",
        "flags & FLAG_SPACE",
        "flags",
        "&",
        "FLAG_SPACE",
        ")",
        "*fbp++ = ' ';",
        "*fbp++ = ' '",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "' '",
        "'",
        "'",
        ";",
        "if (flags & FLAG_ALT)\n                  *fbp++ = '#';",
        "if",
        "(flags & FLAG_ALT)",
        "(",
        "flags & FLAG_ALT",
        "flags",
        "&",
        "FLAG_ALT",
        ")",
        "*fbp++ = '#';",
        "*fbp++ = '#'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'#'",
        "'",
        "'",
        ";",
        "#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif",
        "#if",
        "__GLIBC__ >= 2 && !defined __UCLIBC__",
        "__GLIBC__ >= 2",
        "__GLIBC__",
        ">=",
        "2",
        "&&",
        "!defined __UCLIBC__",
        "!",
        "defined __UCLIBC__",
        "defined",
        "__UCLIBC__",
        "\n",
        "if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';",
        "if",
        "(flags & FLAG_LOCALIZED)",
        "(",
        "flags & FLAG_LOCALIZED",
        "flags",
        "&",
        "FLAG_LOCALIZED",
        ")",
        "*fbp++ = 'I';",
        "*fbp++ = 'I'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'I'",
        "'",
        "'",
        ";",
        "#endif",
        "if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "if",
        "(!pad_ourselves)",
        "(",
        "!pad_ourselves",
        "!",
        "pad_ourselves",
        ")",
        "{\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "{",
        "if (flags & FLAG_ZERO)\n                      *fbp++ = '0';",
        "if",
        "(flags & FLAG_ZERO)",
        "(",
        "flags & FLAG_ZERO",
        "flags",
        "&",
        "FLAG_ZERO",
        ")",
        "*fbp++ = '0';",
        "*fbp++ = '0'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'0'",
        "'",
        "'",
        ";",
        "if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "if",
        "(dp->width_start != dp->width_end)",
        "(",
        "dp->width_start != dp->width_end",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        "{\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "{",
        "size_t n = dp->width_end - dp->width_start;",
        "size_t",
        "n = dp->width_end - dp->width_start",
        "n",
        "=",
        "dp->width_end - dp->width_start",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        "-",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "/* The width specification is known to consist only\n                           of standard ASCII characters.  */",
        "if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "if",
        "(sizeof (FCHAR_T) == sizeof (TCHAR_T))",
        "(",
        "sizeof (FCHAR_T) == sizeof (TCHAR_T)",
        "sizeof (FCHAR_T)",
        "sizeof",
        "(FCHAR_T)",
        "(",
        "FCHAR_T",
        ")",
        "==",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "{\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }",
        "{",
        "memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));",
        "memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T))",
        "memcpy",
        "(fbp, dp->width_start, n * sizeof (TCHAR_T))",
        "(",
        "fbp",
        ",",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ",",
        "n * sizeof (TCHAR_T)",
        "n",
        "*",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "fbp += n;",
        "fbp += n",
        "fbp",
        "+=",
        "n",
        ";",
        "}",
        "else",
        "{\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "{",
        "const FCHAR_T *mp = dp->width_start;",
        "const",
        "const",
        "FCHAR_T",
        "*mp = dp->width_start",
        "*mp",
        "*",
        "mp",
        "=",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "do\n                              *fbp++ = *mp++;\n                            while (--n > 0);",
        "do",
        "*fbp++ = *mp++;",
        "*fbp++ = *mp++",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "*mp++",
        "*",
        "mp++",
        "mp",
        "++",
        ";",
        "while",
        "(--n > 0)",
        "(",
        "--n > 0",
        "--n",
        "--",
        "n",
        ">",
        "0",
        ")",
        ";",
        "}",
        "}",
        "}",
        "if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "if",
        "(!prec_ourselves)",
        "(",
        "!prec_ourselves",
        "!",
        "prec_ourselves",
        ")",
        "{\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "{",
        "if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "if",
        "(dp->precision_start != dp->precision_end)",
        "(",
        "dp->precision_start != dp->precision_end",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "{\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "{",
        "size_t n = dp->precision_end - dp->precision_start;",
        "size_t",
        "n = dp->precision_end - dp->precision_start",
        "n",
        "=",
        "dp->precision_end - dp->precision_start",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        "-",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ";",
        "/* The precision specification is known to consist only\n                           of standard ASCII characters.  */",
        "if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "if",
        "(sizeof (FCHAR_T) == sizeof (TCHAR_T))",
        "(",
        "sizeof (FCHAR_T) == sizeof (TCHAR_T)",
        "sizeof (FCHAR_T)",
        "sizeof",
        "(FCHAR_T)",
        "(",
        "FCHAR_T",
        ")",
        "==",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "{\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }",
        "{",
        "memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));",
        "memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T))",
        "memcpy",
        "(fbp, dp->precision_start, n * sizeof (TCHAR_T))",
        "(",
        "fbp",
        ",",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ",",
        "n * sizeof (TCHAR_T)",
        "n",
        "*",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "fbp += n;",
        "fbp += n",
        "fbp",
        "+=",
        "n",
        ";",
        "}",
        "else",
        "{\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "{",
        "const FCHAR_T *mp = dp->precision_start;",
        "const",
        "const",
        "FCHAR_T",
        "*mp = dp->precision_start",
        "*mp",
        "*",
        "mp",
        "=",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ";",
        "do\n                              *fbp++ = *mp++;\n                            while (--n > 0);",
        "do",
        "*fbp++ = *mp++;",
        "*fbp++ = *mp++",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "*mp++",
        "*",
        "mp++",
        "mp",
        "++",
        ";",
        "while",
        "(--n > 0)",
        "(",
        "--n > 0",
        "--n",
        "--",
        "n",
        ">",
        "0",
        ")",
        ";",
        "}",
        "}",
        "}",
        "switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif\n#endif\n                    FALLTHROUGH;\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }",
        "switch",
        "(type)",
        "(",
        "type",
        ")",
        "{\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif\n#endif\n                    FALLTHROUGH;\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }",
        "{",
        "#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif\n#endif",
        "#if",
        "HAVE_LONG_LONG_INT",
        "\n",
        "case TYPE_LONGLONGINT:",
        "case",
        "TYPE_LONGLONGINT",
        ":",
        "case TYPE_ULONGLONGINT:",
        "case",
        "TYPE_ULONGLONGINT",
        ":",
        "# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif",
        "# if",
        "(defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__",
        "(defined _WIN32 || defined __WIN32__)",
        "(",
        "defined _WIN32 || defined __WIN32__",
        "defined _WIN32",
        "defined",
        "_WIN32",
        "||",
        "defined __WIN32__",
        "defined",
        "__WIN32__",
        ")",
        "&&",
        "! defined __CYGWIN__",
        "!",
        "defined __CYGWIN__",
        "defined",
        "__CYGWIN__",
        "\n",
        "*fbp++ = 'I';",
        "*fbp++ = 'I'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'I'",
        "'",
        "'",
        ";",
        "*fbp++ = '6';",
        "*fbp++ = '6'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'6'",
        "'",
        "'",
        ";",
        "*fbp++ = '4';",
        "*fbp++ = '4'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'4'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "# else\n                    *fbp++ = 'l';",
        "# else",
        "*fbp++ = 'l';",
        "*fbp++ = 'l'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'l'",
        "'",
        "'",
        ";",
        "# endif",
        "#endif",
        "FALLTHROUGH;",
        "FALLTHROUGH",
        ";",
        "case TYPE_LONGINT:",
        "case",
        "TYPE_LONGINT",
        ":",
        "case TYPE_ULONGINT:",
        "case",
        "TYPE_ULONGINT",
        ":",
        "#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif",
        "#if",
        "HAVE_WINT_T",
        "\n",
        "case TYPE_WIDE_CHAR:",
        "case",
        "TYPE_WIDE_CHAR",
        ":",
        "#endif",
        "#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif",
        "#if",
        "HAVE_WCHAR_T",
        "\n",
        "case TYPE_WIDE_STRING:",
        "case",
        "TYPE_WIDE_STRING",
        ":",
        "#endif",
        "*fbp++ = 'l';",
        "*fbp++ = 'l'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'l'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;",
        "case",
        "TYPE_LONGDOUBLE",
        ":",
        "*fbp++ = 'L';",
        "*fbp++ = 'L'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'L'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    break;",
        "default",
        ":",
        "break;",
        "break",
        ";",
        "}",
        "#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif",
        "#if",
        "NEED_PRINTF_DIRECTIVE_F",
        "\n",
        "if (dp->conversion == 'F')\n                  *fbp = 'f';",
        "if",
        "(dp->conversion == 'F')",
        "(",
        "dp->conversion == 'F'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'F'",
        "'",
        "'",
        ")",
        "*fbp = 'f';",
        "*fbp = 'f'",
        "*fbp",
        "*",
        "fbp",
        "=",
        "'f'",
        "'",
        "'",
        ";",
        "else",
        "else",
        "#endif",
        "*fbp = dp->conversion;",
        "*fbp = dp->conversion",
        "*fbp",
        "*",
        "fbp",
        "=",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ";",
        "#if USE_SNPRINTF\n# if ! (((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "# if ! (((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif",
        "# if",
        "! (((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))",
        "!",
        "(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))",
        "(",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)",
        "(",
        "(__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__",
        "(__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))",
        "(",
        "__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)",
        "__GLIBC__ > 2",
        "__GLIBC__",
        ">",
        "2",
        "||",
        "(__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)",
        "(",
        "__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3",
        "__GLIBC__ == 2",
        "__GLIBC__",
        "==",
        "2",
        "&&",
        "__GLIBC_MINOR__ >= 3",
        "__GLIBC_MINOR__",
        ">=",
        "3",
        ")",
        ")",
        "&&",
        "!defined __UCLIBC__",
        "!",
        "defined __UCLIBC__",
        "defined",
        "__UCLIBC__",
        ")",
        "||",
        "(defined __APPLE__ && defined __MACH__)",
        "(",
        "defined __APPLE__ && defined __MACH__",
        "defined __APPLE__",
        "defined",
        "__APPLE__",
        "&&",
        "defined __MACH__",
        "defined",
        "__MACH__",
        ")",
        "||",
        "((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)",
        "(",
        "(defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__",
        "(defined _WIN32 || defined __WIN32__)",
        "(",
        "defined _WIN32 || defined __WIN32__",
        "defined _WIN32",
        "defined",
        "_WIN32",
        "||",
        "defined __WIN32__",
        "defined",
        "__WIN32__",
        ")",
        "&&",
        "! defined __CYGWIN__",
        "!",
        "defined __CYGWIN__",
        "defined",
        "__CYGWIN__",
        ")",
        ")",
        "\n",
        "fbp[1] = '%';",
        "fbp[1] = '%'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'%'",
        "'",
        "'",
        ";",
        "fbp[2] = 'n';",
        "fbp[2] = 'n'",
        "fbp[2]",
        "fbp",
        "[",
        "2",
        "]",
        "=",
        "'n'",
        "'",
        "'",
        ";",
        "fbp[3] = '\\0';",
        "fbp[3] = '\\0'",
        "fbp[3]",
        "fbp",
        "[",
        "3",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';",
        "# else",
        "/* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */",
        "/* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */",
        "/* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "# endif",
        "#else\n                fbp[1] = '\\0';",
        "#else",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "#endif",
        "/* Construct the arguments for calling snprintf or sprintf.  */",
        "prefix_count = 0;",
        "prefix_count = 0",
        "prefix_count",
        "=",
        "0",
        ";",
        "if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }",
        "if",
        "(!pad_ourselves && dp->width_arg_index != ARG_NONE)",
        "(",
        "!pad_ourselves && dp->width_arg_index != ARG_NONE",
        "!pad_ourselves",
        "!",
        "pad_ourselves",
        "&&",
        "dp->width_arg_index != ARG_NONE",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }",
        "{",
        "if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();",
        "if",
        "(!(a.arg[dp->width_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->width_arg_index].type == TYPE_INT",
        "a.arg[dp->width_arg_index].type",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;",
        "prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int",
        "prefixes[prefix_count++]",
        "prefixes",
        "[",
        "prefix_count++",
        "prefix_count",
        "++",
        "]",
        "=",
        "a.arg[dp->width_arg_index].a.a_int",
        "a.arg[dp->width_arg_index].a",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "}",
        "if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }",
        "if",
        "(!prec_ourselves && dp->precision_arg_index != ARG_NONE)",
        "(",
        "!prec_ourselves && dp->precision_arg_index != ARG_NONE",
        "!prec_ourselves",
        "!",
        "prec_ourselves",
        "&&",
        "dp->precision_arg_index != ARG_NONE",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }",
        "{",
        "if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();",
        "if",
        "(!(a.arg[dp->precision_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->precision_arg_index].type == TYPE_INT",
        "a.arg[dp->precision_arg_index].type",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;",
        "prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int",
        "prefixes[prefix_count++]",
        "prefixes",
        "[",
        "prefix_count++",
        "prefix_count",
        "++",
        "]",
        "=",
        "a.arg[dp->precision_arg_index].a.a_int",
        "a.arg[dp->precision_arg_index].a",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "}",
        "#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */",
        "# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n",
        "# define",
        "TCHARS_PER_DCHAR",
        " (sizeof (DCHAR_T) / sizeof (TCHAR_T))",
        "\n",
        "/* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */",
        "ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));",
        "ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR))",
        "ENSURE_ALLOCATION",
        "(xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR))",
        "(",
        "xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "(2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR",
        "(2 + TCHARS_PER_DCHAR - 1)",
        "(",
        "2 + TCHARS_PER_DCHAR - 1",
        "2 + TCHARS_PER_DCHAR",
        "2",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ")",
        ";",
        "/* Prepare checking whether snprintf returns the count\n                   via %n.  */",
        "*(TCHAR_T *) (result + length) = '\\0';",
        "*(TCHAR_T *) (result + length) = '\\0'",
        "*(TCHAR_T *) (result + length)",
        "*",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "#endif",
        "orig_errno = errno;",
        "orig_errno = errno",
        "orig_errno",
        "=",
        "errno",
        ";",
        "for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }",
        "for",
        "(",
        ";",
        ";",
        ")",
        "{\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }",
        "{",
        "int count = -1;",
        "int",
        "count = -1",
        "count",
        "=",
        "-1",
        ";",
        "#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "int retcount = 0;",
        "int",
        "retcount = 0",
        "retcount",
        "=",
        "0",
        ";",
        "size_t maxlen = allocated - length;",
        "size_t",
        "maxlen = allocated - length",
        "maxlen",
        "=",
        "allocated - length",
        "allocated",
        "-",
        "length",
        ";",
        "/* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */",
        "if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;",
        "if",
        "(maxlen > INT_MAX / TCHARS_PER_DCHAR)",
        "(",
        "maxlen > INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        ">",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        "maxlen = INT_MAX / TCHARS_PER_DCHAR;",
        "maxlen = INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        "=",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "maxlen = maxlen * TCHARS_PER_DCHAR;",
        "maxlen = maxlen * TCHARS_PER_DCHAR",
        "maxlen",
        "=",
        "maxlen * TCHARS_PER_DCHAR",
        "maxlen",
        "*",
        "TCHARS_PER_DCHAR",
        ";",
        "# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "# define",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        " \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }",
        "\n",
        "#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "#else",
        "# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "# define",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        " \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }",
        "\n",
        "#endif",
        "errno = 0;",
        "errno = 0",
        "errno",
        "=",
        "0",
        ";",
        "switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }",
        "switch",
        "(type)",
        "(",
        "type",
        ")",
        "{\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }",
        "{",
        "case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_SCHAR",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_schar;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_schar",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_schar",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_schar",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_UCHAR",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_uchar;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_uchar",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_uchar",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_uchar",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_SHORT",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_short;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_short",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_short",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_short",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_USHORT",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_ushort;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ushort",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ushort",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ushort",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_INT",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_int;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_int",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_UINT",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_uint;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_uint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_uint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_uint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGINT",
        ":",
        "{\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long int arg = a.arg[dp->arg_index].a.a_longint;",
        "long int",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_longint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_ULONGINT",
        ":",
        "{\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;",
        "unsigned long int",
        "unsigned",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ulongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ulongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ulongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_LONG_LONG_INT",
        "\n",
        "case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGLONGINT",
        ":",
        "{\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long long int arg = a.arg[dp->arg_index].a.a_longlongint;",
        "long long int",
        "long",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_longlongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longlongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longlongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_ULONGLONGINT",
        ":",
        "{\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;",
        "unsigned long long int",
        "unsigned",
        "long",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ulonglongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ulonglongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ulonglongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_DOUBLE",
        ":",
        "{\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "double arg = a.arg[dp->arg_index].a.a_double;",
        "double",
        "arg = a.arg[dp->arg_index].a.a_double",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_double",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_double",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGDOUBLE",
        ":",
        "{\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long double arg = a.arg[dp->arg_index].a.a_longdouble;",
        "long double",
        "long",
        "double",
        "arg = a.arg[dp->arg_index].a.a_longdouble",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longdouble",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longdouble",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_CHAR",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_char;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_char",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_char",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_char",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_WINT_T",
        "\n",
        "case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_WIDE_CHAR",
        ":",
        "{\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "wint_t arg = a.arg[dp->arg_index].a.a_wide_char;",
        "wint_t",
        "arg = a.arg[dp->arg_index].a.a_wide_char",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_wide_char",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_wide_char",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_STRING",
        ":",
        "{\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "const char *arg = a.arg[dp->arg_index].a.a_string;",
        "const",
        "const",
        "char",
        "*arg = a.arg[dp->arg_index].a.a_string",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_string",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_string",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_WCHAR_T",
        "\n",
        "case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_WIDE_STRING",
        ":",
        "{\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;",
        "const",
        "const",
        "wchar_t",
        "*arg = a.arg[dp->arg_index].a.a_wide_string",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_wide_string",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_wide_string",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_POINTER",
        ":",
        "{\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "void *arg = a.arg[dp->arg_index].a.a_pointer;",
        "void",
        "*arg = a.arg[dp->arg_index].a.a_pointer",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_pointer",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_pointer",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "default:\n                        abort ();",
        "default",
        ":",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "}",
        "#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */",
        "if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }",
        "if",
        "(count >= 0)",
        "(",
        "count >= 0",
        "count",
        ">=",
        "0",
        ")",
        "{\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }",
        "{",
        "/* Verify that snprintf() has NUL-terminated its\n                           result.  */",
        "if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();",
        "if",
        "(count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')",
        "(",
        "count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0'",
        "count < maxlen",
        "count",
        "<",
        "maxlen",
        "&&",
        "((TCHAR_T *) (result + length)) [count] != '\\0'",
        "((TCHAR_T *) (result + length)) [count]",
        "((TCHAR_T *) (result + length))",
        "(",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ")",
        "[",
        "count",
        "]",
        "!=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "/* Portability hack.  */",
        "if (retcount > count)\n                          count = retcount;",
        "if",
        "(retcount > count)",
        "(",
        "retcount > count",
        "retcount",
        ">",
        "count",
        ")",
        "count = retcount;",
        "count = retcount",
        "count",
        "=",
        "retcount",
        ";",
        "}",
        "else",
        "{\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }",
        "{",
        "/* snprintf() doesn't understand the '%n'\n                           directive.  */",
        "if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }",
        "if",
        "(fbp[1] != '\\0')",
        "(",
        "fbp[1] != '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "!=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ")",
        "{\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }",
        "{",
        "/* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "else",
        "{\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }",
        "{",
        "/* Look at the snprintf() return value.  */",
        "if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;",
        "if",
        "(retcount < 0)",
        "(",
        "retcount < 0",
        "retcount",
        "<",
        "0",
        ")",
        "{\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }",
        "{",
        "# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif",
        "# if",
        "!HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "USE_MSVC__SNPRINTF",
        "\n",
        "/* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */",
        "size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);",
        "size_t",
        "tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "tmp_length",
        "=",
        "MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "MAX_ROOM_NEEDED",
        "(&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "(",
        "&a",
        "&",
        "a",
        ",",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        ",",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ",",
        "type",
        ",",
        "flags",
        ",",
        "width",
        ",",
        "has_precision",
        ",",
        "precision",
        ",",
        "pad_ourselves",
        ")",
        ";",
        "if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }",
        "if",
        "(maxlen < tmp_length)",
        "(",
        "maxlen < tmp_length",
        "maxlen",
        "<",
        "tmp_length",
        ")",
        "{\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }",
        "{",
        "/* Make more room.  But try to do through\n                                       this reallocation only once.  */",
        "size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);",
        "size_t",
        "bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "bigger_need",
        "=",
        "xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR",
        "xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)",
        "xsum",
        "(tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)",
        "(",
        "tmp_length",
        ",",
        "TCHARS_PER_DCHAR - 1",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ";",
        "/* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */",
        "size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);",
        "size_t",
        "bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12)",
        "bigger_need2",
        "=",
        "xsum (xtimes (allocated, 2), 12)",
        "xsum",
        "(xtimes (allocated, 2), 12)",
        "(",
        "xtimes (allocated, 2)",
        "xtimes",
        "(allocated, 2)",
        "(",
        "allocated",
        ",",
        "2",
        ")",
        ",",
        "12",
        ")",
        ";",
        "if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;",
        "if",
        "(bigger_need < bigger_need2)",
        "(",
        "bigger_need < bigger_need2",
        "bigger_need",
        "<",
        "bigger_need2",
        ")",
        "bigger_need = bigger_need2;",
        "bigger_need = bigger_need2",
        "bigger_need",
        "=",
        "bigger_need2",
        ";",
        "ENSURE_ALLOCATION (bigger_need);",
        "ENSURE_ALLOCATION (bigger_need)",
        "ENSURE_ALLOCATION",
        "(bigger_need)",
        "(",
        "bigger_need",
        ")",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "# endif",
        "}",
        "else",
        "count = retcount;",
        "count = retcount",
        "count",
        "=",
        "retcount",
        ";",
        "}",
        "}",
        "#endif",
        "/* Attempt to handle failure.  */",
        "if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }",
        "if",
        "(count < 0)",
        "(",
        "count < 0",
        "count",
        "<",
        "0",
        ")",
        "{\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }",
        "{",
        "/* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */",
        "int saved_errno = errno;",
        "int",
        "saved_errno = errno",
        "saved_errno",
        "=",
        "errno",
        ";",
        "if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }",
        "if",
        "(saved_errno == 0)",
        "(",
        "saved_errno == 0",
        "saved_errno",
        "==",
        "0",
        ")",
        "{\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }",
        "{",
        "if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;",
        "if",
        "(dp->conversion == 'c' || dp->conversion == 's')",
        "(",
        "dp->conversion == 'c' || dp->conversion == 's'",
        "dp->conversion == 'c'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'c'",
        "'",
        "'",
        "||",
        "dp->conversion == 's'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'s'",
        "'",
        "'",
        ")",
        "saved_errno = EILSEQ;",
        "saved_errno = EILSEQ",
        "saved_errno",
        "=",
        "EILSEQ",
        ";",
        "else",
        "saved_errno = EINVAL;",
        "saved_errno = EINVAL",
        "saved_errno",
        "=",
        "EINVAL",
        ";",
        "}",
        "if (!(result == resultbuf || result == NULL))\n                          free (result);",
        "if",
        "(!(result == resultbuf || result == NULL))",
        "(",
        "!(result == resultbuf || result == NULL)",
        "!",
        "(result == resultbuf || result == NULL)",
        "(",
        "result == resultbuf || result == NULL",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        "||",
        "result == NULL",
        "result",
        "==",
        "NULL",
        ")",
        ")",
        "free (result);",
        "free (result)",
        "free",
        "(result)",
        "(",
        "result",
        ")",
        ";",
        "if (buf_malloced != NULL)\n                          free (buf_malloced);",
        "if",
        "(buf_malloced != NULL)",
        "(",
        "buf_malloced != NULL",
        "buf_malloced",
        "!=",
        "NULL",
        ")",
        "free (buf_malloced);",
        "free (buf_malloced)",
        "free",
        "(buf_malloced)",
        "(",
        "buf_malloced",
        ")",
        ";",
        "CLEANUP ();",
        "CLEANUP ()",
        "CLEANUP",
        "()",
        "(",
        ")",
        ";",
        "errno = saved_errno;",
        "errno = saved_errno",
        "errno",
        "=",
        "saved_errno",
        ";",
        "return NULL;",
        "return",
        "NULL",
        ";",
        "}",
        "#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */",
        "if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }",
        "if",
        "((unsigned int) count + 1 >= maxlen)",
        "(",
        "(unsigned int) count + 1 >= maxlen",
        "(unsigned int) count + 1",
        "(unsigned int) count",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "count",
        "+",
        "1",
        ">=",
        "maxlen",
        ")",
        "{\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }",
        "{",
        "/* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */",
        "if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }",
        "if",
        "(maxlen == INT_MAX / TCHARS_PER_DCHAR)",
        "(",
        "maxlen == INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        "==",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        "goto overflow;",
        "goto",
        "overflow",
        ";",
        "else",
        "{\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }",
        "{",
        "/* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */",
        "size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));",
        "size_t",
        "n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "n",
        "=",
        "xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "xmax",
        "(xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "(",
        "xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR",
        "((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)",
        "(",
        "(unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1",
        "(unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR",
        "(unsigned int) count + 2",
        "(unsigned int) count",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "count",
        "+",
        "2",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ",",
        "xtimes (allocated, 2)",
        "xtimes",
        "(allocated, 2)",
        "(",
        "allocated",
        ",",
        "2",
        ")",
        ")",
        ";",
        "ENSURE_ALLOCATION (n);",
        "ENSURE_ALLOCATION (n)",
        "ENSURE_ALLOCATION",
        "(n)",
        "(",
        "n",
        ")",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "}",
        "#endif",
        "#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif",
        "#if",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }",
        "if",
        "(prec_ourselves)",
        "(",
        "prec_ourselves",
        ")",
        "{\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }",
        "{",
        "/* Handle the precision.  */",
        "TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);",
        "TCHAR_T",
        "*prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length)",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "=",
        "# if",
        "# if",
        "USE_SNPRINTF\n                          (TCHAR_T *) (result + length)",
        "USE_SNPRINTF\n                          (TCHAR_T *)",
        "USE_SNPRINTF",
        "(TCHAR_T *)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# else\n                          tmp;\n",
        "# else",
        "\n                          tmp;",
        "\n",
        "# endif\n                        size_t prefix_count;\n",
        "# endif",
        "\n                        size_t prefix_count;",
        "\n",
        "size_t move;",
        "size_t",
        "move",
        ";",
        "prefix_count = 0;",
        "prefix_count = 0",
        "prefix_count",
        "=",
        "0",
        ";",
        "/* Put the additional zeroes after the sign.  */",
        "if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;",
        "if",
        "(count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))",
        "(",
        "count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' ')",
        "count >= 1",
        "count",
        ">=",
        "1",
        "&&",
        "(*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' ')",
        "(",
        "*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '",
        "*prec_ptr == '-' || *prec_ptr == '+'",
        "*prec_ptr == '-'",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "'-'",
        "'",
        "'",
        "||",
        "*prec_ptr == '+'",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "'+'",
        "'",
        "'",
        "||",
        "*prec_ptr == ' '",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "' '",
        "'",
        "'",
        ")",
        ")",
        "prefix_count = 1;",
        "prefix_count = 1",
        "prefix_count",
        "=",
        "1",
        ";",
        "/* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */",
        "else",
        "if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;",
        "if",
        "(count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))",
        "(",
        "count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X')",
        "count >= 2\n                                 && prec_ptr[0] == '0'",
        "count >= 2",
        "count",
        ">=",
        "2",
        "&&",
        "prec_ptr[0] == '0'",
        "prec_ptr[0]",
        "prec_ptr",
        "[",
        "0",
        "]",
        "==",
        "'0'",
        "'",
        "'",
        "&&",
        "(prec_ptr[1] == 'x' || prec_ptr[1] == 'X')",
        "(",
        "prec_ptr[1] == 'x' || prec_ptr[1] == 'X'",
        "prec_ptr[1] == 'x'",
        "prec_ptr[1]",
        "prec_ptr",
        "[",
        "1",
        "]",
        "==",
        "'x'",
        "'",
        "'",
        "||",
        "prec_ptr[1] == 'X'",
        "prec_ptr[1]",
        "prec_ptr",
        "[",
        "1",
        "]",
        "==",
        "'X'",
        "'",
        "'",
        ")",
        ")",
        "prefix_count = 2;",
        "prefix_count = 2",
        "prefix_count",
        "=",
        "2",
        ";",
        "move = count - prefix_count;",
        "move = count - prefix_count",
        "move",
        "=",
        "count - prefix_count",
        "count",
        "-",
        "prefix_count",
        ";",
        "if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }",
        "if",
        "(precision > move)",
        "(",
        "precision > move",
        "precision",
        ">",
        "move",
        ")",
        "{\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }",
        "{",
        "/* Insert zeroes.  */",
        "size_t insert = precision - move;",
        "size_t",
        "insert = precision - move",
        "insert",
        "=",
        "precision - move",
        "precision",
        "-",
        "move",
        ";",
        "TCHAR_T *prec_end;",
        "TCHAR_T",
        "*prec_end",
        "*",
        "prec_end",
        ";",
        "# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);",
        "size_t",
        "n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "n",
        "=",
        "xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "(count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR",
        "(count + insert + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + insert + TCHARS_PER_DCHAR - 1",
        "count + insert + TCHARS_PER_DCHAR",
        "count + insert",
        "count",
        "+",
        "insert",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ";",
        "length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;",
        "length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "length",
        "+=",
        "(count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "(count + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + TCHARS_PER_DCHAR - 1",
        "count + TCHARS_PER_DCHAR",
        "count",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "ENSURE_ALLOCATION (n);",
        "ENSURE_ALLOCATION (n)",
        "ENSURE_ALLOCATION",
        "(n)",
        "(",
        "n",
        ")",
        ";",
        "length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;",
        "length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "length",
        "-=",
        "(count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "(count + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + TCHARS_PER_DCHAR - 1",
        "count + TCHARS_PER_DCHAR",
        "count",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "prec_ptr = (TCHAR_T *) (result + length);",
        "prec_ptr = (TCHAR_T *) (result + length)",
        "prec_ptr",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# endif",
        "prec_end = prec_ptr + count;",
        "prec_end = prec_ptr + count",
        "prec_end",
        "=",
        "prec_ptr + count",
        "prec_ptr",
        "+",
        "count",
        ";",
        "prec_ptr += prefix_count;",
        "prec_ptr += prefix_count",
        "prec_ptr",
        "+=",
        "prefix_count",
        ";",
        "while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }",
        "while",
        "(prec_end > prec_ptr)",
        "(",
        "prec_end > prec_ptr",
        "prec_end",
        ">",
        "prec_ptr",
        ")",
        "{\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }",
        "{",
        "prec_end--;",
        "prec_end--",
        "prec_end",
        "--",
        ";",
        "prec_end[insert] = prec_end[0];",
        "prec_end[insert] = prec_end[0]",
        "prec_end[insert]",
        "prec_end",
        "[",
        "insert",
        "]",
        "=",
        "prec_end[0]",
        "prec_end",
        "[",
        "0",
        "]",
        ";",
        "}",
        "prec_end += insert;",
        "prec_end += insert",
        "prec_end",
        "+=",
        "insert",
        ";",
        "do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);",
        "do",
        "*--prec_end = '0';",
        "*--prec_end = '0'",
        "*--prec_end",
        "*",
        "--prec_end",
        "--",
        "prec_end",
        "=",
        "'0'",
        "'",
        "'",
        ";",
        "while",
        "(prec_end > prec_ptr)",
        "(",
        "prec_end > prec_ptr",
        "prec_end",
        ">",
        "prec_ptr",
        ")",
        ";",
        "count += insert;",
        "count += insert",
        "count",
        "+=",
        "insert",
        ";",
        "}",
        "}",
        "#endif",
        "#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();",
        "if",
        "(count >= tmp_length)",
        "(",
        "count >= tmp_length",
        "count",
        ">=",
        "tmp_length",
        ")",
        "/* tmp_length was incorrectly calculated - fix the\n                         code above!  */",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "#endif",
        "#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "\n",
        "/* Convert from TCHAR_T[] to DCHAR_T[].  */",
        "if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }",
        "if",
        "(dp->conversion == 'c' || dp->conversion == 's')",
        "(",
        "dp->conversion == 'c' || dp->conversion == 's'",
        "dp->conversion == 'c'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'c'",
        "'",
        "'",
        "||",
        "dp->conversion == 's'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'s'",
        "'",
        "'",
        ")",
        "{\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }",
        "{",
        "/* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */",
        "const TCHAR_T *tmpsrc;",
        "const",
        "const",
        "TCHAR_T",
        "*tmpsrc",
        "*",
        "tmpsrc",
        ";",
        "DCHAR_T *tmpdst;",
        "DCHAR_T",
        "*tmpdst",
        "*",
        "tmpdst",
        ";",
        "size_t tmpdst_len;",
        "size_t",
        "tmpdst_len",
        ";",
        "/* This code assumes that TCHAR_T is 'char'.  */",
        "verify (sizeof (TCHAR_T) == 1);",
        "verify (sizeof (TCHAR_T) == 1)",
        "verify",
        "(sizeof (TCHAR_T) == 1)",
        "(",
        "sizeof (TCHAR_T) == 1",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        "==",
        "1",
        ")",
        ";",
        "# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "tmpsrc = (TCHAR_T *) (result + length);",
        "tmpsrc = (TCHAR_T *) (result + length)",
        "tmpsrc",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# else\n                        tmpsrc = tmp;",
        "# else",
        "tmpsrc = tmp;",
        "tmpsrc = tmp",
        "tmpsrc",
        "=",
        "tmp",
        ";",
        "# endif",
        "tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);",
        "tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "tmpdst",
        "=",
        "DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "DCHAR_CONV_FROM_ENCODING",
        "(locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "(",
        "locale_charset ()",
        "locale_charset",
        "()",
        "(",
        ")",
        ",",
        "iconveh_question_mark",
        ",",
        "tmpsrc",
        ",",
        "count",
        ",",
        "NULL",
        ",",
        "NULL",
        ",",
        "&tmpdst_len",
        "&",
        "tmpdst_len",
        ")",
        ";",
        "if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }",
        "if",
        "(tmpdst == NULL)",
        "(",
        "tmpdst == NULL",
        "tmpdst",
        "==",
        "NULL",
        ")",
        "{\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }",
        "{",
        "int saved_errno = errno;",
        "int",
        "saved_errno = errno",
        "saved_errno",
        "=",
        "errno",
        ";",
        "if (!(result == resultbuf || result == NULL))\n                              free (result);",
        "if",
        "(!(result == resultbuf || result == NULL))",
        "(",
        "!(result == resultbuf || result == NULL)",
        "!",
        "(result == resultbuf || result == NULL)",
        "(",
        "result == resultbuf || result == NULL",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        "||",
        "result == NULL",
        "result",
        "==",
        "NULL",
        ")",
        ")",
        "free (result);",
        "free (result)",
        "free",
        "(result)",
        "(",
        "result",
        ")",
        ";",
        "if (buf_malloced != NULL)\n                              free (buf_malloced);",
        "if",
        "(buf_malloced != NULL)",
        "(",
        "buf_malloced != NULL",
        "buf_malloced",
        "!=",
        "NULL",
        ")",
        "free (buf_malloced);",
        "free (buf_malloced)",
        "free",
        "(buf_malloced)",
        "(",
        "buf_malloced",
        ")",
        ";",
        "CLEANUP ();",
        "CLEANUP ()",
        "CLEANUP",
        "()",
        "(",
        ")",
        ";",
        "errno = saved_errno;",
        "errno = saved_errno",
        "errno",
        "=",
        "saved_errno",
        ";",
        "return NULL;",
        "return",
        "NULL",
        ";",
        "}",
        "ENSURE_ALLOCATION (xsum (length, tmpdst_len));",
        "ENSURE_ALLOCATION (xsum (length, tmpdst_len))",
        "ENSURE_ALLOCATION",
        "(xsum (length, tmpdst_len))",
        "(",
        "xsum (length, tmpdst_len)",
        "xsum",
        "(length, tmpdst_len)",
        "(",
        "length",
        ",",
        "tmpdst_len",
        ")",
        ")",
        ";",
        "DCHAR_CPY (result + length, tmpdst, tmpdst_len);",
        "DCHAR_CPY (result + length, tmpdst, tmpdst_len)",
        "DCHAR_CPY",
        "(result + length, tmpdst, tmpdst_len)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ",",
        "tmpdst",
        ",",
        "tmpdst_len",
        ")",
        ";",
        "free (tmpdst);",
        "free (tmpdst)",
        "free",
        "(tmpdst)",
        "(",
        "tmpdst",
        ")",
        ";",
        "count = tmpdst_len;",
        "count = tmpdst_len",
        "count",
        "=",
        "tmpdst_len",
        ";",
        "}",
        "else",
        "{\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }",
        "{",
        "/* The result string is ASCII.\n                           Simple 1:1 conversion.  */",
        "# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "/* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */",
        "if (sizeof (DCHAR_T) != sizeof (TCHAR_T))",
        "if",
        "(sizeof (DCHAR_T) != sizeof (TCHAR_T))",
        "(",
        "sizeof (DCHAR_T) != sizeof (TCHAR_T)",
        "sizeof (DCHAR_T)",
        "sizeof",
        "(DCHAR_T)",
        "(",
        "DCHAR_T",
        ")",
        "!=",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "",
        "",
        "# endif",
        "{\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }",
        "{",
        "const TCHAR_T *tmpsrc;",
        "const",
        "const",
        "TCHAR_T",
        "*tmpsrc",
        "*",
        "tmpsrc",
        ";",
        "DCHAR_T *tmpdst;",
        "DCHAR_T",
        "*tmpdst",
        "*",
        "tmpdst",
        ";",
        "size_t n;",
        "size_t",
        "n",
        ";",
        "# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }",
        "if",
        "(result == resultbuf)",
        "(",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        ")",
        "{\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }",
        "{",
        "tmpsrc = (TCHAR_T *) (result + length);",
        "tmpsrc = (TCHAR_T *) (result + length)",
        "tmpsrc",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "/* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */",
        "ENSURE_ALLOCATION (xsum (length, count));",
        "ENSURE_ALLOCATION",
        "(xsum (length, count))",
        "("
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/vasnprintf.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/vasprintf.c": {
    "vasprintf": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nvasprintf (char **resultp, const char *format, va_list args)\n{\n  size_t length;\n  char *result = vasnprintf (NULL, &length, format, args);\n  if (result == NULL)\n    return -1;\n\n  if (length > INT_MAX)\n    {\n      free (result);\n      errno = EOVERFLOW;\n      return -1;\n    }\n\n  *resultp = result;\n  /* Return the number of resulting bytes, excluding the trailing NUL.  */\n  return length;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/verify.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/warn-on-use.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/wchar.in.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/wcrtomb.c": {
    "wcrtomb": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "size_t\nwcrtomb (char *s, wchar_t wc, mbstate_t *ps)\n{\n  /* This implementation of wcrtomb on top of wctomb() supports only\n     stateless encodings.  ps must be in the initial state.  */\n  if (ps != NULL && !mbsinit (ps))\n    {\n      errno = EINVAL;\n      return (size_t)(-1);\n    }\n\n  if (s == NULL)\n    /* We know the NUL wide character corresponds to the NUL character.  */\n    return 1;\n  else\n    {\n      int ret = wctomb (s, wc);\n\n      if (ret >= 0)\n        return ret;\n      else\n        {\n          errno = EILSEQ;\n          return (size_t)(-1);\n        }\n    }\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "size_t"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/wctype-h.c": {},
  "texinfo/texinfo-6.5/gnulib/lib/wctype.in.h": {
    "rpl_towlower": {
      "start_point": [
        371,
        0
      ],
      "end_point": [
        375,
        1
      ],
      "content": "_GL_WCTYPE_INLINE wint_t\nrpl_towlower (wint_t wc)\n{\n  return (wint_t) (wchar_t) towlower (wc);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_WCTYPE_INLINE",
        "wint_t",
        "wint_t"
      ]
    },
    "rpl_towupper": {
      "start_point": [
        380,
        0
      ],
      "end_point": [
        384,
        1
      ],
      "content": "_GL_WCTYPE_INLINE wint_t\nrpl_towupper (wint_t wc)\n{\n  return (wint_t) (wchar_t) towupper (wc);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_WCTYPE_INLINE",
        "wint_t",
        "wint_t"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/wcwidth.c": {},
  "texinfo/texinfo-6.5/gnulib/lib/xalloc-die.c": {
    "xalloc_die": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "void\nxalloc_die (void)\n{\n  error (exit_failure, 0, \"%s\", _(\"memory exhausted\"));\n\n  /* _Noreturn cannot be given to error, since it may return if\n     its first argument is 0.  To help compilers understand the\n     xalloc_die does not return, call abort.  Also, the abort is a\n     safety feature if exit_failure is 0 (which shouldn't happen).  */\n  abort ();\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/xalloc-oversized.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/xalloc.h": {
    "xnmalloc": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "XALLOC_INLINE void *\nxnmalloc (size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xmalloc (n * s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "XALLOC_INLINE",
        "void",
        "void",
        "*\nxnmalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xnrealloc": [
      {
        "start_point": [
          116,
          0
        ],
        "end_point": [
          122,
          1
        ],
        "content": "XALLOC_INLINE void *\nxnrealloc (void *p, size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xrealloc (p, n * s);\n}",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "XALLOC_INLINE",
          "void",
          "void",
          "*\nxnrealloc (void *p, size_t n, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          239,
          29
        ],
        "end_point": [
          243,
          1
        ],
        "content": "T *\nxnrealloc (T *p, size_t n, size_t s)\n{\n  return (T *) xnrealloc ((void *) p, n, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nxnrealloc (T *p, size_t n, size_t s)",
          "*"
        ]
      }
    ],
    "x2nrealloc": [
      {
        "start_point": [
          178,
          0
        ],
        "end_point": [
          213,
          1
        ],
        "content": "XALLOC_INLINE void *\nx2nrealloc (void *p, size_t *pn, size_t s)\n{\n  size_t n = *pn;\n\n  if (! p)\n    {\n      if (! n)\n        {\n          /* The approximate size to use for initial small allocation\n             requests, when the invoking code specifies an old size of\n             zero.  This is the largest \"small\" request for the GNU C\n             library malloc.  */\n          enum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };\n\n          n = DEFAULT_MXFAST / s;\n          n += !n;\n        }\n      if (xalloc_oversized (n, s))\n        xalloc_die ();\n    }\n  else\n    {\n      /* Set N = floor (1.5 * N) + 1 so that progress is made even if N == 0.\n         Check for overflow, so that N * S stays in both ptrdiff_t and\n         size_t range.  The check may be slightly conservative, but an\n         exact check isn't worth the trouble.  */\n      if ((PTRDIFF_MAX < SIZE_MAX ? PTRDIFF_MAX : SIZE_MAX) / 3 * 2 / s\n          <= n)\n        xalloc_die ();\n      n += n / 2 + 1;\n    }\n\n  *pn = n;\n  return xrealloc (p, n * s);\n}",
        "lines": 36,
        "depth": 14,
        "decorators": [
          "XALLOC_INLINE",
          "void",
          "void",
          "*\nx2nrealloc (void *p, size_t *pn, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          251,
          29
        ],
        "end_point": [
          255,
          1
        ],
        "content": "T *\nx2nrealloc (T *p, size_t *pn, size_t s)\n{\n  return (T *) x2nrealloc ((void *) p, pn, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nx2nrealloc (T *p, size_t *pn, size_t s)",
          "*"
        ]
      }
    ],
    "xcharalloc": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "XALLOC_INLINE char *\nxcharalloc (size_t n)\n{\n  return XNMALLOC (n, char);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "XALLOC_INLINE",
        "char",
        "char",
        "*\nxcharalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        233,
        29
      ],
      "end_point": [
        237,
        1
      ],
      "content": "T *\nxrealloc (T *p, size_t s)\n{\n  return (T *) xrealloc ((void *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxrealloc (T *p, size_t s)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        245,
        29
      ],
      "end_point": [
        249,
        1
      ],
      "content": "T *\nx2realloc (T *p, size_t *pn)\n{\n  return (T *) x2realloc ((void *) p, pn);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nx2realloc (T *p, size_t *pn)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        257,
        29
      ],
      "end_point": [
        261,
        1
      ],
      "content": "T *\nxmemdup (T const *p, size_t s)\n{\n  return (T *) xmemdup ((void const *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxmemdup (T const *p, size_t s)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/xmalloc.c": {
    "xmalloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void *\nxmalloc (size_t n)\n{\n  void *p = malloc (n);\n  if (!p && n != 0)\n    xalloc_die ();\n  return p;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void",
        "*\nxmalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void *\nxrealloc (void *p, size_t n)\n{\n  if (!n && p)\n    {\n      /* The GNU and C99 realloc behaviors disagree here.  Act like\n         GNU, even if the underlying realloc is C99.  */\n      free (p);\n      return NULL;\n    }\n\n  p = realloc (p, n);\n  if (!p && n)\n    xalloc_die ();\n  return p;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxrealloc (void *p, size_t n)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void *\nx2realloc (void *p, size_t *pn)\n{\n  return x2nrealloc (p, pn, 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void",
        "*\nx2realloc (void *p, size_t *pn)",
        "*"
      ]
    },
    "xzalloc": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "void *\nxzalloc (size_t s)\n{\n  return memset (xmalloc (s), 0, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxzalloc (size_t s)",
        "*"
      ]
    },
    "xcalloc": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "void *\nxcalloc (size_t n, size_t s)\n{\n  void *p;\n  /* Test for overflow, since objects with size greater than\n     PTRDIFF_MAX cause pointer subtraction to go awry.  Omit size-zero\n     tests if HAVE_GNU_CALLOC, since GNU calloc never returns NULL if\n     successful.  */\n  if (xalloc_oversized (n, s)\n      || (! (p = calloc (n, s)) && (HAVE_GNU_CALLOC || n != 0)))\n    xalloc_die ();\n  return p;\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "void",
        "*\nxcalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void *\nxmemdup (void const *p, size_t s)\n{\n  return memcpy (xmalloc (s), p, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxmemdup (void const *p, size_t s)",
        "*"
      ]
    },
    "xstrdup": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "char *\nxstrdup (char const *string)\n{\n  return xmemdup (string, strlen (string) + 1);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "char",
        "*\nxstrdup (char const *string)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/xsize.c": {},
  "texinfo/texinfo-6.5/gnulib/lib/xsize.h": {
    "size_t": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "__attribute__ ((__pure__))\n#endif\nxsum (size_t size1, size_t size2)\n{\n  size_t sum = size1 + size2;\n  return (sum >= size1 ? sum : SIZE_MAX);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": null
    },
    "__pure__": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "__attribute__ ((__pure__))\n#endif\nxmax (size_t size1, size_t size2)\n{\n  /* No explicit check is needed here, because for any n:\n     max (SIZE_MAX, n) == SIZE_MAX and max (n, SIZE_MAX) == SIZE_MAX.  */\n  return (size1 >= size2 ? size1 : size2);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": null
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/_Noreturn.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/glthread/lock.c": {
    "glthread_rwlock_init_for_glibc": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nglthread_rwlock_init_for_glibc (pthread_rwlock_t *lock)\n{\n  pthread_rwlockattr_t attributes;\n  int err;\n\n  err = pthread_rwlockattr_init (&attributes);\n  if (err != 0)\n    return err;\n  /* Note: PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP is the only value that\n     causes the writer to be preferred. PTHREAD_RWLOCK_PREFER_WRITER_NP does not\n     do this; see\n     http://man7.org/linux/man-pages/man3/pthread_rwlockattr_setkind_np.3.html */\n  err = pthread_rwlockattr_setkind_np (&attributes,\n                                       PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);\n  if (err == 0)\n    err = pthread_rwlock_init(lock, &attributes);\n  /* pthread_rwlockattr_destroy always returns 0.  It cannot influence the\n     return value.  */\n  pthread_rwlockattr_destroy (&attributes);\n  return err;\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_init_multithreaded": [
      {
        "start_point": [
          65,
          0
        ],
        "end_point": [
          75,
          1
        ],
        "content": "int\nglthread_rwlock_init_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_rwlock_init (&lock->rwlock, NULL);\n  if (err != 0)\n    return err;\n  lock->initialized = 1;\n  return 0;\n}",
        "lines": 11,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          155,
          0
        ],
        "end_point": [
          172,
          1
        ],
        "content": "int\nglthread_rwlock_init_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_init (&lock->lock, NULL);\n  if (err != 0)\n    return err;\n  err = pthread_cond_init (&lock->waiting_readers, NULL);\n  if (err != 0)\n    return err;\n  err = pthread_cond_init (&lock->waiting_writers, NULL);\n  if (err != 0)\n    return err;\n  lock->waiting_writers_count = 0;\n  lock->runcount = 0;\n  return 0;\n}",
        "lines": 18,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          512,
          0
        ],
        "end_point": [
          525,
          1
        ],
        "content": "int\nglthread_rwlock_init_multithreaded (gl_rwlock_t *lock)\n{\n  if (!pth_mutex_init (&lock->lock))\n    return errno;\n  if (!pth_cond_init (&lock->waiting_readers))\n    return errno;\n  if (!pth_cond_init (&lock->waiting_writers))\n    return errno;\n  lock->waiting_writers_count = 0;\n  lock->runcount = 0;\n  lock->initialized = 1;\n  return 0;\n}",
        "lines": 14,
        "depth": 10,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_rdlock_multithreaded": [
      {
        "start_point": [
          77,
          0
        ],
        "end_point": [
          101,
          1
        ],
        "content": "int\nglthread_rwlock_rdlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_rwlock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_rwlock_rdlock (&lock->rwlock);\n}",
        "lines": 25,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          174,
          0
        ],
        "end_point": [
          199,
          1
        ],
        "content": "int\nglthread_rwlock_rdlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n  /* Test whether only readers are currently running, and whether the runcount\n     field will not overflow, and whether no writer is waiting.  The latter\n     condition is because POSIX recommends that \"write locks shall take\n     precedence over read locks\", to avoid \"writer starvation\".  */\n  while (!(lock->runcount + 1 > 0 && lock->waiting_writers_count == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_readers.  */\n      err = pthread_cond_wait (&lock->waiting_readers, &lock->lock);\n      if (err != 0)\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return err;\n        }\n    }\n  lock->runcount++;\n  return pthread_mutex_unlock (&lock->lock);\n}",
        "lines": 26,
        "depth": 12,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          527,
          0
        ],
        "end_point": [
          551,
          1
        ],
        "content": "int\nglthread_rwlock_rdlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    glthread_rwlock_init_multithreaded (lock);\n  if (!pth_mutex_acquire (&lock->lock, 0, NULL))\n    return errno;\n  /* Test whether only readers are currently running, and whether the runcount\n     field will not overflow, and whether no writer is waiting.  The latter\n     condition is because POSIX recommends that \"write locks shall take\n     precedence over read locks\", to avoid \"writer starvation\".  */\n  while (!(lock->runcount + 1 > 0 && lock->waiting_writers_count == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_readers.  */\n      if (!pth_cond_await (&lock->waiting_readers, &lock->lock, NULL))\n        {\n          int err = errno;\n          pth_mutex_release (&lock->lock);\n          return err;\n        }\n    }\n  lock->runcount++;\n  return (!pth_mutex_release (&lock->lock) ? errno : 0);\n}",
        "lines": 25,
        "depth": 12,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_wrlock_multithreaded": [
      {
        "start_point": [
          103,
          0
        ],
        "end_point": [
          127,
          1
        ],
        "content": "int\nglthread_rwlock_wrlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_rwlock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_rwlock_wrlock (&lock->rwlock);\n}",
        "lines": 25,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          201,
          0
        ],
        "end_point": [
          226,
          1
        ],
        "content": "int\nglthread_rwlock_wrlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n  /* Test whether no readers or writers are currently running.  */\n  while (!(lock->runcount == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_writers.  */\n      lock->waiting_writers_count++;\n      err = pthread_cond_wait (&lock->waiting_writers, &lock->lock);\n      if (err != 0)\n        {\n          lock->waiting_writers_count--;\n          pthread_mutex_unlock (&lock->lock);\n          return err;\n        }\n      lock->waiting_writers_count--;\n    }\n  lock->runcount--; /* runcount becomes -1 */\n  return pthread_mutex_unlock (&lock->lock);\n}",
        "lines": 26,
        "depth": 12,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          553,
          0
        ],
        "end_point": [
          577,
          1
        ],
        "content": "int\nglthread_rwlock_wrlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    glthread_rwlock_init_multithreaded (lock);\n  if (!pth_mutex_acquire (&lock->lock, 0, NULL))\n    return errno;\n  /* Test whether no readers or writers are currently running.  */\n  while (!(lock->runcount == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_writers.  */\n      lock->waiting_writers_count++;\n      if (!pth_cond_await (&lock->waiting_writers, &lock->lock, NULL))\n        {\n          int err = errno;\n          lock->waiting_writers_count--;\n          pth_mutex_release (&lock->lock);\n          return err;\n        }\n      lock->waiting_writers_count--;\n    }\n  lock->runcount--; /* runcount becomes -1 */\n  return (!pth_mutex_release (&lock->lock) ? errno : 0);\n}",
        "lines": 25,
        "depth": 12,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_unlock_multithreaded": [
      {
        "start_point": [
          129,
          0
        ],
        "end_point": [
          135,
          1
        ],
        "content": "int\nglthread_rwlock_unlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    return EINVAL;\n  return pthread_rwlock_unlock (&lock->rwlock);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          228,
          0
        ],
        "end_point": [
          282,
          1
        ],
        "content": "int\nglthread_rwlock_unlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n  if (lock->runcount < 0)\n    {\n      /* Drop a writer lock.  */\n      if (!(lock->runcount == -1))\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount = 0;\n    }\n  else\n    {\n      /* Drop a reader lock.  */\n      if (!(lock->runcount > 0))\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount--;\n    }\n  if (lock->runcount == 0)\n    {\n      /* POSIX recommends that \"write locks shall take precedence over read\n         locks\", to avoid \"writer starvation\".  */\n      if (lock->waiting_writers_count > 0)\n        {\n          /* Wake up one of the waiting writers.  */\n          err = pthread_cond_signal (&lock->waiting_writers);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->lock);\n              return err;\n            }\n        }\n      else\n        {\n          /* Wake up all waiting readers.  */\n          err = pthread_cond_broadcast (&lock->waiting_readers);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->lock);\n              return err;\n            }\n        }\n    }\n  return pthread_mutex_unlock (&lock->lock);\n}",
        "lines": 55,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          579,
          0
        ],
        "end_point": [
          634,
          1
        ],
        "content": "int\nglthread_rwlock_unlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  if (!lock->initialized)\n    return EINVAL;\n  if (!pth_mutex_acquire (&lock->lock, 0, NULL))\n    return errno;\n  if (lock->runcount < 0)\n    {\n      /* Drop a writer lock.  */\n      if (!(lock->runcount == -1))\n        {\n          pth_mutex_release (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount = 0;\n    }\n  else\n    {\n      /* Drop a reader lock.  */\n      if (!(lock->runcount > 0))\n        {\n          pth_mutex_release (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount--;\n    }\n  if (lock->runcount == 0)\n    {\n      /* POSIX recommends that \"write locks shall take precedence over read\n         locks\", to avoid \"writer starvation\".  */\n      if (lock->waiting_writers_count > 0)\n        {\n          /* Wake up one of the waiting writers.  */\n          if (!pth_cond_notify (&lock->waiting_writers, FALSE))\n            {\n              int err = errno;\n              pth_mutex_release (&lock->lock);\n              return err;\n            }\n        }\n      else\n        {\n          /* Wake up all waiting readers.  */\n          if (!pth_cond_notify (&lock->waiting_readers, TRUE))\n            {\n              int err = errno;\n              pth_mutex_release (&lock->lock);\n              return err;\n            }\n        }\n    }\n  return (!pth_mutex_release (&lock->lock) ? errno : 0);\n}",
        "lines": 56,
        "depth": 14,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_destroy_multithreaded": [
      {
        "start_point": [
          137,
          0
        ],
        "end_point": [
          149,
          1
        ],
        "content": "int\nglthread_rwlock_destroy_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  if (!lock->initialized)\n    return EINVAL;\n  err = pthread_rwlock_destroy (&lock->rwlock);\n  if (err != 0)\n    return err;\n  lock->initialized = 0;\n  return 0;\n}",
        "lines": 13,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          284,
          0
        ],
        "end_point": [
          299,
          1
        ],
        "content": "int\nglthread_rwlock_destroy_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_destroy (&lock->lock);\n  if (err != 0)\n    return err;\n  err = pthread_cond_destroy (&lock->waiting_readers);\n  if (err != 0)\n    return err;\n  err = pthread_cond_destroy (&lock->waiting_writers);\n  if (err != 0)\n    return err;\n  return 0;\n}",
        "lines": 16,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          636,
          0
        ],
        "end_point": [
          641,
          1
        ],
        "content": "int\nglthread_rwlock_destroy_multithreaded (gl_rwlock_t *lock)\n{\n  lock->initialized = 0;\n  return 0;\n}",
        "lines": 6,
        "depth": 6,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_init_multithreaded": [
      {
        "start_point": [
          309,
          0
        ],
        "end_point": [
          334,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_mutexattr_t attributes;\n  int err;\n\n  err = pthread_mutexattr_init (&attributes);\n  if (err != 0)\n    return err;\n  err = pthread_mutexattr_settype (&attributes, PTHREAD_MUTEX_RECURSIVE);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutex_init (lock, &attributes);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutexattr_destroy (&attributes);\n  if (err != 0)\n    return err;\n  return 0;\n}",
        "lines": 26,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          338,
          0
        ],
        "end_point": [
          364,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_mutexattr_t attributes;\n  int err;\n\n  err = pthread_mutexattr_init (&attributes);\n  if (err != 0)\n    return err;\n  err = pthread_mutexattr_settype (&attributes, PTHREAD_MUTEX_RECURSIVE);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutex_init (&lock->recmutex, &attributes);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutexattr_destroy (&attributes);\n  if (err != 0)\n    return err;\n  lock->initialized = 1;\n  return 0;\n}",
        "lines": 27,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          418,
          0
        ],
        "end_point": [
          429,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_init (&lock->mutex, NULL);\n  if (err != 0)\n    return err;\n  lock->owner = (pthread_t) 0;\n  lock->depth = 0;\n  return 0;\n}",
        "lines": 12,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          692,
          0
        ],
        "end_point": [
          703,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  int err;\n\n  err = mutex_init (&lock->mutex, USYNC_THREAD, NULL);\n  if (err != 0)\n    return err;\n  lock->owner = (thread_t) 0;\n  lock->depth = 0;\n  return 0;\n}",
        "lines": 12,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_lock_multithreaded": [
      {
        "start_point": [
          366,
          0
        ],
        "end_point": [
          390,
          1
        ],
        "content": "int\nglthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_recursive_lock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_mutex_lock (&lock->recmutex);\n}",
        "lines": 25,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          431,
          0
        ],
        "end_point": [
          450,
          1
        ],
        "content": "int\nglthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_t self = pthread_self ();\n  if (lock->owner != self)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->mutex);\n      if (err != 0)\n        return err;\n      lock->owner = self;\n    }\n  if (++(lock->depth) == 0) /* wraparound? */\n    {\n      lock->depth--;\n      return EAGAIN;\n    }\n  return 0;\n}",
        "lines": 20,
        "depth": 11,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          705,
          0
        ],
        "end_point": [
          724,
          1
        ],
        "content": "int\nglthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock)\n{\n  thread_t self = thr_self ();\n  if (lock->owner != self)\n    {\n      int err;\n\n      err = mutex_lock (&lock->mutex);\n      if (err != 0)\n        return err;\n      lock->owner = self;\n    }\n  if (++(lock->depth) == 0) /* wraparound? */\n    {\n      lock->depth--;\n      return EAGAIN;\n    }\n  return 0;\n}",
        "lines": 20,
        "depth": 11,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_unlock_multithreaded": [
      {
        "start_point": [
          392,
          0
        ],
        "end_point": [
          398,
          1
        ],
        "content": "int\nglthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (!lock->initialized)\n    return EINVAL;\n  return pthread_mutex_unlock (&lock->recmutex);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          452,
          0
        ],
        "end_point": [
          466,
          1
        ],
        "content": "int\nglthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != pthread_self ())\n    return EPERM;\n  if (lock->depth == 0)\n    return EINVAL;\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = (pthread_t) 0;\n      return pthread_mutex_unlock (&lock->mutex);\n    }\n  else\n    return 0;\n}",
        "lines": 15,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          726,
          0
        ],
        "end_point": [
          740,
          1
        ],
        "content": "int\nglthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != thr_self ())\n    return EPERM;\n  if (lock->depth == 0)\n    return EINVAL;\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = (thread_t) 0;\n      return mutex_unlock (&lock->mutex);\n    }\n  else\n    return 0;\n}",
        "lines": 15,
        "depth": 10,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_destroy_multithreaded": [
      {
        "start_point": [
          400,
          0
        ],
        "end_point": [
          412,
          1
        ],
        "content": "int\nglthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock)\n{\n  int err;\n\n  if (!lock->initialized)\n    return EINVAL;\n  err = pthread_mutex_destroy (&lock->recmutex);\n  if (err != 0)\n    return err;\n  lock->initialized = 0;\n  return 0;\n}",
        "lines": 13,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          468,
          0
        ],
        "end_point": [
          474,
          1
        ],
        "content": "int\nglthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != (pthread_t) 0)\n    return EBUSY;\n  return pthread_mutex_destroy (&lock->mutex);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          742,
          0
        ],
        "end_point": [
          748,
          1
        ],
        "content": "int\nglthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != (thread_t) 0)\n    return EBUSY;\n  return mutex_destroy (&lock->mutex);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_once_singlethreaded": [
      {
        "start_point": [
          482,
          0
        ],
        "end_point": [
          496,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (pthread_once_t *once_control)\n{\n  /* We don't know whether pthread_once_t is an integer type, a floating-point\n     type, a pointer type, or a structure type.  */\n  char *firstbyte = (char *)once_control;\n  if (*firstbyte == *(const char *)&fresh_once)\n    {\n      /* First time use of once_control.  Invert the first byte.  */\n      *firstbyte = ~ *(const char *)&fresh_once;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 15,
        "depth": 12,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          664,
          0
        ],
        "end_point": [
          676,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (pth_once_t *once_control)\n{\n  /* We know that pth_once_t is an integer type.  */\n  if (*once_control == PTH_ONCE_INIT)\n    {\n      /* First time use of once_control.  Invert the marker.  */\n      *once_control = ~ PTH_ONCE_INIT;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 13,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          775,
          0
        ],
        "end_point": [
          787,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (gl_once_t *once_control)\n{\n  /* We know that gl_once_t contains an integer type.  */\n  if (!once_control->inited)\n    {\n      /* First time use of once_control.  Invert the marker.  */\n      once_control->inited = ~ 0;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 13,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_once_call": {
      "start_point": [
        649,
        0
      ],
      "end_point": [
        655,
        1
      ],
      "content": "static void\nglthread_once_call (void *arg)\n{\n  void (**gl_once_temp_addr) (void) = (void (**) (void)) arg;\n  void (*initfunction) (void) = *gl_once_temp_addr;\n  initfunction ();\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glthread_once_multithreaded": [
      {
        "start_point": [
          657,
          0
        ],
        "end_point": [
          662,
          1
        ],
        "content": "int\nglthread_once_multithreaded (pth_once_t *once_control, void (*initfunction) (void))\n{\n  void (*temp) (void) = initfunction;\n  return (!pth_once (once_control, glthread_once_call, &temp) ? errno : 0);\n}",
        "lines": 6,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          752,
          0
        ],
        "end_point": [
          773,
          1
        ],
        "content": "int\nglthread_once_multithreaded (gl_once_t *once_control, void (*initfunction) (void))\n{\n  if (!once_control->inited)\n    {\n      int err;\n\n      /* Use the mutex to guarantee that if another thread is already calling\n         the initfunction, this thread waits until it's finished.  */\n      err = mutex_lock (&once_control->mutex);\n      if (err != 0)\n        return err;\n      if (!once_control->inited)\n        {\n          once_control->inited = 1;\n          initfunction ();\n        }\n      return mutex_unlock (&once_control->mutex);\n    }\n  else\n    return 0;\n}",
        "lines": 22,
        "depth": 11,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_lock_init_func": {
      "start_point": [
        797,
        0
      ],
      "end_point": [
        802,
        1
      ],
      "content": "void\nglthread_lock_init_func (gl_lock_t *lock)\n{\n  InitializeCriticalSection (&lock->lock);\n  lock->guard.done = 1;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glthread_lock_lock_func": {
      "start_point": [
        804,
        0
      ],
      "end_point": [
        820,
        1
      ],
      "content": "int\nglthread_lock_lock_func (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_lock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glthread_lock_unlock_func": {
      "start_point": [
        822,
        0
      ],
      "end_point": [
        829,
        1
      ],
      "content": "int\nglthread_lock_unlock_func (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "glthread_lock_destroy_func": {
      "start_point": [
        831,
        0
      ],
      "end_point": [
        839,
        1
      ],
      "content": "int\nglthread_lock_destroy_func (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  DeleteCriticalSection (&lock->lock);\n  lock->guard.done = 0;\n  return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "gl_waitqueue_init": {
      "start_point": [
        846,
        0
      ],
      "end_point": [
        853,
        1
      ],
      "content": "static void\ngl_waitqueue_init (gl_waitqueue_t *wq)\n{\n  wq->array = NULL;\n  wq->count = 0;\n  wq->alloc = 0;\n  wq->offset = 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gl_waitqueue_add": {
      "start_point": [
        857,
        0
      ],
      "end_point": [
        904,
        1
      ],
      "content": "static HANDLE\ngl_waitqueue_add (gl_waitqueue_t *wq)\n{\n  HANDLE event;\n  unsigned int index;\n\n  if (wq->count == wq->alloc)\n    {\n      unsigned int new_alloc = 2 * wq->alloc + 1;\n      HANDLE *new_array =\n        (HANDLE *) realloc (wq->array, new_alloc * sizeof (HANDLE));\n      if (new_array == NULL)\n        /* No more memory.  */\n        return INVALID_HANDLE_VALUE;\n      /* Now is a good opportunity to rotate the array so that its contents\n         starts at offset 0.  */\n      if (wq->offset > 0)\n        {\n          unsigned int old_count = wq->count;\n          unsigned int old_alloc = wq->alloc;\n          unsigned int old_offset = wq->offset;\n          unsigned int i;\n          if (old_offset + old_count > old_alloc)\n            {\n              unsigned int limit = old_offset + old_count - old_alloc;\n              for (i = 0; i < limit; i++)\n                new_array[old_alloc + i] = new_array[i];\n            }\n          for (i = 0; i < old_count; i++)\n            new_array[i] = new_array[old_offset + i];\n          wq->offset = 0;\n        }\n      wq->array = new_array;\n      wq->alloc = new_alloc;\n    }\n  /* Whether the created event is a manual-reset one or an auto-reset one,\n     does not matter, since we will wait on it only once.  */\n  event = CreateEvent (NULL, TRUE, FALSE, NULL);\n  if (event == INVALID_HANDLE_VALUE)\n    /* No way to allocate an event.  */\n    return INVALID_HANDLE_VALUE;\n  index = wq->offset + wq->count;\n  if (index >= wq->alloc)\n    index -= wq->alloc;\n  wq->array[index] = event;\n  wq->count++;\n  return event;\n}",
      "lines": 48,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "HANDLE"
      ]
    },
    "gl_waitqueue_notify_first": {
      "start_point": [
        907,
        0
      ],
      "end_point": [
        915,
        1
      ],
      "content": "static void\ngl_waitqueue_notify_first (gl_waitqueue_t *wq)\n{\n  SetEvent (wq->array[wq->offset + 0]);\n  wq->offset++;\n  wq->count--;\n  if (wq->count == 0 || wq->offset == wq->alloc)\n    wq->offset = 0;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gl_waitqueue_notify_all": {
      "start_point": [
        918,
        0
      ],
      "end_point": [
        932,
        1
      ],
      "content": "static void\ngl_waitqueue_notify_all (gl_waitqueue_t *wq)\n{\n  unsigned int i;\n\n  for (i = 0; i < wq->count; i++)\n    {\n      unsigned int index = wq->offset + i;\n      if (index >= wq->alloc)\n        index -= wq->alloc;\n      SetEvent (wq->array[index]);\n    }\n  wq->count = 0;\n  wq->offset = 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glthread_rwlock_init_func": {
      "start_point": [
        934,
        0
      ],
      "end_point": [
        942,
        1
      ],
      "content": "void\nglthread_rwlock_init_func (gl_rwlock_t *lock)\n{\n  InitializeCriticalSection (&lock->lock);\n  gl_waitqueue_init (&lock->waiting_readers);\n  gl_waitqueue_init (&lock->waiting_writers);\n  lock->runcount = 0;\n  lock->guard.done = 1;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glthread_rwlock_rdlock_func": {
      "start_point": [
        944,
        0
      ],
      "end_point": [
        998,
        1
      ],
      "content": "int\nglthread_rwlock_rdlock_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_rwlock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n  /* Test whether only readers are currently running, and whether the runcount\n     field will not overflow, and whether no writer is waiting.  The latter\n     condition is because POSIX recommends that \"write locks shall take\n     precedence over read locks\", to avoid \"writer starvation\".  */\n  if (!(lock->runcount + 1 > 0 && lock->waiting_writers.count == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_readers.  */\n      HANDLE event = gl_waitqueue_add (&lock->waiting_readers);\n      if (event != INVALID_HANDLE_VALUE)\n        {\n          DWORD result;\n          LeaveCriticalSection (&lock->lock);\n          /* Wait until another thread signals this event.  */\n          result = WaitForSingleObject (event, INFINITE);\n          if (result == WAIT_FAILED || result == WAIT_TIMEOUT)\n            abort ();\n          CloseHandle (event);\n          /* The thread which signalled the event already did the bookkeeping:\n             removed us from the waiting_readers, incremented lock->runcount.  */\n          if (!(lock->runcount > 0))\n            abort ();\n          return 0;\n        }\n      else\n        {\n          /* Allocation failure.  Weird.  */\n          do\n            {\n              LeaveCriticalSection (&lock->lock);\n              Sleep (1);\n              EnterCriticalSection (&lock->lock);\n            }\n          while (!(lock->runcount + 1 > 0));\n        }\n    }\n  lock->runcount++;\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 55,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_wrlock_func": {
      "start_point": [
        1000,
        0
      ],
      "end_point": [
        1051,
        1
      ],
      "content": "int\nglthread_rwlock_wrlock_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_rwlock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n  /* Test whether no readers or writers are currently running.  */\n  if (!(lock->runcount == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_writers.  */\n      HANDLE event = gl_waitqueue_add (&lock->waiting_writers);\n      if (event != INVALID_HANDLE_VALUE)\n        {\n          DWORD result;\n          LeaveCriticalSection (&lock->lock);\n          /* Wait until another thread signals this event.  */\n          result = WaitForSingleObject (event, INFINITE);\n          if (result == WAIT_FAILED || result == WAIT_TIMEOUT)\n            abort ();\n          CloseHandle (event);\n          /* The thread which signalled the event already did the bookkeeping:\n             removed us from the waiting_writers, set lock->runcount = -1.  */\n          if (!(lock->runcount == -1))\n            abort ();\n          return 0;\n        }\n      else\n        {\n          /* Allocation failure.  Weird.  */\n          do\n            {\n              LeaveCriticalSection (&lock->lock);\n              Sleep (1);\n              EnterCriticalSection (&lock->lock);\n            }\n          while (!(lock->runcount == 0));\n        }\n    }\n  lock->runcount--; /* runcount becomes -1 */\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 52,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_unlock_func": {
      "start_point": [
        1053,
        0
      ],
      "end_point": [
        1095,
        1
      ],
      "content": "int\nglthread_rwlock_unlock_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  EnterCriticalSection (&lock->lock);\n  if (lock->runcount < 0)\n    {\n      /* Drop a writer lock.  */\n      if (!(lock->runcount == -1))\n        abort ();\n      lock->runcount = 0;\n    }\n  else\n    {\n      /* Drop a reader lock.  */\n      if (!(lock->runcount > 0))\n        {\n          LeaveCriticalSection (&lock->lock);\n          return EPERM;\n        }\n      lock->runcount--;\n    }\n  if (lock->runcount == 0)\n    {\n      /* POSIX recommends that \"write locks shall take precedence over read\n         locks\", to avoid \"writer starvation\".  */\n      if (lock->waiting_writers.count > 0)\n        {\n          /* Wake up one of the waiting writers.  */\n          lock->runcount--;\n          gl_waitqueue_notify_first (&lock->waiting_writers);\n        }\n      else\n        {\n          /* Wake up all waiting readers.  */\n          lock->runcount += lock->waiting_readers.count;\n          gl_waitqueue_notify_all (&lock->waiting_readers);\n        }\n    }\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_destroy_func": {
      "start_point": [
        1097,
        0
      ],
      "end_point": [
        1111,
        1
      ],
      "content": "int\nglthread_rwlock_destroy_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  if (lock->runcount != 0)\n    return EBUSY;\n  DeleteCriticalSection (&lock->lock);\n  if (lock->waiting_readers.array != NULL)\n    free (lock->waiting_readers.array);\n  if (lock->waiting_writers.array != NULL)\n    free (lock->waiting_writers.array);\n  lock->guard.done = 0;\n  return 0;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "glthread_recursive_lock_init_func": {
      "start_point": [
        1115,
        0
      ],
      "end_point": [
        1122,
        1
      ],
      "content": "void\nglthread_recursive_lock_init_func (gl_recursive_lock_t *lock)\n{\n  lock->owner = 0;\n  lock->depth = 0;\n  InitializeCriticalSection (&lock->lock);\n  lock->guard.done = 1;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glthread_recursive_lock_lock_func": {
      "start_point": [
        1124,
        0
      ],
      "end_point": [
        1152,
        1
      ],
      "content": "int\nglthread_recursive_lock_lock_func (gl_recursive_lock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_recursive_lock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  {\n    DWORD self = GetCurrentThreadId ();\n    if (lock->owner != self)\n      {\n        EnterCriticalSection (&lock->lock);\n        lock->owner = self;\n      }\n    if (++(lock->depth) == 0) /* wraparound? */\n      {\n        lock->depth--;\n        return EAGAIN;\n      }\n  }\n  return 0;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glthread_recursive_lock_unlock_func": {
      "start_point": [
        1154,
        0
      ],
      "end_point": [
        1167,
        1
      ],
      "content": "int\nglthread_recursive_lock_unlock_func (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != GetCurrentThreadId ())\n    return EPERM;\n  if (lock->depth == 0)\n    return EINVAL;\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = 0;\n      LeaveCriticalSection (&lock->lock);\n    }\n  return 0;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "glthread_recursive_lock_destroy_func": {
      "start_point": [
        1169,
        0
      ],
      "end_point": [
        1177,
        1
      ],
      "content": "int\nglthread_recursive_lock_destroy_func (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != 0)\n    return EBUSY;\n  DeleteCriticalSection (&lock->lock);\n  lock->guard.done = 0;\n  return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "glthread_once_func": {
      "start_point": [
        1181,
        0
      ],
      "end_point": [
        1216,
        1
      ],
      "content": "void\nglthread_once_func (gl_once_t *once_control, void (*initfunction) (void))\n{\n  if (once_control->inited <= 0)\n    {\n      if (InterlockedIncrement (&once_control->started) == 0)\n        {\n          /* This thread is the first one to come to this once_control.  */\n          InitializeCriticalSection (&once_control->lock);\n          EnterCriticalSection (&once_control->lock);\n          once_control->inited = 0;\n          initfunction ();\n          once_control->inited = 1;\n          LeaveCriticalSection (&once_control->lock);\n        }\n      else\n        {\n          /* Undo last operation.  */\n          InterlockedDecrement (&once_control->started);\n          /* Some other thread has already started the initialization.\n             Yield the CPU while waiting for the other thread to finish\n             initializing and taking the lock.  */\n          while (once_control->inited < 0)\n            Sleep (0);\n          if (once_control->inited <= 0)\n            {\n              /* Take the lock.  This blocks until the other thread has\n                 finished calling the initfunction.  */\n              EnterCriticalSection (&once_control->lock);\n              LeaveCriticalSection (&once_control->lock);\n              if (!(once_control->inited > 0))\n                abort ();\n            }\n        }\n    }\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/glthread/lock.h": {},
  "texinfo/texinfo-6.5/gnulib/lib/glthread/threadlib.c": {
    "dummy_thread_func": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static void *\ndummy_thread_func (void *arg)\n{\n  return arg;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndummy_thread_func (void *arg)",
        "*"
      ]
    },
    "glthread_in_use": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\nglthread_in_use (void)\n{\n  static int tested;\n  static int result; /* 1: linked with -lpthread, 0: only with libc */\n\n  if (!tested)\n    {\n      pthread_t thread;\n\n      if (pthread_create (&thread, NULL, dummy_thread_func, NULL) != 0)\n        /* Thread creation failed.  */\n        result = 0;\n      else\n        {\n          /* Thread creation works.  */\n          void *retval;\n          if (pthread_join (thread, &retval) != 0)\n            abort ();\n          result = 1;\n        }\n      tested = 1;\n    }\n  return result;\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/uniwidth/cjk.h": {
    "is_cjk_encoding": {
      "start_point": [
        19,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static int\nis_cjk_encoding (const char *encoding)\n{\n  if (0\n      /* Legacy Japanese encodings */\n      || STREQ_OPT (encoding, \"EUC-JP\", 'E', 'U', 'C', '-', 'J', 'P', 0, 0, 0)\n      /* Legacy Chinese encodings */\n      || STREQ_OPT (encoding, \"GB2312\", 'G', 'B', '2', '3', '1', '2', 0, 0, 0)\n      || STREQ_OPT (encoding, \"GBK\", 'G', 'B', 'K', 0, 0, 0, 0, 0, 0)\n      || STREQ_OPT (encoding, \"EUC-TW\", 'E', 'U', 'C', '-', 'T', 'W', 0, 0, 0)\n      || STREQ_OPT (encoding, \"BIG5\", 'B', 'I', 'G', '5', 0, 0, 0, 0, 0)\n      /* Legacy Korean encodings */\n      || STREQ_OPT (encoding, \"EUC-KR\", 'E', 'U', 'C', '-', 'K', 'R', 0, 0, 0)\n      || STREQ_OPT (encoding, \"CP949\", 'C', 'P', '9', '4', '9', 0, 0, 0, 0)\n      || STREQ_OPT (encoding, \"JOHAB\", 'J', 'O', 'H', 'A', 'B', 0, 0, 0, 0))\n    return 1;\n  return 0;\n}",
      "lines": 18,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/gnulib/lib/uniwidth/width.c": {
    "uc_width": {
      "start_point": [
        395,
        0
      ],
      "end_point": [
        449,
        1
      ],
      "content": "int\nuc_width (ucs4_t uc, const char *encoding)\n{\n  /* Test for non-spacing or control character.  */\n  if ((uc >> 9) < 248)\n    {\n      int ind = nonspacing_table_ind[uc >> 9];\n      if (ind >= 0)\n        if ((nonspacing_table_data[64*ind + ((uc >> 3) & 63)] >> (uc & 7)) & 1)\n          {\n            if (uc > 0 && uc < 0xa0)\n              return -1;\n            else\n              return 0;\n          }\n    }\n  else if ((uc >> 9) == (0xe0000 >> 9))\n    {\n      if (uc >= 0xe0100)\n        {\n          if (uc <= 0xe01ef)\n            return 0;\n        }\n      else\n        {\n          if (uc >= 0xe0020 ? uc <= 0xe007f : uc == 0xe0001)\n            return 0;\n        }\n    }\n  /* Test for double-width character.\n   * Generated from \"grep '^[^;]\\{4,5\\};[WF]' EastAsianWidth.txt\"\n   * and            \"grep '^[^;]\\{4,5\\};[^WF]' EastAsianWidth.txt\"\n   */\n  if (uc >= 0x1100\n      && ((uc < 0x1160) /* Hangul Jamo */\n          || (uc >= 0x2329 && uc < 0x232b) /* Angle Brackets */\n          || (uc >= 0x2e80 && uc < 0xa4d0  /* CJK ... Yi */\n              && !(uc == 0x303f) && !(uc >= 0x4dc0 && uc < 0x4e00))\n          || (uc >= 0xac00 && uc < 0xd7a4) /* Hangul Syllables */\n          || (uc >= 0xf900 && uc < 0xfb00) /* CJK Compatibility Ideographs */\n          || (uc >= 0xfe10 && uc < 0xfe20) /* Presentation Forms for Vertical */\n          || (uc >= 0xfe30 && uc < 0xfe70) /* CJK Compatibility Forms */\n          || (uc >= 0xff00 && uc < 0xff61) /* Fullwidth Forms */\n          || (uc >= 0xffe0 && uc < 0xffe7) /* Fullwidth Signs */\n          || (uc >= 0x20000 && uc <= 0x2ffff) /* Supplementary Ideographic Plane */\n          || (uc >= 0x30000 && uc <= 0x3ffff) /* Tertiary Ideographic Plane */\n     )   )\n    return 2;\n  /* In ancient CJK encodings, Cyrillic and most other characters are\n     double-width as well.  */\n  if (uc >= 0x00A1 && uc < 0xFF61 && uc != 0x20A9\n      && is_cjk_encoding (encoding))\n    return 2;\n  return 1;\n}",
      "lines": 55,
      "depth": 22,
      "decorators": [
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/info/dir.c": {
    "get_dir_node": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "NODE *\nget_dir_node (void)\n{\n  NODE *node;\n\n  if (!dir_node)\n    dir_node = build_dir_node ();\n\n  node = xmalloc (sizeof (NODE));\n  *node = *dir_node;\n\n  return node;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "NODE",
        "*\nget_dir_node (void)",
        "*"
      ]
    },
    "build_dir_node": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "static NODE *\nbuild_dir_node (void)\n{\n  int path_index;\n  char *this_dir;\n  NODE *node;\n\n  node = info_create_node ();\n  node->nodename = xstrdup (\"Top\");\n  node->fullpath = xstrdup (\"dir\");\n  node->contents = xstrdup (\n\n\"File: dir,\tNode: Top,\tThis is the top of the INFO tree.\\n\"\n\"\\n\"\n\"This is the Info main menu (aka directory node).\\n\"\n\"A few useful Info commands:\\n\"\n\"\\n\"\n\"  'q' quits;\\n\"\n\"  'H' lists all Info commands;\\n\"\n\"  'h' starts the Info tutorial;\\n\"\n\"  'mTexinfo RET' visits the Texinfo manual, etc.\\n\"\n\n  );\n\n  node->nodelen = strlen (node->contents);\n\n  /* Using each element of the path, check for one of the files in\n     DIRS_TO_ADD.  Do not check for \"localdir.info.Z\" or anything else.\n     Only files explictly named are eligible.  This is a design decision.\n     There can be an info file name \"localdir.info\" which contains\n     information on the setting up of \"localdir\" files. */\n  for (this_dir = infopath_first (&path_index); this_dir; \n       this_dir = infopath_next (&path_index))\n    {\n      register int da_index;\n      char *from_file;\n\n      /* Expand a leading tilde if one is present. */\n      if (*this_dir == '~')\n        {\n          char *tilde_expanded_dirname;\n\n          tilde_expanded_dirname = tilde_expand_word (this_dir);\n          if (tilde_expanded_dirname != this_dir)\n            {\n              this_dir = tilde_expanded_dirname;\n            }\n        }\n\n      /* For every different file named in DIRS_TO_ADD found in the\n         search path, add that file's menu to our \"dir\" node. */\n      for (da_index = 0; (from_file = dirs_to_add[da_index]); da_index++)\n        {\n          struct stat finfo;\n          int statable;\n          int namelen = strlen (from_file);\n          char *fullpath = xmalloc (3 + strlen (this_dir) + namelen);\n          \n          strcpy (fullpath, this_dir);\n          if (!IS_SLASH (fullpath[strlen (fullpath) - 1]))\n            strcat (fullpath, \"/\");\n          strcat (fullpath, from_file);\n\n          statable = (stat (fullpath, &finfo) == 0);\n\n          if (statable && S_ISREG (finfo.st_mode))\n            {\n              size_t filesize;\n\t      int compressed;\n              char *contents = filesys_read_info_file (fullpath, &filesize,\n                                                       &finfo, &compressed);\n              if (contents)\n                {\n                  add_menu_to_node (contents, filesize, node);\n                  free (contents);\n                }\n            }\n\n          free (fullpath);\n        }\n    }\n\n  node->flags |= N_IsDir;\n  dir_contents = node->contents;\n  scan_node_contents (node, 0, 0);\n  return node;\n}",
      "lines": 87,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nbuild_dir_node (void)",
        "*"
      ]
    },
    "add_menu_to_node": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        232,
        1
      ],
      "content": "static void\nadd_menu_to_node (char *contents, size_t size, NODE *node)\n{\n  SEARCH_BINDING contents_binding, fb_binding;\n  long contents_offset, fb_offset;\n\n  contents_binding.buffer = contents;\n  contents_binding.start = 0;\n  contents_binding.end = size;\n  contents_binding.flags = S_FoldCase | S_SkipDest;\n\n  fb_binding.buffer = node->contents;\n  fb_binding.start = 0;\n  fb_binding.end = node->nodelen;\n  fb_binding.flags = S_FoldCase | S_SkipDest;\n\n  /* Move to the start of the menus in CONTENTS and NODE. */\n  if (search_forward (INFO_MENU_LABEL, &contents_binding, &contents_offset)\n      != search_success)\n    /* If there is no menu in CONTENTS, quit now. */\n    return;\n\n  /* There is a menu in CONTENTS, and contents_offset points to the first\n     character following the menu starter string.  Skip all whitespace\n     and newline characters. */\n  contents_offset += skip_whitespace_and_newlines (contents + contents_offset);\n\n  /* If there is no menu in NODE, make one. */\n  if (search_forward (INFO_MENU_LABEL, &fb_binding, &fb_offset)\n      != search_success)\n    {\n      fb_binding.start = node->nodelen;\n\n      insert_text_into_node\n        (node, fb_binding.start, INFO_MENU_LABEL, strlen (INFO_MENU_LABEL));\n\n      fb_binding.buffer = node->contents;\n      fb_binding.start = 0;\n      fb_binding.end = node->nodelen;\n      if (search_forward (INFO_MENU_LABEL, &fb_binding, &fb_offset)\n\t  != search_success)\n        abort ();\n    }\n\n  /* CONTENTS_OFFSET and FB_OFFSET point to the starts of the menus that\n     appear in their respective buffers.  Add the remainder of CONTENTS\n     to the end of NODE's menu. */\n  fb_binding.start = fb_offset;\n  fb_offset = find_node_separator (&fb_binding);\n  if (fb_offset != -1)\n    fb_binding.start = fb_offset;\n  else\n    fb_binding.start = fb_binding.end;\n\n  /* Leave exactly one blank line between directory entries. */\n  {\n    int num_found = 0;\n\n    while ((fb_binding.start > 0) &&\n           (whitespace_or_newline (fb_binding.buffer[fb_binding.start - 1])))\n      {\n        num_found++;\n        fb_binding.start--;\n      }\n\n    /* Optimize if possible. */\n    if (num_found >= 2)\n      {\n        fb_binding.buffer[fb_binding.start++] = '\\n';\n        fb_binding.buffer[fb_binding.start++] = '\\n';\n      }\n    else\n      {\n        /* Do it the hard way. */\n        insert_text_into_node (node, fb_binding.start, \"\\n\\n\", 2);\n        fb_binding.start += 2;\n      }\n  }\n\n  /* Insert the new menu. */\n  insert_text_into_node\n    (node, fb_binding.start, contents + contents_offset, size - contents_offset);\n}",
      "lines": 83,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "insert_text_into_node": {
      "start_point": [
        234,
        0
      ],
      "end_point": [
        249,
        1
      ],
      "content": "static void\ninsert_text_into_node (NODE *node, long start, char *text, int textlen)\n{\n  char *contents;\n  long end;\n\n  end = node->nodelen;\n\n  contents = xmalloc (node->nodelen + textlen + 1);\n  memcpy (contents, node->contents, start);\n  memcpy (contents + start, text, textlen);\n  memcpy (contents + start + textlen, node->contents + start, end - start + 1);\n  free (node->contents);\n  node->contents = contents;\n  node->nodelen += textlen;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "lookup_dir_entry": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "REFERENCE *\nlookup_dir_entry (char *label, int sloppy)\n{\n  REFERENCE *entry;\n\n  if (!dir_node)\n    dir_node = build_dir_node ();\n\n  entry = info_get_menu_entry_by_label (dir_node, label, sloppy);\n\n  return entry;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "REFERENCE",
        "*\nlookup_dir_entry (char *label, int sloppy)",
        "*"
      ]
    },
    "dir_entry_of_infodir": {
      "start_point": [
        267,
        0
      ],
      "end_point": [
        308,
        1
      ],
      "content": "REFERENCE *\ndir_entry_of_infodir (char *label, char *searchdir)\n{\n  int da_index;\n  char *dir_filename;\n  char *dir_fullpath;\n\n  struct stat dummy;\n  char *entry_fullpath;\n\n  NODE *dir_node;\n  REFERENCE *entry;\n\n  for (da_index = 0; (dir_filename = dirs_to_add[da_index]); da_index++)\n    {\n      dir_fullpath = info_add_extension (searchdir, dir_filename, &dummy);\n      if (!dir_fullpath)\n        continue;\n\n      dir_node = info_get_node (dir_fullpath, \"Top\");\n      free (dir_fullpath);\n      entry = info_get_menu_entry_by_label (dir_node, label, 1);\n      if (!entry || !entry->filename)\n        {\n          free_history_node (dir_node);\n          continue;\n          /* A dir entry with no filename is unlikely, but not impossible. */\n        }\n\n      entry = info_copy_reference (entry);\n      entry_fullpath = info_add_extension (searchdir, entry->filename, &dummy);\n      if (entry_fullpath)\n        {\n          free (entry->filename);\n          entry->filename = entry_fullpath;\n        }\n\n      free_history_node (dir_node);\n      return entry;\n    }\n  return 0;\n}",
      "lines": 42,
      "depth": 11,
      "decorators": [
        "REFERENCE",
        "*\ndir_entry_of_infodir (char *label, char *searchdir)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/info/display.c": {
    "display_initialize_display": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "void\ndisplay_initialize_display (int width, int height)\n{\n  free_display (the_display);\n  the_display = make_display (width, height);\n  display_clear_display (the_display);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "display_clear_display": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "void\ndisplay_clear_display (DISPLAY_LINE **display)\n{\n  register int i;\n\n  signal_block_winch ();\n  for (i = 0; display[i]; i++)\n    {\n      display[i]->text[0] = '\\0';\n      display[i]->textlen = 0;\n      display[i]->inverse = 0;\n    }\n  signal_unblock_winch ();\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "display_update_display": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "void\ndisplay_update_display (void)\n{\n  register WINDOW *win;\n\n  /* Block window resize signals (SIGWINCH) while accessing the the_display\n     object, because the signal handler may reallocate it out from under our\n     feet. */\n  signal_block_winch ();\n  display_was_interrupted_p = 0;\n\n  for (win = windows; win; win = win->next)\n    {\n      /* Only re-display visible windows which need updating. */\n      if ((win->flags & W_WindowVisible) == 0\n          || (win->flags & W_UpdateWindow) == 0\n          || win->height == 0)\n        continue;\n\n      display_update_one_window (win);\n      if (display_was_interrupted_p)\n        break;\n    }\n\n  /* Always update the echo area. */\n  display_update_one_window (the_echo_area);\n  signal_unblock_winch ();\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "find_diff": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "static int\nfind_diff (const char *a, size_t alen, const char *b, size_t blen, int *ppos)\n{\n  mbi_iterator_t itra, itrb;\n  int i;\n  int pos = 0;\n  int first_escape = -1;\n  int escape_pos = -1;\n  \n  for (i = 0, mbi_init (itra, a, alen), mbi_init (itrb, b, blen);\n       mbi_avail (itra) && mbi_avail (itrb);\n       i += wcwidth (itra.cur.wc), mbi_advance (itra), mbi_advance (itrb))\n    {\n      if (mb_cmp (mbi_cur (itra), mbi_cur (itrb)))\n        break;\n\n      if (first_escape == -1 && *mbi_cur_ptr (itra) == '\\033')\n        {\n          first_escape = i;\n          escape_pos = pos;\n        }\n      pos += mb_len (mbi_cur (itra));\n    }\n\n  if (mbi_avail (itra) || mbi_avail (itrb))\n    {\n      if (first_escape != -1)\n        {\n          *ppos = escape_pos;\n          return first_escape;\n        }\n      else\n        {\n          /* If there was a difference in the line, and there was an escape\n             character, return the position of the escape character, as it could\n             start a terminal escape sequence. */\n          *ppos = pos;\n          return i;\n        }\n    }\n\n  /* Otherwise, no redrawing is required. */\n  return -1;\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "display_update_line": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "static int\ndisplay_update_line (long pl_num, char *printed_line,\n                     long pl_bytes, long pl_chars)\n{\n  DISPLAY_LINE **display = the_display;\n  DISPLAY_LINE *entry;\n\n entry = display[pl_num];\n\n  /* We have the exact line as it should appear on the screen.\n     Check to see if this line matches the one already appearing\n     on the screen. */\n\n  /* If the window is very small, entry might be NULL. */\n  if (entry)\n    {\n      int i, off;\n\t      \n      /* If the screen line is inversed, or if the entry is marked as\n         invalid, then clear the line from the screen first. */\n      if (entry->inverse)\n\t{\n\t  terminal_goto_xy (0, pl_num);\n\t  terminal_clear_to_eol ();\n\t  entry->inverse = 0;\n\t  entry->text[0] = '\\0';\n\t  entry->textlen = 0;\n\t}\n\n      i = find_diff (printed_line, pl_bytes,\n\t\t     entry->text, strlen (entry->text), &off);\n\n      /* If the lines differed at all, we must do some redrawing. */\n      if (i != -1)\n\t{\n\t  /* Move to the proper point on the terminal. */\n\t  terminal_goto_xy (i, pl_num);\n\n\t  /* If there is any text to print, print it. */\n          terminal_put_text (printed_line + off);\n\t  \n\t  /* If the printed text didn't extend all the way to the edge\n\t     of the screen, and text was appearing between here and the\n\t     edge of the screen, clear from here to the end of the\n\t     line. */\n\t  if ((pl_chars < screenwidth && pl_chars < entry->textlen)\n\t      || entry->inverse)\n\t    terminal_clear_to_eol ();\n\t  \n\t  fflush (stdout);\n\t  \n\t  /* Update the display text buffer. */\n\t  if (strlen (printed_line) > (unsigned int) screenwidth)\n\t    /* printed_line[] can include more than screenwidth\n\t       characters, e.g. if multibyte encoding is used or\n\t       if we are under -R and there are escape sequences\n\t       in it.  However, entry->text was allocated (in\n\t       display_initialize_display) for screenwidth\n\t       bytes only.  */\n\t    entry->text = xrealloc (entry->text, strlen (printed_line) + 1);\n\t  strcpy (entry->text + off, printed_line + off);\n\t  entry->textlen = pl_chars;\n\t  \n\t  /* Lines showing node text are not in inverse.  Only modelines\n\t     have that distinction. */\n\t  entry->inverse = 0;\n\t}\n    }\n\n  /* A line has been displayed, and the screen reflects that state.\n     If there is typeahead pending, then let that typeahead be read\n     now, instead of continuing with the display. */\n  if (info_any_buffered_input_p ())\n    {\n      display_was_interrupted_p = 1;\n      return 1;\n    }\n  return 0;\n}",
      "lines": 79,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "decide_if_in_reference": {
      "start_point": [
        231,
        0
      ],
      "end_point": [
        253,
        1
      ],
      "content": "static void\ndecide_if_in_reference (long off, int *in_ref, REFERENCE **references,\n                        int *ref_index)\n{\n  int i = *ref_index;\n  int m = *in_ref;\n\n  for (; (references[i]); i++)\n    {\n      if (references[i]->start > off)\n        break;\n\n      m = 1;\n\n      if (references[i]->end > off)\n        break;\n\n      m = 0;\n    }\n\n  *ref_index = i;\n  *in_ref = m;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wrap_terminal_switch_rendition": {
      "start_point": [
        271,
        0
      ],
      "end_point": [
        298,
        1
      ],
      "content": "static void\nwrap_terminal_switch_rendition (struct text_buffer *printed_line,\n                                 RENDITION rendition1,\n                                 RENDITION rendition2,\n                                 RENDITION rendition3)\n{\n  long int desired_rendition = 0;\n  desired_rendition = rendition1.value;\n  desired_rendition &= ~rendition2.mask;\n  desired_rendition |= rendition2.value;\n  desired_rendition &= ~rendition3.mask;\n  desired_rendition |= rendition3.value;\n\n  if (writing_out == WRITEOUT)\n    terminal_switch_rendition (desired_rendition);\n  else\n    {\n      /* Guarantee that each byte is non-zero, by having at least one\n         non-zero bit in it.  See ZERO1_MASK symbol in display.c. */\n      desired_rendition = ~desired_rendition;\n\n      /* The text added here is only used internally to see when the\n         display has changed, and is not output to the terminal. */\n      text_buffer_add_string (printed_line, \"\\033\", 1);\n      text_buffer_add_string (printed_line, (char *) &desired_rendition,\n                              sizeof (long));\n    }\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "display_process_line": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        480,
        1
      ],
      "content": "static void\ndisplay_process_line (WINDOW *win,\n                 mbi_iterator_t *iter_inout,\n                 struct text_buffer *tb_printed_line,\n                 int *delim)\n{\n  mbi_iterator_t iter;\n  const char *cur_ptr;\n  size_t pchars = 0; /* Printed chars */\n  size_t pbytes = 0; /* Bytes to output. */\n  char *rep;\n  int in_match = 0;\n  int in_ref = 0, in_ref_proper = 0;\n  RENDITION empty = {0, 0};\n\n  int point_in_line;\n\n  if (win->point >= win->line_starts[win->pagetop + pl_num]\n      && win->point < win->line_starts[win->pagetop + pl_num + 1])\n    point_in_line = 1;\n  else\n    point_in_line = 0;\n\n  iter = *iter_inout;\n\n  while (1)\n    {\n      int was_in_ref_proper = in_ref_proper;\n      int was_in_match = in_match;\n\n      if (!mbi_avail (iter))\n        break;\n      cur_ptr = mbi_cur_ptr (iter);\n\n      if (matches && matches_ready (matches)\n          && !at_end_of_matches (matches, match_index))\n        {\n          int was_in_match = in_match;\n          decide_if_in_match (cur_ptr - win->node->contents,\n                              &in_match, matches, &match_index);\n\n          if (!was_in_match && in_match && writing_out == DEFAULT)\n            writing_out = COLLECT;\n        }\n\n      if (refs && refs[ref_index])\n        {\n          int was_in_ref = in_ref;\n          decide_if_in_reference (cur_ptr - win->node->contents,\n                                  &in_ref, refs, &ref_index);\n\n          if (was_in_ref && !in_ref)\n            {\n              in_ref_proper = ref_highlighted = 0;\n            }\n          else if (!was_in_ref && in_ref)\n            {\n              if (writing_out == DEFAULT)\n                writing_out = COLLECT;\n\n              /* Decide if this reference should be highlighted. */\n              if (point_in_line && win->point < refs[ref_index]->end)\n                {\n                  /* The reference in is the part of the line after\n                     the cursor, or the reference contains the cursor. */\n                  point_in_line = 0;\n                  ref_highlighted = 1;\n                }\n              else if (point_in_line\n                       && (!refs[ref_index + 1]\n                           || refs[ref_index + 1]->start\n                              >= win->line_starts[win->pagetop + pl_num + 1]))\n                {\n                  /* The reference label is before the cursor in\n                     the current line and none occurs after it in\n                     the current line. */\n                  point_in_line = 0;\n                  ref_highlighted = 1;\n                }\n              else if (win->point >= refs[ref_index]->start\n                       && win->point < refs[ref_index]->end)\n                {\n                  /* The point is in a cross-reference, but not in the \n                     current line. */\n                  ref_highlighted = 1;\n                }\n              else if (win->point >= win->line_starts\n                                                  [win->pagetop + pl_num + 1]\n                       && win->point < win->line_starts\n                                                    [win->pagetop + pl_num + 2]\n                       && refs[ref_index]->end\n                          >= win->line_starts[win->pagetop + pl_num + 1]\n                       && (!refs[ref_index + 1]\n                           || refs[ref_index + 1]->start\n                              >= win->line_starts[win->pagetop + pl_num + 2]))\n                {\n                  /* Point is in the next line, not inside this reference,\n                     but this reference continues onto the next line and\n                     no other reference follows it in the line. */\n                  ref_highlighted = 1;\n                }\n            }\n        }\n\n      if (in_ref && !in_ref_proper && !strchr (\" \\t\", *cur_ptr))\n        in_ref_proper = 1;\n\n      if (was_in_ref_proper != in_ref_proper || was_in_match != in_match)\n        {\n          /* Calculate the new rendition for output characters, and call\n             the function to switch to it. */\n          RENDITION ref = {0, 0};\n          RENDITION match = {0, 0};\n\n          if (in_ref_proper)\n            ref = ref_highlighted && hl_ref_rendition.mask\n                    ? hl_ref_rendition : ref_rendition;\n          if (in_match)\n            match = match_rendition;\n          if (!ref_highlighted)\n            {\n              wrap_terminal_switch_rendition (tb_printed_line,\n                                              ref, match, empty);\n            }\n          else\n            {\n              wrap_terminal_switch_rendition (tb_printed_line,\n                                              match, ref, empty);\n            }\n        }\n\n      rep = printed_representation (&iter, delim, pl_chars,\n                                    &pchars, &pbytes);\n\n      /* If a newline character has been seen, or we have reached the\n         edge of the display.  */\n      if (*delim || pl_chars + pchars >= win->width)\n        break;\n\n      if (rep)\n        {\n          if (writing_out != WRITEOUT)\n            text_buffer_add_string (tb_printed_line, rep, pbytes);\n          else\n            terminal_write_chars (rep, pbytes);\n\n          pl_chars += pchars;\n        }\n      mbi_advance (iter);\n    }\n\n  if (writing_out != DEFAULT)\n    wrap_terminal_switch_rendition (tb_printed_line, empty, empty, empty);\n\n  *iter_inout = iter;\n}",
      "lines": 156,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "display_update_node_text": {
      "start_point": [
        487,
        0
      ],
      "end_point": [
        636,
        1
      ],
      "content": "int\ndisplay_update_node_text (WINDOW *win)\n{\n  static struct text_buffer tb_printed_line;  /* Buffer for a printed line.  */\n\n  mbi_iterator_t iter;  /* Used to iterate through part of node displayed.  */\n  mbi_iterator_t bol_iter; /* Keep reference to beginning of each line.  */\n  int bol_ref_index = 0, bol_match_index = 0;\n  int bol_ref_highlighted;\n\n  int finish;\n\n  matches = 0;\n  refs = 0;\n  if (match_rendition.mask)\n    matches = &win->matches;\n  if (ref_rendition.mask || hl_ref_rendition.mask)\n    refs = win->node->references;\n\n  pl_num = 0;\n\n  ref_highlighted = 0;\n\n  writing_out = DEFAULT; /* Global variable, declared above. */\n  ref_index = match_index = 0;\n\n  mbi_init (iter, win->node->contents + win->line_starts[win->pagetop],\n            win->node->nodelen - win->line_starts[win->pagetop]);\n  mbi_avail (iter);\n  while (1)\n    {\n      int delim;\n      mbi_copy (&bol_iter, &iter);\n      bol_ref_index = ref_index;\n      bol_match_index = match_index;\n      bol_ref_highlighted = ref_highlighted;\n\n      /* Come back here at end of line when write_out == COLLECT */\nstart_of_line:\n      pl_chars = 0;\n\n      text_buffer_reset (&tb_printed_line);\n\n      delim = 0;\n      /* Check if we have processed all the lines in the window. */\n      if (pl_num == win->height)\n        break;\n\n      /* Check if this line of the window is off the screen.  This might \n         happen if the screen was resized very small. */\n      if (win->first_row + pl_num >= screenheight)\n        break;\n\n      display_process_line (win, &iter, &tb_printed_line, &delim);\n\n      /* End of printed line. */\n      text_buffer_add_char (&tb_printed_line, '\\0');\n\n      finish = 0;\n      /* If there are no highlighted regions in a line, we output the line with\n         display_update_line, which does some optimization of the redisplay.\n         Otherwise, the entire line is output in this function. */\n      if (writing_out == DEFAULT)\n        {\n          finish = display_update_line (win->first_row + pl_num,\n                      text_buffer_base (&tb_printed_line),\n                      text_buffer_off (&tb_printed_line) - 1,\n                      pl_chars);\n        }\n      else if (writing_out == COLLECT)\n        {\n          /* Check if the line differs from what is already on the display,\n             and if so, go back to the start of the line and display it for\n             real. */\n          DISPLAY_LINE *entry = the_display[win->first_row + pl_num];\n          if (strcmp (tb_printed_line.base,\n                      the_display[win->first_row + pl_num]->text))\n            {\n              if (tb_printed_line.off > screenwidth)\n                {\n                  entry->text = xrealloc (entry->text,\n                                          tb_printed_line.off + 1);\n                }\n              strcpy (entry->text, tb_printed_line.base);\n              /* Record that the contents of this DISPLAY_LINE isn't\n                 literally what is on the display. */\n              entry->textlen = 0;\n              entry->inverse = 1;\n              mbi_copy (&iter, &bol_iter);\n              mbi_avail (bol_iter);\n              ref_index = bol_ref_index;\n              match_index = bol_match_index;\n              terminal_goto_xy (0, win->first_row + pl_num);\n              ref_highlighted = bol_ref_highlighted;\n              writing_out = WRITEOUT;\n              goto start_of_line;\n            }\n          else\n            writing_out = DEFAULT;\n        }\n      else /* writing_out == WRITEOUT */\n        {\n          /* We have just written out this line to the display. */\n          terminal_clear_to_eol ();\n          writing_out = DEFAULT;\n        }\n\n      /* Check if a line continuation character should be displayed.\n         Don't print one on the very last line of the display, as this could \n         cause it to scroll. */\n      if (delim)\n        mbi_advance (iter);\n      else if (win->first_row + pl_num <= the_screen->height - 2)\n        {\n          terminal_goto_xy (win->width - 1, win->first_row + pl_num);\n\n          if (!(win->flags & W_NoWrap))\n            terminal_put_text (\"\\\\\");\n          else\n            {\n              terminal_put_text (\"$\");\n\n              /* If this window has chosen not to wrap lines, skip to the\n                 end of the logical line in the buffer, and start a new\n                 line here. */\n              for (; mbi_avail (iter); mbi_advance (iter))\n                if (mb_len (mbi_cur (iter)) == 1\n                    && *mbi_cur_ptr (iter) == '\\n')\n                  {\n                    mbi_advance (iter);\n                    break;\n                  }\n            }\n          fflush (stdout);\n        }\n\n      pl_num++;\n      if (finish)\n        break; /* Display was interrupted by typed input. */\n\n      if (!mbi_avail (iter))\n        break;\n    }\n\n  /* Unlike search match highlighting, we always turn reference highlighting\n     off at the end of each line, so the following isn't needed. */\n  /* terminal_end_underline (); */\n\n  return pl_num;\n}",
      "lines": 150,
      "depth": 19,
      "decorators": [
        "int"
      ]
    },
    "display_update_one_window": {
      "start_point": [
        642,
        0
      ],
      "end_point": [
        741,
        1
      ],
      "content": "void\ndisplay_update_one_window (WINDOW *win)\n{\n  size_t line_index = 0;\n  DISPLAY_LINE **display = the_display;\n\n  signal_block_winch ();\n\n  /* If display is inhibited, that counts as an interrupted display. */\n  if (display_inhibited)\n    {\n      display_was_interrupted_p = 1;\n      goto funexit;\n    }\n\n  /* If the window has no height, quit now.  Strictly speaking, it\n     should only be necessary to test if the values are equal to zero, since\n     window_new_screen_size should ensure that the window height/width never\n     becomes negative, but since historically this has often been the culprit\n     for crashes, do our best to be doubly safe.  */\n  if (win->height <= 0 || win->width <= 0)\n    goto funexit;\n\n  /* If the window's first row doesn't appear in the_screen, then it\n     cannot be displayed.  This can happen when the_echo_area is the\n     window to be displayed, and the screen has shrunk to less than one\n     line. */\n  if ((win->first_row < 0) || (win->first_row > the_screen->height))\n    goto funexit;\n\n  /* If this window has a modeline, it might need to be redisplayed.  Do\n     this before the rest of the window to aid in navigation in case the\n     rest of the window is slow to update (for example, if it has lots of\n     search matches to be displayed). */\n  if (!(win->flags & W_InhibitMode))\n    {\n      window_make_modeline (win);\n      line_index = win->first_row + win->height;\n\n      /* This display line must both be in inverse, and have the same\n         contents. */\n      if ((!display[line_index]->inverse\n           || (strcmp (display[line_index]->text, win->modeline) != 0))\n          /* Check screen isn't very small. */\n          && line_index < the_screen->height)\n        {\n          terminal_goto_xy (0, line_index);\n          terminal_begin_inverse ();\n          terminal_put_text (win->modeline);\n          terminal_end_inverse ();\n          strcpy (display[line_index]->text, win->modeline);\n          display[line_index]->inverse = 1;\n          display[line_index]->textlen = strlen (win->modeline);\n        }\n    }\n\n  if (win->node)\n    {\n      if (!win->line_starts)\n        calculate_line_starts (win);\n      line_index = display_update_node_text (win);\n\n      if (display_was_interrupted_p)\n\tgoto funexit;\n    }\n\n  /* We have reached the end of the node or the end of the window.  If it\n     is the end of the node, then clear the lines of the window from here\n     to the end of the window. */\n  for (; line_index < win->height; line_index++)\n    {\n      DISPLAY_LINE *entry = display[win->first_row + line_index];\n\n      /* If this line has text on it, or if we don't know what is on the line,\n         clear this line. */\n      if (entry->textlen || entry->inverse)\n        {\n          entry->textlen = 0;\n          entry->text[0] = '\\0';\n          entry->inverse = 0;\n\n          terminal_goto_xy (0, win->first_row + line_index);\n          terminal_clear_to_eol ();\n          fflush (stdout);\n\n          if (info_any_buffered_input_p ())\n            {\n              display_was_interrupted_p = 1;\n              goto funexit;\n            }\n        }\n    }\n\n  fflush (stdout);\n\n  /* Okay, this window doesn't need updating anymore. */\n  win->flags &= ~W_UpdateWindow;\nfunexit:\n  signal_unblock_winch ();\n}",
      "lines": 100,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "display_scroll_region": {
      "start_point": [
        745,
        0
      ],
      "end_point": [
        792,
        1
      ],
      "content": "static void\ndisplay_scroll_region (int start, int end, int amount)\n{\n  int i;\n  DISPLAY_LINE *temp;\n\n  /* Do it on the screen. */\n  terminal_scroll_region (start, end, amount);\n\n  /* Now do it in the display buffer so our contents match the screen. */\n  if (amount > 0)\n    {\n      for (i = end - 1; i >= start + amount; i--)\n        {\n          /* Swap rows i and (i - amount). */\n          temp = the_display[i];\n          the_display[i] = the_display[i - amount];\n          the_display[i - amount] = temp;\n        }\n\n      /* Clear vacated lines */\n      for (i = start; i < start + amount && i < end; i++)\n        {\n          the_display[i]->text[0] = '\\0';\n          the_display[i]->textlen = 0;\n          the_display[i]->inverse = 0;\n        }\n    }\n  else\n    {\n      amount *= -1;\n      for (i = start; i <= end - 1 - amount; i++)\n        {\n          /* Swap rows i and (i + amount). */\n          temp = the_display[i];\n          the_display[i] = the_display[i + amount];\n          the_display[i + amount] = temp;\n        }\n\n      /* Clear vacated lines */\n      for (i = end - 1; i >= end - amount && i >= start; i--)\n        {\n          the_display[i]->text[0] = '\\0';\n          the_display[i]->textlen = 0;\n          the_display[i]->inverse = 0;\n        }\n    }\n}",
      "lines": 48,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "display_scroll_display": {
      "start_point": [
        799,
        0
      ],
      "end_point": [
        877,
        1
      ],
      "content": "void\ndisplay_scroll_display (int start, int end, int amount)\n{\n  register int i, last;\n  DISPLAY_LINE *temp;\n\n  /* If this terminal cannot do scrolling, give up now. */\n  if (!terminal_can_scroll && !terminal_can_scroll_region)\n    return;\n\n  /* If there isn't anything displayed on the screen because it is too\n     small, quit now. */\n  if (!the_display[0])\n    return;\n\n  /* If there is typeahead pending, then don't actually do any scrolling. */\n  if (info_any_buffered_input_p ())\n    return;\n\n  /* Use scrolling region if we can because it doesn't affect the area\n     below the area we want to scroll. */\n  if (terminal_can_scroll_region)\n    {\n      display_scroll_region (start, end, amount);\n      return;\n    }\n\n  /* Otherwise scroll by deleting and inserting lines. */\n\n  if (amount < 0)\n    start -= amount;\n  else\n    end -= amount;\n\n  /* Do it on the screen. */\n  terminal_scroll_terminal (start, end, amount);\n\n  /* Now do it in the display buffer so our contents match the screen. */\n  if (amount > 0)\n    {\n      last = end + amount;\n\n      /* Shift the lines to scroll right into place. */\n      for (i = 1; i <= (end - start); i++)\n        {\n          temp = the_display[last - i];\n          the_display[last - i] = the_display[end - i];\n          the_display[end - i] = temp;\n        }\n\n      /* The lines have been shifted down in the buffer.  Clear all of the\n         lines that were vacated. */\n      for (i = start; i != (start + amount); i++)\n        {\n          the_display[i]->text[0] = '\\0';\n          the_display[i]->textlen = 0;\n          the_display[i]->inverse = 0;\n        }\n    }\n  else\n    {\n      last = start + amount;\n      for (i = 0; i < (end - start); i++)\n        {\n          temp = the_display[last + i];\n          the_display[last + i] = the_display[start + i];\n          the_display[start + i] = temp;\n        }\n\n      /* The lines have been shifted up in the buffer.  Clear all of the\n         lines that are left over. */\n      for (i = end + amount; i != end; i++)\n        {\n          the_display[i]->text[0] = '\\0';\n          the_display[i]->textlen = 0;\n          the_display[i]->inverse = 0;\n        }\n    }\n}",
      "lines": 79,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "display_scroll_line_starts": {
      "start_point": [
        883,
        0
      ],
      "end_point": [
        953,
        1
      ],
      "content": "void\ndisplay_scroll_line_starts (WINDOW *window, int old_pagetop,\n    long *old_starts, int old_count)\n{\n  register int i, old, new;     /* Indices into the line starts arrays. */\n  int last_new, last_old;       /* Index of the last visible line. */\n  int old_first, new_first;     /* Index of the first changed line. */\n  int unchanged_at_top = 0;\n  int already_scrolled = 0;\n\n  /* Locate the first line which was displayed on the old window. */\n  old_first = old_pagetop;\n  new_first = window->pagetop;\n\n  /* Find the last line currently visible in this window. */\n  last_new = window->pagetop + (window->height - 1);\n  if (last_new > window->line_count)\n    last_new = window->line_count - 1;\n\n  /* Find the last line which used to be currently visible in this window. */\n  last_old = old_pagetop + (window->height - 1);\n  if (last_old > old_count)\n    last_old = old_count - 1;\n\n  for (old = old_first, new = new_first;\n       old < last_old && new < last_new;\n       old++, new++)\n    if (old_starts[old] != window->line_starts[new])\n      break;\n    else\n      unchanged_at_top++;\n\n  /* Loop through the old lines looking for a match in the new lines. */\n  for (old = old_first + unchanged_at_top; old < last_old; old++)\n    {\n      for (new = new_first; new < last_new; new++)\n        if (old_starts[old] == window->line_starts[new])\n          {\n            /* Find the extent of the matching lines. */\n            for (i = 0; (old + i) < last_old; i++)\n              if (old_starts[old + i] != window->line_starts[new + i])\n                break;\n\n            /* Scroll these lines if there are enough of them. */\n            {\n              int start, end, amount;\n\n              start = (window->first_row\n                       + ((old + already_scrolled) - old_pagetop));\n              amount = new - (old + already_scrolled);\n              end = window->first_row + window->height;\n\n              /* If we are shifting the block of lines down, then the last\n                 AMOUNT lines will become invisible.  Thus, don't bother\n                 scrolling them. */\n              if (amount > 0)\n                end -= amount;\n\n              if ((end - start) > 0)\n                {\n                  display_scroll_display (start, end, amount);\n\n                  /* Some lines have been scrolled.  Simulate the scrolling\n                     by offsetting the value of the old index. */\n                  old += i;\n                  already_scrolled += amount;\n                }\n            }\n          }\n    }\n}",
      "lines": 71,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "display_cursor_at_point": {
      "start_point": [
        956,
        0
      ],
      "end_point": [
        965,
        1
      ],
      "content": "void\ndisplay_cursor_at_point (WINDOW *window)\n{\n  int vpos, hpos;\n\n  vpos = window_line_of_point (window) - window->pagetop + window->first_row;\n  hpos = window_get_cursor_column (window);\n  terminal_goto_xy (hpos, vpos);\n  fflush (stdout);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "make_display": {
      "start_point": [
        974,
        0
      ],
      "end_point": [
        991,
        1
      ],
      "content": "static DISPLAY_LINE **\nmake_display (int width, int height)\n{\n  register int i;\n  DISPLAY_LINE **display;\n\n  display = xmalloc ((1 + height) * sizeof (DISPLAY_LINE *));\n\n  for (i = 0; i < height; i++)\n    {\n      display[i] = xmalloc (sizeof (DISPLAY_LINE));\n      display[i]->text = xmalloc (1 + width);\n      display[i]->textlen = 0;\n      display[i]->inverse = 0;\n    }\n  display[i] = NULL;\n  return display;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "DISPLAY_LINE",
        "**\nmake_display (int width, int height)",
        "*",
        "*\nmake_display (int width, int height)",
        "*"
      ]
    },
    "free_display": {
      "start_point": [
        994,
        0
      ],
      "end_point": [
        1009,
        1
      ],
      "content": "static void\nfree_display (DISPLAY_LINE **display)\n{\n  register int i;\n  register DISPLAY_LINE *display_line;\n\n  if (!display)\n    return;\n\n  for (i = 0; (display_line = display[i]); i++)\n    {\n      free (display_line->text);\n      free (display_line);\n    }\n  free (display);\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "texinfo/texinfo-6.5/info/display.h": {},
  "texinfo/texinfo-6.5/info/doc.h": {},
  "texinfo/texinfo-6.5/info/dribble.c": {
    "open_dribble_file": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "void\nopen_dribble_file (char *name)\n{\n  /* Perhaps close existing dribble file. */\n  close_dribble_file ();\n\n  /* Keystrokes can be non-printable characters, so we need binary I/O.  */\n  info_dribble_file = fopen (name, FOPEN_WBIN);\n\n#if defined (HAVE_SETVBUF)\n  if (info_dribble_file)\n#  if defined (SETVBUF_REVERSED)\n    setvbuf (info_dribble_file, _IONBF, NULL, 1);\n#  else\n    setvbuf (info_dribble_file, NULL, _IONBF, 1);\n#  endif /* !SETVBUF_REVERSED */\n#endif /* HAVE_SETVBUF */\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "close_dribble_file": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "void\nclose_dribble_file (void)\n{\n  if (info_dribble_file)\n    {\n      fflush (info_dribble_file);\n      fclose (info_dribble_file);\n      info_dribble_file = NULL;\n    }\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "dribble": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "void\ndribble (unsigned char byte)\n{\n  if (info_dribble_file)\n    fwrite (&byte, sizeof (unsigned char), 1, info_dribble_file);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "texinfo/texinfo-6.5/info/dribble.h": {},
  "texinfo/texinfo-6.5/info/echo-area.c": {
    "remember_calling_window": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static void\nremember_calling_window (WINDOW *window)\n{\n  /* Only do this if the calling window is not the completions window, or,\n     if it is the completions window and there is no other window. */\n  if (!completions_window_p (window) ||\n      ((window == windows) && !(window->next)))\n    {\n      calling_window = window;\n      calling_window_node = window->node;\n    }\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "restore_calling_window": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "static void\nrestore_calling_window (void)\n{\n  register WINDOW *win, *compwin = NULL;\n\n  /* If the calling window is still visible, and it is the window that\n     we used for completions output, then restore the calling window. */\n  for (win = windows; win; win = win->next)\n    {\n      if (completions_window_p (win))\n        compwin = win;\n\n      if (win == calling_window && win == compwin)\n        {\n          forget_node (win);\n          compwin = NULL;\n          break;\n        }\n    }\n\n  /* Delete the completions window if it is still present, it isn't the\n     last window on the screen, and there aren't any prior echo area reads\n     pending which created a completions window. */\n  if (compwin)\n    {\n      if ((compwin != windows || windows->next)\n          && !echo_area_stack_contains_completions_p ())\n        {\n          info_delete_window_internal (compwin);\n        }\n    }\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "initialize_input_line": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "static void\ninitialize_input_line (const char *prompt)\n{\n  strcpy (input_line, prompt);\n  input_line_beg = input_line_end = input_line_point = strlen (prompt);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "echo_area_after_read": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "static char *\necho_area_after_read (void)\n{\n  char *return_value;\n\n  if (info_aborted_echo_area)\n    {\n      info_aborted_echo_area = 0;\n      return_value = NULL;\n    }\n  else\n    {\n      if (input_line_beg == input_line_end)\n        return_value = xstrdup (\"\");\n      else\n        {\n          int line_len = input_line_end - input_line_beg;\n          return_value = xmalloc (1 + line_len);\n          strncpy (return_value, &input_line[input_line_beg], line_len);\n          return_value[line_len] = '\\0';\n        }\n    }\n  return return_value;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "*\necho_area_after_read (void)",
        "*"
      ]
    },
    "read_and_dispatch_in_echo_area": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "static void\nread_and_dispatch_in_echo_area (void)\n{\n  while (1)\n    {\n      int count;\n      VFunction *cmd;\n      int lk = 0;\n\n      lk = echo_area_last_command_was_kill;\n      echo_area_prep_read ();\n\n      if (!info_any_buffered_input_p ())\n        display_update_display ();\n\n      display_cursor_at_point (active_window);\n\n      /* Do the selected command. */\n      cmd = read_key_sequence (echo_area_keymap, 0, 0, 1, &count);\n      if (cmd)\n        {\n          (*cmd) (the_echo_area, count);\n          ea_last_executed_command = cmd;\n        }\n      else\n        ea_last_executed_command = 0;\n\n      /* Echo area commands that do killing increment the value of\n         ECHO_AREA_LAST_COMMAND_WAS_KILL.  Thus, if there is no\n         change in the value of this variable, the last command\n         executed was not a kill command. */\n      if (lk == echo_area_last_command_was_kill)\n        echo_area_last_command_was_kill = 0;\n\n      if (cmd == ea_newline || info_aborted_echo_area)\n        {\n          ea_last_executed_command = NULL;\n          break;\n        }\n    }\n}",
      "lines": 41,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "info_read_in_echo_area": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        245,
        1
      ],
      "content": "char *\ninfo_read_in_echo_area (const char *prompt)\n{\n  char *line;\n\n  /* If the echo area is already active, remember the current state. */\n  if (echo_area_is_active)\n    push_echo_area ();\n\n  /* Initialize our local variables. */\n  initialize_input_line (prompt);\n\n  /* Initialize the echo area for the first (but maybe not the last) time. */\n  echo_area_initialize_node ();\n\n  /* Save away the original node of this window, and the window itself,\n     so echo area commands can temporarily use this window. */\n  remember_calling_window (active_window);\n\n  /* Let the rest of Info know that the echo area is active. */\n  echo_area_is_active++;\n  active_window = the_echo_area;\n\n  /* Read characters in the echo area. */\n  read_and_dispatch_in_echo_area ();\n\n  window_clear_echo_area ();\n\n  echo_area_is_active--;\n\n  /* Restore the original active window and show point in it. */\n  active_window = calling_window;\n  restore_calling_window ();\n  display_cursor_at_point (active_window);\n  fflush (stdout);\n\n  /* Get the value of the line. */\n  line = echo_area_after_read ();\n\n  /* If there is a previous loop waiting for us, restore it now. */\n  if (echo_area_is_active)\n    pop_echo_area ();\n\n  /* Return the results to the caller. */\n  return line;\n}",
      "lines": 46,
      "depth": 7,
      "decorators": [
        "char",
        "*\ninfo_read_in_echo_area (const char *prompt)",
        "*"
      ]
    },
    "echo_area_initialize_node": {
      "start_point": [
        248,
        0
      ],
      "end_point": [
        259,
        1
      ],
      "content": "static void\necho_area_initialize_node (void)\n{\n  register int i;\n\n  for (i = input_line_end; (unsigned int) i < sizeof (input_line); i++)\n    input_line[i] = ' ';\n\n  input_line[i - 1] = '\\n';\n  window_set_node_of_window (the_echo_area, &input_line_node);\n  input_line[input_line_end] = '\\n';\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "echo_area_prep_read": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        281,
        1
      ],
      "content": "void\necho_area_prep_read (void)\n{\n  if (the_echo_area->node != &input_line_node)\n    echo_area_initialize_node ();\n\n  the_echo_area->point = input_line_point;\n  input_line[input_line_end] = '\\n';\n\n  /* Mark the line map as invalid.  This causes window_compute_line_map to\n     recalculate it when it is called via display_cursor_at_point below.  \n     Otherwise adding or removing multi-column characters (like tabs) lead \n     to incorrect cursor positioning. */\n  the_echo_area->line_map.used = 0;\n\n  display_update_one_window (the_echo_area);\n  display_cursor_at_point (active_window);\n}",
      "lines": 18,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "ea_insert": {
      "start_point": [
        507,
        0
      ],
      "end_point": [
        525,
        1
      ],
      "content": "void\nea_insert (WINDOW *window, int count, int key)\n{\n  register int i;\n\n  if ((input_line_end + 1) == EA_MAX_INPUT)\n    {\n      terminal_ring_bell ();\n      return;\n    }\n\n  for (i = input_line_end + 1; i != input_line_point; i--)\n    input_line[i] = input_line[i - 1];\n\n  input_line[input_line_point] = key;\n  input_line_point++;\n  input_line_end++;\n  window_line_map_init (window);\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ea_swap_chars": {
      "start_point": [
        534,
        0
      ],
      "end_point": [
        575,
        1
      ],
      "content": "static void\nea_swap_chars (int c1, int c1e, int c2, int c2e)\n{\n  int len1, len2;\n  char *tmp;\n\n  len1 = c1e - c1;\n  len2 = c2e - c2;\n\n  if (len1 >= len2)\n    {\n      /* Save first character. */\n      tmp = xmalloc (len1);\n      memcpy (tmp, input_line + c1, len1);\n\n      /* Move the second character to where the first was. */\n      memcpy (input_line + c1, input_line + c2, len2);\n\n      /* Shift the part in between the characters backwards. */\n      memmove (input_line + c1 + len2, input_line + c1e, c2 - c1e);\n\n      /* Restore the first character at the end. */\n      memcpy (input_line + c2 - (len1 - len2), tmp, len1);\n      free (tmp);\n    }\n  else /* len2 > len1 */\n    {\n      /* Save second character. */\n      tmp = xmalloc (len2);\n      memcpy (tmp, input_line + c2, len2);\n\n      /* Move first character to end of second character. */\n      memcpy (input_line + c2e - len1, input_line + c1, len1);\n\n      /* Shift the part in between the characters forwards. */\n      memmove (input_line + c1e + (len2 - len1), input_line + c1e, c2 - c1e);\n\n      /* Place the second character at the beginning. */\n      memcpy (input_line + c1, tmp, len2);\n      free (tmp);\n    }\n}",
      "lines": 42,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ea_remove_text": {
      "start_point": [
        764,
        0
      ],
      "end_point": [
        774,
        1
      ],
      "content": "static void\nea_remove_text (int from, int to)\n{\n  int distance, i, counter;\n  counter = input_line_end - to;\n  distance = to - from;\n\n  for (i = from; counter; i++, counter--)\n    input_line[i] = input_line[i + distance];\n  input_line_end -= distance;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ea_kill_text": {
      "start_point": [
        781,
        0
      ],
      "end_point": [
        860,
        1
      ],
      "content": "static void\nea_kill_text (int from, int to)\n{\n  register int distance;\n  int killing_backwards, slot;\n  char *killed_text;\n\n  killing_backwards = (from > to);\n\n  /* If killing backwards, reverse the values of FROM and TO. */\n  if (killing_backwards)\n    {\n      int temp = from;\n      from = to;\n      to = temp;\n    }\n\n  /* Remember the text that we are about to delete. */\n  distance = to - from;\n  killed_text = xmalloc (1 + distance);\n  strncpy (killed_text, &input_line[from], distance);\n  killed_text[distance] = '\\0';\n\n  /* Actually delete the text from the line. */\n  ea_remove_text (from, to);\n\n  /* If the last command was a kill, append or prepend the killed text to\n     the last command's killed text. */\n  if (echo_area_last_command_was_kill)\n    {\n      char *old, *new;\n\n      slot = kill_ring_loc;\n      old = kill_ring[slot];\n      new = xmalloc (1 + strlen (old) + strlen (killed_text));\n\n      if (killing_backwards)\n        {\n          /* Prepend TEXT to current kill. */\n          strcpy (new, killed_text);\n          strcat (new, old);\n        }\n      else\n        {\n          /* Append TEXT to current kill. */\n          strcpy (new, old);\n          strcat (new, killed_text);\n        }\n\n      free (old);\n      free (killed_text);\n      kill_ring[slot] = new;\n    }\n  else\n    {\n      /* Try to store the kill in a new slot, unless that would cause there\n         to be too many remembered kills. */\n      slot = kill_ring_index;\n\n      if (slot == max_retained_kills)\n        slot = 0;\n\n      if (slot + 1 > kill_ring_slots)\n        kill_ring = xrealloc (kill_ring,\n\t\t\t      (kill_ring_slots += max_retained_kills)\n\t\t\t      * sizeof (char *));\n\n      if (slot != kill_ring_index)\n        free (kill_ring[slot]);\n      else\n        kill_ring_index++;\n\n      kill_ring[slot] = killed_text;\n\n      kill_ring_loc = slot;\n    }\n\n  /* Notice that the last command was a kill. */\n  echo_area_last_command_was_kill++;\n}",
      "lines": 80,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "completions_window_p": {
      "start_point": [
        894,
        0
      ],
      "end_point": [
        904,
        1
      ],
      "content": "static int\ncompletions_window_p (WINDOW *window)\n{\n  int result = 0;\n\n  if (internal_info_node_p (window->node) &&\n      (strcmp (window->node->nodename, compwin_name) == 0))\n    result = 1;\n\n  return result;\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "info_read_completing_internal": {
      "start_point": [
        909,
        0
      ],
      "end_point": [
        1003,
        1
      ],
      "content": "char *\ninfo_read_completing_internal (const char *prompt, REFERENCE **completions,\n                               int force, reference_bool_fn exclude_func)\n{\n  char *line;\n\n  /* If the echo area is already active, remember the current state. */\n  if (echo_area_is_active)\n    push_echo_area ();\n\n  echo_area_must_complete_p = force;\n\n  /* Initialize our local variables. */\n  initialize_input_line (prompt);\n  \n  /* Initialize the echo area for the first (but maybe not the last) time. */\n  echo_area_initialize_node ();\n\n  /* Save away the original node of this window, and the window itself,\n     so echo area commands can temporarily use this window. */\n  remember_calling_window (active_window);\n\n  /* Save away the list of items to complete over. */\n  echo_area_completion_items = completions;\n  completions_must_be_rebuilt ();\n  completion_exclude_func = exclude_func;\n\n  active_window = the_echo_area;\n  echo_area_is_active++;\n  window_line_map_init (active_window);\n\n  /* Read characters in the echo area. */\n  while (1)\n    {\n      read_and_dispatch_in_echo_area ();\n\n      line = echo_area_after_read ();\n\n      /* Force the completion to take place if the user hasn't accepted\n         a default or aborted, and if FORCE is active. */\n      if (force && line && *line && completions)\n        {\n          size_t i;\n\t  \n          build_completions ();\n\n          /* If there is only one completion, then make the line be that\n             completion. */\n          if (completions_found_index == 1)\n            {\n              free (line);\n              line = xstrdup (completions_found[0]->label);\n              break;\n            }\n\n          /* If one of the completions matches exactly, then that is okay, so\n             return the current line. */\n          for (i = 0; i < completions_found_index; i++)\n            if (mbscasecmp (completions_found[i]->label, line) == 0)\n              {\n                free (line);\n                line = xstrdup (completions_found[i]->label);\n                break;\n              }\n\n          /* If no match, go back and try again. */\n          if (i == completions_found_index)\n            {\n              if (!completions_found_index)\n                inform_in_echo_area (_(\"No completions\"));\n              else\n                inform_in_echo_area (_(\"Not complete\"));\n              continue;\n            }\n        }\n      break;\n    }\n  echo_area_is_active--;\n  window_clear_echo_area ();\n\n  /* Restore the original active window and show point in it. */\n  active_window = calling_window;\n  restore_calling_window ();\n  display_cursor_at_point (active_window);\n  fflush (stdout);\n\n  echo_area_completion_items = NULL;\n  completions_must_be_rebuilt ();\n\n  /* If there is a previous loop waiting for us, restore it now. */\n  if (echo_area_is_active)\n    pop_echo_area ();\n\n  return line;\n}",
      "lines": 95,
      "depth": 16,
      "decorators": [
        "char",
        "*\ninfo_read_completing_internal (const char *prompt, REFERENCE **completions,\n                               int force, reference_bool_fn exclude_func)",
        "*"
      ]
    },
    "info_read_completing_in_echo_area": {
      "start_point": [
        1006,
        0
      ],
      "end_point": [
        1010,
        1
      ],
      "content": "char *\ninfo_read_completing_in_echo_area (const char *prompt, REFERENCE **completions)\n{\n  return info_read_completing_internal (prompt, completions, 1, 0);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "char",
        "*\ninfo_read_completing_in_echo_area (const char *prompt, REFERENCE **completions)",
        "*"
      ]
    },
    "info_read_maybe_completing": {
      "start_point": [
        1014,
        0
      ],
      "end_point": [
        1018,
        1
      ],
      "content": "char *\ninfo_read_maybe_completing (const char *prompt, REFERENCE **completions)\n{\n  return info_read_completing_internal (prompt, completions, 0, 0);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "char",
        "*\ninfo_read_maybe_completing (const char *prompt, REFERENCE **completions)",
        "*"
      ]
    },
    "info_read_completing_in_echo_area_with_exclusions": {
      "start_point": [
        1022,
        0
      ],
      "end_point": [
        1027,
        1
      ],
      "content": "char *\ninfo_read_completing_in_echo_area_with_exclusions (const char *prompt,\n     REFERENCE **completions, reference_bool_fn exclude)\n{\n  return info_read_completing_internal (prompt, completions, 1, exclude);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "char",
        "*\ninfo_read_completing_in_echo_area_with_exclusions (const char *prompt,\n     REFERENCE **completions, reference_bool_fn exclude)",
        "*"
      ]
    },
    "completions_must_be_rebuilt": {
      "start_point": [
        1203,
        0
      ],
      "end_point": [
        1209,
        1
      ],
      "content": "static void\ncompletions_must_be_rebuilt (void)\n{\n  free (last_completion_request);\n  last_completion_request = NULL;\n  last_completion_items = NULL;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "build_completions": {
      "start_point": [
        1213,
        0
      ],
      "end_point": [
        1333,
        1
      ],
      "content": "static void\nbuild_completions (void)\n{\n  size_t i;\n  int len;\n  register REFERENCE *entry;\n  char *request;\n  int informed_of_lengthy_job = 0;\n\n  /* If there are no items to complete over, exit immediately. */\n  if (!echo_area_completion_items)\n    {\n      completions_found_index = 0;\n      LCD_completion = NULL;\n      return;\n    }\n\n  /* Check to see if this call to build completions is the same as the last\n     call to build completions. */\n  len = input_line_end - input_line_beg;\n  request = xmalloc (1 + len);\n  strncpy (request, &input_line[input_line_beg], len);\n  request[len] = '\\0';\n\n  if (last_completion_request && last_completion_items &&\n      last_completion_items == echo_area_completion_items &&\n      (strcmp (last_completion_request, request) == 0))\n    {\n      free (request);\n      return;\n    }\n\n  free (last_completion_request);\n  last_completion_request = request;\n  last_completion_items = echo_area_completion_items;\n\n  /* Always start at the beginning of the list. */\n  completions_found_index = 0;\n  LCD_completion = NULL;\n\n  for (i = 0; (entry = echo_area_completion_items[i]); i++)\n    {\n      /* Skip certain items (for example, we might only want\n         a list of menu items). */\n      if (completion_exclude_func && completion_exclude_func (entry))\n        continue;\n\n      if (mbsncasecmp (request, entry->label, len) == 0)\n        add_pointer_to_array (entry, completions_found_index,\n                              completions_found, completions_found_slots,\n                              20);\n\n      if (!informed_of_lengthy_job && completions_found_index > 100)\n        {\n          informed_of_lengthy_job = 1;\n          window_message_in_echo_area (_(\"Building completions...\"));\n        }\n    }\n\n  if (!completions_found_index)\n    return;\n\n  /* Sort and prune duplicate entries from the completions array. */\n  remove_completion_duplicates ();\n\n  /* If there is only one completion, just return that. */\n  if (completions_found_index == 1)\n    {\n      LCD_completion = completions_found[0];\n      return;\n    }\n\n  /* Find the least common denominator. */\n  {\n    long shortest = 100000;\n\n    for (i = 1; i < completions_found_index; i++)\n      {\n        register int j;\n        int c1, c2;\n\n        for (j = 0;\n             (c1 = tolower (completions_found[i - 1]->label[j]))\n             && (c2 = tolower (completions_found[i]->label[j]));\n             j++)\n          if (c1 != c2)\n            break;\n\n        if (shortest > j)\n          shortest = j;\n      }\n\n    free (LCD_reference.label);\n    LCD_reference.label = xmalloc (1 + shortest);\n    /* Since both the sorting done inside remove_completion_duplicates\n       and all the comparisons above are case-insensitive, it's\n       possible that the completion we are going to return is\n       identical to what the user typed but for the letter-case.  This\n       is confusing, since the user could type FOOBAR<TAB> and get her\n       string change letter-case for no good reason.  So try to find a\n       possible completion whose letter-case is identical, and if so,\n       use that.  */\n    if (completions_found_index > 1)\n      {\n\tint req_len = strlen (request);\n\n        for (i = 0; i < completions_found_index; i++)\n          if (strncmp (request, completions_found[i]->label, req_len) == 0)\n            break;\n        /* If none of the candidates match exactly, use the first one.  */\n        if (i >= completions_found_index)\n          i = 0;\n      }\n    strncpy (LCD_reference.label, completions_found[i]->label, shortest);\n    LCD_reference.label[shortest] = '\\0';\n    LCD_completion = &LCD_reference;\n  }\n\n  if (informed_of_lengthy_job)\n    echo_area_initialize_node ();\n}",
      "lines": 121,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "compare_references": {
      "start_point": [
        1336,
        0
      ],
      "end_point": [
        1343,
        1
      ],
      "content": "static int\ncompare_references (const void *entry1, const void *entry2)\n{\n  REFERENCE **e1 = (REFERENCE **) entry1;\n  REFERENCE **e2 = (REFERENCE **) entry2;\n\n  return mbscasecmp ((*e1)->label, (*e2)->label);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "remove_completion_duplicates": {
      "start_point": [
        1346,
        0
      ],
      "end_point": [
        1382,
        1
      ],
      "content": "static void\nremove_completion_duplicates (void)\n{\n  size_t i, j;\n  REFERENCE **temp;\n  int newlen;\n\n  if (!completions_found_index)\n    return;\n\n  /* Sort the items. */\n  qsort (completions_found, completions_found_index, sizeof (REFERENCE *),\n         compare_references);\n\n  for (i = 0, newlen = 1; i < completions_found_index - 1; i++)\n    {\n      if (strcmp (completions_found[i]->label,\n                  completions_found[i + 1]->label) == 0)\n        completions_found[i] = NULL;\n      else\n        newlen++;\n    }\n\n  /* We have marked all the dead slots.  It is faster to copy the live slots\n     twice than to prune the dead slots one by one. */\n  temp = xmalloc ((1 + newlen) * sizeof (REFERENCE *));\n  for (i = 0, j = 0; i < completions_found_index; i++)\n    if (completions_found[i])\n      temp[j++] = completions_found[i];\n\n  for (i = 0; i < newlen; i++)\n    completions_found[i] = temp[i];\n\n  completions_found[i] = NULL;\n  completions_found_index = newlen;\n  free (temp);\n}",
      "lines": 37,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "echo_area_inform_of_deleted_window": {
      "start_point": [
        1403,
        0
      ],
      "end_point": [
        1419,
        1
      ],
      "content": "void\necho_area_inform_of_deleted_window (WINDOW *window)\n{\n  /* If this is the calling_window, forget what we remembered about it. */\n  if (window == calling_window)\n    {\n      if (active_window != the_echo_area)\n        remember_calling_window (active_window);\n      else\n        remember_calling_window (windows);\n    }\n\n  /* If this window was the echo_area_completions_window, then notice that\n     the window has been deleted. */\n  if (window == echo_area_completions_window)\n    echo_area_completions_window = NULL;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "push_echo_area": {
      "start_point": [
        1442,
        0
      ],
      "end_point": [
        1461,
        1
      ],
      "content": "static void\npush_echo_area (void)\n{\n  PUSHED_EA *pushed;\n\n  pushed = xmalloc (sizeof (PUSHED_EA));\n  pushed->line = xstrdup (input_line);\n  pushed->point = input_line_point;\n  pushed->beg = input_line_beg;\n  pushed->end = input_line_end;\n  pushed->node = input_line_node;\n  pushed->comp_items = echo_area_completion_items;\n  pushed->must_complete = echo_area_must_complete_p;\n  pushed->compwin = echo_area_completions_window;\n\n  add_pointer_to_array (pushed, pushed_echo_areas_index, pushed_echo_areas,\n                        pushed_echo_areas_slots, 4);\n\n  echo_area_completion_items = NULL;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pop_echo_area": {
      "start_point": [
        1463,
        0
      ],
      "end_point": [
        1496,
        1
      ],
      "content": "static void\npop_echo_area (void)\n{\n  PUSHED_EA *popped;\n\n  popped = pushed_echo_areas[--pushed_echo_areas_index];\n\n  strcpy (input_line, popped->line);\n  free (popped->line);\n  input_line_point = popped->point;\n  input_line_beg = popped->beg;\n  input_line_end = popped->end;\n  input_line_node = popped->node;\n  echo_area_completion_items = popped->comp_items;\n  echo_area_must_complete_p = popped->must_complete;\n  echo_area_completions_window = popped->compwin;\n  completions_must_be_rebuilt ();\n\n  /* If the completion window no longer exists, forget about it. */\n  if (echo_area_completions_window)\n    {\n      register WINDOW *win;\n\n      for (win = windows; win; win = win->next)\n        if (echo_area_completions_window == win)\n          break;\n\n      /* If the window wasn't found, then it has already been deleted. */\n      if (!win)\n        echo_area_completions_window = NULL;\n    }\n\n  free (popped);\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "echo_area_stack_contains_completions_p": {
      "start_point": [
        1500,
        0
      ],
      "end_point": [
        1510,
        1
      ],
      "content": "static int\necho_area_stack_contains_completions_p (void)\n{\n  size_t i;\n\n  for (i = 0; i < pushed_echo_areas_index; i++)\n    if (pushed_echo_areas[i]->compwin)\n      return 1;\n\n  return 0;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "pause_or_input": {
      "start_point": [
        1528,
        0
      ],
      "end_point": [
        1546,
        1
      ],
      "content": "static void\npause_or_input (void)\n{\n#ifdef FD_SET\n  struct timeval timer;\n  fd_set readfds;\n\n  FD_ZERO (&readfds);\n  FD_SET (fileno (stdin), &readfds);\n  timer.tv_sec = 2;\n  timer.tv_usec = 0;\n  select (fileno (stdin) + 1, &readfds, NULL, NULL, &timer);\n#elif defined (__MINGW32__)\n  /* This is signalled on key release, so flush it and wait again. */\n  WaitForSingleObject (GetStdHandle (STD_INPUT_HANDLE), 2000);\n  FlushConsoleInputBuffer (GetStdHandle (STD_INPUT_HANDLE));\n  WaitForSingleObject (GetStdHandle (STD_INPUT_HANDLE), 2000);\n#endif /* FD_SET */\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "inform_in_echo_area": {
      "start_point": [
        1551,
        0
      ],
      "end_point": [
        1573,
        1
      ],
      "content": "void\ninform_in_echo_area (const char *message)\n{\n  int i;\n  char *text;\n  int avail = EA_MAX_INPUT + 1 - input_line_end;\n\n  text = xstrdup (message);\n  for (i = 0; text[i] && text[i] != '\\n' && i < avail; i++)\n    ;\n  text[i] = 0;\n\n  echo_area_initialize_node ();\n  sprintf (&input_line[input_line_end], \"%s[%s]\\n\",\n           echo_area_is_active ? \" \": \"\", text);\n  free (text);\n  the_echo_area->point = input_line_point;\n  display_update_one_window (the_echo_area);\n  display_cursor_at_point (active_window);\n  fflush (stdout);\n  pause_or_input ();\n  echo_area_initialize_node ();\n}",
      "lines": 23,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "texinfo/texinfo-6.5/info/echo-area.h": {},
  "texinfo/texinfo-6.5/info/filesys.c": {
    "info_find_fullpath": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "char *\ninfo_find_fullpath (char *partial, struct stat *finfo)\n{\n  char *fullpath = 0;\n  struct stat dummy;\n\n  debug(1, (_(\"looking for file \\\"%s\\\"\"), partial));\n\n  if (!finfo)\n    finfo = &dummy;\n\n  filesys_error_number = 0;\n\n  if (!partial || !*partial)\n    return 0;\n  \n  /* IS_SLASH and IS_ABSOLUTE defined in ../system.h. */\n\n  /* If path is absolute already, see if it needs an extension. */\n  if (IS_ABSOLUTE (partial)\n      || partial[0] == '.' && IS_SLASH(partial[1]))\n    {\n      fullpath = info_add_extension (0, partial, finfo);\n    }\n\n  /* Tilde expansion.  FIXME: Not needed, because done by shell. */\n  else if (partial[0] == '~')\n    {\n      partial = tilde_expand_word (partial);\n      fullpath = info_add_extension (0, partial, finfo);\n    }\n\n  /* If just a simple name element, look for it in the path. */\n  else\n    fullpath = info_file_in_path (partial, finfo);\n\n  if (!fullpath)\n    filesys_error_number = ENOENT;\n\n  return fullpath;\n}",
      "lines": 41,
      "depth": 11,
      "decorators": [
        "char",
        "*\ninfo_find_fullpath (char *partial, struct stat *finfo)",
        "*"
      ]
    },
    "info_file_find_next_in_path": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "char *\ninfo_file_find_next_in_path (char *filename, int *path_index, struct stat *finfo)\n{\n  struct stat dummy;\n\n  /* Used for output of stat in case the caller doesn't care about\n     its value. */\n  if (!finfo)\n    finfo = &dummy;\n\n  /* Reject ridiculous cases up front, to prevent infinite recursion\n     later on.  E.g., someone might say \"info '(.)foo'\"...  */\n  if (!*filename || STREQ (filename, \".\") || STREQ (filename, \"..\"))\n    return NULL;\n\n  while (1)\n    {\n      char *dirname, *with_extension = 0;\n\n      dirname = infopath_next (path_index);\n      if (!dirname)\n        break;\n\n      debug(1, (_(\"looking for file %s in %s\"), filename, dirname));\n\n      /* Expand a leading tilde if one is present. */\n      if (*dirname == '~')\n        {\n          char *expanded_dirname = tilde_expand_word (dirname);\n          free (dirname);\n          dirname = expanded_dirname;\n        }\n\n      with_extension = info_add_extension (dirname, filename, finfo);\n\n      if (with_extension)\n        {\n          if (!IS_ABSOLUTE (with_extension))\n            {\n              /* Prefix \"./\" to it. */\n              char *s;\n              asprintf (&s, \"%s%s\", \"./\", with_extension);\n              free (with_extension);\n              return s;\n            }\n          else\n            return with_extension;\n        }\n    }\n  return NULL;\n}",
      "lines": 51,
      "depth": 13,
      "decorators": [
        "char",
        "*\ninfo_file_find_next_in_path (char *filename, int *path_index, struct stat *finfo)",
        "*"
      ]
    },
    "info_file_in_path": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "static char *\ninfo_file_in_path (char *filename, struct stat *finfo)\n{\n  int i = 0;\n  return info_file_find_next_in_path (filename, &i, finfo);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ninfo_file_in_path (char *filename, struct stat *finfo)",
        "*"
      ]
    },
    "info_add_extension": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        281,
        1
      ],
      "content": "char *\ninfo_add_extension (char *dirname, char *filename, struct stat *finfo)\n{\n  char *try_filename;\n  register int i, pre_suffix_length = 0;\n  struct stat dummy;\n\n  if (!finfo)\n    finfo = &dummy;\n\n  if (dirname)\n    pre_suffix_length += strlen (dirname);\n\n  pre_suffix_length += strlen (filename);\n\n  /* Add enough space for any file extensions at end. */\n  try_filename = xmalloc (pre_suffix_length + 30);\n  try_filename[0] = '\\0';\n\n  if (dirname)\n    {\n      strcpy (try_filename, dirname);\n      if (!IS_SLASH (try_filename[(strlen (try_filename)) - 1]))\n        {\n          strcat (try_filename, \"/\");\n          pre_suffix_length++;\n        }\n    }\n\n  strcat (try_filename, filename);\n\n  for (i = 0; info_suffixes[i]; i++)\n    {\n      int statable;\n\n      strcpy (try_filename + pre_suffix_length, info_suffixes[i]);\n      statable = (stat (try_filename, finfo) == 0);\n\n      /* If we have found a regular file, then use that.  Else, if we\n         have found a directory, look in that directory for this file. */\n      if (statable)\n        {\n          if (S_ISREG (finfo->st_mode))\n            {\n              debug(1, (_(\"found file %s\"), try_filename));\n              return try_filename;\n            }\n          else if (S_ISDIR (finfo->st_mode))\n            {\n              char *newpath, *new_filename;\n\n              newpath = xstrdup (try_filename);\n              new_filename = info_add_extension (newpath, filename, finfo);\n\n              free (newpath);\n              if (new_filename)\n                {\n                  free (try_filename);\n                  debug(1, (_(\"found file %s\"), new_filename));\n                  return new_filename;\n                }\n            }\n        }\n      else\n        {\n          /* Add various compression suffixes to the name to see if\n             the file is present in compressed format. */\n          register int j, pre_compress_suffix_length;\n\n          pre_compress_suffix_length = strlen (try_filename);\n\n          for (j = 0; compress_suffixes[j].suffix; j++)\n            {\n              strcpy (try_filename + pre_compress_suffix_length,\n                      compress_suffixes[j].suffix);\n\n              statable = (stat (try_filename, finfo) == 0);\n              if (statable && (S_ISREG (finfo->st_mode)))\n                {\n                  debug(1, (_(\"found file %s\"), try_filename));\n                  return try_filename;\n                }\n            }\n        }\n    }\n  /* Nothing was found. */\n  free (try_filename);\n  return 0;\n}",
      "lines": 89,
      "depth": 20,
      "decorators": [
        "char",
        "*\ninfo_add_extension (char *dirname, char *filename, struct stat *finfo)",
        "*"
      ]
    },
    "convert_eols": {
      "start_point": [
        292,
        0
      ],
      "end_point": [
        309,
        1
      ],
      "content": "static long\nconvert_eols (char *text, long int textlen)\n{\n  register char *s = text;\n  register char *d = text;\n\n  while (textlen--)\n    {\n      if (*s == '\\r' && textlen && s[1] == '\\n')\n       {\n         s++;\n         textlen--;\n       }\n      *d++ = *s++;\n    }\n\n  return d - text;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "long",
        "long"
      ]
    },
    "filesys_read_info_file": {
      "start_point": [
        317,
        0
      ],
      "end_point": [
        386,
        1
      ],
      "content": "char *\nfilesys_read_info_file (char *pathname, size_t *filesize,\n\t\t\tstruct stat *finfo, int *is_compressed)\n{\n  size_t fsize;\n  char *contents;\n\n  fsize = filesys_error_number = 0;\n\n  stat (pathname, finfo);\n  fsize = (long) finfo->st_size;\n\n  if (compressed_filename_p (pathname))\n    {\n      *is_compressed = 1;\n      contents = filesys_read_compressed (pathname, &fsize);\n    }\n  else\n    {\n      int descriptor;\n\n      *is_compressed = 0;\n      descriptor = open (pathname, O_RDONLY | O_BINARY, 0666);\n\n      /* If the file couldn't be opened, give up. */\n      if (descriptor < 0)\n        {\n          filesys_error_number = errno;\n          return NULL;\n        }\n\n      /* Try to read the contents of this file. */\n      contents = xmalloc (1 + fsize);\n      if ((read (descriptor, contents, fsize)) != fsize)\n        {\n\t  filesys_error_number = errno;\n\t  close (descriptor);\n\t  free (contents);\n\t  return NULL;\n        }\n      contents[fsize] = 0;\n      close (descriptor);\n    }\n\n#if defined (__MSDOS__) || defined (__MINGW32__)\n  /* Old versions of makeinfo on MS-DOS or MS-Windows generated Info files\n     with CR-LF line endings which are only counted as one byte in the file\n     tag table.  Convert any of these DOS-style CRLF EOLs into Unix-style NL\n     so that these files can be read correctly on such operating systems.\n\n     Don't do this on GNU/Linux (or other Unix-type operating system), so\n     as not to encourage Info files with CR-LF line endings to be distributed\n     widely beyond their native operating system, which would cause only\n     problems.  (If someone really needs to, they can convert the line endings\n     themselves with a separate program.)\n     Also, this will allow any Info files that contain any CR-LF endings by\n     mistake to work as expected (except on MS-DOS/Windows). */\n\n  fsize = convert_eols (contents, fsize);\n\n  /* EOL conversion can shrink the text quite a bit.  We don't\n     want to waste storage.  */\n  contents = xrealloc (contents, 1 + fsize);\n  contents[fsize] = '\\0';\n#endif\n\n  *filesize = fsize;\n\n  return contents;\n}",
      "lines": 70,
      "depth": 11,
      "decorators": [
        "char",
        "*\nfilesys_read_info_file (char *pathname, size_t *filesize,\n\t\t\tstruct stat *finfo, int *is_compressed)",
        "*"
      ]
    },
    "filesys_read_compressed": {
      "start_point": [
        394,
        0
      ],
      "end_point": [
        475,
        1
      ],
      "content": "static char *\nfilesys_read_compressed (char *pathname, size_t *filesize)\n{\n  FILE *stream;\n  char *command, *decompressor;\n  char *contents = NULL;\n\n  *filesize = filesys_error_number = 0;\n\n  decompressor = filesys_decompressor_for_file (pathname);\n\n  if (!decompressor)\n    return NULL;\n\n  command = xmalloc (15 + strlen (pathname) + strlen (decompressor));\n  /* Explicit .exe suffix makes the diagnostics of `popen'\n     better on systems where COMMAND.COM is the stock shell.  */\n  sprintf (command, \"%s%s < %s\",\n\t   decompressor, STRIP_DOT_EXE ? \".exe\" : \"\", pathname);\n\n  if (info_windows_initialized_p)\n    {\n      char *temp;\n\n      temp = xmalloc (5 + strlen (command));\n      sprintf (temp, \"%s...\", command);\n      message_in_echo_area (\"%s\", temp);\n      free (temp);\n    }\n\n  stream = popen (command, FOPEN_RBIN);\n  free (command);\n\n  /* Read chunks from this file until there are none left to read. */\n  if (stream)\n    {\n      size_t offset, size;\n      char *chunk;\n    \n      offset = size = 0;\n      chunk = xmalloc (FILESYS_PIPE_BUFFER_SIZE);\n\n      while (1)\n        {\n          size_t bytes_read;\n\n          bytes_read = fread (chunk, 1, FILESYS_PIPE_BUFFER_SIZE, stream);\n\n          if (bytes_read + offset >= size)\n            contents = xrealloc\n              (contents, size += (2 * FILESYS_PIPE_BUFFER_SIZE));\n\n          memcpy (contents + offset, chunk, bytes_read);\n          offset += bytes_read;\n          if (bytes_read != FILESYS_PIPE_BUFFER_SIZE)\n            break;\n        }\n\n      free (chunk);\n      if (pclose (stream) == -1)\n\t{\n\t  if (contents)\n\t    free (contents);\n\t  contents = NULL;\n\t  filesys_error_number = errno;\n\t}\n      else\n\t{\n\t  contents = xrealloc (contents, 1 + offset);\n\t  contents[offset] = '\\0';\n\t  *filesize = offset;\n\t}\n    }\n  else\n    {\n      filesys_error_number = errno;\n    }\n\n  if (info_windows_initialized_p)\n    unmessage_in_echo_area ();\n  return contents;\n}",
      "lines": 82,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nfilesys_read_compressed (char *pathname, size_t *filesize)",
        "*"
      ]
    },
    "compressed_filename_p": {
      "start_point": [
        478,
        0
      ],
      "end_point": [
        491,
        1
      ],
      "content": "static int\ncompressed_filename_p (char *filename)\n{\n  char *decompressor;\n\n  /* Find the final extension of this filename, and see if it matches one\n     of our known ones. */\n  decompressor = filesys_decompressor_for_file (filename);\n\n  if (decompressor)\n    return 1;\n  else\n    return 0;\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "filesys_decompressor_for_file": {
      "start_point": [
        494,
        0
      ],
      "end_point": [
        527,
        1
      ],
      "content": "static char *\nfilesys_decompressor_for_file (char *filename)\n{\n  register int i;\n  char *extension = NULL;\n\n  /* Find the final extension of FILENAME, and see if it appears in our\n     list of known compression extensions. */\n  for (i = strlen (filename) - 1; i > 0; i--)\n    if (filename[i] == '.')\n      {\n        extension = filename + i;\n        break;\n      }\n\n  if (!extension)\n    return NULL;\n\n  for (i = 0; compress_suffixes[i].suffix; i++)\n    if (FILENAME_CMP (extension, compress_suffixes[i].suffix) == 0)\n      return compress_suffixes[i].decompressor;\n\n#if defined (__MSDOS__)\n  /* If no other suffix matched, allow any extension which ends\n     with `z' to be decompressed by gunzip.  Due to limited 8+3 DOS\n     file namespace, we can expect many such cases, and supporting\n     every weird suffix thus produced would be a pain.  */\n  if (extension[strlen (extension) - 1] == 'z' ||\n      extension[strlen (extension) - 1] == 'Z')\n    return \"gunzip\";\n#endif\n\n  return NULL;\n}",
      "lines": 34,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nfilesys_decompressor_for_file (char *filename)",
        "*"
      ]
    },
    "filesys_error_string": {
      "start_point": [
        539,
        0
      ],
      "end_point": [
        556,
        1
      ],
      "content": "char *\nfilesys_error_string (char *filename, int error_num)\n{\n  int len;\n  char *result;\n\n  if (error_num == 0)\n    return NULL;\n\n  result = strerror (error_num);\n\n  len = 4 + strlen (filename) + strlen (result);\n  if (len >= errmsg_buf_size)\n    errmsg_buf = xrealloc (errmsg_buf, (errmsg_buf_size = 2 + len));\n\n  sprintf (errmsg_buf, \"%s: %s\", filename, result);\n  return errmsg_buf;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "char",
        "*\nfilesys_error_string (char *filename, int error_num)",
        "*"
      ]
    },
    "is_dir_name": {
      "start_point": [
        562,
        0
      ],
      "end_point": [
        588,
        1
      ],
      "content": "int\nis_dir_name (char *filename)\n{\n  unsigned i;\n\n  for (i = 0; info_suffixes[i]; i++)\n    {\n      unsigned c;\n      char trydir[50];\n      strcpy (trydir, \"dir\");\n      strcat (trydir, info_suffixes[i]);\n      \n      if (mbscasecmp (filename, trydir) == 0)\n        return 1;\n\n      for (c = 0; compress_suffixes[c].suffix; c++)\n        {\n          char dir_compressed[50]; /* can be short */\n          strcpy (dir_compressed, trydir); \n          strcat (dir_compressed, compress_suffixes[c].suffix);\n          if (mbscasecmp (filename, dir_compressed) == 0)\n            return 1;\n        }\n    }  \n\n  return 0;\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/info/filesys.h": {},
  "texinfo/texinfo-6.5/info/footnotes.c": {
    "find_footnotes_window": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static WINDOW *\nfind_footnotes_window (void)\n{\n  WINDOW *win;\n\n  /* Try to find an existing window first. */\n  for (win = windows; win; win = win->next)\n    if (internal_info_node_p (win->node) &&\n        (strcmp (win->node->nodename, footnote_nodename) == 0))\n      break;\n\n  return win;\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "WINDOW",
        "*\nfind_footnotes_window (void)",
        "*"
      ]
    },
    "make_footnotes_node": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "NODE *\nmake_footnotes_node (NODE *node)\n{\n  NODE *fn_node, *footnotes_node = NULL, *result = NULL;\n  long fn_start = -1;\n  char *fnptr;\n\n  /* Make the initial assumption that the footnotes appear as simple\n     text within this windows node. */\n  fn_node = node;\n\n  /* See if this node contains the magic footnote label. */\n    {\n      char saved = node->contents[node->nodelen];\n      node->contents[node->nodelen] = '\\0';\n      fnptr = strstr (node->contents, FOOTNOTE_LABEL);\n      node->contents[node->nodelen] = saved;\n    }\n  if (fnptr)\n    fn_start = fnptr - node->contents;\n\n  /* If it doesn't, check to see if it has an associated footnotes node. */\n  if (!fnptr)\n    {\n      REFERENCE **refs;\n\n      refs = node->references;\n\n      if (refs)\n        {\n          register int i;\n          char *refname;\n          int reflen = strlen (\"-Footnotes\") + strlen (node->nodename);\n\n          refname = xmalloc (reflen + 1);\n\n          strcpy (refname, node->nodename);\n          strcat (refname, \"-Footnotes\");\n\n          for (i = 0; refs[i]; i++)\n            if (refs[i]->type == REFERENCE_XREF\n                && (refs[i]->nodename != NULL)\n                /* Support both the older \"foo-Footnotes\" and the new\n                   style \"foo-Footnote-NN\" references.  */\n                && (strcmp (refs[i]->nodename, refname) == 0 ||\n                 (strncmp (refs[i]->nodename, refname, reflen - 1) == 0 &&\n                  refs[i]->nodename[reflen - 1] == '-' &&\n                  isdigit (refs[i]->nodename[reflen]))))\n              {\n                footnotes_node = info_get_node (node->fullpath, refname);\n                if (footnotes_node)\n                  {\n                    fn_node = footnotes_node;\n                    fn_start = 0;\n                  }\n                break;\n              }\n\n          free (refname);\n        }\n    }\n\n  /* If we never found the start of a footnotes area, quit now. */\n  if (fn_start == -1)\n    return NULL;\n\n  /* Make the new node. */\n  result = info_create_node ();\n\n  /* Get the size of the footnotes appearing within this node. */\n  {\n    char *header;\n    long text_start = fn_start;\n\n    asprintf (&header,\n              \"*** Footnotes appearing in the node '%s' ***\\n\",\n              node->nodename);\n\n    /* Move the start of the displayed text to right after the first line.\n       This effectively skips either \"---- footno...\", or \"File: foo...\". */\n    while (text_start < fn_node->nodelen)\n      if (fn_node->contents[text_start++] == '\\n')\n        break;\n  \n    result->nodelen = strlen (header) + fn_node->nodelen - text_start;\n\n    /* Set the contents of this node. */\n    result->contents = xmalloc (1 + result->nodelen);\n    sprintf (result->contents, \"%s\", header);\n    memcpy (result->contents + strlen (header),\n            fn_node->contents + text_start, fn_node->nodelen - text_start);\n    result->contents[strlen (header) + fn_node->nodelen - text_start] = '\\0';\n\n   /* Copy and adjust references that appear in footnotes section. */\n    {\n      REFERENCE **ref = fn_node->references;\n\n      for (; *ref; ref++)\n        {\n          if ((*ref)->start > text_start)\n            break;\n        }\n\n      result->references = info_copy_references (ref);\n\n      for (ref = result->references; *ref; ref++)\n        {\n          (*ref)->start -= text_start - strlen (header);\n          (*ref)->end -= text_start - strlen (header);\n        }\n    }\n\n    result->nodename = xstrdup (footnote_nodename);\n    result->flags |= N_IsInternal | N_WasRewritten;\n\n    /* Needed in case the user follows a reference in the footnotes window. */\n    result->fullpath = fn_node->fullpath;\n    result->subfile = fn_node->subfile;\n\n    free (header);\n  }\n\n  free_history_node (footnotes_node);\n  return result;\n}",
      "lines": 125,
      "depth": 21,
      "decorators": [
        "NODE",
        "*\nmake_footnotes_node (NODE *node)",
        "*"
      ]
    },
    "info_get_or_remove_footnotes": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        246,
        1
      ],
      "content": "int\ninfo_get_or_remove_footnotes (WINDOW *window)\n{\n  WINDOW *fn_win;\n  NODE *new_footnotes = 0;\n\n  fn_win = find_footnotes_window ();\n\n  /* If we are in the footnotes window, change nothing. */\n  if (fn_win == window)\n    return FN_FOUND;\n\n  /* Don't display footnotes for the \"*\" node (entire contents of file) or\n     for nodes without a name like completion windows. */\n  if (window->node->nodename && strcmp (\"*\", window->node->nodename))\n    /* Try to find footnotes for this window's node. */\n    new_footnotes = make_footnotes_node (window->node);\n\n  if (!new_footnotes)\n    {\n      /* If there was a window showing footnotes, and there are no footnotes\n         for the current window, delete the old footnote window. */\n      if (fn_win && windows->next)\n        info_delete_window_internal (fn_win);\n      return FN_UNFOUND;\n    }\n\n  /* If there is no window around showing footnotes, try\n     to make a new window. */\n  if (!fn_win)\n    {\n      WINDOW *old_active;\n      WINDOW *last, *win;\n\n      /* Always make this window be the last one appearing in the list.  Find\n         the last window in the chain. */\n      for (win = windows, last = windows; win; last = win, win = win->next);\n\n      /* Try to split this window, and make the split window the one to\n         contain the footnotes. */\n      old_active = active_window;\n      active_window = last;\n      fn_win = window_make_window ();\n      active_window = old_active;\n\n      /* If we are hacking automatic footnotes, and there are footnotes\n         but we couldn't display them, print a message to that effect. */\n      if (!fn_win)\n        {\n          if (auto_footnotes_p)\n            info_error (_(\"Footnotes could not be displayed\"));\n          return FN_UNABLE;\n        }\n    }\n\n  /* Note that info_set_node_of_window calls this function\n     (info_get_or_remove_footnotes), but we do not recurse indefinitely\n     because we check if we are in the footnote window above. */\n  info_set_node_of_window (fn_win, new_footnotes);\n  fn_win->flags |= W_TempWindow;\n\n  /* Make the height be the number of lines appearing in the footnotes. */\n  if (new_footnotes)\n    window_change_window_height (fn_win, fn_win->line_count - fn_win->height);\n\n  return FN_FOUND;\n}",
      "lines": 67,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/info/footnotes.h": {},
  "texinfo/texinfo-6.5/info/indices.c": {
    "add_index_to_index_nodenames": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static void\nadd_index_to_index_nodenames (REFERENCE **array, NODE *node)\n{\n  register int i, last;\n  INDEX_NAME_ASSOC *assoc;\n\n  for (last = 0; array[last + 1]; last++);\n  assoc = xmalloc (sizeof (INDEX_NAME_ASSOC));\n  assoc->name = xstrdup (node->nodename);\n\n  if (!index_nodenames_index)\n    {\n      assoc->first = 0;\n      assoc->last = last;\n    }\n  else\n    {\n      for (i = 0; index_nodenames[i + 1]; i++);\n      assoc->first = 1 + index_nodenames[i]->last;\n      assoc->last = assoc->first + last;\n    }\n  add_pointer_to_array (assoc, index_nodenames_index, index_nodenames, \n                        index_nodenames_slots, 10);\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "info_indices_of_file_buffer": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "static void\ninfo_indices_of_file_buffer (FILE_BUFFER *file_buffer)\n{\n  register int i;\n  REFERENCE **result = NULL;\n\n  /* No file buffer, no indices. */\n  if (!file_buffer)\n    {\n      free (index_index);\n      index_index = 0;\n      return;\n    }\n\n  /* If the file is the same as the one that we last built an\n     index for, don't do anything. */\n  if (initial_index_filename\n      && FILENAME_CMP (initial_index_filename, file_buffer->filename) == 0)\n    {\n      return;\n    }\n\n  /* Display a message because finding the index entries might take a while. */\n  if (info_windows_initialized_p)\n    window_message_in_echo_area (_(\"Finding index entries...\"));\n\n  /* Reset globals describing where the index was found. */\n  free (initial_index_filename);\n  free (initial_index_nodename);\n  initial_index_filename = NULL;\n  initial_index_nodename = NULL;\n\n  if (index_nodenames)\n    {\n      for (i = 0; index_nodenames[i]; i++)\n        {\n          free (index_nodenames[i]->name);\n          free (index_nodenames[i]);\n        }\n\n      index_nodenames_index = 0;\n      index_nodenames[0] = NULL;\n    }\n\n  /* Grovel the names of the nodes found in this file. */\n  if (file_buffer->tags)\n    {\n      TAG *tag;\n\n      for (i = 0; (tag = file_buffer->tags[i]); i++)\n        {\n          if (strcasestr (tag->nodename, \"Index\")\n              && tag->cache.nodelen != 0) /* Not an anchor. */\n            {\n              NODE *node;\n              REFERENCE **menu;\n\n              node = info_node_of_tag (file_buffer, &file_buffer->tags[i]);\n\n              if (!node)\n                continue;\n\n              if (!initial_index_filename)\n                {\n                  /* Remember the filename and nodename of this index. */\n                  initial_index_filename = xstrdup (file_buffer->filename);\n                  initial_index_nodename = xstrdup (tag->nodename);\n                }\n\n              menu = node->references;\n\n              /* If we have a non-empty menu, add this index's nodename\n                 and range to our list of index_nodenames. */\n              if (menu && menu[0])\n                {\n                  add_index_to_index_nodenames (menu, node);\n\n                  /* Concatenate the references found so far. */\n                  {\n                  REFERENCE **old_result = result;\n                  result = info_concatenate_references (result, menu);\n                  free (old_result);\n                  }\n                }\n              free_history_node (node);\n            }\n        }\n    }\n\n  /* If there is a result, clean it up so that every entry has a filename. */\n  for (i = 0; result && result[i]; i++)\n    if (!result[i]->filename)\n      result[i]->filename = xstrdup (file_buffer->filename);\n\n  free (index_index);\n  index_index = result;\n\n  if (info_windows_initialized_p)\n    window_clear_echo_area ();\n}",
      "lines": 100,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "index_entry_matches": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        293,
        1
      ],
      "content": "static int\nindex_entry_matches (REFERENCE *ent, const char *str, size_t len)\n{\n  char *p;\n  \n  if (strncmp (ent->label, str, len))\n    return 0;\n  p = ent->label + len;\n  if (!*p)\n    return 1;\n  if (p[0] == ' ' && p[1] == '<')\n    {\n      for (p += 2; *p; p++)\n\t{\n\t  if (p[0] == '>' && p[1] == 0)\n\t    return 1;\n\t  else if (!isdigit (*p))\n\t    return 0;\n\t}\n    }\n  return 0;\n}",
      "lines": 22,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "next_index_match": {
      "start_point": [
        306,
        0
      ],
      "end_point": [
        394,
        1
      ],
      "content": "REFERENCE *\nnext_index_match (FILE_BUFFER *fb, char *string, int offset, int dir,\n                  int *found_offset, int *match_offset)\n{\n  int i;\n  int partial_match;\n  size_t search_len;\n  REFERENCE *result;\n\n  partial_match = 0;\n  search_len = strlen (string);\n\n  info_indices_of_file_buffer (fb); /* Sets index_index. */\n  if (!index_index)\n    {\n      info_error (_(\"No indices found.\"));\n      return 0;\n    }\n\n  if (index_search != string)\n    {\n      free (index_search); index_search = string;\n    }\n\n  if (!index_initial && !index_partial)\n    {\n      /* First try to find an exact match. */\n      for (i = offset + dir; i > -1 && index_index[i]; i += dir)\n        if (index_entry_matches (index_index[i], string, search_len))\n          {\n            *match_offset = 0;\n            break;\n          }\n\n      if (i < 0 || !index_index[i])\n\t{\n          offset = 0;\n          index_initial = 1;\n\t}\n    }\n\n  if (index_initial)\n    {\n      for (i = offset + dir; i > -1 && index_index[i]; i += dir)\n        if (!index_entry_matches (index_index[i], string, search_len)\n            && !strncmp (index_index[i]->label, string, search_len))\n          {\n            *match_offset = search_len;\n            break;\n          }\n\n      if (i < 0 || !index_index[i])\n\t{\n          offset = 0;\n          index_initial = 0;\n          index_partial = 1;\n\t}\n    }\n\n  if (index_partial)\n    {\n      /* Look for substrings, excluding case-matching inital matches. */\n      for (i = offset + dir; i > -1 && index_index[i]; i += dir)\n        {\n          if (strncmp (index_index[i]->label, string, search_len) != 0)\n            {\n              partial_match = string_in_line (string, index_index[i]->label);\n              if (partial_match != -1)\n                {\n                  *match_offset = partial_match;\n                  break;\n                }\n            }\n        }\n      if (partial_match <= 0)\n        index_partial = 0;\n    }\n\n  if (i < 0 || !index_index[i])\n    result = 0;\n  else\n    {\n      index_offset = i;\n      result = index_index[i];\n    }\n\n  *found_offset = i;\n  return result;\n}",
      "lines": 89,
      "depth": 15,
      "decorators": [
        "REFERENCE",
        "*\nnext_index_match (FILE_BUFFER *fb, char *string, int offset, int dir,\n                  int *found_offset, int *match_offset)",
        "*"
      ]
    },
    "report_index_match": {
      "start_point": [
        397,
        0
      ],
      "end_point": [
        444,
        1
      ],
      "content": "void\nreport_index_match (int i, int match_offset)\n{\n  register int j;\n  const char *name = \"CAN'T SEE THIS\";\n  char *match;\n\n  for (j = 0; index_nodenames[j]; j++)\n    {\n      if ((i >= index_nodenames[j]->first) &&\n          (i <= index_nodenames[j]->last))\n        {\n          name = index_nodenames[j]->name;\n          break;\n        }\n    }\n\n  /* If we had a partial match, indicate to the user which part of the\n     string matched. */\n  match = xstrdup (index_index[i]->label);\n\n  if (match_offset > 0 && show_index_match)\n    {\n      int k, ls, start, upper;\n\n      ls = strlen (index_search);\n      start = match_offset - ls;\n      upper = isupper (match[start]) ? 1 : 0;\n\n      for (k = 0; k < ls; k++)\n        if (upper)\n          match[k + start] = tolower (match[k + start]);\n        else\n          match[k + start] = toupper (match[k + start]);\n    }\n\n    {\n      char *format;\n\n      format = replace_in_documentation\n        (_(\"Found '%s' in %s. ('\\\\[next-index-match]' tries to find next.)\"),\n         0);\n\n      window_message_in_echo_area (format, match, (char *) name);\n    }\n\n  free (match);\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "look_in_indices": {
      "start_point": [
        494,
        0
      ],
      "end_point": [
        524,
        1
      ],
      "content": "REFERENCE *\nlook_in_indices (FILE_BUFFER *fb, char *string, int sloppy)\n{\n  REFERENCE **index_ptr;\n  REFERENCE *nearest = 0;\n\n  /* Remember the search string so we can use it as the default for \n     'virtual-index' or 'next-index-match'. */\n  free (index_search);\n  index_search = xstrdup (string);\n\n  info_indices_of_file_buffer (fb); /* Sets index_index. */\n  if (!index_index)\n    return 0;\n\n  for (index_ptr = index_index; *index_ptr; index_ptr++)\n    {\n      if (!strcmp (string, (*index_ptr)->label))\n        {\n          nearest = *index_ptr;\n          break;\n        }\n      /* Case-insensitive initial substring. */\n      if (sloppy && !nearest && !mbsncasecmp (string, (*index_ptr)->label,\n                                    mbslen (string)))\n        {\n          nearest = *index_ptr;\n        }\n    }\n  return nearest;\n}",
      "lines": 31,
      "depth": 14,
      "decorators": [
        "REFERENCE",
        "*\nlook_in_indices (FILE_BUFFER *fb, char *string, int sloppy)",
        "*"
      ]
    },
    "apropos_in_all_indices": {
      "start_point": [
        534,
        0
      ],
      "end_point": [
        642,
        1
      ],
      "content": "REFERENCE **\napropos_in_all_indices (char *search_string, int inform)\n{\n  size_t i, dir_index;\n  REFERENCE **all_indices = NULL;\n  REFERENCE **dir_menu = NULL;\n  NODE *dir_node;\n\n  dir_node = get_dir_node ();\n\n  /* It should be safe to assume that dir nodes do not contain any\n     cross-references, i.e., its references list only contains\n     menu items. */\n  if (dir_node)\n    dir_menu = dir_node->references;\n\n  if (!dir_menu)\n    {\n      free (dir_node);\n      return NULL;\n    }\n\n  /* For every menu item in DIR, get the associated file buffer and\n     read the indices of that file buffer.  Gather all of the indices into\n     one large one. */\n  for (dir_index = 0; dir_menu[dir_index]; dir_index++)\n    {\n      REFERENCE **this_index, *this_item;\n      FILE_BUFFER *this_fb, *loaded_file = 0;\n\n      this_item = dir_menu[dir_index];\n      if (!this_item->filename)\n        continue;\n\n      /* If we already scanned this file, don't do that again.\n         In addition to being faster, this also avoids having\n         multiple identical entries in the *Apropos* menu.  */\n      for (i = 0; i < dir_index; i++)\n        if (dir_menu[i]->filename\n            && FILENAME_CMP (this_item->filename, dir_menu[i]->filename) == 0)\n          break;\n      if (i < dir_index)\n        continue;\n\n      this_fb = check_loaded_file (this_item->filename);\n\n      if (!this_fb)\n        this_fb = loaded_file = info_find_file (this_item->filename);\n\n      if (!this_fb)\n        continue; /* Couldn't load file. */\n\n      if (this_fb && inform)\n        message_in_echo_area (_(\"Scanning indices of '%s'...\"), this_item->filename);\n\n      info_indices_of_file_buffer (this_fb);\n      this_index = index_index;\n\n      if (this_fb && inform)\n        unmessage_in_echo_area ();\n\n      if (this_index)\n        {\n          /* Remember the filename which contains this set of references. */\n          for (i = 0; this_index && this_index[i]; i++)\n            if (!this_index[i]->filename)\n              this_index[i]->filename = xstrdup (this_fb->filename);\n\n          /* Concatenate with the other indices.  */\n          {\n          REFERENCE **old_indices = all_indices;\n          all_indices = info_concatenate_references (all_indices, this_index);\n          free (old_indices);\n          }\n        }\n\n      /* Try to avoid running out of memory by not loading all of the\n         Info files on the system into memory.  This is risky because we\n         may have a pointer into the file buffer, so only free the contents\n         if we have just loaded the file. */\n      if (loaded_file)\n        {\n          free (loaded_file->contents);\n          loaded_file->contents = NULL;\n        }\n    }\n\n  /* Build a list of the references which contain SEARCH_STRING. */\n  if (all_indices)\n    {\n      REFERENCE *entry, **apropos_list = NULL;\n      size_t apropos_list_index = 0;\n      size_t apropos_list_slots = 0;\n\n      for (i = 0; (entry = all_indices[i]); i++)\n        {\n          if (string_in_line (search_string, entry->label) != -1)\n            {\n              add_pointer_to_array (entry, apropos_list_index, apropos_list, \n                                    apropos_list_slots, 100);\n            }\n        }\n\n      free (all_indices);\n      all_indices = apropos_list;\n    }\n  free (dir_node);\n  return all_indices;\n}",
      "lines": 109,
      "depth": 14,
      "decorators": [
        "REFERENCE",
        "**\napropos_in_all_indices (char *search_string, int inform)",
        "*",
        "*\napropos_in_all_indices (char *search_string, int inform)",
        "*"
      ]
    },
    "format_reference": {
      "start_point": [
        783,
        0
      ],
      "end_point": [
        805,
        1
      ],
      "content": "static void\nformat_reference (REFERENCE *ref, const char *filename, struct text_buffer *buf)\n{\n  size_t n;\n  \n  n = text_buffer_printf (buf, \"* %s: \", ref->label);\n  if (n < NODECOL)\n    n += text_buffer_fill (buf, ' ', NODECOL - n);\n  \n  if (ref->filename && strcmp (ref->filename, filename))\n    n += text_buffer_printf (buf, \"(%s)\", ref->filename);\n  n += text_buffer_printf (buf, \"%s. \", ref->nodename);\n\n  if (n < LINECOL)\n    n += text_buffer_fill (buf, ' ', LINECOL - n);\n  else\n    {\n      text_buffer_add_char (buf, '\\n');\n      text_buffer_fill (buf, ' ', LINECOL);\n    }\n  \n  text_buffer_printf (buf, \"(line %4d)\\n\", ref->line_number);\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_virtual_index": {
      "start_point": [
        807,
        0
      ],
      "end_point": [
        863,
        1
      ],
      "content": "NODE *\ncreate_virtual_index (FILE_BUFFER *file_buffer, char *index_search)\n{\n  struct text_buffer text;\n  int i;\n  size_t cnt;\n  NODE *node;\n\n  text_buffer_init (&text);\n  text_buffer_printf (&text,\n                      \"File: %s,  Node: Index for '%s'\\n\\n\",\n                      file_buffer->filename, index_search);\n  text_buffer_printf (&text, _(\"Virtual Index\\n\"\n                               \"*************\\n\\n\"\n                               \"Index entries that match '%s':\\n\"),\n                      index_search);\n  text_buffer_add_string (&text, \"\\0\\b[index\\0\\b]\", 11);\n  text_buffer_printf (&text, \"\\n* Menu:\\n\\n\");\n\n  cnt = 0;\n\n  index_offset = 0;\n  index_initial = 0;\n  index_partial = 0;\n  while (1)\n    {\n      REFERENCE *result;\n      int match_offset;\n\n      result = next_index_match (file_buffer, index_search, index_offset, 1,\n                                 &i, &match_offset);\n      if (!result)\n        break;\n      format_reference (index_index[i],\n                        file_buffer->filename, &text);\n      cnt++;\n    }\n  text_buffer_add_char (&text, '\\0');\n\n  if (cnt == 0)\n    {\n      text_buffer_free (&text);\n      return 0;\n    }\n\n  node = info_create_node ();\n  asprintf (&node->nodename, \"Index for '%s'\", index_search);\n  node->fullpath = file_buffer->filename;\n  node->contents = text_buffer_base (&text);\n  node->nodelen = text_buffer_off (&text) - 1;\n  node->body_start = strcspn (node->contents, \"\\n\");\n  node->flags |= N_IsInternal | N_WasRewritten;\n\n  scan_node_contents (node, 0, 0);\n\n  return node;\n}",
      "lines": 57,
      "depth": 10,
      "decorators": [
        "NODE",
        "*\ncreate_virtual_index (FILE_BUFFER *file_buffer, char *index_search)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/info/indices.h": {},
  "texinfo/texinfo-6.5/info/info-utils.c": {
    "read_bracketed_filename": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "int\nread_bracketed_filename (char *string, char **filename)\n{\n  register int i = 0;\n  int count = 0; /* Level of nesting. */\n  int first_close = -1; /* First \")\" encountered. */\n\n  if (*string != '(')\n    return 0;\n\n  string++;\n  count = 1;\n  for (i = 0; string[i]; i++)\n    {\n      if (string[i] == '(')\n        count++;\n      else if (string[i] == ')')\n        {\n          if (first_close == -1)\n            first_close = i;\n\n          count--;\n          if (count == 0)\n            break;\n        } \n    }\n  \n  /* If string ended before brackets were balanced, take the first \")\" as\n     terminating the filename. */\n  if (count > 0)\n    {\n      if (first_close == -1)\n        {\n          if (filename)\n            *filename = 0;\n          return 0;\n        }\n      i = first_close;\n    }\n\n  if (filename)\n    {\n      *filename = xcalloc (1, i + 1);\n      memcpy (*filename, string, i);\n    }\n\n  return i + 2; /* Length of filename plus \"(\" and \")\". */\n}",
      "lines": 48,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "info_parse_node": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "void\ninfo_parse_node (char *string)\n{\n  int nodename_len;\n\n  free (info_parsed_filename);\n  free (info_parsed_nodename);\n  info_parsed_filename = 0;\n  info_parsed_nodename = 0;\n\n  /* Special case of nothing passed.  Return nothing. */\n  if (!string || !*string)\n    return;\n\n  string += skip_whitespace_and_newlines (string);\n\n  string += read_bracketed_filename (string, &info_parsed_filename);\n\n  /* Parse out nodename. */\n  string += skip_whitespace_and_newlines (string);\n  nodename_len = read_quoted_string (string, \"\", 0, &info_parsed_nodename);\n\n  if (nodename_len != 0)\n    {\n      canonicalize_whitespace (info_parsed_nodename);\n    }\n}",
      "lines": 27,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "read_quoted_string": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "long\nread_quoted_string (char *start, char *terminator, int lines, char **output)\n{\n  long len;\n  char *nl = 0, saved_char;\n\n  if (lines)\n    {\n      int i;\n      nl = start;\n      for (i = 0; i < lines; i++)\n        {\n          nl = strchr (nl, '\\n');\n          if (!nl)\n            break; /* End of input string reached. */\n          nl++;\n        }\n      if (nl)\n        {\n          saved_char = *nl;\n          *nl = '\\0';\n        }\n    }\n\n  if (start[0] != '\\177')\n    {\n      len = strcspn (start, terminator);\n\n      if (*terminator && !start[len])\n        {\n          len = 0;\n          *output = 0;\n        }\n      else\n        {\n          *output = xmalloc (len + 1);\n          strncpy (*output, start, len);\n          (*output)[len] = '\\0';\n        }\n    }\n  else\n    {\n      len = strcspn (start + 1, \"\\177\");\n\n      if (*terminator && !(start + 1)[len])\n        {\n          /* No closing 177 byte. */\n          len = 0;\n          *output = 0;\n        }\n      else\n        {\n          *output = xmalloc (len + 1);\n          strncpy (*output, start + 1, len);\n          (*output)[len] = '\\0';\n          len += 2; /* Count the two 177 bytes. */\n        }\n\n    }\n\n  if (nl)\n    *nl = saved_char;\n  return len;\n}",
      "lines": 64,
      "depth": 12,
      "decorators": [
        "long",
        "long"
      ]
    },
    "info_get_menu_entry_by_label": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        246,
        1
      ],
      "content": "REFERENCE *\ninfo_get_menu_entry_by_label (NODE *node, char *label, int sloppy) \n{\n  register int i;\n  int best_guess = -1;\n  REFERENCE *entry;\n  REFERENCE **references = node->references;\n\n  if (!references)\n    return 0;\n\n  for (i = 0; (entry = references[i]); i++)\n    {\n      if (entry->type != REFERENCE_MENU_ITEM)\n        continue;\n      if (mbscasecmp (label, entry->label) == 0)\n        return entry; /* Exact, case-insensitive match. */\n      else if (sloppy && best_guess == -1\n               && (mbsncasecmp (entry->label, label, strlen (label)) == 0))\n        best_guess = i;\n    }\n\n  if (sloppy && best_guess != -1)\n    return references[best_guess];\n\n  return 0;\n}",
      "lines": 27,
      "depth": 15,
      "decorators": [
        "REFERENCE",
        "*\ninfo_get_menu_entry_by_label (NODE *node, char *label, int sloppy)",
        "*"
      ]
    },
    "info_concatenate_references": {
      "start_point": [
        250,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "REFERENCE **\ninfo_concatenate_references (REFERENCE **ref1, REFERENCE **ref2)\n{\n  register int i, j;\n  REFERENCE **result;\n  int size = 0;\n\n  /* Get the total size of the slots that we will need. */\n  if (ref1)\n    {\n      for (i = 0; ref1[i]; i++);\n      size += i;\n    }\n\n  if (ref2)\n    {\n      for (i = 0; ref2[i]; i++);\n      size += i;\n    }\n\n  result = xmalloc ((1 + size) * sizeof (REFERENCE *));\n\n  /* Copy the contents over. */\n\n  j = 0;\n  if (ref1)\n    {\n      for (i = 0; ref1[i]; i++)\n        result[j++] = ref1[i];\n    }\n\n  if (ref2)\n    {\n      for (i = 0; ref2[i]; i++)\n        result[j++] = ref2[i];\n    }\n\n  result[j] = NULL;\n  return result;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "REFERENCE",
        "**\ninfo_concatenate_references (REFERENCE **ref1, REFERENCE **ref2)",
        "*",
        "*\ninfo_concatenate_references (REFERENCE **ref1, REFERENCE **ref2)",
        "*"
      ]
    },
    "info_copy_reference": {
      "start_point": [
        292,
        0
      ],
      "end_point": [
        305,
        1
      ],
      "content": "REFERENCE *\ninfo_copy_reference (REFERENCE *src)\n{\n  REFERENCE *dest = xmalloc (sizeof (REFERENCE));\n  dest->label = src->label ? xstrdup (src->label) : NULL;\n  dest->filename = src->filename ? xstrdup (src->filename) : NULL;\n  dest->nodename = src->nodename ? xstrdup (src->nodename) : NULL;\n  dest->start = src->start;\n  dest->end = src->end;\n  dest->line_number = src->line_number;\n  dest->type = src->type;\n  \n  return dest;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "REFERENCE",
        "*\ninfo_copy_reference (REFERENCE *src)",
        "*"
      ]
    },
    "info_copy_references": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        331,
        1
      ],
      "content": "REFERENCE **\ninfo_copy_references (REFERENCE **ref1)\n{\n  int i;\n  REFERENCE **result;\n  int size;\n\n  if (!ref1)\n    return 0;\n\n  /* Get the total size of the slots that we will need. */\n  for (i = 0; ref1[i]; i++);\n  size = i;\n\n  result = xmalloc ((1 + size) * sizeof (REFERENCE *));\n\n  /* Copy the contents over. */\n  for (i = 0; ref1[i]; i++)\n    result[i] = info_copy_reference (ref1[i]);\n  result[i] = NULL;\n\n  return result;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "REFERENCE",
        "**\ninfo_copy_references (REFERENCE **ref1)",
        "*",
        "*\ninfo_copy_references (REFERENCE **ref1)",
        "*"
      ]
    },
    "info_reference_free": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        343,
        1
      ],
      "content": "void\ninfo_reference_free (REFERENCE *ref)\n{\n  if (ref)\n    {\n      free (ref->label);\n      free (ref->filename);\n      free (ref->nodename);\n      free (ref);\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "info_free_references": {
      "start_point": [
        346,
        0
      ],
      "end_point": [
        359,
        1
      ],
      "content": "void\ninfo_free_references (REFERENCE **references)\n{\n  register int i;\n  REFERENCE *entry;\n\n  if (references)\n    {\n      for (i = 0; references && (entry = references[i]); i++)\n        info_reference_free (entry);\n\n      free (references);\n    }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "info_new_reference": {
      "start_point": [
        362,
        0
      ],
      "end_point": [
        374,
        1
      ],
      "content": "REFERENCE *\ninfo_new_reference (char *filename, char *nodename)\n{\n  REFERENCE *r = xmalloc (sizeof (REFERENCE));\n  r->label = 0;\n  r->filename = filename ? xstrdup (filename) : 0;\n  r->nodename = nodename ? xstrdup (nodename) : 0;\n  r->start = 0;\n  r->end = 0;\n  r->line_number = 0;\n  r->type = 0;\n  return r;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "REFERENCE",
        "*\ninfo_new_reference (char *filename, char *nodename)",
        "*"
      ]
    },
    "canonicalize_whitespace": {
      "start_point": [
        380,
        0
      ],
      "end_point": [
        427,
        1
      ],
      "content": "void\ncanonicalize_whitespace (char *string)\n{\n  register int i, j;\n  int len, whitespace_found, whitespace_loc = 0;\n  char *temp;\n\n  if (!string)\n    return;\n\n  len = strlen (string);\n  temp = xmalloc (1 + len);\n\n  /* Search for sequences of whitespace or newlines.  Replace all such\n     sequences in the string with just a single space. */\n\n  whitespace_found = 0;\n  for (i = 0, j = 0; string[i]; i++)\n    {\n      if (whitespace_or_newline (string[i]))\n        {\n          whitespace_found++;\n          whitespace_loc = i;\n          continue;\n        }\n      else\n        {\n          if (whitespace_found && whitespace_loc)\n            {\n              whitespace_found = 0;\n\n              /* Suppress whitespace at start of string. */\n              if (j)\n                temp[j++] = ' ';\n            }\n\n          temp[j++] = string[i];\n        }\n    }\n\n  /* Kill trailing whitespace. */\n  if (j && whitespace (temp[j - 1]))\n    j--;\n\n  temp[j] = '\\0';\n  strcpy (string, temp);\n  free (temp);\n}",
      "lines": 48,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "ansi_escape": {
      "start_point": [
        433,
        0
      ],
      "end_point": [
        467,
        1
      ],
      "content": "int\nansi_escape (mbi_iterator_t iter, size_t *plen)\n{\n  if (raw_escapes_p && *mbi_cur_ptr (iter) == '\\033' && mbi_avail (iter))\n    {\n      mbi_advance (iter);\n      if (*mbi_cur_ptr (iter) == '[' &&  mbi_avail (iter))\n        {\n          ITER_SETBYTES (iter, 1);\n          mbi_advance (iter);\n          if (isdigit (*mbi_cur_ptr (iter)) && mbi_avail (iter))\n            {\t\n              ITER_SETBYTES (iter, 1);\n              mbi_advance (iter);\n              if (*mbi_cur_ptr (iter) == 'm')\n                {\n                  *plen = 4;\n                  return 1;\n                }\n              else if (isdigit (*mbi_cur_ptr (iter)) && mbi_avail (iter))\n                {\n                  ITER_SETBYTES (iter, 1);\n                  mbi_advance (iter);\n                  if (*mbi_cur_ptr (iter) == 'm')\n                    {\n                      *plen = 5;\n                      return 1;\n                    }\n                }\n            }\n        }\n    }\n                \n  return 0;\n}",
      "lines": 35,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "printed_representation": {
      "start_point": [
        480,
        0
      ],
      "end_point": [
        567,
        1
      ],
      "content": "char *\nprinted_representation (mbi_iterator_t *iter, int *delim, size_t pl_chars,\n                        size_t *pchars, size_t *pbytes) \n{\n  struct text_buffer *rep = &printed_rep;\n\n  char *cur_ptr = (char *) mbi_cur_ptr (*iter);\n  size_t cur_len = mb_len (mbi_cur (*iter));\n\n  text_buffer_reset (&printed_rep);\n\n  if (mb_isprint (mbi_cur (*iter)))\n    {\n      /* cur.wc gives a wchar_t object.  See mbiter.h in the\n         gnulib/lib directory. */\n      *pchars = wcwidth ((*iter).cur.wc);\n      *pbytes = cur_len;\n      return cur_ptr;\n    }\n  else if (cur_len == 1)\n    {\n      if (*cur_ptr == '\\n' || *cur_ptr == '\\r')\n        {\n          /* If this is a CRLF line ending, ignore this character. */\n          if (*cur_ptr == '\\r' && cur_ptr[1] == '\\n')\n            {\n              *pchars = 0;\n              *pbytes = 0;\n              return cur_ptr;\n            }\n\n          *pchars = 1;\n          *pbytes = cur_len;\n          *delim = *cur_ptr;\n          text_buffer_add_char (rep, ' ');\n          return cur_ptr;\n        }\n      else if (ansi_escape (*iter, &cur_len))\n        {\n          *pchars = 0; \n          *pbytes = cur_len;\n          ITER_SETBYTES (*iter, cur_len);\n\n          return cur_ptr;\n        }\n      else if (*cur_ptr == '\\t')\n        {\n          int i = 0;\n\n          *pchars = ((pl_chars + 8) & 0xf8) - pl_chars;\n          *pbytes = *pchars;\n\n          /* We must output spaces instead of the tab because a tab may\n             not clear characters already on the screen. */\n          for (i = 0; i < *pbytes; i++)\n            text_buffer_add_char (rep, ' ');\n          return text_buffer_base (rep);\n        }\n    }\n\n  /* Show CTRL-x as \"^X\".  */\n  if (iscntrl (*cur_ptr) && *(unsigned char *)cur_ptr < 127)\n    {\n      *pchars = 2;\n      *pbytes = 2;\n      text_buffer_add_char (rep, '^');\n      text_buffer_add_char (rep, *cur_ptr | 0x40);\n      return text_buffer_base (rep);\n    }\n  else if (*cur_ptr == DEL)\n    {\n      *pchars = 0;\n      *pbytes = 0;\n      return text_buffer_base (rep);\n    }\n  else\n    {\n      /* Original byte was not recognized as anything.  Display its octal \n         value.  This could happen in the C locale for bytes above 128,\n         or for bytes 128-159 in an ISO-8859-1 locale.  Don't output the bytes \n         as they are, because they could have special meaning to the \n         terminal. */\n      *pchars = 4;\n      *pbytes = 4;\n      text_buffer_printf (rep, \"\\\\%o\", *(unsigned char *)cur_ptr);\n      return text_buffer_base (rep);\n    }\n}",
      "lines": 88,
      "depth": 17,
      "decorators": [
        "char",
        "*\nprinted_representation (mbi_iterator_t *iter, int *delim, size_t pl_chars,\n                        size_t *pchars, size_t *pbytes)",
        "*"
      ]
    },
    "init_conversion": {
      "start_point": [
        621,
        0
      ],
      "end_point": [
        673,
        1
      ],
      "content": "void\ninit_conversion (FILE_BUFFER *fb)\n{\n  char *target_encoding;\n\n  convert_encoding_p = 0;\n\n  /* Node being processed does not come from an Info file. */\n  if (!fb)\n    return;\n\n#if !HAVE_ICONV\n  return;\n#else\n  file_is_in_utf8 = 0;\n\n  /* Don't process file if encoding is unknown. */\n  if (!fb->encoding)\n    return;\n\n  /* Read name of character encoding from environment locale */\n  target_encoding = nl_langinfo (CODESET);\n\n  /* Don't convert the contents if the locale\n     uses the same character encoding as the file */\n  if (!strcasecmp(target_encoding, fb->encoding))\n    return;\n\n  /* Check if an iconv conversion from file locale to system\n     locale exists */\n  iconv_to_output = iconv_open (target_encoding, fb->encoding);\n  if (iconv_to_output == (iconv_t) -1)\n    return; /* Return if no conversion function implemented */\n\n  if (   !strcasecmp (\"UTF8\",  fb->encoding)\n      || !strcasecmp (\"UTF-8\", fb->encoding))\n    file_is_in_utf8 = 1;\n\n  if (!file_is_in_utf8)\n    {\n      iconv_to_utf8 = iconv_open (\"UTF-8\", fb->encoding);\n      if (iconv_to_utf8 == (iconv_t) -1)\n        {\n          /* Return if no conversion function implemented */\n          iconv_close (iconv_to_output);\n          return; \n        }\n    }\n\n  convert_encoding_p = 1;\n  rewrite_p = 1;\n#endif /* HAVE_ICONV */\n}",
      "lines": 53,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "close_conversion": {
      "start_point": [
        675,
        0
      ],
      "end_point": [
        684,
        1
      ],
      "content": "void close_conversion (void)\n{\n#if HAVE_ICONV\n  if (convert_encoding_p)\n    {\n      iconv_close (iconv_to_output);\n      if (!file_is_in_utf8) iconv_close (iconv_to_utf8);\n    }\n#endif\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "init_output_stream": {
      "start_point": [
        686,
        0
      ],
      "end_point": [
        694,
        1
      ],
      "content": "static void\ninit_output_stream (FILE_BUFFER *fb)\n{\n  init_conversion (fb);\n  output_bytes_difference = 0;\n\n  if (rewrite_p)\n    text_buffer_init (&output_buf);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "save_conversion_state": {
      "start_point": [
        700,
        0
      ],
      "end_point": [
        706,
        1
      ],
      "content": "void\nsave_conversion_state (void)\n{\n  saved_offset = text_buffer_off (&output_buf);\n  saved_inptr = inptr;\n  saved_difference = output_bytes_difference;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "reset_conversion": {
      "start_point": [
        709,
        0
      ],
      "end_point": [
        715,
        1
      ],
      "content": "void\nreset_conversion (void)\n{\n  text_buffer_off (&output_buf) = saved_offset;\n  inptr = saved_inptr;\n  output_bytes_difference = saved_difference;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "copy_direct": {
      "start_point": [
        718,
        0
      ],
      "end_point": [
        723,
        1
      ],
      "content": "static void\ncopy_direct (long n)\n{\n  text_buffer_add_string (&output_buf, inptr, n);\n  inptr += n;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "degrade_utf8": {
      "start_point": [
        728,
        0
      ],
      "end_point": [
        810,
        1
      ],
      "content": "static int\ndegrade_utf8 (char **from, size_t *from_left)\n{\n  static struct encoding_replacement\n  {\n    char *from_string;\n    char *to_string;\n  } er[] = {\n    {\"\\xE2\\x80\\x98\",\"'\"}, /* Opening single quote */\n    {\"\\xE2\\x80\\x99\",\"'\"}, /* Closing single quote */\n    {\"\\xE2\\x80\\x9C\",\"\\\"\"},/* Opening double quote */\n    {\"\\xE2\\x80\\x9D\",\"\\\"\"},/* Closing double quote */\n    {\"\\xC2\\xA9\",\"(C)\"},   /* Copyright symbol */\n    {\"\\xC2\\xBB\",\">>\"},    /* Closing double angle brackets */\n\n    {\"\\xE2\\x86\\x92\",\"->\"},/* Right arrow */\n    {\"\\xE2\\x87\\x92\",\"=>\"},/* Right double arrow */\n    {\"\\xE2\\x8A\\xA3\",\"-|\"},/* Print symbol */\n    {\"\\xE2\\x98\\x85\",\"-!-\"}, /* Point symbol */\n    {\"\\xE2\\x86\\xA6\",\"==>\"}, /* Expansion symbol */\n\n    {\"\\xE2\\x80\\x90\",\"-\"},  /* Hyphen */\n    {\"\\xE2\\x80\\x91\",\"-\"},  /* Non-breaking hyphen */\n    {\"\\xE2\\x80\\x92\",\"-\"},  /* Figure dash */\n    {\"\\xE2\\x80\\x93\",\"-\"},  /* En dash */\n    {\"\\xE2\\x80\\x94\",\"--\"},  /* Em dash */\n    {\"\\xE2\\x88\\x92\",\"-\"},  /* Minus sign */\n    {\"\\xE2\\x80\\xA6\",\"...\"},  /* Ellipsis */\n    {\"\\xE2\\x80\\xA2\",\"*\"},  /* Bullet */\n\n    {\"\\xC3\\xA0\",\"a`\"},   /* Lower case letter a with grave accent */\n    {\"\\xC3\\xA2\",\"a^\"},   /* Lower case letter a with circumflex */\n    {\"\\xC3\\xA4\",\"a\\\"\"},  /* Lower case letter a with diaeresis */\n    {\"\\xC3\\xA6\",\"ae\"},   /* Lower case letter ae ligature */\n    {\"\\xC3\\xA9\",\"e'\"},   /* Lower case letter e with acute accent */\n    {\"\\xC3\\xA8\",\"e`\"},   /* Lower case letter e with grave accent */\n    {\"\\xC3\\xAA\",\"e^\"},   /* Lower case letter e with circumflex */\n    {\"\\xC3\\xAB\",\"e\\\"\"},  /* Lower case letter e with diaeresis */\n    {\"\\xC3\\xB6\",\"o\\\"\"},  /* Lower case letter o with diaeresis */\n    {\"\\xC3\\xBC\",\"u\\\"\"},  /* Lower case letter u with diaeresis */\n    {\"\\xC3\\x84\", \"A\\\"\"},  /* Upper case letter A with diaeresis. */\n    {\"\\xC3\\x96\", \"O\\\"\"},  /* Upper case letter O with diaeresis. */\n    {\"\\xC3\\x9c\", \"U\\\"\"},  /* Upper case letter U with diaeresis. */\n\n    {\"\\xC3\\xB1\",\"n~\"},  /* Lower case letter n with tilde */\n    {\"\\xC3\\x87\",\"C,\"},  /* Upper case letter C with cedilla */\n    {\"\\xC3\\xA7\",\"c,\"},  /* Lower case letter c with cedilla */\n    {\"\\xC3\\x9f\",\"ss\"},  /* Lower case letter sharp s */\n\n    {0, 0}\n  };\n\n  struct encoding_replacement *erp;\n\n  for (erp = er; erp->from_string != 0; erp++)\n    {\n      /* Avoid reading past end of input. */\n      int width = strlen (erp->from_string);\n      if (width > *from_left)\n        continue;\n\n      if (!strncmp (erp->from_string, *from, width))\n        {\n          text_buffer_add_string (&output_buf, erp->to_string,\n                                  strlen(erp->to_string));\n          *from += width;\n          *from_left -= width;\n          return 1;\n        }\n    }\n\n  /* Failing this, just print a question mark.  Maybe we should use SUB\n     (^Z) (ASCII substitute character code) instead, or pass through the\n     original bytes. */\n  text_buffer_add_string (&output_buf, \"?\", 1);\n\n  /* Ideally we would advance one UTF-8 character.  This would\n     require knowing its length in bytes. */\n  (*from)++;\n  (*from_left)--;\n\n  return 0;\n}",
      "lines": 83,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "copy_converting": {
      "start_point": [
        814,
        0
      ],
      "end_point": [
        961,
        1
      ],
      "content": "static int\ncopy_converting (long n)\n{\n#if !HAVE_ICONV\n  return 0;\n#else\n  size_t bytes_left, orig_bytes_left;\n  int extra_at_end;\n  size_t iconv_ret;\n  long output_start;\n\n  size_t utf8_char_free; \n  char utf8_char[4]; /* Maximum 4 bytes in a UTF-8 character */\n  char *utf8_char_ptr, *orig_inptr;\n  size_t i;\n  \n  /* Use n as an estimate of how many bytes will be required\n     in target encoding. */\n  text_buffer_alloc (&output_buf, (size_t) n);\n\n  output_start = text_buffer_off (&output_buf);\n  bytes_left = n;\n  extra_at_end = 0;\n  while (1)\n    {\n      iconv_ret = text_buffer_iconv (&output_buf, iconv_to_output,\n                                     (ICONV_CONST char **)&inptr, &bytes_left);\n\n      /* Make sure libiconv flushes out the last converted character.\n\t This is required when the conversion is stateful, in which\n\t case libiconv might not output the last character, waiting to\n\t see whether it should be combined with the next one.  */\n      if (iconv_ret != (size_t) -1\n\t  && text_buffer_iconv (&output_buf, iconv_to_output,\n\t\t\t\tNULL, NULL) != (size_t) -1)\n        /* Success: all of input converted. */\n        break;\n\n      /* There's been an error while converting. */\n      switch (errno)\n        {\n        case E2BIG:\n          /* Ran out of space in output buffer.  Allocate more\n             and try again. */\n          text_buffer_alloc (&output_buf, n);\n          continue;\n        case EINVAL:\n          /* Incomplete byte sequence at end of input buffer.  Try to read\n             more. */\n\n          /* input_length - 2 is offset of last-but-one byte within input.\n             This checks if there is at least one more byte within node\n             contents. */\n          if (inptr - input_start + (bytes_left - 1) <= input_length - 2)\n            {\n              bytes_left++;\n              extra_at_end++;\n            }\n          else\n            {\n              copy_direct (bytes_left);\n              bytes_left = 0;\n            }\n          continue;\n        default: /* Unknown error */\n          info_error (_(\"Error converting file character encoding\"));\n\n          /* Skip past current input and hope we don't get an\n             error next time. */\n          inptr += bytes_left;\n          return 0;\n        case EILSEQ:\n          /* Byte sequence in input not recognized.  Degrade to ASCII.  */\n          break;\n        }\n\n      /* Flush any waiting input in iconv_to_output and enter the\n         default shift state. */\n      text_buffer_iconv (&output_buf, iconv_to_output, NULL, NULL);\n      \n      if (file_is_in_utf8)\n        {\n          degrade_utf8 (&inptr, &bytes_left);\n          continue;     \n        }\n\n      /* If file is not in UTF-8, we degrade to ASCII in two steps:\n         first convert the character to UTF-8, then look up a replacement\n         string.  Note that mixing iconv_to_output and iconv_to_utf8\n         on the same input may not work well if the input encoding\n         is stateful.  We could deal with this by always converting to\n         UTF-8 first; then we could mix conversions on the UTF-8 stream. */\n\n      /* We want to read exactly one character.  Do this by\n         restricting size of output buffer. */\n      utf8_char_ptr = utf8_char;\n      orig_inptr = inptr;\n      orig_bytes_left = bytes_left;\n      for (i = 1; i <= 4; i++)\n        {\n          utf8_char_free = i;\n          errno = 0;\n          iconv_ret = iconv (iconv_to_utf8, (ICONV_CONST char **)&inptr,\n                             &bytes_left, &utf8_char_ptr, &utf8_char_free);\n          if ((iconv_ret == (size_t) -1 && errno != E2BIG)\n              /* If we managed to convert a character: */\n              || utf8_char_ptr > utf8_char)\n            break;\n        }\n\n      /* errno == E2BIG if iconv ran out of output buffer,\n         which is expected. */\n      if (iconv_ret == (size_t) -1 && errno != E2BIG)\n\t{\n\t  /* Character is not recognized.  Copy a single byte.  */\n\t  inptr = orig_inptr;\t/* iconv might have incremented inptr  */\n\t  copy_direct (1);\n\t  bytes_left = orig_bytes_left - 1;\n\t}\n      else\n        {\n          utf8_char_ptr = utf8_char;\n          /* i is width of UTF-8 character */\n          degrade_utf8 (&utf8_char_ptr, &i);\n\t  /* If we are done, make sure iconv flushes the last character.  */\n\t  if (bytes_left <= 0)\n\t    {\n\t      utf8_char_ptr = utf8_char;\n\t      i = 4;\n\t      iconv (iconv_to_utf8, NULL, NULL,\n\t\t     &utf8_char_ptr, &utf8_char_free);\n\t      if (utf8_char_ptr > utf8_char)\n\t\t{\n\t\t  utf8_char_ptr = utf8_char;\n\t\t  degrade_utf8 (&utf8_char_ptr, &i);\n\t\t}\n\t    }\n        }\n    }\n\n  /* Must cast because the difference between unsigned size_t is always\n     positive. */\n  output_bytes_difference +=\n    n - ((signed long) text_buffer_off (&output_buf) - output_start);\n\n  return extra_at_end;\n#endif /* HAVE_ICONV */\n}",
      "lines": 148,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "copy_input_to_output": {
      "start_point": [
        968,
        0
      ],
      "end_point": [
        1039,
        1
      ],
      "content": "static void\ncopy_input_to_output (long n)\n{\n  if (rewrite_p)\n    {\n      long bytes_left;\n\n      bytes_left = n;\n      while (bytes_left > 0)\n        {\n          if (!convert_encoding_p)\n            {\n              copy_direct (bytes_left);\n              bytes_left = 0;\n            }\n          else\n            {\n              long bytes_to_convert;\n              long extra_written;\n\n              bytes_to_convert = bytes_left;\n\n              if (anchor_to_adjust)\n                {\n                  char *first_anchor = input_start\n                             + (*anchor_to_adjust)->nodestart - node_offset;\n\n                  /* If there is an anchor in the input: */\n                  if (first_anchor < inptr + bytes_left)\n                    {\n                      /* Convert enough to pass the first anchor in input. */\n                      bytes_to_convert = first_anchor - inptr + 1;\n\n                      /* Shouldn't happen because we should have already\n                         have adjusted this anchor. */\n                      if (bytes_to_convert < 0)\n                        {\n                          anchor_to_adjust = 0; /* Abandon anchor adjustment.*/\n                          bytes_to_convert = bytes_left;\n                        }\n                    }\n                }\n\n              /* copy_converting may read more than bytes_to_convert\n                 bytes if its input ends in an incomplete byte sequence. */\n              extra_written = copy_converting (bytes_to_convert);\n\n              bytes_left -= bytes_to_convert + extra_written;\n            }\n\n          /* Check if we have gone past any anchors and\n             adjust with output_bytes_difference. */\n          if (anchor_to_adjust)\n            while ((*anchor_to_adjust)->nodestart - node_offset\n                   <= inptr - input_start)\n              {\n                (*anchor_to_adjust)->nodestart_adjusted\n                   = (*anchor_to_adjust)->nodestart - output_bytes_difference;\n\n                anchor_to_adjust++;\n                if (!*anchor_to_adjust\n                    || (*anchor_to_adjust)->cache.nodelen != 0)\n                  {\n                    anchor_to_adjust = 0;\n                    break;\n                  }\n              }\n        }\n    }\n  else\n    inptr += n;\n}",
      "lines": 72,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "skip_input": {
      "start_point": [
        1041,
        0
      ],
      "end_point": [
        1058,
        1
      ],
      "content": "static void\nskip_input (long n)\n{\n  if (preprocess_nodes_p)\n    {\n      inptr += n;\n      output_bytes_difference += n;\n    }\n  else if (rewrite_p)\n    {\n      /* We are expanding tags only.  Do not skip input. */\n      copy_input_to_output (n);\n    }\n  else\n    {\n      inptr += n;\n    }\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "write_extra_bytes_to_output": {
      "start_point": [
        1060,
        0
      ],
      "end_point": [
        1068,
        1
      ],
      "content": "static void\nwrite_extra_bytes_to_output (char *input, long n)\n{\n  if (preprocess_nodes_p)\n    {\n      text_buffer_add_string (&output_buf, input, n);\n      output_bytes_difference -= n;\n    }\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "write_tag_contents": {
      "start_point": [
        1072,
        0
      ],
      "end_point": [
        1080,
        1
      ],
      "content": "static void\nwrite_tag_contents (char *input, long n)\n{\n  if (rewrite_p)\n    {\n      text_buffer_add_string (&output_buf, input, n);\n      output_bytes_difference -= n;\n    }\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "skip_tag_contents": {
      "start_point": [
        1083,
        0
      ],
      "end_point": [
        1091,
        1
      ],
      "content": "static void\nskip_tag_contents (long n)\n{\n  if (rewrite_p)\n    {\n      inptr += n;\n      output_bytes_difference += n;\n    }\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_top_node_line": {
      "start_point": [
        1094,
        0
      ],
      "end_point": [
        1179,
        1
      ],
      "content": "static void\nparse_top_node_line (NODE *node)\n{\n  char **store_in = 0;\n  char *nodename;\n  char *ptr;\n  int value_length;\n\n  /* If the first line is empty, leave it in.  This is the case\n     in the index-apropos window. */\n  if (*node->contents == '\\n')\n    return;\n\n  node->next = node->prev = node->up = 0;\n  ptr = node->contents;\n\n  while (1)\n    {\n      store_in = 0;\n\n      ptr += skip_whitespace (ptr);\n\n      /* Check what field we are looking at */\n      if (!strncasecmp (ptr, INFO_FILE_LABEL, strlen(INFO_FILE_LABEL)))\n        {\n          ptr += strlen (INFO_FILE_LABEL);\n        }\n      else if (!strncasecmp (ptr, INFO_NODE_LABEL, strlen(INFO_NODE_LABEL)))\n        {\n          ptr += strlen (INFO_NODE_LABEL);\n        }\n      else if (!strncasecmp (ptr, INFO_PREV_LABEL, strlen(INFO_PREV_LABEL)))\n        {\n          ptr += strlen (INFO_PREV_LABEL);\n          store_in = &node->prev;\n        }\n      else if (!strncasecmp (ptr, INFO_ALTPREV_LABEL, \n                             strlen(INFO_ALTPREV_LABEL)))\n        {\n          ptr += strlen (INFO_ALTPREV_LABEL);\n          store_in = &node->prev;\n        }\n      else if (!strncasecmp (ptr, INFO_NEXT_LABEL, strlen(INFO_NEXT_LABEL)))\n        {\n          ptr += strlen (INFO_NEXT_LABEL);\n          store_in = &node->next;\n        }\n      else if (!strncasecmp (ptr, INFO_UP_LABEL, strlen(INFO_UP_LABEL)))\n        {\n          ptr += strlen (INFO_UP_LABEL);\n          store_in = &node->up;\n        }\n      else \n        {\n          store_in = 0;\n          /* Not recognized - code below will skip to next comma */\n        }\n      ptr += skip_whitespace (ptr);\n\n      /* Get length of a bracketed filename component. */\n      if (*ptr != '(')\n        value_length = 0;\n      else\n        value_length = read_bracketed_filename (ptr, 0);\n\n      /* Get length of node name, or filename if following \"File:\".  Note \n         that .  is not included in the second argument here in order to \n         support this character in file names. */\n      value_length += read_quoted_string (ptr + value_length,\n                                          \"\\n\\r\\t,\", 1, &nodename);\n      if (store_in)\n        {\n          *store_in = xmalloc (value_length + 1);\n          strncpy (*store_in, ptr, value_length);\n          (*store_in)[value_length] = '\\0';\n        }\n\n      free (nodename);\n      ptr += value_length;\n\n      if (*ptr == '\\n' || !*ptr)\n        break;\n\n      ptr += 1; /* Point after field terminator */\n    }\n}",
      "lines": 86,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "scan_reference_marker": {
      "start_point": [
        1184,
        0
      ],
      "end_point": [
        1254,
        1
      ],
      "content": "static int\nscan_reference_marker (REFERENCE *entry, int in_parentheses)\n{\n  /* When preprocess_nodes is Off, we position the cursor on\n     the \"*\" when moving between references. */\n  if (!preprocess_nodes_p)\n    {\n      if (rewrite_p)\n        entry->start = text_buffer_off(&output_buf);\n      else\n        entry->start = inptr - input_start;\n    }\n\n  /* Check what we found based on first character of match */\n  if (inptr[0] == '\\n')\n    {\n      entry->type = REFERENCE_MENU_ITEM;\n      if (!preprocess_nodes_p)\n        entry->start++;\n    }\n  else\n    entry->type = REFERENCE_XREF;\n\n  if (entry->type == REFERENCE_MENU_ITEM)\n    copy_input_to_output (strlen (\"\\n* \"));\n  else\n    {\n      /* Only match \"*Note\" if it is followed by a whitespace character so that \n         it will not be recognized if, e.g., it is surrounded in inverted \n         commas. */\n      if (!strchr (\" \\t\\r\\n\", inptr[strlen (\"*Note\")]))\n        {\n          copy_input_to_output (strlen (\"*Note:\"));\n          return 0;\n        }\n\n      /* Cross-references can be generated by four different Texinfo\n         commands.  @inforef and @xref output \"*Note \" in Info format,\n         and \"See\" in HTML and print.  @ref and @pxref output \"*note \"\n         in Info format, and either nothing at all or \"see\" in HTML\n         and print.  Unfortunately, there is no easy way to distinguish\n         between these latter two cases. */\n      /* TODO: Internationalize these strings, but only if we know the\n         language of the document. */\n      if (inptr[1] == 'N')\n        {\n          write_extra_bytes_to_output (\"See\", 3);\n          in_parentheses = 1;\n        }\n      else if (in_parentheses)\n        {\n          write_extra_bytes_to_output (\"see\", 3);\n          /* Only output the \"see\" for input like \"(*note ...)\", which\n             would have come from a use of @pxref.  We used to output \"see\" for \n             \"*note\" in more circumstances, with a list of words where to\n             suppress it (to avoid \"see *note\" turning into \"see see\"), but\n             such a list can't be complete or reliable.  It's better to remove \n             it with more enthusiasm, then if the document writer wants a \"see\"\n             to appear, they can add one themselves. */\n        }\n\n      skip_input (strlen (\"*Note\"));\n      if (!in_parentheses)\n        skip_input (skip_whitespace (inptr));\n    }\n\n  /* Copy any white space before label. */\n  copy_input_to_output (skip_whitespace_and_newlines (inptr));\n\n  return 1;\n}",
      "lines": 71,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "scan_reference_label": {
      "start_point": [
        1260,
        0
      ],
      "end_point": [
        1335,
        1
      ],
      "content": "static int\nscan_reference_label (REFERENCE *entry, int in_index)\n{\n  int max_lines;\n  int len, label_len = 0;\n\n  /* Handle case of cross-reference like (FILE)NODE::. */\n  if (inptr[0] == '(')\n    label_len = read_bracketed_filename (inptr, &entry->filename);\n\n  /* Search forward to \":\" to get label name.  Cross-references may have\n     a newline in the middle. */\n  if (entry->type == REFERENCE_MENU_ITEM)\n    max_lines = 1;\n  else\n    max_lines = 2;\n  if (!in_index || inptr[label_len] == '\\177')\n    {\n      len = read_quoted_string (inptr + label_len, \":\", max_lines,\n                                &entry->nodename);\n      canonicalize_whitespace (entry->nodename);\n      if (!len)\n        return 0; /* Input invalid. */\n      label_len += len;\n    }\n  else\n    {\n      /* If in an index node, go forward to the last colon on the line\n         (not preceded by a newline, NUL or DEL).  This is in order to\n         support index entries containing colons.  This should work fine\n         as long as the node name does not contain a colon as well. */\n\n      char *p;\n      int n, m = 0;\n      p = inptr + label_len;\n\n      while (1)\n        {\n          n = strcspn (p, \":\\n\\177\");\n          if (p[n] == ':')\n            {\n              m += n + 1;\n              p += n + 1;\n              continue;\n            }\n          break;\n        }\n      if (m == 0)\n        return 0; /* no : found */\n      label_len += m - 1;\n    }\n\n  entry->label = xmalloc (label_len + 1);\n  memcpy (entry->label, inptr, label_len);\n  entry->label[label_len] = '\\0';\n  canonicalize_whitespace (entry->label);\n\n  if (preprocess_nodes_p)\n    entry->start = text_buffer_off (&output_buf);\n\n  /* Write text of label. */\n  copy_input_to_output (label_len);\n\n  if (rewrite_p)\n    entry->end = text_buffer_off (&output_buf);\n  else\n    entry->end = inptr - input_start;\n\n  /* Colon after label. */\n  skip_input (1);\n  /* Don't mess up the margin of a menu description. */\n  if (entry->type == REFERENCE_MENU_ITEM)\n    write_extra_bytes_to_output (\" \", 1);\n\n  return 1;\n}",
      "lines": 76,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "scan_reference_target": {
      "start_point": [
        1339,
        0
      ],
      "end_point": [
        1499,
        1
      ],
      "content": "static int\nscan_reference_target (REFERENCE *entry, NODE *node, int in_parentheses)\n{\n  int i;\n\n  /* This entry continues with a specific target.  Parse the\n     file name and node name from the specification. */\n\n  if (entry->type == REFERENCE_XREF)\n    {\n      int length = 0; /* Length of specification */\n      char *target_start = inptr;\n      char *nl_off = 0;\n      int space_at_start_of_line = 0;\n\n      length += skip_whitespace_and_newlines (inptr);\n\n      length += read_bracketed_filename (inptr + length, &entry->filename);\n\n      length += skip_whitespace_and_newlines (inptr + length);\n\n      /* Get the node name. */\n      length += read_quoted_string (inptr + length, \",.\", 2, &entry->nodename);\n\n      skip_input (length);\n\n      /* Check if there is a newline in the target. */\n      nl_off = strchr (target_start, '\\n');\n      if (nl_off)\n        {\n          if (nl_off < inptr)\n            space_at_start_of_line = skip_whitespace (nl_off + 1);\n          else\n            nl_off = 0;\n        }\n      canonicalize_whitespace (entry->nodename);\n\n      if (entry->filename)\n        {\n          /* Heuristic of whether it's worth outputing a newline before the\n             filename.  This checks whether the newline appears more\n             than half way through the text, and therefore which side is\n             longer. */\n          if (nl_off\n              && nl_off < target_start + (length - space_at_start_of_line) / 2)\n            {\n              int i;\n              write_extra_bytes_to_output (\"\\n\", 1);\n\n              for (i = 0; i < space_at_start_of_line; i++)\n                write_extra_bytes_to_output (\" \", 1);\n              skip_input (strspn (inptr, \" \"));\n              nl_off = 0;\n            }\n          else\n\n          if (*inptr != '\\n')\n            {\n              write_extra_bytes_to_output (\" \", 1);\n            }\n          write_extra_bytes_to_output (\"(\", 1);\n          write_extra_bytes_to_output (entry->filename,\n                                       strlen (entry->filename));\n          write_extra_bytes_to_output (\" manual)\",\n                                       strlen (\" manual)\"));\n        }\n      \n      /* Hide terminating punctuation if we are in a reference\n         like \"(*note Label:(file)node.)\". */\n      if (in_parentheses && inptr[0] == '.')\n        skip_input (1);\n\n      /* Copy any terminating punctuation before the optional newline. */\n      copy_input_to_output (strspn (inptr, \".),\"));\n\n      /* Output a newline if one is needed.  Don't do it at the end of\n         a paragraph. */\n      if (nl_off && *inptr != '\\n')\n        { \n          int i;\n\n          write_extra_bytes_to_output (\"\\n\", 1);\n          for (i = 0; i < space_at_start_of_line; i++)\n            write_extra_bytes_to_output (\" \", 1);\n          skip_input (strspn (inptr, \" \"));\n        }\n    }\n  else /* entry->type == REFERENCE_MENU_ITEM */\n    {\n      int line_len;\n      int length = 0; /* Length of specification */\n\n      length = skip_whitespace (inptr);\n      length += read_bracketed_filename (inptr + length, &entry->filename);\n      length += strspn (inptr + length, \" \");\n\n      /* Get the node name. */\n      length += read_quoted_string (inptr + length, \",.\\t\\n\", 2, \n                                    &entry->nodename);\n      if (inptr[length] == '.') /* A '.' terminating the entry. */\n        length++;\n\n      if (node->flags & N_IsDir)\n        {\n          /* Set line_len to length of line so far. */\n\n          char *linestart;\n          linestart = memrchr (input_start, '\\n', inptr - input_start);\n          if (!linestart)\n            linestart = input_start;\n          else\n            linestart++; /* Point to first character after newline. */\n          line_len = inptr - linestart;\n        }\n\n      if (node->flags & N_IsIndex)\n        /* Show the name of the node the index entry refers to. */\n        copy_input_to_output (length);\n      else\n        {\n          skip_input (length);\n\n          if ((node->flags & N_IsDir) && inptr[strspn (inptr, \" \")] == '\\n')\n            {\n              /* For a dir node, if there is no more text in this line,\n                 check if there is a menu entry description in the next\n                 line to the right of the end of the label, and display it\n                 in this line. */\n              skip_input (strspn (inptr, \" \"));\n              if (line_len <= strspn (inptr + 1, \" \"))\n                skip_input (1 + line_len);\n            }\n          else\n            {\n              for (i = 0; i < length; i++)\n                write_extra_bytes_to_output (\" \", 1);\n            }\n        }\n\n      /* Parse \"(line ...)\" part of menus, if any.  */\n      {\n        char *lineptr = inptr;\n        /* Skip any whitespace first, and then a newline in case the item\n           was so long to contain the ``(line ...)'' string in the same\n           physical line.  */\n        lineptr += skip_whitespace (inptr);\n        if (*lineptr == '\\n')\n          lineptr += 1 + skip_whitespace (lineptr + 1);\n\n        if (!strncmp (lineptr, \"(line \", strlen (\"(line \")))\n          {\n            lineptr += strlen (\"(line \");\n            entry->line_number = strtol (lineptr, 0, 0);\n          }\n        else\n          entry->line_number = 0;\n      }\n    }\n\n  return 1;\n}",
      "lines": 161,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "safe_string_index": {
      "start_point": [
        1504,
        0
      ],
      "end_point": [
        1514,
        1
      ],
      "content": "static char\nsafe_string_index (char *ptr, long index, char *base, long len)\n{\n  long offset = ptr - base;\n\n  if (   offset + index < 0\n      || offset + index >= len)\n    return 0;\n\n  return ptr[index];\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "scan_info_tag": {
      "start_point": [
        1518,
        0
      ],
      "end_point": [
        1561,
        1
      ],
      "content": "static void\nscan_info_tag (NODE *node, int *in_index, FILE_BUFFER *fb)\n{\n  char *p, *p1;\n  struct text_buffer *expansion = xmalloc (sizeof (struct text_buffer));\n\n  p = inptr;\n  p1 = p;\n\n  text_buffer_init (expansion);\n\n  if (tag_expand (&p1, input_start + input_length, expansion, in_index))\n    {\n      if (*in_index)\n        node->flags |= N_IsIndex;\n\n      if (!rewrite_p)\n        {\n          rewrite_p = 1;\n          init_output_stream (fb);\n\n          /* Put inptr back to start so that\n             copy_input_to_output below gets all\n             preceding contents. */\n          inptr = node->contents;\n        }\n\n      /* Write out up to tag. */\n      copy_input_to_output (p - inptr);\n\n      write_tag_contents (text_buffer_base (expansion),\n                          text_buffer_off (expansion));\n      /* Skip past body of tag. */\n      skip_tag_contents (p1 - inptr);\n    }\n  else\n    {\n      /* It was not a valid tag. */ \n      copy_input_to_output (p - inptr + 1);\n    }\n\n  text_buffer_free (expansion);\n  free (expansion);\n}",
      "lines": 44,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "forward_to_info_syntax": {
      "start_point": [
        1566,
        0
      ],
      "end_point": [
        1583,
        1
      ],
      "content": "static char *\nforward_to_info_syntax (char *contents)\n{\n  /* Loop until just before the end of the input.  The '- 3' prevents us\n     accessing memory after the end of the input, and none of the strings we \n     are looking for are shorter than 3 bytes. */\n  while (contents < input_start + input_length - 3)\n    {\n      /* Menu entry comes first to optimize for the case of looking through a \n         long index node. */\n      if (looking_at_string (contents, INFO_MENU_ENTRY_LABEL)\n          || looking_at_string (contents, INFO_XREF_LABEL)\n          || !memcmp (contents, \"\\0\\b[\", 3))\n        return contents;\n      contents++;\n    }\n  return 0;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nforward_to_info_syntax (char *contents)",
        "*"
      ]
    },
    "scan_node_contents": {
      "start_point": [
        1596,
        0
      ],
      "end_point": [
        1782,
        1
      ],
      "content": "void\nscan_node_contents (NODE *node, FILE_BUFFER *fb, TAG **tag_ptr)\n{\n  int in_menu = 0;\n  char *match;\n\n  REFERENCE **refs = NULL;\n  size_t refs_index = 0, refs_slots = 0;\n\n  /* Whether an index tag was seen. */\n  int in_index = 0;\n\n  rewrite_p = preprocess_nodes_p;\n\n  init_output_stream (fb);\n\n  if (fb)\n    {\n      char *file_contents;\n\n      /* Set anchor_to_adjust to first anchor in node, if any. */\n      anchor_to_adjust = tag_ptr + 1;\n      if (!*anchor_to_adjust)\n        anchor_to_adjust = 0;\n      else if (*anchor_to_adjust\n               && (*anchor_to_adjust)->cache.nodelen != 0)\n        anchor_to_adjust = 0;\n\n      if (!node->subfile)\n        file_contents = fb->contents;\n      else\n        {\n          FILE_BUFFER *f = info_find_subfile (node->subfile);\n          if (!f)\n            return; /* This shouldn't happen. */\n          file_contents = f->contents;\n        }\n      node_offset = (*tag_ptr)->nodestart\n        + skip_node_separator (file_contents + (*tag_ptr)->nodestart);\n    }\n  else\n    anchor_to_adjust = 0;\n\n  /* Initialize refs to point to array of one null pointer in case\n     there are no results.  This way we know if refs has been initialized\n     even if it is empty. */\n  refs = calloc (1, sizeof *refs);\n  refs_slots = 1;\n\n  parse_top_node_line (node);\n\n  /* This should be the only time we assign to inptr in this function -\n     all other assignment should be done with the helper functions above. */\n  inptr = node->contents;\n  input_start = node->contents;\n  input_length = node->nodelen;\n\n\n  while ((match = forward_to_info_syntax (inptr))\n          && match < node->contents + node->nodelen)\n    {\n      int in_parentheses = 0;\n      REFERENCE *entry;\n\n      /* Write out up to match */\n      copy_input_to_output (match - inptr); \n\n      if ((in_menu && match[0] == '\\n') || match[0] == '*')\n        {\n          /* Menu entry or cross reference. */\n          /* Create REFERENCE entity. */\n          entry = info_new_reference (0, 0);\n\n          if (safe_string_index (inptr, -1, input_start, input_length) == '('\n             && safe_string_index (inptr, 1, input_start, input_length) == 'n')\n            in_parentheses = 1;\n\n          save_conversion_state ();\n          \n          if (!scan_reference_marker (entry, in_parentheses))\n            goto not_a_reference;\n\n          if (!scan_reference_label (entry, in_index))\n            goto not_a_reference;\n\n          /* If this reference entry continues with another ':' then the target\n             of the reference is given by the label. */\n          if (*inptr == ':')\n            {\n              int label_len;\n              skip_input (1);\n              if (entry->type == REFERENCE_MENU_ITEM)\n                write_extra_bytes_to_output (\" \", 1);\n\n              /* Remove the DEL bytes from a label like \"(FOO)^?BAR^?::\". */\n              label_len = strlen (entry->label);\n              if (label_len >= 2 && entry->label[label_len - 1] == 0177)\n                {\n                  char *p = strchr (entry->label, '\\177');\n                  memmove (p, p + 1, label_len - (p - entry->label) - 1);\n                  entry->label[label_len - 2] = '\\0';\n                }\n            }\n          else\n            {\n              /* Proceed to read the rest of the reference. */\n              /* TODO: we should probably not allow references of the form \n                 \"(file)node1:node2.\" or \"(file1)node1:(file2)node2\", so\n                 bail out here if entry->filename is non-null. */\n\n              free (entry->filename); entry->filename = 0;\n              free (entry->nodename); entry->nodename = 0;\n              if (!scan_reference_target (entry, node, in_parentheses))\n                goto not_a_reference;\n            }\n\n          if (0)\n            {\n              char *cur_inptr;\n\nnot_a_reference:\n              /* This is not a menu entry or reference.  Do not add to our \n                 list. */\n              cur_inptr = inptr;\n              reset_conversion ();\n              copy_input_to_output (cur_inptr - inptr);\n\n              info_reference_free (entry);\n              continue;\n            }\n\n          add_pointer_to_array (entry, refs_index, refs, refs_slots, 50);\n        }\n      /* Was \"* Menu:\" seen?  If so, search for menu entries hereafter. */\n      else if (!in_menu && !strncmp (match, INFO_MENU_LABEL,\n                               strlen (INFO_MENU_LABEL)))\n        {\n          in_menu = 1;\n          skip_input (strlen (\"\\n* Menu:\"));\n          if (*inptr == '\\n')\n            skip_input (strspn (inptr, \"\\n\") - 1); /* Keep one newline. */\n\n        }\n      else if (match[0] == '\\0') /* Info tag */\n        {\n          scan_info_tag (node, &in_index, fb);\n        }\n      else\n        copy_input_to_output (1);\n    }\n\n  /* If we haven't accidentally gone past the end of the node, write\n     out the rest of it. */\n  if (inptr < node->contents + node->nodelen)\n    copy_input_to_output ((node->contents + node->nodelen) - inptr); \n\n  /* Null to terminate buffer. */\n  if (rewrite_p)\n    text_buffer_add_string (&output_buf, \"\\0\", 1);\n\n  /* Free resources used in character encoding conversion. */\n  close_conversion ();\n  \n  node->references = refs;\n\n  if (rewrite_p)\n    {\n      node->contents = text_buffer_base (&output_buf);\n      node->flags |= N_WasRewritten;\n \n      /* output_buf.off is the offset of the next character to be\n         written.  Subtracting 1 gives the offset of our terminating\n         null, that is, the length. */\n      node->nodelen = text_buffer_off (&output_buf) - 1;\n    }\n  else if (fb && tag_ptr)\n    {\n      /* Set nodestart_adjusted for all of the anchors in this node. */\n      tag_ptr++;\n      while (*tag_ptr && (*tag_ptr)->cache.nodelen == 0)\n        {\n          (*tag_ptr)->nodestart_adjusted = (*tag_ptr)->nodestart\n                                             - output_bytes_difference;\n          tag_ptr++;\n        }\n    }\n}",
      "lines": 187,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "file_buffer_of_window": {
      "start_point": [
        1788,
        0
      ],
      "end_point": [
        1799,
        1
      ],
      "content": "FILE_BUFFER *\nfile_buffer_of_window (WINDOW *window)\n{\n  /* If this window has no node, then it has no file buffer. */\n  if (!window->node)\n    return NULL;\n\n  if (window->node->fullpath)\n    return info_find_file (window->node->fullpath);\n\n  return NULL;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "FILE_BUFFER",
        "*\nfile_buffer_of_window (WINDOW *window)",
        "*"
      ]
    },
    "node_printed_rep": {
      "start_point": [
        1803,
        0
      ],
      "end_point": [
        1817,
        1
      ],
      "content": "char *\nnode_printed_rep (NODE *node)\n{\n  static char *rep;\n\n  if (node->fullpath)\n    {\n      char *filename = filename_non_directory (node->fullpath);\n      rep = xrealloc (rep, 1 + strlen (filename) + 1 + strlen (node->nodename) + 1);\n      sprintf (rep, \"(%s)%s\", filename, node->nodename);\n      return rep;\n    }\n  else\n    return node->nodename;\n}",
      "lines": 15,
      "depth": 15,
      "decorators": [
        "char",
        "*\nnode_printed_rep (NODE *node)",
        "*"
      ]
    },
    "filename_non_directory": {
      "start_point": [
        1821,
        0
      ],
      "end_point": [
        1833,
        1
      ],
      "content": "char *\nfilename_non_directory (char *pathname)\n{\n  register char *filename = pathname + strlen (pathname);\n\n  if (HAVE_DRIVE (pathname))\n    pathname += 2;\n\n  while (filename > pathname && !IS_SLASH (filename[-1]))\n    filename--;\n\n  return filename;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "char",
        "*\nfilename_non_directory (char *pathname)",
        "*"
      ]
    },
    "internal_info_node_p": {
      "start_point": [
        1836,
        0
      ],
      "end_point": [
        1840,
        1
      ],
      "content": "int\ninternal_info_node_p (NODE *node)\n{\n  return (node != NULL) && (node->flags & N_IsInternal);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "name_internal_node": {
      "start_point": [
        1843,
        0
      ],
      "end_point": [
        1853,
        1
      ],
      "content": "void\nname_internal_node (NODE *node, char *name)\n{\n  if (!node)\n    return;\n\n  node->fullpath = \"\";\n  node->subfile = 0;\n  node->nodename = name;\n  node->flags |= N_IsInternal;\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "get_internal_info_window": {
      "start_point": [
        1857,
        0
      ],
      "end_point": [
        1868,
        1
      ],
      "content": "WINDOW *\nget_internal_info_window (char *name)\n{\n  WINDOW *win;\n\n  for (win = windows; win; win = win->next)\n    if (internal_info_node_p (win->node) &&\n        (strcmp (win->node->nodename, name) == 0))\n      break;\n\n  return win;\n}",
      "lines": 12,
      "depth": 13,
      "decorators": [
        "WINDOW",
        "*\nget_internal_info_window (char *name)",
        "*"
      ]
    },
    "text_buffer_init": {
      "start_point": [
        1872,
        0
      ],
      "end_point": [
        1876,
        1
      ],
      "content": "void\ntext_buffer_init (struct text_buffer *buf)\n{\n  memset (buf, 0, sizeof *buf);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "text_buffer_free": {
      "start_point": [
        1878,
        0
      ],
      "end_point": [
        1882,
        1
      ],
      "content": "void\ntext_buffer_free (struct text_buffer *buf)\n{\n  free (buf->base);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "text_buffer_vprintf": {
      "start_point": [
        1884,
        0
      ],
      "end_point": [
        1920,
        1
      ],
      "content": "size_t\ntext_buffer_vprintf (struct text_buffer *buf, const char *format, va_list ap)\n{\n  ssize_t n;\n  va_list ap_copy;\n\n  if (!buf->base)\n    {\n      if (buf->size == 0)\n\tbuf->size = MIN_TEXT_BUF_ALLOC; /* Initial allocation */\n      \n      buf->base = xmalloc (buf->size);\n    }\n  \n  for (;;)\n    {\n      va_copy (ap_copy, ap);\n      n = vsnprintf (buf->base + buf->off, buf->size - buf->off,\n\t\t     format, ap_copy);\n      va_end (ap_copy);\n      if (n < 0 || buf->off + n >= buf->size ||\n\t  !memchr (buf->base + buf->off, '\\0', buf->size - buf->off + 1))\n\t{\n\t  size_t newlen = buf->size * 2;\n\t  if (newlen < buf->size)\n\t    xalloc_die ();\n\t  buf->size = newlen;\n\t  buf->base = xrealloc (buf->base, buf->size);\n\t}\n      else\n\t{\n\t  buf->off += n;\n\t  break;\n\t}\n    }\n  return n;\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "size_t"
      ]
    },
    "text_buffer_alloc": {
      "start_point": [
        1923,
        0
      ],
      "end_point": [
        1933,
        1
      ],
      "content": "void\ntext_buffer_alloc (struct text_buffer *buf, size_t len)\n{\n  if (buf->off + len > buf->size)\n    {\n      buf->size = buf->off + len;\n      if (buf->size < MIN_TEXT_BUF_ALLOC)\n\tbuf->size = MIN_TEXT_BUF_ALLOC;\n      buf->base = xrealloc (buf->base, buf->size);\n    }\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "text_buffer_space_left": {
      "start_point": [
        1937,
        0
      ],
      "end_point": [
        1943,
        1
      ],
      "content": "size_t\ntext_buffer_space_left (struct text_buffer *buf)\n{\n  /* buf->size is the offset of the first byte after the allocated space.\n     buf->off is the offset of the first byte to be written to. */\n  return buf->size - buf->off;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    },
    "text_buffer_iconv": {
      "start_point": [
        1948,
        0
      ],
      "end_point": [
        1964,
        1
      ],
      "content": "size_t\ntext_buffer_iconv (struct text_buffer *buf, iconv_t iconv_state,\n                   ICONV_CONST char **inbuf, size_t *inbytesleft)\n{\n  size_t out_bytes_left;\n  char *outptr;\n  size_t iconv_ret;\n\n  outptr = text_buffer_base (buf) + text_buffer_off (buf);\n  out_bytes_left = text_buffer_space_left (buf);\n  iconv_ret = iconv (iconv_state, inbuf, inbytesleft,\n                     &outptr, &out_bytes_left);\n\n  text_buffer_off (buf) = outptr - text_buffer_base (buf);    \n\n  return iconv_ret;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "text_buffer_add_string": {
      "start_point": [
        1968,
        0
      ],
      "end_point": [
        1975,
        1
      ],
      "content": "size_t\ntext_buffer_add_string (struct text_buffer *buf, const char *str, size_t len)\n{\n  text_buffer_alloc (buf, len);\n  memcpy (buf->base + buf->off, str, len);\n  buf->off += len;\n  return len;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "text_buffer_fill": {
      "start_point": [
        1977,
        0
      ],
      "end_point": [
        1990,
        1
      ],
      "content": "size_t\ntext_buffer_fill (struct text_buffer *buf, int c, size_t len)\n{\n  char *p;\n  int i;\n  \n  text_buffer_alloc (buf, len);\n  \n  for (i = 0, p = buf->base + buf->off; i < len; i++)\n    *p++ = c;\n  buf->off += len;\n  \n  return len;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "text_buffer_add_char": {
      "start_point": [
        1992,
        0
      ],
      "end_point": [
        1997,
        1
      ],
      "content": "void\ntext_buffer_add_char (struct text_buffer *buf, int c)\n{\n  char ch = c;\n  text_buffer_add_string (buf, &ch, 1);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "text_buffer_printf": {
      "start_point": [
        1999,
        0
      ],
      "end_point": [
        2009,
        1
      ],
      "content": "size_t\ntext_buffer_printf (struct text_buffer *buf, const char *format, ...)\n{\n  va_list ap;\n  size_t n;\n  \n  va_start (ap, format);\n  n = text_buffer_vprintf (buf, format, ap);\n  va_end (ap);\n  return n;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "size_t"
      ]
    },
    "fncmp": {
      "start_point": [
        2014,
        0
      ],
      "end_point": [
        2029,
        1
      ],
      "content": "int\nfncmp (const char *fn1, const char *fn2)\n{\n  const char *s1 = fn1, *s2 = fn2;\n\n  while (tolower (*s1) == tolower (*s2)\n\t || (IS_SLASH (*s1) && IS_SLASH (*s2)))\n    {\n      if (*s1 == 0)\n\treturn 0;\n      s1++;\n      s2++;\n    }\n\n  return tolower (*s1) - tolower (*s2);\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "info_namelist_add": {
      "start_point": [
        2038,
        0
      ],
      "end_point": [
        2052,
        1
      ],
      "content": "int\ninfo_namelist_add (struct info_namelist_entry **ptop, const char *name)\n{\n  struct info_namelist_entry *p;\n\n  for (p = *ptop; p; p = p->next)\n    if (fncmp (p->name, name) == 0)\n      return 1;\n\n  p = xmalloc (sizeof (*p) + strlen (name));\n  strcpy (p->name, name);\n  p->next = *ptop;\n  *ptop = p;\n  return 0;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "info_namelist_free": {
      "start_point": [
        2054,
        0
      ],
      "end_point": [
        2063,
        1
      ],
      "content": "void\ninfo_namelist_free (struct info_namelist_entry *top)\n{\n  while (top)\n    {\n      struct info_namelist_entry *next = top->next;\n      free (top);\n      top = next;\n    }\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "texinfo/texinfo-6.5/info/info-utils.h": {},
  "texinfo/texinfo-6.5/info/info.c": {
    "get_initial_file": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        328,
        1
      ],
      "content": "static void\nget_initial_file (int *argc, char ***argv, char **error)\n{\n  REFERENCE *entry;\n\n  /* User used \"--file\". */\n  if (user_filename)\n    {\n      if (!IS_ABSOLUTE(user_filename) && HAS_SLASH(user_filename)\n          && !(user_filename[0] == '.' && IS_SLASH(user_filename[1])))\n        {\n          /* Prefix \"./\" to the filename to prevent a lookup\n             in INFOPATH.  */\n          char *s;\n          asprintf (&s, \"%s%s\", \"./\", user_filename);\n          free (user_filename);\n          user_filename = s;\n        }\n      if (IS_ABSOLUTE(user_filename) || HAS_SLASH(user_filename))\n        initial_file = info_add_extension (0, user_filename, 0);\n      else\n        initial_file = info_find_fullpath (user_filename, 0);\n\n      if (!initial_file)\n        {\n          if (!filesys_error_number)\n            filesys_error_number = ENOENT;\n          *error = filesys_error_string (user_filename, filesys_error_number);\n        }\n\n      return;\n    }\n\n  if (!(*argv)[0])\n    {\n      /* No more non-option arguments. */\n      initial_file = xstrdup(\"dir\");\n      return;\n    }\n\n  /* If first argument begins with '(', add it as if it were given with \n     '--node'.  This is to support invoking like\n     \"info '(emacs)Buffers'\".  If it is a well-formed node spec then\n     the rest of the arguments are menu entries to follow, or an\n     index entry.  */\n  if ((*argv)[0][0] == '(')\n    {\n      info_parse_node ((*argv)[0]);\n      if (info_parsed_filename)\n        {\n          initial_file = info_find_fullpath (info_parsed_filename, 0);\n          if (initial_file)\n            {\n              add_pointer_to_array (info_new_reference (initial_file,\n                                                        info_parsed_nodename),\n                                    ref_index, ref_list, ref_slots, 2);\n              /* Remove this argument from the argument list. */\n              memmove (*argv, *argv + 1, *argc-- * sizeof (char *));\n              return;\n            }\n        }\n    }\n\n  /* If there are any more arguments, the initial file is the\n     dir entry given by the first one. */\n    {\n      /* If they say info info (or info -O info, etc.), show them \n         info-stnd.texi.  (Get info.texi with info -f info.) */\n      if ((*argv)[0] && mbscasecmp ((*argv)[0], \"info\") == 0)\n        (*argv)[0] = \"info-stnd\";\n\n      entry = lookup_dir_entry ((*argv)[0], 0);\n      if (entry)\n        {\n          initial_file = info_find_fullpath (entry->filename, 0);\n          if (initial_file)\n            {\n              REFERENCE *copy;\n              (*argv)++; /* Advance past first remaining argument. */\n              (*argc)--;\n\n              copy = info_copy_reference (entry);\n              /* Store full path, so that we find the already loaded file in\n                 info_find_file, and show the full path if --where is used. */\n              free (copy->filename);\n              copy->filename = xstrdup (initial_file);\n              add_pointer_to_array (copy, ref_index, ref_list, ref_slots, 2);\n              return;\n            }\n        }\n    }\n\n  /* File name lookup. */\n    {\n      /* Try finding a file with this name, in case\n         it exists, but wasn't listed in dir. */\n      initial_file = info_find_fullpath ((*argv)[0], 0);\n      if (initial_file)\n        {\n          add_pointer_to_array (info_new_reference ((*argv)[0], \"Top\"),\n                                ref_index, ref_list, ref_slots, 2);\n          (*argv)++; /* Advance past first remaining argument. */\n          (*argc)--;\n          return;\n        }\n      else\n        asprintf (error, _(\"No menu item '%s' in node '%s'\"),\n            (*argv)[0], \"(dir)Top\");\n    }\n\n  /* Fall back to loading man page. */\n    {\n      NODE *man_node;\n\n      debug (3, (\"falling back to manpage node\"));\n\n      man_node = get_manpage_node ((*argv)[0]);\n      if (man_node)\n        {\n          add_pointer_to_array\n            (info_new_reference (MANPAGE_FILE_BUFFER_NAME, (*argv)[0]),\n             ref_index, ref_list, ref_slots, 2);\n\n          initial_file = MANPAGE_FILE_BUFFER_NAME;\n          return;\n        }\n    }\n\n  /* Inexact dir lookup. */\n    {\n      entry = lookup_dir_entry ((*argv)[0], 1);\n      if (entry)\n        {\n          initial_file = info_find_fullpath (entry->filename, 0);\n          if (initial_file)\n            {\n              REFERENCE *copy;\n              (*argv)++; /* Advance past first remaining argument. */\n              (*argc)--;\n              /* Clear error message. */\n              free (*error);\n              *error = 0;\n\n              copy = info_copy_reference (entry);\n              /* Store full path, so that we find the already loaded file in\n                 info_find_file, and show the full path if --where is used. */\n              free (copy->filename);\n              copy->filename = initial_file;\n              add_pointer_to_array (copy, ref_index, ref_list, ref_slots, 2);\n              return;\n            }\n        }\n    }\n\n  return;\n}",
      "lines": 156,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "add_initial_nodes": {
      "start_point": [
        331,
        0
      ],
      "end_point": [
        568,
        1
      ],
      "content": "static void\nadd_initial_nodes (int argc, char **argv, char **error)\n{\n  /* Add nodes specified with --node. */\n  if (user_nodenames)\n    {\n      int i;\n\n      /* If any --node arguments were given, the node in ref_list[0] is only \n         used to set initial_file. */\n      if (user_nodenames_index > 0 && ref_index > 0)\n        {\n          info_reference_free (ref_list[0]);\n          ref_list[0] = 0;\n          ref_index = 0;\n        }\n\n      for (i = 0; user_nodenames[i]; i++)\n        {\n          char *node_filename = 0;\n          char *node_nodename = 0;\n\n          /* Parse node spec to support invoking\n             like info --node \"(emacs)Buffers\". */\n          info_parse_node (user_nodenames[i]);\n          if (info_parsed_filename)\n            {\n              node_filename = info_parsed_filename;\n              node_nodename = info_parsed_nodename;\n            }\n          else\n            {\n              FILE_BUFFER *file_buffer;\n              TAG *tag;\n              int j;\n\n              if (!initial_file)\n                continue; /* Shouldn't happen. */\n\n              /* Check for a node by this name, and if there isn't one\n                 look for an inexact match. */\n\n              node_filename = initial_file;\n              node_nodename = 0;\n\n              file_buffer = info_find_file (node_filename);\n              if (!file_buffer)\n                continue;\n\n              /* First look for an exact match. */\n              for (j = 0; (tag = file_buffer->tags[j]); j++)\n                if (strcmp (user_nodenames[i], tag->nodename) == 0)\n                  {\n                    node_nodename = tag->nodename;\n                    break;\n                  }\n\n              if (!node_nodename)\n                {\n                  int best_guess = -1;\n                  int len = strlen (user_nodenames[i]);\n                  for (j = 0; (tag = file_buffer->tags[j]); j++)\n                    {\n                      if (mbscasecmp (user_nodenames[i], tag->nodename) == 0)\n                        {\n                          /* Exact, case-insensitive match. */\n                          node_nodename = tag->nodename;\n                          best_guess = -1;\n                          break;\n                        }\n                      else if (best_guess == -1\n                               && (mbsncasecmp (user_nodenames[i],\n                                                tag->nodename, len) == 0))\n                        /* Case-insensitive initial substring. */\n                        best_guess = j;\n                    }\n                  if (best_guess != -1)\n                    {\n                      node_nodename = file_buffer->tags[best_guess]->nodename;\n                    }\n                }\n\n              if (!node_nodename)\n                {\n                  free (*error);\n                  asprintf (error, _(\"Cannot find node '%s'\"),\n                            user_nodenames[i]);\n                  continue;\n                }\n            }\n\n          if (node_filename && node_nodename)\n            add_pointer_to_array\n              (info_new_reference (node_filename, node_nodename),\n               ref_index, ref_list, ref_slots, 2);\n        }\n    }\n\n  if (goto_invocation_p)\n    {\n      NODE *top_node = 0;\n      REFERENCE *invoc_ref = 0;\n\n      char *program;\n\n      if (ref_index == 0)\n        {\n          info_error (_(\"No program name given\"));\n          exit (1);\n        }\n\n      if (invocation_program_name)\n        program = xstrdup (invocation_program_name);\n      else if (ref_list[0] && ref_list[0]->filename)\n        /* If there's no command-line arguments to\n           supply the program name, use the Info file\n           name (sans extension and leading directories)\n           instead.  */\n        program = program_name_from_file_name (ref_list[0]->filename);\n      else\n        program = xstrdup (\"\");\n      \n      if (ref_index > 0)\n        top_node = info_get_node (ref_list[0]->filename, \n                                  ref_list[0]->nodename);\n      if (top_node)\n        invoc_ref = info_intuit_options_node (top_node, program);\n      if (invoc_ref)\n        {\n          info_reference_free (ref_list[0]);\n          ref_index = 0;\n\n          add_pointer_to_array (invoc_ref, ref_index, ref_list, ref_slots, 2);\n        }\n      free (program);\n    }\n\n  /* Default is the \"Top\" node if there were no other nodes. */\n  if (ref_index == 0 && initial_file)\n    {\n       add_pointer_to_array (info_new_reference (initial_file, \"Top\"), \n                             ref_index, ref_list, ref_slots, 2);\n    }\n\n  /* If there are arguments remaining, they are the names of menu items\n     in sequential info files starting from the first one loaded. */\n  if (*argv && ref_index > 0)\n    {\n      NODE *initial_node; /* Node to start following menus from. */\n      NODE *node_via_menus;\n\n      initial_node = info_get_node_with_defaults (ref_list[0]->filename,\n                                                  ref_list[0]->nodename, 0);\n      if (!initial_node)\n        return;\n\n      node_via_menus = info_follow_menus (initial_node, argv, error, 1);\n      if (node_via_menus)\n        {\n          argv += argc; argc = 0;\n\n          info_reference_free (ref_list[0]);\n          ref_list[0] = info_new_reference (node_via_menus->fullpath,\n                                            node_via_menus->nodename);\n          free_history_node (node_via_menus);\n        }\n\n      /* If no nodes found, and there is exactly one argument remaining,\n         check for it as an index entry. */\n      else if (argc == 1 && argv[0])\n        {\n          FILE_BUFFER *fb;\n          REFERENCE *match;\n\n          debug (3, (\"looking in indices\"));\n          fb = info_find_file (ref_list[0]->filename);\n          if (fb)\n            {\n              match = look_in_indices (fb, argv[0], 0);\n              if (match)\n                {\n                  argv += argc; argc = 0;\n                  free (*error); *error = 0;\n\n                  info_reference_free (ref_list[0]);\n                  ref_list[0] = info_copy_reference (match);\n                }\n            }\n        }\n\n      /* If there are arguments remaining, follow menus inexactly. */\n      if (argc != 0)\n        {\n          initial_node = info_get_node_with_defaults (ref_list[0]->filename,\n                                                      ref_list[0]->nodename,\n                                                      0);\n          free (*error); *error = 0;\n          node_via_menus = info_follow_menus (initial_node, argv, error, 0);\n          if (node_via_menus)\n            {\n              if (argc >= 2 || !*error)\n                {\n                  argv += argc; argc = 0;\n\n                  info_reference_free (ref_list[0]);\n                  ref_list[0] = info_new_reference (node_via_menus->fullpath,\n                                                    node_via_menus->nodename);\n                }\n              free_history_node (node_via_menus);\n            }\n        }\n\n      /* If still no nodes found, and there is exactly one argument remaining,\n         look in indices sloppily. */\n      if (argc == 1)\n        {\n          FILE_BUFFER *fb;\n          REFERENCE *nearest;\n\n          debug (3, (\"looking in indices sloppily\"));\n          fb = info_find_file (ref_list[0]->filename);\n          if (fb)\n            {\n              nearest = look_in_indices (fb, argv[0], 1);\n              if (nearest)\n                {\n                  argv += argc; argc = 0;\n                  free (*error); *error = 0;\n\n                  info_reference_free (ref_list[0]);\n                  ref_list[0] = info_copy_reference (nearest);\n                }\n            }\n        }\n    }\n\n  return;\n}",
      "lines": 238,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "info_find_matching_files": {
      "start_point": [
        570,
        0
      ],
      "end_point": [
        626,
        1
      ],
      "content": "static void\ninfo_find_matching_files (char *filename)\n{\n  int i;\n  char *searchdir;\n\n  NODE *man_node;\n\n  /* Check for dir entries first. */\n  i = 0;\n  for (searchdir = infopath_first (&i); searchdir;\n       searchdir = infopath_next (&i))\n    {\n      REFERENCE *new_ref = dir_entry_of_infodir (filename, searchdir);\n\n      if (new_ref)\n        add_pointer_to_array (new_ref, ref_index, ref_list, ref_slots, 2);\n    }\n\n  /* Look for files with matching names. */\n  i = 0;\n  while (1)\n    {\n      char *p;\n      int j;\n\n      p = info_file_find_next_in_path (filename, &i, 0);\n      if (!p)\n        break;\n\n      /* Add to list only if the file is not in the list already (which would\n         happen if there was a dir entry with the label and filename both\n         being this file). */\n      for (j = 0; j < ref_index; j++)\n        {\n          if (!strcmp (p, ref_list[j]->filename))\n            break;\n        }\n\n      if (j == ref_index)\n        {\n          add_pointer_to_array (info_new_reference (p, 0),\n            ref_index, ref_list, ref_slots, 2);\n        }\n      free (p);\n    }\n\n  /* Check for man page. */\n  man_node = get_manpage_node (filename);\n  if (man_node)\n    {\n      free (man_node);\n      add_pointer_to_array\n        (info_new_reference (MANPAGE_FILE_BUFFER_NAME, filename),\n         ref_index, ref_list, ref_slots, 2);\n    }\n}",
      "lines": 57,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_debug_level": {
      "start_point": [
        629,
        0
      ],
      "end_point": [
        643,
        1
      ],
      "content": "static void\nset_debug_level (const char *arg)\n{\n  char *p;\n  long n = strtol (arg, &p, 10);\n  if (*p)\n    {\n      fprintf (stderr, _(\"invalid number: %s\\n\"), arg);\n      exit (EXIT_FAILURE);\n    }\n  if (n < 0 || n > UINT_MAX)\n    debug_level = UINT_MAX;\n  else\n    debug_level = n;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "add_file_directory_to_path": {
      "start_point": [
        645,
        0
      ],
      "end_point": [
        665,
        1
      ],
      "content": "static void\nadd_file_directory_to_path (char *filename)\n{\n  char *directory_name = xstrdup (filename);\n  char *temp = filename_non_directory (directory_name);\n\n  if (temp != directory_name)\n    {\n      if (HAVE_DRIVE (directory_name) && temp == directory_name + 2)\n\t{\n\t  /* The directory of \"d:foo\" is stored as \"d:.\", to avoid\n\t     mixing it with \"d:/\" when a slash is appended.  */\n\t  *temp = '.';\n\t  temp += 2;\n\t}\n      temp[-1] = 0;\n      infopath_add (directory_name);\n    }\n\n  free (directory_name);\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        674,
        0
      ],
      "end_point": [
        1083,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int getopt_long_index;       /* Index returned by getopt_long (). */\n  char *init_file = 0;         /* Name of init file specified. */\n  char *error = 0;             /* Error message to display in mini-buffer. */\n\n#ifdef HAVE_SETLOCALE\n  /* Set locale via LC_ALL.  */\n  setlocale (LC_ALL, \"\");\n#endif /* HAVE_SETLOCALE */\n\n#ifdef ENABLE_NLS\n  /* Set the text message domain.  */\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n#endif\n\n  init_messages ();\n  while (1)\n    {\n      int option_character;\n\n      option_character = getopt_long (argc, argv, short_options, long_options,\n\t\t\t\t      &getopt_long_index);\n\n      /* getopt_long returns EOF when there are no more long options. */\n      if (option_character == EOF)\n        break;\n\n      /* If this is a long option, then get the short version of it. */\n      if (option_character == 0 && long_options[getopt_long_index].flag == 0)\n        option_character = long_options[getopt_long_index].val;\n\n      /* Case on the option that we have received. */\n      switch (option_character)\n        {\n        case 0:\n          break;\n\n\tcase 'a':\n\t  all_matches_p = 1;\n\t  break;\n\t  \n          /* User wants to add a directory. */\n        case 'd':\n          infopath_add (optarg);\n          break;\n\n          /* User is specifying a particular node. */\n        case 'n':\n          add_pointer_to_array (optarg, user_nodenames_index, user_nodenames,\n                                user_nodenames_slots, 10);\n          break;\n\n          /* User is specifying a particular Info file. */\n        case 'f':\n          if (user_filename)\n            free (user_filename);\n\n          user_filename = xstrdup (optarg);\n          break;\n\n          /* Treat -h like --help. */\n        case 'h':\n          print_help_p = 1;\n          break;\n\n          /* User is specifying the name of a file to output to. */\n        case 'o':\n          if (user_output_filename)\n            free (user_output_filename);\n          user_output_filename = xstrdup (optarg);\n          break;\n\n         /* User has specified that she wants to find the \"Options\"\n             or \"Invocation\" node for the program.  */\n        case 'O':\n          goto_invocation_p = 1;\n          break;\n\n\t  /* User has specified that she wants the escape sequences\n\t     in man pages to be passed thru unaltered.  */\n        case 'R':\n          raw_escapes_p = 1;\n          break;\n\n          /* User is specifying that she wishes to dump the subnodes of\n             the node that she is dumping. */\n        case 's':\n          dump_subnodes = 1;\n          break;\n\n          /* For compatibility with man, -w is --where.  */\n        case 'w':\n          print_where_p = 1;\n          break;\n\n#if defined(__MSDOS__) || defined(__MINGW32__)\n\t  /* User wants speech-friendly output.  */\n\tcase 'b':\n\t  speech_friendly = 1;\n\t  break;\n#endif /* __MSDOS__ || __MINGW32__ */\n\n          /* User has specified a string to search all indices for. */\n        case 'k':\n          apropos_p = 1;\n          free (apropos_search_string);\n          apropos_search_string = xstrdup (optarg);\n          break;\n\n          /* User has specified a dribble file to receive keystrokes. */\n        case DRIBBLE_OPTION:\n          close_dribble_file ();\n          open_dribble_file (optarg);\n          break;\n\n          /* User has specified an alternate input stream. */\n        case RESTORE_OPTION:\n          info_set_input_from_file (optarg);\n          break;\n\n          /* User has specified a string to search all indices for. */\n        case IDXSRCH_OPTION:\n          index_search_p = 1;\n          free (index_search_string);\n          index_search_string = xstrdup (optarg);\n          break;\n\n          /* User has specified a file to use as the init file. */\n        case INITFLE_OPTION:\n          init_file = optarg;\n          break;\n\n\tcase 'v':\n\t  {\n            VARIABLE_ALIST *var;\n\t    char *p;\n\t    p = strchr (optarg, '=');\n\t    if (!p)\n\t      {\n\t\tinfo_error (_(\"malformed variable assignment: %s\"), optarg);\n\t\texit (EXIT_FAILURE);\n\t      }\n\t    *p++ = 0;\n\n            if (!(var = variable_by_name (optarg)))\n              {\n                info_error (_(\"%s: no such variable\"), optarg);\n                exit (EXIT_FAILURE);\n              }\n\n\t    if (!set_variable_to_value (var, p, SET_ON_COMMAND_LINE))\n\t      {\n                info_error (_(\"value %s is not valid for variable %s\"),\n                            p, optarg);\n\t\texit (EXIT_FAILURE);\n\t      }\t\n\t  }\n\t  break;\n\t  \n\tcase 'x':\n\t  set_debug_level (optarg);\n\t  break;\n\t  \n        default:\n          fprintf (stderr, _(\"Try --help for more information.\\n\"));\n          exit (EXIT_FAILURE);\n        }\n    }\n\n  /* If the output device is not a terminal, and no output filename has been\n     specified, make user_output_filename be \"-\", so that the info is written\n     to stdout, and turn on the dumping of subnodes. */\n  if ((!isatty (fileno (stdout))) && (user_output_filename == NULL))\n    {\n      user_output_filename = xstrdup (\"-\");\n      dump_subnodes = 1;\n    }\n\n  /* If the user specified --version, then show the version and exit. */\n  if (print_version_p)\n    {\n      printf (\"info (GNU %s) %s\\n\", PACKAGE, VERSION);\n      puts (\"\");\n      printf (_(\"Copyright (C) %s Free Software Foundation, Inc.\\n\\\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\\n\\\nThis is free software: you are free to change and redistribute it.\\n\\\nThere is NO WARRANTY, to the extent permitted by law.\\n\"),\n\t      \"2017\");\n      exit (EXIT_SUCCESS);\n    }\n\n  /* If the `--help' option was present, show the help and exit. */\n  if (print_help_p)\n    {\n      info_short_help ();\n      exit (EXIT_SUCCESS);\n    }\n\n  argc -= optind;\n  argv += optind;\n  \n  /* If --file was not used and there is a slash in the first non-option\n     argument (e.g. \"info subdir/file.info\"), do not search the dir files\n     for a matching entry. */\n  if (!user_filename && argv[0] && HAS_SLASH (argv[0]))\n    {\n      user_filename = xstrdup (argv[0]);\n      argv++; /* Advance past first remaining argument. */\n      argc--;\n    }\n\n  /* If the user specified a particular filename, add the path of that\n     file to the contents of INFOPATH. */\n  if (user_filename)\n    add_file_directory_to_path (user_filename);\n\n  /* Load custom key mappings and variable settings */\n  initialize_terminal_and_keymaps (init_file);\n\n  /* Add extra search directories to any already specified with\n     --directory. */\n  infopath_init ();\n\n  /* If the user wants to search every known index for a given string,\n     do that now, and report the results. */\n  if (apropos_p)\n    {\n      REFERENCE **apropos_list;\n\n      apropos_list = apropos_in_all_indices (apropos_search_string, 0);\n\n      if (!apropos_list)\n        info_error (_(APROPOS_NONE), apropos_search_string);\n      else\n        {\n          register int i;\n          REFERENCE *entry;\n\n          for (i = 0; (entry = apropos_list[i]); i++)\n            fprintf (stdout, \"\\\"(%s)%s\\\" -- %s\\n\",\n                entry->filename, entry->nodename, entry->label);\n        }\n      exit (0);\n    }\n\n  /* Initialize empty list of nodes to load. */\n  add_pointer_to_array (0, ref_index, ref_list, ref_slots, 2);\n  ref_index--;\n\n  if (all_matches_p && !index_search_p)\n    {\n      /* --all */\n      if (!user_filename && argv[0])\n        {\n          user_filename = xstrdup (argv[0]);\n          argv++; argc--;\n        }\n      else if (!user_filename)\n        {\n          exit (1);\n        }\n      info_find_matching_files (user_filename);\n      /* If only one match, don't start in a menu of matches. */\n      if (ref_index == 1)\n        all_matches_p = 0;\n\n      /* --where */\n      if (print_where_p)\n        {\n          int i;\n          if (!ref_list)\n            exit (1);\n\n          for (i = 0; ref_list[i]; i++)\n            printf (\"%s\\n\", ref_list[i]->filename);\n          exit (0);\n        }\n    }\n  else\n    {\n      if (goto_invocation_p)\n        {\n          /* If they said \"info --show-options foo bar baz\",\n             the last of the arguments is the program whose\n             options they want to see.  */\n          char **p = argv;\n          if (*p)\n            {\n              while (p[1])\n                p++;\n              invocation_program_name = *p;\n            }\n        }\n\n      get_initial_file (&argc, &argv, &error);\n\n      /* If the user specified `--index-search=STRING --all', create\n         and display the menu of results. */\n      if (index_search_p && all_matches_p && initial_file)\n        {\n          FILE_BUFFER *initial_fb;\n          initial_fb = info_find_file (initial_file);\n          if (initial_fb)\n            {\n              NODE *node = create_virtual_index (initial_fb,\n                                                 index_search_string);\n              if (node)\n                {\n                  if (user_output_filename)\n                    {\n                      FILE *output_stream = 0;\n                      if (strcmp (user_output_filename, \"-\") == 0)\n                        output_stream = stdout;\n                      else\n                        output_stream = fopen (user_output_filename, \"w\");\n                      if (output_stream)\n                        {\n                          write_node_to_stream (node, output_stream);\n                        }\n                      exit (0);\n                    }\n                  else\n                    {\n                      initialize_info_session ();\n                      info_set_node_of_window (active_window, node);\n                      info_read_and_dispatch ();\n                      close_info_session ();\n                      exit (0);\n                    }\n                }\n            }\n        }\n\n      /* If the user specified `--index-search=STRING', \n         start the info session in the node corresponding\n         to what they want. */\n      else if (index_search_p && initial_file && !user_output_filename)\n        {\n          FILE_BUFFER *initial_fb;\n          initial_fb = info_find_file (initial_file);\n          if (initial_fb)\n            {\n              REFERENCE *result;\n              int i, match_offset;\n\n              result = next_index_match (initial_fb, index_search_string, 0, 1,\n                                         &i, &match_offset);\n\n              if (result)\n                {\n                  initialize_info_session ();\n                  report_index_match (i, match_offset);\n                  info_select_reference (active_window, result);\n                  info_read_and_dispatch ();\n                  close_info_session ();\n                  exit (0);\n                }\n            }\n\n          fprintf (stderr, _(\"no index entries found for '%s'\\n\"),\n                   index_search_string);\n          close_dribble_file ();\n          exit (1);\n        }\n\n      /* Add nodes to start with (unless we fell back to the man page). */\n      if (!ref_list[0] || strcmp (ref_list[0]->filename, \n                                  MANPAGE_FILE_BUFFER_NAME))\n        {\n          add_initial_nodes (argc, argv, &error);\n        }\n\n      /* --where */\n      if (print_where_p)\n        {\n          if (initial_file)\n            printf (\"%s\\n\", initial_file);\n          exit (0);\n        }\n\n    }\n\n  /* --output */\n  if (user_output_filename)\n    {\n      if (error)\n        info_error (\"%s\", error);\n\n      preprocess_nodes_p = 0;\n      dump_nodes_to_file (ref_list, user_output_filename, dump_subnodes);\n      exit (0);\n    }\n\n  if (ref_index == 0)\n    {\n      if (error)\n        {\n          info_error (\"%s\", error);\n          exit (1);\n        }\n      exit (0);\n    }\n    \n  info_session (ref_list, all_matches_p ? user_filename : 0, error);\n  close_info_session ();\n  exit (0);\n}",
      "lines": 410,
      "depth": 19,
      "decorators": [
        "int"
      ]
    },
    "info_short_help": {
      "start_point": [
        1087,
        0
      ],
      "end_point": [
        1154,
        1
      ],
      "content": "static void\ninfo_short_help (void)\n{\n  printf (_(\"\\\nUsage: %s [OPTION]... [MENU-ITEM...]\\n\\\n\\n\\\nRead documentation in Info format.\\n\"), program_name);\n  puts (\"\");\n\n  puts (_(\"\\\nFrequently-used options:\\n\\\n  -a, --all                    use all matching manuals\\n\\\n  -k, --apropos=STRING         look up STRING in all indices of all manuals\\n\\\n  -d, --directory=DIR          add DIR to INFOPATH\\n\\\n  -f, --file=MANUAL            specify Info manual to visit\"));\n\n  puts (_(\"\\\n  -h, --help                   display this help and exit\\n\\\n      --index-search=STRING    go to node pointed by index entry STRING\\n\\\n  -n, --node=NODENAME          specify nodes in first visited Info file\\n\\\n  -o, --output=FILE            output selected nodes to FILE\"));\n\n  puts (_(\"\\\n  -O, --show-options, --usage  go to command-line options node\"));\n\n#if defined(__MSDOS__) || defined(__MINGW32__)\n  puts (_(\"\\\n  -b, --speech-friendly        be friendly to speech synthesizers\"));\n#endif\n\n  puts (_(\"\\\n      --subnodes               recursively output menu items\\n\\\n  -v, --variable VAR=VALUE     assign VALUE to Info variable VAR\\n\\\n      --version                display version information and exit\\n\\\n  -w, --where, --location      print physical location of Info file\"));\n\n  puts (_(\"\\n\\\nThe first non-option argument, if present, is the menu entry to start from;\\n\\\nit is searched for in all 'dir' files along INFOPATH.\\n\\\nIf it is not present, info merges all 'dir' files and shows the result.\\n\\\nAny remaining arguments are treated as the names of menu\\n\\\nitems relative to the initial node visited.\"));\n\n  puts (_(\"\\n\\\nFor a summary of key bindings, type H within Info.\"));\n\n  puts (_(\"\\n\\\nExamples:\\n\\\n  info                         show top-level dir menu\\n\\\n  info info-stnd               show the manual for this Info program\\n\\\n  info emacs                   start at emacs node from top-level dir\\n\\\n  info emacs buffers           select buffers menu entry in emacs manual\\n\\\n  info emacs -n Files          start at Files node within emacs manual\\n\\\n  info '(emacs)Files'          alternative way to start at Files node\\n\\\n  info --show-options emacs    start at node with emacs' command line options\\n\\\n  info --subnodes -o out.txt emacs\\n\\\n                               dump entire emacs manual to out.txt\\n\\\n  info -f ./foo.info           show file ./foo.info, not searching dir\"));\n\n  puts (\"\");\n\n  puts (_(\"\\\nEmail bug reports to bug-texinfo@gnu.org,\\n\\\ngeneral questions and discussion to help-texinfo@gnu.org.\\n\\\nTexinfo home page: http://www.gnu.org/software/texinfo/\"));\n\n  exit (EXIT_SUCCESS);\n}",
      "lines": 68,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "init_messages": {
      "start_point": [
        1179,
        0
      ],
      "end_point": [
        1198,
        1
      ],
      "content": "static void\ninit_messages (void)\n{\n  msg_cant_find_node   = _(\"Cannot find node '%s'\");\n  msg_cant_file_node   = _(\"Cannot find node '(%s)%s'\");\n  msg_cant_find_window = _(\"Cannot find a window!\");\n  msg_cant_find_point  = _(\"Point doesn't appear within this window's node!\");\n  msg_cant_kill_last   = _(\"Cannot delete the last window\");\n  msg_no_menu_node     = _(\"No menu in this node\");\n  msg_no_foot_node     = _(\"No footnotes in this node\");\n  msg_no_xref_node     = _(\"No cross references in this node\");\n  msg_no_pointer       = _(\"No '%s' pointer for this node\");\n  msg_unknown_command  = _(\"Unknown Info command '%c'; try '?' for help\");\n  msg_term_too_dumb    = _(\"Terminal type '%s' is not smart enough to run Info\");\n  msg_at_node_bottom   = _(\"You are already at the last page of this node\");\n  msg_at_node_top      = _(\"You are already at the first page of this node\");\n  msg_one_window       = _(\"Only one window\");\n  msg_win_too_small    = _(\"Resulting window would be too small\");\n  msg_cant_make_help   = _(\"Not enough room for a help window, please delete a window\");\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "texinfo/texinfo-6.5/info/info.h": {},
  "texinfo/texinfo-6.5/info/infodoc.c": {
    "dump_map_to_text_buffer": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "static void\ndump_map_to_text_buffer (struct text_buffer *tb, int *prefix,\n                         int prefix_len, Keymap map)\n{\n  register int i;\n  int *new_prefix = xmalloc ((prefix_len + 2) * sizeof (int));\n\n  memcpy (new_prefix, prefix, prefix_len * sizeof (int));\n  new_prefix[prefix_len + 1] = 0;\n\n  for (i = 0; i < KEYMAP_SIZE; i++)\n    {\n      if (i == 128)\n        i = 256;\n      if (i == 128 + KEYMAP_META_BASE)\n        i = 256 + KEYMAP_META_BASE;\n\n      new_prefix[prefix_len] = i;\n      if (map[i].type == ISKMAP)\n        {\n          dump_map_to_text_buffer (tb, new_prefix, prefix_len + 1,\n                                   map[i].value.keymap);\n        }\n      else if (map[i].value.function)\n        {\n          long start_of_line = tb->off;\n          register int last;\n          char *doc, *name;\n\n          /* Hide some key mappings. */\n          if (map[i].value.function\n              && (map[i].value.function->func == info_do_lowercase_version))\n            continue;\n\n          doc = function_documentation (map[i].value.function);\n          name = function_name (map[i].value.function);\n\n          if (!*doc)\n            continue;\n\n          /* Find out if there is a series of identical functions, as in\n             add-digit-to-numeric-arg. */\n          for (last = i + 1; last < KEYMAP_SIZE; last++)\n            if ((map[last].type != ISFUNC) ||\n                (map[last].value.function != map[i].value.function))\n              break;\n\n          if (last - 1 != i)\n            {\n              text_buffer_printf (tb, \"%s .. \", pretty_keyseq (new_prefix));\n              new_prefix[prefix_len] = last - 1;\n              text_buffer_printf (tb, \"%s\", pretty_keyseq (new_prefix));\n              i = last - 1;\n            }\n          else\n            text_buffer_printf (tb, \"%s\", pretty_keyseq (new_prefix));\n\n          while (tb->off - start_of_line < 8)\n            text_buffer_printf (tb, \" \");\n\n          /* Print the name of the function, and some padding before the\n             documentation string is printed. */\n          {\n            int length_so_far;\n            int desired_doc_start = 40;\n\n            text_buffer_printf (tb, \"(%s)\", name);\n            length_so_far = tb->off - start_of_line;\n\n            if ((desired_doc_start + strlen (doc))\n                >= (unsigned int) the_screen->width)\n              text_buffer_printf (tb, \"\\n     \");\n            else\n              {\n                while (length_so_far < desired_doc_start)\n                  {\n                    text_buffer_printf (tb, \" \");\n                    length_so_far++;\n                  }\n              }\n          }\n          text_buffer_printf (tb, \"%s\\n\", doc);\n        }\n    }\n  free (new_prefix);\n}",
      "lines": 86,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_internal_info_help_node": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        253,
        1
      ],
      "content": "static void\ncreate_internal_info_help_node (int help_is_only_window_p)\n{\n  register int i;\n  NODE *node;\n  char *exec_keys;\n\n  int printed_one_mx = 0;\n  struct text_buffer msg;\n  char *infopath_str = infopath_string ();\n\n  text_buffer_init (&msg);\n\n  for (i = 0; info_internal_help_text[i]; i++)\n    text_buffer_printf (&msg, replace_in_documentation\n                        (_(info_internal_help_text[i]),\n                         help_is_only_window_p), NULL, NULL, NULL);\n\n  text_buffer_printf (&msg, \"---------------------\\n\");\n  text_buffer_printf (&msg, _(\"This is GNU Info version %s.  \"), VERSION);\n  text_buffer_printf (&msg, _(\"The current search path is:\\n\"));\n  text_buffer_printf (&msg, \"%s\\n\", infopath_str);\n  text_buffer_printf (&msg, \"---------------------\\n\\n\");\n  free (infopath_str);\n\n  text_buffer_printf (&msg, _(\"Commands available in Info windows:\\n\\n\"));\n  dump_map_to_text_buffer (&msg, 0, 0, info_keymap);\n  text_buffer_printf (&msg, \"---------------------\\n\\n\");\n  text_buffer_printf (&msg, _(\"Commands available in the echo area:\\n\\n\"));\n  dump_map_to_text_buffer (&msg, 0, 0, echo_area_keymap);\n\n  /* Get a list of commands which have no keystroke equivs. */\n  exec_keys = where_is (info_keymap, InfoCmd(info_execute_command));\n  if (exec_keys)\n    exec_keys = xstrdup (exec_keys);\n  for (i = 0; function_doc_array[i].func; i++)\n    {\n      InfoCommand *cmd = &function_doc_array[i];\n\n      if (cmd->func != info_do_lowercase_version\n          && !where_is_internal (info_keymap, cmd)\n          && !where_is_internal (echo_area_keymap, cmd))\n        {\n          if (!printed_one_mx)\n            {\n              text_buffer_printf (&msg, \"---------------------\\n\\n\");\n              if (exec_keys && exec_keys[0])\n                text_buffer_printf (&msg,\n                    _(\"The following commands can only be invoked via \"\n                      \"%s:\\n\\n\"),\n                    exec_keys);\n              else\n                text_buffer_printf (&msg,\n                   _(\"The following commands cannot be invoked at all:\\n\\n\"));\n              printed_one_mx = 1;\n            }\n\n          text_buffer_printf (&msg,\n             \"%s %s\\n     %s\\n\",\n             exec_keys,\n             function_doc_array[i].func_name,\n             replace_in_documentation (strlen (function_doc_array[i].doc)\n               ? _(function_doc_array[i].doc) : \"\", 0)\n            );\n\n        }\n    }\n\n  free (exec_keys);\n\n  node = text_buffer_to_node (&msg);\n\n  internal_info_help_node = node;\n\n  name_internal_node (internal_info_help_node, xstrdup (info_help_nodename));\n}",
      "lines": 76,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "info_find_or_create_help_window": {
      "start_point": [
        261,
        0
      ],
      "end_point": [
        332,
        1
      ],
      "content": "static WINDOW *\ninfo_find_or_create_help_window (void)\n{\n  int help_is_only_window_p;\n  WINDOW *eligible = NULL;\n  WINDOW *help_window = get_internal_info_window (info_help_nodename);\n\n  /* Close help window if in it already. */\n  if (help_window && help_window == active_window)\n    {\n      info_delete_window_internal (help_window);\n      return NULL;\n    }\n\n  /* If we couldn't find the help window, then make it. */\n  if (!help_window)\n    {\n      WINDOW *window;\n      int max = 0;\n\n      for (window = windows; window; window = window->next)\n        {\n          if (window->height > max)\n            {\n              max = window->height;\n              eligible = window;\n            }\n        }\n\n      if (!eligible)\n        {\n          info_error (\"%s\", msg_cant_make_help);\n          return NULL;\n        }\n    }\n\n  /* Make sure that we have a node containing the help text.  The\n     argument is false if help will be the only window (so l must be used\n     to quit help), true if help will be one of several visible windows\n     (so CTRL-x 0 must be used to quit help).  */\n  help_is_only_window_p = ((help_window && !windows->next)\n        || (!help_window && eligible->height < HELP_SPLIT_SIZE));\n  create_internal_info_help_node (help_is_only_window_p);\n\n  /* Either use the existing window to display the help node, or create\n     a new window if there was no existing help window. */\n  if (!help_window)\n    { /* Split the largest window into 2 windows, and show the help text\n         in that window. */\n      if (eligible->height >= HELP_SPLIT_SIZE)\n        {\n          active_window = eligible;\n          help_window = window_make_window ();\n          info_set_node_of_window (help_window, internal_info_help_node);\n        }\n      else\n        {\n          info_set_node_of_window (active_window, internal_info_help_node);\n          help_window = active_window;\n        }\n    }\n  else\n    { /* Case where help node always gets regenerated, and we have an\n         existing window in which to place the node. */\n      if (active_window != help_window)\n        {\n          active_window = help_window;\n        }\n      info_set_node_of_window (active_window, internal_info_help_node);\n    }\n  return help_window;\n}",
      "lines": 72,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "WINDOW",
        "*\ninfo_find_or_create_help_window (void)",
        "*"
      ]
    },
    "function_documentation": {
      "start_point": [
        418,
        0
      ],
      "end_point": [
        426,
        1
      ],
      "content": "char *\nfunction_documentation (InfoCommand *cmd)\n{\n  char *doc;\n\n  doc = cmd->doc;\n\n  return replace_in_documentation ((strlen (doc) == 0) ? doc : _(doc), 0);\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "char",
        "*\nfunction_documentation (InfoCommand *cmd)",
        "*"
      ]
    },
    "function_name": {
      "start_point": [
        430,
        0
      ],
      "end_point": [
        434,
        1
      ],
      "content": "char *\nfunction_name (InfoCommand *cmd)\n{\n  return cmd->func_name;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nfunction_name (InfoCommand *cmd)",
        "*"
      ]
    },
    "named_function": {
      "start_point": [
        437,
        0
      ],
      "end_point": [
        450,
        1
      ],
      "content": "InfoCommand *\nnamed_function (char *name)\n{\n  register int i;\n\n  for (i = 0; function_doc_array[i].func; i++)\n    if (strcmp (function_doc_array[i].func_name, name) == 0)\n      break;\n\n  if (!function_doc_array[i].func)\n    return 0;\n  else\n    return &function_doc_array[i];\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "InfoCommand",
        "*\nnamed_function (char *name)",
        "*"
      ]
    },
    "pretty_keyname": {
      "start_point": [
        534,
        0
      ],
      "end_point": [
        607,
        1
      ],
      "content": "char *\npretty_keyname (int key)\n{\n  static char rep_buffer[30];\n  char *rep;\n\n  if (key >= KEYMAP_META_BASE)\n    {\n      char temp[20];\n\n      rep = pretty_keyname (key - KEYMAP_META_BASE);\n\n      sprintf (temp, \"M-%s\", rep);\n      strcpy (rep_buffer, temp);\n      rep = rep_buffer;\n    }\n  else if (Control_p (key))\n    {\n      switch (key)\n        {\n        case '\\n': rep = \"LFD\"; break;\n        case '\\t': rep = \"TAB\"; break;\n        case '\\r': rep = \"RET\"; break;\n        case ESC:  rep = \"ESC\"; break;\n\n        default:\n          sprintf (rep_buffer, \"C-%c\", UnControl (key));\n          rep = rep_buffer;\n        }\n    }\n  else if (key >= 256)\n    switch (key)\n      {\n      case KEY_RIGHT_ARROW:\n        rep = \"Right\"; break;\n      case KEY_LEFT_ARROW:\n        rep = \"Left\"; break;\n      case KEY_UP_ARROW:\n        rep = \"Up\"; break;\n      case KEY_DOWN_ARROW:\n        rep = \"Down\"; break;\n      case KEY_PAGE_UP:\n        rep = \"PgUp\"; break;\n      case KEY_PAGE_DOWN:\n        rep = \"PgDn\"; break;\n      case KEY_HOME:\n        rep = \"Home\"; break;\n      case KEY_END:\n        rep = \"End\"; break;\n      case KEY_DELETE:\n        rep = \"DEL\"; break;\n      case KEY_INSERT:\n        rep = \"INS\"; break;\n      case KEY_BACK_TAB:\n        rep = \"BackTab\"; break;\n      case KEY_MOUSE:\n        rep = \"(mouse event)\"; break;\n      default:\n        rep = \"(unknown key)\"; break; /* This shouldn't be displayed. */\n      }\n  else\n    {\n      switch (key)\n        {\n        case ' ': rep = \"SPC\"; break;\n        case DEL: rep = \"DEL\"; break;\n        default:\n          rep_buffer[0] = key;\n          rep_buffer[1] = '\\0';\n          rep = rep_buffer;\n        }\n    }\n  return rep;\n}",
      "lines": 74,
      "depth": 14,
      "decorators": [
        "char",
        "*\npretty_keyname (int key)",
        "*"
      ]
    },
    "pretty_keyseq": {
      "start_point": [
        611,
        0
      ],
      "end_point": [
        635,
        1
      ],
      "content": "char *\npretty_keyseq (int *keyseq)\n{\n  static struct text_buffer rep = { 0 };\n\n  if (!text_buffer_base (&rep))\n    text_buffer_init (&rep);\n  else\n    text_buffer_reset (&rep);\n\n  if (!*keyseq)\n    return \"\";\n\n  while (1)\n    {\n      text_buffer_printf (&rep, \"%s\", pretty_keyname (keyseq[0]));\n      keyseq++;\n\n      if (!*keyseq)\n        break;\n\n      text_buffer_add_char (&rep, ' ');\n    }\n  return text_buffer_base (&rep);\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "char",
        "*\npretty_keyseq (int *keyseq)",
        "*"
      ]
    },
    "replace_in_documentation": {
      "start_point": [
        639,
        0
      ],
      "end_point": [
        743,
        1
      ],
      "content": "char *\nreplace_in_documentation (const char *string, int help_is_only_window_p)\n{\n  register int i, start;\n  static struct text_buffer txtresult = {0};\n\n  text_buffer_free (&txtresult);\n  text_buffer_init (&txtresult);\n  text_buffer_alloc (&txtresult, strlen (string));\n\n  start = 0;\n\n  /* Skip to the beginning of a replaceable function. */\n  for (i = start; string[i]; i++)\n    {\n      int j = i + 1;\n\n      /* Is this the start of a replaceable function name? */\n      if (string[i] == '\\\\')\n        {\n          char *fmt = NULL;\n\n          if(string[j] == '%')\n            {\n              if (string[++j] == '-')\n                j++;\n              if (isdigit(string[j]))\n                {\n                  while (isdigit(string[j]))\n                    j++;\n                  if (string[j] == '.' && isdigit(string[j + 1]))\n                    {\n                      j += 1;\n                      while (isdigit(string[j]))\n                        j++;\n                    }\n                  fmt = xmalloc (j - i + 2);\n                  strncpy (fmt, string + i + 1, j - i);\n                  fmt[j - i - 1] = 's';\n                  fmt[j - i] = '\\0';\n                }\n              else\n                j = i + 1;\n            }\n          if (string[j] == '[')\n            {\n              char *rep_name, *fun_name, *rep;\n              InfoCommand *command;\n              unsigned replen;\n\n              /* Copy in the old text. */\n              text_buffer_add_string (&txtresult, string + start, i - start);\n              start = j + 1;\n\n              /* Move to the end of the function name. */\n              for (i = start; string[i] && (string[i] != ']'); i++);\n\n              rep_name = xmalloc (1 + i - start);\n              strncpy (rep_name, string + start, i - start);\n              rep_name[i - start] = '\\0';\n\n              start = i;\n              if (string[start] == ']')\n                start++;\n\n              fun_name = rep_name;\n              if (strcmp (rep_name, \"quit-help\") == 0)\n                {\n                  /* Special case for help window.  If we have only one window \n                     (because the window size was too small to split it), we \n                     have to quit help by going back one node in the history \n                     list, not deleting the window.  */\n\n                  fun_name = help_is_only_window_p ? \"history-node\"\n                                                   : \"get-help-window\";\n                }\n\n              /* Find a key which invokes this function in the info_keymap. */\n              command = named_function (fun_name);\n              free (rep_name);\n\n              /* If the internal documentation string fails, there is a\n                 serious problem with the associated command's documentation.\n                 We croak so that it can be fixed immediately. */\n              if (!command)\n                abort ();\n\n              rep = where_is (info_keymap, command);\n              if (!rep)\n                rep = \"N/A\";\n              replen = strlen (rep);\n\n              if (fmt)\n                text_buffer_printf (&txtresult, fmt, rep);\n              else\n                text_buffer_add_string (&txtresult, rep, replen);\n            }\n\n          free (fmt);\n        }\n    }\n  text_buffer_add_string (&txtresult,\n                          string + start, strlen (string + start) + 1);\n  return text_buffer_base (&txtresult);\n}",
      "lines": 105,
      "depth": 18,
      "decorators": [
        "char",
        "*\nreplace_in_documentation (const char *string, int help_is_only_window_p)",
        "*"
      ]
    },
    "where_is": {
      "start_point": [
        751,
        0
      ],
      "end_point": [
        780,
        1
      ],
      "content": "char *\nwhere_is (Keymap map, InfoCommand *cmd)\n{\n  char *rep;\n\n  if (!where_is_rep_size)\n    where_is_rep = xmalloc (where_is_rep_size = 100);\n  where_is_rep_index = 0;\n\n  rep = where_is_internal (map, cmd);\n\n  /* If it couldn't be found, return \"M-x Foo\" (or equivalent). */\n  if (!rep)\n    {\n      char *name;\n\n      name = function_name (cmd);\n      if (!name)\n        return NULL; /* no such function */\n\n      rep = where_is_internal (map, InfoCmd(info_execute_command));\n      if (!rep)\n        return \"\"; /* function exists but can't be got to by user */\n\n      sprintf (where_is_rep, \"%s %s\", rep, name);\n\n      rep = where_is_rep;\n    }\n  return rep;\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "char",
        "*\nwhere_is (Keymap map, InfoCommand *cmd)",
        "*"
      ]
    },
    "where_is_internal": {
      "start_point": [
        784,
        0
      ],
      "end_point": [
        794,
        1
      ],
      "content": "static char *\nwhere_is_internal (Keymap map, InfoCommand *cmd)\n{\n  register FUNCTION_KEYSEQ *k;\n\n  for (k = cmd->keys; k; k = k->next)\n    if (k->map == map)\n      return pretty_keyseq (k->keyseq);\n\n  return NULL;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nwhere_is_internal (Keymap map, InfoCommand *cmd)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/info/infokey.c": {
    "compile": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        583,
        1
      ],
      "content": "int\ncompile (FILE *fp, const char *filename, int *suppress_info, int *suppress_ea)\n{\n  int error = 0; /* Set if there was a fatal error in reading init file. */\n  char rescan = 0; /* Whether to reuse the same character when moving onto the\n                      next state. */\n  unsigned int lnum = 0;\n  int c = 0;\n\n  /* This parser is a true state machine, with no sneaky fetching\n     of input characters inside the main loop.  In other words, all\n     state is fully represented by the following variables:\n   */\n  enum\n    {\n      start_of_line,\n      start_of_comment,\n      in_line_comment,\n      in_trailing_comment,\n      get_keyseq,\n      got_keyseq,\n      get_action,\n      got_action,\n      get_varname,\n      got_varname,\n      get_equals,\n      got_equals,\n      get_value\n    }\n  state = start_of_line;\n  enum sect_e section = info;\n  enum\n    {\n      normal,\n      slosh,\n      control,\n      octal,\n      special_key\n    }\n  seqstate = normal;\t/* used if state == get_keyseq */\n  char meta = 0;\n  char ocnt = 0;\t/* used if state == get_keyseq && seqstate == octal */\n\n  /* Data is accumulated in the following variables.  The code\n     avoids overflowing these strings, and throws an error\n     where appropriate if a string limit is exceeded.  These string\n     lengths are arbitrary (and should be large enough) and their\n     lengths are not hard-coded anywhere else, so increasing them\n     here will not break anything.  */\n  char oval = 0;\n  char comment[10];\n  unsigned int clen = 0;\n  int seq[20];\n  unsigned int slen = 0;\n  char act[80];\n  unsigned int alen = 0;\n  char varn[80];\n  unsigned int varlen = 0;\n  char val[80];\n  unsigned int vallen = 0;\n\n#define\tTo_seq(c) \\\n\t\t  do { \\\n\t\t    if (slen < sizeof seq/sizeof(int)) \\\n\t\t      seq[slen++] = meta ? KEYMAP_META(c) : (c); \\\n\t\t    else \\\n\t\t      { \\\n\t\t\tsyntax_error(filename, lnum, \\\n\t\t\t\t     _(\"key sequence too long\")); \\\n\t\t\terror = 1; \\\n\t\t      } \\\n\t\t    meta = 0; \\\n\t\t  } while (0)\n\n  while (!error && (rescan || (c = fgetc (fp)) != EOF))\n    {\n      rescan = 0;\n      switch (state)\n\t{\n\tcase start_of_line:\n\t  lnum++;\n\t  if (c == '#')\n\t    state = start_of_comment;\n\t  else if (c != '\\n')\n\t    {\n\t      switch (section)\n\t\t{\n\t\tcase info:\n\t\tcase ea:\n\t\t  state = get_keyseq;\n\t\t  seqstate = normal;\n\t\t  slen = 0;\n\t\t  break;\n\t\tcase var:\n\t\t  state = get_varname;\n\t\t  varlen = 0;\n\t\t  break;\n\t\t}\n\t      rescan = 1;\n\t    }\n\t  break;\n\n\tcase start_of_comment:\n\t  clen = 0;\n\t  state = in_line_comment;\n\t  /* fall through */\n\tcase in_line_comment:\n\t  if (c == '\\n')\n\t    {\n\t      state = start_of_line;\n\t      comment[clen] = '\\0';\n\t      if (strcmp (comment, \"info\") == 0)\n\t\tsection = info;\n\t      else if (strcmp (comment, \"echo-area\") == 0)\n\t\tsection = ea;\n\t      else if (strcmp (comment, \"var\") == 0)\n\t\tsection = var;\n\t      else if (strcmp (comment, \"stop\") == 0\n\t\t       && (section == info || section == ea))\n                {\n                  if (section == info)\n                    *suppress_info = 1;\n                  else\n                    *suppress_ea = 1;\n                }\n\t    }\n\t  else if (clen < sizeof comment - 1)\n\t    comment[clen++] = c;\n\t  break;\n\n\tcase in_trailing_comment:\n\t  if (c == '\\n')\n\t    state = start_of_line;\n\t  break;\n\n\tcase get_keyseq:\n\t  switch (seqstate)\n\t    {\n\t    case normal:\n\t      if (c == '\\n' || isspace (c))\n\t\t{\n\t\t  state = got_keyseq;\n\t\t  rescan = 1;\n\t\t  if (slen == 0)\n\t\t    {\n\t\t      syntax_error (filename, lnum, _(\"missing key sequence\"));\n\t\t      error = 1;\n\t\t    }\n\t\t}\n\t      else if (c == '\\\\')\n\t\tseqstate = slosh;\n\t      else if (c == '^')\n\t\tseqstate = control;\n\t      else\n\t\tTo_seq (c);\n\t      break;\n\n\t    case slosh:\n\t      switch (c)\n\t\t{\n\t\tcase '0': case '1': case '2': case '3':\n\t\tcase '4': case '5': case '6': case '7':\n\t\t  seqstate = octal;\n\t\t  oval = c - '0';\n\t\t  ocnt = 1;\n\t\t  break;\n\t\tcase 'b':\n\t\t  To_seq ('\\b');\n\t\t  seqstate = normal;\n\t\t  break;\n\t\tcase 'e':\n\t\t  To_seq ('\\033');\n\t\t  seqstate = normal;\n\t\t  break;\n\t\tcase 'n':\n\t\t  To_seq ('\\n');\n\t\t  seqstate = normal;\n\t\t  break;\n\t\tcase 'r':\n\t\t  To_seq ('\\r');\n\t\t  seqstate = normal;\n\t\t  break;\n\t\tcase 't':\n\t\t  To_seq ('\\t');\n\t\t  seqstate = normal;\n\t\t  break;\n\t\tcase 'm':\n\t\t  meta = 1;\n\t\t  seqstate = normal;\n\t\t  break;\n\t\tcase 'k':\n\t\t  seqstate = special_key;\n\t\t  break;\n\t\tdefault:\n\t\t  /* Backslash followed by any other char\n\t\t     just means that char.  */\n\t\t  To_seq (c);\n\t\t  seqstate = normal;\n\t\t  break;\n\t\t}\n\t      break;\n\n\t    case octal:\n\t      switch (c)\n\t\t{\n\t\tcase '0': case '1': case '2': case '3':\n\t\tcase '4': case '5': case '6': case '7':\n\t\t  if (++ocnt <= 3)\n\t\t    oval = oval * 8 + c - '0';\n\t\t  if (ocnt == 3)\n\t\t    seqstate = normal;\n\t\t  break;\n\t\tdefault:\n\t\t  ocnt = 4;\n\t\t  seqstate = normal;\n\t\t  rescan = 1;\n\t\t  break;\n\t\t}\n\t      if (seqstate != octal)\n\t\t{\n\t\t  if (oval)\n\t\t    To_seq (oval);\n\t\t  else\n\t\t    {\n\t\t      syntax_error (filename, lnum,\n\t\t\t\t    _(\"NUL character (\\\\000) not permitted\"));\n\t\t      error = 1;\n\t\t    }\n\t\t}\n\t      break;\n\n\t    case special_key:\n\t      switch (c)\n\t\t{\n\t\tcase 'u': To_seq (KEY_UP_ARROW); break;\n\t\tcase 'd': To_seq (KEY_DOWN_ARROW); break;\n\t\tcase 'r': To_seq (KEY_RIGHT_ARROW); break;\n\t\tcase 'l': To_seq (KEY_LEFT_ARROW); break;\n\t\tcase 'U': To_seq (KEY_PAGE_UP); break;\n\t\tcase 'D': To_seq (KEY_PAGE_DOWN); break;\n\t\tcase 'h': To_seq (KEY_HOME); break;\n\t\tcase 'e': To_seq (KEY_END); break;\n\t\tcase 'x': To_seq (KEY_DELETE); break;\n\t\tdefault:  To_seq (c); rescan = 1; break;\n\t\t}\n\t      seqstate = normal;\n\t      break;\n\n\t    case control:\n\t      if (CONTROL (c))\n\t\tTo_seq (CONTROL (c));\n\t      else\n\t\t{\n\t\t  syntax_error (filename, lnum,\n\t\t\t\t_(\"NUL character (^%c) not permitted\"), c);\n\t\t  error = 1;\n\t\t}\n\t      seqstate = normal;\n\t      break;\n\t    }\n\t  break;\n\n\tcase got_keyseq:\n\t  if (isspace (c) && c != '\\n')\n\t    break;\n\t  state = get_action;\n\t  alen = 0;\n\t  /* fall through */\n\tcase get_action:\n\t  if (c == '\\n' || isspace (c))\n\t    {\n\t      int a;\n\n\t      state = got_action;\n\t      rescan = 1;\n\t      if (alen == 0)\n\t\t{\n\t\t  syntax_error (filename, lnum, _(\"missing action name\"));\n\t\t  error = 1;\n\t\t}\n\t      else\n\t\t{\n                  int keymap_bind_keyseq (Keymap, int *, KEYMAP_ENTRY *);\n\n\t\t  act[alen] = '\\0';\n\t\t  a = lookup_action (act);\n                  if (a == A_info_menu_digit)\n\t\t    {\n                      /* Only allow \"1 menu-digit\".  (This is useful if\n                         this default binding is disabled with \"#stop\".)\n                         E.g. do not allow \"b menu-digit\".  */\n                      if (seq[0] != '1' || seq[1] != '\\0'\n                          || section != info)\n                        {\n                          syntax_error (filename, lnum,\n                                 _(\"cannot bind key sequence to menu-digit\"));\n                        }\n                      else\n                        {\n                          /* Bind each key from '1' to '9' to 'menu-digit'. */\n                          KEYMAP_ENTRY ke;\n                          int i;\n                      \n                          ke.type = ISFUNC;\n                          ke.value.function = &function_doc_array[a];\n\n                          for (i = '1'; i <= '9'; i++)\n                            {\n                              seq[0] = i;\n                              keymap_bind_keyseq (info_keymap, seq, &ke);\n                            }\n                        }\n\t\t    }\n\t\t  else if (a == -1)\n\t\t    {\n                      /* Print an error message, but keep going (don't set\n                         error = 1) for compatibility with infokey files aimed\n                         at future versions which may have different\n                         actions. */\n\t\t      syntax_error (filename, lnum, _(\"unknown action `%s'\"),\n\t\t\t\t    act);\n\t\t    }\n                  else\n\t\t    {\n                      KEYMAP_ENTRY ke;\n                      static InfoCommand invalid_function = { 0 };\n                      \n                      ke.type = ISFUNC;\n                      ke.value.function = a != A_INVALID\n                                            ? &function_doc_array[a]\n                                            : &invalid_function;\n                      To_seq (0);\n\n                      if (section == info)\n                        keymap_bind_keyseq (info_keymap, seq, &ke);\n                      else /* section == ea */\n                        keymap_bind_keyseq (echo_area_keymap, seq, &ke);\n\t\t    }\n\t\t}\n\t    }\n\t  else if (alen < sizeof act - 1)\n\t    act[alen++] = c;\n\t  else\n\t    {\n\t      syntax_error (filename, lnum, _(\"action name too long\"));\n\t      error = 1;\n\t    }\n\t  break;\n\n\tcase got_action:\n\t  if (c == '#')\n\t    state = in_trailing_comment;\n\t  else if (c == '\\n')\n\t    state = start_of_line;\n\t  else if (!isspace (c))\n\t    {\n\t      syntax_error (filename, lnum,\n\t\t\t    _(\"extra characters following action `%s'\"),\n\t\t\t    act);\n\t      error = 1;\n\t    }\n\t  break;\n\n\tcase get_varname:\n\t  if (c == '=')\n\t    {\n\t      if (varlen == 0)\n\t\t{\n\t\t  syntax_error (filename, lnum, _(\"missing variable name\"));\n\t\t  error = 1;\n\t\t}\n\t      state = get_value;\n\t      vallen = 0;\n\t    }\n\t  else if (c == '\\n' || isspace (c))\n\t    {\n\t      syntax_error (filename, lnum,\n\t\t\t    _(\"missing `=' immediately after variable name\"));\n\t      error = 1;\n\t    }\n\t  else if (varlen < sizeof varn - 1)\n\t    varn[varlen++] = c;\n\t  else\n\t    {\n\t      syntax_error (filename, lnum, _(\"variable name too long\"));\n\t      error = 1;\n\t    }\n\t  break;\n\n\tcase get_value:\n\t  if (c == '\\n')\n\t    {\n              VARIABLE_ALIST *v;\n\n              state = start_of_line;\n              varn[varlen] = '\\0';\n              val[vallen] = '\\0';\n              v = variable_by_name (varn);\n              if (!v)\n                info_error (_(\"%s: no such variable\"), varn);\n              else if (!set_variable_to_value (v, val, SET_IN_CONFIG_FILE))\n                info_error (_(\"value %s is not valid for variable %s\"),\n                              val, varn);\n\t    }\n\t  else if (vallen < sizeof val - 1)\n\t    val[vallen++] = c;\n\t  else\n\t    {\n\t      syntax_error (filename, lnum, _(\"value too long\"));\n\t      error = 1;\n\t    }\n\t  break;\n\n        case get_equals:\n        case got_equals:\n        case got_varname:\n          break;\n\t}\n    }\n\n#undef To_seq\n\n  return !error;\n}",
      "lines": 424,
      "depth": 22,
      "decorators": [
        "int"
      ]
    },
    "lookup_action": {
      "start_point": [
        587,
        0
      ],
      "end_point": [
        598,
        1
      ],
      "content": "static int\nlookup_action (const char *name)\n{\n  int i;\n\n  if (!strcmp (name, \"invalid\"))\n    return A_INVALID;\n  for (i = 0; function_doc_array[i].func_name; i++)\n    if (!strcmp (function_doc_array[i].func_name, name))\n      return i;\n  return -1;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "syntax_error": {
      "start_point": [
        607,
        0
      ],
      "end_point": [
        619,
        1
      ],
      "content": "static void\nsyntax_error (const char *filename,\n\t      unsigned int linenum, const char *fmt, ...)\n{\n  va_list ap;\n  \n  fprintf (stderr, \"%s: \", program_name);\n  fprintf (stderr, _(\"\\\"%s\\\", line %u: \"), filename, linenum);\n  va_start(ap, fmt);\n  vfprintf (stderr, fmt, ap);\n  va_end(ap);\n  fprintf (stderr, \"\\n\");\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "texinfo/texinfo-6.5/info/infomap.c": {
    "keymap_make_keymap": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "Keymap\nkeymap_make_keymap (void)\n{\n  int i;\n  Keymap keymap;\n\n  keymap = (Keymap)xmalloc (KEYMAP_SIZE * sizeof (KEYMAP_ENTRY));\n\n  for (i = 0; i < KEYMAP_SIZE; i++)\n    {\n      keymap[i].type = ISFUNC;\n      keymap[i].value.function = NULL;\n    }\n\n  return keymap;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "Keymap"
      ]
    },
    "add_function_keyseq": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "static void\nadd_function_keyseq (InfoCommand *function, int *keyseq, Keymap rootmap)\n{\n  FUNCTION_KEYSEQ *ks, *k;\n  int len;\n\n  if (function == NULL ||\n      function == InfoCmd (info_do_lowercase_version))\n    return;\n\n  /* If there is already a key sequence recorded for this key map,\n     don't do anything. */\n  for (k = function->keys; k; k = k->next)\n    if (k->map == rootmap)\n      return;\n\n  ks = xmalloc (sizeof (FUNCTION_KEYSEQ));\n  ks->next = function->keys;\n  ks->map = rootmap;\n  for (len = 0; keyseq[len]; len++);\n  ks->keyseq = xmalloc ((len + 1) * sizeof (int));\n  memcpy (ks->keyseq, keyseq, (len + 1) * sizeof (int));\n\n  function->keys = ks;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "keymap_bind_keyseq": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "void\nkeymap_bind_keyseq (Keymap map, int *keyseq, KEYMAP_ENTRY *keyentry)\n{\n  Keymap m = map;\n  int *s = keyseq;\n  int c;\n\n  if (!s || *s == 0)\n    return;\n\n  while ((c = *s++) != '\\0')\n    {\n      switch (m[c].type)\n        {\n        case ISFUNC:\n          if (m[c].value.function)\n            return; /* There is a function here already. */\n\n          if (*s != '\\0')\n            {\n              m[c].type = ISKMAP;\n              m[c].value.keymap = keymap_make_keymap ();\n            }\n          break;\n\n        case ISKMAP:\n          if (*s == '\\0')\n            return; /* The key sequence we were asked to bind is an initial\n                       subsequence of an already-bound sequence. */\n          break;\n        }\n      if (*s != '\\0')\n        {\n          m = m[c].value.keymap;\n        }\n      else\n        {\n          add_function_keyseq (keyentry->value.function, keyseq, map);\n          m[c] = *keyentry;\n        }\n    }\n\n  return;\n}",
      "lines": 44,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "fetch_user_maps": {
      "start_point": [
        564,
        0
      ],
      "end_point": [
        606,
        1
      ],
      "content": "static int\nfetch_user_maps (char *init_file)\n{\n  char *filename = NULL;\n  char *homedir;\n  FILE *inf;\n\n  /* In infokey.c */\n  int compile (FILE *fp, const char *filename, int *, int *);\n\n  /* Find and open file. */\n  if (init_file)\n    filename = xstrdup (init_file);\n  else if ((homedir = getenv (\"HOME\")) != NULL\n#ifdef __MINGW32__\n\t    || (homedir = getenv (\"USERPROFILE\")) != NULL\n#endif\n\t  )\n    {\n      filename = xmalloc (strlen (homedir) + 2 + strlen (INFOKEY_FILE));\n      strcpy (filename, homedir);\n      strcat (filename, \"/\");\n      strcat (filename, INFOKEY_FILE);\n    }\n#if defined(__MSDOS__) || defined(__MINGW32__)\n  /* Poor baby, she doesn't have a HOME...  */\n  else\n    filename = xstrdup (INFOKEY_FILE); /* try current directory */\n#endif\n  inf = fopen (filename, \"r\");\n  if (!inf)\n    {\n      free (filename);\n      if (init_file)\n        info_error (_(\"could not open init file %s\"), init_file);\n      return 0;\n    }\n\n  compile (inf, filename, &sup_info, &sup_ea);\n\n  free (filename);\n  return 1;\n}",
      "lines": 43,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "section_to_keymaps": {
      "start_point": [
        610,
        0
      ],
      "end_point": [
        678,
        1
      ],
      "content": "static void\nsection_to_keymaps (Keymap map, int *table, unsigned int len)\n{\n  int k;\n  Keymap esc_map;\n\n  int *p;\n  int *seq;\n  enum { getseq, gotseq, getaction } state = getseq;\n  \n  for (p = table; (unsigned int) (p - table) < len; p++)\n    {\n      switch (state)\n\t{\n\tcase getseq:\n\t  if (*p)\n\t    {\n\t      seq = p;\n\t      state = gotseq;\n\t    }\n\t  break;\n\t  \n\tcase gotseq:\n\t  if (!*p)\n            state = getaction;\n\t  break;\n\t  \n\tcase getaction:\n\t  {\n\t    unsigned int action = *p;\n\t    KEYMAP_ENTRY ke;\n\t    \n\t    state = getseq;\n\n            ke.type = ISFUNC;\n            ke.value.function = action < A_NCOMMANDS ?\n                                &function_doc_array[action]\n                                : NULL;\n            keymap_bind_keyseq (map, seq, &ke);\n\t  }\n\t  break;\n\t}\n    }\n  if (state != getseq)\n    abort ();\n\n  /* Go through map and bind ESC x to the same function as M-x if it is not \n     bound already. */\n  if (!map[ESC].value.function)\n    {\n      map[ESC].type = ISKMAP;\n      map[ESC].value.keymap = keymap_make_keymap ();\n    }\n\n  if (map[ESC].type != ISKMAP)\n    return; /* ESC is bound to a command. */\n\n  esc_map = map[ESC].value.keymap;\n  for (k = 1; k < KEYMAP_META_BASE; k++)\n    {\n      if (map[k + KEYMAP_META_BASE].type == ISFUNC\n          && esc_map[k].value.function == 0)\n        {\n          esc_map[k].type = ISFUNC;\n          esc_map[k].value.function = map[k + KEYMAP_META_BASE].value.function;\n        }\n    }\n  return;\n}",
      "lines": 69,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_init_file": {
      "start_point": [
        682,
        0
      ],
      "end_point": [
        742,
        1
      ],
      "content": "void\nread_init_file (char *init_file)\n{\n  int *info_keys, *ea_keys; /* Pointers to keymap tables. */\n  long info_keys_len, ea_keys_len; /* Sizes of keymap tables. */\n\n  int i;\n\n  if (!info_keymap)\n    {\n      info_keymap = keymap_make_keymap ();\n      echo_area_keymap = keymap_make_keymap ();\n    }\n\n  if (!vi_keys_p)\n    {\n      info_keys = default_emacs_like_info_keys;\n      info_keys_len = sizeof (default_emacs_like_info_keys)/sizeof (int);\n      ea_keys = default_emacs_like_ea_keys;\n      ea_keys_len = sizeof (default_emacs_like_ea_keys)/sizeof (int);\n    }\n  else\n    {\n      info_keys = default_vi_like_info_keys;\n      info_keys_len = sizeof (default_vi_like_info_keys)/sizeof(int);\n      ea_keys = default_vi_like_ea_keys;\n      ea_keys_len = sizeof (default_vi_like_ea_keys)/sizeof(int);\n    }\n\n  /* Get user-defined keys and variables.  */\n  if (fetch_user_maps (init_file))\n    {\n      if (sup_info)\n        info_keys = 0; /* Suppress default bindings. */\n      if (sup_ea)\n        ea_keys = 0;\n    }\n\n  /* Apply the default bindings, unless the user says to suppress\n     them. */\n  if (info_keys)\n    section_to_keymaps (info_keymap, info_keys, info_keys_len);\n  if (ea_keys)\n    section_to_keymaps (echo_area_keymap, ea_keys, ea_keys_len);\n\n  for (i = 'A'; i < ('Z' + 1); i++)\n    {\n      if (!info_keymap[i].value.function)\n        {\n          info_keymap[i].type = ISFUNC;\n          info_keymap[i].value.function = InfoCmd (info_do_lowercase_version);\n        }\n\n      if (!info_keymap[KEYMAP_META(i)].value.function)\n        {\n          info_keymap[KEYMAP_META(i)].type = ISFUNC;\n          info_keymap[KEYMAP_META(i)].value.function\n            = InfoCmd (info_do_lowercase_version);\n        }\n    }\n}",
      "lines": 61,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "texinfo/texinfo-6.5/info/infomap.h": {},
  "texinfo/texinfo-6.5/info/infopath.c": {
    "infopath_init": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "void\ninfopath_init ()\n{\n  /* Initialize INFOPATH.\n     Highest priority is the environment variable, if set\n     Then comes the user's INFODIR from the Makefile.\n     The hardwired default settings (filesys.h) are the lowest priority. */\n  char *path_from_env = getenv (\"INFOPATH\");\n\n  if (path_from_env)\n    {\n      infopath_add (path_from_env);\n    }\n\n  if (!infopath_no_defaults_p)\n    {\n#ifdef INFODIR /* $infodir, set by configure script in Makefile */\n      infopath_add (INFODIR);\n#ifdef INFODIR2 /* $datadir/info, which could be different. */\n      if (!STREQ (INFODIR, INFODIR2))\n        infopath_add (INFODIR2);\n#endif /* INFODIR2 */\n#endif /* INFODIR */\n    }\n\n  if (!path_from_env)\n    {\n      infopath_add (DEFAULT_INFOPATH);\n    }\n  else\n    { \n      /* Only insert default path if there is a trailing : on INFOPATH. */\n\n      unsigned len = strlen (path_from_env);\n      if (len && path_from_env[len - 1] == PATH_SEP[0])\n\t{\n\t  path_from_env[len - 1] = 0;\n\t  infopath_add (DEFAULT_INFOPATH);\n\t}\n    }\n}",
      "lines": 41,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "infopath_string": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "char *\ninfopath_string ()\n{\n  struct text_buffer path;\n  int dir_idx;\n  char *this_dir;\n\n  this_dir = infopath_first (&dir_idx);\n  if (!this_dir)\n    return \"\";\n\n  text_buffer_init (&path);\n\n  while (1)\n    {\n      text_buffer_printf (&path, \"%s\", this_dir);\n      this_dir = infopath_next (&dir_idx);\n      if (!this_dir)\n        break;\n      text_buffer_add_char (&path, ':');\n    }\n  return text_buffer_base (&path); \n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "char",
        "*\ninfopath_string ()",
        "*"
      ]
    },
    "build_infopath_from_path": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "static void\nbuild_infopath_from_path (void)\n{\n  char *path_from_env, *temp_dirname;\n  int dirname_index = 0;\n  struct stat finfo;\n\n  path_from_env = getenv (\"PATH\");\n\n  while ((temp_dirname = extract_colon_unit (path_from_env, &dirname_index)))\n    {\n      unsigned int i, dir = 0;\n\n      /* Find end of DIRNAME/ (but ignore \"/\") */\n      for (i = 0; temp_dirname[i]; i++)\n        if (i && IS_SLASH (temp_dirname[i]))\n          dir = i + 1;\n\n      /* Discard path elements ending with \"/\", \"/.\", or \"/..\" */\n      if (!temp_dirname[dir] || STREQ (temp_dirname + dir, \".\") || STREQ (temp_dirname + dir, \".\"))\n        dir = 0;\n      \n      if (dir)\n        {\n          temp_dirname = xrealloc (temp_dirname, dir + strlen (\"share/info\") +1);\n\n          /* first try DIRNAME/share/info */\n          strcpy (temp_dirname + dir, \"share/info\");\n          if (stat (temp_dirname, &finfo) != 0 || !S_ISDIR (finfo.st_mode))\n            {\n              /* then try DIRNAME/info */\n              strcpy (temp_dirname + dir, \"info\");\n              if (stat (temp_dirname, &finfo) != 0 || !S_ISDIR (finfo.st_mode))\n                dir = 0;\n            }\n        }\n\n      if (dir)\n        infopath_add_dir (temp_dirname);\n      else\n        free (temp_dirname);\n    }\n}",
      "lines": 43,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "infopath_add_dir": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "static void\ninfopath_add_dir (char *path)\n{\n  struct stat dirinfo;\n  INFO_DIR *entry;\n  int i;\n\n  if (stat (path, &dirinfo) == -1)\n    {\n      debug (2, (\"inaccessible directory %s not added to INFOPATH\", path));\n      free (path);\n      return; /* Doesn't exist, or not accessible. */\n    }\n\n  for (i = 0; i < infodirs_index; i++)\n    {\n      if (   dirinfo.st_ino == infodirs[i]->inode\n          && dirinfo.st_dev == infodirs[i]->device\n          /* On MS-Windows, `stat' returns zero as the inode, so we\n             use file-name comparison instead for that OS.  */\n          && (infodirs[i]->inode != 0 || fncmp (path, infodirs[i]->name) == 0))\n        {\n          debug (2, (\"duplicate directory %s not added to INFOPATH\", path));\n          free (path);\n          return; /* We have it already. */\n        }\n    }\n\n  debug (2, (\"adding %s to INFOPATH\", path));\n  entry = xmalloc (sizeof (INFO_DIR));\n  entry->name = path;\n  entry->inode = dirinfo.st_ino;\n  entry->device = dirinfo.st_dev;\n  add_pointer_to_array (entry, infodirs_index, infodirs, infodirs_slots, 8);\n}",
      "lines": 35,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "infopath_add": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        212,
        1
      ],
      "content": "void\ninfopath_add (char *path)\n{\n  int idx = 0;\n  char *dirname;\n\n  while (dirname = extract_colon_unit (path, &idx))\n    {\n      if (!strcmp (\"PATH\", dirname))\n        {\n          free (dirname);\n          build_infopath_from_path ();\n        }\n      else\n        infopath_add_dir (dirname);\n    }\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "infopath_next": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        227,
        1
      ],
      "content": "char *\ninfopath_next (int *idx)\n{\n  INFO_DIR *entry;\n \n  if (!infodirs)\n   return 0;\n  entry = infodirs[(*idx)++];\n  if (!entry)\n    return 0;\n  return entry->name;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "char",
        "*\ninfopath_next (int *idx)",
        "*"
      ]
    },
    "infopath_first": {
      "start_point": [
        229,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "char *\ninfopath_first (int *idx)\n{\n  *idx = 0;\n  return infopath_next (idx);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\ninfopath_first (int *idx)",
        "*"
      ]
    },
    "extract_colon_unit": {
      "start_point": [
        239,
        0
      ],
      "end_point": [
        264,
        1
      ],
      "content": "char *\nextract_colon_unit (char *string, int *idx)\n{\n  unsigned int i = (unsigned int) *idx;\n  unsigned int start = i;\n\n  if (!string || i >= strlen (string))\n    return NULL;\n\n  if (!string[i]) /* end of string */\n    return NULL;\n\n  /* Advance to next PATH_SEP.  */\n  while (string[i] && string[i] != PATH_SEP[0])\n    i++;\n\n  {\n    char *value = xmalloc ((i - start) + 1);\n    strncpy (value, &string[start], (i - start));\n    value[i - start] = 0;\n\n    i++; /* move past PATH_SEP */\n    *idx = i;\n    return value;\n  }\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "char",
        "*\nextract_colon_unit (char *string, int *idx)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/info/m-x.c": {
    "read_function_name": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "char *\nread_function_name (char *prompt, WINDOW *window)\n{\n  register int i;\n  char *line;\n  REFERENCE **array = NULL;\n  size_t array_index = 0, array_slots = 0;\n\n  /* Make an array of REFERENCE which actually contains the names of\n     the functions available in Info. */\n  for (i = 0; function_doc_array[i].func; i++)\n    {\n      REFERENCE *entry;\n\n      entry = xmalloc (sizeof (REFERENCE));\n      entry->label = xstrdup (function_doc_array[i].func_name);\n      entry->nodename = NULL;\n      entry->filename = NULL;\n\n      add_pointer_to_array (entry, array_index, array, array_slots, 200);\n    }\n\n  line = info_read_completing_in_echo_area (prompt, array);\n  info_free_references (array);\n\n  return line;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "char",
        "*\nread_function_name (char *prompt, WINDOW *window)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/info/makedoc.c": {
    "main": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  register int i;\n  int tags_only = 0;\n  FILE *funs_stream, *doc_stream;\n\n#if STRIP_DOT_EXE\n  {\n    char *dot = strrchr (argv[0], '.');\n\n    if (dot && FILENAME_CMP (dot, \".exe\") == 0)\n      *dot = 0;\n  }\n#endif\n\n  for (i = 1; i < argc; i++)\n    if (strcmp (argv[i], \"-tags\") == 0)\n      {\n        tags_only++;\n        break;\n      }\n\n  if (tags_only)\n    {\n      funs_filename = NULL_DEVICE;\n      doc_filename = NULL_DEVICE;\n    }\n\n  /* The order of these calls depends exactly on the order in the\n     Makefile.{in,am}, or they might fail on filesystems with\n     high-precision times; see also the fclose calls below.  */\n  funs_stream = must_fopen (funs_filename, \"w\");\n  doc_stream = must_fopen (doc_filename, \"w\");\n\n  fprintf (funs_stream,\n      \"/* %s -- Generated declarations for Info commands. */\\n\\n\"\n      \"#include \\\"info.h\\\"\\n\"\n      \"#include \\\"window.h\\\"\\n\",\n      funs_filename);\n\n  for (i = 0; doc_header[i]; i++)\n    {\n      fprintf (doc_stream, doc_header[i], argv[0], argv[0]);\n      fprintf (doc_stream, \"\\n\");\n    }\n\n  fprintf (doc_stream,\n           _(\"   Source files groveled to make this file include:\\n\\n\"));\n\n  for (i = 1; i < argc; i++)\n    fprintf (doc_stream, \"\\t%s\\n\", argv[i]);\n\n  fprintf (doc_stream, \"\\n\");\n  for (i = 0; doc_header_1[i]; i++)\n    fprintf (doc_stream, \"%s\\n\", doc_header_1[i]);\n\n  init_func_key(0);\n\n  for (i = 1; i < argc; i++)\n    {\n      char *curfile;\n      curfile = argv[i];\n\n      if (*curfile == '-')\n        continue;\n\n      fprintf (doc_stream, \"/* Commands found in \\\"%s\\\". */\\n\", curfile);\n      fprintf (funs_stream, \"\\n/* Functions declared in \\\"%s\\\". */\\n\",\n               curfile);\n\n      process_one_file (curfile, doc_stream, funs_stream);\n    }\n\n  fprintf (doc_stream, \"   { NULL, NULL, NULL, NULL }\\n};\\n\");\n  fprintf (funs_stream, \"\\n#define A_NCOMMANDS %u\\n\", next_func_key());\n\n  /* The order of these calls also depends exactly on the order in the\n   * Makefile.{in,am}; see the must_fopen calls above.  */\n  fclose (funs_stream);\n  fclose (doc_stream);\n\n  if (tags_only)\n    maybe_dump_tags (stdout);\n  return 0;\n}",
      "lines": 86,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "maybe_dump_tags": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "static void\nmaybe_dump_tags (FILE *stream)\n{\n  size_t i;\n\n  /* Emacs needs its TAGS file to be in Unix text format (i.e., only\n     newline at end of every line, no CR), so when we generate a\n     TAGS table, we must switch the output stream to binary mode.\n     (If the table is written to a terminal, this is obviously not needed.) */\n  SET_BINARY (fileno (stream));\n\n  /* Print out the information for each block. */\n  for (i = 0; i < emacs_tags_index; i++)\n    {\n      size_t j;\n      register EMACS_TAG_BLOCK *block;\n      register EMACS_TAG *etag;\n      long block_len;\n\n      block_len = 0;\n      block = emacs_tags[i];\n\n      /* Calculate the length of the dumped block first. */\n      for (j = 0; j < block->entries_index; j++)\n        {\n          char digits[30];\n          etag = block->entries[j];\n          block_len += 3 + strlen (etag->name);\n          sprintf (digits, \"%d,%ld\", etag->line, etag->char_offset);\n          block_len += strlen (digits);\n        }\n\n      /* Print out the defining line. */\n      fprintf (stream, \"\\f\\n%s,%ld\\n\", block->filename, block_len);\n\n      /* Print out the individual tags. */\n      for (j = 0; j < block->entries_index; j++)\n        {\n          etag = block->entries[j];\n\n          fprintf (stream, \"%s,\\177%d,%ld\\n\",\n                   etag->name, etag->line, etag->char_offset);\n        }\n    }\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "make_emacs_tag_block": {
      "start_point": [
        228,
        0
      ],
      "end_point": [
        240,
        1
      ],
      "content": "static EMACS_TAG_BLOCK *\nmake_emacs_tag_block (char *filename)\n{\n  EMACS_TAG_BLOCK *block;\n\n  block = xmalloc (sizeof (EMACS_TAG_BLOCK));\n  block->filename = xstrdup (filename);\n  block->entrylen = 0;\n  block->entries = NULL;\n  block->entries_index = 0;\n  block->entries_slots = 0;\n  return block;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "EMACS_TAG_BLOCK",
        "*\nmake_emacs_tag_block (char *filename)",
        "*"
      ]
    },
    "add_tag_to_block": {
      "start_point": [
        242,
        0
      ],
      "end_point": [
        254,
        1
      ],
      "content": "static void\nadd_tag_to_block (EMACS_TAG_BLOCK *block,\n    char *name, int line, long int char_offset)\n{\n  EMACS_TAG *tag;\n\n  tag = xmalloc (sizeof (EMACS_TAG));\n  tag->name = name;\n  tag->line = line;\n  tag->char_offset = char_offset;\n  add_pointer_to_array (tag, block->entries_index, block->entries,\n                        block->entries_slots, 50);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "process_one_file": {
      "start_point": [
        259,
        0
      ],
      "end_point": [
        460,
        1
      ],
      "content": "static void\nprocess_one_file (char *filename, FILE *doc_stream, FILE *funs_stream)\n{\n  int descriptor, decl_len;\n  char *buffer, *decl_str;\n  struct stat finfo;\n  long offset;\n  long file_size;\n  EMACS_TAG_BLOCK *block;\n\n  if (stat (filename, &finfo) == -1)\n    fatal_file_error (filename);\n\n  descriptor = open (filename, O_RDONLY, 0666);\n\n  if (descriptor == -1)\n    fatal_file_error (filename);\n\n  file_size = (long) finfo.st_size;\n  buffer = xmalloc (1 + file_size);\n  /* On some systems, the buffer will actually contain\n     less characters than the full file's size, because\n     the CR characters are removed from line endings.  */\n  file_size = read (descriptor, buffer, file_size);\n  close (descriptor);\n\n  offset = 0;\n  decl_str = DECLARATION_STRING;\n  decl_len = strlen (decl_str);\n\n  block = make_emacs_tag_block (filename);\n\n  while (1)\n    {\n      long point = 0;\n      long line_start = 0;\n      int line_number = 0;\n\n      char *func, *doc;\n      char *func_name;\n\n      for (; offset < (file_size - decl_len); offset++)\n        {\n          if (buffer[offset] == '\\n')\n            {\n              line_number++;\n              line_start = offset + 1;\n            }\n\n          if (strncmp (buffer + offset, decl_str, decl_len) == 0)\n            {\n              offset += decl_len;\n              point = offset;\n              break;\n            }\n        }\n\n      if (!point)\n        break;\n\n      /* Skip forward until we find the open paren. */\n      while (point < file_size)\n        {\n          if (buffer[point] == '\\n')\n            {\n              line_number++;\n              line_start = point + 1;\n            }\n          else if (buffer[point] == '(')\n            break;\n\n          point++;\n        }\n\n      while (point++ < file_size)\n        {\n          if (!whitespace_or_newline (buffer[point]))\n            break;\n          else if (buffer[point] == '\\n')\n            {\n              line_number++;\n              line_start = point + 1;\n            }\n        }\n\n      if (point >= file_size)\n        break;\n\n      /* Now looking at name of function.  Get it. */\n      for (offset = point; buffer[offset] != ','; offset++);\n      func = xmalloc (1 + (offset - point));\n      strncpy (func, buffer + point, offset - point);\n      func[offset - point] = '\\0';\n\n      /* Remember this tag in the current block. */\n      {\n        char *tag_name;\n\n        tag_name = xmalloc (1 + (offset - line_start));\n        strncpy (tag_name, buffer + line_start, offset - line_start);\n        tag_name[offset - line_start] = '\\0';\n        add_tag_to_block (block, tag_name, line_number, point);\n      }\n\n      /* Generate the user-visible function name from the function's name. */\n      {\n        register int i;\n        char *name_start;\n\n        name_start = func;\n\n        if (strncmp (name_start, \"info_\", 5) == 0)\n          name_start += 5;\n\n        func_name = xstrdup (name_start);\n\n        /* Fix up \"ea\" commands. */\n        if (strncmp (func_name, \"ea_\", 3) == 0)\n          {\n            char *temp_func_name;\n\n            temp_func_name = xmalloc (10 + strlen (func_name));\n            strcpy (temp_func_name, \"echo_area_\");\n            strcat (temp_func_name, func_name + 3);\n            free (func_name);\n            func_name = temp_func_name;\n          }\n\n        for (i = 0; func_name[i]; i++)\n          if (func_name[i] == '_')\n            func_name[i] = '-';\n      }\n\n      /* Find doc string. */\n      point = offset + 1;\n\n      while (point < file_size)\n        {\n          if (buffer[point] == '\\n')\n            {\n              line_number++;\n              line_start = point + 1;\n            }\n\n          if (buffer[point] == '\"')\n            break;\n          else\n            point++;\n        }\n\n      offset = point + 1;\n\n      while (offset < file_size)\n        {\n          if (buffer[offset] == '\\n')\n            {\n              line_number++;\n              line_start = offset + 1;\n            }\n\n          if (buffer[offset] == '\\\\')\n            offset += 2;\n          else if (buffer[offset] == '\"')\n            break;\n          else\n            offset++;\n        }\n\n      offset++;\n      if (offset >= file_size)\n        break;\n\n      doc = xmalloc (1 + (offset - point));\n      strncpy (doc, buffer + point, offset - point);\n      doc[offset - point] = '\\0';\n\n      fprintf (doc_stream,\n          \"   { (VFunction *)%s, \\\"%s\\\", (FUNCTION_KEYSEQ *)0, %s },\\n\",\n          func, func_name, doc);\n\n      free (func_name);\n\n      fprintf (funs_stream, \"#define A_%s %u\\n\", func, next_func_key());\n      fprintf (funs_stream,\n          \"extern void %s (WINDOW *window, int count);\\n\",\n          func);\n      free (func);\n      free (doc);\n    }\n  free (buffer);\n\n  /* If we created any tags, remember this file on our global list.  Otherwise,\n     free the memory already allocated to it. */\n  if (block->entries)\n    add_pointer_to_array (block, emacs_tags_index, emacs_tags,\n                          emacs_tags_slots, 10);\n  else\n    {\n      free (block->filename);\n      free (block);\n    }\n}",
      "lines": 202,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fatal_file_error": {
      "start_point": [
        462,
        0
      ],
      "end_point": [
        467,
        1
      ],
      "content": "static void\nfatal_file_error (char *filename)\n{\n  fprintf (stderr, _(\"Couldn't manipulate the file %s.\\n\"), filename);\n  exit (EXIT_FAILURE);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "must_fopen": {
      "start_point": [
        469,
        0
      ],
      "end_point": [
        479,
        1
      ],
      "content": "static FILE *\nmust_fopen (char *filename, char *mode)\n{\n  FILE *stream;\n\n  stream = fopen (filename, mode);\n  if (!stream)\n    fatal_file_error (filename);\n\n  return stream;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "FILE",
        "*\nmust_fopen (char *filename, char *mode)",
        "*"
      ]
    },
    "init_func_key": {
      "start_point": [
        483,
        0
      ],
      "end_point": [
        487,
        1
      ],
      "content": "static void\ninit_func_key(unsigned int val)\n{\n\tfunc_key = val;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "next_func_key": {
      "start_point": [
        489,
        0
      ],
      "end_point": [
        493,
        1
      ],
      "content": "static unsigned int\nnext_func_key(void)\n{\n\treturn func_key++;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/info/man.c": {
    "get_manpage_node": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "NODE *\nget_manpage_node (char *pagename)\n{\n  NODE *node = 0, **n, *node2 = 0;\n  char *page;\n\n  if (manpage_node_index > 0)\n    for (n = manpage_nodes; (node = *n); n++)\n      if (!strcmp (node->nodename, pagename))\n        break;\n\n  /* Node was not found, so we have to create it. */\n  if (!node)\n    {\n      node = info_create_node ();\n      node->fullpath = MANPAGE_FILE_BUFFER_NAME;\n      node->nodename = xstrdup (pagename);\n      node->flags |= N_HasTagsTable | N_IsManPage;\n\n      /* Save this node. */\n      add_pointer_to_array (node, manpage_node_index,\n                            manpage_nodes,\n                            manpage_node_slots, 100);\n    } \n\n  /* Node wasn't found, or its contents were freed since last time. */\n  if (!node->contents)\n    {\n      int plen;\n\n      page = get_manpage_contents (pagename);\n      if (!page)\n        return 0;\n      plen = strlen (page);\n\n      node->contents = page;\n      node->nodelen = plen;\n\n      node->body_start = 0;\n      node->references = xrefs_of_manpage (node);\n      node->up = \"(dir)\";\n    }\n\n  node2 = xmalloc (sizeof (NODE));\n  *node2 = *node;\n  return node2;\n}",
      "lines": 47,
      "depth": 11,
      "decorators": [
        "NODE",
        "*\nget_manpage_node (char *pagename)",
        "*"
      ]
    },
    "executable_file_in_path": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "static char *\nexecutable_file_in_path (char *filename, char *path)\n{\n  struct stat finfo;\n  char *temp_dirname;\n  int statable, dirname_index;\n\n  dirname_index = 0;\n\n  while ((temp_dirname = extract_colon_unit (path, &dirname_index)))\n    {\n      char *temp;\n      char *temp_end;\n      int i;\n\n      /* Expand a leading tilde if one is present. */\n      if (*temp_dirname == '~')\n        {\n          char *expanded_dirname;\n\n          expanded_dirname = tilde_expand_word (temp_dirname);\n          free (temp_dirname);\n          temp_dirname = expanded_dirname;\n        }\n\n      temp = xmalloc (34 + strlen (temp_dirname) + strlen (filename));\n      strcpy (temp, temp_dirname);\n      if (!IS_SLASH (temp[(strlen (temp)) - 1]))\n        strcat (temp, \"/\");\n      strcat (temp, filename);\n      temp_end = temp + strlen (temp);\n\n      free (temp_dirname);\n\n      /* Look for FILENAME, possibly with any of the extensions\n\t in EXEC_EXTENSIONS[].  */\n      for (i = 0; exec_extensions[i]; i++)\n\t{\n\t  if (exec_extensions[i][0])\n\t    strcpy (temp_end, exec_extensions[i]);\n\t  statable = (stat (temp, &finfo) == 0);\n\n\t  /* If we have found a regular executable file, then use it. */\n\t  if ((statable) && (S_ISREG (finfo.st_mode)) &&\n\t      (access (temp, X_OK) == 0))\n\t    return temp;\n\t}\n\n      free (temp);\n    }\n  return NULL;\n}",
      "lines": 52,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nexecutable_file_in_path (char *filename, char *path)",
        "*"
      ]
    },
    "find_man_formatter": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "static char *\nfind_man_formatter (void)\n{\n  char *man_command = getenv (\"INFO_MAN_COMMAND\");\n  return man_command ? man_command :\n                       executable_file_in_path (\"man\", getenv (\"PATH\"));\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nfind_man_formatter (void)",
        "*"
      ]
    },
    "get_page_and_section": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "static void\nget_page_and_section (char *pagename)\n{\n  register int i;\n\n  if (manpage_pagename)\n    free (manpage_pagename);\n\n  if (manpage_section)\n    free (manpage_section);\n\n  manpage_pagename = NULL;\n  manpage_section  = NULL;\n\n  for (i = 0; pagename[i] != '\\0' && pagename[i] != '('; i++);\n\n  manpage_pagename = xmalloc (1 + i);\n  strncpy (manpage_pagename, pagename, i);\n  manpage_pagename[i] = '\\0';\n\n  if (pagename[i] == '(')\n    {\n      int start;\n\n      start = i + 1;\n\n      for (i = start; pagename[i] != '\\0' && pagename[i] != ')'; i++);\n\n      manpage_section = xmalloc (1 + (i - start));\n      strncpy (manpage_section, pagename + start, (i - start));\n      manpage_section[i - start] = '\\0';\n    }\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "clean_manpage": {
      "start_point": [
        215,
        0
      ],
      "end_point": [
        258,
        1
      ],
      "content": "void\nclean_manpage (char *manpage)\n{\n  mbi_iterator_t iter;\n  size_t len = strlen (manpage);\n  char *newpage = xmalloc (len + 1);\n  char *np = newpage;\n  int prev_len = 0;\n  \n  for (mbi_init (iter, manpage, len);\n       mbi_avail (iter);\n       mbi_advance (iter))\n    {\n      const char *cur_ptr = mbi_cur_ptr (iter);\n      size_t cur_len = mb_len (mbi_cur (iter));\n\n      if (cur_len == 1)\n\t{\n\t  if (*cur_ptr == '\\b' || *cur_ptr == '\\f')\n\t    {\n\t      if (np >= newpage + prev_len)\n\t\tnp -= prev_len;\n\t    }\n\t  else if (ansi_escape (iter, &cur_len))\n\t    {\n\t      memcpy (np, cur_ptr, cur_len);\n\t      np += cur_len;\n\t      ITER_SETBYTES (iter, cur_len);\n\t    }\n\t  else if (show_malformed_multibyte_p || mbi_cur (iter).wc_valid)\n\t    *np++ = *cur_ptr;\n\t}\n      else\n\t{\n\t  memcpy (np, cur_ptr, cur_len);\n\t  np += cur_len;\n\t}\n      prev_len = cur_len;\n    }\n  *np = 0;\n  \n  strcpy (manpage, newpage);\n  free (newpage);\n}",
      "lines": 44,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "get_manpage_contents": {
      "start_point": [
        262,
        0
      ],
      "end_point": [
        295,
        1
      ],
      "content": "static char *\nget_manpage_contents (char *pagename)\n{\n  static char *formatter_args[4] = { NULL };\n  char *formatted_page;\n\n  if (formatter_args[0] == NULL)\n    formatter_args[0] = find_man_formatter ();\n\n  if (formatter_args[0] == NULL)\n    return NULL;\n\n  get_page_and_section (pagename);\n\n  if (manpage_section)\n    formatter_args[1] = manpage_section;\n  else\n    formatter_args[1] = \"-a\";\n\n  formatter_args[2] = manpage_pagename;\n  formatter_args[3] = NULL;\n\n  formatted_page = get_manpage_from_formatter (formatter_args);\n\n  /* If there was a section and the page wasn't found, try again\n     without the section (e.g. \"man 3X curses\" versus \"man -a curses\"). */\n  if (!formatted_page && manpage_section)\n    {\n      formatter_args[1] = \"-a\";\n      formatted_page = get_manpage_from_formatter (formatter_args);\n    }\n\n  return formatted_page;\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_manpage_contents (char *pagename)",
        "*"
      ]
    },
    "get_manpage_from_formatter": {
      "start_point": [
        297,
        0
      ],
      "end_point": [
        405,
        1
      ],
      "content": "static char *\nget_manpage_from_formatter (char *formatter_args[])\n{\n  char *formatted_page = NULL;\n  int pipes[2];\n  pid_t child;\n  int formatter_status = 0;\n\n  /* Open a pipe to this program, read the output, and save it away\n     in FORMATTED_PAGE.  The reader end of the pipe is pipes[0]; the\n     writer end is pipes[1]. */\n#if PIPE_USE_FORK\n  pipe (pipes);\n\n  child = fork ();\n  if (child == -1)\n    return NULL;\n\n  if (child != 0)\n    {\n      /* In the parent, close the writing end of the pipe, and read from\n         the exec'd child. */\n      close (pipes[1]);\n      formatted_page = read_from_fd (pipes[0]);\n      close (pipes[0]);\n      wait (&formatter_status); /* Wait for child process to exit. */\n    }\n  else\n    { /* In the child, close the read end of the pipe, make the write end\n         of the pipe be stdout, and execute the man page formatter. */\n      close (pipes[0]);\n      freopen (NULL_DEVICE, \"w\", stderr);\n      freopen (NULL_DEVICE, \"r\", stdin);\n      dup2 (pipes[1], fileno (stdout));\n\n      execv (formatter_args[0], formatter_args);\n\n      /* If we get here, we couldn't exec, so close out the pipe and\n         exit. */\n      close (pipes[1]);\n      exit (EXIT_SUCCESS);\n    }\n#else  /* !PIPE_USE_FORK */\n  /* Cannot fork/exec, but can popen/pclose.  */\n  {\n    FILE *fpipe;\n    char *cmdline;\n    size_t cmdlen = 0;\n    int save_stderr = dup (fileno (stderr));\n    int fd_err = open (NULL_DEVICE, O_WRONLY, 0666);\n    int i;\n\n    for (i = 0; formatter_args[i]; i++)\n      cmdlen += strlen (formatter_args[i]);\n    /* Add-ons: 2 blanks, 2 quotes for the formatter program, 1\n       terminating null character.  */\n    cmdlen += 2 + 2 + 1;\n    cmdline = xmalloc (cmdlen);\n\n    if (fd_err > 2)\n      dup2 (fd_err, fileno (stderr)); /* Don't print errors. */\n    sprintf (cmdline, \"\\\"%s\\\" %s %s\",\n\t     formatter_args[0], formatter_args[1], formatter_args[2]);\n    fpipe = popen (cmdline, \"r\");\n    free (cmdline);\n    if (fd_err > 2)\n      close (fd_err);\n    dup2 (save_stderr, fileno (stderr));\n    if (fpipe == 0)\n      return NULL;\n    formatted_page = read_from_fd (fileno (fpipe));\n    formatter_status = pclose (fpipe);\n  }\n#endif /* !PIPE_USE_FORK */\n\n  if (!formatted_page)\n    return 0;\n\n  /* We could check the exit status of \"man -a\" to see if it successfully\n     output a man page  However:\n      * It is possible for \"man -a\" to output a man page and still to exit with\n        a non-zero status.  This was found to happen when duplicate man pages \n        were found.\n      * \"man\" was found to exit with a zero status on Solaris 10 even when\n        it found nothing.\n     Hence, treat it as a success if more than three lines were output.  (A \n     small amount of output could be error messages that were sent to standard \n     output.) */\n  {\n    int i;\n    char *p;\n    p = formatted_page;\n    for (i = 0; i < 3; i++)\n      {\n        p = strchr (p, '\\n');\n        if (!p)\n          {\n            free (formatted_page);\n            return NULL;\n          }\n        p++;\n      }\n  }\n\n  /* If we have the page, then clean it up. */\n  clean_manpage (formatted_page);\n\n  return formatted_page;\n}",
      "lines": 109,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_manpage_from_formatter (char *formatter_args[])",
        "*"
      ]
    },
    "read_from_fd": {
      "start_point": [
        409,
        0
      ],
      "end_point": [
        472,
        1
      ],
      "content": "static char *\nread_from_fd (int fd)\n{\n  struct timeval timeout;\n  char *buffer = NULL;\n  int bsize = 0;\n  int bindex = 0;\n  int select_result;\n#if defined (FD_SET)\n  fd_set read_fds;\n\n  timeout.tv_sec = 15;\n  timeout.tv_usec = 0;\n\n  FD_ZERO (&read_fds);\n  FD_SET (fd, &read_fds);\n\n  select_result = select (fd + 1, fd_set_cast (&read_fds), 0, 0, &timeout);\n#else /* !FD_SET */\n  select_result = 1;\n#endif /* !FD_SET */\n\n  switch (select_result)\n    {\n    case 0:\n    case -1:\n      break;\n\n    default:\n      {\n        int amount_read;\n        int done = 0;\n\n        while (!done)\n          {\n            while ((bindex + 1024) > (bsize))\n              buffer = xrealloc (buffer, (bsize += 1024));\n            buffer[bindex] = '\\0';\n\n            amount_read = read (fd, buffer + bindex, 1023);\n\n            if (amount_read < 0)\n              {\n                done = 1;\n              }\n            else\n              {\n                bindex += amount_read;\n                buffer[bindex] = '\\0';\n                if (amount_read == 0)\n                  done = 1;\n              }\n          }\n      }\n    }\n\n  if ((buffer != NULL) && (*buffer == '\\0'))\n    {\n      free (buffer);\n      buffer = NULL;\n    }\n\n  return buffer;\n}",
      "lines": 64,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nread_from_fd (int fd)",
        "*"
      ]
    },
    "xrefs_of_manpage": {
      "start_point": [
        474,
        0
      ],
      "end_point": [
        602,
        1
      ],
      "content": "static REFERENCE **\nxrefs_of_manpage (NODE *node)\n{\n  SEARCH_BINDING s;\n\n  REFERENCE **refs = NULL;\n  size_t refs_index = 0;\n  size_t refs_slots = 0;\n  long position;\n\n  /* Initialize reference list to have a single null entry. */\n  refs = calloc(1, sizeof (REFERENCE *));\n  refs_slots = 1;\n\n  s.buffer = node->contents;\n  s.start = 0;\n  s.flags = 0;\n  s.end = node->nodelen;\n\n  /* Exclude first line, which often looks like:\nCAT(1)                           User Commands                          CAT(1)\n  */\n  s.start = strcspn (node->contents, \"\\n\");\n\n  /* Build a list of references.  A reference is alphabetic characters\n     followed by non-whitespace text within parenthesis leading with a digit. */\n  while (search_forward (\"(\", &s, &position) == search_success)\n    {\n      register int name, name_end;\n      int section, section_end;\n\n      name = position;\n      if (name == 0)\n        goto skip;\n      else\n        name--;\n\n      /* Go to the start of a sequence of non-whitespace characters,\n         checking the characters are those that should appear in a man\n         page name. */\n      for (; name > 0; name--)\n        if (whitespace_or_newline (s.buffer[name])\n            || (!isalnum (s.buffer[name])\n                && s.buffer[name] != '_'\n                && s.buffer[name] != '.'\n                && s.buffer[name] != '-'\n                && s.buffer[name] != '\\033'\n                && s.buffer[name] != '['))\n          break;\n\n      /* Check if reached start of buffer. */\n      if (name == 0)\n        goto skip;\n\n      /* Check for invalid sequence in name. */\n      if (!whitespace_or_newline (s.buffer[name]))\n        goto skip;\n\n      name++;\n\n      if (name == position)\n        goto skip; /* Whitespace immediately before '('. */\n\n      /* 'name' is now at the start of a sequence of non-whitespace\n         characters.  If we are on an ECMA-48 SGR escape sequence, skip\n         past it. */\n      if (s.buffer[name] == '\\033' && s.buffer[name + 1] == '[')\n        {\n          name += 2;\n          name += strspn (s.buffer + name, \"0123456789;\");\n          if (s.buffer[name] == 'm')\n            name++;\n          else\n            goto skip;\n        }\n\n      /* Set name_end to the end of the name, but before any SGR sequence. */\n      for (name_end = name; name_end < position; name_end++)\n        if (!isalnum (s.buffer[name_end])\n            && s.buffer[name_end] != '_'\n            && s.buffer[name_end] != '.'\n            && s.buffer[name_end] != '-')\n          break;\n\n      section = position;\n      section_end = 0;\n\n      /* Look for one or two characters within the brackets, the\n         first of which must be a non-zero digit and the second a letter. */\n      if (!isdigit (s.buffer[section + 1])\n          || s.buffer[section + 1] == '0')\n        ;\n      else if (!s.buffer[section + 2])\n        ; /* end of buffer */\n      else if (s.buffer[section + 2] == ')')\n        section_end = section + 3;\n      else if (!isalpha(s.buffer[section + 2]))\n        ;\n      else if (s.buffer[section + 3] == ')')\n        section_end = section + 4;\n\n      if (section_end)\n        {\n          REFERENCE *entry;\n          int len = name_end - name + section_end - section;\n\n          entry = xmalloc (sizeof (REFERENCE));\n          entry->label = xcalloc (1, 1 + len);\n          strncpy (entry->label, s.buffer + name, name_end - name);\n          strncpy (entry->label + strlen (entry->label),\n                   s.buffer + section,\n                   section_end - section);\n\n          entry->filename = xstrdup (MANPAGE_FILE_BUFFER_NAME);\n          entry->nodename = xstrdup (entry->label);\n          entry->line_number = 0;\n          entry->start = name;\n          entry->end = section_end;\n          entry->type = REFERENCE_XREF;\n\n          add_pointer_to_array (entry, refs_index, refs, refs_slots, 10);\n        }\n\nskip:\n      s.start = position + 1;\n    }\n\n  return refs;\n}",
      "lines": 129,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "REFERENCE",
        "**\nxrefs_of_manpage (NODE *node)",
        "*",
        "*\nxrefs_of_manpage (NODE *node)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/info/man.h": {},
  "texinfo/texinfo-6.5/info/nodemenu.c": {
    "nodemenu_format_info": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static const char *\nnodemenu_format_info (void)\n{\n  /* TRANSLATORS: The \"\\n* Menu:\\n\\n\" part of this should not be translated, as \n     it is part of the Info syntax. */\n  return _(\"\\n* Menu:\\n\\n\\\n  (File)Node                        Lines   Size   Containing File\\n\\\n  ----------                        -----   ----   ---------------\");\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nnodemenu_format_info (void)",
        "*"
      ]
    },
    "format_node_info": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "static char *\nformat_node_info (NODE *node)\n{\n  register int i;\n  char *containing_file;\n  static struct text_buffer line_buffer = { 0 };\n\n  if (!text_buffer_base (&line_buffer))\n    text_buffer_init (&line_buffer);\n  else\n    text_buffer_reset (&line_buffer);\n\n  if (node->subfile)\n    containing_file = node->subfile;\n  else\n    containing_file = node->fullpath;\n\n  if (!containing_file || !*containing_file)\n    text_buffer_printf (&line_buffer, \"* %s::\", node->nodename);\n  else\n    text_buffer_printf (&line_buffer, \"* (%s)%s::\",\n                        filename_non_directory (node->fullpath),\n                        node->nodename);\n\n  for (i = text_buffer_off (&line_buffer); i < 36; i++)\n    text_buffer_add_char (&line_buffer, ' ');\n\n  {\n    int lines = 1;\n\n    for (i = 0; i < node->nodelen; i++)\n      if (node->contents[i] == '\\n')\n        lines++;\n\n    text_buffer_printf (&line_buffer, \"%d\", lines);\n  }\n\n  text_buffer_add_char (&line_buffer, ' ');\n  for (i = text_buffer_off (&line_buffer); i < 44; i++)\n    text_buffer_add_char (&line_buffer, ' ');\n  text_buffer_printf (&line_buffer, \"%ld\", node->nodelen);\n\n  if (containing_file)\n    {\n      for (i = text_buffer_off (&line_buffer); i < 51; i++)\n        text_buffer_add_char (&line_buffer, ' ');\n      text_buffer_printf (&line_buffer, containing_file);\n    }\n\n  return xstrdup (text_buffer_base (&line_buffer));\n}",
      "lines": 51,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nformat_node_info (NODE *node)",
        "*"
      ]
    },
    "compare_strings": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "static int\ncompare_strings (const void *entry1, const void *entry2)\n{\n  char **e1 = (char **) entry1;\n  char **e2 = (char **) entry2;\n\n  return mbscasecmp (*e1, *e2);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "get_visited_nodes": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "static NODE *\nget_visited_nodes (void)\n{\n  register int i;\n  WINDOW *info_win;\n  NODE *node;\n  char **lines = NULL;\n  size_t lines_index = 0, lines_slots = 0;\n  struct text_buffer message;\n\n  for (info_win = windows; info_win; info_win = info_win->next)\n    {\n      for (i = 0; i < info_win->hist_index; i++)\n        {\n          NODE *history_node = info_win->hist[i]->node;\n\n          /* We skip mentioning \"*Node Menu*\" nodes. */\n          if (strcmp (history_node->nodename, nodemenu_nodename) == 0)\n            continue;\n\n          if (history_node)\n            {\n              char *line;\n\n              line = format_node_info (history_node);\n              add_pointer_to_array (line, lines_index, lines, lines_slots, 20);\n            }\n        }\n    }\n\n  /* Sort the array of information lines, if there are any. */\n  if (lines)\n    {\n      register int j, newlen;\n      char **temp;\n\n      qsort (lines, lines_index, sizeof (char *), compare_strings);\n\n      /* Delete duplicates. */\n      for (i = 0, newlen = 1; i < lines_index - 1; i++)\n        {\n\t  /* Use FILENAME_CMP here, since the most important piece\n\t     of info in each line is the file name of the node.  */\n          if (FILENAME_CMP (lines[i], lines[i + 1]) == 0)\n            {\n              free (lines[i]);\n              lines[i] = NULL;\n            }\n          else\n            newlen++;\n        }\n\n      /* We have free ()'d and marked all of the duplicate slots.\n         Copy the live slots rather than pruning the dead slots. */\n      temp = xmalloc ((1 + newlen) * sizeof (char *));\n      for (i = 0, j = 0; i < lines_index; i++)\n        if (lines[i])\n          temp[j++] = lines[i];\n\n      temp[j] = NULL;\n      free (lines);\n      lines = temp;\n      lines_index = newlen;\n    }\n\n  text_buffer_init (&message);\n\n  text_buffer_printf (&message, \"\\n\");\n  text_buffer_printf (&message,\n    \"%s\", replace_in_documentation\n     (_(\"Here is the menu of nodes you have recently visited.\\n\\\nSelect one from this menu, or use '\\\\[history-node]' in another window.\\n\"), 0));\n\n  text_buffer_printf (&message, \"%s\\n\", nodemenu_format_info ());\n\n  for (i = 0; (lines != NULL) && (i < lines_index); i++)\n    {\n      text_buffer_printf (&message, \"%s\\n\", lines[i]);\n      free (lines[i]);\n    }\n\n  if (lines)\n    free (lines);\n\n  node = text_buffer_to_node (&message);\n  scan_node_contents (node, 0, 0);\n\n  return node;\n}",
      "lines": 89,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nget_visited_nodes (void)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/info/nodes.c": {
    "build_tags_and_nodes": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "void\nbuild_tags_and_nodes (FILE_BUFFER *file_buffer)\n{\n  SEARCH_BINDING binding;\n  long position;\n  long tags_table_begin, tags_table_end;\n\n  free_file_buffer_tags (file_buffer);\n  file_buffer->flags &= ~N_HasTagsTable;\n\n  /* See if there is a tags table in this info file. */\n  binding.buffer = file_buffer->contents;\n  binding.start = file_buffer->filesize;\n  binding.end = binding.start - 1000;\n  if (binding.end < 0)\n    binding.end = 0;\n  binding.flags = S_FoldCase;\n\n  position = find_file_section (&binding, TAGS_TABLE_END_LABEL);\n  if (position == -1)\n    goto no_tags_table;\n\n  /* If there is a tag table, find the start of it, and grovel over it\n     extracting tag information. */\n\n  /* Remember the end of the tags table. */\n  if (position == 0)\n    goto no_tags_table;\n  else\n    tags_table_end = position - 1;\n\n  /* Locate the start of the tags table. */\n  binding.start = tags_table_end;\n  binding.end = 0;\n  position = find_file_section (&binding, TAGS_TABLE_BEG_LABEL);\n  if (position == -1)\n    goto no_tags_table;\n\n  /* The file contains a valid tags table.  Fill the FILE_BUFFER's\n     tags member. */\n  file_buffer->flags |= N_HasTagsTable;\n  tags_table_begin = position;\n\n  position += skip_node_separator (file_buffer->contents + position);\n  position += strlen (TAGS_TABLE_BEG_LABEL);\n  position += strspn (file_buffer->contents + position, \"\\r\\n\");\n  if (!looking_at_line (TAGS_TABLE_IS_INDIRECT_LABEL,\n                        file_buffer->contents + position))\n    {\n      /* If this isn't an indirect tags table, just remember the nodes\n         described locally in this tags table. */\n      binding.start = tags_table_begin;\n      binding.end = tags_table_end;\n      get_nodes_of_tags_table (file_buffer, &binding);\n    }\n  else\n    {\n      /* This is an indirect tags table.  Find the indirect table\n         preceding the tags table. */\n      SEARCH_BINDING indirect;\n\n      indirect.start = tags_table_begin;\n      indirect.end = 0;\n      indirect.buffer = file_buffer->contents;\n      indirect.flags = S_FoldCase;\n\n      position = find_file_section (&indirect, INDIRECT_TABLE_LABEL);\n      if (position == -1)\n        /* This file is malformed.  Give up. */\n        return;\n\n      /* Skip \"Indirect:\" line. */\n      position += skip_node_separator (file_buffer->contents + position);\n      position += strlen (INDIRECT_TABLE_LABEL);\n      position += strspn (file_buffer->contents + position, \"\\r\\n\");\n\n      indirect.start = position;\n      indirect.end = tags_table_begin;\n\n      binding.start = tags_table_begin;\n      binding.end = tags_table_end;\n      get_tags_of_indirect_tags_table (file_buffer, &indirect, &binding);\n    }\n  return;\n\nno_tags_table:\n  /* This file doesn't have a tag table. */\n  build_tag_table (file_buffer);\n}",
      "lines": 89,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "init_file_buffer_tag": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "static void\ninit_file_buffer_tag (FILE_BUFFER *fb, TAG *entry)\n{\n  if (fb->flags & N_HasTagsTable)\n    {\n      entry->flags |= N_HasTagsTable;\n      entry->filename = fb->fullpath;\n\n      if (fb->flags & N_TagsIndirect)\n        entry->flags |= N_TagsIndirect;\n    }\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "build_tag_table": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "static void\nbuild_tag_table (FILE_BUFFER *file_buffer)\n{\n  long nodestart;\n  size_t tags_index = 0;\n  SEARCH_BINDING binding;\n\n  binding.buffer = file_buffer->contents;\n  binding.start = 0;\n  binding.end = file_buffer->filesize;\n  binding.flags = S_FoldCase;\n\n  while ((nodestart = find_node_separator (&binding)) != -1)\n    {\n      int start;\n      char *nodeline;\n      TAG *entry;\n      int anchor = 0;\n\n      /* Skip past the characters just found. */\n      binding.start = nodestart;\n      binding.start += skip_node_separator (binding.buffer + binding.start);\n\n      /* Move to the start of the line defining the node. */\n      nodeline = binding.buffer + binding.start;\n\n      /* Find \"Node:\" */\n      start = string_in_line (INFO_NODE_LABEL, nodeline);\n      /* No Node:.  Maybe it's a Ref:.  */\n      if (start == -1)\n        {\n          start = string_in_line (INFO_REF_LABEL, nodeline);\n          if (start != -1)\n            anchor = 1;\n        }\n\n      /* If not there, this is not the start of a node. */\n      if (start == -1)\n        continue;\n\n      /* Find the start of the nodename. */\n      start += skip_whitespace (nodeline + start);\n\n      /* Record nodename and nodestart. */\n      entry = info_create_tag ();\n      read_quoted_string (nodeline + start, \",\\n\\r\\t\", 0, &entry->nodename);\n      if (!entry->nodename || !*entry->nodename)\n        {\n          free (entry);\n          continue;\n        }\n      entry->nodestart = nodestart;\n\n      init_file_buffer_tag (file_buffer, entry);\n\n      if (anchor)\n        entry->cache.nodelen = 0;\n      else\n        /* Record that the length is unknown. */\n        entry->cache.nodelen = -1;\n\n      entry->filename = file_buffer->fullpath;\n\n      /* Add this tag to the array of tag structures in this FILE_BUFFER. */\n      add_pointer_to_array (entry, tags_index, file_buffer->tags,\n                            file_buffer->tags_slots, 100);\n    }\n}",
      "lines": 68,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_nodes_of_tags_table": {
      "start_point": [
        238,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "static void\nget_nodes_of_tags_table (FILE_BUFFER *file_buffer,\n    SEARCH_BINDING *buffer_binding)\n{\n  int name_offset;\n  SEARCH_BINDING s;\n  long position;\n  size_t tags_index = 0;\n\n  /* Copy buffer_binding */\n  s = *buffer_binding;\n\n  /* Find the start of the tags table. */\n  position = buffer_binding->start;\n\n  /* If none, we're all done. */\n  if (position == -1)\n    return;\n\n  /* Move to one character before the start of the actual table. */\n  s.start = position;\n  s.start += skip_node_separator (s.buffer + s.start);\n  s.start += strlen (TAGS_TABLE_BEG_LABEL);\n\n  /* The tag table consists of lines containing node names and positions.\n     Do each line until we find one that doesn't contain a node name. */\n  while (search_forward (\"\\n\", &s, &position) == search_success)\n    {\n      TAG *entry;\n      char *nodedef;\n      unsigned p;\n      int anchor = 0;\n\n      /* Prepare to skip this line. */\n      s.start = position;\n      s.start++;\n\n      /* Skip past informative \"(Indirect)\" tags table line. */\n      if (!tags_index && looking_at (TAGS_TABLE_IS_INDIRECT_LABEL, &s))\n        continue;\n\n      /* Find the label preceding the node name. */\n      name_offset = string_in_line (INFO_NODE_LABEL, s.buffer + s.start);\n\n      /* If no node label, maybe it's an anchor.  */\n      if (name_offset == -1)\n        {\n          name_offset = string_in_line (INFO_REF_LABEL, s.buffer + s.start);\n          if (name_offset != -1)\n            anchor = 1;\n        }\n\n      /* If not there, not a defining line, so we must be out of the\n         tags table.  */\n      if (name_offset == -1)\n        break;\n\n      entry = info_create_tag ();\n\n      init_file_buffer_tag (file_buffer, entry);\n\n      /* Find the beginning of the node definition. */\n      s.start += name_offset;\n      nodedef = s.buffer + s.start;\n      nodedef += skip_whitespace (nodedef);\n\n      /* Move past the node's name in this tag to the TAGSEP character. */\n      for (p = 0; nodedef[p] && nodedef[p] != INFO_TAGSEP; p++)\n        ;\n      if (nodedef[p] != INFO_TAGSEP)\n        continue;\n\n      entry->nodename = xmalloc (p + 1);\n      strncpy (entry->nodename, nodedef, p);\n      entry->nodename[p] = 0;\n      p++;\n      entry->nodestart = atol (nodedef + p);\n\n      /* If a node, we don't know the length yet, but if it's an\n         anchor, the length is 0. */\n      entry->cache.nodelen = anchor ? 0 : -1;\n\n      /* The filename of this node is currently known as the same as the\n         name of this file. */\n      entry->filename = file_buffer->fullpath;\n\n      /* Add this node structure to the array of node structures in this\n         FILE_BUFFER. */\n      add_pointer_to_array (entry, tags_index, file_buffer->tags,\n                            file_buffer->tags_slots, 100);\n    }\n}",
      "lines": 92,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_tags_of_indirect_tags_table": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        504,
        1
      ],
      "content": "static void\nget_tags_of_indirect_tags_table (FILE_BUFFER *file_buffer,\n    SEARCH_BINDING *indirect_binding, SEARCH_BINDING *tags_binding)\n{\n  int i;\n\n  /* A structure used only in `get_tags_of_indirect_tags_table' to hold onto\n     an intermediate value. */\n  typedef struct {\n    char *filename;\n    long first_byte;\n  } SUBFILE;\n\n  SUBFILE **subfiles = NULL;\n  size_t subfiles_index = 0, subfiles_slots = 0;\n  TAG *entry;\n\n  /* Remember that tags table was indirect. */\n  file_buffer->flags |= N_TagsIndirect;\n\n  /* First get the list of tags from the tags table.  Then lookup the\n     associated file in the indirect list for each tag, and update it. */\n  get_nodes_of_tags_table (file_buffer, tags_binding);\n  if (!file_buffer->tags)\n    return;\n\n  /* We have the list of tags in file_buffer->tags.  Get the list of\n     subfiles from the indirect table. */\n  {\n    char *start, *end, *line;\n    SUBFILE *subfile;\n\n    start = indirect_binding->buffer + indirect_binding->start;\n    end = indirect_binding->buffer + indirect_binding->end;\n    line = start;\n\n    while (line < end)\n      {\n        int colon;\n\n        colon = string_in_line (\":\", line);\n\n        if (colon == -1)\n          break;\n\n        subfile = xmalloc (sizeof (SUBFILE));\n        subfile->filename = xmalloc (colon);\n        strncpy (subfile->filename, line, colon - 1);\n        subfile->filename[colon - 1] = 0;\n        subfile->first_byte = (long) atol (line + colon);\n\n        add_pointer_to_array (subfile, subfiles_index, subfiles, \n                              subfiles_slots, 10);\n\n        while (*line++ != '\\n');\n      }\n  }\n\n  /* If we have successfully built the indirect files table, then\n     merge the information in the two tables. */\n  if (!subfiles)\n    {\n      free_file_buffer_tags (file_buffer);\n      return;\n    }\n  else\n    {\n      int tags_index;\n      long header_length;\n      SEARCH_BINDING binding;\n\n      /* Find the length of the header of the file containing the indirect\n         tags table.  This header appears at the start of every file.  We\n         want the absolute position of each node within each subfile, so\n         we subtract the start of the containing subfile from the logical\n         position of the node, and then add the length of the header in. */\n      binding.buffer = file_buffer->contents;\n      binding.start = 0;\n      binding.end = file_buffer->filesize;\n      binding.flags = S_FoldCase;\n\n      header_length = find_node_separator (&binding);\n      if (header_length == -1)\n        header_length = 0;\n\n      /* Build the file buffer's list of subfiles. */\n      {\n        char *containing_dir = xstrdup (file_buffer->fullpath);\n        char *temp = filename_non_directory (containing_dir);\n        int len_containing_dir;\n\n        if (temp > containing_dir)\n          {\n            if (HAVE_DRIVE (file_buffer->fullpath) &&\n                temp == containing_dir + 2)\n              {\n                /* Avoid converting \"d:foo\" into \"d:/foo\" below.  */\n                *temp = '.';\n                temp += 2;\n              }\n            temp[-1] = 0;\n          }\n\n        len_containing_dir = strlen (containing_dir);\n\n        for (i = 0; subfiles[i]; i++);\n\n        file_buffer->subfiles = xmalloc ((1 + i) * sizeof (char *));\n\n        for (i = 0; subfiles[i]; i++)\n          {\n            char *fullpath;\n\n            fullpath = xmalloc\n              (2 + strlen (subfiles[i]->filename) + len_containing_dir);\n\n            sprintf (fullpath, \"%s/%s\",\n                     containing_dir, subfiles[i]->filename);\n\n            file_buffer->subfiles[i] = fullpath;\n          }\n        file_buffer->subfiles[i] = NULL;\n        free (containing_dir);\n      }\n\n      /* For each node in the file's tags table, remember the starting\n         position. */\n      for (tags_index = 0; (entry = file_buffer->tags[tags_index]);\n           tags_index++)\n        {\n          for (i = 0;\n               subfiles[i] && entry->nodestart >= subfiles[i]->first_byte;\n               i++);\n\n          /* If the Info file containing the indirect tags table is\n             malformed, then give up. */\n          if (!i)\n            {\n              /* The Info file containing the indirect tags table is\n                 malformed.  Give up. */\n              for (i = 0; subfiles[i]; i++)\n                {\n                  free (subfiles[i]->filename);\n                  free (subfiles[i]);\n                  free (file_buffer->subfiles[i]);\n                }\n              file_buffer->subfiles = NULL;\n              free_file_buffer_tags (file_buffer);\n              return;\n            }\n\n          /* SUBFILES[i] is the index of the first subfile whose logical\n             first byte is greater than the logical offset of this node's\n             starting position.  This means that the subfile directly\n             preceding this one is the one containing the node. */\n\n          entry->filename = file_buffer->subfiles[i - 1];\n          entry->nodestart -= subfiles[i - 1]->first_byte;\n          entry->nodestart += header_length;\n        }\n    }\n\n  /* Free the structures assigned to SUBFILES.  Free the names as well\n     as the structures themselves, then finally, the array. */\n  for (i = 0; subfiles[i]; i++)\n    {\n      free (subfiles[i]->filename);\n      free (subfiles[i]);\n    }\n  free (subfiles);\n}",
      "lines": 171,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "free_file_buffer_tags": {
      "start_point": [
        507,
        0
      ],
      "end_point": [
        532,
        1
      ],
      "content": "static void\nfree_file_buffer_tags (FILE_BUFFER *file_buffer)\n{\n  int i;\n\n  if (file_buffer->tags)\n    {\n      TAG *tag;\n\n      for (i = 0; (tag = file_buffer->tags[i]); i++)\n        free_info_tag (tag);\n\n      free (file_buffer->tags);\n      file_buffer->tags = NULL;\n      file_buffer->tags_slots = 0;\n    }\n\n  if (file_buffer->subfiles)\n    {\n      for (i = 0; file_buffer->subfiles[i]; i++)\n        free (file_buffer->subfiles[i]);\n\n      free (file_buffer->subfiles);\n      file_buffer->subfiles = NULL;\n    }\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "free_info_tag": {
      "start_point": [
        535,
        0
      ],
      "end_point": [
        545,
        1
      ],
      "content": "static void\nfree_info_tag (TAG *tag)\n{\n  free (tag->nodename);\n  \n  /* We don't free tag->filename, because that filename is part of the\n     subfiles list for the containing FILE_BUFFER.  free_info_tags ()\n     will free the subfiles when it is appropriate. */\n\n  free (tag);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_loaded_file": {
      "start_point": [
        555,
        0
      ],
      "end_point": [
        605,
        1
      ],
      "content": "FILE_BUFFER *\ncheck_loaded_file (char *filename)\n{\n  int is_fullpath, i;\n  FILE_BUFFER *file_buffer;\n  \n  /* If full path to the file has been given, we must find it exactly. */\n  is_fullpath = IS_ABSOLUTE (filename)\n                || filename[0] == '.' && IS_SLASH(filename[1]);\n\n  if (info_loaded_files)\n    {\n      for (i = 0; (file_buffer = info_loaded_files[i]); i++)\n        if (   (FILENAME_CMP (filename, file_buffer->fullpath) == 0)\n            || (!is_fullpath\n                 && (FILENAME_CMP (filename, file_buffer->filename) == 0)))\n          {\n            struct stat new_info, *old_info;\n\n            old_info = &file_buffer->finfo;\n            if (   stat (file_buffer->fullpath, &new_info) == -1\n                || new_info.st_size != old_info->st_size\n                || new_info.st_mtime != old_info->st_mtime)\n              {\n                /* The file has changed.  Forget that we ever had loaded it\n                   in the first place. */\n                forget_info_file (file_buffer);\n                break;\n              }\n\n            /* The info file exists, and has not changed since the last\n               time it was loaded.  If the caller requested a nodes list\n               for this file, and there isn't one here, build the nodes\n               for this file_buffer.  In any case, return the file_buffer\n               object. */\n            if (!file_buffer->contents)\n              {\n                /* The file's contents have been gc'ed.  Reload it.  */\n                info_reload_file_buffer_contents (file_buffer);\n                if (!file_buffer->contents)\n                  return NULL;\n              }\n\n            if (!file_buffer->tags)\n              build_tags_and_nodes (file_buffer);\n\n            return file_buffer;\n          }\n    }\n  return 0;\n}",
      "lines": 51,
      "depth": 16,
      "decorators": [
        "FILE_BUFFER",
        "*\ncheck_loaded_file (char *filename)",
        "*"
      ]
    },
    "info_find_file": {
      "start_point": [
        612,
        0
      ],
      "end_point": [
        642,
        1
      ],
      "content": "FILE_BUFFER *\ninfo_find_file (char *filename)\n{\n  FILE_BUFFER *file_buffer;\n  char *fullpath;\n  int is_fullpath;\n  \n  file_buffer = check_loaded_file (filename);\n  if (file_buffer)\n    return file_buffer;\n\n  /* The file wasn't loaded.  Try to load it now. */\n\n  /* Get the full pathname of this file, as known by the info system.\n     That is to say, search along INFOPATH and expand tildes, etc. */\n  is_fullpath = IS_ABSOLUTE (filename)\n                || filename[0] == '.' && IS_SLASH(filename[1]);\n  if (!is_fullpath)\n    fullpath = info_find_fullpath (filename, 0);\n  else\n    fullpath = xstrdup (filename);\n\n  /* If the file wasn't found, give up, returning a NULL pointer. */\n  if (!fullpath)\n    return NULL;\n\n  file_buffer = info_load_file (fullpath, 0);\n\n  free (fullpath);\n  return file_buffer;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "FILE_BUFFER",
        "*\ninfo_find_file (char *filename)",
        "*"
      ]
    },
    "info_find_subfile": {
      "start_point": [
        646,
        0
      ],
      "end_point": [
        688,
        1
      ],
      "content": "FILE_BUFFER *\ninfo_find_subfile (char *fullpath)\n{\n  char *with_extension = 0;\n  int i;\n  FILE_BUFFER *file_buffer = 0;\n  int fullpath_len = strlen (fullpath);\n\n  /* First try to find the file in our list of already loaded files. */\n  if (info_loaded_files)\n    {\n      for (i = 0; (file_buffer = info_loaded_files[i]); i++)\n        /* Check if fullpath starts the name of the recorded file (extra\n           extensions like \".info.gz\" could be added.) */\n        if (!strncmp (file_buffer->fullpath, fullpath, fullpath_len)\n            && (file_buffer->fullpath[fullpath_len] == '\\0'\n                || file_buffer->fullpath[fullpath_len] == '.'))\n          {\n            struct stat new_info, *old_info;\n\n            old_info = &file_buffer->finfo;\n            if (   stat (file_buffer->fullpath, &new_info) == -1\n                || new_info.st_size != old_info->st_size\n                || new_info.st_mtime != old_info->st_mtime)\n              {\n                /* The file has changed.  Forget that we ever had loaded it\n                   in the first place. */\n                forget_info_file (file_buffer);\n                break;\n              }\n            return file_buffer;\n          }\n    }\n\n  /* The file wasn't loaded.  Try to load it now. */\n  with_extension = info_find_fullpath (fullpath, 0);\n  if (with_extension)\n    {\n      file_buffer = info_load_file (with_extension, 1);\n      free (with_extension);\n    }\n  return file_buffer;\n}",
      "lines": 43,
      "depth": 16,
      "decorators": [
        "FILE_BUFFER",
        "*\ninfo_find_subfile (char *fullpath)",
        "*"
      ]
    },
    "info_load_file": {
      "start_point": [
        695,
        0
      ],
      "end_point": [
        750,
        1
      ],
      "content": "static FILE_BUFFER *\ninfo_load_file (char *fullpath, int is_subfile)\n{\n  char *contents;\n  size_t filesize;\n  struct stat finfo;\n  int compressed;\n  FILE_BUFFER *file_buffer = NULL;\n\n  contents = filesys_read_info_file (fullpath, &filesize, &finfo, &compressed);\n\n  if (!contents)\n    return NULL;\n\n  /* The file was found, and can be read.  Allocate FILE_BUFFER and fill\n     in the various members. */\n  file_buffer = make_file_buffer ();\n  file_buffer->fullpath = xstrdup (fullpath);\n  file_buffer->filename = filename_non_directory (file_buffer->fullpath);\n  file_buffer->filename = xstrdup (file_buffer->filename);\n  /* Strip off a file extension, so we can find it again in info_find_file. */\n  {\n    char *p = strchr (file_buffer->filename, '.');\n    if (p)\n      *p = '\\0';\n  }\n  file_buffer->finfo = finfo;\n  file_buffer->filesize = filesize;\n  file_buffer->contents = contents;\n  if (compressed)\n    file_buffer->flags |= N_IsCompressed;\n  \n  /* Find encoding of file, if set */\n  get_file_character_encoding (file_buffer);\n\n  if (!is_subfile)\n    {\n      build_tags_and_nodes (file_buffer);\n      if (!file_buffer->tags)\n        {\n          free (file_buffer->fullpath);\n          free (file_buffer->filename);\n          free (file_buffer);\n          return 0;\n        }\n    }\n  else\n    file_buffer->flags |= N_Subfile;\n\n  /* If the file was loaded, remember the name under which it was found. */\n  if (file_buffer)\n    add_pointer_to_array (file_buffer, info_loaded_files_index,\n                          info_loaded_files, info_loaded_files_slots, 10);\n\n  return file_buffer;\n}",
      "lines": 56,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "FILE_BUFFER",
        "*\ninfo_load_file (char *fullpath, int is_subfile)",
        "*"
      ]
    },
    "get_file_character_encoding": {
      "start_point": [
        753,
        0
      ],
      "end_point": [
        794,
        1
      ],
      "content": "static void\nget_file_character_encoding (FILE_BUFFER *fb)\n{\n  SEARCH_BINDING binding;\n  long position;\n\n  long int enc_start, enc_len;\n  char *enc_string;\n\n  /* See if there is a local variables section in this info file. */\n  binding.buffer = fb->contents;\n  binding.start = fb->filesize;\n  binding.end = binding.start - 1000;\n  if (binding.end < 0)\n    binding.end = 0;\n  binding.flags = S_FoldCase;\n\n  /* Null means the encoding is unknown. */\n  fb->encoding = 0;\n\n  if (search_backward (LOCAL_VARIABLES_LABEL, &binding, &position)\n      != search_success)\n    return;\n\n  binding.start = position;\n  binding.end = fb->filesize;\n\n  if (search_forward (CHARACTER_ENCODING_LABEL, &binding, &enc_start)\n      != search_success)\n    return;\n\n  enc_start += strlen(CHARACTER_ENCODING_LABEL); /* Skip to after \"coding:\" */\n  enc_start += skip_whitespace(fb->contents + enc_start);\n\n  enc_len = strcspn (fb->contents + enc_start, \"\\r\\n\");\n\n  enc_string = xmalloc (enc_len + 1);\n  strncpy (enc_string, fb->contents + enc_start, enc_len);\n  enc_string[enc_len] = '\\0';\n\n  fb->encoding = enc_string;\n}",
      "lines": 42,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "make_file_buffer": {
      "start_point": [
        797,
        0
      ],
      "end_point": [
        811,
        1
      ],
      "content": "FILE_BUFFER *\nmake_file_buffer (void)\n{\n  FILE_BUFFER *file_buffer = xmalloc (sizeof (FILE_BUFFER));\n\n  file_buffer->filename = file_buffer->fullpath = NULL;\n  file_buffer->contents = NULL;\n  file_buffer->tags = NULL;\n  file_buffer->subfiles = NULL;\n  file_buffer->tags_slots = 0;\n  file_buffer->flags = 0;\n  file_buffer->encoding = 0;\n\n  return file_buffer;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "FILE_BUFFER",
        "*\nmake_file_buffer (void)",
        "*"
      ]
    },
    "forget_info_file": {
      "start_point": [
        814,
        0
      ],
      "end_point": [
        821,
        1
      ],
      "content": "static void\nforget_info_file (FILE_BUFFER *file_buffer)\n{\n  file_buffer->flags |= N_Gone;\n  file_buffer->filename[0] = '\\0';\n  file_buffer->fullpath = \"\";\n  memset (&file_buffer->finfo, 0, sizeof (struct stat));\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "info_reload_file_buffer_contents": {
      "start_point": [
        828,
        0
      ],
      "end_point": [
        841,
        1
      ],
      "content": "static void\ninfo_reload_file_buffer_contents (FILE_BUFFER *fb)\n{\n  int is_compressed;\n\n  fb->flags &= ~N_IsCompressed;\n\n  /* Let the filesystem do all the work for us. */\n  fb->contents =\n    filesys_read_info_file (fb->fullpath, &(fb->filesize), &(fb->finfo),\n                            &is_compressed);\n  if (is_compressed)\n    fb->flags |= N_IsCompressed;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "info_create_tag": {
      "start_point": [
        852,
        0
      ],
      "end_point": [
        865,
        1
      ],
      "content": "TAG *\ninfo_create_tag (void)\n{\n  TAG *t = xmalloc (sizeof (TAG));\n\n  memset (t, 0, sizeof (TAG));\n  t->filename = 0;\n  t->nodename = 0;\n  t->nodestart = -1;\n  t->nodestart_adjusted = -1;\n  t->cache.nodelen = -1;\n\n  return t;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "TAG",
        "*\ninfo_create_tag (void)",
        "*"
      ]
    },
    "info_create_node": {
      "start_point": [
        868,
        0
      ],
      "end_point": [
        887,
        1
      ],
      "content": "NODE *\ninfo_create_node (void)\n{\n  NODE *n = xmalloc (sizeof (NODE));\n\n  n->fullpath = 0;\n  n->subfile = 0;\n  n->nodename = 0;\n  n->contents = 0;\n  n->nodelen = -1;\n  n->display_pos = 0;\n  n->body_start = 0;\n  n->flags = 0;\n  n->references = 0;\n  n->up = 0;\n  n->prev = 0;\n  n->next = 0;\n\n  return n;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "NODE",
        "*\ninfo_create_node (void)",
        "*"
      ]
    },
    "get_node_length": {
      "start_point": [
        890,
        0
      ],
      "end_point": [
        903,
        1
      ],
      "content": "static long\nget_node_length (SEARCH_BINDING *binding)\n{\n  int i;\n  char *body;\n\n  /* [A node] ends with either a ^_, a ^L, or end of file.  */\n  for (i = binding->start, body = binding->buffer; i < binding->end; i++)\n    {\n      if (body[i] == INFO_FF || body[i] == INFO_COOKIE)\n        break;\n    }\n  return i - binding->start;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "long",
        "long"
      ]
    },
    "info_get_node_with_defaults": {
      "start_point": [
        916,
        0
      ],
      "end_point": [
        1007,
        1
      ],
      "content": "NODE *\ninfo_get_node_with_defaults (char *filename_in, char *nodename_in,\n                NODE *defaults)\n{\n  NODE *node = 0;\n  FILE_BUFFER *file_buffer = NULL;\n  char *filename = 0, *nodename = 0;\n\n  info_recent_file_error = NULL;\n\n  filename = filename_in;\n  if (filename_in)\n    {\n      filename = xstrdup (filename_in);\n      if (follow_strategy == FOLLOW_REMAIN\n          && defaults && defaults->fullpath\n          && filename_in)\n        {\n          /* Find the directory in the filename for defaults, and look in\n             that directory first. */\n          char *file_in_same_dir;\n          char saved_char, *p;\n\n          p = defaults->fullpath + strlen (defaults->fullpath);\n          while (p > defaults->fullpath && !IS_SLASH (*p))\n            p--;\n\n          if (p > defaults->fullpath)\n            {\n              saved_char = *p;\n              *p = 0;\n\n              file_in_same_dir = info_add_extension (defaults->fullpath,\n                                                     filename, 0);\n              if (file_in_same_dir)\n                file_buffer = info_find_file (file_in_same_dir);\n              free (file_in_same_dir);\n              *p = saved_char;\n            }\n        }\n    }\n  else\n    {\n      if (defaults)\n        filename = xstrdup (defaults->fullpath);\n      else\n        filename = xstrdup (\"dir\");\n    }\n\n  if (nodename_in && *nodename_in)\n    nodename = xstrdup (nodename_in);\n  else\n    /* If NODENAME is not specified, it defaults to \"Top\". */\n    nodename = xstrdup (\"Top\");\n\n  /* If the file to be looked up is \"dir\", build the contents from all of\n     the \"dir\"s and \"localdir\"s found in INFOPATH. */\n  if (is_dir_name (filename))\n    {\n      node = get_dir_node ();\n      goto cleanup_and_exit;\n    }\n\n  if (mbscasecmp (filename, MANPAGE_FILE_BUFFER_NAME) == 0)\n    {\n      node = get_manpage_node (nodename);\n      goto cleanup_and_exit;\n    }\n\n  if (!file_buffer)\n    file_buffer = info_find_file (filename);\n\n  if (file_buffer)\n    {\n      /* Look for the node.  */\n      node = info_get_node_of_file_buffer (file_buffer, nodename);\n    }\n\n  /* If the node not found was \"Top\", try again with different case. */\n  if (!node && (nodename && mbscasecmp (nodename, \"Top\") == 0))\n    {\n      node = info_get_node_of_file_buffer (file_buffer, \"Top\");\n      if (!node)\n        node = info_get_node_of_file_buffer (file_buffer, \"top\");\n      if (!node)\n        node = info_get_node_of_file_buffer (file_buffer, \"TOP\");\n    }\n\ncleanup_and_exit:\n  free (filename); free (nodename);\n  return node;\n}",
      "lines": 92,
      "depth": 14,
      "decorators": [
        "NODE",
        "*\ninfo_get_node_with_defaults (char *filename_in, char *nodename_in,\n                NODE *defaults)",
        "*"
      ]
    },
    "info_get_node": {
      "start_point": [
        1011,
        0
      ],
      "end_point": [
        1015,
        1
      ],
      "content": "NODE *\ninfo_get_node (char *filename_in, char *nodename_in)\n{\n  return info_get_node_with_defaults (filename_in, nodename_in, 0);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "NODE",
        "*\ninfo_get_node (char *filename_in, char *nodename_in)",
        "*"
      ]
    },
    "node_set_body_start": {
      "start_point": [
        1017,
        0
      ],
      "end_point": [
        1023,
        1
      ],
      "content": "static void\nnode_set_body_start (NODE *node)\n{\n  int n = skip_node_separator (node->contents);\n  node->body_start = strcspn(node->contents + n, \"\\n\");\n  node->body_start += n;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "info_get_node_of_file_buffer": {
      "start_point": [
        1030,
        0
      ],
      "end_point": [
        1076,
        1
      ],
      "content": "NODE *\ninfo_get_node_of_file_buffer (FILE_BUFFER *file_buffer, char *nodename)\n{\n  NODE *node = NULL;\n\n  /* If we are unable to find the file, we have to give up.  There isn't\n     anything else we can do. */\n  if (!file_buffer)\n    return NULL;\n\n  /* If the file buffer was gc'ed, reload the contents now. */\n  if (!file_buffer->contents)\n    info_reload_file_buffer_contents (file_buffer);\n\n  /* If the name of the node that we wish to find is exactly \"*\", then the\n     node body is the contents of the entire file.  Create and return such\n     a node. */\n  if (strcmp (nodename, \"*\") == 0)\n    {\n      node = info_create_node ();\n      node->fullpath = file_buffer->fullpath;\n      node->nodename = xstrdup (\"*\");\n      node->contents = file_buffer->contents;\n      node->nodelen = file_buffer->filesize;\n      node->body_start = 0;\n    }\n  /* Search the tags table for an entry which matches the node that we want. */\n  else\n    {\n      TAG *tag;\n      int i;\n\n      /* If no tags at all (possibly a misformatted info file), quit.  */\n      if (!file_buffer->tags)\n        return NULL;\n\n      for (i = 0; (tag = file_buffer->tags[i]); i++)\n        if (strcmp (nodename, tag->nodename) == 0)\n          {\n            node = info_node_of_tag (file_buffer, &file_buffer->tags[i]);\n            break;\n          }\n    }\n\n  /* Return the results of our node search. */\n  return node;\n}",
      "lines": 47,
      "depth": 15,
      "decorators": [
        "NODE",
        "*\ninfo_get_node_of_file_buffer (FILE_BUFFER *file_buffer, char *nodename)",
        "*"
      ]
    },
    "adjust_nodestart": {
      "start_point": [
        1089,
        0
      ],
      "end_point": [
        1140,
        1
      ],
      "content": "static int\nadjust_nodestart (FILE_BUFFER *fb, TAG *node)\n{\n  long position = -1;\n  SEARCH_BINDING s;\n\n  /* Try the optimal case first.  Who knows?  This file may actually be\n     formatted (mostly) correctly. */\n  s.buffer = fb->contents;\n  s.start = node->nodestart;\n  s.end = s.start + 1;\n\n  /* Check that the given nodestart is in fact inside the file buffer. */\n  if (s.start >= 0 && s.start < fb->filesize)\n    {\n      /* Check for node separator at node->nodestart\n         introducting this node. */\n      position = find_node_in_binding (node->nodename, &s);\n    }\n\n  if (position == -1)\n    {\n      if (strict_node_location_p)\n        return 0;\n\n      /* Oh well, I guess we have to try to find it in a larger area. */\n\n      s.start -= DEFAULT_INFO_FUDGE;\n      s.end += DEFAULT_INFO_FUDGE;\n\n      if (s.start < 0)\n        s.start = 0;\n      else if (s.start > fb->filesize)\n        s.start = fb->filesize;\n      if (s.end > fb->filesize)\n        s.end = fb->filesize;\n\n      position = find_node_in_binding (node->nodename, &s);\n\n      /* If the node still couldn't be found, we lose big. */\n      if (position == -1)\n        return 0;\n\n      /* Set the flag in NODE->flags to say that the the tags table could\n         need updating (if we used a tag to get here, that is). */\n      if (node->flags & N_HasTagsTable)\n        node->flags |= N_UpdateTags;\n    }\n\n  node->nodestart_adjusted = s.buffer + position - fb->contents;\n  return 1;\n}",
      "lines": 52,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "find_node_from_tag": {
      "start_point": [
        1147,
        0
      ],
      "end_point": [
        1160,
        1
      ],
      "content": "static int\nfind_node_from_tag (FILE_BUFFER *parent, FILE_BUFFER *fb, TAG *tag)\n{\n  int success;\n\n  if (tag->nodestart_adjusted != -1)\n    success = 1;\n  else\n    success = adjust_nodestart (fb, tag);\n\n  if (success)\n    return success;\n  return 0;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "set_tag_nodelen": {
      "start_point": [
        1163,
        0
      ],
      "end_point": [
        1174,
        1
      ],
      "content": "static void\nset_tag_nodelen (FILE_BUFFER *subfile, TAG *tag)\n{\n  SEARCH_BINDING node_body;\n\n  node_body.buffer = subfile->contents;\n  node_body.start = tag->nodestart_adjusted;\n  node_body.end = subfile->filesize;\n  node_body.flags = 0;\n  node_body.start += skip_node_separator (node_body.buffer + node_body.start);\n  tag->cache.nodelen = get_node_length (&node_body);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "info_node_of_tag_ext": {
      "start_point": [
        1180,
        0
      ],
      "end_point": [
        1320,
        1
      ],
      "content": "static NODE *\ninfo_node_of_tag_ext (FILE_BUFFER *fb, TAG **tag_ptr, int fast)\n{\n  TAG *tag = *tag_ptr;\n  NODE *node;\n  int is_anchor;\n  TAG *anchor_tag;\n  int node_pos, anchor_pos;\n\n  FILE_BUFFER *parent; /* File containing tag table. */\n  FILE_BUFFER *subfile; /* File containing node. */\n \n  if (!FILENAME_CMP (fb->fullpath, tag->filename))\n    parent = subfile = fb;\n  else\n    {\n      /* This is a split file. */\n      parent = fb;\n      subfile = info_find_subfile (tag->filename);\n    }\n\n  if (!subfile)\n    return NULL;\n\n  if (!subfile->contents)\n    {\n      info_reload_file_buffer_contents (subfile);\n      if (!subfile->contents)\n        return NULL;\n    }\n\n  /* If we were able to find this file and load it, then return\n     the node within it. */\n  if (!(tag->nodestart >= 0 && tag->nodestart < subfile->filesize))\n    return NULL;\n\n  node = 0;\n\n  is_anchor = tag->cache.nodelen == 0;\n \n  if (is_anchor)\n    {\n      anchor_pos = tag_ptr - fb->tags;\n\n      /* Look backwards in the tag table for the node preceding\n         the anchor (we're assuming the tags are given in order),\n         skipping over any preceding anchors.  */\n      for (node_pos = anchor_pos - 1;\n           node_pos >= 0 && fb->tags[node_pos]->cache.nodelen == 0;\n           node_pos--)\n        ;\n\n      /* An info file with an anchor before any nodes is pathological, but\n         it's possible, so don't crash.  */\n      if (node_pos < 0)\n        return NULL;\n\n      anchor_tag = tag;\n      tag = fb->tags[node_pos];\n      tag_ptr = &fb->tags[node_pos];\n    }\n\n  /* We haven't checked the entry pointer yet.  Look for the node\n     around about it and adjust it if necessary. */\n  if (tag->cache.nodelen == -1)\n    {\n      if (!find_node_from_tag (parent, subfile, tag))\n        return NULL; /* Node not found. */\n\n      set_tag_nodelen (subfile, tag);\n    }\n\n  node = xmalloc (sizeof (NODE));\n  memset (node, 0, sizeof (NODE));\n  if (tag->cache.references)\n    {\n      /* Initialize the node from the cache. */\n      *node = tag->cache;\n      if (!node->contents)\n        {\n          node->contents = subfile->contents + tag->nodestart_adjusted;\n          node->contents += skip_node_separator (node->contents);\n        }\n    }\n  else\n    {\n      /* Data for node has not been generated yet. */\n      node->contents = subfile->contents + tag->nodestart_adjusted;\n      node->contents += skip_node_separator (node->contents);\n      node->nodelen = tag->cache.nodelen;\n      node->nodename = tag->nodename;\n      node->flags = tag->flags;\n\n      node->fullpath = parent->fullpath;\n      if (parent != subfile)\n        node->subfile = tag->filename;\n\n      if (fast)\n        node->flags |= N_Simple;\n      else\n        {\n          /* Read locations of references in node and similar.  Strip Info file\n             syntax from node if preprocess_nodes=On.  Adjust the offsets of\n             anchors that occur within the node. */\n          scan_node_contents (node, parent, tag_ptr);\n\n          if (!preprocess_nodes_p)\n            node_set_body_start (node);\n          tag->cache = *node;\n          if (!(node->flags & N_WasRewritten))\n            tag->cache.contents = 0; /* Pointer into file buffer\n                                        is not saved.  */\n        }\n    }\n\n  /* We can't set this when tag table is built, because\n     if file is split, we don't know which of the sub-files\n     are compressed. */\n  if (subfile->flags & N_IsCompressed)\n    node->flags |= N_IsCompressed;\n\n  if (is_anchor)\n    {\n      /* Start displaying the node at the anchor position.  */\n\n      node->display_pos = anchor_tag->nodestart_adjusted\n        - (tag->nodestart_adjusted\n           + skip_node_separator (subfile->contents\n                                  + tag->nodestart_adjusted));\n\n      /* Otherwise an anchor at the end of a node ends up displaying at\n         the end of the last line of the node (way over on the right of\n         the screen), which looks wrong.  */\n      if (node->display_pos >= (unsigned long) node->nodelen)\n        node->display_pos = node->nodelen - 1;\n      else if (node->display_pos < 0)\n        node->display_pos = 0; /* Shouldn't happen. */\n    }\n\n  return node;\n}",
      "lines": 141,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\ninfo_node_of_tag_ext (FILE_BUFFER *fb, TAG **tag_ptr, int fast)",
        "*"
      ]
    },
    "info_node_of_tag": {
      "start_point": [
        1322,
        0
      ],
      "end_point": [
        1326,
        1
      ],
      "content": "NODE *\ninfo_node_of_tag (FILE_BUFFER *fb, TAG **tag_ptr)\n{\n  return info_node_of_tag_ext (fb, tag_ptr, 0);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "NODE",
        "*\ninfo_node_of_tag (FILE_BUFFER *fb, TAG **tag_ptr)",
        "*"
      ]
    },
    "info_node_of_tag_fast": {
      "start_point": [
        1328,
        0
      ],
      "end_point": [
        1332,
        1
      ],
      "content": "NODE *\ninfo_node_of_tag_fast (FILE_BUFFER *fb, TAG **tag_ptr)\n{\n  return info_node_of_tag_ext (fb, tag_ptr, 1);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "NODE",
        "*\ninfo_node_of_tag_fast (FILE_BUFFER *fb, TAG **tag_ptr)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/info/nodes.h": {},
  "texinfo/texinfo-6.5/info/pcterm.c": {
    "w32_info_prep": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "void\nw32_info_prep (void)\n{\n  if (hinfo != INVALID_HANDLE_VALUE)\n    {\n      DWORD new_mode;\n\n      SetConsoleActiveScreenBuffer (hinfo);\n      current_attr = norm_attr;\n      hscreen = hinfo;\n      SetConsoleMode (hstdin, ENABLE_WINDOW_INPUT | ENABLE_MOUSE_INPUT);\n      GetConsoleMode (hscreen, &old_outpmode);\n      new_mode = old_outpmode & ~ENABLE_WRAP_AT_EOL_OUTPUT;\n      SetConsoleMode (hscreen, new_mode);\n      /* Enable underline, if available. */\n      SetConsoleMode (hscreen, new_mode | ENABLE_VIRTUAL_TERMINAL_PROCESSING);\n    }\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "w32_info_unprep": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "void\nw32_info_unprep (void)\n{\n  if (hinfo != INVALID_HANDLE_VALUE)\n    {\n      SetConsoleActiveScreenBuffer (hstdout);\n      current_attr = outside_info.normattr;\n      hscreen = hstdout;\n      SetConsoleMode (hstdin, old_inpmode);\n    }\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "w32_cleanup": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "void\nw32_cleanup (void)\n{\n  if (hinfo != INVALID_HANDLE_VALUE)\n    {\n      COORD cursor_pos;\n\n      /* Restore the original position of the cursor.  */\n      cursor_pos.X = outside_info.curx;\n      cursor_pos.Y = outside_info.cury;\n      SetConsoleCursorPosition (hstdout, cursor_pos);\n\n      /* Close the input handle we created.  */\n      CloseHandle (hinfo);\n    }\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "w32_info_init": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "static void\nw32_info_init (void)\n{\n  /* We need to set this single hook here; the rest\n     will be set by pc_initialize_terminal when it is called.  */\n  terminal_initialize_terminal_hook = pc_initialize_terminal;\n}",
      "lines": 7,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gettextinfo": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "static void\ngettextinfo (struct text_info *ti)\n{\n  CONSOLE_SCREEN_BUFFER_INFO csbi;\n  static TCHAR errbuf[500];\n  DWORD ignored;\n\n  hstdin = GetStdHandle (STD_INPUT_HANDLE);\n  hstdout = GetStdHandle (STD_OUTPUT_HANDLE);\n\n  if (!GetConsoleMode (hstdin, &ignored))\n    hstdin = INVALID_HANDLE_VALUE;\n\n  if (hstdout != INVALID_HANDLE_VALUE\n      && GetConsoleMode (hstdout, &ignored))\n    {\n      hinfo = CreateConsoleScreenBuffer (GENERIC_READ | GENERIC_WRITE,\n\t\t\t\t\t FILE_SHARE_READ | FILE_SHARE_WRITE,\n\t\t\t\t\t NULL, CONSOLE_TEXTMODE_BUFFER, NULL);\n      if (hinfo != INVALID_HANDLE_VALUE\n\t  && GetConsoleScreenBufferInfo (hstdout, &csbi))\n\t{\n\t  ti->normattr = csbi.wAttributes;\n\t  ti->winleft = 1;\n\t  ti->wintop = 1;\n\t  ti->winright = csbi.srWindow.Right + 1;\n\t  ti->winbottom = csbi.srWindow.Bottom - csbi.srWindow.Top + 1;\n\t  ti->attribute = csbi.wAttributes;\n\t  ti->screenheight = csbi.srWindow.Bottom - csbi.srWindow.Top + 1;\n\t  ti->screenwidth = csbi.srWindow.Right - csbi.srWindow.Left + 1;\n\t  ti->curx = csbi.dwCursorPosition.X;\n\t  ti->cury = csbi.dwCursorPosition.Y;\n\t  ti->bufsize = csbi.dwSize;\n\n\t  atexit (w32_cleanup);\n\t}\n      else\n\t{\n\t  DWORD error_no = GetLastError ();\n\n\t  if (!FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM, NULL,\n\t\t\t      error_no,\n\t\t\t      0, /* choose most suitable language */\n\t\t\t      errbuf, sizeof (errbuf), NULL))\n\t    sprintf (errbuf, \"w32 error %u\", error_no);\n\t  CloseHandle (hinfo);\n\t  info_error (_(\"Terminal cannot be initialized: %s\\n\"), errbuf);\n\t  exit (1);\n\t}\n    }\n  else\n    {\n      /* We were invoked non-interactively.  Do the minimum we must.   */\n      ti->screenheight = 24;\n      ti->screenwidth = 80;\n    }\n}",
      "lines": 57,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "textattr": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "void\ntextattr (int attr)\n{\n  if (hscreen != INVALID_HANDLE_VALUE)\n    SetConsoleTextAttribute (hscreen, attr);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "textmode": {
      "start_point": [
        243,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "void\ntextmode (int mode)\n{\n  /* Nothing.  */\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "highvideo": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        259,
        1
      ],
      "content": "void\nhighvideo (void)\n{\n  int attr;\n  CONSOLE_SCREEN_BUFFER_INFO csbi;\n\n  GetConsoleScreenBufferInfo (hscreen, &csbi);\n  attr = csbi.wAttributes | FOREGROUND_INTENSITY;\n  attr ^= norm_attr & FOREGROUND_INTENSITY;\n  textattr (attr);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "normvideo": {
      "start_point": [
        261,
        0
      ],
      "end_point": [
        272,
        1
      ],
      "content": "void\nnormvideo (void)\n{\n  int attr;\n  CONSOLE_SCREEN_BUFFER_INFO csbi;\n\n  GetConsoleScreenBufferInfo (hscreen, &csbi);\n  attr = csbi.wAttributes & ~(FOREGROUND_INTENSITY | BACKGROUND_INTENSITY\n\t\t\t      | COMMON_LVB_UNDERSCORE);\n  attr |= norm_attr & (FOREGROUND_INTENSITY | BACKGROUND_INTENSITY);\n  textattr (attr);\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "blinkvideo": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "void\nblinkvideo (void)\n{\n  int attr;\n  CONSOLE_SCREEN_BUFFER_INFO csbi;\n\n  GetConsoleScreenBufferInfo (hscreen, &csbi);\n  attr = csbi.wAttributes | BACKGROUND_INTENSITY;\n  attr ^= norm_attr & BACKGROUND_INTENSITY;\n  textattr (attr);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "underline": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        295,
        1
      ],
      "content": "void\nunderline (void)\n{\n  int attr;\n  CONSOLE_SCREEN_BUFFER_INFO csbi;\n\n  GetConsoleScreenBufferInfo (hscreen, &csbi);\n  attr = csbi.wAttributes | COMMON_LVB_UNDERSCORE;\n  textattr (attr);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "textcolor": {
      "start_point": [
        297,
        0
      ],
      "end_point": [
        306,
        1
      ],
      "content": "void\ntextcolor (int color)\n{\n  int attr;\n  CONSOLE_SCREEN_BUFFER_INFO csbi;\n\n  GetConsoleScreenBufferInfo (hscreen, &csbi);\n  attr = (csbi.wAttributes & (COMMON_LVB_UNDERSCORE | 0xf0)) | (color & 0x0f);\n  textattr (attr);\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "textbackground": {
      "start_point": [
        308,
        0
      ],
      "end_point": [
        317,
        1
      ],
      "content": "void\ntextbackground (int color)\n{\n  int attr;\n  CONSOLE_SCREEN_BUFFER_INFO csbi;\n\n  GetConsoleScreenBufferInfo (hscreen, &csbi);\n  attr = (csbi.wAttributes & (COMMON_LVB_UNDERSCORE | 0x0f)) | ((color & 0x0f) << 4);\n  textattr (attr);\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "ScreenGetCursor": {
      "start_point": [
        319,
        0
      ],
      "end_point": [
        332,
        1
      ],
      "content": "void\nScreenGetCursor (int *row, int *col)\n{\n  CONSOLE_SCREEN_BUFFER_INFO csbi;\n\n  if (hscreen == INVALID_HANDLE_VALUE)\n    *row = *col = 0;\n  else\n    {\n      GetConsoleScreenBufferInfo (hscreen, &csbi);\n      *row = csbi.dwCursorPosition.Y;\n      *col = csbi.dwCursorPosition.X;\n    }\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ScreenSetCursor": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        346,
        1
      ],
      "content": "void\nScreenSetCursor (int row, int col)\n{\n  if (hscreen != INVALID_HANDLE_VALUE)\n    {\n      COORD cursor_pos;\n\n      cursor_pos.X = col;\n      cursor_pos.Y = row;\n\n      SetConsoleCursorPosition (hscreen, cursor_pos);\n    }\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ScreenClear": {
      "start_point": [
        348,
        0
      ],
      "end_point": [
        362,
        1
      ],
      "content": "void\nScreenClear (void)\n{\n  if (hscreen != INVALID_HANDLE_VALUE)\n    {\n      DWORD nchars = screenwidth * screenheight;\n      COORD start_pos;\n      DWORD written;\n\n      start_pos.X = start_pos.Y = 0;\n      FillConsoleOutputAttribute (hscreen, norm_attr, nchars, start_pos,\n\t\t\t\t  &written);\n      FillConsoleOutputCharacter (hscreen, ' ', nchars, start_pos, &written);\n    }\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "clreol": {
      "start_point": [
        364,
        0
      ],
      "end_point": [
        382,
        1
      ],
      "content": "void\nclreol (void)\n{\n  if (hscreen != INVALID_HANDLE_VALUE)\n    {\n      DWORD nchars;\n      COORD start_pos;\n      DWORD written;\n      CONSOLE_SCREEN_BUFFER_INFO csbi;\n\n      GetConsoleScreenBufferInfo (hscreen, &csbi);\n      start_pos = csbi.dwCursorPosition;\n      nchars = csbi.dwSize.X - start_pos.X;\n\n      FillConsoleOutputAttribute (hscreen, current_attr, nchars, start_pos,\n\t\t\t\t  &written);\n      FillConsoleOutputCharacter (hscreen, ' ', nchars, start_pos, &written);\n    }\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "ScreenVisualBell": {
      "start_point": [
        384,
        0
      ],
      "end_point": [
        412,
        1
      ],
      "content": "void\nScreenVisualBell (void)\n{\n  if (hscreen != INVALID_HANDLE_VALUE)\n    {\n      DWORD nchars = screenwidth * screenheight;\n      COORD start_pos;\n      DWORD written;\n      PWORD attr;\n      DWORD i;\n\n      start_pos.X = start_pos.Y = 0;\n      attr = xmalloc (nchars * sizeof (WORD));\n      ReadConsoleOutputAttribute (hscreen, attr, nchars, start_pos, &written);\n      for (i = 0; i < nchars; ++i)\n\tattr[i] ^= norm_attr ^ inv_attr;\n      WriteConsoleOutputAttribute (hscreen, attr, nchars, start_pos, &written);\n      Sleep (50);\n      for (i = 0; i < nchars; ++i)\n\tattr[i] ^= norm_attr ^ inv_attr;\n      WriteConsoleOutputAttribute (hscreen, attr, nchars, start_pos, &written);\n      free (attr);\n    }\n  else\n    {\n      printf (\"%c\", '\\a');\n      fflush (stdout);\n    }\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "movetext": {
      "start_point": [
        414,
        0
      ],
      "end_point": [
        438,
        1
      ],
      "content": "int\nmovetext(int left, int top, int right, int bottom, int destleft, int desttop)\n{\n  if (hscreen != INVALID_HANDLE_VALUE)\n    {\n      SMALL_RECT src;\n      COORD dest;\n      CHAR_INFO fill;\n\n      src.Left = left - 1;\n      src.Top = top - 1;\n      src.Right = right - 1;\n      src.Bottom = bottom - 1;\n\n      dest.X = destleft - 1;\n      dest.Y = desttop - 1;\n\n      fill.Attributes = norm_attr;\n      fill.Char.AsciiChar = (CHAR)' ';\n\n      return ScrollConsoleScreenBuffer (hscreen, &src , NULL, dest, &fill) != 0;\n    }\n  else\n    return 0;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "ScreenRows": {
      "start_point": [
        440,
        0
      ],
      "end_point": [
        452,
        1
      ],
      "content": "int\nScreenRows (void)\n{\n  if (hscreen != INVALID_HANDLE_VALUE)\n    {\n      CONSOLE_SCREEN_BUFFER_INFO csbi;\n\n      GetConsoleScreenBufferInfo (hscreen, &csbi);\n      return csbi.srWindow.Bottom - csbi.srWindow.Top + 1;\n    }\n  else\n    return 24;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "ScreenCols": {
      "start_point": [
        454,
        0
      ],
      "end_point": [
        466,
        1
      ],
      "content": "int\nScreenCols (void)\n{\n  if (hscreen != INVALID_HANDLE_VALUE)\n    {\n      CONSOLE_SCREEN_BUFFER_INFO csbi;\n\n      GetConsoleScreenBufferInfo (hscreen, &csbi);\n      return csbi.srWindow.Right - csbi.srWindow.Left + 1;\n    }\n  else\n    return 80;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_set_screen_lines": {
      "start_point": [
        468,
        0
      ],
      "end_point": [
        489,
        1
      ],
      "content": "void\n_set_screen_lines (int lines)\n{\n  if (hscreen != INVALID_HANDLE_VALUE)\n    {\n      SMALL_RECT window_rectangle;\n      CONSOLE_SCREEN_BUFFER_INFO csbi;\n      COORD scrbufsize;\n\n      GetConsoleScreenBufferInfo (hscreen, &csbi);\n\n      window_rectangle = csbi.srWindow;\n      window_rectangle.Bottom = window_rectangle.Top + lines - 1;\n      SetConsoleWindowInfo (hscreen, TRUE, &window_rectangle);\n\n      /* Set the screen buffer size to the same dimensions as the window,\n\t so that the dysfunctional scroll bar disappears.  */\n      scrbufsize.X = window_rectangle.Right - window_rectangle.Left + 1;\n      scrbufsize.Y = window_rectangle.Bottom - window_rectangle.Top + 1;\n      SetConsoleScreenBufferSize (hscreen, scrbufsize);\n    }\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "w32_set_screen_dimensions": {
      "start_point": [
        491,
        0
      ],
      "end_point": [
        506,
        1
      ],
      "content": "void\nw32_set_screen_dimensions (int cols, int rows)\n{\n  if (hscreen != INVALID_HANDLE_VALUE)\n    {\n      SMALL_RECT window_rectangle;\n      CONSOLE_SCREEN_BUFFER_INFO csbi;\n\n      GetConsoleScreenBufferInfo (hscreen, &csbi);\n\n      window_rectangle = csbi.srWindow;\n      window_rectangle.Bottom = window_rectangle.Top + rows - 1;\n      window_rectangle.Right = window_rectangle.Left + cols - 1;\n      SetConsoleWindowInfo (hscreen, TRUE, &window_rectangle);\n    }\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "sleep": {
      "start_point": [
        509,
        0
      ],
      "end_point": [
        514,
        1
      ],
      "content": "unsigned\nsleep (unsigned sec)\n{\n  Sleep (sec*1000);\n  return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "unsigned",
        "unsigned"
      ]
    },
    "w32_our_tty": {
      "start_point": [
        518,
        0
      ],
      "end_point": [
        524,
        1
      ],
      "content": "static int\nw32_our_tty (int fd)\n{\n  /* Is this our tty?  */\n  return hstdin != INVALID_HANDLE_VALUE\n\t && hstdin == (HANDLE)_get_osfhandle (fd);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "w32keyseq": {
      "start_point": [
        536,
        0
      ],
      "end_point": [
        622,
        1
      ],
      "content": "static int\nw32keyseq (unsigned char ascii_ch, WORD vkey, DWORD ctl, unsigned char *seq)\n{\n  unsigned char *p = seq;\n\n  switch (ascii_ch)\n    {\n      case '\\0':\n\t/* Keys with no ASCII code are extended keys, like arrows.  */\n\tswitch (vkey)\n\t  {\n\t    case VK_PRIOR:\n\t      define_seq (p, \"\\033\\061p\", \"\\033v\");\n\t      break;\n\t    case VK_NEXT:\n\t      define_seq (p, \"\\033\\061n\", \"\\026\");\n\t      break;\n\t    case VK_END:\n\t      define_seq (p, \"\\033>\", \"\\033>\");\n\t      break;\n\t    case VK_HOME:\n\t      define_seq (p, \"\\033<\", \"\\033<\");\n\t      break;\n\t    case VK_LEFT:\n\t      define_seq (p, \"\\033b\", \"\\033[D\");\n\t      break;\n\t    case VK_UP:\n\t      define_seq (p, \"\\033\\061u\", \"\\033[A\");\n\t      break;\n\t    case VK_RIGHT:\n\t      define_seq (p, \"\\033f\", \"\\033[C\");\n\t      break;\n\t    case VK_DOWN:\n\t      define_seq (p, \"\\033\\061m\", \"\\033[B\");\n\t      break;\n\t    case VK_INSERT:\n\t      define_seq (p, \"\\033[L\", \"\\033[L\");\n\t      break;\n\t    case VK_DELETE:\t/* Delete => Ctrl-d, Alt-Delete => ESC d */\n\t      if ((ctl & (LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED)) != 0)\n\t\tdefine_seq (p, \"\\033d\", \"\\033d\");\n\t      else\n\t\tdefine_seq (p, \"\\033d\", \"\\004\");\n\t      break;\n\t    case VK_HELP:\t/* F1 => Ctrl-h */\n\t    case VK_F1:\n\t      *p++ = '\\010';\n\t      break;\n\t    case 50:\t\t/* Ctrl-@ => '\\0' */\n\t      if ((ctl & SHIFT_PRESSED) != 0)\n\t\t*p++ = '\\0';\n\t      break;\n\t    default:\n\t      if (0x41 <= vkey && vkey <= 0x5a)\n\t\t{\n\t\t  /* Alt-Ctrl-a, Alt-Ctrl-b, etc.  */\n\t\t  *p++ = '\\033';\n\t\t  *p++ = '\\001' + vkey - 0x41;\n\t\t}\n\t  }\n\tbreak;\n      case ' ':\t\t\t/* Ctrl-SPC => '\\0' */\n\tif ((ctl & (LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED)) != 0)\n\t  ascii_ch = '\\0';\n\t*p++ = ascii_ch;\n\tbreak;\n      case '\\t':\t\t/* Shift-TAB/Alt-TAB => Esc-TAB */\n\tif ((ctl & (SHIFT_PRESSED | LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED)) != 0)\n\t  {\n\t    memcpy (p, \"\\033\\011\", sizeof (\"\\033\\011\"));\n\t    p += sizeof (\"\\033\\011\") - 1;\n\t  }\n\telse\n\t  *p++ = '\\t';\n\tbreak;\n      case '\\b':\n\t/* Backspace => DEL.  */\n\tascii_ch = '\\177';\n\t/* FALLTHROUGH */\n      default:\n\tif ((ctl & (LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED)) != 0)\n\t  *p++ = '\\033';\n\t*p++ = ascii_ch;\n\tbreak;\n    }\n  return p - seq;\n}",
      "lines": 87,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "w32_kbd_read": {
      "start_point": [
        628,
        0
      ],
      "end_point": [
        755,
        1
      ],
      "content": "static ssize_t\nw32_kbd_read (unsigned char *inbuf, size_t n)\n{\n  DWORD nevents, nread;\n  INPUT_RECORD inrec;\n  ssize_t nret = 0;\n\n  do {\n\n    /* Stuff any unread buffered characters.  */\n    while (buf_head < buf_tail && n > 0)\n      {\n\t*inbuf++ = buffered_chars[buf_head++];\n\tnret++;\n\tn--;\n      }\n    if (n <= 0)\n      break;\n\n    /* Wait for input.  */\n    while (GetNumberOfConsoleInputEvents (hstdin, &nevents)\n\t   && nevents < 1)\n      Sleep (20);\n\n    while (nevents-- && n > 0)\n      {\n\tif (!ReadConsoleInput (hstdin, &inrec, 1, &nread))\n\t  return -1;\n\n\tif (nread > 0)\n\t  {\n\t    switch (inrec.EventType)\n\t      {\n\t\tcase KEY_EVENT:\n\t\t  if (inrec.Event.KeyEvent.bKeyDown == TRUE\n\t\t      && !(inrec.Event.KeyEvent.wVirtualScanCode == 0\n\t\t\t   || inrec.Event.KeyEvent.wVirtualKeyCode == VK_SHIFT\n\t\t\t   || inrec.Event.KeyEvent.wVirtualKeyCode == VK_CONTROL\n\t\t\t   || inrec.Event.KeyEvent.wVirtualKeyCode == VK_MENU))\n\t\t    {\n\t\t      unsigned char keyseq[10];\n\t\t      int count = inrec.Event.KeyEvent.wRepeatCount;\n\t\t      unsigned char ch = inrec.Event.KeyEvent.uChar.AsciiChar;\n\t\t      WORD vkey = inrec.Event.KeyEvent.wVirtualKeyCode;\n\t\t      DWORD ctl_state = inrec.Event.KeyEvent.dwControlKeyState;\n\t\t      int nbytes = w32keyseq (ch, vkey, ctl_state, keyseq);\n\n\t\t      /* Supply up to N characters to the caller.  */\n\t\t      while (count && n >= nbytes)\n\t\t\t{\n\t\t\t  if (nbytes == 1 && keyseq[0] == '\\032')\n\t\t\t    {\n\t\t\t      terminal_goto_xy (0, screenheight - 1);\n\t\t\t      terminal_clear_to_eol ();\n\t\t\t      fflush (stdout);\n\t\t\t      terminal_unprep_terminal ();\n\t\t\t      kill (getpid (), 0);\n\t\t\t      terminal_prep_terminal ();\n\t\t\t      reset_info_window_sizes ();\n\t\t\t    }\n\t\t\t  else\n\t\t\t    {\n\t\t\t      memcpy (&inbuf[nret], keyseq, nbytes);\n\t\t\t      nret += nbytes;\n\t\t\t      n -= nbytes;\n\t\t\t    }\n\t\t\t  count--;\n\t\t\t}\n\t\t      /* Buffer the rest.  */\n\t\t      if (count > 0)\n\t\t\t{\n\t\t\t  buf_head = buf_tail = 0;\n\t\t\t  while (count--\n\t\t\t\t && buf_tail < sizeof(buffered_chars) - nbytes)\n\t\t\t    {\n\t\t\t      memcpy (&buffered_chars[buf_tail], keyseq, nbytes);\n\t\t\t      buf_tail += nbytes;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t  break;\n\t\tcase WINDOW_BUFFER_SIZE_EVENT:\n\t\t  {\n\t\t    int rows, cols;\n\n\t\t    /* Note: this event is only sent when the console\n\t\t       window's _screen_buffer_ size is changed via\n\t\t       the Properties->Layout dialog.  */\n\t\t    cols = inrec.Event.WindowBufferSizeEvent.dwSize.X;\n\t\t    rows = inrec.Event.WindowBufferSizeEvent.dwSize.Y;\n\t\t    screenwidth = cols;\n\t\t    screenheight = rows;\n\t\t    w32_set_screen_dimensions (cols, rows);\n\t\t    display_initialize_display (screenwidth, screenheight);\n\t\t    window_new_screen_size (screenwidth, screenheight);\n\t\t    redisplay_after_signal ();\n\t\t  }\n\t\t  break;\n\t\tcase MOUSE_EVENT:\n\t\t  {\n\t\t    /* Only vertical wheel support for now.  */\n\t\t    int wheeled =\n\t\t      (inrec.Event.MouseEvent.dwEventFlags & MOUSE_WHEELED) != 0;\n\t\t    if (wheeled && mouse_protocol == MP_NORMAL_TRACKING)\n\t\t      {\n\t\t\textern void info_up_line (WINDOW *, int count);\n\t\t\textern void info_down_line (WINDOW *, int count);\n\t\t\textern WINDOW *active_window;\n\n\t\t\tint hiword =\n\t\t\t  HIWORD (inrec.Event.MouseEvent.dwButtonState);\n\n\t\t\tif ((hiword & 0xFF00) == 0)\n\t\t\t  info_up_line (active_window, 3);\n\t\t\telse\n\t\t\t  info_down_line (active_window, 3);\n\t\t\tdisplay_update_display ();\n\t\t      }\n\t\t  }\n\t\t  break;\n\t\tdefault:\n\t\t  break;\n\t      }\n\t  }\n      }\n  } while (n > 0);\n  return nret;\n}",
      "lines": 128,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "w32_chars_avail": {
      "start_point": [
        757,
        0
      ],
      "end_point": [
        771,
        1
      ],
      "content": "long\nw32_chars_avail (int fd)\n{\n  if (w32_our_tty (fd))\n    return buf_tail - buf_head;\n  else\n    {\n      struct stat st;\n\n      if (fstat (fd, &st) < 0)\n\treturn 1;\n      else\n\treturn st.st_size;\n    }\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "long",
        "long"
      ]
    },
    "w32_read": {
      "start_point": [
        773,
        0
      ],
      "end_point": [
        780,
        1
      ],
      "content": "ssize_t\nw32_read (int fd, void *buf, size_t n)\n{\n  if (w32_our_tty (fd))\n    return w32_kbd_read (buf, n);\n  else\n    return _read (fd, buf, n);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "ssize_t"
      ]
    },
    "write_utf": {
      "start_point": [
        783,
        0
      ],
      "end_point": [
        808,
        1
      ],
      "content": "static void\nwrite_utf (DWORD cp, const char *text, int nbytes)\n{\n  /* MSDN says UTF-7 requires zero in flags.  */\n  DWORD flags = (cp == CP_UTF7) ? 0 : MB_ERR_INVALID_CHARS;\n  /* How much space do we need for wide characters?  */\n  int wlen = MultiByteToWideChar (cp, flags, text, nbytes, NULL, 0);\n\n  if (wlen)\n    {\n      WCHAR *text_w = alloca (wlen * sizeof (WCHAR));\n      DWORD written;\n\n      if (MultiByteToWideChar (cp, flags, text, nbytes, text_w, wlen) > 0)\n\t{\n\t  WriteConsoleW (hscreen, text_w, (nbytes < 0) ? wlen - 1 : wlen,\n\t\t\t &written, NULL);\n\t  return;\n\t}\n    }\n  /* Fall back on conio.  */\n  if (nbytes < 0)\n    cputs (text);\n  else\n    cprintf (\"%.*s\", nbytes, text);\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rpl_nl_langinfo": {
      "start_point": [
        818,
        0
      ],
      "end_point": [
        832,
        1
      ],
      "content": "char *\nrpl_nl_langinfo (nl_item item)\n{\n  if (item == CODESET)\n    {\n      static char buf[100];\n\n      /* We need all the help we can get from GNU libiconv, so we\n\t request transliteration as well.  */\n      sprintf (buf, \"CP%u//TRANSLIT\", GetConsoleOutputCP ());\n      return buf;\n    }\n  else\n    return nl_langinfo (item);\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "char",
        "*\nrpl_nl_langinfo (nl_item item)",
        "*"
      ]
    },
    "wcwidth": {
      "start_point": [
        844,
        0
      ],
      "end_point": [
        848,
        1
      ],
      "content": "int\nwcwidth (wchar_t wc)\n{\n  return wc == 0 ? 0 : iswprint (wc) ? 1 : -1;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "pc_begin_inverse": {
      "start_point": [
        854,
        0
      ],
      "end_point": [
        858,
        1
      ],
      "content": "static void\npc_begin_inverse (void)\n{\n  textattr (inv_attr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pc_end_inverse": {
      "start_point": [
        861,
        0
      ],
      "end_point": [
        865,
        1
      ],
      "content": "static void\npc_end_inverse (void)\n{\n  textattr (norm_attr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pc_begin_underline": {
      "start_point": [
        870,
        0
      ],
      "end_point": [
        877,
        1
      ],
      "content": "static void\npc_begin_underline (void)\n{\n  if (xref_attr != COMMON_LVB_UNDERSCORE)\n    textattr (xref_attr);\n  else\n    underline ();\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pc_end_underline": {
      "start_point": [
        879,
        0
      ],
      "end_point": [
        886,
        1
      ],
      "content": "static void\npc_end_underline (void)\n{\n  if (xref_attr != COMMON_LVB_UNDERSCORE)\n    textattr (norm_attr);\n  else\n    normvideo ();\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pc_begin_standout": {
      "start_point": [
        889,
        0
      ],
      "end_point": [
        893,
        1
      ],
      "content": "static void\npc_begin_standout (void)\n{\n  highvideo ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pc_end_standout": {
      "start_point": [
        895,
        0
      ],
      "end_point": [
        899,
        1
      ],
      "content": "static void\npc_end_standout (void)\n{\n  normvideo ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pc_begin_blink": {
      "start_point": [
        901,
        0
      ],
      "end_point": [
        905,
        1
      ],
      "content": "static void\npc_begin_blink (void)\n{\n  blinkvideo ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pc_default_color": {
      "start_point": [
        907,
        0
      ],
      "end_point": [
        911,
        1
      ],
      "content": "static void\npc_default_color (void)\n{\n  textattr (norm_attr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "convert_color": {
      "start_point": [
        918,
        0
      ],
      "end_point": [
        933,
        1
      ],
      "content": "static int\nconvert_color (int terminal_color)\n{\n  /* The terminal.h order is:\n     black, red, green, yellow, blue, magenta, cyan, white.  */\n  static int pc_color_map[] = {\n    0, 4, 2, 6, 1, 5, 3, 7\n  };\n  int intensity = terminal_color & (FOREGROUND_INTENSITY | BACKGROUND_INTENSITY);\n  terminal_color &= ~(FOREGROUND_INTENSITY | BACKGROUND_INTENSITY);\n\n  if (terminal_color >= 0\n      && terminal_color < sizeof(pc_color_map) / sizeof (pc_color_map[0]))\n    return pc_color_map[terminal_color] | intensity;\n  return 7;\t/* lightgray */\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "pc_set_fg_color": {
      "start_point": [
        935,
        0
      ],
      "end_point": [
        939,
        1
      ],
      "content": "static void\npc_set_fg_color (int color)\n{\n  textcolor (convert_color (color) | (norm_attr & FOREGROUND_INTENSITY));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pc_set_bg_color": {
      "start_point": [
        941,
        0
      ],
      "end_point": [
        945,
        1
      ],
      "content": "static void\npc_set_bg_color (int color)\n{\n  textbackground (convert_color (color) | (norm_attr & BACKGROUND_INTENSITY));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pc_up_line": {
      "start_point": [
        948,
        0
      ],
      "end_point": [
        954,
        1
      ],
      "content": "static void\npc_up_line (void)\n{\n  int x, y;\n  ScreenGetCursor (&y, &x);\n  ScreenSetCursor (MAX (y-1, 0), x);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pc_down_line": {
      "start_point": [
        957,
        0
      ],
      "end_point": [
        963,
        1
      ],
      "content": "static void\npc_down_line (void)\n{\n  int x, y;\n  ScreenGetCursor (&y, &x);\n  ScreenSetCursor (MIN (screenheight-1, y+1), x);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pc_clear_screen": {
      "start_point": [
        966,
        0
      ],
      "end_point": [
        970,
        1
      ],
      "content": "static void\npc_clear_screen (void)\n{\n  ScreenClear ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pc_clear_to_eol": {
      "start_point": [
        973,
        0
      ],
      "end_point": [
        977,
        1
      ],
      "content": "static void\npc_clear_to_eol (void)\n{\n  clreol (); /* perhaps to be replaced by a loop */\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pc_get_screen_size": {
      "start_point": [
        980,
        0
      ],
      "end_point": [
        996,
        1
      ],
      "content": "static void\npc_get_screen_size(void)\n{\n  /* Current screen dimensions are the default.  */\n  if (!outside_info.screenheight)\t/* paranoia */\n    gettextinfo (&outside_info);\n  screenwidth  = outside_info.screenwidth;\n  screenheight = outside_info.screenheight;\n\n  /* Environment variable \"LINES\" overrides the default.  */\n  if (getenv (\"LINES\") != NULL)\n    screenheight = atoi (getenv (\"LINES\"));\n\n  /* Environment variable \"INFO_LINES\" overrides \"LINES\".  */\n  if (getenv (\"INFO_LINES\") != NULL)\n    screenheight = atoi (getenv (\"INFO_LINES\"));\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pc_ring_bell": {
      "start_point": [
        1025,
        0
      ],
      "end_point": [
        1035,
        1
      ],
      "content": "static void\npc_ring_bell(void)\n{\n  if (terminal_has_visible_bell_p && terminal_use_visible_bell_p)\n    ScreenVisualBell ();\n  else\n    {\n      printf (\"%c\",'\\a');\n      fflush (stdout);\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pc_prep_terminal": {
      "start_point": [
        1084,
        0
      ],
      "end_point": [
        1113,
        1
      ],
      "content": "static void\npc_prep_terminal (void)\n{\n  int tty;\n\n#ifdef _WIN32\n  w32_info_prep ();\n#endif\n\n  /* Do not set screen height if we already have it, because\n     doing so erases the screen.  */\n  if (screenheight != ScreenRows ())\n    _set_screen_lines (screenheight);\n\n  /* Don't fail if they asked for screen dimensions that their\n     hardware cannot support.  */\n  screenheight = ScreenRows ();\n  screenwidth  = ScreenCols ();\n\n  /* Try setting the colors user asked for.  */\n  textattr (norm_attr);\n  ScreenClear ();\n\n  /* Switch console reads to binary mode.  */\n  tty = fileno (stdin);\n#ifdef __DJGPP__\n  setmode (tty, O_BINARY);\n  __djgpp_set_ctrl_c (1);\t/* re-enable SIGINT generation by Ctrl-C */\n#endif\n}",
      "lines": 30,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pc_unprep_terminal": {
      "start_point": [
        1117,
        0
      ],
      "end_point": [
        1149,
        1
      ],
      "content": "static void\npc_unprep_terminal (void)\n{\n  int tty;\n\n#ifdef _WIN32\n  w32_info_unprep ();\n#endif\n\n  textattr (outside_info.normattr);\n\n  /* Do not set screen height if we already have it, because\n     doing so erases the screen.  */\n  if (outside_info.screenheight != ScreenRows ())\n    {\n      _set_screen_lines (outside_info.screenheight);\n      textmode (LASTMODE);\n    }\n#ifdef __MSDOS__\n  else\n    pc_clear_to_eol ();\t/* for text attributes to really take effect */\n#endif\n#ifdef _WIN32\n  if (hscreen != INVALID_HANDLE_VALUE)\n    SetConsoleScreenBufferSize (hstdout, outside_info.bufsize);\n#endif\n\n  /* Switch back to text mode on stdin.  */\n  tty = fileno (stdin);\n#ifdef __DJGPP__\n  setmode (tty, O_TEXT);\n#endif\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "find_sequence": {
      "start_point": [
        1429,
        0
      ],
      "end_point": [
        1439,
        1
      ],
      "content": "static unsigned const char *\nfind_sequence (int key)\n{\n  int i;\n\n  for (i = 0; DJGPP_keytab[i].inkey; i++)\n    if (key == DJGPP_keytab[i].inkey)\n      return DJGPP_keytab[i].sequence;\n\n  return NULL;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned",
        "const",
        "const",
        "char",
        "char",
        "*\nfind_sequence (int key)",
        "*"
      ]
    },
    "kbd_buffer_empty": {
      "start_point": [
        1443,
        0
      ],
      "end_point": [
        1454,
        1
      ],
      "content": "static int\nkbd_buffer_empty (void)\n{\n  __dpmi_regs r;\n  int retval;\n\n  r.h.ah = 0x11;\t/* Get enhanced keyboard status */\n  __dpmi_int (0x16, &r);\n\n  /* If the keyboard buffer is empty, the Zero Flag will be set.  */\n  return (r.x.flags & 0x40) == 0x40;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "pc_term_chars_avail": {
      "start_point": [
        1465,
        0
      ],
      "end_point": [
        1476,
        1
      ],
      "content": "long\npc_term_chars_avail (void)\n{\n  if (buf_idx >= sizeof (buffered)) /* paranoia */\n    {\n      buf_idx = 0;\n      buffered[buf_idx] = '\\0';\n      return 0;\n    }\n  else\n    return strlen (buffered + buf_idx);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "long",
        "long"
      ]
    },
    "keyboard_read": {
      "start_point": [
        1484,
        0
      ],
      "end_point": [
        1564,
        1
      ],
      "content": "static int\nkeyboard_read (__FSEXT_Fnumber func, int *retval, va_list rest_args)\n{\n  /* When we are called, REST_ARGS are: file_descriptor, buf, nbytes.  */\n  unsigned char *buf;\n  size_t nbytes, nread = 0;\n  int fd = va_arg (rest_args, int);\n\n  /* Is this call for us?  */\n  if (func != __FSEXT_read || !isatty (fd))\n    return 0;\t/* and the usual DOS call will be issued */\n\n  buf = va_arg (rest_args, unsigned char *);\n  nbytes = va_arg (rest_args, size_t);\n\n  if (!buf)\n    {\n      errno = EINVAL;\n      *retval = -1;\n      return 1;\n    }\n  if (!nbytes)\n    {\n      *retval = 0;\n      return 1;\n    }\n\n  /* Loop here until enough bytes has been read.  */\n  do\n    {\n      int key;\n\n      /* If any ``buffered characters'' are left, return as much\n\t of them as the caller wanted.  */\n      while (buffered[buf_idx] && nbytes)\n\t{\n\t  *buf++ = buffered[buf_idx++];\n\t  nread++;\n\t  nbytes--;\n\t}\n\n      if (nbytes <= 0)\n\tbreak;\n\n      /* Wait for another key.\n\t We do that in a busy-waiting loop so we don't get parked\n\t inside a BIOS call, which will effectively disable signals.\n         While we wait for them to type something, we repeatedly\n         release the rest of our time slice, so that other programs\n         in a multitasking environment, such as Windows, get more cycles.  */\n      while (kbd_buffer_empty ())\n\t__dpmi_yield ();\n\n      key = getxkey ();\n\n      /* Translate the key if necessary.\n\t Untranslated non-ASCII keys are silently ignored.  */\n      if ((key & 0x300) != 0)\n\t{\n\t  unsigned char const * key_sequence = find_sequence (key);\n\n\t  if (key_sequence != NULL)\n\t    {\n\t      strcpy (buffered, key_sequence);\n\t      buf_idx = 0;\n\t    }\n\t}\n      else if (key == K_Control_Z)\n\traise (SIGUSR1);\t/* we don't have SIGTSTP, so simulate it */\n      else if (key <= 0xff)\n\t{\n\t  *buf++ = key;\n\t  nbytes--;\n\t  nread++;\n\t}\n    }\n  while (nbytes > 0);\n\n  *retval = nread;\n  return 1;\t/* meaning that we handled the call */\n}",
      "lines": 81,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "install_keyboard_handler": {
      "start_point": [
        1568,
        0
      ],
      "end_point": [
        1576,
        1
      ],
      "content": "static void __attribute__((constructor))\ninstall_keyboard_handler (void)\n{\n  __FSEXT_set_function (fileno (stdin), keyboard_read);\n\n  /* We need to set this single hook here; the rest\n     will be set by pc_initialize_terminal when it is called.  */\n  terminal_initialize_terminal_hook = pc_initialize_terminal;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "__attribute__((constructor))",
        "__attribute__",
        "(",
        "(constructor)",
        "(",
        "constructor",
        ")",
        ")"
      ]
    },
    "kill": {
      "start_point": [
        1603,
        0
      ],
      "end_point": [
        1680,
        1
      ],
      "content": "int\nkill (pid_t pid, int sig)\n{\n  static char interrupted_msg[] = \"Interrupted\\r\\n\";\n  static char stopped_msg[] = \"Stopped.  Type 'exit RET' to return.\\r\\n\";\n  char cwd[PATH_MAX + 1];\n\n  if (pid == getpid ()\n      || pid == 0\n      || pid == -1\n      || pid == -getpid ())\n    {\n      switch (sig)\n\t{\n\tRETSIGTYPE (*old_INT)(int), (*old_QUIT)(int);\n\n\tcase SIGINT:\n#ifdef __DJGPP__\n\t  /* If SIGINT was generated by a readable key, we want to remove\n\t     it from the PC keyboard buffer, so that DOS and other\n\t     programs never see it.  DJGPP signal-handling mechanism\n\t     doesn't remove the INT key from the keyboard buffer.  */\n\t  if (!kbd_buffer_empty ())\n\t    getxkey ();\n#endif\n\t  pc_write_chars (interrupted_msg, sizeof (interrupted_msg) - 1);\n\t  exit (EXIT_FAILURE);\n\tcase SIGUSR1:\n\t  /* Simulate SIGTSTP by invoking a subsidiary shell.  */\n#ifndef _WIN32\n\t  pc_goto_xy (0, outside_info.screenheight - 1);\n\t  pc_clear_to_eol ();\n\t  pc_write_chars (stopped_msg, sizeof (stopped_msg) - 1);\n#endif\n\n\t  /* The child shell can change the working directory, so\n\t     we need to save and restore it, since it is global.  */\n\t  if (!getcwd (cwd, PATH_MAX)) /* should never happen */\n\t    cwd[0] = '\\0';\n\n\t  /* We don't want to get fatal signals while the subshell runs.  */\n\t  old_INT = signal (SIGINT, SIG_IGN);\n\t  old_QUIT = signal (SIGQUIT, SIG_IGN);\n#ifdef _WIN32\n\t  {\n\t    const char *argv[2];\n\t    const char *shell = NULL;\n\n\t    argv[0] = NULL;\n\t    shell = getenv (\"SHELL\");\n\t    if (!shell)\n\t      {\n\t\tshell = getenv (\"COMSPEC\");\n\t\tif (!shell)\n\t\t  return -1;\n\t\targv[0] = \" /k\";\n\t      }\n\t    argv[1] = NULL;\n\t    _spawnvp (_P_WAIT, shell, argv);\n\t  }\n#else\n\t  system (\"\");\n#endif\n\t  if (*cwd)\n\t    chdir (cwd);\n\t  signal (SIGINT, old_INT);\n\t  signal (SIGQUIT, old_QUIT);\n\t  break;\n\tdefault:\n\t  if (sig)\n\t    raise (sig);\n\t  break;\n\t}\n      return 0;\n    }\n  else\n    return -1;\n}",
      "lines": 78,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "tputs": {
      "start_point": [
        1684,
        0
      ],
      "end_point": [
        1687,
        1
      ],
      "content": "int       tputs (const char *a, int b, int (*c)(int))\n{\n  perror (\"tputs\"); return 0; /* here and below, added dummy retvals */\n}",
      "lines": 4,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "tgoto": {
      "start_point": [
        1689,
        0
      ],
      "end_point": [
        1692,
        1
      ],
      "content": "char*     tgoto (const char *a, int b, int c)\n{\n  perror (\"tgoto\"); return 0;\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "char",
        "*     tgoto (const char *a, int b, int c)",
        "*"
      ]
    },
    "tgetnum": {
      "start_point": [
        1694,
        0
      ],
      "end_point": [
        1697,
        1
      ],
      "content": "int       tgetnum (char*a)\n{\n  perror (\"tgetnum\"); return 0;\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "tgetflag": {
      "start_point": [
        1699,
        0
      ],
      "end_point": [
        1702,
        1
      ],
      "content": "int       tgetflag (char*a)\n{\n  perror (\"tgetflag\"); return 0;\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "tgetstr": {
      "start_point": [
        1704,
        0
      ],
      "end_point": [
        1707,
        1
      ],
      "content": "char*     tgetstr (char *a, char **b)\n{\n  perror (\"tgetstr\"); return 0;\n}",
      "lines": 4,
      "depth": 8,
      "decorators": [
        "char",
        "*     tgetstr (char *a, char **b)",
        "*"
      ]
    },
    "tgetent": {
      "start_point": [
        1709,
        0
      ],
      "end_point": [
        1712,
        1
      ],
      "content": "int       tgetent (char *a, const char *b)\n{\n  perror (\"tgetent\"); return 0;\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "tcgetattr": {
      "start_point": [
        1714,
        0
      ],
      "end_point": [
        1717,
        1
      ],
      "content": "int\ttcgetattr(int fildes, struct termios *termios_p)\n{\n  perror (\"tcgetattr\"); return 0;\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "tcsetattr": {
      "start_point": [
        1719,
        0
      ],
      "end_point": [
        1722,
        1
      ],
      "content": "int\ttcsetattr(int fd, int opt_actions, const struct termios *termios_p)\n{\n  perror (\"tcsetattr\"); return 0;\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/info/pseudotty.c": {
    "main": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int master, slave, control;\n  char *name;\n  fd_set read_set;\n\n  error (0, 0, \"getting pty master fd\");\n  master = posix_openpt (O_RDWR);\n  if (master == -1)\n    exit (1);\n\n  error (0, 0, \"unlocking slave device\");\n  if (grantpt (master) < 0 || unlockpt (master) < 0)\n    exit (1);\n  error (0, 0, \"getting file name of slave device...\");\n  name = ptsname (master);\n  if (!name)\n    exit (1);\n  error (0, 0, \"%s\", name);\n\n  error (0, 0, \"opening slave device\");\n  slave = open (name, O_RDWR);\n  if (slave == -1)\n    exit (1);\n\n#ifdef HAVE_STROPTS_H\n  if (!isatty (slave))\n    {\n      error (0, 0, \"performing STREAMS ioctl's on slave\");\n      if (isastream (slave))\n        {\n          if (ioctl (slave, I_PUSH, \"ptem\") < 0\n              || ioctl (slave, I_PUSH, \"ldterm\") < 0)\n            error (1, 0, \"STREAMS ioctl's failed\");\n        }\n    }\n  /* Don't close it because it just leads to an EOF read at the master end. */\n  /*\n  error (0, 0, \"closing slave device\");\n  close (slave);\n  error (0, 0, \"...closed\");\n  */\n#endif\n\n#if defined (HAVE_TERMIOS_H)\n  {\n  struct termios t;\n  long int disable;\n  disable = fpathconf (slave, _PC_VDISABLE);\n  if (tcgetattr (slave, &t) == -1)\n    error (0, 0, \"error calling tcgetattr\");\n  else\n    {\n      t.c_cc[VSTART] = disable; /* C-q */\n      t.c_cc[VSTOP] = disable;  /* C-s */\n      t.c_cc[VKILL] = disable;  /* C-u */\n      t.c_cc[VINTR] = disable;  /* C-c */\n      if (tcsetattr (slave, TCSANOW, &t) == -1)\n        error (0, 0, \"error calling tcsetattr\");\n    }\n  }\n#endif\n\n#if defined (TIOCSWINSZ)\n  {\n    struct winsize ws;\n    ws.ws_col = ws.ws_row = 0;\n\n    error (0, 0, \"attempting to set window size\");\n    if (ioctl (master, TIOCSWINSZ, &ws) == 0)\n      error (0, 0, \"...succeeded\");\n    else\n      error (0, 0, \"...failed\");\n  }\n#endif \n\n  printf (\"%s\\n\", name);\n  if (fclose (stdout) != 0)\n    error (1, 0, \"error closing stdout: aborting\");\n\n  error (0, 0, \"opening control channel\");\n  control = open (argv[1], O_RDONLY);\n  if (control == -1)\n    error (1, 0, \"error opening control channel: aborting\");\n\n\n  FD_ZERO (&read_set);\n\n  error (0, 0, \"entering main loop\");\n  while (1)\n    {\n      FD_SET (master, &read_set);\n      FD_SET (control, &read_set);\n\n      select (FD_SETSIZE, &read_set, 0, 0, 0);\n\n      if (FD_ISSET (control, &read_set))\n        {\n          char c;\n          int success;\n          errno = 0;\n          while (1)\n            {\n              error (0, 0, \"trying to read\");\n              success = read (control, &c, 1);\n              if (success < 0)\n                {\n                  if (errno != EINTR)\n                    error (1, errno, \"read error on control channel\");\n                }\n              else if (success == 0)\n                {\n                  error (1, 0, \"end of file on control channel\");\n                }\n              else if (success == 1)\n                {\n                  error (0, 0, \"read byte 0x%02X\", c);\n                  break;\n                }\n            }\n\n          /* Feed any read bytes to the program being controlled. */\n          do\n            {\n              success = write (master, &c, 1);\n              if (success == 0)\n                {\n                  error (0, 0, \"couldn't send byte!\");\n                  sleep (1);\n                  continue;\n                }\n            }\n          while (success == -1 && errno == EINTR);\n\n          if (success != 1)\n            {\n              /* The controlled process has probably exited, or been killed. */\n              error (0, 0, \"couldn't send byte (giving up)\");\n              sleep (1);\n            }\n        }\n\n      if (FD_ISSET (master, &read_set))\n        {\n          char c;\n          int success;\n          errno = 0;\n          do\n            {\n              success = read (master, &c, 1);\n            }\n          while (success == -1 && errno == EINTR);\n\n          if (success == -1)\n            {\n              /* The controlled process has probably exited, or been killed. */\n              error (0, 0, \"read error on master fd\");\n              sleep (1);\n            }\n        }\n    }\n\n  return 0; /* NOTREACHED */\n}",
      "lines": 165,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/info/search.c": {
    "search": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "enum search_result\nsearch (char *string, SEARCH_BINDING *binding, long *poff)\n{\n  enum search_result result;\n\n  /* If the search is backwards, then search backwards, otherwise forwards. */\n  if (binding->start > binding->end)\n    result = search_backward (string, binding, poff);\n  else\n    result = search_forward (string, binding, poff);\n\n  return result;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "enum search_result",
        "enum",
        "search_result"
      ]
    },
    "regexp_expand_newlines_and_tabs": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "static char *\nregexp_expand_newlines_and_tabs (char *regexp)\n{\n  char *unescaped_regexp = xmalloc (1 + strlen (regexp));\n  char *p, *q;\n\n  for (p = regexp, q = unescaped_regexp; *p != '\\0'; p++, q++)\n    {\n      if (*p == '\\\\')\n        switch(*++p)\n          {\n          case 'n':\n            *q = '\\n';\n            break;\n          case 't':\n            *q = '\\t';\n            break;\n          case '\\0':\n            *q = '\\\\';\n            p--;\n            break;\n          default:\n            *q++ = '\\\\';\n            *q = *p;\n            break;\n          }\n      else\n        *q = *p;\n    }\n  *q = '\\0';\n\n  return unescaped_regexp;\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nregexp_expand_newlines_and_tabs (char *regexp)",
        "*"
      ]
    },
    "regexp_escape_string": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static char *\nregexp_escape_string (char *search_string)\n{\n  char *special_chars = \"\\\\[]^$.*(){}|+?\";\n  char *p, *q;\n\n  char *escaped_string = xmalloc (strlen (search_string) * 2 + 1);\n\n  for (p = search_string, q = escaped_string; *p != '\\0'; )\n    {\n      if (strchr (special_chars, *p))\n        {\n          *q++ = '\\\\';\n        }\n      *q++ = *p++;\n    }\n\n  *q = '\\0';\n\n  return escaped_string;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nregexp_escape_string (char *search_string)",
        "*"
      ]
    },
    "extend_matches": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "static void\nextend_matches (MATCH_STATE *state)\n{\n  regmatch_t *matches = state->matches;\n  size_t match_alloc = state->match_alloc;\n  size_t match_count = state->match_count;\n  char *buffer = state->buffer;\n  size_t buflen = state->buflen;\n\n  regoff_t offset = 0;\n  char saved_char;\n  size_t initial_match_count = match_count;\n\n  if (state->finished)\n    return;\n\n  saved_char = buffer[buflen];\n  buffer[buflen] = '\\0';\n\n  if (match_count > 0)\n    {\n      offset = matches[match_count - 1].rm_eo;\n\n      /* move past zero-length match */\n      if (offset == matches[match_count - 1].rm_so)\n        offset++;\n    }\n\n  while (offset < buflen && match_count < initial_match_count + 5)\n    {\n      int result = 0;\n      regmatch_t m;\n\n      result = regexec (&state->regex, &buffer[offset], 1, &m, REG_NOTBOL);\n      if (result == 0)\n        {\n          if (match_count == match_alloc)\n            {\n              /* The match list is full. */\n              if (match_alloc == 0)\n                match_alloc = 50;\n              matches = x2nrealloc\n                (matches, &match_alloc, sizeof matches[0]);\n            }\n\n          matches[match_count] = m;\n          matches[match_count].rm_so += offset;\n          matches[match_count].rm_eo += offset;\n          offset = matches[match_count++].rm_eo;\n\n          if (m.rm_eo == 0)\n            offset++; /* Avoid finding match again for a pattern of \"$\". */\n        }\n      else\n        {\n          state->finished = 1;\n          break;\n        }\n    }\n  buffer[buflen] = saved_char;\n\n  state->matches = matches;\n  state->match_alloc = match_alloc;\n  state->match_count = match_count;\n}",
      "lines": 65,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "regexp_search": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "enum search_result\nregexp_search (char *regexp, int is_literal, int is_insensitive,\n               char *buffer, size_t buflen,\n               MATCH_STATE *match_state)\n{\n  regex_t preg; /* Compiled pattern buffer for regexp. */\n  int result;\n  char *regexp_str;\n\n  if (!is_literal)\n    regexp_str = regexp_expand_newlines_and_tabs (regexp);\n  else\n    regexp_str = regexp_escape_string (regexp);\n\n  result = regcomp (&preg, regexp_str,\n                    REG_EXTENDED | REG_NEWLINE\n                    | (is_insensitive ? REG_ICASE : 0));\n  free (regexp_str);\n\n  if (result != 0)\n    {\n      int size = regerror (result, &preg, NULL, 0);\n      char *buf = xmalloc (size);\n      regerror (result, &preg, buf, size);\n      info_error (_(\"regexp error: %s\"), buf);\n      free (buf);\n      return search_invalid;\n    }\n\n  match_state->matches = 0;\n  match_state->match_count = 0;\n  match_state->match_alloc = 0;\n  match_state->finished = 0;\n  match_state->regex = preg;\n  match_state->buffer = buffer;\n  match_state->buflen = buflen;\n\n  extend_matches (match_state);\n\n  if (match_state->match_count == 0)\n    {\n      free_matches (match_state);\n      return search_not_found;\n    }\n  else\n    return search_success;\n}",
      "lines": 47,
      "depth": 11,
      "decorators": [
        "enum search_result",
        "enum",
        "search_result"
      ]
    },
    "search_forward": {
      "start_point": [
        227,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "enum search_result\nsearch_forward (char *string, SEARCH_BINDING *binding, long *poff)\n{\n  register int c, i, len;\n  register char *buff, *end;\n  char *alternate = NULL;\n\n  len = strlen (string);\n\n  /* We match characters in the search buffer against STRING and ALTERNATE.\n     ALTERNATE is a case reversed version of STRING; this is cheaper than\n     case folding each character before comparison.   Alternate is only\n     used if the case folding bit is turned on in the passed BINDING. */\n\n  if (binding->flags & S_FoldCase)\n    {\n      alternate = xstrdup (string);\n\n      for (i = 0; i < len; i++)\n        {\n          if (islower (alternate[i]))\n            alternate[i] = toupper (alternate[i]);\n          else if (isupper (alternate[i]))\n            alternate[i] = tolower (alternate[i]);\n        }\n    }\n\n  buff = binding->buffer + binding->start;\n  end = binding->buffer + binding->end + 1;\n\n  while (buff < (end - len))\n    {\n      for (i = 0; i < len; i++)\n        {\n          c = buff[i];\n\n          if ((c != string[i]) && (!alternate || c != alternate[i]))\n            break;\n        }\n\n      if (!string[i])\n        {\n          if (alternate)\n            free (alternate);\n          if (binding->flags & S_SkipDest)\n            buff += len;\n          *poff = buff - binding->buffer;\n\t  return search_success;\n        }\n\n      buff++;\n    }\n\n  if (alternate)\n    free (alternate);\n\n  return search_not_found;\n}",
      "lines": 58,
      "depth": 14,
      "decorators": [
        "enum search_result",
        "enum",
        "search_result"
      ]
    },
    "search_backward": {
      "start_point": [
        287,
        0
      ],
      "end_point": [
        355,
        1
      ],
      "content": "enum search_result\nsearch_backward (char *input_string, SEARCH_BINDING *binding, long *poff)\n{\n  register int c, i, len;\n  register char *buff, *end;\n  char *string;\n  char *alternate = NULL;\n\n  len = strlen (input_string);\n\n  /* Reverse the characters in the search string. */\n  string = xmalloc (1 + len);\n  for (c = 0, i = len - 1; input_string[c]; c++, i--)\n    string[i] = input_string[c];\n\n  string[c] = '\\0';\n\n  /* We match characters in the search buffer against STRING and ALTERNATE.\n     ALTERNATE is a case reversed version of STRING; this is cheaper than\n     case folding each character before comparison.   ALTERNATE is only\n     used if the case folding bit is turned on in the passed BINDING. */\n\n  if (binding->flags & S_FoldCase)\n    {\n      alternate = xstrdup (string);\n\n      for (i = 0; i < len; i++)\n        {\n          if (islower (alternate[i]))\n            alternate[i] = toupper (alternate[i]);\n          else if (isupper (alternate[i]))\n            alternate[i] = tolower (alternate[i]);\n        }\n    }\n\n  buff = binding->buffer + binding->start - 1;\n  end = binding->buffer + binding->end;\n\n  while (buff > (end + len))\n    {\n      for (i = 0; i < len; i++)\n        {\n          c = *(buff - i);\n\n          if (c != string[i] && (!alternate || c != alternate[i]))\n            break;\n        }\n\n      if (!string[i])\n        {\n          free (string);\n          if (alternate)\n            free (alternate);\n\n          if (binding->flags & S_SkipDest)\n            buff -= len;\n          *poff = 1 + buff - binding->buffer;\n\t  return search_success;\n        }\n\n      buff--;\n    }\n\n  free (string);\n  if (alternate)\n    free (alternate);\n\n  return search_not_found;\n}",
      "lines": 69,
      "depth": 14,
      "decorators": [
        "enum search_result",
        "enum",
        "search_result"
      ]
    },
    "string_in_line": {
      "start_point": [
        360,
        0
      ],
      "end_point": [
        379,
        1
      ],
      "content": "int\nstring_in_line (char *string, char *line)\n{\n  register int end;\n  SEARCH_BINDING binding;\n  long offset;\n  \n  /* Find the end of the line. */\n  for (end = 0; line[end] && line[end] != '\\n'; end++);\n\n  /* Search for STRING within these confines. */\n  binding.buffer = line;\n  binding.start = 0;\n  binding.end = end;\n  binding.flags = S_FoldCase | S_SkipDest;\n\n  if (search_forward (string, &binding, &offset) == search_success)\n    return offset;\n  return -1;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "looking_at": {
      "start_point": [
        382,
        0
      ],
      "end_point": [
        394,
        1
      ],
      "content": "int\nlooking_at (char *string, SEARCH_BINDING *binding)\n{\n  long search_end;\n\n  if (search (string, binding, &search_end) != search_success)\n    return 0;\n\n  /* If the string was not found, SEARCH_END is -1.  If the string was found,\n     but not right away, SEARCH_END is != binding->start.  Otherwise, the\n     string was found at binding->start. */\n  return search_end == binding->start;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "looking_at_line": {
      "start_point": [
        398,
        0
      ],
      "end_point": [
        412,
        1
      ],
      "content": "int\nlooking_at_line (char *string, char *pointer)\n{\n  int len;\n\n  len = strlen (string);\n  if (strncasecmp (pointer, string, len) != 0)\n    return 0;\n\n  pointer += len;\n  if (*pointer == '\\n' || !strncmp (pointer, \"\\r\\n\", 2)\n      || *pointer == '\\0')\n    return 1;\n  return 0;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "match_in_match_list": {
      "start_point": [
        422,
        0
      ],
      "end_point": [
        468,
        1
      ],
      "content": "enum search_result\nmatch_in_match_list (MATCH_STATE *match_state,\n                     long start, long end, int dir,\n                     int *match_index)\n{\n  regmatch_t *matches = match_state->matches;\n  size_t match_count = match_state->match_count;\n\n  int i;\n  int index = -1;\n\n  for (i = 0; i < match_count || !match_state->finished; i++)\n    {\n      /* get more matches as we need them */\n      if (i == match_count)\n        {\n          extend_matches (match_state);\n          matches = match_state->matches;\n          match_count = match_state->match_count;\n\n          if (i == match_count)\n            break;\n        }\n\n      if (matches[i].rm_so >= end)\n        break; /* No  more matches found in search area. */\n\n      if (matches[i].rm_so >= start)\n        {\n          index = i;\n          if (dir > 0)\n            {\n              *match_index = index;\n              return search_success;\n            }\n        }\n    }\n\n  if (index != -1)\n    {\n      *match_index = index;\n      return search_success;\n    }\n\n  /* not found */\n  return search_not_found;\n}",
      "lines": 47,
      "depth": 12,
      "decorators": [
        "enum search_result",
        "enum",
        "search_result"
      ]
    },
    "match_by_index": {
      "start_point": [
        471,
        0
      ],
      "end_point": [
        477,
        1
      ],
      "content": "regmatch_t\nmatch_by_index (MATCH_STATE *state, int index)\n{\n  while (state->match_alloc <= index)\n    extend_matches (state);\n  return state->matches[index];\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "regmatch_t"
      ]
    },
    "free_matches": {
      "start_point": [
        480,
        0
      ],
      "end_point": [
        489,
        1
      ],
      "content": "void\nfree_matches (MATCH_STATE *state)\n{\n  free (state->matches);\n  state->matches = 0;\n  state->match_count = state->match_alloc = state->finished = 0;\n  state->buffer = 0; /* do not free as it is kept elsewhere */\n  state->buflen = 0;\n  regfree (&state->regex);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "matches_ready": {
      "start_point": [
        491,
        0
      ],
      "end_point": [
        495,
        1
      ],
      "content": "int\nmatches_ready (MATCH_STATE *state)\n{\n  return state->matches ? 1 : 0;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "decide_if_in_match": {
      "start_point": [
        500,
        0
      ],
      "end_point": [
        522,
        1
      ],
      "content": "void\ndecide_if_in_match (long off, int *in_match,\n                    MATCH_STATE *matches, size_t *match_index)\n{\n  size_t i = *match_index;\n  int m = *in_match;\n\n  for (; !at_end_of_matches (matches, i); i++)\n    {\n      if (match_by_index (matches, i).rm_so > off)\n        break;\n\n      m = 1;\n\n      if (match_by_index (matches, i).rm_eo > off)\n        break;\n\n      m = 0;\n    }\n\n  *match_index = i;\n  *in_match = m;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "at_end_of_matches": {
      "start_point": [
        525,
        0
      ],
      "end_point": [
        540,
        1
      ],
      "content": "int\nat_end_of_matches (MATCH_STATE *state, int index)\n{\n  if (index < state->match_count)\n    return 0;\n  else\n    {\n      if (!state->finished)\n        extend_matches (state);\n\n      if (state->finished)\n        return (state->match_count == index) ? 1 : 0;\n      else\n        return 0;\n    }\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "skip_whitespace": {
      "start_point": [
        557,
        0
      ],
      "end_point": [
        564,
        1
      ],
      "content": "int\nskip_whitespace (char *string)\n{\n  register int i;\n\n  for (i = 0; string && whitespace (string[i]); i++);\n  return i;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "skip_whitespace_and_newlines": {
      "start_point": [
        568,
        0
      ],
      "end_point": [
        575,
        1
      ],
      "content": "int\nskip_whitespace_and_newlines (char *string)\n{\n  register int i;\n\n  for (i = 0; string && whitespace_or_newline (string[i]); i++);\n  return i;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "skip_non_whitespace": {
      "start_point": [
        578,
        0
      ],
      "end_point": [
        585,
        1
      ],
      "content": "int\nskip_non_whitespace (char *string)\n{\n  register int i;\n\n  for (i = 0; string && string[i] && !whitespace (string[i]); i++);\n  return i;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "find_node_separator": {
      "start_point": [
        596,
        0
      ],
      "end_point": [
        635,
        1
      ],
      "content": "long\nfind_node_separator (SEARCH_BINDING *binding)\n{\n  register long i;\n  char *body;\n  int dir;\n\n  body = binding->buffer;\n  dir = binding->start < binding->end ? 1 : -1;\n\n  /* A node is started by [^L]^_[^L][\\r]\\n.  That is to say, the C-l's are\n     optional, but the US and NEWLINE are not.  This separator holds\n     true for all separated elements in an Info file, including the tags\n     table (if present) and the indirect tags table (if present). */\n  i = binding->start;\n  while (1)\n    {\n      /* Note that bytes are read in order from the buffer, so if at any\n         point a null byte is encountered signifying the end of the buffer,\n         no more bytes will be read past that point. */\n      if (body[i] == INFO_COOKIE)\n        {\n          int j = i + 1;\n\n          if (body[j] == INFO_FF)\n            j++;\n          if (body[j] == '\\r')\n            j++;\n\n          if (body[j] == '\\n')\n            return i;\n        }\n\n      if (i == binding->end)\n        break;\n      i += dir;\n    }\n\n  return -1;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "long",
        "long"
      ]
    },
    "skip_node_separator": {
      "start_point": [
        639,
        0
      ],
      "end_point": [
        662,
        1
      ],
      "content": "int\nskip_node_separator (char *body)\n{\n  register int i;\n\n  i = 0;\n\n  if (body[i] == INFO_FF)\n    i++;\n\n  if (body[i++] != INFO_COOKIE)\n    return 0;\n\n  if (body[i] == INFO_FF)\n    i++;\n\n  if (body[i] == '\\r')\n    i++;\n\n  if (body[i++] != '\\n')\n    return 0;\n\n  return i;\n}",
      "lines": 24,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "find_file_section": {
      "start_point": [
        666,
        0
      ],
      "end_point": [
        700,
        1
      ],
      "content": "long\nfind_file_section (SEARCH_BINDING *binding, char *label)\n{\n  SEARCH_BINDING s;\n  long position;\n  int dir;\n\n  s.buffer = binding->buffer;\n  s.start = binding->start;\n  s.end = binding->end;\n  s.flags = S_FoldCase;\n  dir = binding->start < binding->end ? 1 : -1;\n\n  while ((position = find_node_separator (&s)) != -1 )\n    {\n      long offset = position;\n      offset += skip_node_separator (s.buffer + offset);\n      if (looking_at_line (label, s.buffer + offset))\n        return position;\n\n      if (dir > 0)\n        {\n          s.start = offset;\n          if (s.start >= s.end)\n            break;\n        }\n      else\n        {\n          s.start = position - 1;\n          if (s.start <= s.end)\n            break;\n        }\n    }\n  return -1;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "long",
        "long"
      ]
    },
    "find_node_in_binding": {
      "start_point": [
        707,
        0
      ],
      "end_point": [
        747,
        1
      ],
      "content": "long\nfind_node_in_binding (char *nodename, SEARCH_BINDING *binding)\n{\n  long position;\n  int offset;\n  SEARCH_BINDING s;\n\n  s.buffer = binding->buffer;\n  s.start = binding->start;\n  s.end = binding->end;\n  s.flags = 0;\n\n  while ((position = find_node_separator (&s)) != -1)\n    {\n      char *nodename_start;\n      char *read_nodename;\n      int found;\n\n      s.start = position;\n      s.start += skip_node_separator (s.buffer + s.start);\n\n      offset = string_in_line (INFO_NODE_LABEL, s.buffer + s.start);\n\n      if (offset == -1)\n        continue;\n\n      s.start += offset;\n      s.start += skip_whitespace (s.buffer + s.start); \n      nodename_start = s.buffer + s.start;\n      read_quoted_string (nodename_start, \"\\n\\r\\t,\", 0, &read_nodename);\n      if (!read_nodename)\n        return -1;\n\n      found = !strcmp (read_nodename, nodename);\n      free (read_nodename);\n\n      if (found)\n        return position;\n    }\n  return -1;\n}",
      "lines": 41,
      "depth": 11,
      "decorators": [
        "long",
        "long"
      ]
    }
  },
  "texinfo/texinfo-6.5/info/search.h": {},
  "texinfo/texinfo-6.5/info/session.c": {
    "allfiles_create_node": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "static void\nallfiles_create_node (char *term, REFERENCE **fref)\n{\n  int i;\n  struct text_buffer text;\n  \n  text_buffer_init (&text);\n\n  text_buffer_printf (&text,\n                      \"%s File names matching '%s'\\n\\n\"\n                      \"Info File Index\\n\"\n                      \"***************\\n\\n\"\n                      \"File names that match '%s':\\n\",\n                      INFO_NODE_LABEL,\n                      term, term);\n\n  /* Mark as an index so that destinations are never hidden. */\n  text_buffer_add_string (&text, \"\\0\\b[index\\0\\b]\", 11);\n  text_buffer_printf (&text, \"\\n* Menu:\\n\\n\");\n\n  for (i = 0; fref[i]; i++)\n    {\n      text_buffer_printf (&text, \"* %4i: (%s)\", i+1, fref[i]->filename);\n      if (fref[i]->nodename)\n        text_buffer_printf (&text, \"%s\", fref[i]->nodename);\n      text_buffer_printf (&text, \".\\n\");\n    }\n\n  allfiles_node = info_create_node ();\n  allfiles_node->fullpath = xstrdup (\"\");\n  allfiles_node->nodename = xstrdup (\"*Info File Index*\");\n  allfiles_node->contents = text_buffer_base (&text);\n  allfiles_node->nodelen = text_buffer_off (&text);\n  allfiles_node->body_start = strcspn (allfiles_node->contents, \"\\n\");\n\n  scan_node_contents (allfiles_node, 0, 0);\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "begin_multiple_window_info_session": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "static void\nbegin_multiple_window_info_session (REFERENCE **references, char *error)\n{\n  register int i;\n  WINDOW *window = 0;\n\n  for (i = 0; references && references[i]; i++)\n    {\n      if (!window)\n        {\n          window = active_window;\n          info_select_reference (window, references[i]);\n          if (!window->node)\n            window = 0;\n        }\n      else\n        {\n          /* Find the largest window in WINDOWS, and make that be the active\n             one.  Then split it and add our window and node to the list\n             of remembered windows and nodes.  Then tile the windows. */\n          WINDOW *win, *largest = NULL;\n          int max_height = 0;\n\n          for (win = windows; win; win = win->next)\n            if (win->height > max_height)\n              {\n                max_height = win->height;\n                largest = win;\n              }\n\n          if (!largest)\n            {\n              display_update_display ();\n              info_error (\"%s\", msg_cant_find_window);\n              return;\n            }\n\n          active_window = largest;\n          window = window_make_window ();\n          info_select_reference (window, references[i]);\n\n          if (!window->node)\n            {\n              /* We couldn't find the node referenced. */\n              window_delete_window (window);\n              window = 0;\n            }\n\n          if (window)\n            window_tile_windows (TILE_INTERNALS);\n          else\n            {\n              display_update_display ();\n              info_error (\"%s\", msg_win_too_small);\n              return;\n            }\n        }\n    }\n\n  /* Load dir node as a back-up if there were no references given, or if\n     none of them were valid. */\n  if (!window)\n    {\n      info_set_node_of_window (active_window, get_dir_node ());\n      return;\n    }\n}",
      "lines": 67,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "display_startup_message": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "static void\ndisplay_startup_message (void)\n{\n  char *format;\n\n  format = replace_in_documentation\n  /* TRANSLATORS: Try to keep this message (when \"expanded\") at most 79 \n     characters; anything after the 79th character will not actually be \n     displayed on an 80-column terminal. */\n(_(\"Welcome to Info version %s.  Type \\\\[get-help-window] for help, \\\\[get-info-help-node] for tutorial.\"),\n     0);\n\n  window_message_in_echo_area (format, VERSION, NULL);\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "info_session": {
      "start_point": [
        201,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "void\ninfo_session (REFERENCE **ref_list, char *user_filename, char *error)\n{\n  /* Initialize the Info session. */\n  initialize_info_session ();\n\n  if (!error)\n    display_startup_message ();\n  else\n    show_error_node (error);\n\n  if (!user_filename)\n    begin_multiple_window_info_session (ref_list, error);\n  else\n    {\n      allfiles_create_node (user_filename, ref_list);\n      info_set_node_of_window (active_window, allfiles_node);\n    }\n\n  info_read_and_dispatch ();\n  close_info_session ();\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "info_read_and_dispatch": {
      "start_point": [
        228,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "void\ninfo_read_and_dispatch (void)\n{\n  VFunction *cmd;\n  int count;\n\n  for (quit_info_immediately = 0; !quit_info_immediately; )\n    {\n      if (!info_any_buffered_input_p ())\n        display_update_display ();\n\n      /* Some redisplay might be necessary if the cursor has moved and\n         a different reference (or no reference) has to be highlighted. */\n      if (hl_ref_rendition.mask)\n        display_update_one_window (active_window);\n\n      display_cursor_at_point (active_window);\n\n      cmd = read_key_sequence (info_keymap, 1, 1, 0, &count);\n      if (cmd)\n        {\n          if (!info_keyseq_displayed_p)\n            window_clear_echo_area ();\n\n          (*cmd) (active_window, count);\n\n          /* Don't change the goal column when going up and down.  This \n             means we can go from a long line to a short line and back to\n             a long line and end back in the same column. */\n          if (!(cmd == &info_next_line || cmd == &info_prev_line))\n            active_window->goal_column = -1; /* Goal is current column. */\n        }\n    }\n}",
      "lines": 34,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "initialize_terminal_and_keymaps": {
      "start_point": [
        267,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "void\ninitialize_terminal_and_keymaps (char *init_file)\n{\n  char *term_name = getenv (\"TERM\");\n  terminal_initialize_terminal (term_name);\n  read_init_file (init_file);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "initialize_info_session": {
      "start_point": [
        277,
        0
      ],
      "end_point": [
        303,
        1
      ],
      "content": "void\ninitialize_info_session (void)\n{\n  if (!terminal_prep_terminal ())\n    {\n      /* Terminal too dumb to run interactively. */\n      char *term_name = getenv (\"TERM\");\n      info_error (msg_term_too_dumb, term_name);\n      exit (EXIT_FAILURE);\n    }\n\n  terminal_clear_screen ();\n\n  window_initialize_windows (screenwidth, screenheight);\n  initialize_info_signal_handler ();\n  display_initialize_display (screenwidth, screenheight);\n\n  /* If input has not been redirected yet, make it come from unbuffered\n     standard input. */\n  if (!info_input_stream)\n    {\n      setbuf (stdin, NULL);\n      info_input_stream = stdin;\n    }\n\n  info_windows_initialized_p = 1;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "close_info_session": {
      "start_point": [
        307,
        0
      ],
      "end_point": [
        315,
        1
      ],
      "content": "void\nclose_info_session (void)\n{\n  terminal_goto_xy (0, screenheight - 1);\n  terminal_clear_to_eol ();\n  fflush (stdout);\n  terminal_unprep_terminal ();\n  close_dribble_file ();\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "info_set_input_from_file": {
      "start_point": [
        318,
        0
      ],
      "end_point": [
        337,
        1
      ],
      "content": "void\ninfo_set_input_from_file (char *filename)\n{\n  FILE *stream;\n\n  /* Input may include binary characters.  */\n  stream = fopen (filename, FOPEN_RBIN);\n\n  if (!stream)\n    return;\n\n  if ((info_input_stream != NULL) &&\n      (info_input_stream != stdin))\n    fclose (info_input_stream);\n\n  info_input_stream = stream;\n\n  if (stream != stdin)\n    display_inhibited = 1;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "get_byte_from_input_buffer": {
      "start_point": [
        359,
        0
      ],
      "end_point": [
        371,
        1
      ],
      "content": "static int\nget_byte_from_input_buffer (unsigned char *key)\n{\n  if (push_index == pop_index)\n    return 0;\n\n  *key = info_input_buffer[pop_index++];\n\n  if (pop_index >= MAX_INFO_INPUT_BUFFERING)\n    pop_index = 0;\n\n  return 1;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "info_any_buffered_input_p": {
      "start_point": [
        373,
        0
      ],
      "end_point": [
        378,
        1
      ],
      "content": "int\ninfo_any_buffered_input_p (void)\n{\n  fill_input_buffer (0);\n  return push_index != pop_index;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "fill_input_buffer": {
      "start_point": [
        382,
        0
      ],
      "end_point": [
        413,
        1
      ],
      "content": "static void\nfill_input_buffer (int wait)\n{\n  while (1)\n    {\n      int success;\n      do\n        {\n          success = info_gather_typeahead (wait);\n        }\n      while (!success && errno == EINTR); /* Try again if the read was\n                                             interrupted due to a signal. */\n      if (success || !wait)\n        return;\n\n      /* Reading failed.  If we were reading from a dribble file with\n         --restore, switch to standard input.  Otherwise quit. */\n      if (info_input_stream != stdin)\n        {\n          fclose (info_input_stream);\n          info_input_stream = stdin;\n          display_inhibited = 0;\n          display_update_display ();\n          display_cursor_at_point (active_window);\n        }\n      else\n        {\n          close_info_session ();\n          exit (EXIT_SUCCESS);\n        }\n    }\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "info_gather_typeahead": {
      "start_point": [
        418,
        0
      ],
      "end_point": [
        544,
        1
      ],
      "content": "static int\ninfo_gather_typeahead (int wait)\n{\n  register int i = 0;\n  int tty, space_avail;\n  long chars_avail;\n  unsigned char input[MAX_INFO_INPUT_BUFFERING];\n\n  tty = fileno (info_input_stream);\n  chars_avail = 0;\n\n  /* Clear errno. */\n  errno = 0;\n\n  /* There may be characters left over from last time, in which case we don't\n     want to wait for another key to be pressed. */\n  if (wait && pop_index == push_index)\n    {\n      char c;\n      /* Wait until there is a byte waiting, and then stuff it into the input\n         buffer. */\n      if (read (tty, &c, 1) <= 0) \n        return 0;\n\n      if (info_dribble_file)\n        dribble (c);\n\n      info_input_buffer[push_index++] = c;\n      if (push_index >= MAX_INFO_INPUT_BUFFERING)\n        push_index = 0;\n      /* Continue to see if there are more bytes waiting. */\n    }\n\n  /* Get the amount of space available in INFO_INPUT_BUFFER for new chars. */\n  if (pop_index > push_index)\n    space_avail = pop_index - push_index;\n  else\n    space_avail = sizeof (info_input_buffer) - (push_index - pop_index);\n\n  /* If we can just find out how many characters there are to read, do so. */\n#if defined (FIONREAD)\n  {\n    ioctl (tty, FIONREAD, &chars_avail);\n\n    if (chars_avail > space_avail)\n      chars_avail = space_avail;\n\n    if (chars_avail)\n      chars_avail = read (tty, &input[0], chars_avail);\n  }\n#else /* !FIONREAD */\n#  if defined (O_NDELAY) && defined (F_GETFL) && defined (F_SETFL)\n  {\n    int flags;\n\n    flags = fcntl (tty, F_GETFL, 0);\n\n    fcntl (tty, F_SETFL, (flags | O_NDELAY));\n      chars_avail = read (tty, &input[0], space_avail);\n    fcntl (tty, F_SETFL, flags);\n\n    if (chars_avail == -1)\n      chars_avail = 0;\n  }\n#  else  /* !O_NDELAY */\n#   ifdef __DJGPP__\n  {\n    extern long pc_term_chars_avail (void);\n\n    if (isatty (tty))\n      chars_avail = pc_term_chars_avail ();\n    else\n      {\n        /* We could be more accurate by calling ltell, but we have no idea\n           whether tty is buffered by stdio functions, and if so, how many\n           characters are already waiting in the buffer.  So we punt.  */\n        struct stat st;\n\n        if (fstat (tty, &st) < 0)\n          chars_avail = 1;\n        else\n          chars_avail = st.st_size;\n      }\n    if (chars_avail > space_avail)\n      chars_avail = space_avail;\n    if (chars_avail)\n      chars_avail = read (tty, &input[0], chars_avail);\n  }\n#   else\n#    ifdef __MINGW32__\n  {\n    extern long w32_chars_avail (int);\n\n    chars_avail = w32_chars_avail (tty);\n\n    if (chars_avail > space_avail)\n      chars_avail = space_avail;\n    if (chars_avail)\n      chars_avail = read (tty, &input[0], chars_avail);\n  }\n#    endif  /* _WIN32 */\n#   endif/* __DJGPP__ */\n#  endif /* O_NDELAY */\n#endif /* !FIONREAD */\n\n  while (i < chars_avail)\n    {\n      if (info_dribble_file)\n        dribble (input[i]);\n\n      /* Add KEY to the buffer of characters to be read. */\n      if (input[i] != Control ('g'))\n        {\n          info_input_buffer[push_index++] = input[i];\n          if (push_index >= MAX_INFO_INPUT_BUFFERING)\n            push_index = 0;\n        }\n      else\n        /* Flush all pending input in the case of C-g pressed. */\n        push_index = pop_index;\n      i++;\n    }\n  /* If wait is true, there is at least one byte left in the input buffer. */\n  if (chars_avail <= 0 && !wait)\n    return 0;\n  return 1;\n}",
      "lines": 127,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mouse_event_handler": {
      "start_point": [
        557,
        0
      ],
      "end_point": [
        572,
        1
      ],
      "content": "void\nmouse_event_handler (void)\n{\n  if (mouse_cb & 0x40)\n    {\n      switch (mouse_cb & 0x03)\n        {\n        case 0: /* Mouse button 4 (scroll up). */\n          _scroll_backward (active_window, 3, 1);\n          break;\n        case 1: /* Mouse button 5 (scroll down). */\n          _scroll_forward (active_window, 3, 1);\n          break;\n        }\n    }\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "get_input_key": {
      "start_point": [
        576,
        0
      ],
      "end_point": [
        593,
        1
      ],
      "content": "int\nget_input_key (void)\n{\n  int ret = -1;\n  \n  while (ret == -1)\n    {\n      ret = get_input_key_internal ();\n\n      if (ret == KEY_MOUSE)\n        {\n          get_byte_from_input_buffer (&mouse_cb);\n          get_byte_from_input_buffer (&mouse_cx);\n          get_byte_from_input_buffer (&mouse_cy);\n        }\n    }\n  return ret;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "get_input_key_internal": {
      "start_point": [
        602,
        0
      ],
      "end_point": [
        740,
        1
      ],
      "content": "static int\nget_input_key_internal (void)\n{\n  BYTEMAP_ENTRY *b;\n  unsigned char c;\n  int esc_seen = 0;\n  int pop_start;\n  int byte_count = 0;\n  fill_input_buffer (1);\n\n  if (pop_index == push_index)\n    return -1; /* No input waiting.  This shouldn't happen. */\n\n  b = byte_seq_to_key;\n  pop_start = pop_index;\n\n  while (pop_index != push_index)\n    {\n      int in_map = 0;\n      int unknown = 0;\n      if (!get_byte_from_input_buffer (&c))\n        break; /* Incomplete byte sequence. */\n      byte_count++;\n\n      switch (b[c].type)\n        {\n        case BYTEMAP_KEY:\n          return b[c].key;\n        case BYTEMAP_ESC:\n          esc_seen = 1;\n          /* Fall through. */\n        case BYTEMAP_MAP:\n          in_map = 1;\n          b = b[c].next;\n          break;\n        case BYTEMAP_NONE:\n          unknown = 1;\n          break;\n        }\n\n      if (unknown)\n        break;\n\n      /* If we read an incomplete byte sequence, pause a short while to\n         see if more bytes follow. */\n      if (in_map && pop_index == push_index)\n        {\n          int ready = 0;\n#if defined (FD_SET)\n          struct timeval timer, *timerp = 0;\n          fd_set readfds;\n\n          FD_ZERO (&readfds);\n          FD_SET (fileno (info_input_stream), &readfds);\n\n          timer.tv_sec = 0;\n          timer.tv_usec = key_time * 1000;\n          timerp = &timer;\n          ready = select (fileno(info_input_stream)+1, &readfds,\n                          NULL, NULL, timerp);\n#else\n          ready = 1;\n#endif /* FD_SET */\n          if (ready)\n            fill_input_buffer (0);\n        }\n    }\n\n  /* Incomplete or unknown byte sequence. Start again with the first byte.  */\n  pop_index = pop_start;\n\n  if (!esc_seen || (byte_count >= 3 && key_time == 0))\n    {\n      /* If the sequence was incomplete, return the first byte.\n             Also return the first byte for sequences with ESC that are at\n         least three bytes long if 'key_time' is 0, to give some support for \n         specifying byte sequences in .infokey for those sent by unrecognized\n         special keys (which would otherwise be skipped below). */\n      pop_index = pop_start;\n      get_byte_from_input_buffer (&c);\n      return c;\n    }\n  else\n    {\n      get_byte_from_input_buffer (&c); /* Should be ESC */\n\n      /* If there are no more characters, then decide that the escape key\n         itself has been pressed. */\n      if (pop_index == push_index)\n        return 033;\n\n      /* Skip byte sequences that look like they could have come from\n         unrecognized keys, e.g. F3 or C-S-Left, to avoid them as being\n         interpreted as random garbage.  These might produce sequences\n         that look like \"ESC O R\" or \"ESC [ 1 ; 6 ~\", depending on\n         the terminal. */\n\n      /* Check if the sequence starts ESC O. */\n      get_byte_from_input_buffer (&c);\n      if (c == 'O')\n        {\n          /* If no more bytes, call it M-O. */\n          if (!info_any_buffered_input_p ())\n            return 'O' + KEYMAP_META_BASE;\n\n          /* Otherwise it could be an unrecognized key producing a sequence\n             ESC O (byte).  Ignore it, discarding the next byte. */\n          get_byte_from_input_buffer (&c);\n          return -1;\n        }\n\n      /* Unknown CSI-style sequences. */\n      else if (c == '[')\n        {\n          /* If no more bytes, call it M-[. */\n          if (!get_byte_from_input_buffer (&c))\n            return '[' + KEYMAP_META_BASE;\n\n          /* Skip a control sequence as defined by ECMA-48. */\n          while (c >= 0x30 && c <= 0x3f)\n            if (!get_byte_from_input_buffer (&c))\n              break;\n\n          while (c >= 0x20 && c <= 0x2f)\n            if (!get_byte_from_input_buffer (&c))\n              break;\n\n          return -1;\n        }\n\n      else\n        {\n          /* The sequence started with ESC, but wasn't recognized.  Treat it\n             as introducing a sequence produced by a key chord with the meta\n             key pressed. */\n          return c + KEYMAP_META_BASE;\n        }\n    }\n}",
      "lines": 139,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "close_debugfile": {
      "start_point": [
        753,
        0
      ],
      "end_point": [
        757,
        1
      ],
      "content": "static void\nclose_debugfile (void)\n{\n  fclose (debug_file);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "vinfo_debug": {
      "start_point": [
        761,
        0
      ],
      "end_point": [
        792,
        1
      ],
      "content": "static void\nvinfo_debug (const char *format, va_list ap)\n{\n  FILE *fp;\n\n  if (!debug_file)\n    {\n      if (!info_windows_initialized_p || display_inhibited)\n\tfp = stderr;\n      else\n\t{\n\t  debug_file = fopen (INFODEBUG_FILE, \"w\");\n\t  if (!debug_file)\n\t    {\n\t      info_error (_(\"can't open %s: %s\"), INFODEBUG_FILE,\n\t\t\t  strerror (errno));\n\t      exit (EXIT_FAILURE);\n\t    }\n\t  atexit (close_debugfile);\n\t  fp = debug_file;\n\t  info_error (_(\"debugging output diverted to \\\"%s\\\"\"),\n\t\t      INFODEBUG_FILE);\n\t}\n    }\n  else\n    fp = debug_file;\n  \n  fprintf (fp, \"%s: \", program_name);\n  vfprintf (fp, format, ap);\n  fprintf (fp, \"\\n\");\n  fflush (stderr);\n}",
      "lines": 32,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "info_debug": {
      "start_point": [
        794,
        0
      ],
      "end_point": [
        801,
        1
      ],
      "content": "void\ninfo_debug (const char *format, ...)\n{\n  va_list ap;\n  va_start (ap, format);\n  vinfo_debug (format, ap);\n  va_end (ap);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "vinfo_error": {
      "start_point": [
        809,
        0
      ],
      "end_point": [
        837,
        1
      ],
      "content": "static void\nvinfo_error (const char *format, va_list ap)\n{\n  if (!info_windows_initialized_p || display_inhibited)\n    {\n      fprintf (stderr, \"%s: \", program_name);\n      vfprintf (stderr, format, ap);\n      fprintf (stderr, \"\\n\");\n      fflush (stderr);\n    }\n  else\n    {\n      if (!echo_area_is_active)\n        {\n          if (info_error_rings_bell_p)\n            terminal_ring_bell ();\n          vwindow_message_in_echo_area (format, ap);\n        }\n      else\n        {\n          NODE *temp = build_message_node (format, ap);\n          if (info_error_rings_bell_p)\n            terminal_ring_bell ();\n          inform_in_echo_area (temp->contents);\n          free (temp->contents);\n          free (temp);\n        }\n    }\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "info_error": {
      "start_point": [
        839,
        0
      ],
      "end_point": [
        846,
        1
      ],
      "content": "void\ninfo_error (const char *format, ...)\n{\n  va_list ap;\n  va_start (ap, format);\n  vinfo_error (format, ap);\n  va_end (ap);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "show_error_node": {
      "start_point": [
        848,
        0
      ],
      "end_point": [
        863,
        1
      ],
      "content": "void\nshow_error_node (char *error)\n{\n  if (info_error_rings_bell_p)\n    terminal_ring_bell ();\n  if (!info_windows_initialized_p)\n    {\n      info_error (\"%s\", error);\n    }\n  else if (!echo_area_is_active)\n    {\n      window_message_in_echo_area (\"%s\", error);\n    }\n  else\n    inform_in_echo_area (error);\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "free_history_node": {
      "start_point": [
        873,
        0
      ],
      "end_point": [
        884,
        1
      ],
      "content": "void\nfree_history_node (NODE *n)\n{\n  if (n && (n->flags & N_IsInternal))\n    {\n      free (n->contents);\n      info_free_references (n->references);\n      free (n->next); free (n->prev); free (n->up);\n      free (n->nodename);\n    }\n  free (n);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "put_node_in_window": {
      "start_point": [
        886,
        0
      ],
      "end_point": [
        896,
        1
      ],
      "content": "static void\nput_node_in_window (WINDOW *win, NODE *node)\n{\n  win->node = node;\n  win->pagetop = 0;\n  win->point = 0;\n  free_matches (&win->matches);\n  free (win->line_starts); win->line_starts = 0;\n  free (win->log_line_no); win->log_line_no = 0;\n  win->flags |= W_UpdateWindow;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "forget_node_fast": {
      "start_point": [
        899,
        0
      ],
      "end_point": [
        920,
        1
      ],
      "content": "int\nforget_node_fast (WINDOW *win)\n{\n  int i = win->hist_index;\n  if (i == 0)\n    return 0;\n\n  free_history_node (win->hist[i - 1]->node);\n  free (win->hist[i - 1]);\n  win->hist[i - 1] = 0;\n  i = --win->hist_index;\n\n  if (i == 0)\n    /* Window history is empty. */\n    win->node = 0;\n  else\n    {\n      put_node_in_window (win, win->hist[i - 1]->node);\n      win->point = win->hist[i - 1]->point;\n    }\n  return i;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "forget_node": {
      "start_point": [
        922,
        0
      ],
      "end_point": [
        940,
        1
      ],
      "content": "void\nforget_node (WINDOW *win)\n{\n  int i = forget_node_fast (win);\n\n  if (i == 0)\n    {\n      win->node = 0;\n      return; /* Window history is empty. */\n    }\n\n  window_set_node_of_window (win, win->hist[i - 1]->node);\n  if (auto_footnotes_p)\n    info_get_or_remove_footnotes (win);\n  set_window_pagetop (win, win->hist[i - 1]->pagetop);\n  win->point = win->hist[i - 1]->point;\n  window_compute_line_map (win);\n  win->node->display_pos = win->point;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "forget_window_and_nodes": {
      "start_point": [
        943,
        0
      ],
      "end_point": [
        953,
        1
      ],
      "content": "void\nforget_window_and_nodes (WINDOW *win)\n{\n  int i;\n  for (i = 0; i < win->hist_index; i++)\n    {\n      free_history_node (win->hist[i]->node);\n      free (win->hist[i]);\n    }\n  free (win->hist);\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "info_set_node_of_window_fast": {
      "start_point": [
        957,
        0
      ],
      "end_point": [
        974,
        1
      ],
      "content": "void\ninfo_set_node_of_window_fast (WINDOW *win, NODE *node)\n{\n  WINDOW_STATE *new;\n\n  if (win->hist_index && win->hist[win->hist_index - 1]->node == win->node)\n    {\n      win->hist[win->hist_index - 1]->pagetop = win->pagetop;\n      win->hist[win->hist_index - 1]->point = win->point;\n    }\n  put_node_in_window (win, node);\n\n  new = xmalloc (sizeof (WINDOW_STATE));\n  new->node = win->node;\n  new->pagetop = win->pagetop;\n  new->point = win->point;\n  add_pointer_to_array (new, win->hist_index, win->hist, win->hist_slots, 16);\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "info_set_node_of_window": {
      "start_point": [
        979,
        0
      ],
      "end_point": [
        1009,
        1
      ],
      "content": "void\ninfo_set_node_of_window (WINDOW *win, NODE *node)\n{\n  WINDOW_STATE *new;\n\n  /* Remember the current values of pagetop and point if the remembered node\n     is the same as the current one being displayed. */\n  if (win->hist_index && win->hist[win->hist_index - 1]->node == win->node)\n    {\n      win->hist[win->hist_index - 1]->pagetop = win->pagetop;\n      win->hist[win->hist_index - 1]->point = win->point;\n    }\n\n  /* Put this node into the window. */\n  window_set_node_of_window (win, node);\n\n  /* Remember this node, the currently displayed pagetop, and the current\n     location of point in this window. */\n  new = xmalloc (sizeof (WINDOW_STATE));\n  new->node = win->node;\n  new->pagetop = win->pagetop;\n  new->point = win->point;\n  add_pointer_to_array (new, win->hist_index, win->hist, win->hist_slots, 16);\n\n  /* If doing auto-footnote display/undisplay, show the footnotes belonging\n     to this window's node.  Don't do that if it is a footnote node itself. */\n  if (auto_footnotes_p\n      && !((win->node->flags & N_IsInternal)\n           && !strcmp (win->node->nodename, \"*Footnotes*\")))\n    info_get_or_remove_footnotes (win);\n}",
      "lines": 31,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "info_show_point": {
      "start_point": [
        1032,
        0
      ],
      "end_point": [
        1058,
        1
      ],
      "content": "static void\ninfo_show_point (WINDOW *window)\n{\n  if (window_scroll_step == 0)\n    window_adjust_pagetop (window);\n  else\n    {\n      int new_pagetop = window->pagetop;\n      int line = window_line_of_point (window);\n      if (line < window->pagetop)\n        new_pagetop -= window_scroll_step;\n      else if (line >= window->pagetop + window->height)\n        new_pagetop += window_scroll_step;\n\n      /* It's possible that moving by 'scroll-step' still won't show the\n         point.  If so, call window_adjust_pagetop as a backup. */\n      if (line >= new_pagetop && line < new_pagetop + window->height)\n        set_window_pagetop (window, new_pagetop);\n      else\n        window_adjust_pagetop (window);\n    }\n\n  if (window->flags & W_UpdateWindow)\n    display_update_one_window (window);\n\n  display_cursor_at_point (window);\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "point_next_line": {
      "start_point": [
        1062,
        0
      ],
      "end_point": [
        1083,
        1
      ],
      "content": "static int\npoint_next_line (WINDOW *win)\n{\n  int line = window_line_of_point (win);\n  if (line + 1 < win->line_count)\n    {\n      win->point = win->line_starts[line + 1];\n      window_compute_line_map (win);\n      return 1;\n    }\n\n  if (cursor_movement_scrolls_p\n      && forward_move_node_structure (win, info_scroll_behaviour) == 0)\n    {\n      win->point = 0;\n      window_compute_line_map (win);\n      return 1;\n    }\n\n  win->point = win->node->nodelen - 1;\n  return 0;\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "point_prev_line": {
      "start_point": [
        1087,
        0
      ],
      "end_point": [
        1111,
        1
      ],
      "content": "static int\npoint_prev_line (WINDOW *win)\n{\n  int line = window_line_of_point (win);\n  if (line > 0)\n    {\n      win->point = win->line_starts[line - 1];\n      window_compute_line_map (win);\n      win->point = win->line_map.map[win->line_map.used - 1];\n      return 1;\n    }\n\n  if (cursor_movement_scrolls_p\n      && backward_move_node_structure (win, info_scroll_behaviour) == 0)\n    {\n      win->point = win->node->nodelen - 1;\n      if (win->line_count > win->height)\n        set_window_pagetop (win, win->line_count - win->height);\n      window_compute_line_map (win);\n      return 1;\n    }\n\n  win->point = 0;\n  return 0;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "looking_at_newline": {
      "start_point": [
        1114,
        0
      ],
      "end_point": [
        1122,
        1
      ],
      "content": "static int\nlooking_at_newline (WINDOW *win, long point)\n{\n  mbi_iterator_t iter;\n  mbi_init (iter, win->node->contents + point,\n\t    win->node->nodelen - point);\n  mbi_avail (iter);\n  return mbi_cur (iter).wc_valid && mbi_cur (iter).wc == '\\n';\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "looking_at_alnum": {
      "start_point": [
        1125,
        0
      ],
      "end_point": [
        1134,
        1
      ],
      "content": "static int\nlooking_at_alnum (WINDOW *win)\n{\n  mbi_iterator_t iter;\n  mbi_init (iter, win->node->contents + win->point,\n\t    win->node->nodelen - win->point);\n  mbi_avail (iter);\n\n  return mbi_cur (iter).wc_valid && iswalnum (mbi_cur (iter).wc);\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "point_forward_char": {
      "start_point": [
        1137,
        0
      ],
      "end_point": [
        1154,
        1
      ],
      "content": "static void\npoint_forward_char (WINDOW *win)\n{\n  long point = win->point;\n  int col;\n\n  /* Find column in the line map after the current one that advances the\n     point.  (This may not be the very next character if we are at a\n     double-width character that occupies multiple columns.) */\n  col = window_point_to_column (win, point, 0) + 1;\n  for (; col < win->line_map.used && win->line_map.map[col] == point; col++)\n    ;\n\n  if (col < win->line_map.used)\n    win->point = win->line_map.map[col];\n  else\n    point_next_line (win);\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "point_backward_char": {
      "start_point": [
        1158,
        0
      ],
      "end_point": [
        1177,
        1
      ],
      "content": "static int\npoint_backward_char (WINDOW *win)\n{\n  long point = win->point;\n  int col;\n\n  /* Find column in the line map before the current one that moves the\n     point backward. */\n  col = window_point_to_column (win, point, 0) - 1;\n  for (; col >= 0 && win->line_map.map[col] == point; col--)\n    ;\n\n  if (col >= 0)\n    {\n      win->point = win->line_map.map[col];\n      return 1;\n    }\n  else\n    return point_prev_line (win);\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "point_forward_word": {
      "start_point": [
        1180,
        0
      ],
      "end_point": [
        1214,
        1
      ],
      "content": "static void\npoint_forward_word (WINDOW *win)\n{\n  int col;\n\n  col = window_point_to_column (win, win->point, &win->point);\n\n  /* Skip white space forwards. */\n  while (1)\n    {\n      for (; col < win->line_map.used; col++)\n\t{\n          win->point = win->line_map.map[col];\n          if (looking_at_alnum (win))\n            goto skipped_whitespace;\n\t}\n      if (!point_next_line (win))\n        return;\n      col = 0;\n    }\n  skipped_whitespace:\n\n  while (1)\n    {\n      for (; col < win->line_map.used; col++)\n\t{\n          win->point = win->line_map.map[col];\n\t  if (!looking_at_alnum (win))\n            return;\n\t}\n      if (!point_next_line (win))\n        return;\n      col = 0;\n    }\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "point_backward_word": {
      "start_point": [
        1217,
        0
      ],
      "end_point": [
        1236,
        1
      ],
      "content": "static void\npoint_backward_word (WINDOW *win)\n{\n  /* Skip any white space before current cursor position. */\n  while (point_backward_char (win))\n    {\n      if (looking_at_alnum (win))\n        goto back_to_word_start;\n    }\n\nback_to_word_start:\n  while (point_backward_char (win))\n    {\n      if (!looking_at_alnum (win))\n        {\n          point_forward_char (win);\n          return;\n        }\n    }\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "move_to_goal_column": {
      "start_point": [
        1241,
        0
      ],
      "end_point": [
        1251,
        1
      ],
      "content": "static void\nmove_to_goal_column (WINDOW *window)\n{\n  long goal;\n\n  goal = window->goal_column;\n  if (goal >= window->line_map.used)\n    goal = window->line_map.used - 1;\n  window->point = window->line_map.map[goal];\n  info_show_point (window);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_scroll_forward": {
      "start_point": [
        1459,
        0
      ],
      "end_point": [
        1482,
        1
      ],
      "content": "static void\n_scroll_forward (WINDOW *window, int count, int nodeonly)\n{\n  if (count < 0)\n    _scroll_backward (window, -count, nodeonly);\n  else\n    {\n      if (window->pagetop >= window->line_count - window->height)\n        {\n          if (!nodeonly)\n            {\n              /* If there are no more lines to scroll here, error, or get\n                 another node. */\n              if (forward_move_node_structure (window, info_scroll_behaviour)\n                  == 0)\n                window->point = 0;\n              else\n                info_end_of_node (window, 1);\n            }\n          return;\n        }\n      set_window_pagetop (window, window->pagetop + count);\n    }\n}",
      "lines": 24,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_scroll_backward": {
      "start_point": [
        1484,
        0
      ],
      "end_point": [
        1516,
        1
      ],
      "content": "static void\n_scroll_backward (WINDOW *window, int count, int nodeonly)\n{\n  if (count < 0)\n    _scroll_backward (window, -count, nodeonly);\n  else\n    {\n      int desired_top;\n\n      if (window->pagetop <= 0)\n        {\n          if (!nodeonly)\n            {\n              /* If there are no more lines to scroll here, error, or get\n                 another node. */\n              if (backward_move_node_structure (window, info_scroll_behaviour)\n                  == 0)\n                {\n                  info_end_of_node (window, 1);\n                  window->point = window->line_starts[window->pagetop];\n                }\n              else\n                window->point = 0;\n            }\n          return;\n        }\n\n      desired_top = window->pagetop - count;\n      if (desired_top < 0)\n        desired_top = 0;\n      set_window_pagetop (window, desired_top);\n    }\n}",
      "lines": 33,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gc_file_buffers_and_nodes": {
      "start_point": [
        1705,
        0
      ],
      "end_point": [
        1795,
        1
      ],
      "content": "static void\ngc_file_buffers_and_nodes (void)\n{\n  /* Array to record whether each file buffer was referenced or not. */\n  int *fb_referenced = xcalloc (info_loaded_files_index, sizeof (int));\n  WINDOW *win;\n  int i;\n  int fb_index;\n\n  /* Loop over nodes in the history of displayed windows recording\n     which file buffers were referenced. */\n  for (win = windows; win; win = win->next)\n    {\n      if (!win->hist)\n        continue;\n      for (i = 0; win->hist[i]; i++)\n        {\n          NODE *n = win->hist[i]->node;\n\n          /* Loop over file buffers. */\n          for (fb_index = 0; fb_index < info_loaded_files_index; fb_index++)\n            {\n              FILE_BUFFER *fb = info_loaded_files[fb_index];\n\n              /* Each node should match at most one file, either a subfile or a \n                 non-split file. */\n              if (fb->flags & N_Subfile)\n                {\n                  if (n->subfile && !FILENAME_CMP (fb->fullpath, n->subfile))\n                    {\n                      fb_referenced[fb_index] = 1;\n                      break;\n                    }\n                }\n              else if (!(fb->flags & N_TagsIndirect))\n                {\n                  if (n->fullpath && !FILENAME_CMP (fb->fullpath, n->fullpath))\n                    {\n                      fb_referenced[fb_index] = 1;\n                      break;\n                    }\n                }\n            }\n        }\n    }\n\n  /* Free unreferenced file buffers. */\n  for (i = 0; i < info_loaded_files_index; i++)\n    {\n      if (!fb_referenced[i])\n        {\n          FILE_BUFFER *fb = info_loaded_files[i];\n          TAG **t;\n\n          if (fb->flags & N_TagsIndirect)\n            continue;\n\n          /* If already gc-ed, do nothing. */\n          if (!fb->contents)\n            continue;\n\n          /* If this file had to be uncompressed, check to see if we should\n             gc it.  This means that the user-variable \"gc-compressed-files\"\n             is non-zero. */\n          if ((fb->flags & N_IsCompressed) && !gc_compressed_files)\n            continue;\n\n          /* If this file's contents are not gc-able, move on. */\n          if (fb->flags & N_CannotGC)\n            continue;\n\n          /* Don't free file buffers corresponding to files that aren't there \n             any more, because a node may still refer to them. */\n          if (fb->flags & N_Gone)\n            continue;\n\n          free (fb->contents);\n          fb->contents = 0;\n\n          /* Clear pointers into the file contents in the tags table. */\n          if (fb->tags)\n            for (t = fb->tags; (*t); t++)\n              {\n                if (!((*t)->cache.flags & N_WasRewritten))\n                  (*t)->cache.contents = 0;\n              }\n        }\n    }\n\n  free (fb_referenced);\n}",
      "lines": 91,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "info_delete_window_internal": {
      "start_point": [
        1955,
        0
      ],
      "end_point": [
        1966,
        1
      ],
      "content": "void\ninfo_delete_window_internal (WINDOW *window)\n{\n  if (windows->next && ((window->flags & W_WindowIsPerm) == 0))\n    {\n      forget_window_and_nodes (window);\n      window_delete_window (window);\n\n      if (echo_area_is_active)\n        echo_area_inform_of_deleted_window (window);\n    }\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "info_select_reference": {
      "start_point": [
        2048,
        0
      ],
      "end_point": [
        2127,
        1
      ],
      "content": "int\ninfo_select_reference (WINDOW *window, REFERENCE *entry)\n{\n  NODE *node;\n  char *file_system_error = NULL;\n\n  /* We need to copy everything from entry because the call to \n     info_get_node_with_defaults can free it if it came from\n     the tag table of a file. */\n  char *filename = entry->filename;\n  char *nodename = entry->nodename;\n  char *label = entry->label;\n  int line_number = entry->line_number;\n\n  node = info_get_node_with_defaults (filename, nodename, window->node);\n\n  /* Try something a little weird.  If the node couldn't be found, and the\n     reference was of the form \"foo::\", see if the entry->label can be found\n     as a file, with a node of \"Top\". */\n  if (!node)\n    {\n      if (info_recent_file_error)\n        file_system_error = xstrdup (info_recent_file_error);\n\n      if (nodename && label && !strcmp (nodename, label))\n        {\n          free (file_system_error);\n          file_system_error = NULL;\n\n          node = info_get_node (label, \"Top\");\n          if (!node && info_recent_file_error)\n            file_system_error = xstrdup (info_recent_file_error);\n        }\n    }\n\n  if (!node)\n    {\n      if (file_system_error)\n        {\n          info_error (\"%s\", file_system_error);\n          free (file_system_error);\n        }\n      else\n        info_error (msg_cant_find_node, nodename ? nodename : \"Top\");\n      return 0;\n    }\n\n  /* If in a footnotes window, try to switch to a window containing a\n     node from the file. */\n  if (window->node && (window->node->flags & N_IsInternal)\n      && !strcmp (window->node->nodename, \"*Footnotes*\"))\n        {\n          WINDOW *w;\n\n          for (w = windows; w; w = windows->next)\n            {\n              if (!strcmp (w->node->fullpath, window->node->fullpath)\n                  && !(w->flags & W_TempWindow))\n                {\n                  /* Switch to this window. */\n                  active_window = window = w;\n                  break;\n                }\n            }\n        }\n  info_set_node_of_window (window, node);\n\n  if (line_number > 0)\n    {\n      /* Go to the line given by entry->line_number. */\n      long line = window_log_to_phys_line (window, line_number - 1);\n\n      if (line >= 0 && line < window->line_count)\n        {\n          window->point = window->line_starts[line];\n          window_adjust_pagetop (window);\n        }\n    }\n  return 1;\n}",
      "lines": 80,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "info_parse_and_select": {
      "start_point": [
        2132,
        0
      ],
      "end_point": [
        2144,
        1
      ],
      "content": "static void\ninfo_parse_and_select (char *line, WINDOW *window)\n{\n  REFERENCE entry;\n\n  info_parse_node (line);\n  entry.filename = info_parsed_filename;\n  entry.nodename = info_parsed_nodename;\n  entry.line_number = 0;\n  entry.label = \"*info-parse-and-select*\";\n\n  info_select_reference (window, &entry);\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "select_menu_digit": {
      "start_point": [
        2148,
        0
      ],
      "end_point": [
        2185,
        1
      ],
      "content": "static REFERENCE *\nselect_menu_digit (WINDOW *window, unsigned char key)\n{\n  register int i, item;\n  register REFERENCE **menu;\n\n  menu = window->node->references;\n  if (!menu)\n    return 0;\n\n  item = key - '0';\n\n  /* Special case.  Item \"0\" is the last item in this menu. */\n  if (item == 0)\n    {\n      int j;\n      i = -1; /* Not found */\n      for (j = 0; menu[j]; j++)\n        if (menu[j]->type == REFERENCE_MENU_ITEM)\n          i = j;\n    }\n  else\n    {\n      int k = 0;\n      for (i = 0; menu[i]; i++)\n        {\n          if (menu[i]->type == REFERENCE_MENU_ITEM)\n            k++;\n          if (k == item)\n            break;\n        }\n    }\n\n  if (i == -1)\n    return 0;\n\n  return menu[i];\n}",
      "lines": 38,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "REFERENCE",
        "*\nselect_menu_digit (WINDOW *window, unsigned char key)",
        "*"
      ]
    },
    "menu_digit": {
      "start_point": [
        2191,
        0
      ],
      "end_point": [
        2222,
        1
      ],
      "content": "void\nmenu_digit (WINDOW *window, int key)\n{\n  int item = key - '0';\n  REFERENCE *entry;\n  REFERENCE **references = window->node->references;\n\n  /* Check if there is a menu in this node. */\n  if (references)\n    {\n      int i; \n      for (i = 0; references[i]; i++)\n        if (references[i]->type == REFERENCE_MENU_ITEM)\n          goto has_menu;\n    }\n\n  info_error (\"%s\", msg_no_menu_node);\n  return;\nhas_menu:\n\n  if (entry = select_menu_digit (window, key))\n    info_select_reference (window, entry);\n  else if (key == '0')\n    /* Don't print \"There aren't 0 items in this menu\" */\n    info_error (\"%s\", msg_no_menu_node);\n  else\n    info_error (ngettext (\"There isn't %d item in this menu\",\n                          \"There aren't %d items in this menu\",\n                          item),\n                item);\n  return;\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "exclude_cross_references": {
      "start_point": [
        2231,
        0
      ],
      "end_point": [
        2234,
        1
      ],
      "content": "static int exclude_cross_references (REFERENCE *r)\n{\n  return r->type == REFERENCE_XREF;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "exclude_menu_items": {
      "start_point": [
        2236,
        0
      ],
      "end_point": [
        2239,
        1
      ],
      "content": "static int exclude_menu_items (REFERENCE *r)\n{\n  return r->type == REFERENCE_MENU_ITEM;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "exclude_nothing": {
      "start_point": [
        2241,
        0
      ],
      "end_point": [
        2244,
        1
      ],
      "content": "static int exclude_nothing (REFERENCE *r)\n{\n  return 1;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "info_menu_or_ref_item": {
      "start_point": [
        2252,
        0
      ],
      "end_point": [
        2433,
        1
      ],
      "content": "static void\ninfo_menu_or_ref_item (WINDOW *window, int menu_item, int xref, int ask_p)\n{\n  REFERENCE *defentry = NULL; /* Default link */\n  REFERENCE **refs = window->node->references;\n  REFERENCE *entry;\n\n  /* Name of destination */\n  char *line;\n\n  int line_no;\n  int this_line, next_line;\n\n  int which, closest = -1;\n\n  reference_bool_fn exclude; \n\n  if (!refs)\n    return;\n\n  if (menu_item && !xref)\n    {\n      exclude = &exclude_cross_references;\n    }\n  else if (!menu_item && xref)\n    {\n      exclude = &exclude_menu_items;\n    }\n  else if (menu_item && xref)\n    {\n      exclude = &exclude_nothing;\n    }\n  else /* !menu_item && !xref */\n    return;\n\n  line_no = window_line_of_point (window);\n  this_line = window->line_starts[line_no];\n  if (window->line_starts[line_no + 1])\n    next_line = window->line_starts[line_no + 1];\n  else\n    next_line = window->node->nodelen;\n\n  /* Look for a reference in the current line, preferring one that\n     the point is in, otherwise preferring after the point. */\n  for (which = 0; refs[which]; which++)\n    {\n      /* If we got to the next line without finding an eligible reference. */\n      if (refs[which]->start >= next_line)\n        break;\n\n      /* Check the type of reference is one we are looking for. */\n      if (!(  (menu_item && refs[which]->type == REFERENCE_MENU_ITEM)\n           || (xref      && refs[which]->type == REFERENCE_XREF)))\n        continue;\n\n      /* Reference is eligible if any part of it is in the line. */\n      if (refs[which]->start >= this_line && refs[which]->start < next_line\n          || refs[which]->start < this_line && refs[which]->end > this_line)\n        {\n          closest = which;\n\n          /* If a reference contains the point, prefer it.  Otherwise prefer a\n             reference after the cursor to one before it. */\n          if (window->point >= refs[which]->start\n              && window->point < refs[which]->end)\n            break;\n        }\n    }\n  if (closest != -1)\n    defentry = refs[closest];\n\n  if (ask_p)\n    {\n      char *prompt;\n\n      /* Build the prompt string. */\n      if (menu_item && !xref)\n        {\n          if (defentry)\n            {\n              prompt = xmalloc (strlen (defentry->label)\n                                + strlen (_(\"Menu item (%s): \")));\n              sprintf (prompt, _(\"Menu item (%s): \"), defentry->label);\n            }\n          else\n            prompt = xstrdup (_(\"Menu item: \"));\n        }\n      else\n        {\n          if (defentry)\n            {\n              prompt = xmalloc (strlen (defentry->label)\n                                + strlen (_(\"Follow xref (%s): \")));\n              sprintf (prompt, _(\"Follow xref (%s): \"), defentry->label);\n            }\n          else\n            prompt = xstrdup (_(\"Follow xref: \"));\n        }\n\n      line = info_read_completing_in_echo_area_with_exclusions (prompt, refs,\n                                                                exclude);\n      free (prompt);\n\n      window = active_window;\n\n      /* User aborts, just quit. */\n      if (!line)\n        {\n          info_abort_key (window, 0);\n          return;\n        }\n\n      /* If we had a default and the user accepted it, use that. */\n      if (!*line)\n        {\n          free (line);\n          if (defentry)\n            line = xstrdup (defentry->label);\n          else\n            line = NULL;\n        }\n    }\n  else\n    {\n      /* Not going to ask any questions.  If we have a default entry, use\n         that, otherwise return. */\n      if (!defentry)\n        return;\n      else\n        line = xstrdup (defentry->label);\n    }\n\n  if (line)\n    {\n      /* It is possible that the references have more than a single\n         entry with the same label, and also LINE is down-cased, which\n         complicates matters even more.  Try to be as accurate as we\n         can: if they've chosen the default, use defentry directly. */\n      if (defentry && strcmp (line, defentry->label) == 0)\n        entry = defentry;\n      else\n        /* Find the selected label in the references.  If there are\n           more than one label which matches, find the one that's\n           closest to point.  */\n        {\n          register int i;\n          int best = -1, min_dist = window->node->nodelen;\n          REFERENCE *ref;\n\n          for (i = 0; refs && (ref = refs[i]); i++)\n            {\n              /* Need to use mbscasecmp because LINE is downcased\n                 inside info_read_completing_in_echo_area.  */\n              if (mbscasecmp (line, ref->label) == 0)\n                {\n                  /* ref->end is more accurate estimate of position\n                     for menus than ref->start.  Go figure.  */\n                  int dist = abs (window->point - ref->end);\n\n                  if (dist < min_dist)\n                    {\n                      min_dist = dist;\n                      best = i;\n                    }\n                }\n            }\n          if (best != -1)\n            entry = refs[best];\n          else\n            entry = NULL;\n        }\n\n      if (!entry && defentry)\n        info_error (_(\"The reference disappeared! (%s)\"), line);\n      else\n        {\n          info_select_reference (window, entry);\n        }\n\n      free (line);\n    }\n}",
      "lines": 182,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "info_move_to_xref": {
      "start_point": [
        2546,
        0
      ],
      "end_point": [
        2583,
        1
      ],
      "content": "static int\ninfo_move_to_xref (WINDOW *window, int dir)\n{\n  long placement = -1;\n  NODE *node = window->node;\n  REFERENCE **ref;\n\n  /* Fail if there are no references in node */\n  if (!node->references || !node->references[0])\n    return 0;\n\n  if (dir == 1) /* Search forwards */\n    for (ref = node->references; *ref != 0; ref++)\n      {\n        if ((*ref)->start > window->point)\n          {\n            placement = (*ref)->start;\n            break;\n          }\n      }\n  else /* Search backwards */\n    for (ref = node->references; *ref != 0; ref++)\n      {\n        if ((*ref)->start >= window->point) break;\n        placement = (*ref)->start;\n      }\n\n  if (placement == -1)\n    {\n      /* There was neither a menu or xref entry appearing in this node\n         after point. */\n      return 0;\n    }\n\n  window->point = placement;\n  window_adjust_pagetop (window);\n  return 1;\n}",
      "lines": 38,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cleanup_history": {
      "start_point": [
        2591,
        0
      ],
      "end_point": [
        2604,
        1
      ],
      "content": "static void\ncleanup_history (WINDOW *window, int start, int end)\n{\n  int i;\n  for (i = start; i < end; i++)\n    {\n      free_history_node (window->hist[i]->node);\n      free (window->hist[i]);\n    }\n  memmove (&window->hist[start], &window->hist[end],\n           (window->hist_index - end) * sizeof (WINDOW_STATE *));\n  window->hist_index -= end - start;\n  window->hist[window->hist_index] = 0;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "info_follow_menus": {
      "start_point": [
        2746,
        0
      ],
      "end_point": [
        2833,
        1
      ],
      "content": "NODE *\ninfo_follow_menus (NODE *initial_node, char **menus, char **error,\n\t\t   int strict)\n{\n  NODE *node = NULL;\n\n  for (; *menus; menus++)\n    {\n      REFERENCE *entry;\n      char *arg = *menus; /* Remember the name of the menu entry we want. */\n\n      debug (3, (\"looking for %s in %s:%s\", arg, initial_node->fullpath,\n\t\t initial_node->nodename));\n\n      if (!initial_node->references)\n        {\n          if (error)\n            {\n              free (*error);\n              asprintf (error, _(\"No menu in node '%s'\"),\n                        node_printed_rep (initial_node));\n            }\n          debug (3, (\"no menu found\"));\n          if (!strict)\n            return initial_node;\n          else\n            {\n              free_history_node (initial_node);\n              return 0;\n            }\n        }\n\n      /* Find the specified menu item. */\n      entry = info_get_menu_entry_by_label (initial_node, arg, !strict);\n\n      /* If we failed to find the reference: */\n      if (!entry)\n        {\n          if (error)\n            {\n              free (*error);\n              asprintf (error, _(\"No menu item '%s' in node '%s'\"),\n                        arg, node_printed_rep (initial_node));\n            }\n          debug (3, (\"no entry found\"));\n          if (!strict)\n            return initial_node;\n          else\n            {\n              free_history_node (initial_node);\n              return 0;\n            }\n        }\n\n      debug (3, (\"entry: %s, %s\", entry->filename, entry->nodename));\n      \n      /* Try to find this node.  */\n      node = info_get_node_with_defaults (entry->filename, entry->nodename,\n                                          initial_node);\n      if (!node)\n        {\n\t  debug (3, (\"no matching node found\"));\n\t  if (error)\n            {\n              free (*error);\n              asprintf (error,\n                        _(\"Unable to find node referenced by '%s' in '%s'\"),\n                        entry->label,\n                        node_printed_rep (initial_node));\n            }\n          if (strict)\n            {\n              free_history_node (initial_node);\n              return 0;\n            }\n          else\n            return initial_node;\n        }\n\n      debug (3, (\"node: %s, %s\", node->fullpath, node->nodename));\n      \n      /* Success.  Go round the loop again.  */\n      free_history_node (initial_node);\n      initial_node = node;\n    }\n\n  return initial_node;\n}",
      "lines": 88,
      "depth": 15,
      "decorators": [
        "NODE",
        "*\ninfo_follow_menus (NODE *initial_node, char **menus, char **error,\n\t\t   int strict)",
        "*"
      ]
    },
    "split_list_of_nodenames": {
      "start_point": [
        2840,
        0
      ],
      "end_point": [
        2862,
        1
      ],
      "content": "static char **\nsplit_list_of_nodenames (char *str)\n{\n  unsigned len = 2;\n  char **nodes = xmalloc (len * sizeof (char *));\n\n  nodes[len - 2] = str;\n\n  while (*str++)\n    {\n      if (*str == ',')\n        {\n          *str++ = 0;           /* get past the null byte */\n          len++;\n          nodes = xrealloc (nodes, len * sizeof (char *));\n          nodes[len - 2] = str;\n        }\n    }\n\n  nodes[len - 1] = NULL;\n\n  return nodes;\n}",
      "lines": 23,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "char",
        "**\nsplit_list_of_nodenames (char *str)",
        "*",
        "*\nsplit_list_of_nodenames (char *str)",
        "*"
      ]
    },
    "info_handle_pointer": {
      "start_point": [
        2918,
        0
      ],
      "end_point": [
        2971,
        1
      ],
      "content": "static int\ninfo_handle_pointer (char *label, WINDOW *window)\n{\n  char *description;\n  NODE *node;\n\n  if (!strcmp (label, \"Up\"))\n    description = window->node->up;\n  else if (!strcmp (label, \"Next\"))\n    description = window->node->next;\n  else if (!strcmp (label, \"Prev\"))\n    description = window->node->prev;\n\n  if (!description)\n    {\n      info_error (msg_no_pointer, label);\n      return 0;\n    }\n\n  info_parse_node (description);\n  node = info_get_node_with_defaults (info_parsed_filename,\n                                      info_parsed_nodename,\n                                      window->node);\n  if (!node)\n    {\n      if (info_recent_file_error)\n        info_error (\"%s\", info_recent_file_error);\n      else\n        info_error (msg_cant_find_node, description);\n      return 0;\n    }\n\n  /* If we are going up, set the cursor position to the last place it\n     was in the node. */\n  if (strcmp (label, \"Up\") == 0)\n    {\n      int i;\n\n      for (i = window->hist_index - 1; i >= 0; i--)\n        {\n          NODE *p = window->hist[i]->node;\n\n          if (p->fullpath && !strcmp (p->fullpath, node->fullpath)\n              && p->nodename && !strcmp (p->nodename, node->nodename))\n            break;\n        }\n\n      if (i >= 0)\n        node->display_pos = window->hist[i]->point;\n    }\n\n  info_set_node_of_window (window, node);\n  return 1;\n}",
      "lines": 54,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "forward_move_node_structure": {
      "start_point": [
        3067,
        0
      ],
      "end_point": [
        3179,
        1
      ],
      "content": "static int\nforward_move_node_structure (WINDOW *window, int behaviour)\n{\n  if (window->node->flags & (N_IsInternal | N_IsManPage))\n    return 1;\n\n  switch (behaviour)\n    {\n    case IS_PageOnly:\n      info_error (\"%s\", msg_at_node_bottom);\n      return 1;\n\n    case IS_NextOnly:\n      return !info_handle_pointer (\"Next\", window);\n      break;\n\n    case IS_Continuous:\n      {\n        /* If this node contains a menu, select its first entry.  Indices\n           are an exception, as their menus lead nowhere meaningful.  Likewise\n           for dir nodes. */\n        if (!(window->node->flags & N_IsIndex)\n            && !(window->node->flags & N_IsDir))\n          {\n            REFERENCE *entry;\n\n            if (entry = select_menu_digit (window, '1'))\n              {\n                info_select_reference (window, entry);\n                return 0;\n              }\n          }\n\n        /* Okay, this node does not contain a menu.  If it contains a\n           \"Next:\" pointer, use that. */\n        if (window->node->next)\n          {\n            info_handle_pointer (\"Next\", window);\n            return 0;\n          }\n\n        /* Okay, there wasn't a \"Next:\" for this node.  Move \"Up:\" until we\n           can move \"Next:\".  If that isn't possible, complain that there\n           are no more nodes. */\n        {\n          int up_counter;\n          int starting_hist_index = window->hist_index;\n\n          /* Back up through the \"Up:\" pointers until we have found a \"Next:\"\n             that isn't the same as the first menu item found in that node. */\n          up_counter = 0;\n          while (1)\n            {\n              if (window->node->up)\n                {\n                  REFERENCE *entry;\n\n                  if (!info_handle_pointer (\"Up\", window))\n                    return 1;\n\n                  up_counter++;\n\n                  /* If no \"Next\" pointer, keep backing up. */\n                  if (!window->node->next)\n                    continue;\n\n                  /* If this node's first menu item is the same as this node's\n                     Next pointer, keep backing up. */\n                  entry = select_menu_digit (window, '1');\n                  if (entry && !strcmp (window->node->next, entry->nodename))\n                    continue;\n\n                  /* This node has a \"Next\" pointer, and it is not the\n                     same as the first menu item found in this node. */\n                  info_handle_pointer (\"Next\", window);\n\n                  /* Don't include intermediate nodes in the window's\n                     history.  */\n                  cleanup_history (window, starting_hist_index,\n                                   window->hist_index - 1);\n                  return 0;\n                }\n              else\n                {\n                  /* No more \"Up\" pointers.  We are at the last node in the\n                     file. */\n                  register int i;\n\n                  for (i = 0; i < up_counter; i++)\n                    forget_node (window);\n\n                  switch (scroll_last_node)\n                    {\n                    case SLN_Stop:\n                      info_error (\"%s\",\n                                  _(\"No more nodes within this document\"));\n                      return 1;\n                      \n                    case SLN_Top:\n                      info_parse_and_select (\"Top\", window);\n                      return 0;\n                      \n                    default:\n                      abort ();\n                    }\n                }\n            }\n        }\n        break;\n      }\n    }\n  return 0;\n}",
      "lines": 113,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "backward_move_node_structure": {
      "start_point": [
        3183,
        0
      ],
      "end_point": [
        3252,
        1
      ],
      "content": "static int\nbackward_move_node_structure (WINDOW *window, int behaviour)\n{\n  if (window->node->flags & (N_IsInternal | N_IsManPage))\n    return 1;\n\n  switch (behaviour)\n    {\n    case IS_PageOnly:\n      info_error (\"%s\", msg_at_node_top);\n      return 1;\n\n    case IS_NextOnly:\n      return !info_handle_pointer (\"Prev\", window);\n      break;\n\n    case IS_Continuous:\n      if (window->node->up)\n        {\n          /* If up is the dir node, we are at the top node.\n             Don't do anything. */\n          if (!strncasecmp (window->node->up, \"(dir)\", strlen (\"(dir)\")))\n            {\n              info_error (\"%s\", _(\"No 'Prev' or 'Up' for this node within this document\"));\n              return 1;\n            }\n          /* If 'Prev' and 'Up' are the same, we are at the first node\n             of the 'Up' node's menu. Go to up node. */\n          else if (window->node->prev\n              && !strcmp(window->node->prev, window->node->up))\n            {\n              info_handle_pointer (\"Up\", window);\n            }\n          /* Otherwise, go to 'Prev' node and go down the last entry\n             in the menus as far as possible. */\n          else if (window->node->prev)\n            {\n              int starting_hist_index = window->hist_index;\n              info_handle_pointer (\"Prev\", window);\n              if (!(window->node->flags & N_IsIndex))\n                {\n                  while (1)\n                    {\n                      REFERENCE *entry = select_menu_digit (window, '0');\n                      if (!entry)\n                        break;\n                      if (!info_select_reference (window, entry))\n                        break;\n                    }\n                  /* Don't include intermediate nodes in the window's\n                     history.  */\n                  cleanup_history (window, starting_hist_index,\n                                   window->hist_index - 1);\n                }\n            }\n          else /* 'Up' but no 'Prev' */\n            info_handle_pointer (\"Up\", window);\n        }\n      else if (window->node->prev) /* 'Prev' but no 'Up' */\n        info_handle_pointer (\"Prev\", window);\n      else\n        {\n          info_error (\"%s\", _(\"No 'Prev' or 'Up' for this node within this document\"));\n          return 1;\n        }\n\n      break; /* case IS_Continuous: */\n    }\n  return 0;\n}",
      "lines": 70,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "find_invocation_node_by_nodename": {
      "start_point": [
        3374,
        0
      ],
      "end_point": [
        3399,
        1
      ],
      "content": "static NODE *\nfind_invocation_node_by_nodename (FILE_BUFFER *fb, char *program)\n{\n  NODE *node = 0;\n  TAG **n;\n  char *try1, *try2;\n  n = fb->tags;\n  if (!n)\n    return 0;\n\n  asprintf (&try1, \"Invoking %s\", program);\n  asprintf (&try2, \"%s invocation\", program);\n  for (; *n; n++)\n    {\n      if ((*n)->nodename\n          && (!strcasecmp ((*n)->nodename, try1)\n              || !strcasecmp ((*n)->nodename, try2)))\n        {\n          node = info_get_node_of_file_buffer (fb, (*n)->nodename);\n          break;\n        }\n    }\n  free (try1); free (try2);\n\n  return node;\n}",
      "lines": 26,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nfind_invocation_node_by_nodename (FILE_BUFFER *fb, char *program)",
        "*"
      ]
    },
    "info_intuit_options_node": {
      "start_point": [
        3406,
        0
      ],
      "end_point": [
        3508,
        1
      ],
      "content": "REFERENCE *\ninfo_intuit_options_node (NODE *node, char *program)\n{\n  /* The list of node names typical for GNU manuals where the program\n     usage and specifically the command-line arguments are described.\n     This is pure heuristics.  I gathered these node names by looking\n     at all the Info files I could put my hands on.  If you are\n     looking for evidence to complain to the GNU project about\n     non-uniform style of documentation, here you have your case!  */\n  static const char *invocation_nodes[] = {\n    \"%s invocation\",\n    \"Invoking %s\",\n    \"Preliminaries\",    /* m4 has Invoking under Preliminaries! */\n    \"Invocation\",\n    \"Command Arguments\",/* Emacs */\n    \"Invoking `%s'\",\n    \"%s options\",\n    \"Options\",\n    \"Option \",          /* e.g. \"Option Summary\" */\n    \"Invoking\",\n    \"All options\",      /* tar, paxutils */\n    \"Arguments\",\n    \"%s cmdline\",       /* ar */\n    \"%s\",               /* last resort */\n    (const char *)0\n  };\n\n  char *filename = node->fullpath;\n  if (!strcmp (\"Top\", node->nodename))\n    {\n      /* Look through the list of nodes (and anchors) in the file for a node to \n         start at.  There may be an invocation node that is not listed in the \n         top-level menu (this is the case for the Bash 4.2 manual), or it may \n         be referred to with an anchor (\"Invoking makeinfo\" in Texinfo \n         manual).  */\n      FILE_BUFFER *fb;\n      NODE *n;\n      fb = info_find_file (filename);\n      if (!fb)\n        return 0;\n      n = find_invocation_node_by_nodename (fb, program);\n      if (n)\n        {\n          free_history_node (node);\n          node = n;\n        }\n    }\n\n  /* We keep looking deeper and deeper in the menu structure until\n     there are no more menus or no menu items from the above list.\n     Some manuals have the invocation node sitting 3 or 4 levels deep\n     in the menu hierarchy...  */\n  while (1)\n    {\n      const char **try_node;\n      REFERENCE *entry = NULL;\n\n      /* If no menu in this node, stop here.  Perhaps this node\n         is the one they need.  */\n      if (!node->references)\n        break;\n\n      /* Look for node names typical for usage nodes in this menu.  */\n      for (try_node = invocation_nodes; *try_node; try_node++)\n        {\n          char *nodename;\n\n          nodename = xmalloc (strlen (program) + strlen (*try_node));\n          sprintf (nodename, *try_node, program);\n          /* The last resort \"%s\" is dangerous, so we restrict it\n             to exact matches here.  */\n          entry = info_get_menu_entry_by_label\n            (node, nodename, strcmp (*try_node, \"%s\"));\n          free (nodename);\n          if (entry)\n            break;\n        }\n\n      if (!entry)\n        break;\n\n      /* Go down into menu, and repeat. */ \n\n      if (!entry->filename)\n        entry->filename = xstrdup (filename);\n\n      {\n        NODE *node2;\n        node2 = info_get_node (entry->filename, entry->nodename);\n        if (!node2)\n          break;\n        free_history_node (node);\n        node = node2;\n      }\n    }\n\n  {\n    char *n = node->nodename;\n    node->nodename = 0;\n    free_history_node (node);\n    return info_new_reference (filename, n);\n  }\n}",
      "lines": 103,
      "depth": 15,
      "decorators": [
        "REFERENCE",
        "*\ninfo_intuit_options_node (NODE *node, char *program)",
        "*"
      ]
    },
    "program_name_from_file_name": {
      "start_point": [
        3513,
        0
      ],
      "end_point": [
        3532,
        1
      ],
      "content": "char *\nprogram_name_from_file_name (char *file_name)\n{\n  int i;\n  char *program_name = xstrdup (filename_non_directory (file_name));\n\n  for (i = strlen (program_name) - 1; i > 0; i--)\n    if (program_name[i] == '.'\n        && (FILENAME_CMPN (program_name + i, \".info\", 5) == 0\n            || FILENAME_CMPN (program_name + i, \".inf\", 4) == 0\n#ifdef __MSDOS__\n            || FILENAME_CMPN (program_name + i, \".i\", 2) == 0\n#endif\n            || isdigit (program_name[i + 1]))) /* a man page foo.1 */\n      {\n        program_name[i] = 0;\n        break;\n      }\n  return program_name;\n}",
      "lines": 20,
      "depth": 15,
      "decorators": [
        "char",
        "*\nprogram_name_from_file_name (char *file_name)",
        "*"
      ]
    },
    "dump_nodes_to_file": {
      "start_point": [
        3695,
        0
      ],
      "end_point": [
        3738,
        1
      ],
      "content": "void\ndump_nodes_to_file (REFERENCE **references,\n                    char *output_filename, int dump_subnodes)\n{\n  int i;\n  FILE *output_stream;\n  \n  if (!references)\n    return;\n\n  /* Get the stream to print the nodes to.  Special case of an output\n     filename of \"-\" means to dump the nodes to stdout. */\n  if (strcmp (output_filename, \"-\") == 0)\n    output_stream = stdout;\n  else\n    output_stream = fopen (output_filename, \"w\");\n\n  if (!output_stream)\n    {\n      info_error (_(\"Could not create output file '%s'\"), output_filename);\n      return;\n    }\n\n  initialize_dumping ();\n\n  /* Print each node to stream. */\n  for (i = 0; references[i]; i++)\n    {\n      if (dump_node_to_stream (references[i]->filename,\n                               references[i]->nodename,\n                               output_stream,\n                               dump_subnodes) == DUMP_SYS_ERROR)\n\t{\n\t  info_error (_(\"error writing to %s: %s\"), output_filename,\n                      strerror (errno));\n\t  exit (EXIT_FAILURE);\n\t}\n    }\n  \n  if (output_stream != stdout)\n    fclose (output_stream);\n\n  debug (1, (_(\"closing %s\"), output_filename));\n}",
      "lines": 44,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "initialize_dumping": {
      "start_point": [
        3743,
        0
      ],
      "end_point": [
        3748,
        1
      ],
      "content": "static void\ninitialize_dumping (void)\n{\n  info_namelist_free (dumped_already);\n  dumped_already = NULL;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dump_node_to_stream": {
      "start_point": [
        3753,
        0
      ],
      "end_point": [
        3825,
        1
      ],
      "content": "static int\ndump_node_to_stream (char *filename, char *nodename,\n\t\t     FILE *stream, int dump_subnodes)\n{\n  register int i;\n  NODE *node;\n\n  node = info_get_node (filename, nodename);\n\n  if (!node)\n    {\n      if (info_recent_file_error)\n        info_error (\"%s\", info_recent_file_error);\n      else\n        {\n          if (filename && *nodename != '(')\n            info_error (msg_cant_file_node,\n                        filename_non_directory (filename),\n                        nodename);\n          else\n            info_error (msg_cant_find_node, nodename);\n        }\n      return DUMP_INFO_ERROR;\n    }\n\n  /* If we have already dumped this node, don't dump it again. */\n  if (info_namelist_add (&dumped_already, node->nodename))\n    {\n      free_history_node (node);\n      return DUMP_SUCCESS;\n    }\n\n  /* Maybe we should print some information about the node being output. */\n  debug (1, (_(\"writing node %s...\"), node_printed_rep (node)));\n\n  if (write_node_to_stream (node, stream))\n    {\n      free_history_node (node);\n      return DUMP_SYS_ERROR;\n    }\n\n  /* If we are dumping subnodes, get the list of menu items in this node,\n     and dump each one recursively. */\n  if (dump_subnodes)\n    {\n      REFERENCE **menu = NULL;\n\n      /* If this node is an Index, do not dump the menu references. */\n      if (string_in_line (\"Index\", node->nodename) == -1)\n        menu = node->references;\n\n      if (menu)\n        {\n          for (i = 0; menu[i]; i++)\n            {\n              if (REFERENCE_MENU_ITEM != menu[i]->type) continue;\n\n              /* We don't dump Info files which are different than the\n                 current one. */\n              if (!menu[i]->filename)\n                if (dump_node_to_stream (filename, menu[i]->nodename,\n                      stream, dump_subnodes) == DUMP_SYS_ERROR)\n                  {\n                    free_history_node (node);\n                    return DUMP_SYS_ERROR;\n                  }\n            }\n        }\n    }\n\n  free_history_node (node);\n  return DUMP_SUCCESS;\n}",
      "lines": 73,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "write_node_to_stream": {
      "start_point": [
        3876,
        0
      ],
      "end_point": [
        3880,
        1
      ],
      "content": "int\nwrite_node_to_stream (NODE *node, FILE *stream)\n{\n  return fwrite (node->contents, node->nodelen, 1, stream) != 1;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "info_search_in_node_internal": {
      "start_point": [
        3922,
        0
      ],
      "end_point": [
        4011,
        1
      ],
      "content": "static enum search_result\ninfo_search_in_node_internal (WINDOW *window, NODE *node,\n                              char *string, long start,\n                              int dir, int case_sensitive,\n                              int match_regexp, long *poff)\n{\n  enum search_result result = search_not_found;\n\n  long start1, end1;\n  int match_index;\n  long new_point;\n\n  MATCH_STATE matches;\n    \n  /* Check if we need to calculate new results. */\n  if (!matches_ready (&window->matches)\n      || strcmp (window->search_string, string)\n      || window->search_is_case_sensitive != case_sensitive)\n    {\n      free_matches (&window->matches);\n      free (window->search_string);\n      window->search_string = xstrdup (string);\n      window->search_is_case_sensitive = case_sensitive;\n      result = regexp_search (string, !match_regexp, !case_sensitive,\n                              node->contents, node->nodelen, &matches);\n    }\n  else\n    {\n      matches = window->matches;\n      result = search_success;\n    }\n  \n  if (result != search_success)\n    return result;\n\n  if (node->flags & N_Simple)\n    {\n      /* There are matches in the node, but it hasn't been scanned yet.  Get\n         the node again, because its contents may differ. */\n      enum search_result subresult;\n      NODE *full_node;\n\n      free_matches (&matches);\n      full_node = info_get_node (node->fullpath, node->nodename);\n      subresult = info_search_in_node_internal (window, full_node,\n                                    string, start,\n                                    dir, case_sensitive,\n                                    match_regexp, poff);\n      if (window->node != full_node)\n        free (full_node);\n      return subresult;\n    }\n\n  if (dir > 0)\n    {\n      start1 = start;\n      end1 = node->nodelen;\n    }\n  else\n    {\n      start1 = 0;\n      end1 = start + 1; /* include start byte in search area */\n    }\n\n  if (start1 < node->body_start)\n    start1 = node->body_start;\n  if (end1 < node->body_start)\n    end1 = node->body_start;\n  \n  result = match_in_match_list (&matches, start1, end1, dir, &match_index);\n  if (result != search_success)\n    return result;\n\n  *poff = match_by_index (&matches, match_index).rm_so;\n\n  window->flags |= W_UpdateWindow;\n  if (window->node != node)\n    info_set_node_of_window (window, node);\n\n  window->matches = matches;\n\n  if (isearch_is_active && dir > 0)\n    new_point = match_by_index (&matches, match_index).rm_eo;\n  else\n    new_point = match_by_index (&matches, match_index).rm_so;\n\n  window->point = new_point;\n\n  return result;\n}",
      "lines": 90,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "enum search_result",
        "enum",
        "search_result"
      ]
    },
    "info_search_internal": {
      "start_point": [
        4025,
        0
      ],
      "end_point": [
        4174,
        1
      ],
      "content": "static int\ninfo_search_internal (char *string, WINDOW *window,\n\t\t      int dir, int case_sensitive,\n                      long *start_off)\n{\n  register int i;\n  FILE_BUFFER *file_buffer;\n  long start;\n  enum search_result result;\n  int search_other_nodes = 1;\n  int number_of_tags = -1, starting_tag = -1, current_tag = -1;\n  NODE *node = window->node; /* Node to search in. */\n  char *subfile_name = 0;\n  TAG *tag;\n  char *msg = 0;\n  int first_time = 1;\n  \n  /* If this node isn't part of a larger file, search this node only. */\n  file_buffer = file_buffer_of_window (window);\n  if (!file_buffer || !file_buffer->tags\n      || !strcmp (window->node->nodename, \"*\"))\n    search_other_nodes = 0;\n\n  /* Find number of tags and current tag. */\n  if (search_other_nodes)\n    {\n      char *initial_nodename = window->node->nodename;\n\n      for (i = 0; file_buffer->tags[i]; i++)\n        if (strcmp (initial_nodename, file_buffer->tags[i]->nodename) == 0)\n          {\n            starting_tag = i;\n            subfile_name = file_buffer->tags[i]->filename;\n          }\n\n      number_of_tags = i;\n\n      /* Our tag wasn't found.  This shouldn't happen. */\n      if (starting_tag == -1)\n        return -1;\n      current_tag = starting_tag;\n    }\n\n  /* Set starting position of search. */\n  start = *start_off;\n  \n  /* Search through subsequent nodes, wrapping around to the top\n     of the Info file until we find the string or return to this\n     window's node and point. */\n  while (1)\n    {\n      result = info_search_in_node_internal (window, node, string, start, dir,\n                 case_sensitive, use_regex, start_off);\n\n      if (node != window->node)\n        free_history_node (node);\n\n      if (result == search_invalid)\n        return 1;\n\n      if (result == search_success)\n        {\n          if (!echo_area_is_active)\n            {\n              if (msg)\n                window_message_in_echo_area (\"%s\", _(msg));\n              else\n                window_clear_echo_area ();\n            }\n          return 0;\n        }\n\n      if (!search_other_nodes)\n        break;\n\n      /* If we've searched our starting node twice, there are no matches.\n         Bail out.  (We searched the second time in case there were matches \n         before the starting offset.) */\n      if (current_tag == starting_tag && !first_time)\n        break;\n      first_time = 0;\n  \n      /* Find the next tag that isn't an anchor.  */\n      for (i = current_tag + dir; ; i += dir)\n        {\n          if (i < 0)\n            {\n              msg = N_(\"Search continued from the end of the document\");\n              i = number_of_tags - 1;\n            }\n          else if (i == number_of_tags)\n            {\n              msg = N_(\"Search continued from the beginning of the document\");\n              i = 0;\n            }\n          \n          tag = file_buffer->tags[i];\n          if (tag->cache.nodelen != 0)\n            break;\n        }\n\n      current_tag = i;\n\n      /* Display message when searching a new subfile. */\n      if (!echo_area_is_active && tag->filename != subfile_name)\n        {\n          subfile_name = tag->filename;\n\n          window_message_in_echo_area\n            (_(\"Searching subfile %s ...\"),\n             filename_non_directory (subfile_name));\n        }\n\n      /* Get a new node to search in. */\n      free_matches (&window->matches);\n\n      node = info_node_of_tag_fast (file_buffer, &tag);\n      if (!node)\n        {\n          /* If not doing i-search... */\n          if (!echo_area_is_active)\n            {\n              if (info_recent_file_error)\n                info_error (\"%s\", info_recent_file_error);\n              else\n                info_error (msg_cant_file_node,\n                            filename_non_directory (file_buffer->filename),\n                            tag->nodename);\n            }\n          return -1;\n        }\n\n      if (dir < 0)\n        start = tag->cache.nodelen;\n      else\n        start = 0;\n\n      /* Allow C-g to quit the search, failing it if pressed. */\n      fill_input_buffer (0); \\\n      if (info_input_buffer[pop_index] == Control ('g'))\n        goto funexit;\n    }\n\n  /* Not in interactive search. */\n  if (!echo_area_is_active)\n    info_error (\"%s\", _(\"Search failed\"));\n\nfunexit:\n  return -1;\n}",
      "lines": 150,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ask_for_search_string": {
      "start_point": [
        4181,
        0
      ],
      "end_point": [
        4222,
        1
      ],
      "content": "static int\nask_for_search_string (int case_sensitive, int use_regex, int direction)\n{\n  char *line, *prompt;\n\n  if (search_string)\n    asprintf (&prompt, _(\"%s%s%s [%s]: \"),\n             use_regex ? _(\"Regexp search\") : _(\"Search\"),\n             case_sensitive ? _(\" case-sensitively\") : \"\",\n             direction < 0 ? _(\" backward\") : \"\",\n             search_string);\n  else\n    asprintf (&prompt, _(\"%s%s%s: \"),\n             use_regex ? _(\"Regexp search\") : _(\"Search\"),\n             case_sensitive ? _(\" case-sensitively\") : \"\",\n             direction < 0 ? _(\" backward\") : \"\");\n\n  line = info_read_in_echo_area (prompt);\n  free (prompt);\n\n  if (!line) /* User aborted. */\n    {\n      return 0;\n    }\n  if (!*line)\n    {\n      free (line);\n      return 1;\n    }\n\n  if (mbslen (line) < min_search_length)\n    {\n      info_error (\"%s\", _(\"Search string too short\"));\n      free (line);\n      return 1;\n    }\n\n  free (search_string);\n  search_string = line;\n\n  return 1;\n}",
      "lines": 42,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "info_search_1": {
      "start_point": [
        4231,
        0
      ],
      "end_point": [
        4280,
        1
      ],
      "content": "static void\ninfo_search_1 (WINDOW *window, int count, int case_sensitive)\n{\n  int result;\n  int direction;\n  long start_off;\n  char *p;\n\n  if (count < 0)\n    {\n      direction = -1;\n      count = -count;\n    }\n  else\n    {\n      direction = 1;\n      if (count == 0)\n        count = 1;      /* for backward compatibility */\n    }\n\n  if (!ask_for_search_string (case_sensitive, use_regex, direction)\n      || !search_string)\n    return;\n\n  start_off = window->point + direction;\n  \n  /* If the search string includes upper-case letters, make the search\n     case-sensitive.  */\n  if (case_sensitive == 0)\n    for (p = search_string; *p; p++)\n      if (isupper (*p))\n        {\n          case_sensitive = 1;\n          break;\n        }\n\n  last_search_direction = direction;\n  last_search_case_sensitive = case_sensitive;\n\n  for (result = 0; result == 0 && count--; )\n    result = info_search_internal (search_string,\n                                   active_window, direction, case_sensitive,\n\t\t\t\t   &start_off);\n\n  window_adjust_pagetop (window);\n\n  /* Perhaps free the unreferenced file buffers that were searched, but\n     not retained. */\n  gc_file_buffers_and_nodes ();\n}",
      "lines": 50,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "tag_of_reference": {
      "start_point": [
        4285,
        0
      ],
      "end_point": [
        4308,
        1
      ],
      "content": "static int\ntag_of_reference (REFERENCE *r, WINDOW *window, FILE_BUFFER **fb, TAG ***t)\n{\n  char *filename, *nodename;\n  int i;\n\n  filename = r->filename;\n  nodename = r->nodename;\n  if (!filename)\n    filename = window->node->fullpath;\n  if (!nodename || !*nodename)\n    nodename = \"Top\";\n\n  *fb = info_find_file (filename);\n  if (!*fb)\n    return 0;\n\n  for (i = 0; *(*t = &(*fb)->tags[i]); i++)\n    if (!strcmp (nodename, (**t)->nodename))\n      goto found_tag;\n  return 0;\nfound_tag: ;\n  return 1;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "tree_search_check_node": {
      "start_point": [
        4318,
        0
      ],
      "end_point": [
        4437,
        1
      ],
      "content": "static void\ntree_search_check_node (WINDOW *window)\n{\n  long start_off;\n  enum search_result result;\n  char *string;\n  int previous_match;\n\n  if (window->node->active_menu != 0)\n    previous_match = 1;\n  else\n    {\n      previous_match = 0;\n      window->node->active_menu = BEFORE_MENU;\n    }\n  string = xstrdup (window->search_string);\n  goto check_node;\n\ncheck_node:\n  result = info_search_in_node_internal (window, window->node,\n                                  string,\n                                  window->point + 1,\n                                  1, /* Search forwards */\n                                  1, /* Case-sensitive */\n                                  0, /* No regular expressions. */\n                                  &start_off);\n  if (result == search_success)\n    {\n      info_show_point (window);\n      goto funexit;\n    }\n\n  /* Otherwise, try each menu entry in turn. */\n  if (matches_ready (&window->matches))\n    window->point++; /* Find this match again if/when we come back. */\n  goto check_menus;\n\n  /* At this juncture, window->node->active_menu is the index of the last\n     reference in the node to have been checked, plus one.  BEFORE_MENU is a \n     special code to say that none of them have been checked. */\ncheck_menus:\n  if (!(window->node->flags & N_IsIndex)) /* Don't go down menus in index  */\n    {                               /* nodes, because this leads to loops. */\n      REFERENCE *r;\n      int ref_index;\n      if (window->node->active_menu != BEFORE_MENU)\n        ref_index = window->node->active_menu;\n      else\n        ref_index = 0;\n      for (; (r = window->node->references[ref_index]); ref_index++)\n        if (r->type == REFERENCE_MENU_ITEM)\n          {\n            FILE_BUFFER *file_buffer;\n            TAG **tag;\n            NODE *node;\n\n            if (!tag_of_reference (r, window, &file_buffer, &tag))\n              continue;\n\n            if ((*tag)->flags & N_SeenBySearch)\n              continue;\n            (*tag)->flags |= N_SeenBySearch;\n\n            window->node->active_menu = ref_index + 1;\n            node = info_node_of_tag (file_buffer, tag);\n            if (!node)\n              continue;\n            info_set_node_of_window_fast (window, node);\n            window->node->active_menu = BEFORE_MENU;\n            goto check_node;\n          }\n    }\n  goto go_up;\n\ngo_up:\n  /* If no more menu entries, try going back. */\n  if (window->hist_index >= 2\n      && window->hist[window->hist_index - 2]->node->active_menu != 0)\n    {\n      forget_node_fast (window);\n      goto check_menus;\n    }\n\n  /* Go back to the final match. */\n  if (previous_match)\n    {\n      message_in_echo_area (_(\"Going back to last match from %s\"),\n                            window->node->nodename);\n\n      /* This is a trick.\n         Set active_menu to one more than the number of references,\n         and add an arbitrary node to the window history.\n         When we call tree_search_check_node_backwards, this will go\n         backwards through the tree structure to the last match.\n         Change active_menu back to a valid value afterwards .*/\n      {\n        int n = 0;\n\n        while (window->node->references[n])\n          n++;\n        window->node->active_menu = n + 1;\n\n        info_parse_and_select (\"Top\", window);\n        /* Check if this worked. */\n        if (strcmp (window->node->nodename, \"Top\"))\n          {\n            /* Loading \"Top\" node failed. */\n            window->node->active_menu = 0;\n            goto funexit;\n          }\n        window->node->active_menu = BEFORE_MENU;\n      }\n      window->point = window->node->body_start;\n      tree_search_check_node_backwards (window);\n    }\n  info_error (previous_match ?  _(\"No more matches\") : _(\"Search failed\"));\n\nfunexit:\n  free (string);\n}",
      "lines": 120,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "tree_search_check_node_backwards": {
      "start_point": [
        4441,
        0
      ],
      "end_point": [
        4550,
        1
      ],
      "content": "static void\ntree_search_check_node_backwards (WINDOW *window)\n{\n  long start_off;\n  enum search_result result;\n  char *string;\n  int previous_match;\n\n  previous_match = (window->node->active_menu != 0);\n\n  string = xstrdup (window->search_string);\n  goto check_node;\n\ncheck_node:\n  result = info_search_in_node_internal (window, window->node,\n                                  string,\n                                  window->point - 1,\n                                 -1, /* Search backwards */\n                                  1, /* Case-sensitive */\n                                  0, /* No regular expressions. */\n                                  &start_off);\n  if (result == search_success)\n    {\n      info_show_point (window);\n      goto funexit;\n    }\n\n  goto go_up;\n\n  /* Check through menus in current node, in reverse order.\n     At this juncture, window->node->active_menu is the index of the last\n     reference in the node to have been checked, plus one.  BEFORE_MENU is a \n     special code to say that none of them have been checked. */\ncheck_menus:\n  if (!(window->node->flags & N_IsIndex)) /* Don't go down menus in index  */\n    {                               /* nodes, because this leads to loops. */\n      REFERENCE *r;\n      int ref_index;\n      if (window->node->active_menu == BEFORE_MENU)\n        goto check_node;\n      else\n        ref_index = window->node->active_menu - 2;\n      for (; ref_index >= 0; ref_index--)\n        {\n          r = window->node->references[ref_index];\n          if (r->type == REFERENCE_MENU_ITEM)\n            {\n              TAG **tag;\n              FILE_BUFFER *file_buffer;\n              NODE *node;\n\n              if (!tag_of_reference (r, window, &file_buffer, &tag))\n                continue;\n\n              /* This inverts what is done for the forwards search.  It's \n                 possible that we will visit the nodes in a different order if \n                 there is more than one reference to a node. */\n              if (!((*tag)->flags & N_SeenBySearch))\n                continue;\n\n              node = info_node_of_tag (file_buffer, tag);\n              if (!node)\n                continue;\n              window->node->active_menu = ref_index + 1;\n              info_set_node_of_window_fast (window, node);\n              window->point = window->node->nodelen;\n              {\n                /* Start at the last menu entry in the subordinate node. */\n                int i;\n                i = 0;\n                while(window->node->references[i])\n                  i++;\n                window->node->active_menu = i + 1;\n              }\n              goto check_menus;\n            }\n        }\n    }\n  window->node->active_menu = BEFORE_MENU;\n  goto check_node;\n\n  /* Try going back. */\ngo_up:\n  if (window->hist_index >= 2\n      && window->hist[window->hist_index - 2]->node->active_menu != 0)\n    {\n      TAG **tag;\n      REFERENCE *r;\n      FILE_BUFFER *file_buffer;\n\n      forget_node_fast (window);\n      r = window->node->references[window->node->active_menu - 1];\n\n      /* Clear the flag to say we've been to the node we just came back\n         from.  This reverse the order from the forwards search, where\n         we set this flag just before going down. */\n      if (r && tag_of_reference (r, window, &file_buffer, &tag))\n        {\n          (*tag)->flags &= ~N_SeenBySearch;\n        }\n\n      goto check_menus;\n    }\n\n  /* Otherwise, no result. */\n  info_error (previous_match ?  _(\"No more matches\") : _(\"Search failed\"));\n\nfunexit:\n  free (string);\n}",
      "lines": 110,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wipe_seen_flags": {
      "start_point": [
        4554,
        0
      ],
      "end_point": [
        4570,
        1
      ],
      "content": "void\nwipe_seen_flags (void)\n{\n  int fb_index;\n  TAG **t;\n\n  for (fb_index = 0; fb_index < info_loaded_files_index; fb_index++)\n    {\n      t = info_loaded_files[fb_index]->tags;\n      if (!t)\n        continue; /* Probably a sub-file of a split file. */\n      for (; *t; t++)\n        {\n          (*t)->flags &= ~N_SeenBySearch;\n        }\n    }\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "window_get_state": {
      "start_point": [
        4785,
        0
      ],
      "end_point": [
        4792,
        1
      ],
      "content": "static void\nwindow_get_state (WINDOW *window, SEARCH_STATE *state)\n{\n  state->fullpath = window->node->fullpath;\n  state->nodename = window->node->nodename;\n  state->pagetop = window->pagetop;\n  state->point = window->point;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "window_set_state": {
      "start_point": [
        4795,
        0
      ],
      "end_point": [
        4806,
        1
      ],
      "content": "static void\nwindow_set_state (WINDOW *window, SEARCH_STATE *state)\n{\n  if (strcmp(window->node->fullpath, state->fullpath)\n      || strcmp(window->node->nodename, state->nodename))\n    {\n      NODE *n = info_get_node (state->fullpath, state->nodename);\n      info_set_node_of_window (window, n);\n    }\n  window->pagetop = state->pagetop;\n  window->point = state->point;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "push_isearch": {
      "start_point": [
        4809,
        0
      ],
      "end_point": [
        4824,
        1
      ],
      "content": "static void\npush_isearch (WINDOW *window, int search_index, int direction,\n              enum search_result failing, long start_off)\n{\n  SEARCH_STATE *state;\n\n  state = xmalloc (sizeof (SEARCH_STATE));\n  window_get_state (window, state);\n  state->search_index = search_index;\n  state->direction = direction;\n  state->failing = failing;\n  state->start = start_off;\n\n  add_pointer_to_array (state, isearch_states_index, isearch_states,\n                        isearch_states_slots, 20);\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pop_isearch": {
      "start_point": [
        4827,
        0
      ],
      "end_point": [
        4846,
        1
      ],
      "content": "static void\npop_isearch (WINDOW *window, int *search_index, int *direction,\n             enum search_result *failing, long *start_off)\n{\n  SEARCH_STATE *state;\n\n  if (isearch_states_index)\n    {\n      isearch_states_index--;\n      state = isearch_states[isearch_states_index];\n      window_set_state (window, state);\n      *search_index = state->search_index;\n      *direction = state->direction;\n      *failing = state->failing;\n      *start_off = state->start;\n\n      free (state);\n      isearch_states[isearch_states_index] = NULL;\n    }\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "free_isearch_states": {
      "start_point": [
        4849,
        0
      ],
      "end_point": [
        4860,
        1
      ],
      "content": "static void\nfree_isearch_states (void)\n{\n  register int i;\n\n  for (i = 0; i < isearch_states_index; i++)\n    {\n      free (isearch_states[i]);\n      isearch_states[i] = NULL;\n    }\n  isearch_states_index = 0;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "show_isearch_prompt": {
      "start_point": [
        4863,
        0
      ],
      "end_point": [
        4912,
        1
      ],
      "content": "static void\nshow_isearch_prompt (int dir, unsigned char *string,\n                     enum search_result failing)\n{\n  register int i;\n  const char *prefix;\n  char *prompt, *p_rep;\n  unsigned int prompt_len, p_rep_index, p_rep_size;\n\n  if (dir < 0)\n    prefix = use_regex ? _(\"Regexp I-search backward: \")\n                       : _(\"I-search backward: \");\n  else\n    prefix = use_regex ? _(\"Regexp I-search: \")\n                       : _(\"I-search: \");\n\n  p_rep_index = p_rep_size = 0;\n  p_rep = NULL;\n  for (i = 0; string[i]; i++)\n    {\n      char *rep;\n\n      switch (string[i])\n        {\n        case ' ': rep = \" \"; break;\n        case LFD: rep = \"\\\\n\"; break;\n        case TAB: rep = \"\\\\t\"; break;\n        default:\n          rep = pretty_keyname (string[i]);\n        }\n      if ((p_rep_index + strlen (rep) + 1) >= p_rep_size)\n        p_rep = xrealloc (p_rep, p_rep_size += 100);\n\n      strcpy (p_rep + p_rep_index, rep);\n      p_rep_index += strlen (rep);\n    }\n\n  prompt_len = strlen (prefix) + p_rep_index + 1;\n  if (failing != search_success)\n    prompt_len += strlen (_(\"Failing \"));\n  prompt = xmalloc (prompt_len);\n  sprintf (prompt, \"%s%s%s\",\n           failing != search_success ? _(\"Failing \") : \"\",\n           prefix, p_rep ? p_rep : \"\");\n\n  window_message_in_echo_area (\"%s\", prompt);\n  free (p_rep);\n  free (prompt);\n  display_cursor_at_point (active_window);\n}",
      "lines": 50,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "incremental_search": {
      "start_point": [
        4915,
        0
      ],
      "end_point": [
        5260,
        1
      ],
      "content": "static void\nincremental_search (WINDOW *window, int count)\n{\n  int key;\n  enum search_result last_search_result, search_result;\n  int dir;\n  SEARCH_STATE orig_state; /* Window state at start of incremental search. */\n  SEARCH_STATE mystate;    /* State before each search. */\n  char *p;\n  int case_sensitive;\n  long start_off = window->point;\n  int starting_history_entry = window->hist_index - 1;\n\n  if (count < 0)\n    dir = -1;\n  else\n    dir = 1;\n\n  last_search_result = search_result = search_success;\n\n  window_get_state (window, &orig_state);\n\n  isearch_string_index = 0;\n  if (!isearch_string_size)\n    isearch_string = xmalloc (isearch_string_size = 50);\n\n  isearch_string[isearch_string_index] = '\\0';\n\n  isearch_is_active = 1;\n\n  /* Save starting position of search. */\n  push_isearch (window, isearch_string_index, dir, search_result, start_off);\n\n  while (isearch_is_active)\n    {\n      VFunction *func = NULL;\n      int quoted = 0;\n\n      /* Show the search string in the echo area. */\n      show_isearch_prompt (dir, (unsigned char *) isearch_string,\n                           search_result);\n\n      /* If a recent display was interrupted, then do the redisplay now if\n         it is convenient. */\n      if (!info_any_buffered_input_p () && display_was_interrupted_p)\n        {\n          display_update_display ();\n          display_cursor_at_point (active_window);\n        }\n\n      /* Read keys, looking in both keymaps for a recognized key sequence. */\n      {\n        Keymap info_kp, ea_kp;\n\n        info_kp = info_keymap;\n        ea_kp = echo_area_keymap;\n\n        key = get_input_key ();\n\n        while (1)\n          {\n            if (key >= 32 && key < 256)\n              break;\n\n            if (info_kp && info_kp[key].type == ISFUNC)\n              {\n                if (info_kp[key].value.function)\n                  func = info_kp[key].value.function->func;\n                if (func == &isearch_forward\n                    || func == &isearch_backward\n                    || func == &info_abort_key)\n                  {\n                    goto gotfunc;\n                  }\n                else\n                  {\n                    func = 0;\n                    info_kp = 0;\n                  }\n              }\n            else if (info_kp) /* ISKMAP */\n              info_kp = info_kp[key].value.keymap;\n\n            if (ea_kp && ea_kp[key].type == ISFUNC)\n              {\n                if (ea_kp[key].value.function)\n                  func = ea_kp[key].value.function->func;\n                if (func == &ea_abort\n                    || func == &ea_quoted_insert\n                    || func == &ea_rubout)\n                  {\n                    func = ea_kp[key].value.function->func;\n                    goto gotfunc;\n                  }\n                else\n                  {\n                    func = 0;\n                    ea_kp = 0;\n                  }\n              }\n            else if (ea_kp) /* ISKMAP */\n              ea_kp = ea_kp[key].value.keymap;\n\n          if (!info_kp && !ea_kp)\n            break;\n\n          key = get_input_key ();\n        }\n      }\ngotfunc:\n\n      if (func == &ea_quoted_insert)\n        {\n          /* User wants to insert a character. */\n          key = get_input_key ();\n          if (key < 0 || key >= 256)\n            continue; /* The user pressed a key like an arrow key. */\n          quoted = 1;\n        }\n\n      if (quoted || (!func && key >= 32 && key < 256))\n        {\n          push_isearch (window, isearch_string_index, dir,\n                        search_result, start_off);\n\n          if (isearch_string_index + 2 >= isearch_string_size)\n            isearch_string = xrealloc\n              (isearch_string, isearch_string_size += 100);\n\n          isearch_string[isearch_string_index++] = key;\n          isearch_string[isearch_string_index] = '\\0';\n\n          if (search_result != search_success && !use_regex)\n            continue;\n        }\n      else if (func == &ea_rubout)\n        {\n          /* User wants to delete one level of search? */\n          if (!isearch_states_index)\n            {\n              terminal_ring_bell ();\n              continue;\n            }\n          else\n            {\n              int end = isearch_string_index;\n              /* Remove a complete multi-byte character from the end of the\n                 search string. */\n              do\n                {\n                  pop_isearch (window, &isearch_string_index,\n                               &dir, &search_result, &start_off);\n                }\n              while (isearch_string_index > 0\n                && (long) mbrlen (isearch_string + isearch_string_index,\n                                  end - isearch_string_index, NULL) <= 0);\n               \n              isearch_string[isearch_string_index] = '\\0';\n\n              if (isearch_string_index == 0)\n                {\n                  /* Don't search for an empty string.  Clear the search. */\n                  free_matches (&window->matches);\n                  display_update_one_window (window);\n                  continue;\n                }\n              if (search_result != search_success)\n                {\n                  display_update_one_window (window);\n                  continue;\n                }\n            }\n        }\n      else if (func == &isearch_forward || func == &isearch_backward)\n        {\n          /* If this key invokes an incremental search, then this\n             means that we will either search again in the same\n             direction, search again in the reverse direction, or\n             insert the last search string that was accepted through\n             incremental searching. */\n          if (func == &isearch_forward && dir > 0\n              || func == &isearch_backward && dir < 0)\n            {\n              /* If the user has typed no characters, then insert the\n                 last successful search into the current search string. */\n              if (isearch_string_index == 0)\n                {\n                  /* Of course, there must be something to insert. */\n                  if (last_isearch_accepted)\n                    {\n                      if (strlen ((char *) last_isearch_accepted) + 1\n                          >= (unsigned int) isearch_string_size)\n                        isearch_string = (char *)\n                          xrealloc (isearch_string,\n                                    isearch_string_size += 10 +\n                                    strlen (last_isearch_accepted));\n                      strcpy (isearch_string, last_isearch_accepted);\n                      isearch_string_index = strlen (isearch_string);\n                    }\n                  else\n                    continue;\n                }\n              else\n                {\n                  /* Search again in the same direction.  This means start\n                     from a new place if the last search was successful. */\n                  if (search_result == search_success)\n                    {\n                      start_off = window->point;\n                      if (dir < 0)\n                        /* Position before match to avoid finding same match\n                           agin. */\n                        start_off--;\n                    }\n                }\n            }\n          else\n            {\n              /* Reverse the direction of the search. */\n              dir = -dir;\n            }\n        }\n      else if (func == &info_abort_key\n               && isearch_states_index && search_result != search_success)\n        {\n          /* If C-g pressed, and the search is failing, pop the search\n             stack back to the last unfailed search. */\n          terminal_ring_bell ();\n          while (isearch_states_index && search_result != search_success)\n            pop_isearch (window, &isearch_string_index, &dir,\n                         &search_result, &start_off);\n          isearch_string[isearch_string_index] = '\\0';\n          show_isearch_prompt (dir, (unsigned char *) isearch_string,\n                               search_result);\n          continue;\n        }\n      else if (func == &info_abort_key || func == &ea_abort || !func)\n        {\n          /* The character is not printable, or it has a function which is\n             non-null.  Exit the search, remembering the search string. */\n          if (isearch_string_index && func != &info_abort_key)\n            {\n              free (last_isearch_accepted);\n              last_isearch_accepted = xstrdup (isearch_string);\n            }\n\n          if (func == &info_abort_key)\n            {\n              if (isearch_states_index)\n                window_set_state (window, &orig_state);\n            }\n\n          if (!echo_area_is_active)\n            window_clear_echo_area ();\n\n          if (auto_footnotes_p)\n            info_get_or_remove_footnotes (active_window);\n\n          isearch_is_active = 0;\n          continue;\n        }\n\n      /* Show the new search string in the prompt. */\n      show_isearch_prompt (dir, (unsigned char *) isearch_string, \n                           search_result);\n\n      /* Make the search case-sensitive only if the search string includes\n         upper-case letters. */\n      case_sensitive = 0;\n      for (p = isearch_string; *p; p++)\n        if (isupper (*p))\n          {\n            case_sensitive = 1;\n            break;\n          }\n\n      last_search_result = search_result;\n\n      window_get_state (window, &mystate);\n      search_result = info_search_internal (isearch_string,\n                                            window, dir, case_sensitive,\n                                            &start_off);\n\n      /* If this search failed, and we didn't already have a failed search,\n         then ring the terminal bell. */\n      if (search_result != search_success\n          && last_search_result == search_success)\n        {\n          terminal_ring_bell ();\n        }\n      else if (search_result == search_success)\n        {\n          /* Make sure the match is visible, and update the display. */\n\n          if (!strcmp(window->node->fullpath, mystate.fullpath)\n              && !strcmp(window->node->nodename, mystate.nodename)\n              && mystate.pagetop != window->pagetop)\n            {\n              int newtop = window->pagetop;\n              window->pagetop = mystate.pagetop;\n              set_window_pagetop (window, newtop);\n            }\n          window_adjust_pagetop (window);\n\n          /* Call display_update_display to update the window and an automatic\n             footnotes window if present. */\n          display_update_display ();\n          display_cursor_at_point (window);\n        }\n    }\n\n  /* Free the memory used to remember each search state. */\n  free_isearch_states ();\n\n  /* Alter the window history so that we have added at most one node in the \n     incremental search, so that going back once with \"l\" goes to where we \n     started the incremental search if the match was in a different node. */\n  {\n    int i = window->hist_index - 1;\n    int j = starting_history_entry;\n\n    if (i > j)\n      {\n        if (!strcmp(window->hist[i]->node->nodename,\n                    window->hist[j]->node->nodename)\n            && !strcmp(window->hist[j]->node->fullpath,\n                       window->hist[i]->node->fullpath))\n          {\n            /* If we end up at the same node we started at, don't extend\n               the history at all. */\n            cleanup_history (window, j, i);\n          }\n        else\n          {\n            cleanup_history (window, j + 1, i);\n          }\n      }\n  }\n\n  /* Perhaps GC some file buffers. */\n  gc_file_buffers_and_nodes ();\n\n  /* After searching, leave the window in the correct state. */\n  if (!echo_area_is_active)\n    window_clear_echo_area ();\n}",
      "lines": 346,
      "depth": 25,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dispatch_error": {
      "start_point": [
        5345,
        0
      ],
      "end_point": [
        5362,
        1
      ],
      "content": "static void\ndispatch_error (int *keyseq)\n{\n  char *rep;\n\n  rep = pretty_keyseq (keyseq);\n\n  if (!echo_area_is_active)\n    info_error (_(\"Unknown command (%s)\"), rep);\n  else\n    {\n      char *temp = xmalloc (1 + strlen (rep) + strlen (_(\"\\\"%s\\\" is invalid\")));\n      sprintf (temp, _(\"'%s' is invalid\"), rep);\n      terminal_ring_bell ();\n      inform_in_echo_area (temp);\n      free (temp);\n    }\n}",
      "lines": 18,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "initialize_keyseq": {
      "start_point": [
        5371,
        0
      ],
      "end_point": [
        5376,
        1
      ],
      "content": "void\ninitialize_keyseq (void)\n{\n  info_keyseq_index = 0;\n  info_keyseq_displayed_p = 0;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "add_char_to_keyseq": {
      "start_point": [
        5379,
        0
      ],
      "end_point": [
        5388,
        1
      ],
      "content": "void\nadd_char_to_keyseq (int character)\n{\n  if (info_keyseq_index + 2 >= info_keyseq_size)\n    info_keyseq = xrealloc (info_keyseq,\n                            sizeof (int) * (info_keyseq_size += 10));\n\n  info_keyseq[info_keyseq_index++] = character;\n  info_keyseq[info_keyseq_index] = '\\0';\n}",
      "lines": 10,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "display_info_keyseq": {
      "start_point": [
        5393,
        0
      ],
      "end_point": [
        5413,
        1
      ],
      "content": "static void\ndisplay_info_keyseq (int expecting_future_input)\n{\n  char *rep;\n\n  if (!info_keyseq || info_keyseq_index == 0)\n    return;\n\n  rep = pretty_keyseq (info_keyseq);\n  if (expecting_future_input)\n    strcat (rep, \"-\");\n\n  if (echo_area_is_active)\n    inform_in_echo_area (rep);\n  else\n    {\n      window_message_in_echo_area (rep, NULL, NULL);\n      display_cursor_at_point (active_window);\n    }\n  info_keyseq_displayed_p = 1;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_another_input_key": {
      "start_point": [
        5418,
        0
      ],
      "end_point": [
        5451,
        1
      ],
      "content": "int\nget_another_input_key (void)\n{\n  int ready = !info_keyseq_displayed_p; /* ready if new and pending key */\n\n  /* If there isn't any input currently available, then wait a\n     moment looking for input.  If we don't get it fast enough,\n     prompt a little bit with the current key sequence. */\n  if (!info_keyseq_displayed_p)\n    {\n      ready = 1;\n      if (!info_any_buffered_input_p ())\n        {\n#if defined (FD_SET)\n          struct timeval timer;\n          fd_set readfds;\n\n          FD_ZERO (&readfds);\n          FD_SET (fileno (info_input_stream), &readfds);\n          timer.tv_sec = 1;\n          timer.tv_usec = 750;\n          ready = select (fileno(info_input_stream)+1, &readfds,\n\t\t\t  NULL, NULL, &timer);\n#else\n          ready = 0;\n#endif /* FD_SET */\n      }\n    }\n\n  if (!ready)\n    display_info_keyseq (1);\n\n  return get_input_key ();\n}",
      "lines": 34,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "read_key_sequence": {
      "start_point": [
        5478,
        0
      ],
      "end_point": [
        5671,
        1
      ],
      "content": "VFunction *\nread_key_sequence (Keymap map, int menu, int mouse,\n                   int insert, int *count)\n{\n  int key;\n  int reading_universal_argument = 0;\n\n  int numeric_arg = 1, numeric_arg_sign = 1, *which_explicit_arg;\n  VFunction *func;\n\n  /* Process the right numeric argument. */\n  if (!echo_area_is_active)\n    which_explicit_arg = &info_explicit_arg;\n  else\n    which_explicit_arg = &ea_explicit_arg;\n\n  *which_explicit_arg = 0;\n\n  initialize_keyseq ();\n\n  key = get_input_key ();\n  if (key == KEY_MOUSE)\n    {\n      if (mouse)\n        mouse_event_handler ();\n      return 0;\n    }\n\n  if (insert\n      && (key >= 040 && key < 0200\n          || ISO_Latin_p && key >= 0200 && key < 0400))\n    {\n      ea_insert (the_echo_area, 1, key);\n      return 0;\n    }\n\n  add_char_to_keyseq (key);\n\n  while (1)\n    {\n      int dash_typed = 0, digit_typed = 0;\n      func = 0;\n\n      if (display_was_interrupted_p && !info_any_buffered_input_p ())\n        display_update_display ();\n\n      if (active_window != the_echo_area)\n        display_cursor_at_point (active_window);\n\n      /* If reading a universal argument, both <digit> and M-<digit> help form \n         the argument.  Don't look up the pressed key in the key map. */\n      if (reading_universal_argument)\n        {\n          int k = key;\n          if (k >= KEYMAP_META_BASE)\n            k -= KEYMAP_META_BASE;\n          if (k == '-')\n            {\n              dash_typed = 1;\n            }\n          else if (isdigit (k))\n            {\n              digit_typed = 1;\n            }\n          else\n            /* Note: we may still read another C-u after this. */\n            reading_universal_argument = 0;\n        }\n\n      if (!dash_typed && !digit_typed && map[key].type == ISFUNC)\n        {\n          func = map[key].value.function ? map[key].value.function->func : 0;\n          if (!func)\n            {\n              dispatch_error (info_keyseq);\n              return 0;\n            }\n        }\n\n      if (dash_typed || digit_typed || func == &info_add_digit_to_numeric_arg)\n        {\n          int k = key;\n          if (k > KEYMAP_META_BASE)\n            k -= KEYMAP_META_BASE;\n          reading_universal_argument = 1;\n          if (dash_typed || k == '-')\n            {\n              if (!*which_explicit_arg)\n                {\n                  numeric_arg_sign = -1;\n                  numeric_arg = 1;\n                }\n\n            }\n          else if (digit_typed || isdigit (k))\n            {\n              if (*which_explicit_arg)\n                numeric_arg = numeric_arg * 10 + (k - '0');\n              else\n                numeric_arg = (k - '0');\n              *which_explicit_arg = 1;\n            }\n        }\n      else if (func == info_do_lowercase_version)\n        {\n          int lowerkey;\n\n          if (key >= KEYMAP_META_BASE)\n            {\n              lowerkey = key;\n              lowerkey -= KEYMAP_META_BASE;\n              lowerkey = tolower (lowerkey);\n              lowerkey += KEYMAP_META_BASE;\n            }\n          else\n            lowerkey = tolower (key);\n\n          if (lowerkey == key)\n            {\n              dispatch_error (info_keyseq);\n              return 0;\n            }\n          key = lowerkey;\n          continue;\n        }\n      else if (func == &info_universal_argument)\n        {\n          /* Multiply by 4. */\n          /* TODO: Maybe C-u should also terminate the universal argument \n             sequence, as in Emacs. (C-u 6 4 C-u 1 inserts 64 1's.) */\n          if (!*which_explicit_arg)\n            numeric_arg *= 4;\n          reading_universal_argument = 1;\n        }\n      else if (menu && func == &info_menu_digit)\n        {\n          /* key can either be digit, or M-digit for --vi-keys. */\n\n          int k = key;\n          if (k > KEYMAP_META_BASE)\n            k -= KEYMAP_META_BASE;\n          window_clear_echo_area ();\n          menu_digit (active_window, k);\n          return 0;\n        }\n      else if (insert\n               && (func == &ea_possible_completions || func == &ea_complete)\n               && !echo_area_completion_items)\n        {\n          ea_insert (the_echo_area, 1, key);\n          return 0;\n        }\n      else if (func)\n        {\n          /* Don't update the key sequence if we have finished reading a key \n             sequence in the echo area.  This means that a key sequence like \n             \"C-u 2 Left\" appears to take effect immediately, instead of there \n             being a delay while the message is displayed. */\n          if (!echo_area_is_active && info_keyseq_displayed_p)\n            display_info_keyseq (0);\n\n          if (count)\n            *count = numeric_arg * numeric_arg_sign;\n\n          /* *which_explicit_arg has not been set yet if only a sequence of \n             C-u's was typed (each of which has multiplied the argument by \n             four).  */\n          if (*count != 1 && !*which_explicit_arg)\n            *which_explicit_arg = 1;\n\n          return func;\n        }\n      else if (map[key].type == ISKMAP)\n        {\n          if (map[key].value.keymap != NULL)\n            map = map[key].value.keymap;\n          else\n            {\n              dispatch_error (info_keyseq);\n              return 0;\n            }\n\n          if (info_keyseq_displayed_p)\n            display_info_keyseq (1);\n        }\n\n      do\n        key = get_another_input_key ();\n      while (key == KEY_MOUSE);\n      add_char_to_keyseq (key);\n    }\n\n  return 0;\n}",
      "lines": 194,
      "depth": 19,
      "decorators": [
        "VFunction",
        "*\nread_key_sequence (Keymap map, int menu, int mouse,\n                   int insert, int *count)",
        "*"
      ]
    },
    "info_initialize_numeric_arg": {
      "start_point": [
        5686,
        0
      ],
      "end_point": [
        5697,
        1
      ],
      "content": "void\ninfo_initialize_numeric_arg (void)\n{\n  if (!echo_area_is_active)\n    {\n      info_explicit_arg = 0;\n    }\n  else\n    {\n      ea_explicit_arg = 0;\n    }\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "texinfo/texinfo-6.5/info/session.h": {},
  "texinfo/texinfo-6.5/info/signals.c": {
    "sigprocmask": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static void\nsigprocmask (int operation, int *newset, int *oldset)\n{\n  switch (operation)\n    {\n    case SIG_UNBLOCK:\n      sigsetmask (sigblock (0) & ~(*newset));\n      break;\n\n    case SIG_BLOCK:\n      *oldset = sigblock (*newset);\n      break;\n\n    case SIG_SETMASK:\n      sigsetmask (*newset);\n      break;\n\n    default:\n      abort ();\n    }\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mask_termsig": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static void\nmask_termsig (sigset_t *set)\n{\n# if defined (SIGTSTP)\n  sigaddset (set, SIGTSTP);\n  sigaddset (set, SIGTTOU);\n  sigaddset (set, SIGTTIN);\n# endif\n# if defined (SIGWINCH)\n  sigaddset (set, SIGWINCH);\n# endif\n#if defined (SIGQUIT)\n  sigaddset (set, SIGQUIT);\n#endif\n#if defined (SIGINT)\n  sigaddset (set, SIGINT);\n#endif\n#if defined (SIGTERM)\n  sigaddset (set, SIGTERM);\n#endif\n# if defined (SIGUSR1)\n  sigaddset (set, SIGUSR1);\n# endif\n}",
      "lines": 24,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_termsig": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static void\nset_termsig (int sig, signal_info *old)\n{\n  sigaction (sig, &info_signal_handler, old);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "restore_termsig": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "static void\nrestore_termsig (int sig, const signal_info *saved)\n{\n  sigaction (sig, saved, NULL);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "initialize_info_signal_handler": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "void\ninitialize_info_signal_handler (void)\n{\n#ifdef SA_NOCLDSTOP\n  /* (Based on info from Paul Eggert found in coreutils.)  Don't use\n     HAVE_SIGACTION to decide whether to use the sa_handler, sa_flags,\n     sa_mask members, as some systems (Solaris 7+) don't define them.  Use\n     SA_NOCLDSTOP instead; it's been part of POSIX.1 since day 1 (in 1988).  */\n  info_signal_handler.sa_handler = info_signal_proc;\n  info_signal_handler.sa_flags = 0;\n  mask_termsig (&info_signal_handler.sa_mask);\n#endif /* SA_NOCLDSTOP */\n\n#if defined (SIGTSTP)\n  set_termsig (SIGTSTP, &old_TSTP);\n  set_termsig (SIGTTOU, &old_TTOU);\n  set_termsig (SIGTTIN, &old_TTIN);\n#endif /* SIGTSTP */\n\n#if defined (SIGWINCH)\n  set_termsig (SIGWINCH, &old_WINCH);\n#endif\n\n#if defined (SIGQUIT)\n  set_termsig (SIGQUIT, &old_QUIT);\n#endif\n\n#if defined (SIGINT)\n  set_termsig (SIGINT, &old_INT);\n#endif\n\n#if defined (SIGTERM)\n  set_termsig (SIGTERM, &old_TERM);\n#endif\n\n#if defined (SIGUSR1)\n  /* Used by DJGPP to simulate SIGTSTP on Ctrl-Z.  */\n  set_termsig (SIGUSR1, &old_USR1);\n#endif\n}",
      "lines": 40,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "redisplay_after_signal": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "void\nredisplay_after_signal (void)\n{\n  terminal_clear_screen ();\n  display_clear_display (the_display);\n  if (auto_footnotes_p)\n    info_get_or_remove_footnotes (active_window);\n  window_mark_chain (windows, W_UpdateWindow);\n  display_update_display ();\n  display_cursor_at_point (active_window);\n  fflush (stdout);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "reset_info_window_sizes": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "void\nreset_info_window_sizes (void)\n{\n  terminal_get_screen_size ();\n  display_initialize_display (screenwidth, screenheight);\n  window_new_screen_size (screenwidth, screenheight);\n  redisplay_after_signal ();\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "signal_block_winch": {
      "start_point": [
        188,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "void\nsignal_block_winch (void)\n{\n#if defined (SIGWINCH)\n  if (sigwinch_block_count == 0)\n    BLOCK_SIGNAL (SIGWINCH);\n  sigwinch_block_count++;\n#endif\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "signal_unblock_winch": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "void\nsignal_unblock_winch (void)\n{\n#if defined (SIGWINCH)\n  sigwinch_block_count--;\n  if (sigwinch_block_count == 0)\n    UNBLOCK_SIGNAL (SIGWINCH);\n#endif\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "info_signal_proc": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        343,
        1
      ],
      "content": "static RETSIGTYPE\ninfo_signal_proc (int sig)\n{\n  signal_info *old_signal_handler = NULL;\n\n#if !defined (HAVE_SIGACTION)\n  /* best effort: first increment this counter and later block signals */\n  if (term_conf_busy)\n    return;\n  term_conf_busy++;\n#if defined (HAVE_SIGPROCMASK) || defined (HAVE_SIGSETMASK)\n    {\n      sigset_t nvar, ovar;\n      sigemptyset (&nvar);\n      mask_termsig (&nvar);\n      sigprocmask (SIG_BLOCK, &nvar, &ovar);\n    }\n#endif /* HAVE_SIGPROCMASK || HAVE_SIGSETMASK */\n#endif /* !HAVE_SIGACTION */\n  switch (sig)\n    {\n#if defined (SIGTSTP)\n    case SIGTSTP:\n    case SIGTTOU:\n    case SIGTTIN:\n#endif\n#if defined (SIGQUIT)\n    case SIGQUIT:\n#endif\n#if defined (SIGINT)\n    case SIGINT:\n#endif\n#if defined (SIGTERM)\n    case SIGTERM:\n#endif\n      {\n#if defined (SIGTSTP)\n        if (sig == SIGTSTP)\n          old_signal_handler = &old_TSTP;\n        if (sig == SIGTTOU)\n          old_signal_handler = &old_TTOU;\n        if (sig == SIGTTIN)\n          old_signal_handler = &old_TTIN;\n#endif /* SIGTSTP */\n#if defined (SIGQUIT)\n        if (sig == SIGQUIT)\n          old_signal_handler = &old_QUIT;\n#endif /* SIGQUIT */\n#if defined (SIGINT)\n        if (sig == SIGINT)\n          old_signal_handler = &old_INT;\n#endif /* SIGINT */\n#if defined (SIGTERM)\n        if (sig == SIGTERM)\n          old_signal_handler = &old_TERM;\n#endif /* SIGTERM */\n\n        /* For stop signals, restore the terminal IO, leave the cursor\n           at the bottom of the window, and stop us. */\n        terminal_goto_xy (0, screenheight - 1);\n        terminal_clear_to_eol ();\n        fflush (stdout);\n        terminal_unprep_terminal ();\n\trestore_termsig (sig, old_signal_handler);\n\tUNBLOCK_SIGNAL (sig);\n\tkill (getpid (), sig);\n\n        /* The program is returning now.  Restore our signal handler,\n           turn on terminal handling, redraw the screen, and place the\n           cursor where it belongs. */\n        terminal_prep_terminal ();\n\tset_termsig (sig, old_signal_handler);\n\t/* window size might be changed while sleeping */\n\treset_info_window_sizes ();\n      }\n      break;\n\n#if defined (SIGWINCH) || defined (SIGUSR1)\n#ifdef SIGWINCH\n    case SIGWINCH:\n#endif\n#ifdef SIGUSR1\n    case SIGUSR1:\n#endif\n      {\n\t/* Turn off terminal IO, tell our parent that the window has changed,\n\t   then reinitialize the terminal and rebuild our windows. */\n#ifdef SIGWINCH\n\tif (sig == SIGWINCH)\n\t  old_signal_handler = &old_WINCH;\n#endif\n#ifdef SIGUSR1\n\tif (sig == SIGUSR1)\n\t  old_signal_handler = &old_USR1;\n#endif\n\n        /* This seems risky: what if we receive a (real) signal before\n           the next line is reached? */\n#if 0\n\trestore_termsig (sig, old_signal_handler);\n\tkill (getpid (), sig);\n#endif\n\n\t/* After our old signal handler returns... */\n\tset_termsig (sig, old_signal_handler); /* needless? */\n\n        if (sigwinch_block_count != 0)\n          abort ();\n\n        /* Avoid any of the code unblocking the signal too early.  This\n           should set the variable to 1 because we shouldn't be here if\n           sigwinch_block_count > 0. */\n        sigwinch_block_count++;\n\n\treset_info_window_sizes ();\n\n        sigwinch_block_count--;\n        /* Don't unblock the signal until after we've finished. */\n\tUNBLOCK_SIGNAL (sig);\n      }\n      break;\n#endif /* SIGWINCH || SIGUSR1 */\n    }\n#if !defined (HAVE_SIGACTION)\n  /* at this time it is safer to perform unblock after decrement */\n  term_conf_busy--;\n#if defined (HAVE_SIGPROCMASK) || defined (HAVE_SIGSETMASK)\n    {\n      sigset_t nvar, ovar;\n      sigemptyset (&nvar);\n      mask_termsig (&nvar);\n      sigprocmask (SIG_UNBLOCK, &nvar, &ovar);\n    }\n#endif /* HAVE_SIGPROCMASK || HAVE_SIGSETMASK */\n#endif /* !HAVE_SIGACTION */\n}",
      "lines": 136,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "RETSIGTYPE"
      ]
    }
  },
  "texinfo/texinfo-6.5/info/signals.h": {},
  "texinfo/texinfo-6.5/info/tag.c": {
    "info_tag_free": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "static void\ninfo_tag_free (struct info_tag *tag)\n{\n  while (tag)\n    {\n      struct info_tag *next = tag->next;\n      free (tag->kw);\n      free (tag->val);\n      free (tag);\n      tag = next;\n    }\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "info_tag_find": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "static struct info_tag *\ninfo_tag_find (struct info_tag *tag, const char *kw)\n{\n  for (; tag; tag = tag->next)\n    if (strcmp (tag->kw, kw) == 0)\n      return tag;\n  return NULL;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "struct info_tag",
        "struct",
        "info_tag",
        "*\ninfo_tag_find (struct info_tag *tag, const char *kw)",
        "*"
      ]
    },
    "tag_found_keyword": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static struct info_tag *\ntag_found_keyword (struct text_buffer *tmpbuf_ptr, char **kw)\n{\n  struct info_tag *tag = xmalloc (sizeof (*tag));\n  tag->next = NULL;  /* have to update in caller */\n\n  text_buffer_add_char (tmpbuf_ptr, 0);\n  if (*kw != tmpbuf_ptr->base) { /* in case tmpbuf got realloc-ed */\n    *kw = tmpbuf_ptr->base;      /* ick */\n  }\n  tag->kw = xstrdup (*kw);\n  tag->val = xstrdup (*kw + strlen(*kw) + 1);\n  text_buffer_reset (tmpbuf_ptr);\n\n  return tag;\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "struct info_tag",
        "struct",
        "info_tag",
        "*\ntag_found_keyword (struct text_buffer *tmpbuf_ptr, char **kw)",
        "*"
      ]
    },
    "tag_image": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "static int\ntag_image (char *text, struct text_buffer *outbuf)\n{\n  mbi_iterator_t iter;\n  enum { state_kw, state_val, state_qstr, state_delim } state = state_kw;\n  struct text_buffer tmpbuf;\n  char *kw;\n  struct info_tag *tag_head = NULL, *tag;\n  int escaped = 0;\n  \n  text_buffer_init (&tmpbuf);\n  for (mbi_init (iter, text, strlen (text)); mbi_avail (iter);\n       mbi_advance (iter))\n    {\n      const char *cur_ptr;\n      size_t cur_len;\n      \n      if (mb_isspace (mbi_cur (iter)))\n\t{\n\t  if (state == state_val)\n\t    {\n              struct info_tag *new_kw = tag_found_keyword (&tmpbuf, &kw);\n              new_kw->next = tag_head;\n              tag_head = new_kw;\n              state = state_delim;\n              continue;\n\t    }\n\t  if (state == state_delim)\n\t    continue;\n\t}\n      else if (state == state_delim)\n\tstate = state_kw;\n      cur_len = mb_len (mbi_cur (iter));\n      cur_ptr = mbi_cur_ptr (iter);\n      \n      if (state == state_qstr && escaped)\n\t{\n\t  escaped = 0;\n\t}\n      else if (cur_len == 1)\n\t{\n\t  switch (*cur_ptr)\n\t    {\n\t    case '=':\n\t      if (state != state_kw)\n\t\tbreak;\n\t      text_buffer_add_char (&tmpbuf, 0);\n\t      kw = tmpbuf.base;\n\t      if (!mbi_avail (iter))\n\t\tbreak;\n\t      mbi_advance (iter);\n\t      state = state_val;\n\t      cur_len = mb_len (mbi_cur (iter));\n\t      cur_ptr = mbi_cur_ptr (iter);\n\t      if (!(cur_len == 1 && *cur_ptr == '\"'))\n\t\tbreak;\n\t      /* fall through */\n\n\t    case '\"':\n\t      if (state == state_val)\n\t\t{\n\t\t  state = state_qstr;\n\t\t  continue;\n\t\t}\n\t      if (state == state_qstr)\n\t\t{\n\t\t  struct info_tag *new_kw = tag_found_keyword (&tmpbuf, &kw);\n\t\t  new_kw->next = tag_head;\n\t\t  tag_head = new_kw;\n\t\t  state = state_delim;\n\t\t  continue;\n\t\t}\n\t      break;\n\n\t    case '\\\\':\n\t      if (state == state_qstr)\n\t\t{\n\t\t  escaped = 1;\n\t\t  continue;\n\t\t}\n\t    }\n\t}\n      text_buffer_add_string (&tmpbuf, cur_ptr, cur_len);\n    }\n\n  tag = info_tag_find (tag_head, \"text\");\n  if (!tag)\n    tag = info_tag_find (tag_head, \"alt\");\n\n  if (tag)\n    {\n      text_buffer_add_string (outbuf, tag->val, strlen (tag->val));\n    }\n  \n  text_buffer_free (&tmpbuf);\n  info_tag_free (tag_head);\n  return 0;\n}",
      "lines": 98,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "find_tag_handler": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        202,
        1
      ],
      "content": "static struct tag_handler *\nfind_tag_handler (char *tag, size_t taglen)\n{\n  struct tag_handler *tp;\n\n  for (tp = tagtab; tp->name; tp++)\n    if (taglen >= tp->len && strncmp (tp->name, tag, tp->len) == 0)\n      return tp;\n  return NULL;\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "struct tag_handler",
        "struct",
        "tag_handler",
        "*\nfind_tag_handler (char *tag, size_t taglen)",
        "*"
      ]
    },
    "tag_expand": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "int\ntag_expand (char **input, char *input_end,\n            struct text_buffer *outbuf, int *is_index)\n{\n  char *p = *input;\n  char *q;\n  size_t len;\n  struct tag_handler *tp;\n\n  if (p >= input_end - 3\n    || memcmp(p, \"\\0\\b[\", 3) != 0)       /* opening magic? */\n    return 0;\n\n  p += 3;\n  q = p + strlen (p);\n  if (q >= input_end - 3\n      || memcmp (q + 1, \"\\b]\", 2)) /* closing magic? */\n    return 0; /* Not a proper tag. */\n\n  /* Output is different for index nodes */\n  if (!strncmp (\"index\", p, strlen (\"index\")))\n    *is_index = 1;\n\n  len = strcspn (p, \" \\t\");       /* tag name */\n  tp = find_tag_handler (p, len);\n  if (tp && tp->handler)\n    {\n      while (p[len] == ' ' || p[len] == '\\t')\n        ++len;                      /* move past whitespace */\n  \n      tp->handler (p + len, outbuf);\n    }\n  *input = q + 3;\n  return 1;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/info/tag.h": {},
  "texinfo/texinfo-6.5/info/termdep.h": {},
  "texinfo/texinfo-6.5/info/terminal.c": {
    "output_character_function": {
      "start_point": [
        157,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "static int\noutput_character_function (int c)\n{\n  putc (c, stdout);\n  return c;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "terminal_begin_using_terminal": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "static void\nterminal_begin_using_terminal (void)\n{\n  RETSIGTYPE (*sigsave) (int signum);\n\n  /* Turn on mouse reporting.  This is \"normal tracking mode\" supported by\n     xterm.  The presence of the Km capability may not be a reliable way to\n     tell whether this mode exists, but sending the following sequence is\n     probably harmless if it doesn't.  */\n  if (mouse_protocol == MP_NORMAL_TRACKING\n      && term_Km && !strcmp (term_Km, \"\\033[M\"))\n    send_to_terminal (\"\\033[?1000h\");\n  else\n    term_Km = 0;\n\n  if (term_keypad_on)\n      send_to_terminal (term_keypad_on);\n  \n  if (!term_begin_use || !*term_begin_use)\n    return;\n\n#ifdef SIGWINCH\n  sigsave = signal (SIGWINCH, SIG_IGN); \n#endif\n\n  send_to_terminal (term_begin_use);\n  fflush (stdout);\n  if (STREQ (term_name, \"sun-cmd\"))\n    /* Without this fflush and sleep, running info in a shelltool or\n       cmdtool (TERM=sun-cmd) with scrollbars loses -- the scrollbars are\n       not restored properly.\n       From: strube@physik3.gwdg.de (Hans Werner Strube).  */\n    sleep (1);\n\n#ifdef SIGWINCH\n  signal (SIGWINCH, sigsave);\n#endif\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "terminal_end_using_terminal": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "static void\nterminal_end_using_terminal (void)\n{\n  RETSIGTYPE (*sigsave) (int signum);\n\n  /* Turn off mouse reporting (\"normal tracking mode\"). */\n  if (term_Km)\n    send_to_terminal (\"\\033[?1000l\");\n\n  if (term_keypad_off)\n      send_to_terminal (term_keypad_off);\n  \n  if (!term_end_use || !*term_end_use)\n    return;\n\n#ifdef SIGWINCH\n  sigsave = signal (SIGWINCH, SIG_IGN);\n#endif\n\n  send_to_terminal (term_end_use);\n  fflush (stdout);\n  if (STREQ (term_name, \"sun-cmd\"))\n    /* See comments at other sleep.  */\n    sleep (1);\n\n#ifdef SIGWINCH\n  signal (SIGWINCH, sigsave);\n#endif\n}",
      "lines": 29,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "terminal_goto_xy": {
      "start_point": [
        285,
        0
      ],
      "end_point": [
        295,
        1
      ],
      "content": "void\nterminal_goto_xy (int x, int y)\n{\n  if (terminal_goto_xy_hook)\n    (*terminal_goto_xy_hook) (x, y);\n  else\n    {\n      if (term_goto)\n        tputs (tgoto (term_goto, x, y), 1, output_character_function);\n    }\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "terminal_put_text": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        307,
        1
      ],
      "content": "void\nterminal_put_text (char *string)\n{\n  if (terminal_put_text_hook)\n    (*terminal_put_text_hook) (string);\n  else\n    {\n      printf (\"%s\", string);\n    }\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "terminal_write_chars": {
      "start_point": [
        310,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "void\nterminal_write_chars (char *string, int nchars)\n{\n  if (terminal_write_chars_hook)\n    (*terminal_write_chars_hook) (string, nchars);\n  else\n    {\n      if (nchars)\n        fwrite (string, 1, nchars, stdout);\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "terminal_clear_to_eol": {
      "start_point": [
        323,
        0
      ],
      "end_point": [
        332,
        1
      ],
      "content": "void\nterminal_clear_to_eol (void)\n{\n  if (terminal_clear_to_eol_hook)\n    (*terminal_clear_to_eol_hook) ();\n  else\n    {\n      send_to_terminal (term_clreol);\n    }\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "terminal_clear_screen": {
      "start_point": [
        335,
        0
      ],
      "end_point": [
        344,
        1
      ],
      "content": "void\nterminal_clear_screen (void)\n{\n  if (terminal_clear_screen_hook)\n    (*terminal_clear_screen_hook) ();\n  else\n    {\n      send_to_terminal (term_clrpag);\n    }\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "terminal_up_line": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        356,
        1
      ],
      "content": "void\nterminal_up_line (void)\n{\n  if (terminal_up_line_hook)\n    (*terminal_up_line_hook) ();\n  else\n    {\n      send_to_terminal (term_up);\n    }\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "terminal_down_line": {
      "start_point": [
        359,
        0
      ],
      "end_point": [
        368,
        1
      ],
      "content": "void\nterminal_down_line (void)\n{\n  if (terminal_down_line_hook)\n    (*terminal_down_line_hook) ();\n  else\n    {\n      send_to_terminal (term_dn);\n    }\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "terminal_begin_inverse": {
      "start_point": [
        371,
        0
      ],
      "end_point": [
        380,
        1
      ],
      "content": "void\nterminal_begin_inverse (void)\n{\n  if (terminal_begin_inverse_hook)\n    (*terminal_begin_inverse_hook) ();\n  else\n    {\n      send_to_terminal (term_invbeg);\n    }\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "terminal_end_inverse": {
      "start_point": [
        383,
        0
      ],
      "end_point": [
        392,
        1
      ],
      "content": "void\nterminal_end_inverse (void)\n{\n  if (terminal_end_inverse_hook)\n    (*terminal_end_inverse_hook) ();\n  else\n    {\n      send_to_terminal (term_invend);\n    }\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "terminal_begin_standout": {
      "start_point": [
        396,
        0
      ],
      "end_point": [
        405,
        1
      ],
      "content": "void\nterminal_begin_standout (void)\n{\n  if (terminal_begin_standout_hook)\n    (*terminal_begin_standout_hook) ();\n  else\n    {\n      send_to_terminal (term_so);\n    }\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "terminal_end_standout": {
      "start_point": [
        408,
        0
      ],
      "end_point": [
        417,
        1
      ],
      "content": "void\nterminal_end_standout (void)\n{\n  if (terminal_end_standout_hook)\n    (*terminal_end_standout_hook) ();\n  else\n    {\n      send_to_terminal (term_se);\n    }\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "terminal_begin_underline": {
      "start_point": [
        419,
        0
      ],
      "end_point": [
        428,
        1
      ],
      "content": "void\nterminal_begin_underline (void)\n{\n  if (terminal_begin_underline_hook)\n    (*terminal_begin_underline_hook) ();\n  else\n    {\n      send_to_terminal (term_us);\n    }\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "terminal_end_underline": {
      "start_point": [
        430,
        0
      ],
      "end_point": [
        439,
        1
      ],
      "content": "void\nterminal_end_underline (void)\n{\n  if (terminal_end_underline_hook)\n    (*terminal_end_underline_hook) ();\n  else\n    {\n      send_to_terminal (term_ue);\n    }\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "terminal_begin_bold": {
      "start_point": [
        441,
        0
      ],
      "end_point": [
        450,
        1
      ],
      "content": "void\nterminal_begin_bold (void)\n{\n  if (terminal_begin_bold_hook)\n    (*terminal_begin_bold_hook) ();\n  else\n    {\n      send_to_terminal (term_md);\n    }\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "terminal_begin_blink": {
      "start_point": [
        452,
        0
      ],
      "end_point": [
        461,
        1
      ],
      "content": "void\nterminal_begin_blink (void)\n{\n  if (terminal_begin_blink_hook)\n    (*terminal_begin_blink_hook) ();\n  else\n    {\n      send_to_terminal (term_mb);\n    }\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "terminal_end_all_modes": {
      "start_point": [
        463,
        0
      ],
      "end_point": [
        472,
        1
      ],
      "content": "void\nterminal_end_all_modes (void)\n{\n  if (terminal_end_all_modes_hook)\n    (*terminal_end_all_modes_hook) ();\n  else\n    {\n      send_to_terminal (term_me);\n    }\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "terminal_ring_bell": {
      "start_point": [
        476,
        0
      ],
      "end_point": [
        488,
        1
      ],
      "content": "void\nterminal_ring_bell (void)\n{\n  if (terminal_ring_bell_hook)\n    (*terminal_ring_bell_hook) ();\n  else\n    {\n      if (terminal_has_visible_bell_p && terminal_use_visible_bell_p)\n        send_to_terminal (visible_bell);\n      else\n        send_to_terminal (audible_bell);\n    }\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "terminal_delete_lines": {
      "start_point": [
        491,
        0
      ],
      "end_point": [
        511,
        1
      ],
      "content": "static void\nterminal_delete_lines (int start, int count)\n{\n  int lines;\n\n  /* Normalize arguments. */\n  if (start < 0)\n    start = 0;\n\n  lines = screenheight - start;\n  terminal_goto_xy (0, start);\n  if (term_DL)\n    tputs (tgoto (term_DL, 0, count), lines, output_character_function);\n  else\n    {\n      while (count--)\n        tputs (term_dl, lines, output_character_function);\n    }\n\n  fflush (stdout);\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "terminal_insert_lines": {
      "start_point": [
        514,
        0
      ],
      "end_point": [
        535,
        1
      ],
      "content": "static void\nterminal_insert_lines (int start, int count)\n{\n  int lines;\n\n  /* Normalize arguments. */\n  if (start < 0)\n    start = 0;\n\n  lines = screenheight - start;\n  terminal_goto_xy (0, start);\n\n  if (term_AL)\n    tputs (tgoto (term_AL, 0, count), lines, output_character_function);\n  else\n    {\n      while (count--)\n        tputs (term_al, lines, output_character_function);\n    }\n\n  fflush (stdout);\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "terminal_scroll_region": {
      "start_point": [
        537,
        0
      ],
      "end_point": [
        565,
        1
      ],
      "content": "void\nterminal_scroll_region (int start, int end, int amount)\n{\n  /* Any scrolling at all? */\n  if (amount == 0)\n    return;\n\n  if (terminal_scroll_terminal_hook)\n    {\n      (*terminal_scroll_terminal_hook) (start, end, amount);\n      return;\n    }\n\n  if (terminal_can_scroll_region)\n    {\n      /* Set scrolling region. */\n      tputs (tgoto (term_cs, end - 1, start), 0, output_character_function);\n\n      /* Scroll. */\n      if (amount > 0)\n        tputs (tgoto (term_SR, 0, amount), 0, output_character_function);\n      else\n        tputs (tgoto (term_SF, 0, -amount), 0, output_character_function);\n\n      /* Reset scrolling region. */\n      tputs (tgoto (term_cs, screenheight - 1, 0), 0, output_character_function);\n      return;\n    }\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "terminal_scroll_terminal": {
      "start_point": [
        571,
        0
      ],
      "end_point": [
        599,
        1
      ],
      "content": "void\nterminal_scroll_terminal (int start, int end, int amount)\n{\n  if (!terminal_can_scroll)\n    return;\n\n  /* Any scrolling at all? */\n  if (amount == 0)\n    return;\n\n  if (terminal_scroll_terminal_hook)\n    (*terminal_scroll_terminal_hook) (start, end, amount);\n  else if (amount > 0)\n    {\n      /* If we are scrolling down, delete AMOUNT lines at END.  Then insert\n         AMOUNT lines at START. */\n      terminal_delete_lines (end, amount);\n      terminal_insert_lines (start, amount);\n    }\n  else\n    {\n      /* If we are scrolling up, delete AMOUNT lines before START.  This\n         actually does the upwards scroll.  Then, insert AMOUNT lines\n         after the already scrolled region (i.e., END - AMOUNT). */\n      int abs_amount = -amount;\n      terminal_delete_lines (start - abs_amount, abs_amount);\n      terminal_insert_lines (end - abs_amount, abs_amount);\n    }\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "terminal_default_colour": {
      "start_point": [
        602,
        0
      ],
      "end_point": [
        609,
        1
      ],
      "content": "static void\nterminal_default_colour (void)\n{\n  if (terminal_default_colour_hook)\n    (*terminal_default_colour_hook) ();\n  else\n    tputs (term_op, 0, output_character_function);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "terminal_set_colour": {
      "start_point": [
        611,
        0
      ],
      "end_point": [
        618,
        1
      ],
      "content": "static void\nterminal_set_colour (int colour)\n{\n  if (terminal_set_colour_hook)\n    (*terminal_set_colour_hook) (colour);\n  else\n    tputs (tgoto (term_AF, 0, colour), 0, output_character_function);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "terminal_set_bgcolour": {
      "start_point": [
        620,
        0
      ],
      "end_point": [
        627,
        1
      ],
      "content": "static void\nterminal_set_bgcolour (int colour)\n{\n  if (terminal_set_bgcolour_hook)\n    (*terminal_set_bgcolour_hook) (colour);\n  else\n    tputs (tgoto (term_AB, 0, colour), 0, output_character_function);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "terminal_switch_rendition": {
      "start_point": [
        637,
        0
      ],
      "end_point": [
        700,
        1
      ],
      "content": "void\nterminal_switch_rendition (unsigned long new)\n{\n  unsigned long old = terminal_rendition;\n\n  if ((old & new & COMBINED_MODES) != (old & COMBINED_MODES))\n    {\n      /* Some modes we can't turn off by themselves, so if we need to turn\n         one of them off, turn back on all the ones that should be on \n         afterwards. */\n      terminal_end_all_modes ();\n      old = 0;\n    }\n  else if (!(new & COLOUR_MASK) && (old & COLOUR_MASK)\n           || !(new & BGCOLOUR_MASK) && (old & BGCOLOUR_MASK))\n    {\n      terminal_default_colour ();\n      old &= ~(COLOUR_MASK|BGCOLOUR_MASK);\n    }\n\n  if ((new & COLOUR_MASK) != (old & COLOUR_MASK))\n    {\n      if ((new & COLOUR_MASK) >= 8)\n        {\n          terminal_set_colour ((new & COLOUR_MASK) - 8);\n        }\n      /* Colour values from 1 to 7 don't do anything right now. */\n    }\n  if ((new & BGCOLOUR_MASK) != (old & BGCOLOUR_MASK))\n    {\n      /* Switch colour. */\n      if ((new & BGCOLOUR_MASK) >> 9 >= 8)\n        {\n          terminal_set_bgcolour (((new & BGCOLOUR_MASK) >> 9) - 8);\n        }\n      /* Colour values from 1 to 7 don't do anything right now. */\n    }\n\n  if ((new & UNDERLINE_MASK) != (old & UNDERLINE_MASK))\n    {\n      if ((new & UNDERLINE_MASK))\n        terminal_begin_underline ();\n      else\n        terminal_end_underline ();\n    }\n  if ((new & STANDOUT_MASK) != (old & STANDOUT_MASK))\n    {\n      if ((new & STANDOUT_MASK))\n        terminal_begin_standout ();\n      else\n        terminal_end_standout ();\n    }\n  if ((new & BOLD_MASK) != (old & BOLD_MASK))\n    {\n      if ((new & BOLD_MASK))\n        terminal_begin_bold ();\n    }\n  if ((new & BLINK_MASK) != (old & BLINK_MASK))\n    {\n      if ((new & BLINK_MASK))\n        terminal_begin_blink ();\n    }\n  terminal_rendition = new;\n}",
      "lines": 64,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "terminal_new_terminal": {
      "start_point": [
        705,
        0
      ],
      "end_point": [
        714,
        1
      ],
      "content": "void\nterminal_new_terminal (char *terminal_name)\n{\n  if (terminal_new_terminal_hook)\n    (*terminal_new_terminal_hook) (terminal_name);\n  else\n    {\n      terminal_initialize_terminal (terminal_name);\n    }\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "terminal_get_screen_size": {
      "start_point": [
        720,
        0
      ],
      "end_point": [
        768,
        1
      ],
      "content": "void\nterminal_get_screen_size (void)\n{\n  if (terminal_get_screen_size_hook)\n    (*terminal_get_screen_size_hook) ();\n  else\n    {\n      screenwidth = screenheight = 0;\n\n#if defined (TIOCGWINSZ)\n      {\n        struct winsize window_size;\n\n        if (ioctl (fileno (stdout), TIOCGWINSZ, &window_size) == 0)\n          {\n            screenwidth = (int) window_size.ws_col;\n            screenheight = (int) window_size.ws_row;\n          }\n      }\n#endif                          /* TIOCGWINSZ */\n\n      /* Environment variable COLUMNS overrides setting of \"co\". */\n      if (screenwidth <= 0)\n        {\n          if (env_columns)\n            screenwidth = atoi (env_columns);\n\n          if (screenwidth <= 0)\n            screenwidth = tgetnum (\"co\");\n        }\n\n      /* Environment variable LINES overrides setting of \"li\". */\n      if (screenheight <= 0)\n        {\n          if (env_lines)\n            screenheight = atoi (env_lines);\n\n          if (screenheight <= 0)\n            screenheight = tgetnum (\"li\");\n        }\n\n      /* If all else fails, default to 80x24 terminal. */\n      if (screenwidth <= 0)\n        screenwidth = 80;\n\n      if (screenheight <= 0)\n        screenheight = 24;\n    }\n}",
      "lines": 49,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "add_seq_to_byte_map": {
      "start_point": [
        774,
        0
      ],
      "end_point": [
        797,
        1
      ],
      "content": "static void\nadd_seq_to_byte_map (int key_id, char *seq)\n{\n  BYTEMAP_ENTRY *b = byte_seq_to_key;\n\n  /* Must consider bytes as unsigned because we use them as array indices. */\n  unsigned char *c = (unsigned char *) seq;\n  for (; *c; c++)\n    {\n      if (c[1] == '\\0') /* Last character. */\n        {\n          b[*c].type = BYTEMAP_KEY;\n          b[*c].key = key_id;\n        }\n      else\n        {\n          b[*c].type = BYTEMAP_MAP;\n          b[*c].key = 0;\n          if (!b[*c].next)\n            b[*c].next = xzalloc (256 * sizeof (BYTEMAP_ENTRY));\n          b = b[*c].next;\n        }\n    }\n}",
      "lines": 24,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "initialize_byte_map": {
      "start_point": [
        804,
        0
      ],
      "end_point": [
        891,
        1
      ],
      "content": "static void\ninitialize_byte_map (void)\n{\n  int i;\n\n  static struct special_keys {\n      int key_id;\n      char **byte_seq;\n  } keys[] = {\n      KEY_RIGHT_ARROW, &term_kr,\n      KEY_LEFT_ARROW, &term_kl,\n      KEY_UP_ARROW, &term_ku,\n      KEY_DOWN_ARROW, &term_kd,\n      KEY_PAGE_UP, &term_kP,\n      KEY_PAGE_DOWN, &term_kN,\n      KEY_HOME, &term_kh,\n      KEY_END, &term_ke,\n      KEY_DELETE, &term_kD,\n      KEY_INSERT, &term_ki,\n      KEY_BACK_TAB, &term_kB\n  };\n\n  /* Recognize arrow key sequences with both of the usual prefixes in case they \n     are missing in the termcap entry. */\n  static struct special_keys2 {\n      int key_id;\n      char *byte_seq;\n  } keys2[] = {\n      KEY_RIGHT_ARROW, \"\\033[C\",\n      KEY_RIGHT_ARROW, \"\\033OC\",\n      KEY_LEFT_ARROW, \"\\033[D\",\n      KEY_LEFT_ARROW, \"\\033OD\",\n      KEY_UP_ARROW, \"\\033[A\",\n      KEY_UP_ARROW, \"\\033OA\",\n      KEY_DOWN_ARROW, \"\\033[B\",\n      KEY_DOWN_ARROW, \"\\033OB\"\n  };\n\n  byte_seq_to_key = xmalloc (256 * sizeof (BYTEMAP_ENTRY));\n\n  /* Make each byte represent itself by default. */\n  for (i = 0; i < 128; i++)\n    {\n      byte_seq_to_key[i].type = BYTEMAP_KEY;\n      byte_seq_to_key[i].key = i;\n      byte_seq_to_key[i].next = 0;\n    }\n\n  /* Use 'ISO-Latin' variable to decide whether bytes with the 8th bit set \n     represent the Meta key being pressed.  Maybe we should have another \n     variable to enable 8-bit input.  If 'ISO-Latin' is set this allows input \n     of non-ASCII characters in the echo area. */\n  if (!ISO_Latin_p)\n    for (i = 128; i < 256; i++)\n      {\n        byte_seq_to_key[i].type = BYTEMAP_KEY;\n        byte_seq_to_key[i].key = (i - 128) + KEYMAP_META_BASE;\n        byte_seq_to_key[i].next = 0;\n      }\n\n  /* Hard-code octal 177 = delete.  Either 177 or the term_kD sequence will\n     result in a delete key being registered. */\n  byte_seq_to_key['\\177'].type = BYTEMAP_KEY;\n  byte_seq_to_key['\\177'].key = KEY_DELETE;\n  byte_seq_to_key['\\177'].next = 0;\n\n  /* For each special key, record its byte sequence. */\n  for (i = 0; i < sizeof (keys) / sizeof (*keys); i++)\n    {\n      if (!*keys[i].byte_seq)\n        continue; /* No byte sequence known for this key. */\n\n      add_seq_to_byte_map (keys[i].key_id, *keys[i].byte_seq);\n    }\n\n  /* Hard-coded byte sequences. */\n  for (i = 0; i < sizeof (keys2) / sizeof (*keys2); i++)\n    {\n      add_seq_to_byte_map (keys2[i].key_id, keys2[i].byte_seq);\n    }\n\n  if (term_Km)\n    add_seq_to_byte_map (KEY_MOUSE, term_Km);\n\n  /* Special case for ESC: Can introduce special key sequences, represent the\n     Meta key being pressed, or be a key on its own. */\n  byte_seq_to_key['\\033'].type = BYTEMAP_ESC;\n}",
      "lines": 88,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "terminal_initialize_terminal": {
      "start_point": [
        898,
        0
      ],
      "end_point": [
        1068,
        1
      ],
      "content": "void\nterminal_initialize_terminal (char *terminal_name)\n{\n  char *buffer;\n\n  terminal_is_dumb_p = 0;\n\n  if (terminal_initialize_terminal_hook)\n    {\n      (*terminal_initialize_terminal_hook) (terminal_name);\n      initialize_byte_map ();\n      return;\n    }\n\n  term_name = terminal_name ? terminal_name : getenv (\"TERM\");\n  if (!term_name)\n    term_name = \"dumb\";\n\n  env_lines = getenv (\"LINES\");\n  env_columns = getenv (\"COLUMNS\");\n  /* We save LINES and COLUMNS before the call to tgetent below, because\n     on some openSUSE systems, including openSUSE 12.3, the call to tgetent \n     changes the values returned by getenv for these. */\n\n  if (!term_string_buffer)\n    term_string_buffer = xmalloc (2048);\n\n  if (!term_buffer)\n    term_buffer = xmalloc (2048);\n\n  buffer = term_string_buffer;\n\n  term_clrpag = term_cr = term_clreol = NULL;\n\n  /* HP-UX 11.x returns 0 for OK --jeff.hull@state.co.us.  */\n  if (tgetent (term_buffer, term_name) < 0)\n    {\n      terminal_is_dumb_p = 1;\n      screenwidth = 80;\n      screenheight = 24;\n      term_cr = \"\\r\";\n      term_up = term_dn = audible_bell = visible_bell = NULL;\n      term_ku = term_kd = term_kl = term_kr = NULL;\n      term_kP = term_kN = NULL;\n      term_kh = term_ke = NULL;\n      term_kD = NULL;\n      return;\n    }\n\n  BC = tgetstr (\"pc\", &buffer);\n  PC = BC ? *BC : 0;\n\n#if defined (HAVE_TERMIOS_H)\n  {\n    struct termios ti;\n    if (tcgetattr (fileno(stdout), &ti) != -1)\n      ospeed = cfgetospeed (&ti);\n    else\n      ospeed = B9600;\n  }\n#else\n# if defined (TIOCGETP)\n  {\n    struct sgttyb sg;\n\n    if (ioctl (fileno (stdout), TIOCGETP, &sg) != -1)\n      ospeed = sg.sg_ospeed;\n    else\n      ospeed = B9600;\n  }\n# else\n#ifndef __MINGW32__\n  ospeed = B9600;\n#endif\n# endif /* !TIOCGETP */\n#endif\n\n  term_cr = tgetstr (\"cr\", &buffer);\n  term_clreol = tgetstr (\"ce\", &buffer);\n  term_clrpag = tgetstr (\"cl\", &buffer);\n  term_goto = tgetstr (\"cm\", &buffer);\n\n  /* Find out about this terminal's scrolling capability. */\n  term_AL = tgetstr (\"AL\", &buffer);\n  term_DL = tgetstr (\"DL\", &buffer);\n  term_al = tgetstr (\"al\", &buffer);\n  term_dl = tgetstr (\"dl\", &buffer);\n\n  term_cs = tgetstr (\"cs\", &buffer);\n  term_SF = tgetstr (\"SF\", &buffer);\n  term_SR = tgetstr (\"SR\", &buffer);\n\n  terminal_can_scroll = ((term_AL || term_al) && (term_DL || term_dl));\n  terminal_can_scroll_region = term_cs && term_SF && term_SR;\n\n  term_invbeg = tgetstr (\"mr\", &buffer);\n  if (term_invbeg)\n    term_invend = tgetstr (\"me\", &buffer);\n  else\n    term_invend = NULL;\n\n  term_so = tgetstr (\"so\", &buffer);\n  if (term_so)\n    term_se = tgetstr (\"se\", &buffer);\n  else\n    term_se = NULL;\n\n  term_us = tgetstr (\"us\", &buffer);\n  if (term_us)\n    term_ue = tgetstr (\"ue\", &buffer);\n  else\n    term_ue = NULL;\n\n  term_AF = tgetstr (\"AF\", &buffer);\n  if (term_AF)\n    term_AB = tgetstr (\"AB\", &buffer);\n  else\n    term_AB = NULL;\n\n  term_op = tgetstr (\"op\", &buffer);\n\n  term_md = tgetstr (\"md\", &buffer);\n  term_mb = tgetstr (\"mb\", &buffer);\n\n  term_me = tgetstr (\"me\", &buffer);\n  if (!term_me)\n    term_md = 0; /* Don't use modes if we can't turn them off. */\n\n  if (!term_cr)\n    term_cr =  \"\\r\";\n\n  terminal_get_screen_size ();\n\n  term_up = tgetstr (\"up\", &buffer);\n  term_dn = tgetstr (\"dn\", &buffer);\n  visible_bell = tgetstr (\"vb\", &buffer);\n  terminal_has_visible_bell_p = (visible_bell != NULL);\n  audible_bell = tgetstr (\"bl\", &buffer);\n  if (!audible_bell)\n    audible_bell = \"\\007\";\n  term_begin_use = tgetstr (\"ti\", &buffer);\n  term_end_use = tgetstr (\"te\", &buffer);\n\n  term_keypad_on = tgetstr (\"ks\", &buffer);\n  term_keypad_off = tgetstr (\"ke\", &buffer);\n\n  /* Attempt to find the arrow keys.  */\n  term_ku = tgetstr (\"ku\", &buffer);\n  term_kd = tgetstr (\"kd\", &buffer);\n  term_kr = tgetstr (\"kr\", &buffer);\n  term_kl = tgetstr (\"kl\", &buffer);\n\n  term_kP = tgetstr (\"kP\", &buffer);\n  term_kN = tgetstr (\"kN\", &buffer);\n\n  term_kh = tgetstr (\"kh\", &buffer);\n  term_ke = tgetstr (\"@7\", &buffer);\n  term_ki = tgetstr (\"kI\", &buffer);\n  term_kD = tgetstr (\"kD\", &buffer);\n\n  term_kB = tgetstr (\"kB\", &buffer);\n\n  /* String introducing a mouse event. */\n  term_Km = tgetstr (\"Km\", &buffer);\n\n  initialize_byte_map ();\n\n  /* If this terminal is not cursor addressable, then it is really dumb. */\n  if (!term_goto)\n    terminal_is_dumb_p = 1;\n}",
      "lines": 171,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "terminal_prep_terminal": {
      "start_point": [
        1109,
        0
      ],
      "end_point": [
        1251,
        1
      ],
      "content": "int\nterminal_prep_terminal (void)\n{\n  int tty;\n\n  if (terminal_is_dumb_p)\n    return 0;\n\n  if (terminal_prep_terminal_hook)\n    {\n      (*terminal_prep_terminal_hook) ();\n      return 1;\n    }\n\n  terminal_begin_using_terminal ();\n\n  tty = fileno (stdin);\n\n#if defined (HAVE_TERMIOS_H)\n  tcgetattr (tty, &original_termios);\n  tcgetattr (tty, &ttybuff);\n#else\n#  if defined (HAVE_TERMIO_H)\n  ioctl (tty, TCGETA, &original_termio);\n  ioctl (tty, TCGETA, &ttybuff);\n#  endif\n#endif\n\n#if defined (HAVE_TERMIOS_H) || defined (HAVE_TERMIO_H)\n  ttybuff.c_iflag &= (~ISTRIP & ~INLCR & ~IGNCR & ~ICRNL & ~IXON);\n/* These output flags are not part of POSIX, so only use them if they\n   are defined.  */\n#ifdef ONLCR\n  ttybuff.c_oflag &= ~ONLCR ;\n#endif\n#ifdef OCRNL\n  ttybuff.c_oflag &= ~OCRNL;\n#endif\n  ttybuff.c_lflag &= (~ICANON & ~ECHO);\n\n  ttybuff.c_cc[VMIN] = 1;\n  ttybuff.c_cc[VTIME] = 0;\n\n  if (ttybuff.c_cc[VINTR] == '\\177')\n    ttybuff.c_cc[VINTR] = -1;\n\n  if (ttybuff.c_cc[VQUIT] == '\\177')\n    ttybuff.c_cc[VQUIT] = -1;\n\n#ifdef VLNEXT\n  if (ttybuff.c_cc[VLNEXT] == '\\026')\n    ttybuff.c_cc[VLNEXT] = -1;\n#endif /* VLNEXT */\n#endif /* TERMIOS or TERMIO */\n\n/* cf. emacs/src/sysdep.c for being sure output is on. */\n#if defined (HAVE_TERMIOS_H)\n  /* linux kernel 2.2.x needs a TCOFF followed by a TCOON to turn output\n     back on if the user presses ^S at the very beginning; just a TCOON\n     doesn't work.  --Kevin Ryde <user42@zip.com.au>, 16jun2000.  */\n  tcsetattr (tty, TCSANOW, &ttybuff);\n#  ifdef TCOON\n  tcflow (tty, TCOOFF);\n  tcflow (tty, TCOON);\n#  endif\n#else\n#  if defined (HAVE_TERMIO_H)\n  ioctl (tty, TCSETA, &ttybuff);\n#    ifdef TCXONC\n  ioctl (tty, TCXONC, 1);\n#    endif\n#  endif\n#endif\n\n#if !defined (HAVE_TERMIOS_H) && !defined (HAVE_TERMIO_H) && !defined(__MINGW32__)\n  ioctl (tty, TIOCGETP, &ttybuff);\n\n  if (!original_tty_flags)\n    original_tty_flags = ttybuff.sg_flags;\n\n  /* Make this terminal pass 8 bits around while we are using it. */\n#  if defined (PASS8)\n  ttybuff.sg_flags |= PASS8;\n#  endif /* PASS8 */\n\n#  if defined (TIOCLGET) && defined (LPASS8)\n  {\n    int flags;\n    ioctl (tty, TIOCLGET, &flags);\n    original_lmode = flags;\n    flags |= LPASS8;\n    ioctl (tty, TIOCLSET, &flags);\n  }\n#  endif /* TIOCLGET && LPASS8 */\n\n#  if defined (TIOCGETC)\n  {\n    struct tchars temp;\n\n    ioctl (tty, TIOCGETC, &original_tchars);\n    temp = original_tchars;\n\n    /* C-s and C-q. */\n    temp.t_startc = temp.t_stopc = -1;\n\n    /* Often set to C-d. */\n    temp.t_eofc = -1;\n\n    /* If the a quit or interrupt character conflicts with one of our\n       commands, then make it go away. */\n    if (temp.t_intrc == '\\177')\n      temp.t_intrc = -1;\n\n    if (temp.t_quitc == '\\177')\n      temp.t_quitc = -1;\n\n    ioctl (tty, TIOCSETC, &temp);\n  }\n#  endif /* TIOCGETC */\n\n#  if defined (TIOCGLTC)\n  {\n    struct ltchars temp;\n\n    ioctl (tty, TIOCGLTC, &original_ltchars);\n    temp = original_ltchars;\n\n    /* Make the interrupt keys go away.  Just enough to make people happy. */\n    temp.t_lnextc = -1;         /* C-v. */\n    temp.t_dsuspc = -1;         /* C-y. */\n    temp.t_flushc = -1;         /* C-o. */\n    ioctl (tty, TIOCSLTC, &temp);\n  }\n#  endif /* TIOCGLTC */\n\n# ifndef __MINGW32__\n  ttybuff.sg_flags &= ~ECHO;\n  ttybuff.sg_flags |= CBREAK;\n  ioctl (tty, TIOCSETN, &ttybuff);\n# endif\n#endif /* !HAVE_TERMIOS_H && !HAVE_TERMIO_H */\n  return 1;\n}",
      "lines": 143,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "terminal_unprep_terminal": {
      "start_point": [
        1255,
        0
      ],
      "end_point": [
        1295,
        1
      ],
      "content": "void\nterminal_unprep_terminal (void)\n{\n  int tty;\n\n  if (terminal_unprep_terminal_hook)\n    {\n      (*terminal_unprep_terminal_hook) ();\n      return;\n    }\n\n  tty = fileno (stdin);\n\n#if defined (HAVE_TERMIOS_H)\n  tcsetattr (tty, TCSANOW, &original_termios);\n#else\n#  if defined (HAVE_TERMIO_H)\n  ioctl (tty, TCSETA, &original_termio);\n#  else /* !HAVE_TERMIO_H */\n#   ifndef __MINGW32__\n  ioctl (tty, TIOCGETP, &ttybuff);\n  ttybuff.sg_flags = original_tty_flags;\n  ioctl (tty, TIOCSETN, &ttybuff);\n#   endif\n\n#  if defined (TIOCGETC)\n  ioctl (tty, TIOCSETC, &original_tchars);\n#  endif /* TIOCGETC */\n\n#  if defined (TIOCGLTC)\n  ioctl (tty, TIOCSLTC, &original_ltchars);\n#  endif /* TIOCGLTC */\n\n#  if defined (TIOCLGET) && defined (LPASS8)\n  ioctl (tty, TIOCLSET, &original_lmode);\n#  endif /* TIOCLGET && LPASS8 */\n\n#  endif /* !HAVE_TERMIO_H */\n#endif /* !HAVE_TERMIOS_H */\n  terminal_end_using_terminal ();\n}",
      "lines": 41,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "texinfo/texinfo-6.5/info/terminal.h": {},
  "texinfo/texinfo-6.5/info/tilde.c": {
    "tilde_expand_word": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "char *\ntilde_expand_word (const char *filename)\n{\n  char *dirname = filename ? xstrdup (filename) : NULL;\n\n  if (dirname && *dirname == '~')\n    {\n      char *temp_name;\n      if (!dirname[1] || IS_SLASH (dirname[1]))\n        {\n          /* Prepend $HOME to the rest of the string. */\n          char *temp_home = getenv (\"HOME\");\n\n          /* If there is no HOME variable, look up the directory in\n             the password database. */\n          if (!temp_home)\n            {\n#ifndef __MINGW32__\n              struct passwd *entry;\n\n              entry = (struct passwd *) getpwuid (getuid ());\n              if (entry)\n                temp_home = entry->pw_dir;\n#else\n\t      temp_home = \".\";\n#endif\n            }\n\n          temp_name = xmalloc (1 + strlen (&dirname[1])\n                               + (temp_home ? strlen (temp_home) : 0));\n          if (temp_home)\n            strcpy (temp_name, temp_home);\n          else\n            temp_name[0] = 0;\n          strcat (temp_name, &dirname[1]);\n          free (dirname);\n          dirname = xstrdup (temp_name);\n          free (temp_name);\n        }\n      else\n        {\n#ifndef __MINGW32__\n          struct passwd *user_entry;\n#endif\n          char *username = xmalloc (257);\n          int i, c;\n\n          for (i = 1; (c = dirname[i]); i++)\n            {\n              if (IS_SLASH (c))\n                break;\n              else\n                username[i - 1] = c;\n            }\n          username[i - 1] = 0;\n\n#ifndef __MINGW32__\n          user_entry = (struct passwd *) getpwnam (username);\n          if (user_entry)\n            {\n              temp_name = xmalloc (1 + strlen (user_entry->pw_dir)\n                                   + strlen (&dirname[i])); \n              strcpy (temp_name, user_entry->pw_dir);\n              strcat (temp_name, &dirname[i]);\n\n              free (dirname);\n              dirname = xstrdup (temp_name);\n              free (temp_name);\n            }\n\n          endpwent ();\n          free (username);\n#else\n\t  free (dirname);\n\t  dirname = xstrdup (temp_name);\n\t  free (temp_name);\n#endif\n        }\n    }\n  return dirname;\n}",
      "lines": 81,
      "depth": 19,
      "decorators": [
        "char",
        "*\ntilde_expand_word (const char *filename)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/info/tilde.h": {},
  "texinfo/texinfo-6.5/info/variables.c": {
    "rendition_to_string": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "static char *\nrendition_to_string (RENDITION *rendition)\n{\n  static char string[8 /* nocolour */ + 1 /* comma */\n                     + 10 /* nobgcolour */ + 1\n                     + 11 /* nounderline */ + 1\n                     + 10 /* nostandout */ + 1\n                     + 7 /* regular */ + 1\n                     + 7 /* noblink */ + 1];\n  unsigned long style;\n  static const char* fg[] = { \"black\", \"red\", \"green\", \"yellow\", \"blue\",\n      \"magenta\", \"cyan\", \"white\" };\n  static const char* bg[] = { \"bgblack\", \"bgred\", \"bggreen\", \"bgyellow\",\n      \"bgblue\", \"bgmagenta\", \"bgcyan\", \"bgwhite\" };\n\n  *string = '\\0';\n\n  if (rendition->mask & BLINK_MASK)\n    strcat (string, rendition->value & BLINK_MASK ? \"blink\" : \"noblink\");\n  if (rendition->mask & BOLD_MASK)\n    {\n      if (*string != '\\0')\n        strcat (string, \",\");\n      strcat (string, rendition->value & BOLD_MASK ? \"bold\" : \"nobold\");\n    }\n  if (rendition->mask & STANDOUT_MASK)\n    {\n      if (*string != '\\0')\n        strcat (string, \",\");\n      strcat (string, rendition->value & STANDOUT_MASK ? \"standout\" : \"nostandout\");\n    }\n  if (rendition->mask & UNDERLINE_MASK)\n    {\n      if (*string != '\\0')\n        strcat (string, \",\");\n      strcat (string, rendition->value & UNDERLINE_MASK ? \"underline\" : \"nounderline\");\n    }\n  if (rendition->mask & COLOUR_MASK)\n    {\n      if (*string != '\\0')\n        strcat (string, \",\");\n      style = rendition->value & COLOUR_MASK;\n      strcat (string, style >= 8 ? fg[style - 8] : \"nocolour\");\n    }\n  if (rendition->mask & BGCOLOUR_MASK)\n    {\n      if (*string != '\\0')\n        strcat (string, \",\");\n      style = (rendition->value & BGCOLOUR_MASK) >> 9;\n      strcat (string, style >= 8 ? bg[style - 8] : \"nobgcolour\");\n    }\n\n  return string;\n}",
      "lines": 54,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nrendition_to_string (RENDITION *rendition)",
        "*"
      ]
    },
    "variable_by_name": {
      "start_point": [
        339,
        0
      ],
      "end_point": [
        353,
        1
      ],
      "content": "VARIABLE_ALIST *\nvariable_by_name (char *name)\n{\n  int i;\n\n  /* Find the variable in our list of variables. */\n  for (i = 0; info_variables[i].name; i++)\n    if (strcmp (info_variables[i].name, name) == 0)\n      break;\n\n  if (!info_variables[i].name)\n    return NULL;\n  else\n    return &info_variables[i];\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "VARIABLE_ALIST",
        "*\nvariable_by_name (char *name)",
        "*"
      ]
    },
    "read_variable_name": {
      "start_point": [
        358,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "static VARIABLE_ALIST *\nread_variable_name (char *prompt, WINDOW *window)\n{\n  char *line;\n  REFERENCE **variables;\n\n  /* Get the completion array of variable names. */\n  variables = make_variable_completions_array ();\n\n  /* Ask the completer to read a variable for us. */\n  line = info_read_completing_in_echo_area (prompt, variables);\n\n  info_free_references (variables);\n\n  /* User aborted? */\n  if (!line)\n    {\n      info_abort_key (active_window, 0);\n      return NULL;\n    }\n\n  /* User accepted \"default\"?  (There is none.) */\n  if (!*line)\n    {\n      free (line);\n      return NULL;\n    }\n\n  return variable_by_name (line);\n}",
      "lines": 30,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "VARIABLE_ALIST",
        "*\nread_variable_name (char *prompt, WINDOW *window)",
        "*"
      ]
    },
    "make_variable_completions_array": {
      "start_point": [
        391,
        0
      ],
      "end_point": [
        411,
        1
      ],
      "content": "REFERENCE **\nmake_variable_completions_array (void)\n{\n  register int i;\n  REFERENCE **array = NULL;\n  size_t array_index = 0, array_slots = 0;\n\n  for (i = 0; info_variables[i].name; i++)\n    {\n      REFERENCE *entry;\n\n      entry = xmalloc (sizeof (REFERENCE));\n      entry->label = xstrdup (info_variables[i].name);\n      entry->nodename = NULL;\n      entry->filename = NULL;\n\n      add_pointer_to_array (entry, array_index, array, array_slots, 200);\n    }\n\n  return array;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "REFERENCE",
        "**\nmake_variable_completions_array (void)",
        "*",
        "*\nmake_variable_completions_array (void)",
        "*"
      ]
    },
    "set_variable_to_value": {
      "start_point": [
        416,
        0
      ],
      "end_point": [
        534,
        1
      ],
      "content": "int\nset_variable_to_value (VARIABLE_ALIST *var, char *value, int where)\n{\n  /* If variable was set elsewhere with a higher priority, don't do\n     anything, but don't indicate an error. */\n  if (var->where_set > where)\n    return 1;\n\n  if (var->choices)\n    {\n      register int j;\n\n      /* \"highlight-searches=On\" is equivalent to\n         \"match-rendition=standout\". */\n      if (var->value == &highlight_searches)\n        {\n          if (strcmp (on_off_choices[0], value) == 0)\n            {\n              match_rendition.mask = 0;\n              match_rendition.value = 0;\n            }\n          else\n            {\n              match_rendition.mask = STANDOUT_MASK;\n              match_rendition.value = STANDOUT_MASK;\n            }\n        }\n      else if (var->choices != (char **) &rendition_choices)\n        {\n          /* Find the choice in our list of choices. */\n          for (j = 0; var->choices[j]; j++)\n            if (strcmp (var->choices[j], value) == 0)\n              {\n                *(int *)var->value = j;\n                var->where_set = where;\n                return 1;\n              }\n        }\n      else\n        {\n          static struct {\n              unsigned long mask;\n              unsigned long value;\n              char *name;\n          } styles[] = {\n              COLOUR_MASK, COLOUR_BLACK,   \"black\",\n              COLOUR_MASK, COLOUR_RED,     \"red\",\n              COLOUR_MASK, COLOUR_GREEN,   \"green\",\n              COLOUR_MASK, COLOUR_YELLOW,  \"yellow\",\n              COLOUR_MASK, COLOUR_BLUE,    \"blue\",\n              COLOUR_MASK, COLOUR_MAGENTA, \"magenta\",\n              COLOUR_MASK, COLOUR_CYAN,    \"cyan\",\n              COLOUR_MASK, COLOUR_WHITE,   \"white\",\n              COLOUR_MASK, 0,           \"nocolour\",\n              COLOUR_MASK, 0,           \"nocolor\",\n              BGCOLOUR_MASK, BGCOLOUR_BLACK,   \"bgblack\",\n              BGCOLOUR_MASK, BGCOLOUR_RED,     \"bgred\",\n              BGCOLOUR_MASK, BGCOLOUR_GREEN,   \"bggreen\",\n              BGCOLOUR_MASK, BGCOLOUR_YELLOW,  \"bgyellow\",\n              BGCOLOUR_MASK, BGCOLOUR_BLUE,    \"bgblue\",\n              BGCOLOUR_MASK, BGCOLOUR_MAGENTA, \"bgmagenta\",\n              BGCOLOUR_MASK, BGCOLOUR_CYAN,    \"bgcyan\",\n              BGCOLOUR_MASK, BGCOLOUR_WHITE,   \"bgwhite\",\n              BGCOLOUR_MASK, 0,           \"nobgcolour\",\n              BGCOLOUR_MASK, 0,           \"nobgcolor\",\n              UNDERLINE_MASK, UNDERLINE_MASK, \"underline\",\n              UNDERLINE_MASK, 0,              \"nounderline\",\n              STANDOUT_MASK, STANDOUT_MASK, \"standout\",\n              STANDOUT_MASK, 0,             \"nostandout\",\n              BOLD_MASK, BOLD_MASK,         \"bold\",\n              BOLD_MASK, 0,                 \"regular\",\n              BOLD_MASK, 0,                 \"nobold\",\n              BLINK_MASK, BLINK_MASK,       \"blink\",\n              BLINK_MASK, 0,                \"noblink\",\n          };\n          int i;\n          char *component;\n          unsigned long rendition_mask = 0;\n          unsigned long rendition_value = 0;\n\n          component = strtok (value, \",\");\n          while (component)\n            {\n              for (i = 0; (styles[i].name); i++)\n                {\n                  if (!strcmp (styles[i].name, component))\n                    break;\n                }\n              if (styles[i].name)\n                {\n                  rendition_mask |= styles[i].mask;\n                  rendition_value &= ~styles[i].mask;\n                  rendition_value |= styles[i].value;\n                }\n              /* If not found, silently ignore, in case more options are\n                 added in the future. */\n\n              component = strtok (0, \",\");\n            }\n\n          /* Now all the specified styles are recorded in rendition_value. */\n          ((RENDITION *)var->value)->mask = rendition_mask;\n          ((RENDITION *)var->value)->value = rendition_value;\n        }\n      return 1;\n    }\n  else\n    {\n      char *p;\n      long n = strtol (value, &p, 10);\n      if (*p == 0 && INT_MIN <= n && n <= INT_MAX)\n\t{\n          *(int *)var->value = n;\n\t  return 1;\n\t}\n    }\n\n  return 0;\n}",
      "lines": 119,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/info/variables.h": {},
  "texinfo/texinfo-6.5/info/window.c": {
    "window_initialize_windows": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "void\nwindow_initialize_windows (int width, int height)\n{\n  the_screen = xzalloc (sizeof (WINDOW));\n  the_echo_area = xzalloc (sizeof (WINDOW));\n  windows = xzalloc (sizeof (WINDOW));\n  active_window = windows;\n\n  /* The active and echo_area windows are visible.\n     The echo_area is permanent.\n     The screen is permanent. */\n  active_window->flags = W_WindowVisible;\n  the_echo_area->flags = W_WindowIsPerm | W_InhibitMode | W_WindowVisible;\n  the_screen->flags    = W_WindowIsPerm;\n\n  /* The height of the echo area never changes.  It is statically set right\n     here, and it must be at least 1 line for display.  The size of the\n     initial window cannot be the same size as the screen, since the screen\n     includes the echo area.  So, we make the height of the initial window\n     equal to the screen's displayable region minus the height of the echo\n     area. */\n  the_echo_area->height = ECHO_AREA_HEIGHT;\n  active_window->height = the_screen->height - 1 - the_echo_area->height;\n  window_new_screen_size (width, height);\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "window_new_screen_size": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "void\nwindow_new_screen_size (int width, int height)\n{\n  register WINDOW *win, *first_win;\n  int delta_height, delta_each, delta_leftover;\n  int numwins;\n\n  /* If no change, do nothing. */\n  if (width == the_screen->width && height == the_screen->height)\n    return;\n\n  /* The screen has changed height and width. */\n  delta_height = height - the_screen->height;\n  the_screen->height = height;\n  the_screen->width = width;\n\n  /* Set the start of the echo area. */\n  the_echo_area->first_row = height - the_echo_area->height;\n  the_echo_area->width = width;\n\n  /* Count number of windows. */\n  numwins = 0;\n  for (win = windows; win; win = win->next)\n    numwins++;\n\n  if (numwins == 0)\n    return; /* There is nothing to do. */\n\n  /* Divide the change in height among the available windows. */\n  delta_each = delta_height / numwins;\n  delta_leftover = delta_height - (delta_each * numwins);\n\n  /* See if some windows will need to be deleted.  This is the case if\n     the screen is getting smaller, and the available space divided by\n     the number of windows is less than WINDOW_MIN_SIZE.  In that case,\n     delete some windows and try again until there is either enough\n     space to divy up among the windows, or until there is only one\n     window left. */\n  while (height - 1 <= WINDOW_MIN_SIZE * numwins)\n    {\n      /* If only one window left, give up. */\n      if (!windows->next)\n        {\n          /* Keep track of the height so that when the screen gets bigger\n             again, it can be resized properly.  The -2 is for the window\n             information bar and the echo area. */\n          windows->height = height - 2;\n          windows->width = width;\n          free (windows->modeline);\n          windows->modeline = xmalloc (1 + width);\n          return;\n        }\n\n      /* If we have some temporary windows, delete one of them. */\n      for (win = windows; win; win = win->next)\n        if (win->flags & W_TempWindow)\n          break;\n\n      /* Otherwise, delete the first window, and try again. */\n      if (!win)\n        win = windows;\n\n      forget_window_and_nodes (win);\n      window_delete_window (win);\n      numwins--;\n    }\n\n  /* Alternate which window we start resizing at, to resize all\n     windows evenly. */\n    {\n      int first_win_num = the_screen->height % numwins;\n      int i;\n      first_win = windows;\n      for (i = 0; i < first_win_num; i++)\n        first_win = first_win->next;\n    }\n\n  /* Change the height of each window in the chain by delta_each.  Change\n     the height of the last window in the chain by delta_each and by the\n     leftover amount of change.  Change the width of each window to be\n     WIDTH. */\n  win = first_win;\n  do\n    {\n      if ((win->width != width) && ((win->flags & W_InhibitMode) == 0))\n        {\n          win->width = width;\n          free (win->modeline);\n          win->modeline = xmalloc (1 + width);\n        }\n\n      /* Don't resize a window to be smaller than one line. */\n      if (win->height + delta_each >= 1)\n        win->height += delta_each;\n      else\n        delta_leftover += delta_each;\n\n      /* Try to use up the extra space. */\n      if (delta_leftover != 0 && win->height + delta_leftover >= 1)\n        {\n          win->height += delta_leftover;\n          delta_leftover = 0;\n        }\n      /* Go to next window, wrapping round to the start. */\n      win = win->next;\n      if (!win)\n        win = windows;\n    }\n  while (win != first_win);\n\n  for (win = windows; win; win = win->next)\n    {\n      /* If this is not the first window in the chain, set the\n         first row of it by adding one to the location of the\n         previous window's modeline. */\n      if (win->prev)\n        win->first_row = (win->prev->first_row + win->prev->height) + 1;\n\n      if (win->node)\n        {\n          free (win->line_starts);\n          free (win->log_line_no);\n          calculate_line_starts (win);\n        }\n\n      win->flags |= W_UpdateWindow;\n    }\n\n  /* If the screen got smaller, check over the windows just shrunk to\n     keep them within bounds.  Some of the windows may have gotten smaller\n     than WINDOW_MIN_HEIGHT in which case some of the other windows are\n     larger than the available display space in the screen.  Because of our\n     intial test above, we know that there is enough space for all of the\n     windows. */\n  if ((delta_each < 0) && ((windows->height != 0) && windows->next))\n    {\n      int avail;\n\n      avail = the_screen->height - (numwins + the_echo_area->height);\n      win = windows;\n\n      while (win)\n        {\n          if ((win->height < WINDOW_MIN_HEIGHT) ||\n              (win->height > avail))\n            {\n              WINDOW *lastwin = NULL;\n\n              /* Split the space among the available windows. */\n              delta_each = avail / numwins;\n              delta_leftover = avail - (delta_each * numwins);\n\n              for (win = windows; win; win = win->next)\n                {\n                  lastwin = win;\n                  if (win->prev)\n                    win->first_row =\n                      (win->prev->first_row + win->prev->height) + 1;\n                  win->height = delta_each;\n                }\n\n              /* Give the leftover space (if any) to the last window. */\n              lastwin->height += delta_leftover;\n              break;\n            }\n          else\n            win = win->next;\n        }\n    }\n\n  /* Make sure point is in displayed part of active window. */\n  window_adjust_pagetop (active_window);\n\n  /* One more loop.  If any heights or widths have become negative,\n     set them to zero.  This can apparently happen with resizing down to\n     very small sizes.  Sadly, it is not apparent to me where in the\n     above calculations it goes wrong.  */\n  for (win = windows; win; win = win->next)\n    {\n      if (win->height < 0)\n        win->height = 0;\n\n      if (win->width < 0)\n        win->width = 0;\n    }\n}",
      "lines": 186,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "window_make_window": {
      "start_point": [
        273,
        0
      ],
      "end_point": [
        312,
        1
      ],
      "content": "WINDOW *\nwindow_make_window (void)\n{\n  WINDOW *window;\n\n  /* If there isn't enough room to make another window, return now. */\n  if ((active_window->height / 2) < WINDOW_MIN_SIZE)\n    return NULL;\n\n  /* Make and initialize the new window.\n     The fudging about with -1 and +1 is because the following window in the\n     chain cannot start at window->height, since that is where the modeline\n     for the previous window is displayed.  The inverse adjustment is made\n     in window_delete_window (). */\n  window = xzalloc (sizeof (WINDOW));\n  window->width = the_screen->width;\n  window->height = (active_window->height / 2) - 1;\n  window->first_row = active_window->first_row +\n    (active_window->height - window->height);\n  window->goal_column = -1;\n  memset (&window->line_map, 0, sizeof (window->line_map));\n  window->modeline = xmalloc (1 + window->width);\n  window->line_starts = NULL;\n  window->flags = W_UpdateWindow | W_WindowVisible;\n\n  /* Adjust the height of the old active window. */\n  active_window->height -= (window->height + 1);\n  active_window->flags |= W_UpdateWindow;\n\n  window_make_modeline (active_window);\n\n  /* This window is just after the active one.  Which window is active is\n     not changed. */\n  window->prev = active_window;\n  window->next = active_window->next;\n  active_window->next = window;\n  if (window->next)\n    window->next->prev = window;\n  return window;\n}",
      "lines": 40,
      "depth": 9,
      "decorators": [
        "WINDOW",
        "*\nwindow_make_window (void)",
        "*"
      ]
    },
    "window_change_window_height": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        469,
        1
      ],
      "content": "void\nwindow_change_window_height (WINDOW *window, int amount)\n{\n  register WINDOW *win, *prev, *next;\n\n  /* If there is only one window, or if the amount of change is zero,\n     return immediately. */\n  if (!windows->next || amount == 0)\n    return;\n\n  /* Find this window in our chain. */\n  for (win = windows; win; win = win->next)\n    if (win == window)\n      break;\n\n  /* If the window is isolated (i.e., doesn't appear in our window list,\n     then quit now. */\n  if (!win)\n    return;\n\n  /* Change the height of this window by AMOUNT, if that is possible.\n     It can be impossible if there isn't enough available room on the\n     screen, or if the resultant window would be too small. */\n\n    prev = window->prev;\n    next = window->next;\n\n  /* WINDOW decreasing in size? */\n  if (amount < 0)\n    {\n      int abs_amount = -amount; /* It is easier to deal with this way. */\n\n      /* If the resultant window would be too small, stop here. */\n      if ((window->height - abs_amount) < WINDOW_MIN_HEIGHT)\n        return;\n\n      /* If we have two neighboring windows, choose the smaller one to get\n         larger. */\n      if (next && prev)\n        {\n          if (prev->height < next->height)\n            shrink_me_growing_prev (window, prev, abs_amount);\n          else\n            shrink_me_growing_next (window, next, abs_amount);\n        }\n      else if (next)\n        shrink_me_growing_next (window, next, abs_amount);\n      else\n        shrink_me_growing_prev (window, prev, abs_amount);\n    }\n\n  /* WINDOW increasing in size? */\n  if (amount > 0)\n    {\n      int total_avail, next_avail = 0, prev_avail = 0;\n\n      if (next)\n        next_avail = next->height - WINDOW_MIN_SIZE;\n\n      if (prev)\n        prev_avail = prev->height - WINDOW_MIN_SIZE;\n\n      total_avail = next_avail + prev_avail;\n\n      /* If there isn't enough space available to grow this window, give up. */\n      if (amount > total_avail)\n        return;\n\n      /* If there aren't two neighboring windows, or if one of the neighbors\n         is larger than the other one by at least AMOUNT, grow that one. */\n      if (next_avail - amount >= prev_avail)\n        grow_me_shrinking_next (window, next, amount);\n      else if (prev_avail - amount >= next_avail)\n        grow_me_shrinking_prev (window, prev, amount);\n      else\n        {\n          int change;\n\n          /* This window has two neighbors.  They both must be shrunk in to\n             make enough space for WINDOW to grow.  Make them both the same\n             size. */\n          if (prev_avail > next_avail)\n            {\n              change = prev_avail - next_avail;\n              grow_me_shrinking_prev (window, prev, change);\n              amount -= change;\n            }\n          else\n            {\n              change = next_avail - prev_avail;\n              grow_me_shrinking_next (window, next, change);\n              amount -= change;\n            }\n\n          /* Both neighbors are the same size.  Split the difference in\n             AMOUNT between them. */\n          while (amount)\n            {\n              window->height++;\n              amount--;\n\n              /* Odd numbers grow next, even grow prev. */\n              if (amount & 1)\n                {\n                  prev->height--;\n                  window->first_row--;\n                }\n              else\n                {\n                  next->height--;\n                  next->first_row++;\n                }\n            }\n        }\n    }\n  if (prev)\n    prev->flags |= W_UpdateWindow;\n\n  if (next)\n    next->flags |= W_UpdateWindow;\n\n  window->flags |= W_UpdateWindow;\n}",
      "lines": 123,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "window_tile_windows": {
      "start_point": [
        475,
        0
      ],
      "end_point": [
        524,
        1
      ],
      "content": "void\nwindow_tile_windows (int style)\n{\n  WINDOW *win, *last_adjusted;\n  int numwins, avail, per_win_height, leftover;\n  int do_internals;\n\n  numwins = avail = 0;\n  do_internals = (style == TILE_INTERNALS);\n\n  for (win = windows; win; win = win->next)\n    if (do_internals || !win->node ||\n        (win->node->flags & N_IsInternal) == 0)\n      {\n        avail += win->height;\n        numwins++;\n      }\n\n  if (numwins <= 1 || !the_screen->height)\n    return;\n\n  /* Find the size for each window.  Divide the size of the usable portion\n     of the screen by the number of windows. */\n  per_win_height = avail / numwins;\n  leftover = avail - (per_win_height * numwins);\n\n  last_adjusted = NULL;\n  for (win = windows; win; win = win->next)\n    {\n      if (do_internals || !win->node ||\n          (win->node->flags & N_IsInternal) == 0)\n        {\n          last_adjusted = win;\n          win->height = per_win_height;\n        }\n    }\n\n  if (last_adjusted)\n    last_adjusted->height += leftover;\n\n  /* Readjust the first_row of every window in the chain. */\n  for (win = windows; win; win = win->next)\n    {\n      if (win->prev)\n        win->first_row = win->prev->first_row + win->prev->height + 1;\n\n      window_adjust_pagetop (win);\n      win->flags |= W_UpdateWindow;\n    }\n}",
      "lines": 50,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "window_toggle_wrap": {
      "start_point": [
        528,
        0
      ],
      "end_point": [
        562,
        1
      ],
      "content": "void\nwindow_toggle_wrap (WINDOW *window)\n{\n  if (window->flags & W_NoWrap)\n    window->flags &= ~W_NoWrap;\n  else\n    window->flags |= W_NoWrap;\n\n  if (window != the_echo_area)\n    {\n      long *old_starts;\n      long *old_xlat;\n      int old_lines, old_pagetop;\n\n      old_starts = window->line_starts;\n      old_xlat = window->log_line_no;\n      old_lines = window->line_count;\n      old_pagetop = window->pagetop;\n\n      calculate_line_starts (window);\n\n      /* Make sure that point appears within this window. */\n      window_adjust_pagetop (window);\n\n      /* If the pagetop hasn't changed maybe we can do some scrolling now\n         to speed up the display.  Many of the line starts will be the same,\n         so scrolling here is a very good optimization.*/\n      if (old_pagetop == window->pagetop)\n        display_scroll_line_starts (window, old_pagetop,\n                                    old_starts, old_lines);\n      free (old_starts);\n      free (old_xlat);\n    }\n  window->flags |= W_UpdateWindow;\n}",
      "lines": 35,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "window_set_node_of_window": {
      "start_point": [
        565,
        0
      ],
      "end_point": [
        588,
        1
      ],
      "content": "void\nwindow_set_node_of_window (WINDOW *window, NODE *node)\n{\n  window->node = node;\n  window->pagetop = 0;\n  window->point = 0;\n\n  free (window->line_starts);\n  free (window->log_line_no);\n  calculate_line_starts (window);\n  window_compute_line_map (window);\n\n  /* Clear displayed search matches if any. */\n  free_matches (&window->matches);\n\n  window->flags |= W_UpdateWindow;\n  if (node)\n    {\n      /* The display_pos member is nonzero if we're displaying an anchor.  */\n      window->point = node ? node->display_pos : 0;\n      window_adjust_pagetop (window);\n    }\n  window_make_modeline (window);\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "window_delete_window": {
      "start_point": [
        596,
        0
      ],
      "end_point": [
        678,
        1
      ],
      "content": "void\nwindow_delete_window (WINDOW *window)\n{\n  WINDOW *next, *prev, *window_to_fix;\n\n  next = window->next;\n  prev = window->prev;\n\n  /* You cannot delete the only window or a permanent window. */\n  if ((!next && !prev) || (window->flags & W_WindowIsPerm))\n    return;\n\n  if (next)\n    next->prev = prev;\n\n  if (!prev)\n    windows = next;\n  else\n    prev->next = next;\n\n  free (window->line_starts);\n  free (window->log_line_no);\n  free (window->line_map.map);\n  free (window->modeline);\n  free_matches (&window->matches);\n  free (window->search_string);\n\n  if (window == active_window)\n    {\n      WINDOW *new_active = 0;\n\n      /* If there isn't a next window, then there must be a previous one,\n         since we cannot delete the last window.  If there is a next window,\n         prefer to use that as the active window.  Try to find an important\n         window to select, e.g. not a footnotes window. */\n      if (next)\n        {\n          new_active = next;\n          while ((new_active->flags & W_TempWindow) && new_active->next)\n            new_active = new_active->next;\n        }\n\n      if ((!new_active || new_active->flags & W_TempWindow) && prev)\n        {\n          new_active = prev;\n          while ((new_active->flags & W_TempWindow) && new_active->prev)\n            new_active = new_active->prev;\n        }\n      active_window = new_active;\n    }\n\n  if (next && active_window == next)\n    window_to_fix = next;\n  else if (prev && active_window == prev)\n    window_to_fix = prev;\n  else if (next)\n    window_to_fix = next;\n  else if (prev)\n    window_to_fix = prev;\n  else\n    window_to_fix = windows;\n    \n  if (window_to_fix->first_row > window->first_row)\n    {\n      int diff;\n\n      /* Try to adjust the visible part of the node so that as little\n         text as possible has to move. */\n      diff = window_to_fix->first_row - window->first_row;\n      window_to_fix->first_row = window->first_row;\n\n      window_to_fix->pagetop -= diff;\n      if (window_to_fix->pagetop < 0)\n        window_to_fix->pagetop = 0;\n    }\n\n  /* The `+ 1' is to offset the difference between the first_row locations.\n     See the code in window_make_window (). */\n  window_to_fix->height += window->height + 1;\n  window_to_fix->flags |= W_UpdateWindow;\n\n  free (window);\n}",
      "lines": 83,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "window_mark_chain": {
      "start_point": [
        681,
        0
      ],
      "end_point": [
        688,
        1
      ],
      "content": "void\nwindow_mark_chain (WINDOW *chain, int flag)\n{\n  register WINDOW *win;\n\n  for (win = chain; win; win = win->next)\n    win->flags |= flag;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "window_unmark_chain": {
      "start_point": [
        691,
        0
      ],
      "end_point": [
        698,
        1
      ],
      "content": "void\nwindow_unmark_chain (WINDOW *chain, int flag)\n{\n  register WINDOW *win;\n\n  for (win = chain; win; win = win->next)\n    win->flags &= ~flag;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "window_log_to_phys_line": {
      "start_point": [
        707,
        0
      ],
      "end_point": [
        717,
        1
      ],
      "content": "long\nwindow_log_to_phys_line (WINDOW *window, long ln)\n{\n  size_t i;\n  \n  if (ln > window->line_count)\n    return 0;\n  for (i = ln; i < window->line_count && window->log_line_no[i] < ln; i++)\n    ;\n  return i;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "long",
        "long"
      ]
    },
    "set_window_pagetop": {
      "start_point": [
        721,
        0
      ],
      "end_point": [
        792,
        1
      ],
      "content": "void\nset_window_pagetop (WINDOW *window, int desired_top)\n{\n  int point_line, old_pagetop;\n\n  if (desired_top < 0)\n    desired_top = 0;\n  else if (desired_top > window->line_count)\n    desired_top = window->line_count - 1;\n\n  if (window->pagetop == desired_top)\n    return;\n\n  old_pagetop = window->pagetop;\n  window->pagetop = desired_top;\n\n  /* Make sure that point appears in this window. */\n  point_line = window_line_of_point (window);\n  if (point_line < window->pagetop)\n    {\n      window->point = window->line_starts[window->pagetop];\n      window->goal_column = 0;\n    }\n  else if (point_line >= window->pagetop + window->height)\n    {\n      long bottom = window->pagetop + window->height - 1;\n      window->point = window->line_starts[bottom];\n      window->goal_column = 0;\n    }\n\n  window->flags |= W_UpdateWindow;\n\n  /* Find out which direction to scroll, and scroll the window in that\n     direction.  Do this only if there would be a savings in redisplay\n     time.  This is true if the amount to scroll is less than the height\n     of the window, and if the number of lines scrolled would be greater\n     than 10 % of the window's height.\n\n     To prevent status line blinking when keeping up or down key,\n     scrolling is disabled if the amount to scroll is 1. */\n  if (old_pagetop < desired_top)\n    {\n      int start, end, amount;\n\n      amount = desired_top - old_pagetop;\n\n      if (amount == 1 ||\n          (amount >= window->height) ||\n          (((window->height - amount) * 10) < window->height))\n        return;\n\n      start = window->first_row;\n      end = window->height + window->first_row;\n\n      display_scroll_display (start, end, -amount);\n    }\n  else\n    {\n      int start, end, amount;\n\n      amount = old_pagetop - desired_top;\n\n      if (amount == 1 ||\n          (amount >= window->height) ||\n          (((window->height - amount) * 10) < window->height))\n        return;\n\n      start = window->first_row;\n      end = window->first_row + window->height;\n      display_scroll_display (start, end, amount);\n    }\n}",
      "lines": 72,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "window_adjust_pagetop": {
      "start_point": [
        795,
        0
      ],
      "end_point": [
        816,
        1
      ],
      "content": "void\nwindow_adjust_pagetop (WINDOW *window)\n{\n  register int line;\n\n  if (!window->node)\n    return;\n\n  line = window_line_of_point (window);\n\n  /* If this line appears in the current displayable page, do nothing.\n     Otherwise, adjust the top of the page to make this line visible. */\n  if (line < window->pagetop\n      || line - window->pagetop > window->height - 1)\n    {\n      int new_pagetop = line - ((window->height - 1) / 2);\n\n      if (new_pagetop < 0)\n        new_pagetop = 0;\n      set_window_pagetop (window, new_pagetop);\n    }\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "window_line_of_point": {
      "start_point": [
        819,
        0
      ],
      "end_point": [
        843,
        1
      ],
      "content": "int\nwindow_line_of_point (WINDOW *window)\n{\n  register int i, start = 0;\n\n  if (!window->line_starts)\n    calculate_line_starts (window);\n\n  /* Check if point is past the pagetop for this window, and if so, start \n     searching forward from there. */\n  if (window->pagetop > -1 && window->pagetop < window->line_count\n      && window->line_starts[window->pagetop] <= window->point)\n    start = window->pagetop;\n\n  for (i = start; i < window->line_count; i++)\n    {\n      if (window->line_starts[i] > window->point)\n        break;\n    }\n\n  if (i > 0)\n    return i - 1;\n  else\n    return 0; /* Shouldn't happen */\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "window_get_cursor_column": {
      "start_point": [
        846,
        0
      ],
      "end_point": [
        850,
        1
      ],
      "content": "int\nwindow_get_cursor_column (WINDOW *window)\n{\n  return window_point_to_column (window, window->point, &window->point);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "window_make_modeline": {
      "start_point": [
        853,
        0
      ],
      "end_point": [
        947,
        1
      ],
      "content": "void\nwindow_make_modeline (WINDOW *window)\n{\n  register int i;\n  char *modeline;\n  char location_indicator[4];\n  int lines_remaining;\n\n  /* Only make modelines for those windows which have one. */\n  if (window->flags & W_InhibitMode)\n    return;\n\n  /* Find the number of lines actually displayed in this window. */\n  lines_remaining = window->line_count - window->pagetop;\n\n  if (window->pagetop == 0)\n    {\n      if (lines_remaining <= window->height)\n        strcpy (location_indicator, \"All\");\n      else\n        strcpy (location_indicator, \"Top\");\n    }\n  else\n    {\n      if (lines_remaining <= window->height)\n        strcpy (location_indicator, \"Bot\");\n      else\n        {\n          float pt, lc;\n          int percentage;\n\n          pt = (float)window->pagetop;\n          lc = (float)(window->line_count - window->height);\n\n          percentage = 100 * (pt / lc);\n\n          sprintf (location_indicator, \"%2d%%\", percentage);\n        }\n    }\n\n  /* Calculate the maximum size of the information to stick in MODELINE. */\n  {\n    int modeline_len = 0;\n    char *nodename = \"*no node*\";\n    NODE *node = window->node;\n    char *name;\n    int dot;\n\n    if (node && node->nodename)\n      nodename = node->nodename;\n\n    name = filename_non_directory (node->fullpath);\n\n    /* 10 for the decimal representation of the number of lines in this\n       node, and the remainder of the text that can appear in the line. */\n    modeline_len += 10 + strlen (_(\"-----Info: (), lines ----, \"));\n    modeline_len += 3; /* strlen (location_indicator) */\n    modeline_len += strlen (name);\n    if (nodename)\n      modeline_len += strlen (nodename);\n    if (modeline_len < window->width)\n      modeline_len = window->width;\n\n    modeline = xcalloc (1, 1 + modeline_len);\n\n    sprintf (modeline + strlen (modeline), \"-----Info: \");\n\n    /* Omit any extension like \".info.gz\" from file name. */\n    dot = strcspn (name, \".\");\n\n    if (name && strcmp (\"\", name))\n      {\n        sprintf (modeline + strlen (modeline), \"(\");\n        strncpy (modeline + strlen (modeline), name, dot);\n        sprintf (modeline + strlen (modeline), \")\");\n      }\n    sprintf (modeline + strlen (modeline),\n             \"%s, %ld lines --%s\",\n             nodename, window->line_count, location_indicator);\n\n    i = strlen (modeline);\n\n    if (i >= window->width)\n      modeline[window->width] = '\\0';\n    else\n      {\n        while (i < window->width)\n          modeline[i++] = '-';\n        modeline[i] = '\\0';\n      }\n\n    strcpy (window->modeline, modeline);\n    free (modeline);\n  }\n}",
      "lines": 95,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "window_goto_percentage": {
      "start_point": [
        950,
        0
      ],
      "end_point": [
        966,
        1
      ],
      "content": "void\nwindow_goto_percentage (WINDOW *window, int percent)\n{\n  int desired_line;\n\n  if (!percent)\n    desired_line = 0;\n  else\n    desired_line =\n      (int) ((float)window->line_count * ((float)percent / 100.0));\n\n  window->pagetop = desired_line;\n  window->point =\n    window->line_starts[window->pagetop];\n  window->flags |= W_UpdateWindow;\n  window_make_modeline (window);\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "free_echo_area": {
      "start_point": [
        973,
        0
      ],
      "end_point": [
        984,
        1
      ],
      "content": "void\nfree_echo_area (void)\n{\n  if (echo_area_node)\n    {\n      free (echo_area_node->contents);\n      free (echo_area_node);\n    }\n\n  echo_area_node = NULL;\n  window_set_node_of_window (the_echo_area, echo_area_node);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "window_clear_echo_area": {
      "start_point": [
        988,
        0
      ],
      "end_point": [
        993,
        1
      ],
      "content": "void\nwindow_clear_echo_area (void)\n{\n  free_echo_area ();\n  display_update_one_window (the_echo_area);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "vwindow_message_in_echo_area": {
      "start_point": [
        995,
        0
      ],
      "end_point": [
        1002,
        1
      ],
      "content": "void\nvwindow_message_in_echo_area (const char *format, va_list ap)\n{\n  free_echo_area ();\n  echo_area_node = build_message_node (format, ap);\n  window_set_node_of_window (the_echo_area, echo_area_node);\n  display_update_one_window (the_echo_area);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "window_message_in_echo_area": {
      "start_point": [
        1008,
        0
      ],
      "end_point": [
        1016,
        1
      ],
      "content": "void\nwindow_message_in_echo_area (const char *format, ...)\n{\n  va_list ap;\n  \n  va_start (ap, format);\n  vwindow_message_in_echo_area (format, ap);\n  va_end (ap);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "message_in_echo_area": {
      "start_point": [
        1026,
        0
      ],
      "end_point": [
        1041,
        1
      ],
      "content": "void\nmessage_in_echo_area (const char *format, ...)\n{\n  va_list ap;\n  \n  if (echo_area_node)\n    {\n      add_pointer_to_array (echo_area_node, old_echo_area_nodes_index,\n                            old_echo_area_nodes, old_echo_area_nodes_slots,\n                            4);\n    }\n  echo_area_node = NULL;\n  va_start (ap, format);\n  vwindow_message_in_echo_area (format, ap);\n  va_end (ap);\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "unmessage_in_echo_area": {
      "start_point": [
        1043,
        0
      ],
      "end_point": [
        1053,
        1
      ],
      "content": "void\nunmessage_in_echo_area (void)\n{\n  free_echo_area ();\n\n  if (old_echo_area_nodes_index)\n    echo_area_node = old_echo_area_nodes[--old_echo_area_nodes_index];\n\n  window_set_node_of_window (the_echo_area, echo_area_node);\n  display_update_one_window (the_echo_area);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "build_message_node": {
      "start_point": [
        1058,
        0
      ],
      "end_point": [
        1067,
        1
      ],
      "content": "NODE *\nbuild_message_node (const char *format, va_list ap)\n{\n  struct text_buffer msg;\n\n  text_buffer_init (&msg);\n  text_buffer_vprintf (&msg, format, ap);\n\n  return text_buffer_to_node (&msg);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "NODE",
        "*\nbuild_message_node (const char *format, va_list ap)",
        "*"
      ]
    },
    "format_message_node": {
      "start_point": [
        1069,
        0
      ],
      "end_point": [
        1079,
        1
      ],
      "content": "NODE *\nformat_message_node (const char *format, ...)\n{\n  NODE *node;\n  va_list ap;\n  \n  va_start (ap, format);\n  node = build_message_node (format, ap);\n  va_end (ap);\n  return node;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "NODE",
        "*\nformat_message_node (const char *format, ...)",
        "*"
      ]
    },
    "text_buffer_to_node": {
      "start_point": [
        1081,
        0
      ],
      "end_point": [
        1096,
        1
      ],
      "content": "NODE *\ntext_buffer_to_node (struct text_buffer *tb)\n{\n  NODE *node;\n\n  node = info_create_node ();\n\n  /* Make sure that this buffer ends with a newline. */\n  text_buffer_add_char (tb, '\\n');\n  node->nodelen = text_buffer_off (tb);\n  text_buffer_add_char (tb, '\\0');\n\n  node->contents = text_buffer_base (tb);\n  node->flags |= N_IsInternal;\n  return node;\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "NODE",
        "*\ntext_buffer_to_node (struct text_buffer *tb)",
        "*"
      ]
    },
    "collect_line_starts": {
      "start_point": [
        1100,
        0
      ],
      "end_point": [
        1111,
        1
      ],
      "content": "static void\ncollect_line_starts (WINDOW *win, long ll_num, long pl_start)\n{\n  add_element_to_array (pl_start, win->line_count,\n                        win->line_starts, win->line_slots, 2);\n\n  /* We cannot do add_element_to_array for this, as this would lead\n     to incrementing cp->win->line_count twice. */\n  win->log_line_no = xrealloc (win->log_line_no,\n                               win->line_slots * sizeof (long));\n  win->log_line_no[win->line_count - 1] = ll_num;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "calculate_line_starts": {
      "start_point": [
        1123,
        0
      ],
      "end_point": [
        1237,
        1
      ],
      "content": "void\ncalculate_line_starts (WINDOW *win)\n{\n  long pl_chars = 0;     /* Number of characters in line so far. */\n  long pl_start;         /* Offset of start of current physical line. */\n  long ll_num = 0;       /* Number of logical lines */\n  mbi_iterator_t iter;\n\n  /* Width of character carried over from one physical line to the next.  */\n  size_t carried_over_chars = 0;\n\n  win->line_starts = NULL;\n  win->log_line_no = NULL;\n  win->line_count = 0;\n  win->line_slots = 0;\n\n  if (!win->node)\n    return;\n\n  pl_start = 0;\n  if (nodeline_print != PRINT_NODELINE\n      && !memcmp (win->node->contents, \"File:\", strlen (\"File:\")))\n    {\n      char *s = strchr (win->node->contents, '\\n');\n      if (s && nodeline_print == NO_NODELINE)\n        {\n          pl_start = s - win->node->contents + 1;\n        }\n      else if (s && nodeline_print == NODELINE_POINTERS_ONLY)\n        {\n          char *s2;\n          char saved = *s;\n          *s = '\\0';\n          s2 = strstr (win->node->contents, \"Next: \");\n          if (!s2)\n            s2 = strstr (win->node->contents, \"Prev: \");\n          if (!s2)\n            s2 = strstr (win->node->contents, \"Up: \");\n          if (s2)\n            pl_start = s2 - win->node->contents;\n          *s = saved;\n        }\n    }\n\n  for (mbi_init (iter,\n                 win->node->contents + pl_start,\n                 win->node->nodelen - pl_start);\n       mbi_avail (iter);\n       mbi_advance (iter))\n    {\n      size_t pchars = 0; /* Screen columns for this character. */\n      size_t pbytes = 0; /* Not used. */\n      int delim = 0;\n\n      /* Set pchars. */\n      (void) printed_representation (&iter, &delim, pl_chars,\n                                     &pchars, &pbytes);\n\n      /* If this character can be printed without passing the width of\n         the line, then include it in the line. */\n      if (!delim && pl_chars + pchars < win->width)\n        {\n          pl_chars += pchars;\n          continue;\n        }\n\n      /* If this character cannot be printed in this line, we have\n         found the end of this line as it would appear on the screen. */\n\n      carried_over_chars = delim ? 0 : pchars;\n\n      collect_line_starts (win, ll_num, pl_start);\n\n      if (delim == '\\r' || delim == '\\n')\n        ++ll_num;\n\n      /* Start a new physical line at next character, unless a character\n         was carried over, in which case start there. */\n      pl_start = mbi_cur_ptr (iter) - win->node->contents;\n      if (carried_over_chars == 0)\n        pl_start += mb_len (mbi_cur (iter));\n      pl_chars = 0;\n\n      /* If there is a character carried over, count it now.  Expected to be \n         \"short\", i.e. a representation like \"^A\". */\n      if (carried_over_chars != 0)\n        {\n          pl_chars = carried_over_chars;\n    \n          /* If this window has chosen not to wrap lines, skip to the end\n             of the logical line in the buffer, and start a new line here. */\n          if (win->flags & W_NoWrap)\n            {\n              for (; mbi_avail (iter); mbi_advance (iter))\n                if (mb_len (mbi_cur (iter)) == 1\n                    && *mbi_cur_ptr (iter) == '\\n')\n                  break;\n\n              pl_chars = 0;\n              pl_start = mbi_cur_ptr (iter) + mb_len (mbi_cur (iter))\n                         - win->node->contents;\n            }\n        }\n    }\n\n  if (pl_chars)\n    collect_line_starts (win, ll_num++, pl_start);\n\n  /* Have one line start at the end of the node. */\n  collect_line_starts (win, ll_num, mbi_cur_ptr (iter) - win->node->contents);\n  win->line_count--;\n\n  /* Finally, initialize the line map for the current line. */\n  window_line_map_init (win);\n}",
      "lines": 115,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "line_map_init": {
      "start_point": [
        1240,
        0
      ],
      "end_point": [
        1246,
        1
      ],
      "content": "static void\nline_map_init (LINE_MAP *map, NODE *node, int line)\n{\n  map->node = node;\n  map->nline = line;\n  map->used = 0;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "line_map_add": {
      "start_point": [
        1248,
        0
      ],
      "end_point": [
        1261,
        1
      ],
      "content": "static void\nline_map_add (LINE_MAP *map, long pos)\n{\n  if (map->used == map->size)\n    {\n      if (map->size == 0)\t\t\t\t       \n\tmap->size = 80; /* Initial allocation */\t       \n      map->map = x2nrealloc (map->map,\n\t\t\t     &map->size,\n\t\t\t     sizeof (map->map[0]));\n    }\n\n  map->map[map->used++] = pos;\n}",
      "lines": 14,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "window_line_map_init": {
      "start_point": [
        1264,
        0
      ],
      "end_point": [
        1268,
        1
      ],
      "content": "void\nwindow_line_map_init (WINDOW *win)\n{\n  win->line_map.used = 0;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "window_compute_line_map": {
      "start_point": [
        1271,
        0
      ],
      "end_point": [
        1311,
        1
      ],
      "content": "void\nwindow_compute_line_map (WINDOW *win)\n{\n  int line = window_line_of_point (win);\n  mbi_iterator_t iter;\n  int delim = 0;\n  char *endp;\n  const char *cur_ptr;\n\n  if (win->line_map.node == win->node && win->line_map.nline == line\n      && win->line_map.used)\n    return;\n  line_map_init (&win->line_map, win->node, line);\n  if (!win->node)\n    return;\n\n  if (line + 1 < win->line_count)\n    endp = win->node->contents + win->line_starts[line + 1];\n  else\n    endp = win->node->contents + win->node->nodelen;\n  \n  for (mbi_init (iter,\n\t\t win->node->contents + win->line_starts[line], \n\t\t win->node->nodelen - win->line_starts[line]);\n       !delim && mbi_avail (iter);\n       mbi_advance (iter))\n    {\n      size_t pchars, pbytes;\n      cur_ptr = mbi_cur_ptr (iter);\n\n      if (cur_ptr >= endp)\n\tbreak;\n      \n      /* Set pchars */\n      (void) printed_representation (&iter, &delim, win->line_map.used,\n                                     &pchars, &pbytes);\n\n      while (pchars--)\n        line_map_add (&win->line_map, cur_ptr - win->node->contents);\n    }\n}",
      "lines": 41,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "window_point_to_column": {
      "start_point": [
        1317,
        0
      ],
      "end_point": [
        1331,
        1
      ],
      "content": "int\nwindow_point_to_column (WINDOW *win, long point, long *np)\n{\n  int i;\n  \n  window_compute_line_map (win);\n  if (!win->line_map.map || point < win->line_map.map[0])\n    return 0;\n  for (i = 0; i < win->line_map.used; i++)\n    if (win->line_map.map[i] >= point)\n      break;\n  if (np)\n    *np = win->line_map.map[i];\n  return i;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/info/window.h": {},
  "texinfo/texinfo-6.5/install-info/install-info.c": {
    "vdiag": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "void\nvdiag (const char *fmt, const char *diagtype, va_list ap)\n{\n  fprintf (stderr, \"%s: \", progname);\n  if (diagtype)\n    fprintf (stderr, \"%s: \", diagtype);\n  vfprintf (stderr, fmt, ap);\n  putc ('\\n', stderr);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "error": {
      "start_point": [
        219,
        0
      ],
      "end_point": [
        227,
        1
      ],
      "content": "void\nerror (const char *fmt, ...)\n{\n  va_list ap;\n\n  va_start (ap, fmt);\n  vdiag (fmt, NULL, ap);\n  va_end (ap);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "warning": {
      "start_point": [
        230,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "void\nwarning (const char *fmt, ...)\n{\n  va_list ap;\n\n  va_start (ap, fmt);\n  vdiag (fmt, \"warning\", ap);\n  va_end (ap);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "fatal": {
      "start_point": [
        242,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "void\nfatal (const char *fmt, ...)\n{\n  va_list ap;\n\n  va_start (ap, fmt);\n  vdiag (fmt, NULL, ap);\n  va_end (ap);\n  exit (EXIT_FAILURE);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "concat": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        267,
        1
      ],
      "content": "char *\nconcat (const char *s1, const char *s2, const char *s3)\n{\n  int len1 = strlen (s1), len2 = strlen (s2), len3 = strlen (s3);\n  char *result = (char *) xmalloc (len1 + len2 + len3 + 1);\n\n  strcpy (result, s1);\n  strcpy (result + len1, s2);\n  strcpy (result + len1 + len2, s3);\n  *(result + len1 + len2 + len3) = 0;\n\n  return result;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "char",
        "*\nconcat (const char *s1, const char *s2, const char *s3)",
        "*"
      ]
    },
    "copy_string": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        281,
        1
      ],
      "content": "char *\ncopy_string (const char *string, int size)\n{\n  int i;\n  char *copy = (char *) xmalloc (size + 1);\n  for (i = 0; i < size; i++)\n    copy[i] = string[i];\n  copy[size] = 0;\n  return copy;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "char",
        "*\ncopy_string (const char *string, int size)",
        "*"
      ]
    },
    "pfatal_with_name": {
      "start_point": [
        285,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "void\npfatal_with_name (const char *name)\n{\n  /* Empty files don't set errno, so we get something like\n     \"install-info: No error for foo\", which is confusing.  */\n  if (errno == 0)\n    fatal (_(\"%s: empty file\"), name);\n\n  fatal (_(\"%s for %s\"), strerror (errno), name);\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "menu_line_lessp": {
      "start_point": [
        300,
        0
      ],
      "end_point": [
        323,
        1
      ],
      "content": "static int\nmenu_line_lessp (char *line1, int len1, char *line2, int len2)\n{\n  int minlen = (len1 < len2 ? len1 : len2);\n  int i;\n\n  for (i = 0; i < minlen; i++)\n    {\n      /* If one item name is a prefix of the other,\n         the former one is less.  */\n      if (line1[i] == ':' && line2[i] != ':')\n        return 1;\n      if (line2[i] == ':' && line1[i] != ':')\n        return 0;\n      /* If they both continue and differ, one is less.  */\n      if (line1[i] < line2[i])\n        return 1;\n      if (line1[i] > line2[i])\n        return 0;\n    }\n  /* With a properly formatted dir file,\n     we can only get here if the item names are equal.  */\n  return 0;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "menu_line_equal": {
      "start_point": [
        329,
        0
      ],
      "end_point": [
        347,
        1
      ],
      "content": "static int\nmenu_line_equal (char *line1, int len1, char *line2, int len2)\n{\n  int minlen = (len1 < len2 ? len1 : len2);\n  int i;\n\n  for (i = 0; i < minlen; i++)\n    {\n      /* If both item names end here, they are equal.  */\n      if (line1[i] == ':' && line2[i] == ':')\n        return 1;\n      /* If they both continue and differ, one is less.  */\n      if (line1[i] != line2[i])\n        return 0;\n    }\n  /* With a properly formatted dir file,\n     we can only get here if the item names are equal.  */\n  return 1;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "extract_menu_item_name": {
      "start_point": [
        353,
        0
      ],
      "end_point": [
        366,
        1
      ],
      "content": "char *\nextract_menu_item_name (char *item_text)\n{\n  char *p;\n\n  if (*item_text == '*')\n    item_text++;\n  while (*item_text == ' ')\n    item_text++;\n\n  p = item_text;\n  while (*p && *p != ':') p++;\n  return copy_string (item_text, p - item_text);\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "char",
        "*\nextract_menu_item_name (char *item_text)",
        "*"
      ]
    },
    "extract_menu_file_name": {
      "start_point": [
        371,
        0
      ],
      "end_point": [
        408,
        1
      ],
      "content": "char *\nextract_menu_file_name (char *item_text)\n{\n  char *p = item_text;\n\n  /* If we have text that looks like * ITEM: (FILE)NODE...,\n     extract just FILE.  Otherwise return \"(none)\".  */\n\n  if (*p == '*')\n    p++;\n  while (*p == ' ')\n    p++;\n\n  /* Skip to and past the colon.  */\n  while (*p && *p != '\\n' && *p != ':') p++;\n  if (*p == ':') p++;\n\n  /* Skip past the open-paren.  */\n  while (1)\n    {\n      if (*p == '(')\n        break;\n      else if (*p == ' ' || *p == '\\t')\n        p++;\n      else\n        return \"(none)\";\n    }\n  p++;\n\n  item_text = p;\n\n  /* File name ends just before the close-paren.  */\n  while (*p && *p != '\\n' && *p != ')') p++;\n  if (*p != ')')\n    return \"(none)\";\n\n  return copy_string (item_text, p - item_text);\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "char",
        "*\nextract_menu_file_name (char *item_text)",
        "*"
      ]
    },
    "strip_info_suffix": {
      "start_point": [
        414,
        0
      ],
      "end_point": [
        466,
        1
      ],
      "content": "static char *\nstrip_info_suffix (char *fname)\n{\n  char *ret = xstrdup (fname);\n  unsigned len = strlen (ret);\n\n  if (len > 3 && FILENAME_CMP (ret + len - 3, \".gz\") == 0)\n    {\n      len -= 3;\n      ret[len] = 0;\n    }\n  else if (len > 3 && FILENAME_CMP (ret + len - 3, \".xz\") == 0)\n    {\n      len -= 3;\n      ret[len] = 0;\n    }\n  else if (len > 4 && FILENAME_CMP (ret + len - 4, \".bz2\") == 0)\n    {\n      len -= 4;\n      ret[len] = 0;\n    }\n  else if (len > 3 && FILENAME_CMP (ret + len - 3, \".lz\") == 0)\n    {\n      len -= 3;\n      ret[len] = 0;\n    }\n  else if (len > 5 && FILENAME_CMP (ret + len - 5, \".lzma\") == 0)\n   {\n      len -= 5;\n      ret[len] =0;\n   }\n\n  if (len > 5 && FILENAME_CMP (ret + len - 5, \".info\") == 0)\n    {\n      len -= 5;\n      ret[len] = 0;\n    }\n  else if (len > 4 && FILENAME_CMP (ret + len - 4, \".inf\") == 0)\n    {\n      len -= 4;\n      ret[len] = 0;\n    }\n#ifdef __MSDOS__\n  else if (len > 4 && (FILENAME_CMP (ret + len - 4, \".inz\") == 0\n                       || FILENAME_CMP (ret + len - 4, \".igz\") == 0))\n    {\n      len -= 4;\n      ret[len] = 0;\n    }\n#endif /* __MSDOS__ */\n\n  return ret;\n}",
      "lines": 53,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nstrip_info_suffix (char *fname)",
        "*"
      ]
    },
    "menu_item_equal": {
      "start_point": [
        473,
        0
      ],
      "end_point": [
        525,
        1
      ],
      "content": "static int\nmenu_item_equal (const char *item, char term_char, const char *name)\n{\n  int ret;\n  const char *item_basename = item;\n  unsigned name_len = strlen (name);\n\n  /* We must compare the basename in ITEM, since we are passed the\n     basename of the original info file.  Otherwise, a new entry like\n     \"lilypond/lilypond\" won't match \"lilypond\".\n     \n     Actually, it seems to me that we should really compare the whole\n     name, and not just the basename.  Couldn't there be dir1/foo.info\n     and dir2/foo.info?  Also, it seems like we should be using the\n     filename from the new dir entries, not the filename on the command\n     line.  Not worrying about those things right now, though.  --karl,\n     26mar04.  */\n  if (!remove_exactly) {\n  while (*item_basename && !IS_SLASH (*item_basename)\n         && *item_basename != term_char)\n    item_basename++;\n  if (! *item_basename || *item_basename == term_char)\n    item_basename = item;  /* no /, use original */\n  else\n    item_basename++;       /* have /, move past it */\n  }\n    \n  /* First, ITEM must actually match NAME (usually it won't).  */\n  ret = mbsncasecmp (item_basename, name, name_len) == 0;\n  if (ret)\n    {\n      /* Then, `foobar' doesn't match `foo', so be sure we've got all of\n         ITEM.  The various suffixes should never actually appear in the\n         dir file, but sometimes people put them in.  */\n      static char *suffixes[]\n        = { \"\", \".info.gz\", \".info\", \".inf\", \".gz\",\n#ifdef __MSDOS__\n            \".inz\", \".igz\",\n#endif\n            NULL };\n      unsigned i;\n      ret = 0;\n      for (i = 0; !ret && suffixes[i]; i++)\n        {\n          char *suffix = suffixes[i];\n          unsigned suffix_len = strlen (suffix);\n          ret = mbsncasecmp (item_basename + name_len, suffix, suffix_len) == 0\n                && item_basename[name_len + suffix_len] == term_char;\n        }\n    }\n\n  return ret;\n}",
      "lines": 53,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "suggest_asking_for_help": {
      "start_point": [
        529,
        0
      ],
      "end_point": [
        535,
        1
      ],
      "content": "void\nsuggest_asking_for_help (void)\n{\n  fprintf (stderr, _(\"\\tTry `%s --help' for a complete list of options.\\n\"),\n           progname);\n  exit (EXIT_FAILURE);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "print_help": {
      "start_point": [
        537,
        0
      ],
      "end_point": [
        619,
        1
      ],
      "content": "void\nprint_help (void)\n{\n  printf (_(\"Usage: %s [OPTION]... [INFO-FILE [DIR-FILE]]\\n\"), progname);\n  puts (\"\");\n  puts (_(\"Add or remove entries in INFO-FILE from the Info directory DIR-FILE.\"));\n  puts (_(\"INFO-FILE and DIR-FILE are required unless the --info-file\\n\\\nor --dir-file (or --info-dir) options are given, respectively.\"));\n  puts (\"\");\n\n  puts (_(\"\\\nOptions:\\n\\\n --add-once          add only to first matching section, not all.\\n\\\n --align=COL         start description of new entries at column COL.\\n\\\n --calign=COL        format second and subsequent description lines to\\n\\\n                       start at column COL.\"));\n\n  puts (_(\"\\\n --debug             report what is being done.\\n\\\n --delete            delete existing entries for INFO-FILE from DIR-FILE;\\n\\\n                      don't insert any new entries.\\n\\\n --defsection=TEXT   like --section, but only use TEXT if no sections\\n\\\n                      are present in INFO-FILE (replacing \\\"Miscellaneous\\\").\\n\\\n --description=TEXT  the description of the entry is TEXT; used with\\n\\\n                      the --name option to become synonymous with the\\n\\\n                      --entry option.\\n\\\n --dir-file=NAME     specify file name of Info directory file;\\n\\\n                      equivalent to using the DIR-FILE argument.\\n\\\n --dry-run           same as --test.\"));\n\n  puts (_(\"\\\n --entry=TEXT        insert TEXT as an Info directory entry,\\n\\\n                      overriding any corresponding entry from DIR-FILE.\\n\\\n                      TEXT is written as an Info menu item line followed\\n\\\n                       by zero or more extra lines starting with whitespace.\\n\\\n                      If you specify more than one entry, all are added.\\n\\\n                      If you don't specify any entries, they are determined\\n\\\n                       from information in the Info file itself.\"));\n\n  puts (_(\"\\\n --help              display this help and exit.\\n\\\n --info-dir=DIR      same as --dir-file=DIR/dir.\\n\\\n --info-file=FILE    specify Info file to install in the directory;\\n\\\n                      equivalent to using the INFO-FILE argument.\\n\\\n --item=TEXT         same as --entry=TEXT.\\n\\\n --keep-old          do not replace entries, or remove empty sections.\"));\n\n  puts (_(\"\\\n --maxwidth, --max-width=COL  wrap description at column COL.\\n\\\n --menuentry=TEXT    same as --name=TEXT.\\n\\\n --name=TEXT         the name of the entry is TEXT; used with --description\\n\\\n                      to become synonymous with the --entry option.\\n\\\n --no-indent         do not format new entries in the DIR file.\\n\\\n --quiet             suppress warnings.\"));\n\n  puts (_(\"\\\n --regex=R           put this file's entries in all sections that match the\\n\\\n                      regular expression R (ignoring case).\\n\\\n --remove            same as --delete.\\n\\\n --remove-exactly    only remove if the info file name matches exactly;\\n\\\n                      suffixes such as .info and .gz are not ignored.\\n\\\n --section=SEC       put entries in section SEC of the directory.\\n\\\n                      If you specify more than one section, all the entries\\n\\\n                       are added in each of the sections.\\n\\\n                      If you don't specify any sections, they are determined\\n\\\n                       from information in the Info file itself;\\n\\\n                       if nothing is available there, the --defsection\\n\\\n                       value is used; if that is not specified, the\\n\\\n                       final default is \\\"Miscellaneous\\\".\\n\\\n --section R SEC     equivalent to --regex=R --section=SEC --add-once.\"));\n\n  puts (_(\"\\\n --silent            suppress warnings.\\n\\\n --test              suppress updating of DIR-FILE.\\n\\\n --version           display version information and exit.\"));\n\n  puts (\"\");\n  \n  puts (_(\"\\\nEmail bug reports to bug-texinfo@gnu.org,\\n\\\ngeneral questions and discussion to help-texinfo@gnu.org.\\n\\\nTexinfo home page: http://www.gnu.org/software/texinfo/\"));\n}",
      "lines": 83,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ensure_dirfile_exists": {
      "start_point": [
        625,
        0
      ],
      "end_point": [
        671,
        1
      ],
      "content": "static void\nensure_dirfile_exists (char *dirfile)\n{\n  int desc;\n  \n  if (chicken_flag)\n    return;\n    \n  desc = open (dirfile, O_RDONLY);\n  if (desc < 0 && errno == ENOENT)\n    {\n      FILE *f;\n      char *readerr = strerror (errno);\n      f = fopen (dirfile, \"w\");\n      if (f)\n        {\n          fprintf (f, _(\"This is the file .../info/dir, which contains the\\n\\\ntopmost node of the Info hierarchy, called (dir)Top.\\n\\\nThe first time you invoke Info you start off looking at this node.\\n\\\n%c\\n\\\n%s\\tThis is the top of the INFO tree\\n\\\n\\n\\\n  This (the Directory node) gives a menu of major topics.\\n\\\n  Typing \\\"q\\\" exits, \\\"H\\\" lists all Info commands, \\\"d\\\" returns here,\\n\\\n  \\\"h\\\" gives a primer for first-timers,\\n\\\n  \\\"mEmacs<Return>\\\" visits the Emacs manual, etc.\\n\\\n\\n\\\n  In Emacs, you can click mouse button 2 on a menu item or cross reference\\n\\\n  to select it.\\n\\\n\\n\\\n%s\\n\\\n\"),         /* These keywords must not be translated:  */\n            '\\x1f',  \"File: dir,\\tNode: Top\",  \"* Menu:\"\n          );\n          if (fclose (f) < 0)\n            pfatal_with_name (dirfile);\n        }\n      else\n        {\n          /* Didn't exist, but couldn't open for writing.  */\n\t  fatal (_(\"%s: could not read (%s) and could not create (%s)\"),\n\t\t dirfile, readerr, strerror (errno));\n        }\n    }\n  else\n    close (desc); /* It already existed, so fine.  */\n}",
      "lines": 47,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "open_possibly_compressed_file": {
      "start_point": [
        686,
        0
      ],
      "end_point": [
        891,
        1
      ],
      "content": "FILE *\nopen_possibly_compressed_file (char *filename,\n    void (*create_callback) (char *),\n    char **opened_filename, char **compression_program) \n{\n  char *local_opened_filename, *local_compression_program;\n  int nread;\n  char data[13];\n  FILE *f;\n\n  /* We let them pass NULL if they don't want this info, but it's easier\n     to always determine it.  */\n  if (!opened_filename)\n    opened_filename = &local_opened_filename;\n\n  *opened_filename = filename;\n  f = fopen (*opened_filename, FOPEN_RBIN);\n  if (!f)\n    {\n      *opened_filename = concat (filename, \".gz\", \"\");\n      f = fopen (*opened_filename, FOPEN_RBIN);\n    }\n  if (!f)\n    {\n      free (*opened_filename);\n      *opened_filename = concat (filename, \".xz\", \"\");\n      f = fopen (*opened_filename, FOPEN_RBIN);\n    }\n  if (!f)\n    {\n      free (*opened_filename);\n      *opened_filename = concat (filename, \".bz2\", \"\");\n      f = fopen (*opened_filename, FOPEN_RBIN);\n    }\n  if (!f)\n    {\n      free (*opened_filename);\n      *opened_filename = concat (filename, \".lz\", \"\");\n      f = fopen (*opened_filename, FOPEN_RBIN);\n    }\n  if (!f)\n    {\n     free (*opened_filename);\n     *opened_filename = concat (filename, \".lzma\", \"\");\n     f = fopen (*opened_filename, FOPEN_RBIN);\n    }\n#ifdef __MSDOS__\n  if (!f)\n    {\n      free (*opened_filename);\n      *opened_filename = concat (filename, \".igz\", \"\");\n      f = fopen (*opened_filename, FOPEN_RBIN);\n    }\n  if (!f)\n    {\n      free (*opened_filename);\n      *opened_filename = concat (filename, \".inz\", \"\");\n      f = fopen (*opened_filename, FOPEN_RBIN);\n    }\n#endif /* __MSDOS__ */\n  if (!f)\n    {\n      /* The file was not found with any extention added.  Try the\n         original file again. */\n      free (*opened_filename);\n      *opened_filename = filename;\n\n      if (create_callback)\n        {\n          /* Create the file if we can.  */\n          (*create_callback) (filename);\n\n          /* And try opening it again.  */\n          f = fopen (*opened_filename, FOPEN_RBIN);\n          if (!f)\n            return 0;\n        }\n      else\n        return 0;\n    }\n\n  /* Read first few bytes of file rather than relying on the filename.\n     If the file is shorter than this it can't be usable anyway.  */\n  nread = fread (data, sizeof (data), 1, f);\n  if (nread != 1)\n    {\n      if (nread == 0)\n        {\n          /* Try to create the file if its empty. */\n          if (feof (f) && create_callback)\n            {\n              if (fclose (f) != 0)\n                return 0; /* unknown error closing file */\n\n              if (remove (filename) != 0)\n                return 0; /* unknown error deleting file */\n\n              (*create_callback) (filename);\n              f = fopen (*opened_filename, FOPEN_RBIN);\n              if (!f)\n                return 0;\n              nread = fread (data, sizeof (data), 1, f);\n              if (nread == 0)\n                return 0;\n              goto determine_file_type; /* success */\n            }\n        }\n      errno = 0;\n      return 0; /* unknown error */\n    }\n\ndetermine_file_type:\n  if (!compression_program)\n    compression_program = &local_compression_program;\n\n  if (data[0] == '\\x1f' && data[1] == '\\x8b')\n#if STRIP_DOT_EXE\n    /* An explicit .exe yields a better diagnostics from popen below\n       if they don't have gzip installed.  */\n    *compression_program = \"gzip.exe\";\n#else\n    *compression_program = \"gzip\";\n#endif\n\n  else if (data[0] == '\\xFD' && data[1] == '7' && data[2] == 'z'\n           && data[3] == 'X' && data[4] == 'Z' && data[5] == 0)\n#ifndef STRIP_DOT_EXE\n    *compression_program = \"xz.exe\";\n#else\n    *compression_program = \"xz\";\n#endif\n\n  else if (data[0] == 'B' && data[1] == 'Z' && data[2] == 'h')\n#ifndef STRIP_DOT_EXE\n    *compression_program = \"bzip2.exe\";\n#else\n    *compression_program = \"bzip2\";\n#endif\n\n  else if (data[0] == 'B' && data[1] == 'Z' && data[2] == '0')\n#ifndef STRIP_DOT_EXE\n    *compression_program = \"bzip.exe\";\n#else\n    *compression_program = \"bzip\";\n#endif\n\n  else if (data[0] == 0x4C && data[1] == 0x5A && data[2] == 0x49\n           && data[3] == 0x50 && data[4] == 1)\t\t/* \"LZIP\" */\n#ifndef STRIP_DOT_EXE\n    *compression_program = \"lzip.exe\";\n#else\n    *compression_program = \"lzip\";\n#endif\n\n    /* We (try to) match against old lzma format (which lacks proper\n       header, two first matches), as well as the new format (last match).  */\n  else if ((data[9] == 0x00 && data[10] == 0x00 && data[11] == 0x00\n            && data[12] == 0x00)\n           || (data[5] == '\\xFF' && data[6] == '\\xFF' && data[7] == '\\xFF'\n               && data[8] == '\\xFF' && data[9] == '\\xFF' && data[10] == '\\xFF'\n               && data[11] == '\\xFF' && data[12] == '\\xFF') \n           || (data[0] == '\\xFF' && data[1] == 'L' && data[2] == 'Z'\n               && data[3] == 'M' && data[4] == 'A' && data[5] == 0x00))\n#ifndef STRIP_DOT_EXE\n    *compression_program = \"lzma.exe\";\n#else\n    *compression_program = \"lzma\";\n#endif\n\n  else\n    *compression_program = NULL;\n\n  /* Seek back over the magic bytes.  */\n  if (fseek (f, 0, 0) < 0)\n    return 0;\n\n  if (*compression_program)\n    { /* It's compressed, so open a pipe.  */\n      char *command = concat (*compression_program, \" -d\", \"\");\n\n      if (fclose (f) < 0)\n        return 0;\n      f = freopen (*opened_filename, FOPEN_RBIN, stdin);\n      if (!f)\n        return 0;\n      f = popen (command, \"r\");\n      if (!f)\n        {\n          /* Used for error message in calling code. */\n          *opened_filename = command;\n          return 0;\n        }\n    }\n  else\n    {\n#if O_BINARY\n      /* Since this is a text file, and we opened it in binary mode,\n         switch back to text mode.  */\n      f = freopen (*opened_filename, \"r\", f);\n      if (! f)\n\treturn 0;\n#endif\n    }\n\n  return f;\n}",
      "lines": 206,
      "depth": 16,
      "decorators": [
        "FILE",
        "*\nopen_possibly_compressed_file (char *filename,\n    void (*create_callback) (char *),\n    char **opened_filename, char **compression_program)",
        "*"
      ]
    },
    "readfile": {
      "start_point": [
        901,
        0
      ],
      "end_point": [
        945,
        1
      ],
      "content": "char *\nreadfile (char *filename, int *sizep,\n    void (*create_callback) (char *), char **opened_filename,\n    char **compression_program)\n{\n  FILE *f;\n  int filled = 0;\n  int data_size = 8192;\n  char *data = xmalloc (data_size);\n\n  /* If they passed the space for the file name to return, use it.  */\n  f = open_possibly_compressed_file (filename, create_callback,\n                                     opened_filename,\n                                     compression_program);\n\n  if (!f)\n    return 0;\n\n  for (;;)\n    {\n      int nread = fread (data + filled, 1, data_size - filled, f);\n      if (nread < 0)\n        return 0;\n      if (nread == 0)\n        break;\n\n      filled += nread;\n      if (filled == data_size)\n        {\n          data_size += 65536;\n          data = xrealloc (data, data_size);\n        }\n    }\n\n  /* We'll end up wasting space if we're not passing the filename back\n     and it is not just FILENAME, but so what.  */\n  /* We need to close the stream, since on some systems the pipe created\n     by popen is simulated by a temporary file which only gets removed\n     inside pclose.  */\n  if (f != stdin)\n    pclose (f);\n\n  *sizep = filled;\n  return data;\n}",
      "lines": 45,
      "depth": 11,
      "decorators": [
        "char",
        "*\nreadfile (char *filename, int *sizep,\n    void (*create_callback) (char *), char **opened_filename,\n    char **compression_program)",
        "*"
      ]
    },
    "output_dirfile": {
      "start_point": [
        952,
        0
      ],
      "end_point": [
        1082,
        1
      ],
      "content": "static void\noutput_dirfile (char *dirfile, int dir_nlines, struct line_data *dir_lines,\n                int n_entries_to_add, struct spec_entry *entries_to_add,\n                struct spec_section *input_sections, char *compression_program)\n{\n  int n_entries_added = 0;\n  int i;\n  FILE *output;\n\n  if (compression_program)\n    {\n      char *command = concat (compression_program, \">\", dirfile);\n      output = popen (command, \"w\");\n    }\n  else\n    output = fopen (dirfile, \"w\");\n\n  if (!output)\n    {\n      perror (dirfile);\n      exit (EXIT_FAILURE);\n    }\n\n  for (i = 0; i <= dir_nlines; i++)\n    {\n      int j;\n\n      /* If we decided to output some new entries before this line,\n         output them now.  */\n      if (dir_lines[i].add_entries_before)\n        for (j = 0; j < n_entries_to_add; j++)\n          {\n            struct spec_entry *this = dir_lines[i].add_entries_before[j];\n            if (this == 0)\n              break;\n            if (n_entries_added >= 1 && \n                !add_entries_into_all_matching_sections)\n              break;\n            fputs (this->text, output);\n            n_entries_added++;\n          }\n      /* If we decided to add some sections here\n         because there are no such sections in the file,\n         output them now.  \n         FIXME:  we add all sections here, but they should\n         be interspersed throughout the DIR file in \n         alphabetic order. */\n      if (dir_lines[i].add_sections_before)\n        {\n          struct spec_section *spec;\n          struct spec_entry *entry;\n          struct spec_entry **entries;\n          int n_entries = 0;\n\n          /* If we specified --add-once, and we've added an entry, then\n             it's time to bail. */\n          if (n_entries_added >= 1 && \n              !add_entries_into_all_matching_sections)\n            break;\n\n          qsort (dir_lines[i].add_sections_before, \n                 dir_lines[i].num_sections_to_add, \n                 sizeof (struct spec_section *), compare_section_names);\n\n          /* Count the entries and allocate a vector for all of them.  */\n          for (entry = entries_to_add; entry; entry = entry->next)\n            n_entries++;\n          entries = ((struct spec_entry **)\n                     xmalloc (n_entries * sizeof (struct spec_entry *)));\n\n          /* Fill the vector ENTRIES with pointers to all the sections,\n             and sort them.  */\n          j = 0;\n          for (entry = entries_to_add; entry; entry = entry->next)\n            entries[j++] = entry;\n          qsort (entries, n_entries, sizeof (struct spec_entry *),\n                 compare_entries_text);\n\n          /* Generate the new sections in alphabetical order.  In each\n             new section, output all of the entries that belong to that\n             section, in alphabetical order.  */\n          for (j = 0; j < dir_lines[i].num_sections_to_add; j++)\n            {\n              spec = dir_lines[i].add_sections_before[j];\n              if (spec->missing)\n                {\n                  int k;\n\n                  putc ('\\n', output);\n                  fputs (spec->name, output);\n                  putc ('\\n', output);\n                  spec->missing = 0;\n                  for (k = 0; k < n_entries; k++)\n                    {\n                      struct spec_section *spec1;\n                      /* Did they at all want this entry to be put into\n                         this section?  */\n                      entry = entries[k];\n                      for (spec1 = entry->entry_sections;\n                           spec1 && spec1 != entry->entry_sections_tail;\n                           spec1 = spec1->next)\n                        {\n                          if (!strcmp (spec1->name, spec->name))\n                            break;\n                        }\n                      if (spec1 && spec1 != entry->entry_sections_tail)\n                        fputs (entry->text, output);\n                    }\n                }\n            }\n\n          n_entries_added++;\n          free (entries);\n        }\n\n      /* Output the original dir lines unless marked for deletion.  */\n      if (i < dir_nlines && !dir_lines[i].delete)\n        {\n          fwrite (dir_lines[i].start, 1, dir_lines[i].size, output);\n          putc ('\\n', output);\n        }\n    }\n\n  /* Some systems, such as MS-DOS, simulate pipes with temporary files.\n     On those systems, the compressor actually gets run inside pclose,\n     so we must call pclose.  */\n  if (compression_program)\n    pclose (output);\n  else\n    fclose (output);\n}",
      "lines": 131,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_input": {
      "start_point": [
        1091,
        0
      ],
      "end_point": [
        1210,
        1
      ],
      "content": "int\nparse_input (const struct line_data *lines, int nlines,\n             struct spec_section **sections, struct spec_entry **entries,\n             int delete_flag) \n{\n  int n_entries = 0;\n  int prefix_length = strlen (\"INFO-DIR-SECTION \");\n  struct spec_section *head = *sections, *tail = NULL;\n  int reset_tail = 0;\n  char *start_of_this_entry = 0;\n  int ignore_sections = *sections != 0;\n  int ignore_entries  = delete_flag ? 0: *entries  != 0;\n\n  int i;\n\n  if (ignore_sections && ignore_entries)\n    return 0;\n\n  for (i = 0; i < nlines; i++)\n    {\n      if (!ignore_sections\n          && !strncmp (\"INFO-DIR-SECTION \", lines[i].start, prefix_length))\n        {\n          struct spec_section *next\n            = (struct spec_section *) xmalloc (sizeof (struct spec_section));\n          next->name = copy_string (lines[i].start + prefix_length,\n                                    lines[i].size - prefix_length);\n          next->next = *sections;\n          next->missing = 1;\n          if (reset_tail)\n            {\n              tail = *sections;\n              reset_tail = 0;\n            }\n          *sections = next;\n          head = *sections;\n        }\n      /* If entries were specified explicitly with command options,\n         ignore the entries in the input file.  */\n      else if (!ignore_entries)\n        {\n          if (!strncmp (\"START-INFO-DIR-ENTRY\", lines[i].start, lines[i].size)\n              && sizeof (\"START-INFO-DIR-ENTRY\") - 1 == lines[i].size)\n            {\n              if (!*sections)\n                {\n                  /* We found an entry, but didn't yet see any sections\n                     specified.  Default to section \"Miscellaneous\".  */\n                  *sections = (struct spec_section *)\n                    xmalloc (sizeof (struct spec_section));\n                  (*sections)->name = \"Miscellaneous\";\n                  (*sections)->next = 0;\n                  (*sections)->missing = 1;\n                  head = *sections;\n                }\n              /* Next time we see INFO-DIR-SECTION, we will reset the\n                 tail pointer.  */\n              reset_tail = 1;\n\n              /* Save start of the entry.  If this is non-zero, we're\n                 already inside an entry, so fail. */\n              if (start_of_this_entry != 0)\n                fatal (_(\"START-INFO-DIR-ENTRY without matching END-INFO-DIR-ENTRY\"));\n              start_of_this_entry = lines[i + 1].start;\n            }\n          else if (start_of_this_entry)\n            {\n              if ((!strncmp (\"* \", lines[i].start, 2)\n                   && lines[i].start > start_of_this_entry)\n                  || (!strncmp (\"END-INFO-DIR-ENTRY\",\n                                lines[i].start, lines[i].size)\n                      && sizeof (\"END-INFO-DIR-ENTRY\") - 1 == lines[i].size))\n                {\n                  /* We found the end of this entry.  Save its contents\n                     in a new entry in the linked list.  */\n                  struct spec_entry *next\n                    = (struct spec_entry *) xmalloc (sizeof (struct spec_entry));\n                  next->text\n                    = copy_string (start_of_this_entry,\n                                   lines[i].start - start_of_this_entry);\n                  next->text_len = lines[i].start - start_of_this_entry;\n                  next->entry_sections = head;\n                  next->entry_sections_tail = tail;\n                  next->missing_basename = 0;\n                  next->next = *entries;\n                  *entries = next;\n                  n_entries++;\n                  if (!strncmp (\"END-INFO-DIR-ENTRY\",\n                                lines[i].start, lines[i].size)\n                      && sizeof (\"END-INFO-DIR-ENTRY\") - 1 == lines[i].size)\n                    start_of_this_entry = 0;\n                  else\n                    start_of_this_entry = lines[i].start;\n                }\n              else if (!strncmp (\"END-INFO-DIR-ENTRY\",\n                                 lines[i].start, lines[i].size)\n                       && sizeof (\"END-INFO-DIR-ENTRY\") - 1 == lines[i].size)\n                fatal (_(\"END-INFO-DIR-ENTRY without matching START-INFO-DIR-ENTRY\"));\n            }\n        }\n    }\n  if (start_of_this_entry != 0)\n    fatal (_(\"START-INFO-DIR-ENTRY without matching END-INFO-DIR-ENTRY\"));\n\n  /* If we ignored the INFO-DIR-ENTRY directives, we need now go back\n     and plug the names of all the sections we found into every\n     element of the ENTRIES list.  */\n  if (ignore_entries && *entries)\n    {\n      struct spec_entry *entry;\n\n      for (entry = *entries; entry; entry = entry->next)\n        {\n          entry->entry_sections = head;\n          entry->entry_sections_tail = tail;\n        }\n    }\n\n  return n_entries;\n}",
      "lines": 120,
      "depth": 21,
      "decorators": [
        "int"
      ]
    },
    "parse_dir_file": {
      "start_point": [
        1215,
        0
      ],
      "end_point": [
        1314,
        1
      ],
      "content": "static void\nparse_dir_file (struct line_data *lines, int nlines, struct node **nodes)\n{\n  int node_header_flag = 0;\n  int i;\n\n  *nodes = 0;\n  for (i = 0; i < nlines; i++)\n    {\n      /* Parse node header lines.  */\n      if (node_header_flag)\n        {\n          int j, end;\n          for (j = 0; j < lines[i].size; j++)\n            /* Find the node name and store it in the `struct node'.  */\n            if (!strncmp (\"Node:\", lines[i].start + j, 5))\n              {\n                char *line = lines[i].start;\n                /* Find the start of the node name.  */\n                j += 5;\n                while (line[j] == ' ' || line[j] == '\\t')\n                  j++;\n                /* Find the end of the node name.  */\n                end = j;\n                while (line[end] != 0 && line[end] != ',' && line[end] != '\\n'\n                       && line[end] != '\\t')\n                  end++;\n                (*nodes)->name = copy_string (line + j, end - j);\n              }\n          node_header_flag = 0;\n        }\n\n      /* Notice the start of a node.  */\n      if (*lines[i].start == 037)\n        {\n          struct node *next = (struct node *) xmalloc (sizeof (struct node));\n\n          next->next = *nodes;\n          next->name = NULL;\n          next->start_line = i;\n          next->end_line = 0;\n          next->menu_start = NULL;\n          next->sections = NULL;\n          next->last_section = NULL;\n\n          if (*nodes != 0)\n            (*nodes)->end_line = i;\n          /* Fill in the end of the last menu section\n             of the previous node.  */\n          if (*nodes != 0 && (*nodes)->last_section != 0)\n            (*nodes)->last_section->end_line = i;\n\n          *nodes = next;\n\n          /* The following line is the header of this node;\n             parse it.  */\n          node_header_flag = 1;\n        }\n\n      /* Notice the lines that start menus.  */\n      if (*nodes != 0 && !strncmp (\"* Menu:\", lines[i].start, 7))\n        (*nodes)->menu_start = lines[i + 1].start;\n\n      /* Notice sections in menus.  */\n      if (*nodes != 0\n          && (*nodes)->menu_start != 0\n          && *lines[i].start != '\\n'\n          && *lines[i].start != '*'\n          && *lines[i].start != ' '\n          && *lines[i].start != '\\t')\n        {\n          /* Add this menu section to the node's list.\n             This list grows in forward order.  */\n          struct menu_section *next\n            = (struct menu_section *) xmalloc (sizeof (struct menu_section));\n\n          next->start_line = i + 1;\n          next->next = 0;\n          next->end_line = 0;\n          next->name = copy_string (lines[i].start, lines[i].size);\n          if ((*nodes)->sections)\n            {\n              (*nodes)->last_section->next = next;\n              (*nodes)->last_section->end_line = i;\n            }\n          else\n            (*nodes)->sections = next;\n          (*nodes)->last_section = next;\n        }\n\n    }\n\n  /* Finish the info about the end of the last node.  */\n  if (*nodes != 0)\n    {\n      (*nodes)->end_line = nlines;\n      if ((*nodes)->last_section != 0)\n        (*nodes)->last_section->end_line = nlines;\n    }\n}",
      "lines": 100,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mark_entry_for_deletion": {
      "start_point": [
        1321,
        0
      ],
      "end_point": [
        1376,
        1
      ],
      "content": "int\nmark_entry_for_deletion (struct line_data *lines, int nlines, char *name)\n{\n  int something_deleted = 0;\n  int i;\n  for (i = 0; i < nlines; i++)\n    {\n      /* Check for an existing entry that should be deleted.\n         Delete all entries which specify this file name.  */\n      if (*lines[i].start == '*')\n        {\n          char *q;\n          char *p = lines[i].start;\n\n          p++; /* skip * */\n          while (*p == ' ') p++; /* ignore following spaces */\n          q = p; /* remember this, it's the beginning of the menu item.  */\n\n          /* Read menu item.  */\n          while (*p != 0 && *p != ':')\n            p++;\n          p++; /* skip : */\n\n          if (*p == ':')\n            { /* XEmacs-style entry, as in * Mew::Messaging.  */\n              if (menu_item_equal (q, ':', name))\n                {\n                  lines[i].delete = 1;\n                  something_deleted = 1;\n                }\n            }\n          else\n            { /* Emacs-style entry, as in * Emacs: (emacs).  */\n              while (*p == ' ') p++; /* skip spaces after : */\n              if (*p == '(')         /* if at parenthesized (FILENAME) */\n                {\n                  p++;\n                  if (menu_item_equal (p, ')', name))\n                    {\n                      lines[i].delete = 1;\n                      something_deleted = 1;\n                    }\n                }\n            }\n        }\n\n      /* Treat lines that start with whitespace\n         as continuations; if we are deleting an entry,\n         delete all its continuations as well.  */\n      else if (i > 0 && (*lines[i].start == ' ' || *lines[i].start == '\\t'))\n        {\n          lines[i].delete = lines[i - 1].delete;\n        }\n    }\n  return something_deleted;\n}",
      "lines": 56,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "adjust_column": {
      "start_point": [
        1384,
        0
      ],
      "end_point": [
        1399,
        1
      ],
      "content": "static size_t\nadjust_column (size_t column, char c)\n{\n  if (c == '\\b')\n    {\n      if (column > 0)\n        column--;\n    }\n  else if (c == '\\r')\n    column = 0;\n  else if (c == '\\t')\n    column += TAB_WIDTH - column % TAB_WIDTH;\n  else                          /* if (isprint (c)) */\n    column++;\n  return column;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "format_entry": {
      "start_point": [
        1408,
        0
      ],
      "end_point": [
        1551,
        1
      ],
      "content": "static int\nformat_entry (char *name, size_t name_len, char *desc, size_t desc_len,\n              int calign, int align, size_t width,\n              char **outstr_out, size_t *outstr_len)\n{\n  int i, j;\n  char c;\n  size_t column = 0;            /* Screen column where next char will go */\n\n  /* Used to collect a line at a time, before transferring to outstr. */\n  static char *line_out = NULL;\n  size_t offset_out = 0;           /* Index in `line_out' for next char. */\n  static size_t allocated_out = 0; /* Space allocated in `line_out'. */\n  char *outstr;\n\n  if (!desc || !name)\n    return 1;\n\n  outstr = xmalloc (width\n         + (desc_len + width) / (width - align) * width * 2 * sizeof (char));\n  outstr[0] = '\\0';\n\n  strncat (outstr, name, name_len);\n\n  column = name_len;\n\n  if (name_len > calign - 2)\n    {\n      /* Name is too long to have description on the same line. */\n      if (desc_len > 1)\n        {\n          strncat (outstr, \"\\n\", 1);\n          column = 0;\n          for (j = 0; j < calign - 1; j++)\n            {\n              column = adjust_column (column, ' ');\n              strncat (outstr, \" \", 1);\n            }\n        }\n    }\n  else\n    for (j = 0; j < calign - name_len - 1; j++)\n      {\n        if (desc_len <= 2)\n          break;\n        column = adjust_column (column, ' ');\n        strncat (outstr, \" \", 1);\n      }\n\n  for (i = 0; i < desc_len; i++)\n    {\n      if (desc_len <= 2)\n        break;\n      c = desc[i];\n      if (offset_out + 1 >= allocated_out)\n        {\n          allocated_out = offset_out + 1;\n          line_out = (char *) xrealloc ((void *)line_out, allocated_out + 1);\n          /* The + 1 here shouldn't be necessary, but a crash was reported\n             for a following strncat call. */\n        }\n\n      if (c == '\\n')\n        {\n          line_out[offset_out++] = c;\n          strncat (outstr, line_out, offset_out);\n          column = offset_out = 0;\n          continue;\n        }\n\n      /* Come here from inside \"column > width\" block below. */\n    rescan:\n      column = adjust_column (column, c);\n\n      if (column > width)\n        {\n          /* This character would make the line too long.\n             Print the line plus a newline, and make this character\n             start the next line. */\n\n          int found_blank = 0;\n          size_t logical_end = offset_out;\n\n          /* Look for the last blank. */\n          while (logical_end)\n            {\n              --logical_end;\n              if (line_out[logical_end] == ' '\n                  || line_out[logical_end] == '\\t')\n                {\n                  found_blank = 1;\n                  break;\n                }\n            }\n\n          if (found_blank)\n            {\n              size_t i;\n\n              /* Found a blank.  Don't output the part after it. */\n              logical_end++;\n              strncat (outstr, line_out, logical_end);\n              strncat (outstr, \"\\n\", 1);\n              for (j = 0; j < align - 1; j++)\n                {\n                  column = adjust_column (column, ' ');\n                  strncat (outstr, \" \", 1);\n                }\n\n              /* Move the remainder to the beginning of the next \n                 line.\n                 The areas being copied here might overlap. */\n              memmove (line_out, line_out + logical_end,\n                       offset_out - logical_end);\n              offset_out -= logical_end;\n              for (column = i = 0; i < offset_out; i++)\n                column = adjust_column (column, line_out[i]);\n              goto rescan;\n            }\n\n          if (offset_out == 0)\n            {\n              line_out[offset_out++] = c;\n              continue;\n            }\n\n          line_out[offset_out++] = '\\n';\n          strncat (outstr, line_out, offset_out);\n          column = offset_out = 0;\n          goto rescan;\n        }\n      line_out[offset_out++] = c;\n    }\n\n  if (desc_len <= 2)\n    strncat (outstr, \"\\n\", 1);\n\n  if (offset_out)\n    strncat (outstr, line_out, offset_out);\n\n  *outstr_out = outstr;\n  *outstr_len = strlen (outstr);\n  return 1;\n}",
      "lines": 144,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "split_entry": {
      "start_point": [
        1557,
        0
      ],
      "end_point": [
        1643,
        1
      ],
      "content": "static void\nsplit_entry (const char *entry, char **name, size_t *name_len,\n             char **description, size_t *description_len)\n{\n  char *endptr;\n\n  /* on the first line, the description starts after the first \". \";\n     that's a period and space -- our heuristic to handle item names like\n     \"config.status\", and node names like \"config.status Invocation\".\n     Also accept period-tab and period-newline.  */\n  char *ptr = strchr (entry, '.');\n  while (ptr && ptr[1] != ' ' && ptr[1] != '\\t' && ptr[1] != '\\n') {\n    ptr = strchr (ptr + 1, '.');\n  }\n  \n  /* Maybe there's no period, and no description */\n  if (!ptr)\n    {\n      size_t length = strlen (entry);\n      if (length == 0)\n        return;\n      *name = strdup (entry);\n      *name_len = length + 1;\n      return;\n    }\n\n  /* The name is everything up to and including the period. */\n  *name_len = (size_t) (ptr - entry + 1);\n  *name = xmalloc (*name_len + 1);\n  (*name)[0] = '\\0';\n  strncat (*name, entry, *name_len);\n\n  ptr++;\n  *description = xmalloc (strlen (entry));\n  (*description)[0] = '\\0';\n\n  while (ptr[0] != '\\0')\n    {\n      /* Eat up the whitespace after the name, and at the start of a line. */\n      while (isspace(ptr[0]))\n        ptr++;\n\n      /* Okay, we're at the start of the description. */\n      if (ptr[0] == '\\0')\n        continue;\n\n      /* See how far the description goes... */\n      endptr = strchr (ptr, '\\n');\n      /* Either the description continues up to the next newline. */\n      if (endptr)\n        {\n          size_t length  = (size_t) (endptr - ptr) / sizeof (char);\n          strncat (*description, ptr, length);\n          ptr = endptr;\n          /* First of all, we eat the newline here.  But then what?\n             Sometimes the newline separates 2 sentences, so we\n             end up with the next word starting directly after the period,\n             instead of after the customary 2 spaces in english. \n             If the previous character was a `.', then we should add 2\n             spaces if there is anything on the next line.\n             if it's a comma, then we should put one space.\n             If it's neither, we just put a space.\n             If it's some other whitespace, we shouldn't do anything. */\n          ptr++;\n          if (length > 1 && strlen (ptr) > 0)\n            {\n              endptr--;\n              /* *ENDPTR is the 2nd last character */\n              if (*endptr == '.')\n                strncat (*description, \"  \", 2);\n              else if (!isspace (*endptr))\n                strncat (*description, \" \", 1);\n            }\n        }\n      /* Or the description continues to the end of the string. */\n      else\n        {\n          /* Just show the rest when there's no newline. */\n          size_t length = strlen (ptr);\n          strncat (*description, ptr, length);\n          ptr += length;\n        }\n    }\n  /* Descriptions end in a new line. */\n  strncat (*description, \"\\n\", 1);\n  *description_len = strlen (*description);\n}",
      "lines": 87,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "reformat_new_entries": {
      "start_point": [
        1652,
        0
      ],
      "end_point": [
        1700,
        1
      ],
      "content": "static void\nreformat_new_entries (struct spec_entry *entries, int calign_cli, int align_cli, \n                      int maxwidth_cli)\n{\n  struct spec_entry *entry;\n  for (entry = entries; entry; entry = entry->next)\n    {\n      int calign = -1, align = -1, maxwidth = -1;\n      char *name = NULL, *desc = NULL;\n      size_t name_len = 0, desc_len = 0;\n      split_entry (entry->text, &name, &name_len, &desc, &desc_len);\n      free (entry->text);\n\n      /* Specify sane defaults if we need to */\n      if (calign_cli == -1 || align_cli == -1)\n        {\n          struct spec_section *section;\n          calign = calign_cli;\n          align = align_cli;\n          for (section = entry->entry_sections; \n               section && section != entry->entry_sections_tail;\n               section = section->next)\n            {\n              if (!strcmp (section->name, \"Individual utilities\"))\n                {\n                  if (calign == -1)\n                    calign = 48 + 1;\n                  if (align == -1)\n                    align = 50 + 1;\n                  break;\n                }\n            }\n          if (calign == -1)\n            calign = 32 + 1;\n          if (align == -1)\n            align = 34 + 1;\n        }\n      else\n        {\n          calign = calign_cli;\n          align = align_cli;\n        }\n\n      maxwidth = maxwidth_cli == -1 ? 79 : maxwidth_cli; \n\n      format_entry (name, name_len, desc, desc_len, calign, align, \n                    maxwidth, &entry->text, &entry->text_len);\n    }\n}",
      "lines": 49,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "add_missing_basenames": {
      "start_point": [
        1706,
        0
      ],
      "end_point": [
        1735,
        1
      ],
      "content": "void\nadd_missing_basenames (struct spec_entry *entries, char *name)\n{\n  struct spec_entry *entry;\n  for (entry = entries; entry; entry = entry->next)\n    {\n      if (entry->missing_basename)\n        {\n          /* Insert NAME into the right place in ENTRY->TEXT. */\n          char *info, *rest, *text;\n          size_t name_len = strlen (name);\n          char *ptr = strstr (entry->text, \": (). \");\n          if (!ptr)\n            return;\n          ptr[0] = '\\0';\n          rest = ptr += strlen (\": (). \");\n\n          info = xmalloc (name_len + 7);\n          snprintf (info, name_len + 7, \": (%s). \", name);\n          text = concat (entry->text, info, rest);\n          free (info);\n          if (entry->text)\n            free (entry->text);\n          entry->text = text;\n          entry->text_len = strlen (entry->text);\n          entry->missing_name = 0;\n          entry->missing_basename = 0;\n        }\n    }\n}",
      "lines": 30,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "add_missing_names": {
      "start_point": [
        1741,
        0
      ],
      "end_point": [
        1777,
        1
      ],
      "content": "void\nadd_missing_names (struct spec_entry *entries, char *name)\n{\n  struct spec_entry *entry;\n  for (entry = entries; entry; entry = entry->next)\n    {\n      if (entry->missing_name)\n        {\n          char *text;\n          /* Prepend NAME onto ENTRY->TEXT. */\n          int add_nl = 1;\n          if (entry->text)\n            if (entry->text[entry->text_len - 1] == '\\n')\n              add_nl = 0;\n\n          if (name[0] == '*')\n            text = concat (name, entry->text == NULL ? \"\" : entry->text, \n                           add_nl ? \"\\n\" : \"\");\n          else\n            {\n              size_t full_name_len = strlen (name) * 2 + 9;\n              char *full_name = xmalloc (full_name_len);\n              snprintf (full_name, full_name_len, \"* %s: (%s).\", name, name);\n              text = concat (full_name, \n                             entry->text == NULL ? \"\" : entry->text, \n                             add_nl ? \"\\n\" : \"\");\n              free (full_name);\n            }\n          if (entry->text)\n            free (entry->text);\n          entry->text = text;\n          entry->text_len = strlen (entry->text);\n          entry->missing_name = 0;\n          entry->missing_basename = 0;\n        }\n    }\n}",
      "lines": 37,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "add_missing_descriptions": {
      "start_point": [
        1781,
        0
      ],
      "end_point": [
        1803,
        1
      ],
      "content": "void\nadd_missing_descriptions (struct spec_entry *entries, char *desc)\n{\n  struct spec_entry *entry;\n  for (entry = entries; entry; entry = entry->next)\n    {\n      if (entry->missing_description)\n        {\n          char *text;\n          int add_nl = 1;\n          if (strlen (desc) > 1)\n            if (desc[strlen (desc) - 1] == '\\n')\n              add_nl = 0;\n          /* Append DESC onto ENTRY->TEXT. */\n          text = concat (entry->text == NULL ? \"\" : entry->text, desc,\n                               add_nl ? \"\\n\" : \"\");\n          if (entry->text)\n            free (entry->text);\n          entry->text = text;\n          entry->text_len = strlen (entry->text);\n        }\n    }\n}",
      "lines": 23,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "munge_old_style_debian_options": {
      "start_point": [
        1814,
        0
      ],
      "end_point": [
        1900,
        1
      ],
      "content": "static int\nmunge_old_style_debian_options (int argc, char **argv, \n                                int *new_argc, char ***new_argv)\n{\n  char *opt = NULL;\n  int i, err;\n  char *argz = NULL;\n  size_t argz_len = 0;\n  const char *regex, *title;\n  int munge = 0;\n\n  /* Flip through the options to detect the old `--section REGEX TITLE' \n     syntax */\n  for (i = 0; i < argc; i++)\n    {\n      if (strcmp (argv[i], \"--section\") == 0)\n        {\n          FILE *fileptr;\n          /* Go forward one arg and obtain the REGEX. */\n          if (i + 1 < argc)\n            i++;\n          else\n            return -1;\n          regex = argv[i];\n          /* Go forward another arg and obtain the TITLE. */\n          if (i + 1 < argc)\n            i++;\n          else\n            return -1;\n          title = argv[i];\n          /* When the title starts with a `-' it's probably an option,\n             and not a title. */\n          if (title[0] == '-')\n            break;\n          /* When the title is a filename it's probably an Info file, or\n             a dir file, and not a title. */\n          fileptr = fopen (title, \"r\");\n          if (fileptr)\n            {\n              fclose (fileptr);\n              break;\n            }\n          /* Okay, it looks like we're using the old debian syntax \n             for --section. */\n          munge = 1;\n        \n          /* Okay, we munge the options to look like this:\n             --regex=REGEX --section=TITLE --add-once */\n          opt = xmalloc (strlen (regex) + sizeof (\"--regex=\"));\n          if (sprintf (opt, \"--regex=%s\", regex) == -1)\n            err = 1;\n          if (!err)\n            err = argz_add (&argz, &argz_len, opt);\n          free (opt); opt = NULL;\n\n          opt = xmalloc (strlen (title) + sizeof (\"--section=\"));\n          if (sprintf (opt, \"--section=%s\", title) == -1)\n            err = 1;\n          if (!err)\n            err = argz_add (&argz, &argz_len, opt);\n          free (opt); opt = NULL;\n\n          if (!err)\n            err = argz_add (&argz, &argz_len, \"--add-once\");\n        }\n      else\n        err = argz_add (&argz, &argz_len, argv[i]); \n      if (err)\n        return -1;\n    }\n\n  if (munge)\n    {\n      *new_argc = argz_count (argz, argz_len);\n      *new_argv = xmalloc ((*new_argc + 1) * sizeof (char *));\n\n      opt = NULL; i = 0;\n      while ((opt = argz_next (argz, argz_len, opt)))\n        {\n          (*new_argv)[i] = xstrdup (opt);\n          i++;\n        }\n      (*new_argv)[*new_argc] = NULL;\n    }\n  free (argz);\n  return munge;\n}",
      "lines": 87,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        1903,
        0
      ],
      "end_point": [
        2710,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  char *opened_dirfilename;\n  char *compression_program;\n  char *infile_sans_info;\n  char *infile = 0, *dirfile = 0;\n  int calign = -1;\n  int align  = -1;\n  int maxwidth = -1;\n\n  /* Record the text of the Info file, as a sequence of characters\n     and as a sequence of lines.  */\n  char *input_data = NULL;\n  int input_size = 0;\n  struct line_data *input_lines = NULL;\n  int input_nlines = 0;\n\n  /* Record here the specified section names and directory entries.  */\n  struct spec_section *input_sections = NULL;\n  struct spec_entry *entries_to_add = NULL;\n  struct spec_entry *entries_to_add_from_file = NULL;\n  int n_entries_to_add = 0;\n  struct spec_entry *default_entries_to_add = NULL;\n  int n_default_entries_to_add = 0;\n\n  /* Record the old text of the dir file, as plain characters,\n     as lines, and as nodes.  */\n  char *dir_data;\n  int dir_size;\n  int dir_nlines;\n  struct line_data *dir_lines;\n  struct node *dir_nodes;\n\n  /* Nonzero means --delete was specified (just delete existing entries).  */\n  int delete_flag = 0;\n  int something_deleted = 0;\n\n  /* Nonzero means -quiet/--silent was specified.  */\n  int quiet_flag = 0;\n\n  /* Nonzero means --debug was specified.  */\n  int debug_flag = 0;\n\n  int i;\n\n#ifdef HAVE_SETLOCALE\n  /* Set locale via LC_ALL.  */\n  setlocale (LC_ALL, \"\");\n#endif\n\n  /* Set the text message domain.  */\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  /* Make sure standard input can be freopened at will.  Otherwise,\n     when stdin starts off closed, bad things could happen if a plain fopen\n     returns stdin before open_possibly_compressed_file freopens it.  */\n  if (! freopen (NULL_DEVICE, \"r\", stdin))\n    pfatal_with_name (NULL_DEVICE);\n\n  munge_old_style_debian_options (argc, argv, &argc, &argv);\n\n  while (1)\n    {\n      int opt = getopt_long (argc, argv, \n                             \"i:d:e:s:t:E:c:C:W:A:hHrk1Ia\", longopts, 0);\n\n      if (opt == EOF)\n        break;\n\n      switch (opt)\n        {\n        case 0:\n          /* If getopt returns 0, then it has already processed a\n             long-named option.  We should do nothing.  */\n          break;\n\n        case 1:\n          abort ();\n\n        case '1':\n          add_entries_into_all_matching_sections = 0;\n          break;\n\n        case 'a':\n          order_new_sections_alphabetically_flag = 0;\n          break;\n\n        case 'A':\n          {\n            char *end = NULL;\n            unsigned long int val;\n            val = strtoul (optarg, &end, 0);\n            if (end == NULL || end == optarg || *end != '\\0')\n              suggest_asking_for_help ();\n            align = val;\n            if (align <= 0)\n              suggest_asking_for_help ();\n          }\n          break;\n\n        case 'c':\n        \n          {\n            struct spec_entry *next;\n            size_t length = strlen (optarg);\n\n            if (!entries_to_add)\n              {\n                next = \n                  (struct spec_entry *) xmalloc (sizeof (struct spec_entry));\n            \n                next->text = NULL;\n                next->text_len = 0;\n                next->entry_sections = NULL;\n                next->entry_sections_tail = NULL;\n                next->missing_name = 1;\n                next->missing_basename = 1;\n                next->next = entries_to_add;\n                entries_to_add = next;\n                n_entries_to_add++;\n              }\n            else\n              next = entries_to_add;\n                \n            next->missing_description = 0;\n            if (next->text)\n              {\n                char *nl = strrchr (next->text, '\\n');\n                if (nl)\n                  nl[0] = '\\0';\n              }\n            /* Concat the description onto the current entry, adding a \n               newline if we need one.  Prepend a space if we have no\n               previous text, since eventually we will be adding the\n               \"* foo ().\" and we want to end up with a \". \" for parsing.  */\n            next->text = concat (next->text ? next->text : \" \",\n                                 optarg, \n                                 optarg[length - 1] == '\\n' ? \"\" : \"\\n\");\n            next->text_len = strlen (next->text);\n          }\n          break;\n\n        case 'C':\n          {\n            char *end = NULL;\n            unsigned long int val;\n            val = strtoul (optarg, &end, 0);\n            if (end == NULL || end == optarg || *end != '\\0')\n              suggest_asking_for_help ();\n            calign = val;\n            if (calign <= 0)\n              suggest_asking_for_help ();\n          }\n          break;\n\n        case 'd':\n          if (dirfile)\n            {\n              fprintf (stderr, _(\"%s: already have dir file: %s\\n\"),\n                       progname, dirfile);\n              suggest_asking_for_help ();\n            }\n          dirfile = optarg;\n          break;\n\n        case 'D':\n          if (dirfile)\n            {\n              fprintf (stderr, _(\"%s: already have dir file: %s\\n\"),\n                       progname, dirfile);\n              suggest_asking_for_help ();\n            }\n          dirfile = concat (optarg, \"\", \"/dir\");\n          break;\n\n        case 't':\n          {\n            struct spec_entry *next\n              = (struct spec_entry *) xmalloc (sizeof (struct spec_entry));\n\n            size_t length;\n            if (optarg[0] != '*')\n              {\n                /* Make enough space for \"* foo: (). \". */\n                length = strlen (optarg) + 9;\n                next->text = xmalloc (length);\n                snprintf (next->text, length, \"* %s: (). \", optarg);\n                next->missing_basename = 1;\n                /* The basename will be inserted in between the parentheses\n                   at a later time.  See add_missing_basenames. */\n              }\n            else\n              {\n                /* Make enough space for \"foo \". */\n                length = strlen (optarg) + 2;\n                next->text = xmalloc (length);\n                snprintf (next->text, length, \"%s \", optarg);\n                next->missing_basename = 0;\n                /* FIXME: check for info entry correctness in TEXT. \n                   e.g. `* Aaa: (bbb).' */\n              }\n\n            next->text_len = length - 1;\n            next->entry_sections = NULL;\n            next->entry_sections_tail = NULL;\n            next->next = entries_to_add;\n            next->missing_name = 0;\n            next->missing_description = 1;\n            entries_to_add = next;\n            n_entries_to_add++;\n          }\n          break;\n\n\tcase 'E':\n        case 'e':\n          {\n            struct spec_entry *next\n              = (struct spec_entry *) xmalloc (sizeof (struct spec_entry));\n            int olen = strlen (optarg);\n            if (! (*optarg != 0 && optarg[olen - 1] == '\\n'))\n              {\n                optarg = concat (optarg, \"\\n\", \"\");\n                olen++;\n              }\n            next->text = optarg;\n            next->text_len = olen;\n            next->entry_sections = NULL;\n            next->entry_sections_tail = NULL;\n            next->missing_name = 0;\n            next->missing_basename = 0;\n            next->missing_description = 0;\n\t    if (opt == 'e')\n  \t      {\n\t\tnext->next = entries_to_add;\n\t\tentries_to_add = next;\n\t\tn_entries_to_add++;\n\t      } \n\t    else\n\t      {\n\t        /* Although this list is maintained, nothing is ever\n\t           done with it.  So it seems no one cares about the\n\t           feature.  The intended --help string was:\n --defentry=TEXT     like --entry, but only use TEXT if an entry\\n\\\n                      is not present in INFO-FILE.\\n\\\n                   in case anyone ever wants to finish it.  */\n\t\tnext->next = default_entries_to_add;\n\t\tdefault_entries_to_add = next;\n\t\tn_default_entries_to_add++;\n\t      }\n          }\n          break;\n\n        case 'g':\n          debug_flag = 1;\n          break;\n\n        case 'h':\n        case 'H':\n          print_help ();\n          exit (EXIT_SUCCESS);\n\n        case 'i':\n          if (infile)\n            {\n              fprintf (stderr, _(\"%s: Specify the Info file only once.\\n\"),\n                       progname);\n              suggest_asking_for_help ();\n            }\n          infile = optarg;\n          break;\n\n        case 'I':\n          indent_flag = 0;\n          break;\n\n        case 'k':\n          keep_old_flag = 1;\n          break;\n\n        case 'n':\n          chicken_flag = 1;\n          break;\n\n        case 'q':\n          quiet_flag = 1;\n          break;\n\n        case 'r':\n          delete_flag = 1;\n          break;\n\n        case 'R':\n          {\n            int error;\n            if (psecreg)\n              {\n                warning \n                  (_(\"Extra regular expression specified, ignoring `%s'\"),\n                   optarg);\n                break;\n              }\n            psecreg = (regex_t *) xmalloc (sizeof (regex_t));\n\n            error = regcomp (psecreg, optarg, REG_ICASE|REG_NOSUB);\n            if (error != 0)\n              {\n                int errbuf_size = regerror (error, psecreg, NULL, 0);\n                char *errbuf = (char *) xmalloc (errbuf_size);\n                regerror (error, psecreg, errbuf, errbuf_size);\n                fatal (_(\"Error in regular expression `%s': %s\"),\n\t\t       optarg, errbuf);\n              };\n          }\n          break;\n\n\tcase 'S':\n\t  default_section = optarg;\n\t  break;\n\n        case 's':\n          {\n            struct spec_section *next\n              = (struct spec_section *) xmalloc (sizeof (struct spec_section));\n            next->name = optarg;\n            next->next = input_sections;\n            next->missing = 1;\n            input_sections = next;\n          }\n          break;\n\n        case 'V':\n          printf (\"install-info (GNU %s) %s\\n\", PACKAGE, VERSION);\n          puts (\"\");\n          printf (_(\"Copyright (C) %s Free Software Foundation, Inc.\\n\\\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\\n\\\nThis is free software: you are free to change and redistribute it.\\n\\\nThere is NO WARRANTY, to the extent permitted by law.\\n\"),\n              \"2016\");\n          exit (EXIT_SUCCESS);\n\n        case 'W':\n          {\n            char *end = NULL;\n            unsigned long int val;\n            val = strtoul (optarg, &end, 0);\n            if (end == NULL || end == optarg || *end != '\\0')\n              suggest_asking_for_help ();\n            maxwidth = val;\n            if (maxwidth <= 0)\n              suggest_asking_for_help ();\n          }\n          break;\n\n        case 'x':\n          delete_flag = 1;\n          remove_exactly = 1;\n          break;\n\n        default:\n          suggest_asking_for_help ();\n        }\n    }\n\n  /* Interpret the non-option arguments as file names.  */\n  for (; optind < argc; ++optind)\n    {\n      if (infile == 0)\n        infile = argv[optind];\n      else if (dirfile == 0)\n        dirfile = argv[optind];\n      else\n        error (_(\"excess command line argument `%s'\"), argv[optind]);\n    }\n\n  if (!infile)\n    fatal (_(\"No input file specified; try --help for more information.\"));\n  if (!dirfile)\n    fatal (_(\"No dir file specified; try --help for more information.\"));\n\n  /* Now read in the Info dir file.  */\n  if (debug_flag)\n    printf (\"debug: reading dir file %s\\n\", dirfile);\n\n  if (!delete_flag)\n    {\n      dir_data = readfile (dirfile, &dir_size, ensure_dirfile_exists,\n                           &opened_dirfilename, &compression_program);\n      if (!dir_data)\n        pfatal_with_name (opened_dirfilename);\n    }\n  else\n    {\n      /* For \"--remove\" operation, it is not an error for the dir file\n         not to exist. */\n      dir_data = readfile (dirfile, &dir_size, NULL,\n                           &opened_dirfilename, &compression_program);\n      if (!dir_data)\n        {\n          warning (_(\"Could not read %s.\"), opened_dirfilename);\n          exit (EXIT_SUCCESS);\n        }\n    }\n\n  dir_lines = findlines (dir_data, dir_size, &dir_nlines);\n\n  parse_dir_file (dir_lines, dir_nlines, &dir_nodes);\n\n  if (!delete_flag)\n    {\n      /* Find which sections match our regular expression. */\n      if (psecreg)\n        {\n          struct node *node;\n          struct menu_section *section;\n          for (node = dir_nodes; node ; node = node->next)\n            for (section = node->sections; section ; section = section->next)\n              if (regexec (psecreg, section->name, 0, NULL, 0) == 0)\n                {\n                  /* we have a match! */\n                  struct spec_section *next = \n                    (struct spec_section *) xmalloc \n                    (sizeof (struct spec_section));\n                  next->name = section->name;\n                  next->next = input_sections;\n                  next->missing = 0;\n                  input_sections = next;\n                }\n        }\n\n    }\n\n  /* We will be comparing the entries in the dir file against the\n     current filename, so need to strip off any directory prefix and/or\n     [.info][.gz] suffix.  */\n  if (!remove_exactly) {\n    char *infile_basename = infile + strlen (infile);\n\n    if (HAVE_DRIVE (infile))\n      infile += 2;      /* get past the drive spec X: */\n\n    while (infile_basename > infile && !IS_SLASH (infile_basename[-1]))\n      infile_basename--;\n\n    infile_sans_info = strip_info_suffix (infile_basename);\n  } else\n    infile_sans_info = xstrdup(infile);\n\n  /* Now Read the Info file and parse it into lines, unless we're \n     removing exactly.  */\n  if (!remove_exactly)\n    {\n      char *opened_infilename;\n\n      if (debug_flag)\n        printf (\"debug: reading input file %s\\n\", infile);\n      input_data = readfile (infile, &input_size, NULL,\n                             &opened_infilename, NULL);\n      if (!input_data)\n        pfatal_with_name (opened_infilename);\n      input_lines = findlines (input_data, input_size, &input_nlines);\n    }\n\n  i = parse_input (input_lines, input_nlines,\n                   &input_sections, &entries_to_add_from_file, delete_flag);\n  if (!delete_flag)\n    {\n      /* If there are no entries on the command-line at all, use the entries\n         found in the Info file itself (if any). */\n      if (entries_to_add == NULL)\n        {\n          entries_to_add = entries_to_add_from_file;\n          n_entries_to_add = i;\n        }\n      /* There are entries on the command-line, and they override the entries\n         found in the Info file. */\n      else if (entries_to_add)\n        {\n          if (entries_to_add_from_file == NULL)\n            {\n              /* No entries found in the file anyway.  Fill in any \n                 missing names with the info file's basename.  We're out\n                 of luck for any missing descriptions. */\n              add_missing_names (entries_to_add, infile_sans_info);\n              /* add_missing_descriptions (entries_to_add, \"\\n\"); */\n            }\n          else\n            {\n              /* Fill in any missing names or descriptions with what was\n                 found in the Info file. */\n              char *desc = NULL;\n              size_t desc_len = 0;\n              char *name = NULL;\n              size_t name_len = 0;\n              split_entry (entries_to_add_from_file->text, &name, &name_len,\n                           &desc, &desc_len);\n              if (name)\n                {\n                  /* If the name doesn't look right, bail and use the \n                     name based on the Info file. */\n                  if (name[0] != '*')\n                    add_missing_names (entries_to_add, infile_sans_info);\n                  else\n                    add_missing_names (entries_to_add, name);\n                  free (name);\n                }\n\n              if (desc)\n                {\n                  add_missing_descriptions (entries_to_add, desc);\n                  free (desc);\n                }\n            }\n        }\n            \n      /* Lastly, fill in any missing basenames that might still be hanging\n         around from --name options on the command-line. */\n      add_missing_basenames (entries_to_add, infile_sans_info);\n\n      /* Reformat the new entries if we're doing that. */\n      if (indent_flag)\n        {\n          char *no_indent = getenv (\"INSTALL_INFO_NO_INDENT\");\n          if (!no_indent)\n            reformat_new_entries (entries_to_add, calign, align, maxwidth);\n        }\n\n      /* If we got no sections, use the --defsection value if it was\n         given, else \"Miscellaneous\".  */ \n      if (input_sections == NULL)\n        {\n          input_sections = (struct spec_section *)\n            xmalloc (sizeof (struct spec_section));\n          input_sections->name = default_section ? default_section\n                                                 : \"Miscellaneous\";\n          input_sections->next = NULL;\n          input_sections->missing = 1;\n        }\n\n      if (entries_to_add == 0)\n        { /* No need to abort here, the original info file may not\n             have the requisite Texinfo commands.  This is not\n             something an installer should have to correct (it's a\n             problem for the maintainer), and there's no need to cause\n             subsequent parts of `make install' to fail.  */\n          if (!quiet_flag)\n            warning (_(\"no info dir entry in `%s'\"), infile);\n          exit (EXIT_SUCCESS);\n        }\n\n      /* If the entries came from the command-line arguments, their\n         entry_sections pointers are not yet set.  Walk the chain of\n         the entries and for each entry update entry_sections to point\n         to the head of the list of sections where this entry should\n         be put.  Note that all the entries specified on the command\n         line get put into ALL the sections we've got, either from the\n         Info file, or (under --section) from the command line,\n         because in the loop below every entry inherits the entire\n         chain of sections.  */\n      if (n_entries_to_add > 0 && entries_to_add->entry_sections == NULL)\n        {\n          struct spec_entry *ep;\n\n          for (ep = entries_to_add; ep; ep = ep->next)\n            ep->entry_sections = input_sections;\n        }\n    }\n\n  if (delete_flag)\n    {\n      something_deleted = mark_entry_for_deletion (dir_lines, dir_nlines, \n                                                   infile_sans_info);\n      if (!something_deleted && !remove_exactly)\n        {\n          struct spec_entry *entry;\n          for (entry = entries_to_add; entry; entry = entry->next)\n            {\n              /* If the entry came from the info file... */\n              if (entry->entry_sections != NULL)\n                {\n                  char *name = extract_menu_item_name (entry->text);\n                  something_deleted = \n                    mark_entry_for_deletion (dir_lines, dir_nlines, name);\n                  free (name);\n                }\n            }\n      \n          if (!something_deleted)\n            {\n              struct spec_entry *entry;\n              for (entry = entries_to_add; entry; entry = entry->next)\n                {\n                  /* If the entry came from the command-line... */\n                  if (entry->entry_sections == NULL)\n                    something_deleted = \n                      mark_entry_for_deletion (dir_lines, dir_nlines, \n                                               entry->text);\n                }\n            }\n        }\n    }\n    \n  /* Check for sections with zero entries and mark them for deletion. */\n  if (delete_flag && something_deleted && !keep_old_flag)\n    {\n      struct node *node;\n      struct menu_section *section;\n      int section_empty;\n\n      for (node = dir_nodes; node ; node = node->next)\n        for (section = node->sections; section ; section = section->next)\n          {\n            section_empty = 1;\n            for (i = section->end_line; i > section->start_line; i--)\n              {\n                if (dir_lines[i - 1].delete == 0 && \n                    dir_lines[i - 1].size != 0)\n                  {\n                    section_empty = 0;\n                    break;\n                  }\n              }\n\n            if (section_empty)\n              {\n                /* This gets rid of any trailing empty lines at the end  \n                   of the section, and the title too. */\n                for (i = section->end_line; i >= section->start_line; i--)\n                  dir_lines[i - 1].delete = 1;\n              }\n          }\n    }\n\n  /* Decide where to add the new entries (unless --delete was used).\n     Find the menu sections to add them in.\n     In each section, find the proper alphabetical place to add\n     each of the entries.  */\n  if (!delete_flag)\n    {\n      struct node *node;\n      struct menu_section *section;\n      struct spec_section *spec;\n\n      for (node = dir_nodes; node; node = node->next)\n        for (section = node->sections; section; section = section->next)\n          {\n            for (i = section->end_line; i > section->start_line; i--)\n              if (dir_lines[i - 1].size != 0)\n                break;\n            section->end_line = i;\n\n            for (spec = input_sections; spec; spec = spec->next)\n              if (!strcmp (spec->name, section->name))\n                break;\n            if (spec)\n              {\n                int add_at_line = section->end_line;\n                struct spec_entry *entry;\n                /* Say we have found at least one section with this name,\n                   so we need not add such a section.  */\n                spec->missing = 0;\n                /* For each entry, find the right place in this section\n                   to add it.  */\n                for (entry = entries_to_add; entry; entry = entry->next)\n                  {\n                    /* Did they at all want this entry to be put into\n                       this section?  */\n                    for (spec = entry->entry_sections;\n                         spec && spec != entry->entry_sections_tail;\n                         spec = spec->next)\n                      {\n                        if (!strcmp (spec->name, section->name))\n                          break;\n                      }\n                    if (!spec || spec == entry->entry_sections_tail)\n                      continue;\n\n                    /* Subtract one because dir_lines is zero-based,\n                       but the `end_line' and `start_line' members are\n                       one-based.  */\n                    for (i = section->end_line - 1;\n                         i >= section->start_line - 1; i--)\n                      {\n                        /* If an entry exists with the same name,\n                           and was not marked for deletion\n                           (which means it is for some other file),\n                           we are in trouble.  */\n                        if (dir_lines[i].start[0] == '*'\n                            && menu_line_equal (entry->text, entry->text_len,\n                                                dir_lines[i].start,\n                                                dir_lines[i].size)\n                            && !dir_lines[i].delete)\n                          {\n                            if (keep_old_flag)\n                              {\n                                add_at_line = -1;\n                                break;\n                              }\n                            else\n                              {\n                                int j;\n                                dir_lines[i].delete = 1;\n                                for (j = i + 1; j < section->end_line; j++)\n                                  {\n                                    if (dir_lines[j].start[0] == '*')\n                                      break;\n                                    dir_lines[j].delete = 1;\n                                  }\n                              }\n                          }\n                        if (dir_lines[i].start[0] == '*'\n                            && menu_line_lessp (entry->text, entry->text_len,\n                                                dir_lines[i].start,\n                                                dir_lines[i].size))\n                          add_at_line = i;\n                      }\n                    if (add_at_line < 0)\n                      continue;\n                    insert_entry_here (entry, add_at_line,\n                                       dir_lines, n_entries_to_add);\n                  }\n              }\n          }\n\n    }\n  /* Decide where to add the new sections (unless --delete was used).\n     Alphabetically find the menu sections to add them before.  */\n  if (!delete_flag)\n    {\n      struct node *node;\n      struct node *top = NULL;\n\n      /* Find the `Top' node. */\n      for (node = dir_nodes; node; node = node->next)\n        if (node->name && strcmp (node->name, \"Top\") == 0)\n          top = node;\n\n      if (top)\n        {\n          struct spec_section *spec;\n          int found = 0;\n          struct line_data *target_line = NULL;\n          for (spec = input_sections; spec; spec = spec->next)\n            {\n              found = 0;\n              target_line = NULL;\n              if (!spec->missing)\n                continue;\n              if (order_new_sections_alphabetically_flag)\n                {\n                  struct menu_section *section;\n                  struct menu_section *prev_section = NULL;\n              \n                  /* Look for the first section name that \n                     exceeds SPEC->NAME. */\n                  for (section = top->sections; section ; \n                       section = section->next)\n                    {\n                      found = (mbscasecmp (spec->name, section->name) < 0);\n                      if (found)\n                        {\n                          /* Mark the section for addition at this point. */\n                          if (prev_section)\n                            target_line = &dir_lines[prev_section->end_line];\n                          else\n                            target_line = \n                              &dir_lines[top->sections->start_line - 2];\n\n                          break;\n                        }\n                      prev_section = section;\n                    }\n                }\n                  \n              /* When we can't put a section anywhere, we put it at the \n                 bottom of the file. */\n              if (!found)\n                target_line = &dir_lines[top->end_line];\n\n              /* Add the section to our list of sections being added\n                 at this point of the DIR file. */\n              target_line->num_sections_to_add++;\n              target_line->add_sections_before = \n                (struct spec_section **) xrealloc \n                (target_line->add_sections_before, \n                 (target_line->num_sections_to_add *\n                  sizeof (struct spec_section *)));\n              i = target_line->num_sections_to_add - 1;\n              target_line->add_sections_before[i] = spec;\n            }\n        }\n    }\n\n  if (delete_flag && !something_deleted && !quiet_flag)\n    warning (_(\"no entries found for `%s'; nothing deleted\"), infile);\n\n  if (debug_flag)\n    printf (\"debug: writing dir file %s\\n\", opened_dirfilename);\n  if (chicken_flag)\n    printf (\"test mode, not updating dir file %s\\n\", opened_dirfilename);\n  else\n    output_dirfile (opened_dirfilename, dir_nlines, dir_lines,\n                    n_entries_to_add, entries_to_add,\n                    input_sections, compression_program);\n\n  exit (EXIT_SUCCESS);\n}",
      "lines": 808,
      "depth": 26,
      "decorators": [
        "int"
      ]
    },
    "findlines": {
      "start_point": [
        2716,
        0
      ],
      "end_point": [
        2762,
        1
      ],
      "content": "struct line_data *\nfindlines (char *data, int size, int *nlinesp)\n{\n  int i;\n  int lineflag = 1;\n  int lines_allocated = 511;\n  int filled = 0;\n  struct line_data *lines\n    = xmalloc ((lines_allocated + 1) * sizeof (struct line_data));\n\n  for (i = 0; i < size; i++)\n    {\n      if (lineflag)\n        {\n          if (filled == lines_allocated)\n            {\n              /* try to keep things somewhat page-aligned */\n              lines_allocated = ((lines_allocated + 1) * 2) - 1;\n              lines = xrealloc (lines, (lines_allocated + 1)\n                                       * sizeof (struct line_data));\n            }\n          lines[filled].start = &data[i];\n          lines[filled].add_entries_before = 0;\n          lines[filled].add_sections_before = NULL;\n          lines[filled].num_sections_to_add = 0;\n          lines[filled].delete = 0;\n          if (filled > 0)\n            lines[filled - 1].size\n              = lines[filled].start - lines[filled - 1].start - 1;\n          filled++;\n        }\n      lineflag = (data[i] == '\\n');\n    }\n  if (filled > 0)\n    lines[filled - 1].size = &data[i] - lines[filled - 1].start - lineflag;\n\n  /* Do not leave garbage in the last element.  */\n  lines[filled].start = NULL;\n  lines[filled].add_entries_before = NULL;\n  lines[filled].add_sections_before = NULL;\n  lines[filled].num_sections_to_add = 0;\n  lines[filled].delete = 0;\n  lines[filled].size = 0;\n\n  *nlinesp = filled;\n  return lines;\n}",
      "lines": 47,
      "depth": 17,
      "decorators": [
        "struct line_data",
        "struct",
        "line_data",
        "*\nfindlines (char *data, int size, int *nlinesp)",
        "*"
      ]
    },
    "compare_section_names": {
      "start_point": [
        2769,
        0
      ],
      "end_point": [
        2777,
        1
      ],
      "content": "int\ncompare_section_names (const void *p1, const void *p2)\n{\n  struct spec_section **sec1 = (struct spec_section **) p1;\n  struct spec_section **sec2 = (struct spec_section **) p2;\n  char *name1 = (*sec1)->name;\n  char *name2 = (*sec2)->name;\n  return strcmp (name1, name2);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "compare_entries_text": {
      "start_point": [
        2783,
        0
      ],
      "end_point": [
        2803,
        1
      ],
      "content": "int\ncompare_entries_text (const void *p1, const void *p2)\n{\n  struct spec_entry **entry1 = (struct spec_entry **) p1;\n  struct spec_entry **entry2 = (struct spec_entry **) p2;\n  char *text1 = (*entry1)->text;\n  char *text2 = (*entry2)->text;\n  char *colon1 = strchr (text1, ':');\n  char *colon2 = strchr (text2, ':');\n  int len1, len2;\n\n  if (!colon1)\n    len1 = strlen (text1);\n  else\n    len1 = colon1 - text1;\n  if (!colon2)\n    len2 = strlen (text2);\n  else\n    len2 = colon2 - text2;\n  return mbsncasecmp (text1, text2, len1 <= len2 ? len1 : len2);\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "insert_entry_here": {
      "start_point": [
        2808,
        0
      ],
      "end_point": [
        2844,
        1
      ],
      "content": "void\ninsert_entry_here (struct spec_entry *entry, int line_number,\n                   struct line_data *dir_lines, int n_entries)\n{\n  int i, j;\n\n  if (dir_lines[line_number].add_entries_before == 0)\n    {\n      dir_lines[line_number].add_entries_before\n        = (struct spec_entry **) xmalloc (n_entries * sizeof (struct spec_entry *));\n      for (i = 0; i < n_entries; i++)\n        dir_lines[line_number].add_entries_before[i] = 0;\n    }\n\n  /* Find the place where this entry belongs.  If there are already\n     several entries to add before LINE_NUMBER, make sure they are in\n     alphabetical order.  */\n  for (i = 0; i < n_entries; i++)\n    if (dir_lines[line_number].add_entries_before[i] == 0\n        || menu_line_lessp (entry->text, strlen (entry->text),\n              dir_lines[line_number].add_entries_before[i]->text,\n              strlen (dir_lines[line_number].add_entries_before[i]->text)))\n      break;\n\n  if (i == n_entries)\n    abort ();\n\n  /* If we need to plug ENTRY into the middle of the\n     ADD_ENTRIES_BEFORE array, move the entries which should be output\n     after this one down one notch, before adding a new one.  */\n  if (dir_lines[line_number].add_entries_before[i] != 0)\n    for (j = n_entries - 1; j > i; j--)\n      dir_lines[line_number].add_entries_before[j]\n        = dir_lines[line_number].add_entries_before[j - 1];\n\n  dir_lines[line_number].add_entries_before[i] = entry;\n}",
      "lines": 37,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/ppport.h": {
    "DPPP_": [
      {
        "start_point": [
          4493,
          0
        ],
        "end_point": [
          4511,
          1
        ],
        "content": "SV*\nDPPP_(my_eval_pv)(char *p, I32 croak_on_error)\n{\n    dSP;\n    SV* sv = newSVpv(p, 0);\n\n    PUSHMARK(sp);\n    eval_sv(sv, G_SCALAR);\n    SvREFCNT_dec(sv);\n\n    SPAGAIN;\n    sv = POPs;\n    PUTBACK;\n\n    if (croak_on_error && SvTRUE(GvSV(errgv)))\n\tcroak(SvPVx(GvSV(errgv), na));\n\n    return sv;\n}",
        "lines": 19,
        "depth": 11,
        "decorators": [
          "SV",
          "*\nDPPP_(my_eval_pv)(char *p, I32 croak_on_error)",
          "*"
        ]
      },
      {
        "start_point": [
          4532,
          0
        ],
        "end_point": [
          4583,
          1
        ],
        "content": "void\nDPPP_(my_vload_module)(U32 flags, SV *name, SV *ver, va_list *args)\n{\n    dTHR;\n    dVAR;\n    OP *veop, *imop;\n\n    OP * const modname = newSVOP(OP_CONST, 0, name);\n    /* 5.005 has a somewhat hacky force_normal that doesn't croak on\n       SvREADONLY() if PL_compling is true. Current perls take care in\n       ck_require() to correctly turn off SvREADONLY before calling\n       force_normal_flags(). This seems a better fix than fudging PL_compling\n     */\n    SvREADONLY_off(((SVOP*)modname)->op_sv);\n    modname->op_private |= OPpCONST_BARE;\n    if (ver) {\n\tveop = newSVOP(OP_CONST, 0, ver);\n    }\n    else\n\tveop = NULL;\n    if (flags & PERL_LOADMOD_NOIMPORT) {\n\timop = sawparens(newNULLLIST());\n    }\n    else if (flags & PERL_LOADMOD_IMPORT_OPS) {\n\timop = va_arg(*args, OP*);\n    }\n    else {\n\tSV *sv;\n\timop = NULL;\n\tsv = va_arg(*args, SV*);\n\twhile (sv) {\n\t    imop = append_elem(OP_LIST, imop, newSVOP(OP_CONST, 0, sv));\n\t    sv = va_arg(*args, SV*);\n\t}\n    }\n    {\n\tconst line_t ocopline = PL_copline;\n\tCOP * const ocurcop = PL_curcop;\n\tconst int oexpect = PL_expect;\n\n#if (PERL_BCDVERSION >= 0x5004000)\n\tutilize(!(flags & PERL_LOADMOD_DENY), start_subparse(FALSE, 0),\n\t\tveop, modname, imop);\n#else\n\tutilize(!(flags & PERL_LOADMOD_DENY), start_subparse(),\n\t\tmodname, imop);\n#endif\n\tPL_expect = oexpect;\n\tPL_copline = ocopline;\n\tPL_curcop = ocurcop;\n    }\n}",
        "lines": 52,
        "depth": 14,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          4604,
          0
        ],
        "end_point": [
          4611,
          1
        ],
        "content": "void\nDPPP_(my_load_module)(U32 flags, SV *name, SV *ver, ...)\n{\n    va_list args;\n    va_start(args, ver);\n    vload_module(flags, name, ver, &args);\n    va_end(args);\n}",
        "lines": 8,
        "depth": 7,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          4634,
          0
        ],
        "end_point": [
          4640,
          1
        ],
        "content": "SV *\nDPPP_(my_newRV_noinc)(SV *sv)\n{\n  SV *rv = (SV *)newRV(sv);\n  SvREFCNT_dec(sv);\n  return rv;\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "SV",
          "*\nDPPP_(my_newRV_noinc)(SV *sv)",
          "*"
        ]
      },
      {
        "start_point": [
          4931,
          0
        ],
        "end_point": [
          4937,
          1
        ],
        "content": "SV*\nDPPP_(my_newSV_type)(pTHX_ svtype const t)\n{\n  SV* const sv = newSV(0);\n  sv_upgrade(sv, t);\n  return sv;\n}",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "SV",
          "*\nDPPP_(my_newSV_type)(pTHX_ svtype const t)",
          "*"
        ]
      },
      {
        "start_point": [
          4977,
          0
        ],
        "end_point": [
          4983,
          1
        ],
        "content": "SV *\nDPPP_(my_newSVpvn_flags)(pTHX_ const char *s, STRLEN len, U32 flags)\n{\n  SV *sv = newSVpvn(D_PPP_CONSTPV_ARG(s), len);\n  SvFLAGS(sv) |= (flags & SVf_UTF8);\n  return (flags & SVs_TEMP) ? sv_2mortal(sv) : sv;\n}",
        "lines": 7,
        "depth": 9,
        "decorators": [
          "SV",
          "*\nDPPP_(my_newSVpvn_flags)(pTHX_ const char *s, STRLEN len, U32 flags)",
          "*"
        ]
      },
      {
        "start_point": [
          5028,
          0
        ],
        "end_point": [
          5033,
          1
        ],
        "content": "char *\nDPPP_(my_sv_2pvbyte)(pTHX_ SV *sv, STRLEN *lp)\n{\n  sv_utf8_downgrade(sv,0);\n  return SvPV(sv,*lp);\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "char",
          "*\nDPPP_(my_sv_2pvbyte)(pTHX_ SV *sv, STRLEN *lp)",
          "*"
        ]
      },
      {
        "start_point": [
          5125,
          0
        ],
        "end_point": [
          5130,
          1
        ],
        "content": "char *\nDPPP_(my_sv_2pv_flags)(pTHX_ SV *sv, STRLEN *lp, I32 flags)\n{\n  STRLEN n_a = (STRLEN) flags;\n  return sv_2pv(sv, lp ? lp : &n_a);\n}",
        "lines": 6,
        "depth": 8,
        "decorators": [
          "char",
          "*\nDPPP_(my_sv_2pv_flags)(pTHX_ SV *sv, STRLEN *lp, I32 flags)",
          "*"
        ]
      },
      {
        "start_point": [
          5149,
          0
        ],
        "end_point": [
          5154,
          1
        ],
        "content": "char *\nDPPP_(my_sv_pvn_force_flags)(pTHX_ SV *sv, STRLEN *lp, I32 flags)\n{\n  STRLEN n_a = (STRLEN) flags;\n  return sv_pvn_force(sv, lp ? lp : &n_a);\n}",
        "lines": 6,
        "depth": 8,
        "decorators": [
          "char",
          "*\nDPPP_(my_sv_pvn_force_flags)(pTHX_ SV *sv, STRLEN *lp, I32 flags)",
          "*"
        ]
      },
      {
        "start_point": [
          5330,
          0
        ],
        "end_point": [
          5336,
          1
        ],
        "content": "SV *\nDPPP_(my_vnewSVpvf)(pTHX_ const char *pat, va_list *args)\n{\n  register SV *sv = newSV(0);\n  sv_vsetpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*));\n  return sv;\n}",
        "lines": 7,
        "depth": 10,
        "decorators": [
          "SV",
          "*\nDPPP_(my_vnewSVpvf)(pTHX_ const char *pat, va_list *args)",
          "*"
        ]
      },
      {
        "start_point": [
          5361,
          0
        ],
        "end_point": [
          5369,
          1
        ],
        "content": "void\nDPPP_(my_sv_catpvf_mg)(pTHX_ SV *sv, const char *pat, ...)\n{\n  va_list args;\n  va_start(args, pat);\n  sv_vcatpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));\n  SvSETMAGIC(sv);\n  va_end(args);\n}",
        "lines": 9,
        "depth": 10,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          5388,
          0
        ],
        "end_point": [
          5397,
          1
        ],
        "content": "void\nDPPP_(my_sv_catpvf_mg_nocontext)(SV *sv, const char *pat, ...)\n{\n  dTHX;\n  va_list args;\n  va_start(args, pat);\n  sv_vcatpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));\n  SvSETMAGIC(sv);\n  va_end(args);\n}",
        "lines": 10,
        "depth": 10,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          5432,
          0
        ],
        "end_point": [
          5440,
          1
        ],
        "content": "void\nDPPP_(my_sv_setpvf_mg)(pTHX_ SV *sv, const char *pat, ...)\n{\n  va_list args;\n  va_start(args, pat);\n  sv_vsetpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));\n  SvSETMAGIC(sv);\n  va_end(args);\n}",
        "lines": 9,
        "depth": 10,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          5459,
          0
        ],
        "end_point": [
          5468,
          1
        ],
        "content": "void\nDPPP_(my_sv_setpvf_mg_nocontext)(SV *sv, const char *pat, ...)\n{\n  dTHX;\n  va_list args;\n  va_start(args, pat);\n  sv_vsetpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));\n  SvSETMAGIC(sv);\n  va_end(args);\n}",
        "lines": 10,
        "depth": 10,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          5514,
          0
        ],
        "end_point": [
          5528,
          1
        ],
        "content": "SV *\nDPPP_(my_newSVpvn_share)(pTHX_ const char *src, I32 len, U32 hash)\n{\n  SV *sv;\n  if (len < 0)\n    len = -len;\n  if (!hash)\n    PERL_HASH(hash, (char*) src, len);\n  sv = newSVpvn((char *) src, len);\n  sv_upgrade(sv, SVt_PVIV);\n  SvIVX(sv) = hash;\n  SvREADONLY_on(sv);\n  SvPOK_on(sv);\n  return sv;\n}",
        "lines": 15,
        "depth": 10,
        "decorators": [
          "SV",
          "*\nDPPP_(my_newSVpvn_share)(pTHX_ const char *src, I32 len, U32 hash)",
          "*"
        ]
      },
      {
        "start_point": [
          5771,
          0
        ],
        "end_point": [
          5784,
          1
        ],
        "content": "void\nDPPP_(my_warner)(U32 err, const char *pat, ...)\n{\n  SV *sv;\n  va_list args;\n\n  PERL_UNUSED_ARG(err);\n\n  va_start(args, pat);\n  sv = vnewSVpvf(pat, &args);\n  va_end(args);\n  sv_2mortal(sv);\n  warn(\"%s\", SvPV_nolen(sv));\n}",
        "lines": 14,
        "depth": 8,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          6316,
          0
        ],
        "end_point": [
          6353,
          1
        ],
        "content": "bool\nDPPP_(my_grok_numeric_radix)(pTHX_ const char **sp, const char *send)\n{\n#ifdef USE_LOCALE_NUMERIC\n#ifdef PL_numeric_radix_sv\n    if (PL_numeric_radix_sv && IN_LOCALE) {\n        STRLEN len;\n        char* radix = SvPV(PL_numeric_radix_sv, len);\n        if (*sp + len <= send && memEQ(*sp, radix, len)) {\n            *sp += len;\n            return TRUE;\n        }\n    }\n#else\n    /* older perls don't have PL_numeric_radix_sv so the radix\n     * must manually be requested from locale.h\n     */\n#include <locale.h>\n    dTHR;  /* needed for older threaded perls */\n    struct lconv *lc = localeconv();\n    char *radix = lc->decimal_point;\n    if (radix && IN_LOCALE) {\n        STRLEN len = strlen(radix);\n        if (*sp + len <= send && memEQ(*sp, radix, len)) {\n            *sp += len;\n            return TRUE;\n        }\n    }\n#endif\n#endif /* USE_LOCALE_NUMERIC */\n    /* always try \".\" if numeric radix didn't match because\n     * we may have data from different locales mixed */\n    if (*sp < send && **sp == '.') {\n        ++*sp;\n        return TRUE;\n    }\n    return FALSE;\n}",
        "lines": 38,
        "depth": 14,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          6372,
          0
        ],
        "end_point": [
          6561,
          1
        ],
        "content": "int\nDPPP_(my_grok_number)(pTHX_ const char *pv, STRLEN len, UV *valuep)\n{\n  const char *s = pv;\n  const char *send = pv + len;\n  const UV max_div_10 = UV_MAX / 10;\n  const char max_mod_10 = UV_MAX % 10;\n  int numtype = 0;\n  int sawinf = 0;\n  int sawnan = 0;\n\n  while (s < send && isSPACE(*s))\n    s++;\n  if (s == send) {\n    return 0;\n  } else if (*s == '-') {\n    s++;\n    numtype = IS_NUMBER_NEG;\n  }\n  else if (*s == '+')\n  s++;\n\n  if (s == send)\n    return 0;\n\n  /* next must be digit or the radix separator or beginning of infinity */\n  if (isDIGIT(*s)) {\n    /* UVs are at least 32 bits, so the first 9 decimal digits cannot\n       overflow.  */\n    UV value = *s - '0';\n    /* This construction seems to be more optimiser friendly.\n       (without it gcc does the isDIGIT test and the *s - '0' separately)\n       With it gcc on arm is managing 6 instructions (6 cycles) per digit.\n       In theory the optimiser could deduce how far to unroll the loop\n       before checking for overflow.  */\n    if (++s < send) {\n      int digit = *s - '0';\n      if (digit >= 0 && digit <= 9) {\n        value = value * 10 + digit;\n        if (++s < send) {\n          digit = *s - '0';\n          if (digit >= 0 && digit <= 9) {\n            value = value * 10 + digit;\n            if (++s < send) {\n              digit = *s - '0';\n              if (digit >= 0 && digit <= 9) {\n                value = value * 10 + digit;\n\t\tif (++s < send) {\n                  digit = *s - '0';\n                  if (digit >= 0 && digit <= 9) {\n                    value = value * 10 + digit;\n                    if (++s < send) {\n                      digit = *s - '0';\n                      if (digit >= 0 && digit <= 9) {\n                        value = value * 10 + digit;\n                        if (++s < send) {\n                          digit = *s - '0';\n                          if (digit >= 0 && digit <= 9) {\n                            value = value * 10 + digit;\n                            if (++s < send) {\n                              digit = *s - '0';\n                              if (digit >= 0 && digit <= 9) {\n                                value = value * 10 + digit;\n                                if (++s < send) {\n                                  digit = *s - '0';\n                                  if (digit >= 0 && digit <= 9) {\n                                    value = value * 10 + digit;\n                                    if (++s < send) {\n                                      /* Now got 9 digits, so need to check\n                                         each time for overflow.  */\n                                      digit = *s - '0';\n                                      while (digit >= 0 && digit <= 9\n                                             && (value < max_div_10\n                                                 || (value == max_div_10\n                                                     && digit <= max_mod_10))) {\n                                        value = value * 10 + digit;\n                                        if (++s < send)\n                                          digit = *s - '0';\n                                        else\n                                          break;\n                                      }\n                                      if (digit >= 0 && digit <= 9\n                                          && (s < send)) {\n                                        /* value overflowed.\n                                           skip the remaining digits, don't\n                                           worry about setting *valuep.  */\n                                        do {\n                                          s++;\n                                        } while (s < send && isDIGIT(*s));\n                                        numtype |=\n                                          IS_NUMBER_GREATER_THAN_UV_MAX;\n                                        goto skip_value;\n                                      }\n                                    }\n                                  }\n\t\t\t\t}\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n\t}\n      }\n    }\n    numtype |= IS_NUMBER_IN_UV;\n    if (valuep)\n      *valuep = value;\n\n  skip_value:\n    if (GROK_NUMERIC_RADIX(&s, send)) {\n      numtype |= IS_NUMBER_NOT_INT;\n      while (s < send && isDIGIT(*s))  /* optional digits after the radix */\n        s++;\n    }\n  }\n  else if (GROK_NUMERIC_RADIX(&s, send)) {\n    numtype |= IS_NUMBER_NOT_INT | IS_NUMBER_IN_UV; /* valuep assigned below */\n    /* no digits before the radix means we need digits after it */\n    if (s < send && isDIGIT(*s)) {\n      do {\n        s++;\n      } while (s < send && isDIGIT(*s));\n      if (valuep) {\n        /* integer approximation is valid - it's 0.  */\n        *valuep = 0;\n      }\n    }\n    else\n      return 0;\n  } else if (*s == 'I' || *s == 'i') {\n    s++; if (s == send || (*s != 'N' && *s != 'n')) return 0;\n    s++; if (s == send || (*s != 'F' && *s != 'f')) return 0;\n    s++; if (s < send && (*s == 'I' || *s == 'i')) {\n      s++; if (s == send || (*s != 'N' && *s != 'n')) return 0;\n      s++; if (s == send || (*s != 'I' && *s != 'i')) return 0;\n      s++; if (s == send || (*s != 'T' && *s != 't')) return 0;\n      s++; if (s == send || (*s != 'Y' && *s != 'y')) return 0;\n      s++;\n    }\n    sawinf = 1;\n  } else if (*s == 'N' || *s == 'n') {\n    /* XXX TODO: There are signaling NaNs and quiet NaNs. */\n    s++; if (s == send || (*s != 'A' && *s != 'a')) return 0;\n    s++; if (s == send || (*s != 'N' && *s != 'n')) return 0;\n    s++;\n    sawnan = 1;\n  } else\n    return 0;\n\n  if (sawinf) {\n    numtype &= IS_NUMBER_NEG; /* Keep track of sign  */\n    numtype |= IS_NUMBER_INFINITY | IS_NUMBER_NOT_INT;\n  } else if (sawnan) {\n    numtype &= IS_NUMBER_NEG; /* Keep track of sign  */\n    numtype |= IS_NUMBER_NAN | IS_NUMBER_NOT_INT;\n  } else if (s < send) {\n    /* we can have an optional exponent part */\n    if (*s == 'e' || *s == 'E') {\n      /* The only flag we keep is sign.  Blow away any \"it's UV\"  */\n      numtype &= IS_NUMBER_NEG;\n      numtype |= IS_NUMBER_NOT_INT;\n      s++;\n      if (s < send && (*s == '-' || *s == '+'))\n        s++;\n      if (s < send && isDIGIT(*s)) {\n        do {\n          s++;\n        } while (s < send && isDIGIT(*s));\n      }\n      else\n      return 0;\n    }\n  }\n  while (s < send && isSPACE(*s))\n    s++;\n  if (s >= send)\n    return numtype;\n  if (len == 10 && memEQ(pv, \"0 but true\", 10)) {\n    if (valuep)\n      *valuep = 0;\n    return IS_NUMBER_IN_UV;\n  }\n  return 0;\n}",
        "lines": 190,
        "depth": 47,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          6586,
          0
        ],
        "end_point": [
          6669,
          1
        ],
        "content": "UV\nDPPP_(my_grok_bin)(pTHX_ const char *start, STRLEN *len_p, I32 *flags, NV *result)\n{\n    const char *s = start;\n    STRLEN len = *len_p;\n    UV value = 0;\n    NV value_nv = 0;\n\n    const UV max_div_2 = UV_MAX / 2;\n    bool allow_underscores = *flags & PERL_SCAN_ALLOW_UNDERSCORES;\n    bool overflowed = FALSE;\n\n    if (!(*flags & PERL_SCAN_DISALLOW_PREFIX)) {\n        /* strip off leading b or 0b.\n           for compatibility silently suffer \"b\" and \"0b\" as valid binary\n           numbers. */\n        if (len >= 1) {\n            if (s[0] == 'b') {\n                s++;\n                len--;\n            }\n            else if (len >= 2 && s[0] == '0' && s[1] == 'b') {\n                s+=2;\n                len-=2;\n            }\n        }\n    }\n\n    for (; len-- && *s; s++) {\n        char bit = *s;\n        if (bit == '0' || bit == '1') {\n            /* Write it in this wonky order with a goto to attempt to get the\n               compiler to make the common case integer-only loop pretty tight.\n               With gcc seems to be much straighter code than old scan_bin.  */\n          redo:\n            if (!overflowed) {\n                if (value <= max_div_2) {\n                    value = (value << 1) | (bit - '0');\n                    continue;\n                }\n                /* Bah. We're just overflowed.  */\n                warn(\"Integer overflow in binary number\");\n                overflowed = TRUE;\n                value_nv = (NV) value;\n            }\n            value_nv *= 2.0;\n\t    /* If an NV has not enough bits in its mantissa to\n\t     * represent a UV this summing of small low-order numbers\n\t     * is a waste of time (because the NV cannot preserve\n\t     * the low-order bits anyway): we could just remember when\n\t     * did we overflow and in the end just multiply value_nv by the\n\t     * right amount. */\n            value_nv += (NV)(bit - '0');\n            continue;\n        }\n        if (bit == '_' && len && allow_underscores && (bit = s[1])\n            && (bit == '0' || bit == '1'))\n\t    {\n\t\t--len;\n\t\t++s;\n                goto redo;\n\t    }\n        if (!(*flags & PERL_SCAN_SILENT_ILLDIGIT))\n            warn(\"Illegal binary digit '%c' ignored\", *s);\n        break;\n    }\n\n    if (   ( overflowed && value_nv > 4294967295.0)\n#if UVSIZE > 4\n\t|| (!overflowed && value > 0xffffffff  )\n#endif\n\t) {\n\twarn(\"Binary number > 0b11111111111111111111111111111111 non-portable\");\n    }\n    *len_p = s - start;\n    if (!overflowed) {\n        *flags = 0;\n        return value;\n    }\n    *flags = PERL_SCAN_GREATER_THAN_UV_MAX;\n    if (result)\n        *result = value_nv;\n    return UV_MAX;\n}",
        "lines": 84,
        "depth": 18,
        "decorators": [
          "UV"
        ]
      },
      {
        "start_point": [
          6688,
          0
        ],
        "end_point": [
          6771,
          1
        ],
        "content": "UV\nDPPP_(my_grok_hex)(pTHX_ const char *start, STRLEN *len_p, I32 *flags, NV *result)\n{\n    const char *s = start;\n    STRLEN len = *len_p;\n    UV value = 0;\n    NV value_nv = 0;\n\n    const UV max_div_16 = UV_MAX / 16;\n    bool allow_underscores = *flags & PERL_SCAN_ALLOW_UNDERSCORES;\n    bool overflowed = FALSE;\n    const char *xdigit;\n\n    if (!(*flags & PERL_SCAN_DISALLOW_PREFIX)) {\n        /* strip off leading x or 0x.\n           for compatibility silently suffer \"x\" and \"0x\" as valid hex numbers.\n        */\n        if (len >= 1) {\n            if (s[0] == 'x') {\n                s++;\n                len--;\n            }\n            else if (len >= 2 && s[0] == '0' && s[1] == 'x') {\n                s+=2;\n                len-=2;\n            }\n        }\n    }\n\n    for (; len-- && *s; s++) {\n\txdigit = strchr((char *) PL_hexdigit, *s);\n        if (xdigit) {\n            /* Write it in this wonky order with a goto to attempt to get the\n               compiler to make the common case integer-only loop pretty tight.\n               With gcc seems to be much straighter code than old scan_hex.  */\n          redo:\n            if (!overflowed) {\n                if (value <= max_div_16) {\n                    value = (value << 4) | ((xdigit - PL_hexdigit) & 15);\n                    continue;\n                }\n                warn(\"Integer overflow in hexadecimal number\");\n                overflowed = TRUE;\n                value_nv = (NV) value;\n            }\n            value_nv *= 16.0;\n\t    /* If an NV has not enough bits in its mantissa to\n\t     * represent a UV this summing of small low-order numbers\n\t     * is a waste of time (because the NV cannot preserve\n\t     * the low-order bits anyway): we could just remember when\n\t     * did we overflow and in the end just multiply value_nv by the\n\t     * right amount of 16-tuples. */\n            value_nv += (NV)((xdigit - PL_hexdigit) & 15);\n            continue;\n        }\n        if (*s == '_' && len && allow_underscores && s[1]\n\t\t&& (xdigit = strchr((char *) PL_hexdigit, s[1])))\n\t    {\n\t\t--len;\n\t\t++s;\n                goto redo;\n\t    }\n        if (!(*flags & PERL_SCAN_SILENT_ILLDIGIT))\n            warn(\"Illegal hexadecimal digit '%c' ignored\", *s);\n        break;\n    }\n\n    if (   ( overflowed && value_nv > 4294967295.0)\n#if UVSIZE > 4\n\t|| (!overflowed && value > 0xffffffff  )\n#endif\n\t) {\n\twarn(\"Hexadecimal number > 0xffffffff non-portable\");\n    }\n    *len_p = s - start;\n    if (!overflowed) {\n        *flags = 0;\n        return value;\n    }\n    *flags = PERL_SCAN_GREATER_THAN_UV_MAX;\n    if (result)\n        *result = value_nv;\n    return UV_MAX;\n}",
        "lines": 84,
        "depth": 19,
        "decorators": [
          "UV"
        ]
      },
      {
        "start_point": [
          6790,
          0
        ],
        "end_point": [
          6864,
          1
        ],
        "content": "UV\nDPPP_(my_grok_oct)(pTHX_ const char *start, STRLEN *len_p, I32 *flags, NV *result)\n{\n    const char *s = start;\n    STRLEN len = *len_p;\n    UV value = 0;\n    NV value_nv = 0;\n\n    const UV max_div_8 = UV_MAX / 8;\n    bool allow_underscores = *flags & PERL_SCAN_ALLOW_UNDERSCORES;\n    bool overflowed = FALSE;\n\n    for (; len-- && *s; s++) {\n         /* gcc 2.95 optimiser not smart enough to figure that this subtraction\n            out front allows slicker code.  */\n        int digit = *s - '0';\n        if (digit >= 0 && digit <= 7) {\n            /* Write it in this wonky order with a goto to attempt to get the\n               compiler to make the common case integer-only loop pretty tight.\n            */\n          redo:\n            if (!overflowed) {\n                if (value <= max_div_8) {\n                    value = (value << 3) | digit;\n                    continue;\n                }\n                /* Bah. We're just overflowed.  */\n                warn(\"Integer overflow in octal number\");\n                overflowed = TRUE;\n                value_nv = (NV) value;\n            }\n            value_nv *= 8.0;\n\t    /* If an NV has not enough bits in its mantissa to\n\t     * represent a UV this summing of small low-order numbers\n\t     * is a waste of time (because the NV cannot preserve\n\t     * the low-order bits anyway): we could just remember when\n\t     * did we overflow and in the end just multiply value_nv by the\n\t     * right amount of 8-tuples. */\n            value_nv += (NV)digit;\n            continue;\n        }\n        if (digit == ('_' - '0') && len && allow_underscores\n            && (digit = s[1] - '0') && (digit >= 0 && digit <= 7))\n\t    {\n\t\t--len;\n\t\t++s;\n                goto redo;\n\t    }\n        /* Allow \\octal to work the DWIM way (that is, stop scanning\n         * as soon as non-octal characters are seen, complain only iff\n         * someone seems to want to use the digits eight and nine). */\n        if (digit == 8 || digit == 9) {\n            if (!(*flags & PERL_SCAN_SILENT_ILLDIGIT))\n                warn(\"Illegal octal digit '%c' ignored\", *s);\n        }\n        break;\n    }\n\n    if (   ( overflowed && value_nv > 4294967295.0)\n#if UVSIZE > 4\n\t|| (!overflowed && value > 0xffffffff  )\n#endif\n\t) {\n\twarn(\"Octal number > 037777777777 non-portable\");\n    }\n    *len_p = s - start;\n    if (!overflowed) {\n        *flags = 0;\n        return value;\n    }\n    *flags = PERL_SCAN_GREATER_THAN_UV_MAX;\n    if (result)\n        *result = value_nv;\n    return UV_MAX;\n}",
        "lines": 75,
        "depth": 17,
        "decorators": [
          "UV"
        ]
      },
      {
        "start_point": [
          6881,
          0
        ],
        "end_point": [
          6897,
          1
        ],
        "content": "int\nDPPP_(my_my_snprintf)(char *buffer, const Size_t len, const char *format, ...)\n{\n    dTHX;\n    int retval;\n    va_list ap;\n    va_start(ap, format);\n#ifdef HAS_VSNPRINTF\n    retval = vsnprintf(buffer, len, format, ap);\n#else\n    retval = vsprintf(buffer, format, ap);\n#endif\n    va_end(ap);\n    if (retval < 0 || (len > 0 && (Size_t)retval >= len))\n\tPerl_croak(aTHX_ \"panic: my_snprintf buffer overflow\");\n    return retval;\n}",
        "lines": 17,
        "depth": 11,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          6915,
          0
        ],
        "end_point": [
          6923,
          1
        ],
        "content": "int\nDPPP_(my_my_sprintf)(char *buffer, const char* pat, ...)\n{\n    va_list args;\n    va_start(args, pat);\n    vsprintf(buffer, pat, args);\n    va_end(args);\n    return strlen(buffer);\n}",
        "lines": 9,
        "depth": 6,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          6957,
          0
        ],
        "end_point": [
          6970,
          1
        ],
        "content": "Size_t\nDPPP_(my_my_strlcat)(char *dst, const char *src, Size_t size)\n{\n    Size_t used, length, copy;\n\n    used = strlen(dst);\n    length = strlen(src);\n    if (size > 0 && used < size - 1) {\n        copy = (length >= size - used) ? size - used - 1 : length;\n        memcpy(dst + used, src, copy);\n        dst[used + copy] = '\\0';\n    }\n    return used + length;\n}",
        "lines": 14,
        "depth": 11,
        "decorators": [
          "Size_t"
        ]
      },
      {
        "start_point": [
          6987,
          0
        ],
        "end_point": [
          6999,
          1
        ],
        "content": "Size_t\nDPPP_(my_my_strlcpy)(char *dst, const char *src, Size_t size)\n{\n    Size_t length, copy;\n\n    length = strlen(src);\n    if (size > 0) {\n        copy = (length >= size) ? size - 1 : length;\n        memcpy(dst, src, copy);\n        dst[copy] = '\\0';\n    }\n    return length;\n}",
        "lines": 13,
        "depth": 10,
        "decorators": [
          "Size_t"
        ]
      },
      {
        "start_point": [
          7080,
          0
        ],
        "end_point": [
          7168,
          1
        ],
        "content": "char *\nDPPP_(my_pv_escape)(pTHX_ SV *dsv, char const * const str,\n  const STRLEN count, const STRLEN max,\n  STRLEN * const escaped, const U32 flags)\n{\n    const char esc = flags & PERL_PV_ESCAPE_RE ? '%' : '\\\\';\n    const char dq = flags & PERL_PV_ESCAPE_QUOTE ? '\"' : esc;\n    char octbuf[32] = \"%123456789ABCDF\";\n    STRLEN wrote = 0;\n    STRLEN chsize = 0;\n    STRLEN readsize = 1;\n#if defined(is_utf8_string) && defined(utf8_to_uvchr)\n    bool isuni = flags & PERL_PV_ESCAPE_UNI ? 1 : 0;\n#endif\n    const char *pv  = str;\n    const char * const end = pv + count;\n    octbuf[0] = esc;\n\n    if (!(flags & PERL_PV_ESCAPE_NOCLEAR))\n\tsv_setpvs(dsv, \"\");\n\n#if defined(is_utf8_string) && defined(utf8_to_uvchr)\n    if ((flags & PERL_PV_ESCAPE_UNI_DETECT) && is_utf8_string((U8*)pv, count))\n        isuni = 1;\n#endif\n\n    for (; pv < end && (!max || wrote < max) ; pv += readsize) {\n        const UV u =\n#if defined(is_utf8_string) && defined(utf8_to_uvchr)\n\t\t     isuni ? utf8_to_uvchr((U8*)pv, &readsize) :\n#endif\n\t\t\t     (U8)*pv;\n        const U8 c = (U8)u & 0xFF;\n\n        if (u > 255 || (flags & PERL_PV_ESCAPE_ALL)) {\n            if (flags & PERL_PV_ESCAPE_FIRSTCHAR)\n                chsize = my_snprintf(octbuf, sizeof octbuf,\n                                      \"%\"UVxf, u);\n            else\n                chsize = my_snprintf(octbuf, sizeof octbuf,\n                                      \"%cx{%\"UVxf\"}\", esc, u);\n        } else if (flags & PERL_PV_ESCAPE_NOBACKSLASH) {\n            chsize = 1;\n        } else {\n            if (c == dq || c == esc || !isPRINT(c)) {\n\t        chsize = 2;\n                switch (c) {\n\t\tcase '\\\\' : /* fallthrough */\n\t\tcase '%'  : if (c == esc)\n\t\t                octbuf[1] = esc;\n\t\t            else\n\t\t                chsize = 1;\n\t\t            break;\n\t\tcase '\\v' : octbuf[1] = 'v'; break;\n\t\tcase '\\t' : octbuf[1] = 't'; break;\n\t\tcase '\\r' : octbuf[1] = 'r'; break;\n\t\tcase '\\n' : octbuf[1] = 'n'; break;\n\t\tcase '\\f' : octbuf[1] = 'f'; break;\n                case '\"'  : if (dq == '\"')\n\t\t\t\toctbuf[1] = '\"';\n\t\t\t    else\n\t\t\t\tchsize = 1;\n\t\t\t    break;\n\t\tdefault:    chsize = my_snprintf(octbuf, sizeof octbuf,\n\t\t\t\tpv < end && isDIGIT((U8)*(pv+readsize))\n\t\t\t\t? \"%c%03o\" : \"%c%o\", esc, c);\n                }\n            } else {\n                chsize = 1;\n            }\n\t}\n\tif (max && wrote + chsize > max) {\n\t    break;\n        } else if (chsize > 1) {\n            sv_catpvn(dsv, octbuf, chsize);\n            wrote += chsize;\n\t} else {\n\t    char tmp[2];\n\t    my_snprintf(tmp, sizeof tmp, \"%c\", c);\n            sv_catpvn(dsv, tmp, 1);\n\t    wrote++;\n\t}\n        if (flags & PERL_PV_ESCAPE_FIRSTCHAR)\n            break;\n    }\n    if (escaped != NULL)\n        *escaped= pv - str;\n    return SvPVX(dsv);\n}",
        "lines": 89,
        "depth": 25,
        "decorators": [
          "char",
          "*\nDPPP_(my_pv_escape)(pTHX_ SV *dsv, char const * const str,\n  const STRLEN count, const STRLEN max,\n  STRLEN * const escaped, const U32 flags)",
          "*"
        ]
      },
      {
        "start_point": [
          7189,
          0
        ],
        "end_point": [
          7222,
          1
        ],
        "content": "char *\nDPPP_(my_pv_pretty)(pTHX_ SV *dsv, char const * const str, const STRLEN count,\n  const STRLEN max, char const * const start_color, char const * const end_color,\n  const U32 flags)\n{\n    const U8 dq = (flags & PERL_PV_PRETTY_QUOTE) ? '\"' : '%';\n    STRLEN escaped;\n\n    if (!(flags & PERL_PV_PRETTY_NOCLEAR))\n\tsv_setpvs(dsv, \"\");\n\n    if (dq == '\"')\n        sv_catpvs(dsv, \"\\\"\");\n    else if (flags & PERL_PV_PRETTY_LTGT)\n        sv_catpvs(dsv, \"<\");\n\n    if (start_color != NULL)\n        sv_catpv(dsv, D_PPP_CONSTPV_ARG(start_color));\n\n    pv_escape(dsv, str, count, max, &escaped, flags | PERL_PV_ESCAPE_NOCLEAR);\n\n    if (end_color != NULL)\n        sv_catpv(dsv, D_PPP_CONSTPV_ARG(end_color));\n\n    if (dq == '\"')\n\tsv_catpvs(dsv, \"\\\"\");\n    else if (flags & PERL_PV_PRETTY_LTGT)\n        sv_catpvs(dsv, \">\");\n\n    if ((flags & PERL_PV_PRETTY_ELLIPSES) && escaped < count)\n\tsv_catpvs(dsv, \"...\");\n\n    return SvPVX(dsv);\n}",
        "lines": 34,
        "depth": 9,
        "decorators": [
          "char",
          "*\nDPPP_(my_pv_pretty)(pTHX_ SV *dsv, char const * const str, const STRLEN count,\n  const STRLEN max, char const * const start_color, char const * const end_color,\n  const U32 flags)",
          "*"
        ]
      },
      {
        "start_point": [
          7243,
          0
        ],
        "end_point": [
          7250,
          1
        ],
        "content": "char *\nDPPP_(my_pv_display)(pTHX_ SV *dsv, const char *pv, STRLEN cur, STRLEN len, STRLEN pvlim)\n{\n    pv_pretty(dsv, pv, cur, pvlim, NULL, NULL, PERL_PV_PRETTY_DUMP);\n    if (len > cur && pv[cur] == '\\0')\n\tsv_catpvs(dsv, \"\\\\0\");\n    return SvPVX(dsv);\n}",
        "lines": 8,
        "depth": 8,
        "decorators": [
          "char",
          "*\nDPPP_(my_pv_display)(pTHX_ SV *dsv, const char *pv, STRLEN cur, STRLEN len, STRLEN pvlim)",
          "*"
        ]
      }
    ]
  },
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/TestXS.c": {
    "S_croak_xs_usage": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "STATIC void\nS_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)\n{\n    const GV *const gv = CvGV(cv);\n\n    PERL_ARGS_ASSERT_CROAK_XS_USAGE;\n\n    if (gv) {\n        const char *const gvname = GvNAME(gv);\n        const HV *const stash = GvSTASH(gv);\n        const char *const hvname = stash ? HvNAME(stash) : NULL;\n\n        if (hvname)\n            Perl_croak(aTHX_ \"Usage: %s::%s(%s)\", hvname, gvname, params);\n        else\n            Perl_croak(aTHX_ \"Usage: %s(%s)\", gvname, params);\n    } else {\n        /* Pants. I don't think that it should be possible to get here. */\n        Perl_croak(aTHX_ \"Usage: CODE(0x%\"UVxf\")(%s)\", PTR2UV(cv), params);\n    }\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "STATIC",
        "void",
        "void"
      ]
    },
    "XS_TestXS_init": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "XS_EUPXS(XS_TestXS_init)\n{\n    dVAR; dXSARGS;\n    if (items != 0)\n       croak_xs_usage(cv,  \"\");\n    {\n\tint\tRETVAL;\n\tdXSTARG;\n#line 19 \"TestXS.xs\"\n        puts (\"message from XS module\\n\");\n#line 177 \"TestXS.c\"\n    }\n    XSRETURN(1);\n}",
      "lines": 14,
      "depth": 8,
      "decorators": null
    },
    "boot_TestXS": {
      "start_point": [
        184,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "XS_EXTERNAL(boot_TestXS)\n{\n    dVAR; dXSARGS;\n#if (PERL_REVISION == 5 && PERL_VERSION < 9)\n    char* file = __FILE__;\n#else\n    const char* file = __FILE__;\n#endif\n\n    PERL_UNUSED_VAR(cv); /* -W */\n    PERL_UNUSED_VAR(items); /* -W */\n#ifdef XS_APIVERSION_BOOTCHECK\n    XS_APIVERSION_BOOTCHECK;\n#endif\n    XS_VERSION_BOOTCHECK;\n\n        (void)newXSproto_portable(\"TestXS::init\", XS_TestXS_init, file, \"\");\n#if (PERL_REVISION == 5 && PERL_VERSION >= 9)\n  if (PL_unitcheckav)\n       call_list(PL_scopestack_ix, PL_unitcheckav);\n#endif\n    XSRETURN_YES;\n}",
      "lines": 23,
      "depth": 8,
      "decorators": null
    }
  },
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/text.c": {
    "text_alloc": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "static void\ntext_alloc (TEXT *t, size_t len)\n{\n  if (t->end + len > t->space)\n    {\n      /* FIXME: Double it instead? */\n      t->space = t->end + len;\n      if (t->space < 10)\n        t->space = 10;\n      t->text = realloc (t->text, t->space);\n      if (!t->text)\n        abort ();\n    }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "text_printf": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "void\ntext_printf (TEXT *t, char *format, ...)\n{\n  va_list v;\n  char *s;\n\n  va_start (v, format);\n  vasprintf (&s, format, v);\n  text_append (t, s);\n  free (s);\n  va_end (v);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "text_append_n": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "void\ntext_append_n (TEXT *t, char *s, size_t len)\n{\n  text_alloc (t, len + 1);\n  memcpy (t->text + t->end, s, len);\n  t->end += len;\n  t->text[t->end] = '\\0';\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "text_append": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "void\ntext_append (TEXT *t, char *s)\n{\n  size_t len = strlen (s);\n  text_append_n (t, s, len);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "text_init": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "void\ntext_init (TEXT *t)\n{\n  t->end = t->space = 0;\n  t->text = 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "text_destroy": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "void\ntext_destroy (TEXT *t)\n{\n  t->end = t->space = 0;\n  free(t->text); t->text = 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/text.h": {},
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/xspara.c": {
    "w32_setlocale": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "char *\nw32_setlocale (int category, const char *value)\n{\n  if (_stricmp (value, \"en_us.utf-8\") != 0)\n    return NULL;\n\n  /* Switch to the Windows U.S. English locale with its default\n     codeset.  We will handle the non-ASCII text ourselves, so the\n     codeset is unimportant, and Windows doesn't support UTF-8 as the\n     codeset anyway.  */\n  return setlocale (category, \"ENU\");\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "char",
        "*\nw32_setlocale (int category, const char *value)",
        "*"
      ]
    },
    "mbrlen": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "size_t\nmbrlen (const char * __restrict__ mbs, size_t n, mbstate_t * __restrict__ ps)\n{\n  unsigned char byte1 = *mbs;\n\n  if (ps != NULL)\n    {\n      errno = ENOSYS;\n      return -1;\n    }\n\n  return\n    ((byte1 & 0x80) == 0) ? 1 : ((byte1 & 0x20) == 0) ? 2 :\n    ((byte1 & 0x10) == 0) ? 3 : 4;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    },
    "mbrtowc": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "size_t\nmbrtowc (wchar_t * __restrict__ pwc, const char * __restrict__ mbs, size_t n,\n\t mbstate_t * __restrict__ ps)\n{\n  int len = mbrlen (mbs, n, ps);\n\n  if (mbs == NULL)\n    return 0;\n  else\n    {\n      wchar_t wc[2];\n      size_t n_utf16 = MultiByteToWideChar (CP_UTF8, MB_ERR_INVALID_CHARS,\n\t\t\t\t\t    mbs, len, wc, 2);\n      if (n_utf16 == 0)\n\t{\n\t  errno = EILSEQ;\n\t  return (size_t)-1;\n\t}\n      if (ps != NULL)\n\t{\n\t  errno = ENOSYS;\n\t  return (size_t)-1;\n\t}\n      /* We don't support UTF-16 surrogates, because the calling code\n\t doesn't, and because character classification functions on\n\t Windows don't support anything beyond the BMP anyway.  So we\n\t return the first character of the surrogate pair and set\n\t errno.  */\n      if (n_utf16 > 1)\n\terrno = ENOSYS;\n      if (pwc != NULL)\n\t*pwc = wc[0];\n\n      return len;\n    }\n}",
      "lines": 36,
      "depth": 10,
      "decorators": [
        "size_t"
      ]
    },
    "iswspace": {
      "start_point": [
        188,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "int\niswspace (wint_t wc)\n{\n  /* See Unicode's Proplist.txt.  */\n  if ((wc >= 0x09 && wc <= 0x0D)\n      || wc == 0x20\n      || wc == 0x85\n      || wc == 0xA0\n      || wc == 0x1680\n      || (wc >= 0x2000 && wc <= 0x200A)\n      || wc == 0x2028\n      || wc == 0x2029\n      || wc == 0x202F\n      || wc == 0x205F\n      || wc == 0x3000)\n    return 1;\n\n  return 0;\n}",
      "lines": 19,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "wcwidth": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "int\nwcwidth (const wchar_t wc)\n{\n  return wc == 0 ? 0 : 1;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "iswupper": {
      "start_point": [
        215,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "int\niswupper (wint_t wi)\n{\n  WORD char_type;\n  wchar_t wc = wi;\n  BOOL status = GetStringTypeW (CT_CTYPE1, &wc, 1, &char_type);\n\n  if (!status || (char_type & C1_UPPER) == 0)\n    return 0;\n\n  return 1;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "xspara_init": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "int\nxspara_init (void)\n{\n  char *utf8_locale = 0;\n  int len;\n  char *cur;\n  char *dot;\n\n  dTHX;\n\n  if (setlocale (LC_CTYPE, \"en_US.UTF-8\")\n      || setlocale (LC_CTYPE, \"en_US.utf8\"))\n    goto success;\n\n  cur = setlocale (LC_CTYPE, 0); /* Name of current locale. */\n  if (!cur)\n    goto failure;\n  len = strlen (cur);\n  if (len >= 6 && !memcmp (\".UTF-8\", cur + len - 6, 6)\n      || len >= 5 && !memcmp (\".utf8\", cur + len - 5, 5)\n      || len >= 6 && !memcmp (\".utf-8\", cur + len - 6, 6)\n      || len >= 5 && !memcmp (\".UTF8\", cur + len - 5, 5))\n    {\n      setlocale (LC_CTYPE, \"\"); /* Use the locale from the environment. */\n      goto success;\n    }\n\n  /* Otherwise try altering the current locale name. */\n  dot = strchr (cur, '.');\n  if (!dot)\n    dot = cur + len;\n  utf8_locale = malloc (len + 6 + 1); /* enough to add \".UTF-8\" to end */\n  memcpy (utf8_locale, cur, dot - cur);\n  dot = utf8_locale + (dot - cur);\n  memcpy (dot, \".UTF-8\", 7);\n  if (setlocale (LC_CTYPE, utf8_locale))\n    goto success;\n\n  memcpy (dot, \".utf8\", 6);\n  if (setlocale (LC_CTYPE, utf8_locale))\n    goto success;\n\n  /* Otherwise, look for any UTF-8 locale in the output of \"locale -a\". */\n  {\n  FILE *p;\n  char *line = 0;\n  size_t n = 0;\n  ssize_t ret;\n  p = popen (\"locale -a\", \"r\");\n  if (!p)\n    goto failure;\n  while (1)\n    {\n      ret = getline (&line, &n, p);\n      if (ret == (ssize_t) -1)\n        {\n          free (line);\n          pclose (p);\n          goto failure;\n        }\n      if (strstr (line, \"UTF-8\") || strstr (line, \"utf8\"))\n        {\n          line[ret - 1] = '\\0';   /* Remove trailing newline. */\n          if (setlocale (LC_CTYPE, line))\n            {\n              free (line);\n              pclose (p);\n              goto success;\n            }\n        }\n    }\n  }\n      \n  if (1)\n    {\nfailure:\n      return 0; /* failure */\n    }\n  else\n    {\nsuccess: ;\n      free (utf8_locale);\n      /*\n      fprintf (stderr, \"tried to set LC_CTYPE to UTF-8.\\n\");\n      fprintf (stderr, \"character encoding is: %s\\n\",\n               nl_langinfo (CODESET));\n       */\n      return 1; /* success */\n    }\n}",
      "lines": 90,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "xspara__switch_state": {
      "start_point": [
        338,
        0
      ],
      "end_point": [
        348,
        1
      ],
      "content": "static void\nxspara__switch_state (int id)\n{\n  if (current_state == id)\n    return;\n  if (current_state != -1)\n    memcpy (&state_array[current_state], &state, sizeof (PARAGRAPH));\n\n  memcpy (&state, &state_array[id], sizeof (PARAGRAPH));\n  current_state = id;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xspara_new": {
      "start_point": [
        350,
        0
      ],
      "end_point": [
        395,
        1
      ],
      "content": "int\nxspara_new (HV *conf)\n{\n  int i;\n\n  dTHX; /* Perl boiler plate */\n\n  TEXT saved_space, saved_word;\n\n  /* Find an unused slot in state_array */\n  for (i = 0; i < state_array_size; i++)\n    {\n      if (!state_array[i].in_use)\n        break;\n    }\n  if (i == state_array_size)\n    {\n      state_array = realloc (state_array,\n                             (state_array_size += 10) * sizeof (PARAGRAPH));\n      memset (state_array + i, 0, 10 * sizeof (PARAGRAPH));\n    }\n\n  state_array[i].in_use = 1;\n  xspara__switch_state (i);\n\n  /* Zero formatter, reusing storage. */\n  saved_space = state.space;\n  saved_word = state.word;\n  memset (&state, 0, sizeof (state));\n  state.space = saved_space;\n  state.word = saved_word;\n  state.space.end = state.word.end = 0;\n  state.in_use = 1;\n\n  /* Default values. */\n  state.max = 72;\n  state.indent_length_next = -1; /* Special value meaning undefined. */\n  state.end_sentence = -2; /* Special value meaning undefined. */\n  state.last_letter = L'\\0';\n\n  if (conf)\n    xspara_init_state (conf);\n\n  /* The paragraph ID. */\n  return i;\n}",
      "lines": 46,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "xspara_set_state": {
      "start_point": [
        399,
        0
      ],
      "end_point": [
        405,
        1
      ],
      "content": "void\nxspara_set_state (SV *sv)\n{\n  dTHX;\n\n  xspara__switch_state (SvIV (sv));\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "xspara_init_state": {
      "start_point": [
        408,
        0
      ],
      "end_point": [
        457,
        1
      ],
      "content": "void\nxspara_init_state (HV *hash)\n{\n#define FETCH(key) hv_fetch (hash, key, strlen (key), 0)\n#define FETCH_INT(key,where) { val = FETCH(key); \\\n                               if (val) { where = SvIV (*val); } }\n\n  SV **val;\n  \n  dTHX; /* This is boilerplate for interacting with Perl. */\n\n  /* Fetch all these so they are set, and reset for each paragraph. */\n  FETCH_INT(\"end_sentence\", state.end_sentence);\n  FETCH_INT(\"max\", state.max);\n\n  FETCH_INT(\"indent_length\", state.indent_length);\n  FETCH_INT(\"indent_length_next\", state.indent_length_next);\n  FETCH_INT(\"counter\", state.counter); \n\n  FETCH_INT(\"word_counter\", state.word_counter);\n\n  FETCH_INT(\"lines_counter\", state.lines_counter);\n  FETCH_INT(\"end_line_count\", state.end_line_count);\n\n  FETCH_INT(\"protect_spaces\", state.protect_spaces);\n  FETCH_INT(\"ignore_columns\", state.ignore_columns);\n  FETCH_INT(\"keep_end_lines\", state.keep_end_lines);\n  FETCH_INT(\"frenchspacing\", state.french_spacing);\n\n  FETCH_INT(\"unfilled\", state.unfilled);\n  FETCH_INT(\"no_final_newline\", state.no_final_newline);\n  FETCH_INT(\"add_final_space\", state.add_final_space);\n\n  val = FETCH(\"word\");\n  if (val)\n    {\n      fprintf (stderr, \"Bug: setting 'word' is not supported.\\n\");\n      abort ();\n    }\n  val = FETCH(\"space\");\n  if (val)\n    {\n      fprintf (stderr, \"Bug: setting 'space' is not supported.\\n\");\n      abort ();\n    }\n  return;\n\n#undef FETCH\n#undef FETCH_INT\n}",
      "lines": 50,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "xspara_get_state": {
      "start_point": [
        460,
        0
      ],
      "end_point": [
        490,
        1
      ],
      "content": "void\nxspara_get_state (HV *hash)\n{\n  /* TODO: The last argument of hv_store would be a precomputed hash, which\n     would save the time of calculating it. */\n#define STORE(key) hv_store (hash, key, strlen (key), val, 0)\n\n  SV *val;\n\n  /* Don't do anything. */\n  return;\n\n  dTHX; /* Perl boilerplate. */\n\n  val = newSViv (state.end_sentence);\n  STORE(\"end_sentence\");\n\n  val = newSViv (state.counter);\n  STORE(\"counter\");\n\n  val = newSViv (state.word_counter);\n  STORE(\"word_counter\");\n\n  val = newSViv (state.lines_counter);\n  STORE(\"lines_counter\");\n\n  return;\n\n\n#undef STORE\n}",
      "lines": 31,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "xspara__cut_line": {
      "start_point": [
        497,
        0
      ],
      "end_point": [
        506,
        1
      ],
      "content": "void\nxspara__cut_line (TEXT *result)\n{\n  if (!state.ignore_columns)\n    {\n      xspara__end_line ();\n\n      text_append (result, \"\\n\");\n    }\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "xspara_end_line_count": {
      "start_point": [
        508,
        0
      ],
      "end_point": [
        512,
        1
      ],
      "content": "int\nxspara_end_line_count (void)\n{\n  return state.end_line_count;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "xspara__end_line": {
      "start_point": [
        516,
        0
      ],
      "end_point": [
        532,
        1
      ],
      "content": "void\nxspara__end_line (void)\n{\n  state.counter = 0;\n  state.space.end = 0;\n  state.space_counter = 0;\n\n  /* This will only be true for the first line of output. */\n  if (state.indent_length_next != -1)\n    {\n      state.indent_length = state.indent_length_next;\n      state.indent_length_next = -1;\n    }\n\n  state.lines_counter++;\n  state.end_line_count++;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "xspara_end_line": {
      "start_point": [
        534,
        0
      ],
      "end_point": [
        540,
        1
      ],
      "content": "char *\nxspara_end_line (void)\n{\n  state.end_line_count = 0;\n  xspara__end_line ();\n  return \"\\n\";\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "char",
        "*\nxspara_end_line (void)",
        "*"
      ]
    },
    "xspara_get_pending": {
      "start_point": [
        543,
        0
      ],
      "end_point": [
        551,
        1
      ],
      "content": "char *\nxspara_get_pending (void)\n{\n  TEXT t;\n  text_init (&t);\n  text_append_n (&t, state.space.text, state.space.end);\n  text_append_n (&t, state.word.text, state.word.end);\n  return t.text;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "char",
        "*\nxspara_get_pending (void)",
        "*"
      ]
    },
    "xspara__add_pending_word": {
      "start_point": [
        556,
        0
      ],
      "end_point": [
        597,
        1
      ],
      "content": "void\nxspara__add_pending_word (TEXT *result, int add_spaces)\n{\n  if (state.word.end == 0 && !state.invisible_pending_word && !add_spaces)\n    return;\n\n  if (state.indent_length > state.counter)\n    {\n      int i;\n      /* If we are not up to the left margin yet, output spaces to get there, \n         and ignore 'state.space', the pending space string.  In this case \n         state.counter is probably 0.  */\n\n      for (i = 0; i < state.indent_length - state.counter; i++)\n        text_append (result, \" \");\n      state.counter = state.indent_length;\n\n      /* Do not output leading spaces after the indent, unless 'unfilled'\n         is on.  */\n      if (!state.unfilled)\n        state.space.end = 0;\n    }\n\n  if (state.space.end > 0)\n    {\n      text_append_n (result, state.space.text, state.space.end);\n\n      state.counter += state.space_counter;\n      state.space.end = 0;\n      state.space_counter = 0;\n    }\n\n  if (state.word.end > 0 || state.invisible_pending_word)\n    {\n      text_append_n (result, state.word.text, state.word.end);\n      state.counter += state.word_counter;\n\n      state.word.end = 0;\n      state.word_counter = 0;\n      state.invisible_pending_word = 0;\n    }\n}",
      "lines": 42,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "xspara_add_pending_word": {
      "start_point": [
        600,
        0
      ],
      "end_point": [
        612,
        1
      ],
      "content": "char *\nxspara_add_pending_word (int add_spaces)\n{\n  TEXT ret;\n\n  text_init (&ret);\n  state.end_line_count = 0;\n  xspara__add_pending_word (&ret, add_spaces);\n  if (ret.text)\n    return ret.text;\n  else\n    return \"\";\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "char",
        "*\nxspara_add_pending_word (int add_spaces)",
        "*"
      ]
    },
    "xspara_end": {
      "start_point": [
        615,
        0
      ],
      "end_point": [
        640,
        1
      ],
      "content": "char *\nxspara_end (void)\n{\n  TEXT ret;\n  text_init (&ret);\n  state.end_line_count = 0;\n  xspara__add_pending_word (&ret, state.add_final_space);\n  if (!state.no_final_newline && state.counter != 0)\n    {\n      text_append (&ret, \"\\n\");\n      state.lines_counter++;\n      state.end_line_count++;\n    }\n\n  /* Now it's time to forget about the state. */\n  state_array[current_state].in_use = 0;\n  state.in_use = 0;\n\n  /* Don't do this so we can get the closing line counts. */\n  /* current_state = -1; */\n\n  if (ret.text)\n    return ret.text;\n  else\n    return \"\";\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "char",
        "*\nxspara_end (void)",
        "*"
      ]
    },
    "xspara__add_next": {
      "start_point": [
        646,
        0
      ],
      "end_point": [
        760,
        1
      ],
      "content": "void\nxspara__add_next (TEXT *result, char *word, int word_len, int transparent)\n{\n  int disinhibit = 0;\n  if (!word)\n    return;\n\n  if (word_len >= 1 && word[word_len - 1] == '\\b')\n    {\n      word[--word_len] = '\\0';\n      disinhibit = 1;\n    }\n\n  if (state.word.end == 0 && !state.invisible_pending_word)\n    {\n      /* Check if we are at the end of a sentence and if we need to\n         output two spaces after the full stop.  If so, check if the\n         word we are given begins with whitespace.  If it doesn't,\n         double the pending space.\n\n         We checked above if there was a pending word because if there\n         was, it is due to be output after the end-sentence whitespace,\n         not the string that was passed as an argument to this function.  \n       */\n      state.last_letter = L'\\0';\n\n      if (state.counter != 0 && state.space.end > 0\n          && state.end_sentence == 1 && !state.french_spacing)\n        {\n          wchar_t wc;\n          size_t char_len;\n\n          char_len = mbrtowc (&wc, word, word_len, NULL);\n          if ((long) char_len > 0 && !iswspace (wc))\n            {\n              /* Make the pending space up to two spaces. */\n              while (state.space_counter < 2)\n                {\n                  text_append_n (&state.space, \" \", 1);\n                  state.space_counter++;\n                }\n            }\n\n          state.end_sentence = -2;\n        }\n    }\n\n  text_append_n (&state.word, word, word_len);\n  if (word_len == 0 && word)\n    state.invisible_pending_word = 1;\n\n  if (!transparent)\n    {\n      if (disinhibit)\n        state.last_letter = L'a'; /* a lower-case letter */\n      else\n        {\n          /* Save last character in WORD */\n          char *p = word + word_len;\n          int len = 0;\n          while (p > word)\n            {\n              p--; len++;\n              if ((long) mbrlen(p, len, NULL) > 0)\n                {\n                  wchar_t wc = L'\\0';\n                  mbrtowc (&wc, p, len, NULL);\n                  if (!wcschr (L\".?!\\\"')]\", wc))\n                    {\n                      state.last_letter = wc;\n                      break;\n                    }\n                }\n            }\n\n        }\n    }\n\n  if (strchr (word, '\\n'))\n    {\n      /* If there was a newline in the word we just added, put the entire\n         pending ouput in the results string, and start a new line. */\n      xspara__add_pending_word (result, 0);\n      xspara__end_line ();\n    }\n  else\n    {\n      /* The possibility of two-column characters is ignored here. */\n\n      /* Calculate length of multibyte string in characters. */\n      int len = 0;\n      int left = word_len;\n      wchar_t w;\n      char *p = word;\n\n      while (left > 0)\n        {\n          int char_len = mbrtowc (&w, p, left, NULL);\n          left -= char_len;\n          p += char_len;\n          len++;\n        }\n\n      state.word_counter += len;\n    }\n\n  /* TODO: Shift this into the \"else\" clause above, because \n     xspara__end_line would have set state.counter to 0. */\n  if (state.counter != 0\n      && state.counter + state.word_counter + state.space_counter\n          > state.max)\n    {\n      xspara__cut_line (result);\n    }\n}",
      "lines": 115,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "xspara_add_next": {
      "start_point": [
        763,
        0
      ],
      "end_point": [
        776,
        1
      ],
      "content": "char *\nxspara_add_next (char *text, int text_len, int transparent)\n{\n  TEXT t;\n\n  text_init (&t);\n  state.end_line_count = 0;\n  xspara__add_next (&t, text, text_len, transparent);\n\n  if (t.space > 0)\n    return t.text;\n  else\n    return \"\";\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "char",
        "*\nxspara_add_next (char *text, int text_len, int transparent)",
        "*"
      ]
    },
    "xspara_remove_end_sentence": {
      "start_point": [
        778,
        0
      ],
      "end_point": [
        782,
        1
      ],
      "content": "void\nxspara_remove_end_sentence (void)\n{\n  state.end_sentence = 0;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "xspara_add_end_sentence": {
      "start_point": [
        784,
        0
      ],
      "end_point": [
        788,
        1
      ],
      "content": "void\nxspara_add_end_sentence (int value)\n{\n  state.end_sentence = value;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "xspara_allow_end_sentence": {
      "start_point": [
        790,
        0
      ],
      "end_point": [
        794,
        1
      ],
      "content": "void\nxspara_allow_end_sentence (void)\n{\n  state.last_letter = L'a'; /* A lower-case letter. */\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "xspara_set_space_protection": {
      "start_point": [
        797,
        0
      ],
      "end_point": [
        861,
        1
      ],
      "content": "char *\nxspara_set_space_protection (int protect_spaces,\n                             int ignore_columns,\n                             int keep_end_lines,\n                             int french_spacing,\n                             int double_width_no_break)\n{\n  if (protect_spaces != -1)\n    state.protect_spaces = protect_spaces;\n  if (ignore_columns != -1)\n    state.ignore_columns = ignore_columns;\n  if (keep_end_lines != -1)\n    state.keep_end_lines = keep_end_lines;\n  if (double_width_no_break != -1)\n    state.double_width_no_break = double_width_no_break;\n\n  /*fprintf (stderr, \"SETTING SPACE (%d, %d, %d, %d)\\n\",\n                                   protect_spaces,\n                                   ignore_columns,\n                                   keep_end_lines,\n                                   french_spacing);*/\n\n  /* If at the end of a sentence, and due to output the end of sentence\n     space, and we switch to French spacing, then make the space up to\n     two spaces.\n\n     FIXME: This seems back-to-front: We want two spaces if we switch FROM\n     French spacing. */\n\n  if (state.french_spacing == 0\n      && french_spacing != -1 && french_spacing != 0\n      && state.end_sentence != -2 && state.end_sentence != 0\n      && state.counter != 0\n      && state.space.end > 0\n      && state.word.end == 0 && !state.invisible_pending_word)\n    {\n      while (state.space_counter < 2)\n        {\n          text_append_n (&state.space, \" \", 1);\n          state.space_counter++;\n        }\n\n      /* End of sentence done. */\n      state.end_sentence = -2;\n    }\n\n  if (french_spacing != -1)\n    {\n      state.french_spacing = french_spacing;\n    }\n\n if (protect_spaces != -1 && state.protect_spaces)\n   {\n     if (state.word.end == 0)\n       {\n         /* In _add_pending_word this meant that an \"empty word\" would\n            be output.  This makes \"a @w{} b\" -> \"a  b\", not \"a b\", and\n            \"a @w{}\" at end of paragraph -> \"a \", not \"a\". */\n\n         state.invisible_pending_word = 1;\n       }\n   }\n\n return \"\"; /* TODO: Check if we can remove this. */\n}",
      "lines": 65,
      "depth": 15,
      "decorators": [
        "char",
        "*\nxspara_set_space_protection (int protect_spaces,\n                             int ignore_columns,\n                             int keep_end_lines,\n                             int french_spacing,\n                             int double_width_no_break)",
        "*"
      ]
    },
    "xspara_add_text": {
      "start_point": [
        869,
        0
      ],
      "end_point": [
        1185,
        1
      ],
      "content": "char *\nxspara_add_text (char *text)\n{\n  char *p = text;\n  int len;\n  wchar_t wc;\n  size_t char_len;\n  TEXT result;\n  dTHX;\n\n  text_init (&result);\n\n  len = strlen (text); /* FIXME: Get this as an argument */\n  state.end_line_count = 0;\n\n  while (len > 0)\n    {\n      char_len = mbrtowc (&wc, p, len, NULL);\n      if ((long) char_len == 0)\n        break; /* Null character. Shouldn't happen. */\n      else if ((long) char_len < 0)\n        {\n          p++; len--; /* Invalid.  Just try to keep going. */\n          continue;\n        }\n\n      /* 00A0 and 202F are non-breaking spaces in Unicode. */\n      if (iswspace (wc) && wc != L'\\x00a0' && wc != L'\\x202f')\n        {\n          state.last_letter = L'\\0';\n\n          /* If protect_spaces is on, ... */\n          if (state.protect_spaces)\n            {\n              /* Append the spaces to the pending word. */\n              text_append_n (&state.word, p, char_len);\n              state.word_counter++;\n\n              if (strchr (state.word.text, '\\n'))\n                {\n                  /* Replace any '\\n' with a ' '. Note that state.word_counter \n                     will still be correct after this. */\n                  char *ptr = state.word.text;\n                  while (*ptr)\n                    {\n                      if (*ptr == '\\n')\n                        *ptr = ' ';\n                      ptr++;\n                    }\n                }\n\n              if (state.counter != 0\n                  && state.counter + state.word_counter + state.space_counter\n                     > state.max)\n                {\n                  xspara__cut_line (&result);\n                }\n            }\n          else /* protect_spaces off */\n            {\n              int pending = state.invisible_pending_word;\n              xspara__add_pending_word (&result, 0);\n\n              if (state.counter != 0 || state.unfilled || pending)\n                {\n                  /* If we are at the end of a sentence where two spaces\n                     are required. */\n                  if (state.end_sentence == 1\n                      && !state.french_spacing\n                      && !state.unfilled)\n                    {\n                      wchar_t q_char;\n                      size_t q_len;\n                      int at_least_two = 0;\n\n                      /* Check if the next character is whitespace as well. */\n                      q_len = mbrtowc (&q_char,\n                                       p + char_len, len - char_len,\n                                       NULL);\n                      if ((long) q_len > 0)\n                        {\n                          if (iswspace (q_char))\n                            at_least_two = 1;\n                        }\n\n                      /* If we have an existing pending space, or if we have\n                         at least two whitespace characters in a row, set the\n                         pending space to be two whitespace characters.\n\n                         I don't know why we do it this way. */\n                      if (state.space_counter >= 1 || at_least_two)\n                        {\n                          if (state.space_counter > 0)\n                            {\n                              /* Truncate to at most 2 spaces, and replace any \n                                 '\\n' or '\\r' characters with ' '. */\n\n                              TEXT new_space;\n                              char *pspace;\n                              int pspace_left;\n                              int len;\n                              int i;\n\n                              text_init (&new_space);\n                              pspace = state.space.text;\n                              pspace_left = state.space.end;\n                              state.space_counter = 0;\n\n                              for (i = 0; i < 2; i++)\n                                {\n                                  if (!*pspace)\n                                    break;\n                                  len = mbrlen (pspace, pspace_left, NULL);\n\n                                  /* Substitute newlines in the pending space\n                                     with spaces. */\n                                  if (*pspace == '\\n' || *pspace == '\\r')\n                                    text_append_n (&new_space, \" \", 1);\n                                  else if (len > 0)\n                                    text_append_n (&new_space, pspace, len);\n                                  else\n                                    /* Skip one character and try again. */\n                                    len = 1;\n\n                                  state.space_counter++;\n\n                                  pspace += len;\n                                  pspace_left -= len;\n                                }\n\n                              state.space.end = 0;\n                              text_append_n (&state.space,\n                                             new_space.text, new_space.end);\n                              text_destroy (&new_space);\n                            }\n\n                          /* Now get characters from the input. */\n                          while (state.space_counter < 2)\n                            {\n                              if (*p == '\\n' || *p == '\\r')\n                                text_append_n (&state.space, \" \", 1);\n                              else\n                                text_append_n (&state.space, p, char_len);\n                              state.space_counter++;\n\n                              p += char_len; len -= char_len;\n                              char_len = mbrtowc (&wc, p, len, NULL);\n                              if ((long) char_len <= 0 || !iswspace (wc))\n                                break;\n                            }\n\n                          /* Skip any more following whitespace. */\n                          while ((long) char_len > 0 && iswspace (wc))\n                            {\n                              p += char_len; len -= char_len;\n                              char_len = mbrtowc (&wc, p, len, NULL);\n                            }\n\n                          /* Make it up to two characters. */\n                          while (state.space_counter < 2)\n                            {\n                              text_append_n (&state.space, \" \", 1);\n                              state.space_counter++;\n                            }\n\n                          /* Reset the end_sentence flag. */\n                          state.end_sentence = -2;\n                          continue;\n                        }\n                      else\n                        {\n                          /* Otherwise, an extra space is added\n                             in _add_next. */\n                          state.space.end = 0;\n                          state.space_counter = 0;\n                          if (*p == '\\n' || *p == '\\r')\n                            text_append_n (&state.space, \" \", 1);\n                          else\n                            text_append_n (&state.space, p, char_len);\n                          state.space_counter++;\n                        }\n\n                    }\n                  else /* Not at end of sentence. */\n                    {\n                      /* Only save the first space. */\n                      if (state.unfilled || state.space_counter < 1)\n                        {\n                          if (*p == '\\n' || *p == '\\r')\n                            {\n                              if (!state.unfilled)\n                                {\n                                  text_append_n (&state.space, \" \", 1);\n                                  state.space_counter++;\n                                }\n                              else if (*p == '\\n')\n                                {\n                                  xspara__add_pending_word (&result, 0);\n                                  xspara__end_line ();\n                                  text_append (&result, \"\\n\");\n                                }\n                            }\n                          else\n                            {\n                              text_append_n (&state.space, p, char_len);\n                              state.space_counter++;\n                            }\n                        }\n                    }\n                }\n            }\n\n          /* If not enough space in the line for the pending space, start\n             a new line. */\n          if (state.counter + state.space_counter > state.max)\n            {\n              xspara__cut_line (&result);\n            }\n\n          if (!state.unfilled && *p == '\\n' && state.keep_end_lines)\n            {\n              xspara__end_line ();\n              text_append (&result, \"\\n\");\n            }\n        }\n      else /************** Not a white space character. *****************/\n        {\n          int width = wcwidth (wc);\n          /*************** Double width character. *********************/\n          if (width == 2)\n            {\n              state.last_letter = L'\\0';\n\n              /* We allow a line break in between Chinese characters even if \n                 there was no space between them, unlike single-width \n                 characters. */\n\n              /* Append wc to state.word. */\n              text_append_n (&state.word, p, char_len);\n\n              state.word_counter += 2;\n\n              if (state.counter != 0\n                  && state.counter + state.word_counter > state.max)\n                {\n                  xspara__cut_line (&result);\n                }\n              /* If protect_spaces is on, accumulate the characters so that\n                 they can be pushed onto the next line if necessary. */\n              if (!state.protect_spaces && !state.double_width_no_break)\n                {\n                  xspara__add_pending_word (&result, 0);\n                  state.end_sentence = -2;\n                }\n            }\n          /*************** Word character ******************************/\n          else if (width == 1)\n            {\n              char *added_word;\n              added_word = malloc (char_len + 1);\n              memcpy (added_word, p, char_len);\n              added_word[char_len] = '\\0';\n\n              xspara__add_next (&result, added_word, char_len, 0);\n              free (added_word);\n\n              /* Now check if it is considered as an end of sentence, and\n                 set state.end_sentence if it is. */\n\n              if (strchr (\".?!\", *p) && !state.unfilled)\n                {\n                  /* Doesn't count if preceded by an upper-case letter. */\n                  if (!iswupper (state.last_letter))\n                    {\n                      if (state.french_spacing)\n                        state.end_sentence = -1;\n                      else\n                        state.end_sentence = 1;\n                    }\n                }\n              else if (strchr (\"\\\"')]\", *p))\n                {\n                  /* '\"', '\\'', ']' and ')' are ignored for the purpose\n                   of deciding whether a full stop ends a sentence. */\n                }\n              else\n                {\n                  /* Otherwise reset the end of sentence marker: a full stop in \n                     a string like \"aaaa.bbbb\" doesn't mark an end of \n                     sentence. */\n                  state.end_sentence = -2;\n                  state.last_letter = wc;\n                }\n            }\n          else if (wc == L'\\b')\n            {\n              /* Code to say that a following full stop (or question or\n                 exclamation mark) may be an end of sentence. */\n              xspara_allow_end_sentence ();\n            }\n          else\n            {\n              /* Not printable, possibly a tab, or a combining character.\n                 Add it to the pending word without increasing the column \n                 count. */\n              text_append_n (&state.word, p, char_len);\n            }\n        }\n\n      p += char_len; len -= char_len;\n    }\n\n  if (result.space > 0)\n    return result.text;\n  else\n    return \"\";\n}",
      "lines": 317,
      "depth": 25,
      "decorators": [
        "char",
        "*\nxspara_add_text (char *text)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/xspara.h": {},
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/XSParagraph.c": {
    "S_croak_xs_usage": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "STATIC void\nS_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)\n{\n    const GV *const gv = CvGV(cv);\n\n    PERL_ARGS_ASSERT_CROAK_XS_USAGE;\n\n    if (gv) {\n        const char *const gvname = GvNAME(gv);\n        const HV *const stash = GvSTASH(gv);\n        const char *const hvname = stash ? HvNAME(stash) : NULL;\n\n        if (hvname)\n            Perl_croak(aTHX_ \"Usage: %s::%s(%s)\", hvname, gvname, params);\n        else\n            Perl_croak(aTHX_ \"Usage: %s(%s)\", gvname, params);\n    } else {\n        /* Pants. I don't think that it should be possible to get here. */\n        Perl_croak(aTHX_ \"Usage: CODE(0x%\"UVxf\")(%s)\", PTR2UV(cv), params);\n    }\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "STATIC",
        "void",
        "void"
      ]
    },
    "XS_Texinfo__Convert__XSParagraph__XSParagraph_init": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "XS_EUPXS(XS_Texinfo__Convert__XSParagraph__XSParagraph_init)\n{\n    dVAR; dXSARGS;\n    if (items != 0)\n       croak_xs_usage(cv,  \"\");\n    {\n\tint\tRETVAL;\n\tdXSTARG;\n\n\tRETVAL = xspara_init();\n\tXSprePUSH; PUSHi((IV)RETVAL);\n    }\n    XSRETURN(1);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": null
    },
    "XS_Texinfo__Convert__XSParagraph__XSParagraph_set_state": {
      "start_point": [
        184,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "XS_EUPXS(XS_Texinfo__Convert__XSParagraph__XSParagraph_set_state)\n{\n    dVAR; dXSARGS;\n    if (items != 1)\n       croak_xs_usage(cv,  \"state\");\n    {\n\tSV *\tstate = ST(0)\n;\n\n\txspara_set_state(state);\n    }\n    XSRETURN_EMPTY;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": null
    },
    "XS_Texinfo__Convert__XSParagraph__XSParagraph_new": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        232,
        1
      ],
      "content": "XS_EUPXS(XS_Texinfo__Convert__XSParagraph__XSParagraph_new)\n{\n    dVAR; dXSARGS;\n    if (items < 1)\n       croak_xs_usage(cv,  \"class, ...\");\n    {\n\tSV *\tclass = ST(0)\n;\n#line 47 \"XSParagraph.xs\"\n        HV *pkg;\n        HV *conf = 0;\n        int id;\n#line 214 \"XSParagraph.c\"\n\tSV *\tRETVAL;\n#line 51 \"XSParagraph.xs\"\n        items--;\n        if (items > 0)\n          {\n            if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVHV)\n              conf = (HV *) SvRV(ST(1));\n          }\n        id = xspara_new (conf);\n\n        /* Create a blessed integer, which the other functions\n           need as their first argument. */\n        pkg = gv_stashpv (\"Texinfo::Convert::XSParagraph::XSParagraph\", 0);\n        RETVAL = newSViv (id);\n#line 229 \"XSParagraph.c\"\n\tST(0) = RETVAL;\n\tsv_2mortal(ST(0));\n    }\n    XSRETURN(1);\n}",
      "lines": 33,
      "depth": 16,
      "decorators": null
    },
    "XS_Texinfo__Convert__XSParagraph__XSParagraph_end_line_count": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        253,
        1
      ],
      "content": "XS_EUPXS(XS_Texinfo__Convert__XSParagraph__XSParagraph_end_line_count)\n{\n    dVAR; dXSARGS;\n    if (items != 1)\n       croak_xs_usage(cv,  \"paragraph\");\n    {\n\tSV *\tparagraph = ST(0)\n;\n\tint\tRETVAL;\n\tdXSTARG;\n#line 71 \"XSParagraph.xs\"\n        xspara_set_state (paragraph);\n        RETVAL = xspara_end_line_count ();\n#line 251 \"XSParagraph.c\"\n\tXSprePUSH; PUSHi((IV)RETVAL);\n    }\n    XSRETURN(1);\n}",
      "lines": 18,
      "depth": 9,
      "decorators": null
    },
    "XS_Texinfo__Convert__XSParagraph__XSParagraph__end_line": {
      "start_point": [
        257,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "XS_EUPXS(XS_Texinfo__Convert__XSParagraph__XSParagraph__end_line)\n{\n    dVAR; dXSARGS;\n    if (items != 1)\n       croak_xs_usage(cv,  \"paragraph\");\n    {\n\tSV *\tparagraph = ST(0)\n;\n#line 80 \"XSParagraph.xs\"\n        xspara_set_state (paragraph);\n        xspara__end_line ();\n#line 270 \"XSParagraph.c\"\n    }\n    XSRETURN_EMPTY;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": null
    },
    "XS_Texinfo__Convert__XSParagraph__XSParagraph_end_line": {
      "start_point": [
        275,
        0
      ],
      "end_point": [
        292,
        1
      ],
      "content": "XS_EUPXS(XS_Texinfo__Convert__XSParagraph__XSParagraph_end_line)\n{\n    dVAR; dXSARGS;\n    if (items != 1)\n       croak_xs_usage(cv,  \"paragraph\");\n    {\n\tSV *\tparagraph = ST(0)\n;\n\tchar *\tRETVAL;\n\tdXSTARG;\n#line 87 \"XSParagraph.xs\"\n        xspara_set_state (paragraph);\n        RETVAL = xspara_end_line ();\n#line 290 \"XSParagraph.c\"\n\tsv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;\n    }\n    XSRETURN(1);\n}",
      "lines": 18,
      "depth": 8,
      "decorators": null
    },
    "XS_Texinfo__Convert__XSParagraph__XSParagraph_get_pending": {
      "start_point": [
        296,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "XS_EUPXS(XS_Texinfo__Convert__XSParagraph__XSParagraph_get_pending)\n{\n    dVAR; dXSARGS;\n    if (items != 1)\n       croak_xs_usage(cv,  \"paragraph\");\n    {\n\tSV *\tparagraph = ST(0)\n;\n\tchar *\tRETVAL;\n\tdXSTARG;\n#line 96 \"XSParagraph.xs\"\n        xspara_set_state (paragraph);\n        RETVAL = xspara_get_pending ();\n#line 311 \"XSParagraph.c\"\n\tsv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;\n    }\n    XSRETURN(1);\n}",
      "lines": 18,
      "depth": 8,
      "decorators": null
    },
    "XS_Texinfo__Convert__XSParagraph__XSParagraph_add_pending_word": {
      "start_point": [
        317,
        0
      ],
      "end_point": [
        349,
        1
      ],
      "content": "XS_EUPXS(XS_Texinfo__Convert__XSParagraph__XSParagraph_add_pending_word)\n{\n    dVAR; dXSARGS;\n    if (items < 1)\n       croak_xs_usage(cv,  \"paragraph, ...\");\n    {\n\tSV *\tparagraph = ST(0)\n;\n#line 106 \"XSParagraph.xs\"\n        int add_spaces = 0;\n        char *retval;\n#line 330 \"XSParagraph.c\"\n\tSV *\tRETVAL;\n#line 109 \"XSParagraph.xs\"\n        items -= 1;\n        if (items > 0)\n          {\n            if (SvOK(ST(1)))\n              {\n                add_spaces = (int)SvIV(ST(1));;\n              }\n          }\n        xspara_set_state (paragraph);\n        retval = xspara_add_pending_word (add_spaces);\n\n        RETVAL = newSVpv (retval, 0);\n        SvUTF8_on (RETVAL);\n#line 346 \"XSParagraph.c\"\n\tST(0) = RETVAL;\n\tsv_2mortal(ST(0));\n    }\n    XSRETURN(1);\n}",
      "lines": 33,
      "depth": 15,
      "decorators": null
    },
    "XS_Texinfo__Convert__XSParagraph__XSParagraph_end": {
      "start_point": [
        353,
        0
      ],
      "end_point": [
        376,
        1
      ],
      "content": "XS_EUPXS(XS_Texinfo__Convert__XSParagraph__XSParagraph_end)\n{\n    dVAR; dXSARGS;\n    if (items != 1)\n       croak_xs_usage(cv,  \"paragraph\");\n    {\n\tSV *\tparagraph = ST(0)\n;\n#line 129 \"XSParagraph.xs\"\n        char *retval;\n#line 365 \"XSParagraph.c\"\n\tSV *\tRETVAL;\n#line 131 \"XSParagraph.xs\"\n        xspara_set_state (paragraph);\n        retval = xspara_end ();\n\n        RETVAL = newSVpv (retval, 0);\n        SvUTF8_on (RETVAL);\n#line 373 \"XSParagraph.c\"\n\tST(0) = RETVAL;\n\tsv_2mortal(ST(0));\n    }\n    XSRETURN(1);\n}",
      "lines": 24,
      "depth": 9,
      "decorators": null
    },
    "XS_Texinfo__Convert__XSParagraph__XSParagraph_add_text": {
      "start_point": [
        380,
        0
      ],
      "end_point": [
        414,
        1
      ],
      "content": "XS_EUPXS(XS_Texinfo__Convert__XSParagraph__XSParagraph_add_text)\n{\n    dVAR; dXSARGS;\n    if (items != 2)\n       croak_xs_usage(cv,  \"paragraph, text_in\");\n    {\n\tSV *\tparagraph = ST(0)\n;\n\tSV *\ttext_in = ST(1)\n;\n#line 145 \"XSParagraph.xs\"\n        char *text;\n        char *retval;\n#line 395 \"XSParagraph.c\"\n\tSV *\tRETVAL;\n#line 148 \"XSParagraph.xs\"\n        /* Always convert the input to UTF8 with sv_utf8_upgrade, so we can \n           process it properly in xspara_add_next. */\n        if (!SvUTF8 (text_in))\n          sv_utf8_upgrade (text_in);\n\n        text = SvPV_nolen (text_in);\n\n        xspara_set_state (paragraph);\n        retval = xspara_add_text (text);\n\n        RETVAL = newSVpv (retval, 0);\n        SvUTF8_on (RETVAL);\n\n#line 411 \"XSParagraph.c\"\n\tST(0) = RETVAL;\n\tsv_2mortal(ST(0));\n    }\n    XSRETURN(1);\n}",
      "lines": 35,
      "depth": 9,
      "decorators": null
    },
    "XS_Texinfo__Convert__XSParagraph__XSParagraph_add_next": {
      "start_point": [
        418,
        0
      ],
      "end_point": [
        463,
        1
      ],
      "content": "XS_EUPXS(XS_Texinfo__Convert__XSParagraph__XSParagraph_add_next)\n{\n    dVAR; dXSARGS;\n    if (items < 2)\n       croak_xs_usage(cv,  \"paragraph, text_in, ...\");\n    {\n\tSV *\tparagraph = ST(0)\n;\n\tSV *\ttext_in = ST(1)\n;\n#line 169 \"XSParagraph.xs\"\n        char *text;\n        STRLEN text_len;\n        char *retval;\n        SV *arg_in;\n        int transparent = 0;\n#line 436 \"XSParagraph.c\"\n\tSV *\tRETVAL;\n#line 175 \"XSParagraph.xs\"\n        items -= 2;\n        if (items > 0)\n          {\n            items--;\n            arg_in = ST(2);\n            if (SvOK(arg_in))\n              transparent = (int)SvIV(arg_in);\n          }\n\n        /* Always convert the input to UTF8 with sv_utf8_upgrade, so we can \n           process it properly in xspara_add_next. */\n        if (!SvUTF8 (text_in))\n          sv_utf8_upgrade (text_in);\n        text = SvPV (text_in, text_len);\n\n        xspara_set_state (paragraph);\n        retval = xspara_add_next (text, text_len, transparent);\n\n        RETVAL = newSVpv (retval, 0);\n        SvUTF8_on (RETVAL);\n\n#line 460 \"XSParagraph.c\"\n\tST(0) = RETVAL;\n\tsv_2mortal(ST(0));\n    }\n    XSRETURN(1);\n}",
      "lines": 46,
      "depth": 12,
      "decorators": null
    },
    "XS_Texinfo__Convert__XSParagraph__XSParagraph_remove_end_sentence": {
      "start_point": [
        467,
        0
      ],
      "end_point": [
        481,
        1
      ],
      "content": "XS_EUPXS(XS_Texinfo__Convert__XSParagraph__XSParagraph_remove_end_sentence)\n{\n    dVAR; dXSARGS;\n    if (items != 1)\n       croak_xs_usage(cv,  \"paragraph\");\n    {\n\tSV *\tparagraph = ST(0)\n;\n#line 204 \"XSParagraph.xs\"\n        xspara_set_state (paragraph);\n        xspara_remove_end_sentence ();\n#line 480 \"XSParagraph.c\"\n    }\n    XSRETURN_EMPTY;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": null
    },
    "XS_Texinfo__Convert__XSParagraph__XSParagraph_add_end_sentence": {
      "start_point": [
        485,
        0
      ],
      "end_point": [
        506,
        1
      ],
      "content": "XS_EUPXS(XS_Texinfo__Convert__XSParagraph__XSParagraph_add_end_sentence)\n{\n    dVAR; dXSARGS;\n    if (items != 2)\n       croak_xs_usage(cv,  \"paragraph, value\");\n    {\n\tSV *\tparagraph = ST(0)\n;\n\tSV *\tvalue = ST(1)\n;\n#line 212 \"XSParagraph.xs\"\n        int intvalue = 0;\n#line 499 \"XSParagraph.c\"\n#line 214 \"XSParagraph.xs\"\n        if (SvOK(value))\n          intvalue = (int)SvIV(value);\n        xspara_set_state (paragraph);\n        xspara_add_end_sentence (intvalue);\n#line 505 \"XSParagraph.c\"\n    }\n    XSRETURN_EMPTY;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": null
    },
    "XS_Texinfo__Convert__XSParagraph__XSParagraph_allow_end_sentence": {
      "start_point": [
        510,
        0
      ],
      "end_point": [
        524,
        1
      ],
      "content": "XS_EUPXS(XS_Texinfo__Convert__XSParagraph__XSParagraph_allow_end_sentence)\n{\n    dVAR; dXSARGS;\n    if (items != 1)\n       croak_xs_usage(cv,  \"paragraph\");\n    {\n\tSV *\tparagraph = ST(0)\n;\n#line 223 \"XSParagraph.xs\"\n        xspara_set_state (paragraph);\n        xspara_allow_end_sentence ();\n#line 523 \"XSParagraph.c\"\n    }\n    XSRETURN_EMPTY;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": null
    },
    "XS_Texinfo__Convert__XSParagraph__XSParagraph_set_space_protection": {
      "start_point": [
        528,
        0
      ],
      "end_point": [
        590,
        1
      ],
      "content": "XS_EUPXS(XS_Texinfo__Convert__XSParagraph__XSParagraph_set_space_protection)\n{\n    dVAR; dXSARGS;\n    if (items < 2)\n       croak_xs_usage(cv,  \"paragraph, space_protection_in, ...\");\n    {\n\tSV *\tparagraph = ST(0)\n;\n\tSV *\tspace_protection_in = ST(1)\n;\n#line 234 \"XSParagraph.xs\"\n        int space_protection = -1;\n        int ignore_columns = -1;\n        int keep_end_lines = -1;\n        int french_spacing = -1;\n        int double_width_no_break = -1;\n        SV *arg_in;\n#line 547 \"XSParagraph.c\"\n\tchar *\tRETVAL;\n\tdXSTARG;\n#line 241 \"XSParagraph.xs\"\n        if (SvOK(space_protection_in))\n          space_protection = (int)SvIV(space_protection_in);\n        /* Get optional arguments from stack. */\n        items -= 2;\n        if (items > 0)\n          {\n            items--;\n            arg_in = ST(2);\n            if (SvOK(arg_in))\n              ignore_columns = (int)SvIV(arg_in);\n          }\n        if (items > 0)\n          {\n            items--;\n            arg_in = ST(3);\n            if (SvOK(arg_in))\n              keep_end_lines = (int)SvIV(arg_in);\n          }\n        if (items > 0)\n          {\n            items--;\n            arg_in = ST(4);\n            if (SvOK(arg_in))\n              french_spacing = (int)SvIV(arg_in);\n          }\n        if (items > 0)\n          {\n            items--;\n            arg_in = ST(5);\n            if (SvOK(arg_in))\n              double_width_no_break = (int)SvIV(arg_in);\n          }\n\n        xspara_set_state (paragraph);\n        RETVAL = xspara_set_space_protection\n          (space_protection, ignore_columns, keep_end_lines,\n           french_spacing, double_width_no_break);\n#line 588 \"XSParagraph.c\"\n\tsv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;\n    }\n    XSRETURN(1);\n}",
      "lines": 63,
      "depth": 12,
      "decorators": null
    },
    "boot_Texinfo__Convert__XSParagraph__XSParagraph": {
      "start_point": [
        596,
        0
      ],
      "end_point": [
        632,
        1
      ],
      "content": "XS_EXTERNAL(boot_Texinfo__Convert__XSParagraph__XSParagraph)\n{\n    dVAR; dXSARGS;\n#if (PERL_REVISION == 5 && PERL_VERSION < 9)\n    char* file = __FILE__;\n#else\n    const char* file = __FILE__;\n#endif\n\n    PERL_UNUSED_VAR(cv); /* -W */\n    PERL_UNUSED_VAR(items); /* -W */\n#ifdef XS_APIVERSION_BOOTCHECK\n    XS_APIVERSION_BOOTCHECK;\n#endif\n    XS_VERSION_BOOTCHECK;\n\n        (void)newXSproto_portable(\"Texinfo::Convert::XSParagraph::XSParagraph::init\", XS_Texinfo__Convert__XSParagraph__XSParagraph_init, file, \"\");\n        (void)newXSproto_portable(\"Texinfo::Convert::XSParagraph::XSParagraph::set_state\", XS_Texinfo__Convert__XSParagraph__XSParagraph_set_state, file, \"$\");\n        (void)newXSproto_portable(\"Texinfo::Convert::XSParagraph::XSParagraph::new\", XS_Texinfo__Convert__XSParagraph__XSParagraph_new, file, \"$;@\");\n        (void)newXSproto_portable(\"Texinfo::Convert::XSParagraph::XSParagraph::end_line_count\", XS_Texinfo__Convert__XSParagraph__XSParagraph_end_line_count, file, \"$\");\n        (void)newXSproto_portable(\"Texinfo::Convert::XSParagraph::XSParagraph::_end_line\", XS_Texinfo__Convert__XSParagraph__XSParagraph__end_line, file, \"$\");\n        (void)newXSproto_portable(\"Texinfo::Convert::XSParagraph::XSParagraph::end_line\", XS_Texinfo__Convert__XSParagraph__XSParagraph_end_line, file, \"$\");\n        (void)newXSproto_portable(\"Texinfo::Convert::XSParagraph::XSParagraph::get_pending\", XS_Texinfo__Convert__XSParagraph__XSParagraph_get_pending, file, \"$\");\n        (void)newXSproto_portable(\"Texinfo::Convert::XSParagraph::XSParagraph::add_pending_word\", XS_Texinfo__Convert__XSParagraph__XSParagraph_add_pending_word, file, \"$;@\");\n        (void)newXSproto_portable(\"Texinfo::Convert::XSParagraph::XSParagraph::end\", XS_Texinfo__Convert__XSParagraph__XSParagraph_end, file, \"$\");\n        (void)newXSproto_portable(\"Texinfo::Convert::XSParagraph::XSParagraph::add_text\", XS_Texinfo__Convert__XSParagraph__XSParagraph_add_text, file, \"$$\");\n        (void)newXSproto_portable(\"Texinfo::Convert::XSParagraph::XSParagraph::add_next\", XS_Texinfo__Convert__XSParagraph__XSParagraph_add_next, file, \"$$;@\");\n        (void)newXSproto_portable(\"Texinfo::Convert::XSParagraph::XSParagraph::remove_end_sentence\", XS_Texinfo__Convert__XSParagraph__XSParagraph_remove_end_sentence, file, \"$\");\n        (void)newXSproto_portable(\"Texinfo::Convert::XSParagraph::XSParagraph::add_end_sentence\", XS_Texinfo__Convert__XSParagraph__XSParagraph_add_end_sentence, file, \"$$\");\n        (void)newXSproto_portable(\"Texinfo::Convert::XSParagraph::XSParagraph::allow_end_sentence\", XS_Texinfo__Convert__XSParagraph__XSParagraph_allow_end_sentence, file, \"$\");\n        (void)newXSproto_portable(\"Texinfo::Convert::XSParagraph::XSParagraph::set_space_protection\", XS_Texinfo__Convert__XSParagraph__XSParagraph_set_space_protection, file, \"$$;@\");\n#if (PERL_REVISION == 5 && PERL_VERSION >= 9)\n  if (PL_unitcheckav)\n       call_list(PL_scopestack_ix, PL_unitcheckav);\n#endif\n    XSRETURN_YES;\n}",
      "lines": 37,
      "depth": 8,
      "decorators": null
    }
  },
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/alloca.in.h": {},
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/arg-nonnull.h": {},
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/asnprintf.c": {
    "asnprintf": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "char *\nasnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)\n{\n  va_list args;\n  char *result;\n\n  va_start (args, format);\n  result = vasnprintf (resultbuf, lengthp, format, args);\n  va_end (args);\n  return result;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "char",
        "*\nasnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/asprintf.c": {
    "asprintf": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nasprintf (char **resultp, const char *format, ...)\n{\n  va_list args;\n  int result;\n\n  va_start (args, format);\n  result = vasprintf (resultp, format, args);\n  va_end (args);\n  return result;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/c++defs.h": {},
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/errno.in.h": {},
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/float+.h": {},
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/float.c": {},
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/float.in.h": {},
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/getdelim.c": {
    "alloc_failed": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static void\nalloc_failed (void)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* Avoid errno problem without using the realloc module; see:\n     http://lists.gnu.org/archive/html/bug-gnulib/2016-08/msg00025.html  */\n  errno = ENOMEM;\n#endif\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "getdelim": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "ssize_t\ngetdelim (char **lineptr, size_t *n, int delimiter, FILE *fp)\n{\n  ssize_t result;\n  size_t cur_len = 0;\n\n  if (lineptr == NULL || n == NULL || fp == NULL)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  flockfile (fp);\n\n  if (*lineptr == NULL || *n == 0)\n    {\n      char *new_lineptr;\n      *n = 120;\n      new_lineptr = (char *) realloc (*lineptr, *n);\n      if (new_lineptr == NULL)\n        {\n          alloc_failed ();\n          result = -1;\n          goto unlock_return;\n        }\n      *lineptr = new_lineptr;\n    }\n\n  for (;;)\n    {\n      int i;\n\n      i = getc_maybe_unlocked (fp);\n      if (i == EOF)\n        {\n          result = -1;\n          break;\n        }\n\n      /* Make enough space for len+1 (for final NUL) bytes.  */\n      if (cur_len + 1 >= *n)\n        {\n          size_t needed_max =\n            SSIZE_MAX < SIZE_MAX ? (size_t) SSIZE_MAX + 1 : SIZE_MAX;\n          size_t needed = 2 * *n + 1;   /* Be generous. */\n          char *new_lineptr;\n\n          if (needed_max < needed)\n            needed = needed_max;\n          if (cur_len + 1 >= needed)\n            {\n              result = -1;\n              errno = EOVERFLOW;\n              goto unlock_return;\n            }\n\n          new_lineptr = (char *) realloc (*lineptr, needed);\n          if (new_lineptr == NULL)\n            {\n              alloc_failed ();\n              result = -1;\n              goto unlock_return;\n            }\n\n          *lineptr = new_lineptr;\n          *n = needed;\n        }\n\n      (*lineptr)[cur_len] = i;\n      cur_len++;\n\n      if (i == delimiter)\n        break;\n    }\n  (*lineptr)[cur_len] = '\\0';\n  result = cur_len ? cur_len : result;\n\n unlock_return:\n  funlockfile (fp); /* doesn't set errno */\n\n  return result;\n}",
      "lines": 82,
      "depth": 13,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/getline.c": {
    "getline": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "ssize_t\ngetline (char **lineptr, size_t *n, FILE *stream)\n{\n  return getdelim (lineptr, n, '\\n', stream);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/itold.c": {
    "_Qp_itoq": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "void\n_Qp_itoq (long double *result, int a)\n{\n  /* Convert from 'int' to 'double', then from 'double' to 'long double'.  */\n  *result = (double) a;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/limits.in.h": {},
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/memchr.c": {
    "__memchr": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "void *\n__memchr (void const *s, int c_in, size_t n)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned reg_char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;\n       --n, ++char_ptr)\n    if (*char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will test a\n     longword at a time.  The tricky part is testing if *any of the four*\n     bytes in the longword in question are equal to c.  We first use an xor\n     with repeated_c.  This reduces the task to testing whether *any of the\n     four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     So, the test whether any byte in longword1 is zero is equivalent to\n     testing whether tmp is nonzero.  */\n\n  while (n >= sizeof (longword))\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n      n -= sizeof (longword);\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that either n < sizeof (longword), or one of the\n     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian\n     machines, we could determine the first such byte without any further\n     memory accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.  Choose code\n     that works in both cases.  */\n\n  for (; n > 0; --n, ++char_ptr)\n    {\n      if (*char_ptr == c)\n        return (void *) char_ptr;\n    }\n\n  return NULL;\n}",
      "lines": 112,
      "depth": 14,
      "decorators": [
        "void",
        "*\n__memchr (void const *s, int c_in, size_t n)",
        "*"
      ]
    }
  },
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/printf-args.c": {
    "PRINTF_FETCHARGS": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "int\nPRINTF_FETCHARGS (va_list args, arguments *a)\n{\n  size_t i;\n  argument *ap;\n\n  for (i = 0, ap = &a->arg[0]; i < a->count; i++, ap++)\n    switch (ap->type)\n      {\n      case TYPE_SCHAR:\n        ap->a.a_schar = va_arg (args, /*signed char*/ int);\n        break;\n      case TYPE_UCHAR:\n        ap->a.a_uchar = va_arg (args, /*unsigned char*/ int);\n        break;\n      case TYPE_SHORT:\n        ap->a.a_short = va_arg (args, /*short*/ int);\n        break;\n      case TYPE_USHORT:\n        ap->a.a_ushort = va_arg (args, /*unsigned short*/ int);\n        break;\n      case TYPE_INT:\n        ap->a.a_int = va_arg (args, int);\n        break;\n      case TYPE_UINT:\n        ap->a.a_uint = va_arg (args, unsigned int);\n        break;\n      case TYPE_LONGINT:\n        ap->a.a_longint = va_arg (args, long int);\n        break;\n      case TYPE_ULONGINT:\n        ap->a.a_ulongint = va_arg (args, unsigned long int);\n        break;\n#if HAVE_LONG_LONG_INT\n      case TYPE_LONGLONGINT:\n        ap->a.a_longlongint = va_arg (args, long long int);\n        break;\n      case TYPE_ULONGLONGINT:\n        ap->a.a_ulonglongint = va_arg (args, unsigned long long int);\n        break;\n#endif\n      case TYPE_DOUBLE:\n        ap->a.a_double = va_arg (args, double);\n        break;\n      case TYPE_LONGDOUBLE:\n        ap->a.a_longdouble = va_arg (args, long double);\n        break;\n      case TYPE_CHAR:\n        ap->a.a_char = va_arg (args, int);\n        break;\n#if HAVE_WINT_T\n      case TYPE_WIDE_CHAR:\n        /* Although ISO C 99 7.24.1.(2) says that wint_t is \"unchanged by\n           default argument promotions\", this is not the case in mingw32,\n           where wint_t is 'unsigned short'.  */\n        ap->a.a_wide_char =\n          (sizeof (wint_t) < sizeof (int)\n           ? (wint_t) va_arg (args, int)\n           : va_arg (args, wint_t));\n        break;\n#endif\n      case TYPE_STRING:\n        ap->a.a_string = va_arg (args, const char *);\n        /* A null pointer is an invalid argument for \"%s\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_string == NULL)\n          ap->a.a_string = \"(NULL)\";\n        break;\n#if HAVE_WCHAR_T\n      case TYPE_WIDE_STRING:\n        ap->a.a_wide_string = va_arg (args, const wchar_t *);\n        /* A null pointer is an invalid argument for \"%ls\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_wide_string == NULL)\n          {\n            static const wchar_t wide_null_string[] =\n              {\n                (wchar_t)'(',\n                (wchar_t)'N', (wchar_t)'U', (wchar_t)'L', (wchar_t)'L',\n                (wchar_t)')',\n                (wchar_t)0\n              };\n            ap->a.a_wide_string = wide_null_string;\n          }\n        break;\n#endif\n      case TYPE_POINTER:\n        ap->a.a_pointer = va_arg (args, void *);\n        break;\n      case TYPE_COUNT_SCHAR_POINTER:\n        ap->a.a_count_schar_pointer = va_arg (args, signed char *);\n        break;\n      case TYPE_COUNT_SHORT_POINTER:\n        ap->a.a_count_short_pointer = va_arg (args, short *);\n        break;\n      case TYPE_COUNT_INT_POINTER:\n        ap->a.a_count_int_pointer = va_arg (args, int *);\n        break;\n      case TYPE_COUNT_LONGINT_POINTER:\n        ap->a.a_count_longint_pointer = va_arg (args, long int *);\n        break;\n#if HAVE_LONG_LONG_INT\n      case TYPE_COUNT_LONGLONGINT_POINTER:\n        ap->a.a_count_longlongint_pointer = va_arg (args, long long int *);\n        break;\n#endif\n#if ENABLE_UNISTDIO\n      /* The unistdio extensions.  */\n      case TYPE_U8_STRING:\n        ap->a.a_u8_string = va_arg (args, const uint8_t *);\n        /* A null pointer is an invalid argument for \"%U\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u8_string == NULL)\n          {\n            static const uint8_t u8_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u8_string = u8_null_string;\n          }\n        break;\n      case TYPE_U16_STRING:\n        ap->a.a_u16_string = va_arg (args, const uint16_t *);\n        /* A null pointer is an invalid argument for \"%lU\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u16_string == NULL)\n          {\n            static const uint16_t u16_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u16_string = u16_null_string;\n          }\n        break;\n      case TYPE_U32_STRING:\n        ap->a.a_u32_string = va_arg (args, const uint32_t *);\n        /* A null pointer is an invalid argument for \"%llU\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u32_string == NULL)\n          {\n            static const uint32_t u32_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u32_string = u32_null_string;\n          }\n        break;\n#endif\n      default:\n        /* Unknown type.  */\n        return -1;\n      }\n  return 0;\n}",
      "lines": 153,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/printf-args.h": {},
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/printf-parse.c": {
    "PRINTF_PARSE": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        631,
        1
      ],
      "content": "int\nPRINTF_PARSE (const CHAR_T *format, DIRECTIVES *d, arguments *a)\n{\n  const CHAR_T *cp = format;    /* pointer into format */\n  size_t arg_posn = 0;          /* number of regular arguments consumed */\n  size_t d_allocated;           /* allocated elements of d->dir */\n  size_t a_allocated;           /* allocated elements of a->arg */\n  size_t max_width_length = 0;\n  size_t max_precision_length = 0;\n\n  d->count = 0;\n  d_allocated = N_DIRECT_ALLOC_DIRECTIVES;\n  d->dir = d->direct_alloc_dir;\n\n  a->count = 0;\n  a_allocated = N_DIRECT_ALLOC_ARGUMENTS;\n  a->arg = a->direct_alloc_arg;\n\n#define REGISTER_ARG(_index_,_type_) \\\n  {                                                                     \\\n    size_t n = (_index_);                                               \\\n    if (n >= a_allocated)                                               \\\n      {                                                                 \\\n        size_t memory_size;                                             \\\n        argument *memory;                                               \\\n                                                                        \\\n        a_allocated = xtimes (a_allocated, 2);                          \\\n        if (a_allocated <= n)                                           \\\n          a_allocated = xsum (n, 1);                                    \\\n        memory_size = xtimes (a_allocated, sizeof (argument));          \\\n        if (size_overflow_p (memory_size))                              \\\n          /* Overflow, would lead to out of memory.  */                 \\\n          goto out_of_memory;                                           \\\n        memory = (argument *) (a->arg != a->direct_alloc_arg            \\\n                               ? realloc (a->arg, memory_size)          \\\n                               : malloc (memory_size));                 \\\n        if (memory == NULL)                                             \\\n          /* Out of memory.  */                                         \\\n          goto out_of_memory;                                           \\\n        if (a->arg == a->direct_alloc_arg)                              \\\n          memcpy (memory, a->arg, a->count * sizeof (argument));        \\\n        a->arg = memory;                                                \\\n      }                                                                 \\\n    while (a->count <= n)                                               \\\n      a->arg[a->count++].type = TYPE_NONE;                              \\\n    if (a->arg[n].type == TYPE_NONE)                                    \\\n      a->arg[n].type = (_type_);                                        \\\n    else if (a->arg[n].type != (_type_))                                \\\n      /* Ambiguous type for positional argument.  */                    \\\n      goto error;                                                       \\\n  }\n\n  while (*cp != '\\0')\n    {\n      CHAR_T c = *cp++;\n      if (c == '%')\n        {\n          size_t arg_index = ARG_NONE;\n          DIRECTIVE *dp = &d->dir[d->count]; /* pointer to next directive */\n\n          /* Initialize the next directive.  */\n          dp->dir_start = cp - 1;\n          dp->flags = 0;\n          dp->width_start = NULL;\n          dp->width_end = NULL;\n          dp->width_arg_index = ARG_NONE;\n          dp->precision_start = NULL;\n          dp->precision_end = NULL;\n          dp->precision_arg_index = ARG_NONE;\n          dp->arg_index = ARG_NONE;\n\n          /* Test for positional argument.  */\n          if (*cp >= '0' && *cp <= '9')\n            {\n              const CHAR_T *np;\n\n              for (np = cp; *np >= '0' && *np <= '9'; np++)\n                ;\n              if (*np == '$')\n                {\n                  size_t n = 0;\n\n                  for (np = cp; *np >= '0' && *np <= '9'; np++)\n                    n = xsum (xtimes (n, 10), *np - '0');\n                  if (n == 0)\n                    /* Positional argument 0.  */\n                    goto error;\n                  if (size_overflow_p (n))\n                    /* n too large, would lead to out of memory later.  */\n                    goto error;\n                  arg_index = n - 1;\n                  cp = np + 1;\n                }\n            }\n\n          /* Read the flags.  */\n          for (;;)\n            {\n              if (*cp == '\\'')\n                {\n                  dp->flags |= FLAG_GROUP;\n                  cp++;\n                }\n              else if (*cp == '-')\n                {\n                  dp->flags |= FLAG_LEFT;\n                  cp++;\n                }\n              else if (*cp == '+')\n                {\n                  dp->flags |= FLAG_SHOWSIGN;\n                  cp++;\n                }\n              else if (*cp == ' ')\n                {\n                  dp->flags |= FLAG_SPACE;\n                  cp++;\n                }\n              else if (*cp == '#')\n                {\n                  dp->flags |= FLAG_ALT;\n                  cp++;\n                }\n              else if (*cp == '0')\n                {\n                  dp->flags |= FLAG_ZERO;\n                  cp++;\n                }\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n              else if (*cp == 'I')\n                {\n                  dp->flags |= FLAG_LOCALIZED;\n                  cp++;\n                }\n#endif\n              else\n                break;\n            }\n\n          /* Parse the field width.  */\n          if (*cp == '*')\n            {\n              dp->width_start = cp;\n              cp++;\n              dp->width_end = cp;\n              if (max_width_length < 1)\n                max_width_length = 1;\n\n              /* Test for positional argument.  */\n              if (*cp >= '0' && *cp <= '9')\n                {\n                  const CHAR_T *np;\n\n                  for (np = cp; *np >= '0' && *np <= '9'; np++)\n                    ;\n                  if (*np == '$')\n                    {\n                      size_t n = 0;\n\n                      for (np = cp; *np >= '0' && *np <= '9'; np++)\n                        n = xsum (xtimes (n, 10), *np - '0');\n                      if (n == 0)\n                        /* Positional argument 0.  */\n                        goto error;\n                      if (size_overflow_p (n))\n                        /* n too large, would lead to out of memory later.  */\n                        goto error;\n                      dp->width_arg_index = n - 1;\n                      cp = np + 1;\n                    }\n                }\n              if (dp->width_arg_index == ARG_NONE)\n                {\n                  dp->width_arg_index = arg_posn++;\n                  if (dp->width_arg_index == ARG_NONE)\n                    /* arg_posn wrapped around.  */\n                    goto error;\n                }\n              REGISTER_ARG (dp->width_arg_index, TYPE_INT);\n            }\n          else if (*cp >= '0' && *cp <= '9')\n            {\n              size_t width_length;\n\n              dp->width_start = cp;\n              for (; *cp >= '0' && *cp <= '9'; cp++)\n                ;\n              dp->width_end = cp;\n              width_length = dp->width_end - dp->width_start;\n              if (max_width_length < width_length)\n                max_width_length = width_length;\n            }\n\n          /* Parse the precision.  */\n          if (*cp == '.')\n            {\n              cp++;\n              if (*cp == '*')\n                {\n                  dp->precision_start = cp - 1;\n                  cp++;\n                  dp->precision_end = cp;\n                  if (max_precision_length < 2)\n                    max_precision_length = 2;\n\n                  /* Test for positional argument.  */\n                  if (*cp >= '0' && *cp <= '9')\n                    {\n                      const CHAR_T *np;\n\n                      for (np = cp; *np >= '0' && *np <= '9'; np++)\n                        ;\n                      if (*np == '$')\n                        {\n                          size_t n = 0;\n\n                          for (np = cp; *np >= '0' && *np <= '9'; np++)\n                            n = xsum (xtimes (n, 10), *np - '0');\n                          if (n == 0)\n                            /* Positional argument 0.  */\n                            goto error;\n                          if (size_overflow_p (n))\n                            /* n too large, would lead to out of memory\n                               later.  */\n                            goto error;\n                          dp->precision_arg_index = n - 1;\n                          cp = np + 1;\n                        }\n                    }\n                  if (dp->precision_arg_index == ARG_NONE)\n                    {\n                      dp->precision_arg_index = arg_posn++;\n                      if (dp->precision_arg_index == ARG_NONE)\n                        /* arg_posn wrapped around.  */\n                        goto error;\n                    }\n                  REGISTER_ARG (dp->precision_arg_index, TYPE_INT);\n                }\n              else\n                {\n                  size_t precision_length;\n\n                  dp->precision_start = cp - 1;\n                  for (; *cp >= '0' && *cp <= '9'; cp++)\n                    ;\n                  dp->precision_end = cp;\n                  precision_length = dp->precision_end - dp->precision_start;\n                  if (max_precision_length < precision_length)\n                    max_precision_length = precision_length;\n                }\n            }\n\n          {\n            arg_type type;\n\n            /* Parse argument type/size specifiers.  */\n            {\n              int flags = 0;\n\n              for (;;)\n                {\n                  if (*cp == 'h')\n                    {\n                      flags |= (1 << (flags & 1));\n                      cp++;\n                    }\n                  else if (*cp == 'L')\n                    {\n                      flags |= 4;\n                      cp++;\n                    }\n                  else if (*cp == 'l')\n                    {\n                      flags += 8;\n                      cp++;\n                    }\n                  else if (*cp == 'j')\n                    {\n                      if (sizeof (intmax_t) > sizeof (long))\n                        {\n                          /* intmax_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (intmax_t) > sizeof (int))\n                        {\n                          /* intmax_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n                  else if (*cp == 'z' || *cp == 'Z')\n                    {\n                      /* 'z' is standardized in ISO C 99, but glibc uses 'Z'\n                         because the warning facility in gcc-2.95.2 understands\n                         only 'Z' (see gcc-2.95.2/gcc/c-common.c:1784).  */\n                      if (sizeof (size_t) > sizeof (long))\n                        {\n                          /* size_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (size_t) > sizeof (int))\n                        {\n                          /* size_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n                  else if (*cp == 't')\n                    {\n                      if (sizeof (ptrdiff_t) > sizeof (long))\n                        {\n                          /* ptrdiff_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (ptrdiff_t) > sizeof (int))\n                        {\n                          /* ptrdiff_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n#if defined __APPLE__ && defined __MACH__\n                  /* On Mac OS X 10.3, PRIdMAX is defined as \"qd\".\n                     We cannot change it to \"lld\" because PRIdMAX must also\n                     be understood by the system's printf routines.  */\n                  else if (*cp == 'q')\n                    {\n                      if (64 / 8 > sizeof (long))\n                        {\n                          /* int64_t = long long */\n                          flags += 16;\n                        }\n                      else\n                        {\n                          /* int64_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n#endif\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                  /* On native Windows, PRIdMAX is defined as \"I64d\".\n                     We cannot change it to \"lld\" because PRIdMAX must also\n                     be understood by the system's printf routines.  */\n                  else if (*cp == 'I' && cp[1] == '6' && cp[2] == '4')\n                    {\n                      if (64 / 8 > sizeof (long))\n                        {\n                          /* __int64 = long long */\n                          flags += 16;\n                        }\n                      else\n                        {\n                          /* __int64 = long */\n                          flags += 8;\n                        }\n                      cp += 3;\n                    }\n#endif\n                  else\n                    break;\n                }\n\n              /* Read the conversion character.  */\n              c = *cp++;\n              switch (c)\n                {\n                case 'd': case 'i':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_LONGLONGINT;\n                  else\n#endif\n                  /* If 'long long' exists and is the same as 'long', we parse\n                     \"lld\" into TYPE_LONGINT.  */\n                  if (flags >= 8)\n                    type = TYPE_LONGINT;\n                  else if (flags & 2)\n                    type = TYPE_SCHAR;\n                  else if (flags & 1)\n                    type = TYPE_SHORT;\n                  else\n                    type = TYPE_INT;\n                  break;\n                case 'o': case 'u': case 'x': case 'X':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_ULONGLONGINT;\n                  else\n#endif\n                  /* If 'unsigned long long' exists and is the same as\n                     'unsigned long', we parse \"llu\" into TYPE_ULONGINT.  */\n                  if (flags >= 8)\n                    type = TYPE_ULONGINT;\n                  else if (flags & 2)\n                    type = TYPE_UCHAR;\n                  else if (flags & 1)\n                    type = TYPE_USHORT;\n                  else\n                    type = TYPE_UINT;\n                  break;\n                case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                case 'a': case 'A':\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_LONGDOUBLE;\n                  else\n                    type = TYPE_DOUBLE;\n                  break;\n                case 'c':\n                  if (flags >= 8)\n#if HAVE_WINT_T\n                    type = TYPE_WIDE_CHAR;\n#else\n                    goto error;\n#endif\n                  else\n                    type = TYPE_CHAR;\n                  break;\n#if HAVE_WINT_T\n                case 'C':\n                  type = TYPE_WIDE_CHAR;\n                  c = 'c';\n                  break;\n#endif\n                case 's':\n                  if (flags >= 8)\n#if HAVE_WCHAR_T\n                    type = TYPE_WIDE_STRING;\n#else\n                    goto error;\n#endif\n                  else\n                    type = TYPE_STRING;\n                  break;\n#if HAVE_WCHAR_T\n                case 'S':\n                  type = TYPE_WIDE_STRING;\n                  c = 's';\n                  break;\n#endif\n                case 'p':\n                  type = TYPE_POINTER;\n                  break;\n                case 'n':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_COUNT_LONGLONGINT_POINTER;\n                  else\n#endif\n                  /* If 'long long' exists and is the same as 'long', we parse\n                     \"lln\" into TYPE_COUNT_LONGINT_POINTER.  */\n                  if (flags >= 8)\n                    type = TYPE_COUNT_LONGINT_POINTER;\n                  else if (flags & 2)\n                    type = TYPE_COUNT_SCHAR_POINTER;\n                  else if (flags & 1)\n                    type = TYPE_COUNT_SHORT_POINTER;\n                  else\n                    type = TYPE_COUNT_INT_POINTER;\n                  break;\n#if ENABLE_UNISTDIO\n                /* The unistdio extensions.  */\n                case 'U':\n                  if (flags >= 16)\n                    type = TYPE_U32_STRING;\n                  else if (flags >= 8)\n                    type = TYPE_U16_STRING;\n                  else\n                    type = TYPE_U8_STRING;\n                  break;\n#endif\n                case '%':\n                  type = TYPE_NONE;\n                  break;\n                default:\n                  /* Unknown conversion character.  */\n                  goto error;\n                }\n            }\n\n            if (type != TYPE_NONE)\n              {\n                dp->arg_index = arg_index;\n                if (dp->arg_index == ARG_NONE)\n                  {\n                    dp->arg_index = arg_posn++;\n                    if (dp->arg_index == ARG_NONE)\n                      /* arg_posn wrapped around.  */\n                      goto error;\n                  }\n                REGISTER_ARG (dp->arg_index, type);\n              }\n            dp->conversion = c;\n            dp->dir_end = cp;\n          }\n\n          d->count++;\n          if (d->count >= d_allocated)\n            {\n              size_t memory_size;\n              DIRECTIVE *memory;\n\n              d_allocated = xtimes (d_allocated, 2);\n              memory_size = xtimes (d_allocated, sizeof (DIRECTIVE));\n              if (size_overflow_p (memory_size))\n                /* Overflow, would lead to out of memory.  */\n                goto out_of_memory;\n              memory = (DIRECTIVE *) (d->dir != d->direct_alloc_dir\n                                      ? realloc (d->dir, memory_size)\n                                      : malloc (memory_size));\n              if (memory == NULL)\n                /* Out of memory.  */\n                goto out_of_memory;\n              if (d->dir == d->direct_alloc_dir)\n                memcpy (memory, d->dir, d->count * sizeof (DIRECTIVE));\n              d->dir = memory;\n            }\n        }\n#if CHAR_T_ONLY_ASCII\n      else if (!c_isascii (c))\n        {\n          /* Non-ASCII character.  Not supported.  */\n          goto error;\n        }\n#endif\n    }\n  d->dir[d->count].dir_start = cp;\n\n  d->max_width_length = max_width_length;\n  d->max_precision_length = max_precision_length;\n  return 0;\n\nerror:\n  if (a->arg != a->direct_alloc_arg)\n    free (a->arg);\n  if (d->dir != d->direct_alloc_dir)\n    free (d->dir);\n  errno = EINVAL;\n  return -1;\n\nout_of_memory:\n  if (a->arg != a->direct_alloc_arg)\n    free (a->arg);\n  if (d->dir != d->direct_alloc_dir)\n    free (d->dir);\n  errno = ENOMEM;\n  return -1;\n}",
      "lines": 551,
      "depth": 24,
      "decorators": [
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/printf-parse.h": {},
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/size_max.h": {},
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/stddef.in.h": {},
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/stdint.in.h": {},
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/stdio.in.h": {},
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/string.in.h": {},
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/sys_types.in.h": {},
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/vasnprintf.c": {
    "local_strnlen": {
      "start_point": [
        227,
        0
      ],
      "end_point": [
        232,
        1
      ],
      "content": "static size_t\nlocal_strnlen (const char *string, size_t maxlen)\n{\n  const char *end = memchr (string, '\\0', maxlen);\n  return end ? (size_t) (end - string) : maxlen;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "local_wcslen": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "static size_t\nlocal_wcslen (const wchar_t *s)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; *ptr != (wchar_t) 0; ptr++)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "local_wcsnlen": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        274,
        1
      ],
      "content": "static size_t\nlocal_wcsnlen (const wchar_t *s, size_t maxlen)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; maxlen > 0 && *ptr != (wchar_t) 0; ptr++, maxlen--)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "decimal_point_char": {
      "start_point": [
        283,
        0
      ],
      "end_point": [
        302,
        1
      ],
      "content": "static char\ndecimal_point_char (void)\n{\n  const char *point;\n  /* Determine it in a multithread-safe way.  We know nl_langinfo is\n     multithread-safe on glibc systems and Mac OS X systems, but is not required\n     to be multithread-safe by POSIX.  sprintf(), however, is multithread-safe.\n     localeconv() is rarely multithread-safe.  */\n#  if HAVE_NL_LANGINFO && (__GLIBC__ || defined __UCLIBC__ || (defined __APPLE__ && defined __MACH__))\n  point = nl_langinfo (RADIXCHAR);\n#  elif 1\n  char pointbuf[5];\n  sprintf (pointbuf, \"%#.0f\", 1.0);\n  point = &pointbuf[1];\n#  else\n  point = localeconv () -> decimal_point;\n#  endif\n  /* The decimal point is always a single byte: either '.' or ','.  */\n  return (point[0] != '\\0' ? point[0] : '.');\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "is_infinite_or_zero": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "static int\nis_infinite_or_zero (double x)\n{\n  return isnand (x) || x + x == x;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_infinite_or_zerol": {
      "start_point": [
        320,
        0
      ],
      "end_point": [
        324,
        1
      ],
      "content": "static int\nis_infinite_or_zerol (long double x)\n{\n  return isnanl (x) || x + x == x;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "multiply": {
      "start_point": [
        352,
        0
      ],
      "end_point": [
        415,
        1
      ],
      "content": "static void *\nmultiply (mpn_t src1, mpn_t src2, mpn_t *dest)\n{\n  const mp_limb_t *p1;\n  const mp_limb_t *p2;\n  size_t len1;\n  size_t len2;\n\n  if (src1.nlimbs <= src2.nlimbs)\n    {\n      len1 = src1.nlimbs;\n      p1 = src1.limbs;\n      len2 = src2.nlimbs;\n      p2 = src2.limbs;\n    }\n  else\n    {\n      len1 = src2.nlimbs;\n      p1 = src2.limbs;\n      len2 = src1.nlimbs;\n      p2 = src1.limbs;\n    }\n  /* Now 0 <= len1 <= len2.  */\n  if (len1 == 0)\n    {\n      /* src1 or src2 is zero.  */\n      dest->nlimbs = 0;\n      dest->limbs = (mp_limb_t *) malloc (1);\n    }\n  else\n    {\n      /* Here 1 <= len1 <= len2.  */\n      size_t dlen;\n      mp_limb_t *dp;\n      size_t k, i, j;\n\n      dlen = len1 + len2;\n      dp = (mp_limb_t *) malloc (dlen * sizeof (mp_limb_t));\n      if (dp == NULL)\n        return NULL;\n      for (k = len2; k > 0; )\n        dp[--k] = 0;\n      for (i = 0; i < len1; i++)\n        {\n          mp_limb_t digit1 = p1[i];\n          mp_twolimb_t carry = 0;\n          for (j = 0; j < len2; j++)\n            {\n              mp_limb_t digit2 = p2[j];\n              carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n              carry += dp[i + j];\n              dp[i + j] = (mp_limb_t) carry;\n              carry = carry >> GMP_LIMB_BITS;\n            }\n          dp[i + len2] = (mp_limb_t) carry;\n        }\n      /* Normalise.  */\n      while (dlen > 0 && dp[dlen - 1] == 0)\n        dlen--;\n      dest->nlimbs = dlen;\n      dest->limbs = dp;\n    }\n  return dest->limbs;\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nmultiply (mpn_t src1, mpn_t src2, mpn_t *dest)",
        "*"
      ]
    },
    "divide": {
      "start_point": [
        424,
        0
      ],
      "end_point": [
        847,
        1
      ],
      "content": "static void *\ndivide (mpn_t a, mpn_t b, mpn_t *q)\n{\n  /* Algorithm:\n     First normalise a and b: a=[a[m-1],...,a[0]], b=[b[n-1],...,b[0]]\n     with m>=0 and n>0 (in base beta = 2^GMP_LIMB_BITS).\n     If m<n, then q:=0 and r:=a.\n     If m>=n=1, perform a single-precision division:\n       r:=0, j:=m,\n       while j>0 do\n         {Here (q[m-1]*beta^(m-1)+...+q[j]*beta^j) * b[0] + r*beta^j =\n               = a[m-1]*beta^(m-1)+...+a[j]*beta^j und 0<=r<b[0]<beta}\n         j:=j-1, r:=r*beta+a[j], q[j]:=floor(r/b[0]), r:=r-b[0]*q[j].\n       Normalise [q[m-1],...,q[0]], yields q.\n     If m>=n>1, perform a multiple-precision division:\n       We have a/b < beta^(m-n+1).\n       s:=intDsize-1-(highest bit in b[n-1]), 0<=s<intDsize.\n       Shift a and b left by s bits, copying them. r:=a.\n       r=[r[m],...,r[0]], b=[b[n-1],...,b[0]] with b[n-1]>=beta/2.\n       For j=m-n,...,0: {Here 0 <= r < b*beta^(j+1).}\n         Compute q* :\n           q* := floor((r[j+n]*beta+r[j+n-1])/b[n-1]).\n           In case of overflow (q* >= beta) set q* := beta-1.\n           Compute c2 := ((r[j+n]*beta+r[j+n-1]) - q* * b[n-1])*beta + r[j+n-2]\n           and c3 := b[n-2] * q*.\n           {We have 0 <= c2 < 2*beta^2, even 0 <= c2 < beta^2 if no overflow\n            occurred.  Furthermore 0 <= c3 < beta^2.\n            If there was overflow and\n            r[j+n]*beta+r[j+n-1] - q* * b[n-1] >= beta, i.e. c2 >= beta^2,\n            the next test can be skipped.}\n           While c3 > c2, {Here 0 <= c2 < c3 < beta^2}\n             Put q* := q* - 1, c2 := c2 + b[n-1]*beta, c3 := c3 - b[n-2].\n           If q* > 0:\n             Put r := r - b * q* * beta^j. In detail:\n               [r[n+j],...,r[j]] := [r[n+j],...,r[j]] - q* * [b[n-1],...,b[0]].\n               hence: u:=0, for i:=0 to n-1 do\n                              u := u + q* * b[i],\n                              r[j+i]:=r[j+i]-(u mod beta) (+ beta, if carry),\n                              u:=u div beta (+ 1, if carry in subtraction)\n                      r[n+j]:=r[n+j]-u.\n               {Since always u = (q* * [b[i-1],...,b[0]] div beta^i) + 1\n                               < q* + 1 <= beta,\n                the carry u does not overflow.}\n             If a negative carry occurs, put q* := q* - 1\n               and [r[n+j],...,r[j]] := [r[n+j],...,r[j]] + [0,b[n-1],...,b[0]].\n         Set q[j] := q*.\n       Normalise [q[m-n],..,q[0]]; this yields the quotient q.\n       Shift [r[n-1],...,r[0]] right by s bits and normalise; this yields the\n       rest r.\n       The room for q[j] can be allocated at the memory location of r[n+j].\n     Finally, round-to-even:\n       Shift r left by 1 bit.\n       If r > b or if r = b and q[0] is odd, q := q+1.\n   */\n  const mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  const mp_limb_t *b_ptr = b.limbs;\n  size_t b_len = b.nlimbs;\n  mp_limb_t *roomptr;\n  mp_limb_t *tmp_roomptr = NULL;\n  mp_limb_t *q_ptr;\n  size_t q_len;\n  mp_limb_t *r_ptr;\n  size_t r_len;\n\n  /* Allocate room for a_len+2 digits.\n     (Need a_len+1 digits for the real division and 1 more digit for the\n     final rounding of q.)  */\n  roomptr = (mp_limb_t *) malloc ((a_len + 2) * sizeof (mp_limb_t));\n  if (roomptr == NULL)\n    return NULL;\n\n  /* Normalise a.  */\n  while (a_len > 0 && a_ptr[a_len - 1] == 0)\n    a_len--;\n\n  /* Normalise b.  */\n  for (;;)\n    {\n      if (b_len == 0)\n        /* Division by zero.  */\n        abort ();\n      if (b_ptr[b_len - 1] == 0)\n        b_len--;\n      else\n        break;\n    }\n\n  /* Here m = a_len >= 0 and n = b_len > 0.  */\n\n  if (a_len < b_len)\n    {\n      /* m<n: trivial case.  q=0, r := copy of a.  */\n      r_ptr = roomptr;\n      r_len = a_len;\n      memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n      q_ptr = roomptr + a_len;\n      q_len = 0;\n    }\n  else if (b_len == 1)\n    {\n      /* n=1: single precision division.\n         beta^(m-1) <= a < beta^m  ==>  beta^(m-2) <= a/b < beta^m  */\n      r_ptr = roomptr;\n      q_ptr = roomptr + 1;\n      {\n        mp_limb_t den = b_ptr[0];\n        mp_limb_t remainder = 0;\n        const mp_limb_t *sourceptr = a_ptr + a_len;\n        mp_limb_t *destptr = q_ptr + a_len;\n        size_t count;\n        for (count = a_len; count > 0; count--)\n          {\n            mp_twolimb_t num =\n              ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--sourceptr;\n            *--destptr = num / den;\n            remainder = num % den;\n          }\n        /* Normalise and store r.  */\n        if (remainder > 0)\n          {\n            r_ptr[0] = remainder;\n            r_len = 1;\n          }\n        else\n          r_len = 0;\n        /* Normalise q.  */\n        q_len = a_len;\n        if (q_ptr[q_len - 1] == 0)\n          q_len--;\n      }\n    }\n  else\n    {\n      /* n>1: multiple precision division.\n         beta^(m-1) <= a < beta^m, beta^(n-1) <= b < beta^n  ==>\n         beta^(m-n-1) <= a/b < beta^(m-n+1).  */\n      /* Determine s.  */\n      size_t s;\n      {\n        mp_limb_t msd = b_ptr[b_len - 1]; /* = b[n-1], > 0 */\n        /* Determine s = GMP_LIMB_BITS - integer_length (msd).\n           Code copied from gnulib's integer_length.c.  */\n# if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)\n        s = __builtin_clz (msd);\n# else\n#  if defined DBL_EXPBIT0_WORD && defined DBL_EXPBIT0_BIT\n        if (GMP_LIMB_BITS <= DBL_MANT_BIT)\n          {\n            /* Use 'double' operations.\n               Assumes an IEEE 754 'double' implementation.  */\n#   define DBL_EXP_MASK ((DBL_MAX_EXP - DBL_MIN_EXP) | 7)\n#   define DBL_EXP_BIAS (DBL_EXP_MASK / 2 - 1)\n#   define NWORDS \\\n     ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n            union { double value; unsigned int word[NWORDS]; } m;\n\n            /* Use a single integer to floating-point conversion.  */\n            m.value = msd;\n\n            s = GMP_LIMB_BITS\n                - (((m.word[DBL_EXPBIT0_WORD] >> DBL_EXPBIT0_BIT) & DBL_EXP_MASK)\n                   - DBL_EXP_BIAS);\n          }\n        else\n#   undef NWORDS\n#  endif\n          {\n            s = 31;\n            if (msd >= 0x10000)\n              {\n                msd = msd >> 16;\n                s -= 16;\n              }\n            if (msd >= 0x100)\n              {\n                msd = msd >> 8;\n                s -= 8;\n              }\n            if (msd >= 0x10)\n              {\n                msd = msd >> 4;\n                s -= 4;\n              }\n            if (msd >= 0x4)\n              {\n                msd = msd >> 2;\n                s -= 2;\n              }\n            if (msd >= 0x2)\n              {\n                msd = msd >> 1;\n                s -= 1;\n              }\n          }\n# endif\n      }\n      /* 0 <= s < GMP_LIMB_BITS.\n         Copy b, shifting it left by s bits.  */\n      if (s > 0)\n        {\n          tmp_roomptr = (mp_limb_t *) malloc (b_len * sizeof (mp_limb_t));\n          if (tmp_roomptr == NULL)\n            {\n              free (roomptr);\n              return NULL;\n            }\n          {\n            const mp_limb_t *sourceptr = b_ptr;\n            mp_limb_t *destptr = tmp_roomptr;\n            mp_twolimb_t accu = 0;\n            size_t count;\n            for (count = b_len; count > 0; count--)\n              {\n                accu += (mp_twolimb_t) *sourceptr++ << s;\n                *destptr++ = (mp_limb_t) accu;\n                accu = accu >> GMP_LIMB_BITS;\n              }\n            /* accu must be zero, since that was how s was determined.  */\n            if (accu != 0)\n              abort ();\n          }\n          b_ptr = tmp_roomptr;\n        }\n      /* Copy a, shifting it left by s bits, yields r.\n         Memory layout:\n         At the beginning: r = roomptr[0..a_len],\n         at the end: r = roomptr[0..b_len-1], q = roomptr[b_len..a_len]  */\n      r_ptr = roomptr;\n      if (s == 0)\n        {\n          memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n          r_ptr[a_len] = 0;\n        }\n      else\n        {\n          const mp_limb_t *sourceptr = a_ptr;\n          mp_limb_t *destptr = r_ptr;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              accu += (mp_twolimb_t) *sourceptr++ << s;\n              *destptr++ = (mp_limb_t) accu;\n              accu = accu >> GMP_LIMB_BITS;\n            }\n          *destptr++ = (mp_limb_t) accu;\n        }\n      q_ptr = roomptr + b_len;\n      q_len = a_len - b_len + 1; /* q will have m-n+1 limbs */\n      {\n        size_t j = a_len - b_len; /* m-n */\n        mp_limb_t b_msd = b_ptr[b_len - 1]; /* b[n-1] */\n        mp_limb_t b_2msd = b_ptr[b_len - 2]; /* b[n-2] */\n        mp_twolimb_t b_msdd = /* b[n-1]*beta+b[n-2] */\n          ((mp_twolimb_t) b_msd << GMP_LIMB_BITS) | b_2msd;\n        /* Division loop, traversed m-n+1 times.\n           j counts down, b is unchanged, beta/2 <= b[n-1] < beta.  */\n        for (;;)\n          {\n            mp_limb_t q_star;\n            mp_limb_t c1;\n            if (r_ptr[j + b_len] < b_msd) /* r[j+n] < b[n-1] ? */\n              {\n                /* Divide r[j+n]*beta+r[j+n-1] by b[n-1], no overflow.  */\n                mp_twolimb_t num =\n                  ((mp_twolimb_t) r_ptr[j + b_len] << GMP_LIMB_BITS)\n                  | r_ptr[j + b_len - 1];\n                q_star = num / b_msd;\n                c1 = num % b_msd;\n              }\n            else\n              {\n                /* Overflow, hence r[j+n]*beta+r[j+n-1] >= beta*b[n-1].  */\n                q_star = (mp_limb_t)~(mp_limb_t)0; /* q* = beta-1 */\n                /* Test whether r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] >= beta\n                   <==> r[j+n]*beta+r[j+n-1] + b[n-1] >= beta*b[n-1]+beta\n                   <==> b[n-1] < floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta)\n                        {<= beta !}.\n                   If yes, jump directly to the subtraction loop.\n                   (Otherwise, r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] < beta\n                    <==> floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta) = b[n-1] ) */\n                if (r_ptr[j + b_len] > b_msd\n                    || (c1 = r_ptr[j + b_len - 1] + b_msd) < b_msd)\n                  /* r[j+n] >= b[n-1]+1 or\n                     r[j+n] = b[n-1] and the addition r[j+n-1]+b[n-1] gives a\n                     carry.  */\n                  goto subtract;\n              }\n            /* q_star = q*,\n               c1 = (r[j+n]*beta+r[j+n-1]) - q* * b[n-1] (>=0, <beta).  */\n            {\n              mp_twolimb_t c2 = /* c1*beta+r[j+n-2] */\n                ((mp_twolimb_t) c1 << GMP_LIMB_BITS) | r_ptr[j + b_len - 2];\n              mp_twolimb_t c3 = /* b[n-2] * q* */\n                (mp_twolimb_t) b_2msd * (mp_twolimb_t) q_star;\n              /* While c2 < c3, increase c2 and decrease c3.\n                 Consider c3-c2.  While it is > 0, decrease it by\n                 b[n-1]*beta+b[n-2].  Because of b[n-1]*beta+b[n-2] >= beta^2/2\n                 this can happen only twice.  */\n              if (c3 > c2)\n                {\n                  q_star = q_star - 1; /* q* := q* - 1 */\n                  if (c3 - c2 > b_msdd)\n                    q_star = q_star - 1; /* q* := q* - 1 */\n                }\n            }\n            if (q_star > 0)\n              subtract:\n              {\n                /* Subtract r := r - b * q* * beta^j.  */\n                mp_limb_t cr;\n                {\n                  const mp_limb_t *sourceptr = b_ptr;\n                  mp_limb_t *destptr = r_ptr + j;\n                  mp_twolimb_t carry = 0;\n                  size_t count;\n                  for (count = b_len; count > 0; count--)\n                    {\n                      /* Here 0 <= carry <= q*.  */\n                      carry =\n                        carry\n                        + (mp_twolimb_t) q_star * (mp_twolimb_t) *sourceptr++\n                        + (mp_limb_t) ~(*destptr);\n                      /* Here 0 <= carry <= beta*q* + beta-1.  */\n                      *destptr++ = ~(mp_limb_t) carry;\n                      carry = carry >> GMP_LIMB_BITS; /* <= q* */\n                    }\n                  cr = (mp_limb_t) carry;\n                }\n                /* Subtract cr from r_ptr[j + b_len], then forget about\n                   r_ptr[j + b_len].  */\n                if (cr > r_ptr[j + b_len])\n                  {\n                    /* Subtraction gave a carry.  */\n                    q_star = q_star - 1; /* q* := q* - 1 */\n                    /* Add b back.  */\n                    {\n                      const mp_limb_t *sourceptr = b_ptr;\n                      mp_limb_t *destptr = r_ptr + j;\n                      mp_limb_t carry = 0;\n                      size_t count;\n                      for (count = b_len; count > 0; count--)\n                        {\n                          mp_limb_t source1 = *sourceptr++;\n                          mp_limb_t source2 = *destptr;\n                          *destptr++ = source1 + source2 + carry;\n                          carry =\n                            (carry\n                             ? source1 >= (mp_limb_t) ~source2\n                             : source1 > (mp_limb_t) ~source2);\n                        }\n                    }\n                    /* Forget about the carry and about r[j+n].  */\n                  }\n              }\n            /* q* is determined.  Store it as q[j].  */\n            q_ptr[j] = q_star;\n            if (j == 0)\n              break;\n            j--;\n          }\n      }\n      r_len = b_len;\n      /* Normalise q.  */\n      if (q_ptr[q_len - 1] == 0)\n        q_len--;\n# if 0 /* Not needed here, since we need r only to compare it with b/2, and\n          b is shifted left by s bits.  */\n      /* Shift r right by s bits.  */\n      if (s > 0)\n        {\n          mp_limb_t ptr = r_ptr + r_len;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = r_len; count > 0; count--)\n            {\n              accu = (mp_twolimb_t) (mp_limb_t) accu << GMP_LIMB_BITS;\n              accu += (mp_twolimb_t) *--ptr << (GMP_LIMB_BITS - s);\n              *ptr = (mp_limb_t) (accu >> GMP_LIMB_BITS);\n            }\n        }\n# endif\n      /* Normalise r.  */\n      while (r_len > 0 && r_ptr[r_len - 1] == 0)\n        r_len--;\n    }\n  /* Compare r << 1 with b.  */\n  if (r_len > b_len)\n    goto increment_q;\n  {\n    size_t i;\n    for (i = b_len;;)\n      {\n        mp_limb_t r_i =\n          (i <= r_len && i > 0 ? r_ptr[i - 1] >> (GMP_LIMB_BITS - 1) : 0)\n          | (i < r_len ? r_ptr[i] << 1 : 0);\n        mp_limb_t b_i = (i < b_len ? b_ptr[i] : 0);\n        if (r_i > b_i)\n          goto increment_q;\n        if (r_i < b_i)\n          goto keep_q;\n        if (i == 0)\n          break;\n        i--;\n      }\n  }\n  if (q_len > 0 && ((q_ptr[0] & 1) != 0))\n    /* q is odd.  */\n    increment_q:\n    {\n      size_t i;\n      for (i = 0; i < q_len; i++)\n        if (++(q_ptr[i]) != 0)\n          goto keep_q;\n      q_ptr[q_len++] = 1;\n    }\n  keep_q:\n  if (tmp_roomptr != NULL)\n    free (tmp_roomptr);\n  q->limbs = q_ptr;\n  q->nlimbs = q_len;\n  return roomptr;\n}",
      "lines": 424,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndivide (mpn_t a, mpn_t b, mpn_t *q)",
        "*"
      ]
    },
    "convert_to_decimal": {
      "start_point": [
        855,
        0
      ],
      "end_point": [
        901,
        1
      ],
      "content": "static char *\nconvert_to_decimal (mpn_t a, size_t extra_zeroes)\n{\n  mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  /* 0.03345 is slightly larger than log(2)/(9*log(10)).  */\n  size_t c_len = 9 * ((size_t)(a_len * (GMP_LIMB_BITS * 0.03345f)) + 1);\n  char *c_ptr = (char *) malloc (xsum (c_len, extra_zeroes));\n  if (c_ptr != NULL)\n    {\n      char *d_ptr = c_ptr;\n      for (; extra_zeroes > 0; extra_zeroes--)\n        *d_ptr++ = '0';\n      while (a_len > 0)\n        {\n          /* Divide a by 10^9, in-place.  */\n          mp_limb_t remainder = 0;\n          mp_limb_t *ptr = a_ptr + a_len;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              mp_twolimb_t num =\n                ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--ptr;\n              *ptr = num / 1000000000;\n              remainder = num % 1000000000;\n            }\n          /* Store the remainder as 9 decimal digits.  */\n          for (count = 9; count > 0; count--)\n            {\n              *d_ptr++ = '0' + (remainder % 10);\n              remainder = remainder / 10;\n            }\n          /* Normalize a.  */\n          if (a_ptr[a_len - 1] == 0)\n            a_len--;\n        }\n      /* Remove leading zeroes.  */\n      while (d_ptr > c_ptr && d_ptr[-1] == '0')\n        d_ptr--;\n      /* But keep at least one zero.  */\n      if (d_ptr == c_ptr)\n        *d_ptr++ = '0';\n      /* Terminate the string.  */\n      *d_ptr = '\\0';\n    }\n  return c_ptr;\n}",
      "lines": 47,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nconvert_to_decimal (mpn_t a, size_t extra_zeroes)",
        "*"
      ]
    },
    "decode_long_double": {
      "start_point": [
        909,
        0
      ],
      "end_point": [
        987,
        1
      ],
      "content": "static void *\ndecode_long_double (long double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  long double y;\n  size_t i;\n\n  /* Allocate memory for result.  */\n  m.nlimbs = (LDBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n  /* Split into exponential part and mantissa.  */\n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n  /* x = 2^exp * y = 2^(exp - LDBL_MANT_BIT) * (y * 2^LDBL_MANT_BIT), and the\n     latter is an integer.  */\n  /* Convert the mantissa (y * 2^LDBL_MANT_BIT) to a sequence of limbs.\n     I'm not sure whether it's safe to cast a 'long double' value between\n     2^31 and 2^32 to 'unsigned int', therefore play safe and cast only\n     'long double' values between 0 and 2^16 (to 'unsigned int' or 'int',\n     doesn't matter).  */\n#  if (LDBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (LDBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = LDBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#  if 0 /* On FreeBSD 6.1/x86, 'long double' numbers sometimes have excess\n           precision.  */\n  if (!(y == 0.0L))\n    abort ();\n#  endif\n  /* Normalise.  */\n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - LDBL_MANT_BIT;\n  return m.limbs;\n}",
      "lines": 79,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndecode_long_double (long double x, int *ep, mpn_t *mp)",
        "*"
      ]
    },
    "decode_double": {
      "start_point": [
        997,
        0
      ],
      "end_point": [
        1072,
        1
      ],
      "content": "static void *\ndecode_double (double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  double y;\n  size_t i;\n\n  /* Allocate memory for result.  */\n  m.nlimbs = (DBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n  /* Split into exponential part and mantissa.  */\n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n  /* x = 2^exp * y = 2^(exp - DBL_MANT_BIT) * (y * 2^DBL_MANT_BIT), and the\n     latter is an integer.  */\n  /* Convert the mantissa (y * 2^DBL_MANT_BIT) to a sequence of limbs.\n     I'm not sure whether it's safe to cast a 'double' value between\n     2^31 and 2^32 to 'unsigned int', therefore play safe and cast only\n     'double' values between 0 and 2^16 (to 'unsigned int' or 'int',\n     doesn't matter).  */\n#  if (DBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (DBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = DBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n  if (!(y == 0.0))\n    abort ();\n  /* Normalise.  */\n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - DBL_MANT_BIT;\n  return m.limbs;\n}",
      "lines": 76,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndecode_double (double x, int *ep, mpn_t *mp)",
        "*"
      ]
    },
    "scale10_round_decimal_decoded": {
      "start_point": [
        1081,
        0
      ],
      "end_point": [
        1294,
        1
      ],
      "content": "static char *\nscale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)\n{\n  int s;\n  size_t extra_zeroes;\n  unsigned int abs_n;\n  unsigned int abs_s;\n  mp_limb_t *pow5_ptr;\n  size_t pow5_len;\n  unsigned int s_limbs;\n  unsigned int s_bits;\n  mpn_t pow5;\n  mpn_t z;\n  void *z_memory;\n  char *digits;\n\n  if (memory == NULL)\n    return NULL;\n  /* x = 2^e * m, hence\n     y = round (2^e * 10^n * m) = round (2^(e+n) * 5^n * m)\n       = round (2^s * 5^n * m).  */\n  s = e + n;\n  extra_zeroes = 0;\n  /* Factor out a common power of 10 if possible.  */\n  if (s > 0 && n > 0)\n    {\n      extra_zeroes = (s < n ? s : n);\n      s -= extra_zeroes;\n      n -= extra_zeroes;\n    }\n  /* Here y = round (2^s * 5^n * m) * 10^extra_zeroes.\n     Before converting to decimal, we need to compute\n     z = round (2^s * 5^n * m).  */\n  /* Compute 5^|n|, possibly shifted by |s| bits if n and s have the same\n     sign.  2.322 is slightly larger than log(5)/log(2).  */\n  abs_n = (n >= 0 ? n : -n);\n  abs_s = (s >= 0 ? s : -s);\n  pow5_ptr = (mp_limb_t *) malloc (((int)(abs_n * (2.322f / GMP_LIMB_BITS)) + 1\n                                    + abs_s / GMP_LIMB_BITS + 1)\n                                   * sizeof (mp_limb_t));\n  if (pow5_ptr == NULL)\n    {\n      free (memory);\n      return NULL;\n    }\n  /* Initialize with 1.  */\n  pow5_ptr[0] = 1;\n  pow5_len = 1;\n  /* Multiply with 5^|n|.  */\n  if (abs_n > 0)\n    {\n      static mp_limb_t const small_pow5[13 + 1] =\n        {\n          1, 5, 25, 125, 625, 3125, 15625, 78125, 390625, 1953125, 9765625,\n          48828125, 244140625, 1220703125\n        };\n      unsigned int n13;\n      for (n13 = 0; n13 <= abs_n; n13 += 13)\n        {\n          mp_limb_t digit1 = small_pow5[n13 + 13 <= abs_n ? 13 : abs_n - n13];\n          size_t j;\n          mp_twolimb_t carry = 0;\n          for (j = 0; j < pow5_len; j++)\n            {\n              mp_limb_t digit2 = pow5_ptr[j];\n              carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n              pow5_ptr[j] = (mp_limb_t) carry;\n              carry = carry >> GMP_LIMB_BITS;\n            }\n          if (carry > 0)\n            pow5_ptr[pow5_len++] = (mp_limb_t) carry;\n        }\n    }\n  s_limbs = abs_s / GMP_LIMB_BITS;\n  s_bits = abs_s % GMP_LIMB_BITS;\n  if (n >= 0 ? s >= 0 : s <= 0)\n    {\n      /* Multiply with 2^|s|.  */\n      if (s_bits > 0)\n        {\n          mp_limb_t *ptr = pow5_ptr;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = pow5_len; count > 0; count--)\n            {\n              accu += (mp_twolimb_t) *ptr << s_bits;\n              *ptr++ = (mp_limb_t) accu;\n              accu = accu >> GMP_LIMB_BITS;\n            }\n          if (accu > 0)\n            {\n              *ptr = (mp_limb_t) accu;\n              pow5_len++;\n            }\n        }\n      if (s_limbs > 0)\n        {\n          size_t count;\n          for (count = pow5_len; count > 0;)\n            {\n              count--;\n              pow5_ptr[s_limbs + count] = pow5_ptr[count];\n            }\n          for (count = s_limbs; count > 0;)\n            {\n              count--;\n              pow5_ptr[count] = 0;\n            }\n          pow5_len += s_limbs;\n        }\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n        {\n          /* Multiply m with pow5.  No division needed.  */\n          z_memory = multiply (m, pow5, &z);\n        }\n      else\n        {\n          /* Divide m by pow5 and round.  */\n          z_memory = divide (m, pow5, &z);\n        }\n    }\n  else\n    {\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n        {\n          /* n >= 0, s < 0.\n             Multiply m with pow5, then divide by 2^|s|.  */\n          mpn_t numerator;\n          mpn_t denominator;\n          void *tmp_memory;\n          tmp_memory = multiply (m, pow5, &numerator);\n          if (tmp_memory == NULL)\n            {\n              free (pow5_ptr);\n              free (memory);\n              return NULL;\n            }\n          /* Construct 2^|s|.  */\n          {\n            mp_limb_t *ptr = pow5_ptr + pow5_len;\n            size_t i;\n            for (i = 0; i < s_limbs; i++)\n              ptr[i] = 0;\n            ptr[s_limbs] = (mp_limb_t) 1 << s_bits;\n            denominator.limbs = ptr;\n            denominator.nlimbs = s_limbs + 1;\n          }\n          z_memory = divide (numerator, denominator, &z);\n          free (tmp_memory);\n        }\n      else\n        {\n          /* n < 0, s > 0.\n             Multiply m with 2^s, then divide by pow5.  */\n          mpn_t numerator;\n          mp_limb_t *num_ptr;\n          num_ptr = (mp_limb_t *) malloc ((m.nlimbs + s_limbs + 1)\n                                          * sizeof (mp_limb_t));\n          if (num_ptr == NULL)\n            {\n              free (pow5_ptr);\n              free (memory);\n              return NULL;\n            }\n          {\n            mp_limb_t *destptr = num_ptr;\n            {\n              size_t i;\n              for (i = 0; i < s_limbs; i++)\n                *destptr++ = 0;\n            }\n            if (s_bits > 0)\n              {\n                const mp_limb_t *sourceptr = m.limbs;\n                mp_twolimb_t accu = 0;\n                size_t count;\n                for (count = m.nlimbs; count > 0; count--)\n                  {\n                    accu += (mp_twolimb_t) *sourceptr++ << s_bits;\n                    *destptr++ = (mp_limb_t) accu;\n                    accu = accu >> GMP_LIMB_BITS;\n                  }\n                if (accu > 0)\n                  *destptr++ = (mp_limb_t) accu;\n              }\n            else\n              {\n                const mp_limb_t *sourceptr = m.limbs;\n                size_t count;\n                for (count = m.nlimbs; count > 0; count--)\n                  *destptr++ = *sourceptr++;\n              }\n            numerator.limbs = num_ptr;\n            numerator.nlimbs = destptr - num_ptr;\n          }\n          z_memory = divide (numerator, pow5, &z);\n          free (num_ptr);\n        }\n    }\n  free (pow5_ptr);\n  free (memory);\n\n  /* Here y = round (x * 10^n) = z * 10^extra_zeroes.  */\n\n  if (z_memory == NULL)\n    return NULL;\n  digits = convert_to_decimal (z, extra_zeroes);\n  free (z_memory);\n  return digits;\n}",
      "lines": 214,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)",
        "*"
      ]
    },
    "scale10_round_decimal_long_double": {
      "start_point": [
        1303,
        0
      ],
      "end_point": [
        1310,
        1
      ],
      "content": "static char *\nscale10_round_decimal_long_double (long double x, int n)\n{\n  int e IF_LINT(= 0);\n  mpn_t m;\n  void *memory = decode_long_double (x, &e, &m);\n  return scale10_round_decimal_decoded (e, m, memory, n);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_long_double (long double x, int n)",
        "*"
      ]
    },
    "scale10_round_decimal_double": {
      "start_point": [
        1321,
        0
      ],
      "end_point": [
        1328,
        1
      ],
      "content": "static char *\nscale10_round_decimal_double (double x, int n)\n{\n  int e IF_LINT(= 0);\n  mpn_t m;\n  void *memory = decode_double (x, &e, &m);\n  return scale10_round_decimal_decoded (e, m, memory, n);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_double (double x, int n)",
        "*"
      ]
    },
    "floorlog10l": {
      "start_point": [
        1337,
        0
      ],
      "end_point": [
        1419,
        1
      ],
      "content": "static int\nfloorlog10l (long double x)\n{\n  int exp;\n  long double y;\n  double z;\n  double l;\n\n  /* Split into exponential part and mantissa.  */\n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n  if (y == 0.0L)\n    return INT_MIN;\n  if (y < 0.5L)\n    {\n      while (y < (1.0L / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n        {\n          y *= 1.0L * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n          exp -= GMP_LIMB_BITS;\n        }\n      if (y < (1.0L / (1 << 16)))\n        {\n          y *= 1.0L * (1 << 16);\n          exp -= 16;\n        }\n      if (y < (1.0L / (1 << 8)))\n        {\n          y *= 1.0L * (1 << 8);\n          exp -= 8;\n        }\n      if (y < (1.0L / (1 << 4)))\n        {\n          y *= 1.0L * (1 << 4);\n          exp -= 4;\n        }\n      if (y < (1.0L / (1 << 2)))\n        {\n          y *= 1.0L * (1 << 2);\n          exp -= 2;\n        }\n      if (y < (1.0L / (1 << 1)))\n        {\n          y *= 1.0L * (1 << 1);\n          exp -= 1;\n        }\n    }\n  if (!(y >= 0.5L && y < 1.0L))\n    abort ();\n  /* Compute an approximation for l = log2(x) = exp + log2(y).  */\n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n  /* Now 0.95 <= z <= 1.01.  */\n  z = 1 - z;\n  /* log2(1-z) = 1/log(2) * (- z - z^2/2 - z^3/3 - z^4/4 - ...)\n     Four terms are enough to get an approximation with error < 10^-7.  */\n  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n  /* Finally multiply with log(2)/log(10), yields an approximation for\n     log10(x).  */\n  l *= 0.30102999566398119523;\n  /* Round down to the next integer.  */\n  return (int) l + (l < 0 ? -1 : 0);\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "floorlog10": {
      "start_point": [
        1428,
        0
      ],
      "end_point": [
        1510,
        1
      ],
      "content": "static int\nfloorlog10 (double x)\n{\n  int exp;\n  double y;\n  double z;\n  double l;\n\n  /* Split into exponential part and mantissa.  */\n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n  if (y == 0.0)\n    return INT_MIN;\n  if (y < 0.5)\n    {\n      while (y < (1.0 / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n        {\n          y *= 1.0 * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n          exp -= GMP_LIMB_BITS;\n        }\n      if (y < (1.0 / (1 << 16)))\n        {\n          y *= 1.0 * (1 << 16);\n          exp -= 16;\n        }\n      if (y < (1.0 / (1 << 8)))\n        {\n          y *= 1.0 * (1 << 8);\n          exp -= 8;\n        }\n      if (y < (1.0 / (1 << 4)))\n        {\n          y *= 1.0 * (1 << 4);\n          exp -= 4;\n        }\n      if (y < (1.0 / (1 << 2)))\n        {\n          y *= 1.0 * (1 << 2);\n          exp -= 2;\n        }\n      if (y < (1.0 / (1 << 1)))\n        {\n          y *= 1.0 * (1 << 1);\n          exp -= 1;\n        }\n    }\n  if (!(y >= 0.5 && y < 1.0))\n    abort ();\n  /* Compute an approximation for l = log2(x) = exp + log2(y).  */\n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n  /* Now 0.95 <= z <= 1.01.  */\n  z = 1 - z;\n  /* log2(1-z) = 1/log(2) * (- z - z^2/2 - z^3/3 - z^4/4 - ...)\n     Four terms are enough to get an approximation with error < 10^-7.  */\n  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n  /* Finally multiply with log(2)/log(10), yields an approximation for\n     log10(x).  */\n  l *= 0.30102999566398119523;\n  /* Round down to the next integer.  */\n  return (int) l + (l < 0 ? -1 : 0);\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_borderline": {
      "start_point": [
        1516,
        0
      ],
      "end_point": [
        1526,
        1
      ],
      "content": "static int\nis_borderline (const char *digits, size_t precision)\n{\n  for (; precision > 0; precision--, digits++)\n    if (*digits != '0')\n      return 0;\n  if (*digits != '1')\n    return 0;\n  digits++;\n  return *digits == '\\0';\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MAX_ROOM_NEEDED": {
      "start_point": [
        1543,
        0
      ],
      "end_point": [
        1778,
        1
      ],
      "content": "static size_t\nMAX_ROOM_NEEDED (const arguments *ap, size_t arg_index, FCHAR_T conversion,\n                 arg_type type, int flags, size_t width, int has_precision,\n                 size_t precision, int pad_ourselves)\n{\n  size_t tmp_length;\n\n  switch (conversion)\n    {\n    case 'd': case 'i': case 'u':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Multiply by 2, as an estimate for FLAG_GROUP.  */\n      tmp_length = xsum (tmp_length, tmp_length);\n      /* Add 1, to account for a leading sign.  */\n      tmp_length = xsum (tmp_length, 1);\n      break;\n\n    case 'o':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Add 1, to account for a leading sign.  */\n      tmp_length = xsum (tmp_length, 1);\n      break;\n\n    case 'x': case 'X':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Add 2, to account for a leading sign or alternate form.  */\n      tmp_length = xsum (tmp_length, 2);\n      break;\n\n    case 'f': case 'F':\n      if (type == TYPE_LONGDOUBLE)\n        tmp_length =\n          (unsigned int) (LDBL_MAX_EXP\n                          * 0.30103 /* binary -> decimal */\n                          * 2 /* estimate for FLAG_GROUP */\n                         )\n          + 1 /* turn floor into ceil */\n          + 10; /* sign, decimal point etc. */\n      else\n        tmp_length =\n          (unsigned int) (DBL_MAX_EXP\n                          * 0.30103 /* binary -> decimal */\n                          * 2 /* estimate for FLAG_GROUP */\n                         )\n          + 1 /* turn floor into ceil */\n          + 10; /* sign, decimal point etc. */\n      tmp_length = xsum (tmp_length, precision);\n      break;\n\n    case 'e': case 'E': case 'g': case 'G':\n      tmp_length =\n        12; /* sign, decimal point, exponent etc. */\n      tmp_length = xsum (tmp_length, precision);\n      break;\n\n    case 'a': case 'A':\n      if (type == TYPE_LONGDOUBLE)\n        tmp_length =\n          (unsigned int) (LDBL_DIG\n                          * 0.831 /* decimal -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (DBL_DIG\n                          * 0.831 /* decimal -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Account for sign, decimal point etc. */\n      tmp_length = xsum (tmp_length, 12);\n      break;\n\n    case 'c':\n# if HAVE_WINT_T && !WIDE_CHAR_VERSION\n      if (type == TYPE_WIDE_CHAR)\n        tmp_length = MB_CUR_MAX;\n      else\n# endif\n        tmp_length = 1;\n      break;\n\n    case 's':\n# if HAVE_WCHAR_T\n      if (type == TYPE_WIDE_STRING)\n        {\n#  if WIDE_CHAR_VERSION\n          /* ISO C says about %ls in fwprintf:\n               \"If the precision is not specified or is greater than the size\n                of the array, the array shall contain a null wide character.\"\n             So if there is a precision, we must not use wcslen.  */\n          const wchar_t *arg = ap->arg[arg_index].a.a_wide_string;\n\n          if (has_precision)\n            tmp_length = local_wcsnlen (arg, precision);\n          else\n            tmp_length = local_wcslen (arg);\n#  else\n          /* ISO C says about %ls in fprintf:\n               \"If a precision is specified, no more than that many bytes are\n                written (including shift sequences, if any), and the array\n                shall contain a null wide character if, to equal the multibyte\n                character sequence length given by the precision, the function\n                would need to access a wide character one past the end of the\n                array.\"\n             So if there is a precision, we must not use wcslen.  */\n          /* This case has already been handled separately in VASNPRINTF.  */\n          abort ();\n#  endif\n        }\n      else\n# endif\n        {\n# if WIDE_CHAR_VERSION\n          /* ISO C says about %s in fwprintf:\n               \"If the precision is not specified or is greater than the size\n                of the converted array, the converted array shall contain a\n                null wide character.\"\n             So if there is a precision, we must not use strlen.  */\n          /* This case has already been handled separately in VASNPRINTF.  */\n          abort ();\n# else\n          /* ISO C says about %s in fprintf:\n               \"If the precision is not specified or greater than the size of\n                the array, the array shall contain a null character.\"\n             So if there is a precision, we must not use strlen.  */\n          const char *arg = ap->arg[arg_index].a.a_string;\n\n          if (has_precision)\n            tmp_length = local_strnlen (arg, precision);\n          else\n            tmp_length = strlen (arg);\n# endif\n        }\n      break;\n\n    case 'p':\n      tmp_length =\n        (unsigned int) (sizeof (void *) * CHAR_BIT\n                        * 0.25 /* binary -> hexadecimal */\n                       )\n          + 1 /* turn floor into ceil */\n          + 2; /* account for leading 0x */\n      break;\n\n    default:\n      abort ();\n    }\n\n  if (!pad_ourselves)\n    {\n# if ENABLE_UNISTDIO\n      /* Padding considers the number of characters, therefore the number of\n         elements after padding may be\n           > max (tmp_length, width)\n         but is certainly\n           <= tmp_length + width.  */\n      tmp_length = xsum (tmp_length, width);\n# else\n      /* Padding considers the number of elements, says POSIX.  */\n      if (tmp_length < width)\n        tmp_length = width;\n# endif\n    }\n\n  tmp_length = xsum (tmp_length, 1); /* account for trailing NUL */\n\n  return tmp_length;\n}",
      "lines": 236,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "xsum": {
      "start_point": [
        4625,
        16
      ],
      "end_point": [
        5554,
        15
      ],
      "content": "int prefixes[2] IF_LINT (= { 0 });\n                int orig_errno;\n#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif\n\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n#endif\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif\n\n                /* Decide whether to handle the precision ourselves.  */\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif\n\n                /* Decide whether to perform the padding ourselves.  */\n#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif\n\n#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif\n\n                /* Construct the format string for calling snprintf or\n                   sprintf.  */\n                fbp = buf;\n                *fbp++ = '%';\n#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif\n                if (flags & FLAG_LEFT)\n                  *fbp++ = '-';\n                if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';\n                if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';\n                if (flags & FLAG_ALT)\n                  *fbp++ = '#';\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif\n                if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n                if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n\n                switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif\n#endif\n                    FALLTHROUGH;\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }\n#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif\n                  *fbp = dp->conversion;\n#if USE_SNPRINTF\n# if ! (((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif\n\n                /* Construct the arguments for calling snprintf or sprintf.  */\n                prefix_count = 0;\n                if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }\n                if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }\n\n#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif\n\n                orig_errno = errno;\n\n                for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }\n                errno = orig_errno;\n#undef pad_ourselves\n#undef prec_ourselves\n              }",
      "lines": 930,
      "depth": 24,
      "decorators": [
        "int",
        "prefixes[2]",
        "prefixes",
        "[",
        "2",
        "]",
        "IF_LINT (=",
        "IF_LINT",
        "(",
        "=",
        "{ 0 });\n                int orig_errno;\n#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif\n\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n#endif\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif\n\n                /* Decide whether to handle the precision ourselves.  */\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif\n\n                /* Decide whether to perform the padding ourselves.  */\n#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif\n\n#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif\n\n                /* Construct the format string for calling snprintf or\n                   sprintf.  */\n                fbp = buf;\n                *fbp++ = '%';\n#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif\n                if (flags & FLAG_LEFT)\n                  *fbp++ = '-';\n                if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';\n                if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';\n                if (flags & FLAG_ALT)\n                  *fbp++ = '#';\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif\n                if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n                if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n\n                switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif\n#endif\n                    FALLTHROUGH;\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }\n#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif\n                  *fbp = dp->conversion;\n#if USE_SNPRINTF\n# if ! (((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif\n\n                /* Construct the arguments for calling snprintf or sprintf.  */\n                prefix_count = 0;\n                if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }\n                if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }\n\n#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif\n\n                orig_errno = errno;\n\n                for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }\n                errno = orig_errno;\n#undef pad_ourselves\n#undef prec_ourselves\n              }",
        "{",
        "0 });",
        "0",
        "})",
        "}",
        ")",
        ";",
        "int orig_errno;",
        "int",
        "orig_errno",
        ";",
        "#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "size_t tmp_length;",
        "size_t",
        "tmp_length",
        ";",
        "TCHAR_T tmpbuf[700];",
        "TCHAR_T",
        "tmpbuf[700]",
        "tmpbuf",
        "[",
        "700",
        "]",
        ";",
        "TCHAR_T *tmp;",
        "TCHAR_T",
        "*tmp",
        "*",
        "tmp",
        ";",
        "#endif",
        "#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_width = 0;",
        "has_width = 0",
        "has_width",
        "=",
        "0",
        ";",
        "#endif",
        "#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "||",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "USE_MSVC__SNPRINTF",
        "||",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "width = 0;",
        "width = 0",
        "width",
        "=",
        "0",
        ";",
        "if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }",
        "if",
        "(dp->width_start != dp->width_end)",
        "(",
        "dp->width_start != dp->width_end",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        "{\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }",
        "{",
        "if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }",
        "if",
        "(dp->width_arg_index != ARG_NONE)",
        "(",
        "dp->width_arg_index != ARG_NONE",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }",
        "{",
        "int arg;",
        "int",
        "arg",
        ";",
        "if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();",
        "if",
        "(!(a.arg[dp->width_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->width_arg_index].type == TYPE_INT",
        "a.arg[dp->width_arg_index].type",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "arg = a.arg[dp->width_arg_index].a.a_int;",
        "arg = a.arg[dp->width_arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->width_arg_index].a.a_int",
        "a.arg[dp->width_arg_index].a",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "width = arg;",
        "width = arg",
        "width",
        "=",
        "arg",
        ";",
        "if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }",
        "if",
        "(arg < 0)",
        "(",
        "arg < 0",
        "arg",
        "<",
        "0",
        ")",
        "{\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }",
        "{",
        "/* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */",
        "flags |= FLAG_LEFT;",
        "flags |= FLAG_LEFT",
        "flags",
        "|=",
        "FLAG_LEFT",
        ";",
        "width = -width;",
        "width = -width",
        "width",
        "=",
        "-width",
        "-",
        "width",
        ";",
        "}",
        "}",
        "else",
        "{\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }",
        "{",
        "const FCHAR_T *digitp = dp->width_start;",
        "const",
        "const",
        "FCHAR_T",
        "*digitp = dp->width_start",
        "*digitp",
        "*",
        "digitp",
        "=",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);",
        "do",
        "width = xsum (xtimes (width, 10), *digitp++ - '0');",
        "width = xsum (xtimes (width, 10), *digitp++ - '0')",
        "width",
        "=",
        "xsum (xtimes (width, 10), *digitp++ - '0')",
        "xsum",
        "(xtimes (width, 10), *digitp++ - '0')",
        "(",
        "xtimes (width, 10)",
        "xtimes",
        "(width, 10)",
        "(",
        "width",
        ",",
        "10",
        ")",
        ",",
        "*digitp++ - '0'",
        "*digitp++",
        "*",
        "digitp++",
        "digitp",
        "++",
        "-",
        "'0'",
        "'",
        "'",
        ")",
        ";",
        "while",
        "(digitp != dp->width_end)",
        "(",
        "digitp != dp->width_end",
        "digitp",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        ";",
        "}",
        "#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_width = 1;",
        "has_width = 1",
        "has_width",
        "=",
        "1",
        ";",
        "#endif",
        "}",
        "#endif",
        "#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "||",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "USE_MSVC__SNPRINTF",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_precision = 0;",
        "has_precision = 0",
        "has_precision",
        "=",
        "0",
        ";",
        "precision = 6;",
        "precision = 6",
        "precision",
        "=",
        "6",
        ";",
        "if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }",
        "if",
        "(dp->precision_start != dp->precision_end)",
        "(",
        "dp->precision_start != dp->precision_end",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "{\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }",
        "{",
        "if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }",
        "if",
        "(dp->precision_arg_index != ARG_NONE)",
        "(",
        "dp->precision_arg_index != ARG_NONE",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }",
        "{",
        "int arg;",
        "int",
        "arg",
        ";",
        "if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();",
        "if",
        "(!(a.arg[dp->precision_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->precision_arg_index].type == TYPE_INT",
        "a.arg[dp->precision_arg_index].type",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "arg = a.arg[dp->precision_arg_index].a.a_int;",
        "arg = a.arg[dp->precision_arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->precision_arg_index].a.a_int",
        "a.arg[dp->precision_arg_index].a",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "/* \"A negative precision is taken as if the precision\n                            were omitted.\"  */",
        "if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }",
        "if",
        "(arg >= 0)",
        "(",
        "arg >= 0",
        "arg",
        ">=",
        "0",
        ")",
        "{\n                            precision = arg;\n                            has_precision = 1;\n                          }",
        "{",
        "precision = arg;",
        "precision = arg",
        "precision",
        "=",
        "arg",
        ";",
        "has_precision = 1;",
        "has_precision = 1",
        "has_precision",
        "=",
        "1",
        ";",
        "}",
        "}",
        "else",
        "{\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }",
        "{",
        "const FCHAR_T *digitp = dp->precision_start + 1;",
        "const",
        "const",
        "FCHAR_T",
        "*digitp = dp->precision_start + 1",
        "*digitp",
        "*",
        "digitp",
        "=",
        "dp->precision_start + 1",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "+",
        "1",
        ";",
        "precision = 0;",
        "precision = 0",
        "precision",
        "=",
        "0",
        ";",
        "while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');",
        "while",
        "(digitp != dp->precision_end)",
        "(",
        "digitp != dp->precision_end",
        "digitp",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "precision = xsum (xtimes (precision, 10), *digitp++ - '0');",
        "precision = xsum (xtimes (precision, 10), *digitp++ - '0')",
        "precision",
        "=",
        "xsum (xtimes (precision, 10), *digitp++ - '0')",
        "xsum",
        "(xtimes (precision, 10), *digitp++ - '0')",
        "(",
        "xtimes (precision, 10)",
        "xtimes",
        "(precision, 10)",
        "(",
        "precision",
        ",",
        "10",
        ")",
        ",",
        "*digitp++ - '0'",
        "*digitp++",
        "*",
        "digitp++",
        "digitp",
        "++",
        "-",
        "'0'",
        "'",
        "'",
        ")",
        ";",
        "has_precision = 1;",
        "has_precision = 1",
        "has_precision",
        "=",
        "1",
        ";",
        "}",
        "}",
        "#endif",
        "/* Decide whether to handle the precision ourselves.  */",
        "#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif",
        "#if",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }",
        "switch",
        "(dp->conversion)",
        "(",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ")",
        "{\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }",
        "{",
        "case 'd':",
        "case",
        "'d'",
        "'",
        "'",
        ":",
        "case 'i':",
        "case",
        "'i'",
        "'",
        "'",
        ":",
        "case 'u':",
        "case",
        "'u'",
        "'",
        "'",
        ":",
        "case 'o':",
        "case",
        "'o'",
        "'",
        "'",
        ":",
        "case 'x':",
        "case",
        "'x'",
        "'",
        "'",
        ":",
        "case 'X':",
        "case",
        "'X'",
        "'",
        "'",
        ":",
        "case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;",
        "case",
        "'p'",
        "'",
        "'",
        ":",
        "prec_ourselves = has_precision && (precision > 0);",
        "prec_ourselves = has_precision && (precision > 0)",
        "prec_ourselves",
        "=",
        "has_precision && (precision > 0)",
        "has_precision",
        "&&",
        "(precision > 0)",
        "(",
        "precision > 0",
        "precision",
        ">",
        "0",
        ")",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    prec_ourselves = 0;\n                    break;",
        "default",
        ":",
        "prec_ourselves = 0;",
        "prec_ourselves = 0",
        "prec_ourselves",
        "=",
        "0",
        ";",
        "break;",
        "break",
        ";",
        "}",
        "#endif",
        "/* Decide whether to perform the padding ourselves.  */",
        "#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif",
        "#if",
        "!NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)",
        "!NEED_PRINTF_FLAG_LEFTADJUST",
        "!",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "&&",
        "(!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)",
        "(",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        ")",
        "\n",
        "switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }",
        "switch",
        "(dp->conversion)",
        "(",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ")",
        "{\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }",
        "{",
        "# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif",
        "# if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "\n",
        "/* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */",
        "case 'c':",
        "case",
        "'c'",
        "'",
        "'",
        ":",
        "case 's':",
        "case",
        "'s'",
        "'",
        "'",
        ":",
        "# endif",
        "# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif",
        "# if",
        "NEED_PRINTF_FLAG_ZERO",
        "\n",
        "case 'f':",
        "case",
        "'f'",
        "'",
        "'",
        ":",
        "case 'F':",
        "case",
        "'F'",
        "'",
        "'",
        ":",
        "case 'e':",
        "case",
        "'e'",
        "'",
        "'",
        ":",
        "case 'E':",
        "case",
        "'E'",
        "'",
        "'",
        ":",
        "case 'g':",
        "case",
        "'g'",
        "'",
        "'",
        ":",
        "case 'G':",
        "case",
        "'G'",
        "'",
        "'",
        ":",
        "case 'a':",
        "case",
        "'a'",
        "'",
        "'",
        ":",
        "case 'A':",
        "case",
        "'A'",
        "'",
        "'",
        ":",
        "# endif",
        "pad_ourselves = 1;",
        "pad_ourselves = 1",
        "pad_ourselves",
        "=",
        "1",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    pad_ourselves = prec_ourselves;\n                    break;",
        "default",
        ":",
        "pad_ourselves = prec_ourselves;",
        "pad_ourselves = prec_ourselves",
        "pad_ourselves",
        "=",
        "prec_ourselves",
        ";",
        "break;",
        "break",
        ";",
        "}",
        "#endif",
        "#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "/* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */",
        "tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);",
        "tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "tmp_length",
        "=",
        "MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "MAX_ROOM_NEEDED",
        "(&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "(",
        "&a",
        "&",
        "a",
        ",",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        ",",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ",",
        "type",
        ",",
        "flags",
        ",",
        "width",
        ",",
        "has_precision",
        ",",
        "precision",
        ",",
        "pad_ourselves",
        ")",
        ";",
        "if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }",
        "if",
        "(tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))",
        "(",
        "tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T)",
        "tmp_length",
        "<=",
        "sizeof (tmpbuf) / sizeof (TCHAR_T)",
        "sizeof (tmpbuf)",
        "sizeof",
        "(",
        "tmpbuf",
        "tmpbuf",
        ")",
        "/",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "tmp = tmpbuf;",
        "tmp = tmpbuf",
        "tmp",
        "=",
        "tmpbuf",
        ";",
        "else",
        "{\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }",
        "{",
        "size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));",
        "size_t",
        "tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T))",
        "tmp_memsize",
        "=",
        "xtimes (tmp_length, sizeof (TCHAR_T))",
        "xtimes",
        "(tmp_length, sizeof (TCHAR_T))",
        "(",
        "tmp_length",
        ",",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;",
        "if",
        "(size_overflow_p (tmp_memsize))",
        "(",
        "size_overflow_p (tmp_memsize)",
        "size_overflow_p",
        "(tmp_memsize)",
        "(",
        "tmp_memsize",
        ")",
        ")",
        "/* Overflow, would lead to out of memory.  */",
        "goto out_of_memory;",
        "goto",
        "out_of_memory",
        ";",
        "tmp = (TCHAR_T *) malloc (tmp_memsize);",
        "tmp = (TCHAR_T *) malloc (tmp_memsize)",
        "tmp",
        "=",
        "(TCHAR_T *) malloc (tmp_memsize)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "malloc (tmp_memsize)",
        "malloc",
        "(tmp_memsize)",
        "(",
        "tmp_memsize",
        ")",
        ";",
        "if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;",
        "if",
        "(tmp == NULL)",
        "(",
        "tmp == NULL",
        "tmp",
        "==",
        "NULL",
        ")",
        "/* Out of memory.  */",
        "goto out_of_memory;",
        "goto",
        "out_of_memory",
        ";",
        "}",
        "#endif",
        "/* Construct the format string for calling snprintf or\n                   sprintf.  */",
        "fbp = buf;",
        "fbp = buf",
        "fbp",
        "=",
        "buf",
        ";",
        "*fbp++ = '%';",
        "*fbp++ = '%'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'%'",
        "'",
        "'",
        ";",
        "#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif",
        "#if",
        "NEED_PRINTF_FLAG_GROUPING",
        "\n",
        "/* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */",
        "#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';",
        "#else",
        "if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';",
        "if",
        "(flags & FLAG_GROUP)",
        "(",
        "flags & FLAG_GROUP",
        "flags",
        "&",
        "FLAG_GROUP",
        ")",
        "*fbp++ = '\\'';",
        "*fbp++ = '\\''",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'\\''",
        "'",
        "\\'",
        "'",
        ";",
        "#endif",
        "if (flags & FLAG_LEFT)\n                  *fbp++ = '-';",
        "if",
        "(flags & FLAG_LEFT)",
        "(",
        "flags & FLAG_LEFT",
        "flags",
        "&",
        "FLAG_LEFT",
        ")",
        "*fbp++ = '-';",
        "*fbp++ = '-'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'-'",
        "'",
        "'",
        ";",
        "if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';",
        "if",
        "(flags & FLAG_SHOWSIGN)",
        "(",
        "flags & FLAG_SHOWSIGN",
        "flags",
        "&",
        "FLAG_SHOWSIGN",
        ")",
        "*fbp++ = '+';",
        "*fbp++ = '+'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'+'",
        "'",
        "'",
        ";",
        "if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';",
        "if",
        "(flags & FLAG_SPACE)",
        "(",
        "flags & FLAG_SPACE",
        "flags",
        "&",
        "FLAG_SPACE",
        ")",
        "*fbp++ = ' ';",
        "*fbp++ = ' '",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "' '",
        "'",
        "'",
        ";",
        "if (flags & FLAG_ALT)\n                  *fbp++ = '#';",
        "if",
        "(flags & FLAG_ALT)",
        "(",
        "flags & FLAG_ALT",
        "flags",
        "&",
        "FLAG_ALT",
        ")",
        "*fbp++ = '#';",
        "*fbp++ = '#'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'#'",
        "'",
        "'",
        ";",
        "#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif",
        "#if",
        "__GLIBC__ >= 2 && !defined __UCLIBC__",
        "__GLIBC__ >= 2",
        "__GLIBC__",
        ">=",
        "2",
        "&&",
        "!defined __UCLIBC__",
        "!",
        "defined __UCLIBC__",
        "defined",
        "__UCLIBC__",
        "\n",
        "if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';",
        "if",
        "(flags & FLAG_LOCALIZED)",
        "(",
        "flags & FLAG_LOCALIZED",
        "flags",
        "&",
        "FLAG_LOCALIZED",
        ")",
        "*fbp++ = 'I';",
        "*fbp++ = 'I'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'I'",
        "'",
        "'",
        ";",
        "#endif",
        "if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "if",
        "(!pad_ourselves)",
        "(",
        "!pad_ourselves",
        "!",
        "pad_ourselves",
        ")",
        "{\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "{",
        "if (flags & FLAG_ZERO)\n                      *fbp++ = '0';",
        "if",
        "(flags & FLAG_ZERO)",
        "(",
        "flags & FLAG_ZERO",
        "flags",
        "&",
        "FLAG_ZERO",
        ")",
        "*fbp++ = '0';",
        "*fbp++ = '0'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'0'",
        "'",
        "'",
        ";",
        "if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "if",
        "(dp->width_start != dp->width_end)",
        "(",
        "dp->width_start != dp->width_end",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        "{\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "{",
        "size_t n = dp->width_end - dp->width_start;",
        "size_t",
        "n = dp->width_end - dp->width_start",
        "n",
        "=",
        "dp->width_end - dp->width_start",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        "-",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "/* The width specification is known to consist only\n                           of standard ASCII characters.  */",
        "if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "if",
        "(sizeof (FCHAR_T) == sizeof (TCHAR_T))",
        "(",
        "sizeof (FCHAR_T) == sizeof (TCHAR_T)",
        "sizeof (FCHAR_T)",
        "sizeof",
        "(FCHAR_T)",
        "(",
        "FCHAR_T",
        ")",
        "==",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "{\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }",
        "{",
        "memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));",
        "memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T))",
        "memcpy",
        "(fbp, dp->width_start, n * sizeof (TCHAR_T))",
        "(",
        "fbp",
        ",",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ",",
        "n * sizeof (TCHAR_T)",
        "n",
        "*",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "fbp += n;",
        "fbp += n",
        "fbp",
        "+=",
        "n",
        ";",
        "}",
        "else",
        "{\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "{",
        "const FCHAR_T *mp = dp->width_start;",
        "const",
        "const",
        "FCHAR_T",
        "*mp = dp->width_start",
        "*mp",
        "*",
        "mp",
        "=",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "do\n                              *fbp++ = *mp++;\n                            while (--n > 0);",
        "do",
        "*fbp++ = *mp++;",
        "*fbp++ = *mp++",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "*mp++",
        "*",
        "mp++",
        "mp",
        "++",
        ";",
        "while",
        "(--n > 0)",
        "(",
        "--n > 0",
        "--n",
        "--",
        "n",
        ">",
        "0",
        ")",
        ";",
        "}",
        "}",
        "}",
        "if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "if",
        "(!prec_ourselves)",
        "(",
        "!prec_ourselves",
        "!",
        "prec_ourselves",
        ")",
        "{\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "{",
        "if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "if",
        "(dp->precision_start != dp->precision_end)",
        "(",
        "dp->precision_start != dp->precision_end",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "{\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "{",
        "size_t n = dp->precision_end - dp->precision_start;",
        "size_t",
        "n = dp->precision_end - dp->precision_start",
        "n",
        "=",
        "dp->precision_end - dp->precision_start",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        "-",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ";",
        "/* The precision specification is known to consist only\n                           of standard ASCII characters.  */",
        "if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "if",
        "(sizeof (FCHAR_T) == sizeof (TCHAR_T))",
        "(",
        "sizeof (FCHAR_T) == sizeof (TCHAR_T)",
        "sizeof (FCHAR_T)",
        "sizeof",
        "(FCHAR_T)",
        "(",
        "FCHAR_T",
        ")",
        "==",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "{\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }",
        "{",
        "memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));",
        "memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T))",
        "memcpy",
        "(fbp, dp->precision_start, n * sizeof (TCHAR_T))",
        "(",
        "fbp",
        ",",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ",",
        "n * sizeof (TCHAR_T)",
        "n",
        "*",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "fbp += n;",
        "fbp += n",
        "fbp",
        "+=",
        "n",
        ";",
        "}",
        "else",
        "{\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "{",
        "const FCHAR_T *mp = dp->precision_start;",
        "const",
        "const",
        "FCHAR_T",
        "*mp = dp->precision_start",
        "*mp",
        "*",
        "mp",
        "=",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ";",
        "do\n                              *fbp++ = *mp++;\n                            while (--n > 0);",
        "do",
        "*fbp++ = *mp++;",
        "*fbp++ = *mp++",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "*mp++",
        "*",
        "mp++",
        "mp",
        "++",
        ";",
        "while",
        "(--n > 0)",
        "(",
        "--n > 0",
        "--n",
        "--",
        "n",
        ">",
        "0",
        ")",
        ";",
        "}",
        "}",
        "}",
        "switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif\n#endif\n                    FALLTHROUGH;\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }",
        "switch",
        "(type)",
        "(",
        "type",
        ")",
        "{\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif\n#endif\n                    FALLTHROUGH;\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }",
        "{",
        "#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif\n#endif",
        "#if",
        "HAVE_LONG_LONG_INT",
        "\n",
        "case TYPE_LONGLONGINT:",
        "case",
        "TYPE_LONGLONGINT",
        ":",
        "case TYPE_ULONGLONGINT:",
        "case",
        "TYPE_ULONGLONGINT",
        ":",
        "# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n# endif",
        "# if",
        "(defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__",
        "(defined _WIN32 || defined __WIN32__)",
        "(",
        "defined _WIN32 || defined __WIN32__",
        "defined _WIN32",
        "defined",
        "_WIN32",
        "||",
        "defined __WIN32__",
        "defined",
        "__WIN32__",
        ")",
        "&&",
        "! defined __CYGWIN__",
        "!",
        "defined __CYGWIN__",
        "defined",
        "__CYGWIN__",
        "\n",
        "*fbp++ = 'I';",
        "*fbp++ = 'I'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'I'",
        "'",
        "'",
        ";",
        "*fbp++ = '6';",
        "*fbp++ = '6'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'6'",
        "'",
        "'",
        ";",
        "*fbp++ = '4';",
        "*fbp++ = '4'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'4'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "# else\n                    *fbp++ = 'l';",
        "# else",
        "*fbp++ = 'l';",
        "*fbp++ = 'l'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'l'",
        "'",
        "'",
        ";",
        "# endif",
        "#endif",
        "FALLTHROUGH;",
        "FALLTHROUGH",
        ";",
        "case TYPE_LONGINT:",
        "case",
        "TYPE_LONGINT",
        ":",
        "case TYPE_ULONGINT:",
        "case",
        "TYPE_ULONGINT",
        ":",
        "#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif",
        "#if",
        "HAVE_WINT_T",
        "\n",
        "case TYPE_WIDE_CHAR:",
        "case",
        "TYPE_WIDE_CHAR",
        ":",
        "#endif",
        "#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif",
        "#if",
        "HAVE_WCHAR_T",
        "\n",
        "case TYPE_WIDE_STRING:",
        "case",
        "TYPE_WIDE_STRING",
        ":",
        "#endif",
        "*fbp++ = 'l';",
        "*fbp++ = 'l'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'l'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;",
        "case",
        "TYPE_LONGDOUBLE",
        ":",
        "*fbp++ = 'L';",
        "*fbp++ = 'L'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'L'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    break;",
        "default",
        ":",
        "break;",
        "break",
        ";",
        "}",
        "#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif",
        "#if",
        "NEED_PRINTF_DIRECTIVE_F",
        "\n",
        "if (dp->conversion == 'F')\n                  *fbp = 'f';",
        "if",
        "(dp->conversion == 'F')",
        "(",
        "dp->conversion == 'F'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'F'",
        "'",
        "'",
        ")",
        "*fbp = 'f';",
        "*fbp = 'f'",
        "*fbp",
        "*",
        "fbp",
        "=",
        "'f'",
        "'",
        "'",
        ";",
        "else",
        "else",
        "#endif",
        "*fbp = dp->conversion;",
        "*fbp = dp->conversion",
        "*fbp",
        "*",
        "fbp",
        "=",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ";",
        "#if USE_SNPRINTF\n# if ! (((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "# if ! (((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif",
        "# if",
        "! (((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))",
        "!",
        "(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))",
        "(",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)                          \\\n        || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)                                            \\\n        || (defined __APPLE__ && defined __MACH__)",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__)",
        "(",
        "(__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))        \\\n         && !defined __UCLIBC__",
        "(__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))",
        "(",
        "__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)",
        "__GLIBC__ > 2",
        "__GLIBC__",
        ">",
        "2",
        "||",
        "(__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)",
        "(",
        "__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3",
        "__GLIBC__ == 2",
        "__GLIBC__",
        "==",
        "2",
        "&&",
        "__GLIBC_MINOR__ >= 3",
        "__GLIBC_MINOR__",
        ">=",
        "3",
        ")",
        ")",
        "&&",
        "!defined __UCLIBC__",
        "!",
        "defined __UCLIBC__",
        "defined",
        "__UCLIBC__",
        ")",
        "||",
        "(defined __APPLE__ && defined __MACH__)",
        "(",
        "defined __APPLE__ && defined __MACH__",
        "defined __APPLE__",
        "defined",
        "__APPLE__",
        "&&",
        "defined __MACH__",
        "defined",
        "__MACH__",
        ")",
        "||",
        "((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)",
        "(",
        "(defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__",
        "(defined _WIN32 || defined __WIN32__)",
        "(",
        "defined _WIN32 || defined __WIN32__",
        "defined _WIN32",
        "defined",
        "_WIN32",
        "||",
        "defined __WIN32__",
        "defined",
        "__WIN32__",
        ")",
        "&&",
        "! defined __CYGWIN__",
        "!",
        "defined __CYGWIN__",
        "defined",
        "__CYGWIN__",
        ")",
        ")",
        "\n",
        "fbp[1] = '%';",
        "fbp[1] = '%'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'%'",
        "'",
        "'",
        ";",
        "fbp[2] = 'n';",
        "fbp[2] = 'n'",
        "fbp[2]",
        "fbp",
        "[",
        "2",
        "]",
        "=",
        "'n'",
        "'",
        "'",
        ";",
        "fbp[3] = '\\0';",
        "fbp[3] = '\\0'",
        "fbp[3]",
        "fbp",
        "[",
        "3",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';",
        "# else",
        "/* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */",
        "/* On Mac OS X 10.3 or newer, we know that snprintf's return\n                   value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99\n                   and gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On Mac OS X 10.13 or newer, the use of %n in format strings\n                   in writable memory by default crashes the program, so we\n                   should avoid it in this situation.  */",
        "/* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "# endif",
        "#else\n                fbp[1] = '\\0';",
        "#else",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "#endif",
        "/* Construct the arguments for calling snprintf or sprintf.  */",
        "prefix_count = 0;",
        "prefix_count = 0",
        "prefix_count",
        "=",
        "0",
        ";",
        "if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }",
        "if",
        "(!pad_ourselves && dp->width_arg_index != ARG_NONE)",
        "(",
        "!pad_ourselves && dp->width_arg_index != ARG_NONE",
        "!pad_ourselves",
        "!",
        "pad_ourselves",
        "&&",
        "dp->width_arg_index != ARG_NONE",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }",
        "{",
        "if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();",
        "if",
        "(!(a.arg[dp->width_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->width_arg_index].type == TYPE_INT",
        "a.arg[dp->width_arg_index].type",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;",
        "prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int",
        "prefixes[prefix_count++]",
        "prefixes",
        "[",
        "prefix_count++",
        "prefix_count",
        "++",
        "]",
        "=",
        "a.arg[dp->width_arg_index].a.a_int",
        "a.arg[dp->width_arg_index].a",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "}",
        "if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }",
        "if",
        "(!prec_ourselves && dp->precision_arg_index != ARG_NONE)",
        "(",
        "!prec_ourselves && dp->precision_arg_index != ARG_NONE",
        "!prec_ourselves",
        "!",
        "prec_ourselves",
        "&&",
        "dp->precision_arg_index != ARG_NONE",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }",
        "{",
        "if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();",
        "if",
        "(!(a.arg[dp->precision_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->precision_arg_index].type == TYPE_INT",
        "a.arg[dp->precision_arg_index].type",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;",
        "prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int",
        "prefixes[prefix_count++]",
        "prefixes",
        "[",
        "prefix_count++",
        "prefix_count",
        "++",
        "]",
        "=",
        "a.arg[dp->precision_arg_index].a.a_int",
        "a.arg[dp->precision_arg_index].a",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "}",
        "#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */",
        "# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n",
        "# define",
        "TCHARS_PER_DCHAR",
        " (sizeof (DCHAR_T) / sizeof (TCHAR_T))",
        "\n",
        "/* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */",
        "ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));",
        "ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR))",
        "ENSURE_ALLOCATION",
        "(xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR))",
        "(",
        "xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "(2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR",
        "(2 + TCHARS_PER_DCHAR - 1)",
        "(",
        "2 + TCHARS_PER_DCHAR - 1",
        "2 + TCHARS_PER_DCHAR",
        "2",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ")",
        ";",
        "/* Prepare checking whether snprintf returns the count\n                   via %n.  */",
        "*(TCHAR_T *) (result + length) = '\\0';",
        "*(TCHAR_T *) (result + length) = '\\0'",
        "*(TCHAR_T *) (result + length)",
        "*",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "#endif",
        "orig_errno = errno;",
        "orig_errno = errno",
        "orig_errno",
        "=",
        "errno",
        ";",
        "for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }",
        "for",
        "(",
        ";",
        ";",
        ")",
        "{\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }",
        "{",
        "int count = -1;",
        "int",
        "count = -1",
        "count",
        "=",
        "-1",
        ";",
        "#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "int retcount = 0;",
        "int",
        "retcount = 0",
        "retcount",
        "=",
        "0",
        ";",
        "size_t maxlen = allocated - length;",
        "size_t",
        "maxlen = allocated - length",
        "maxlen",
        "=",
        "allocated - length",
        "allocated",
        "-",
        "length",
        ";",
        "/* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */",
        "if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;",
        "if",
        "(maxlen > INT_MAX / TCHARS_PER_DCHAR)",
        "(",
        "maxlen > INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        ">",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        "maxlen = INT_MAX / TCHARS_PER_DCHAR;",
        "maxlen = INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        "=",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "maxlen = maxlen * TCHARS_PER_DCHAR;",
        "maxlen = maxlen * TCHARS_PER_DCHAR",
        "maxlen",
        "=",
        "maxlen * TCHARS_PER_DCHAR",
        "maxlen",
        "*",
        "TCHARS_PER_DCHAR",
        ";",
        "# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "# define",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        " \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }",
        "\n",
        "#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "#else",
        "# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "# define",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        " \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }",
        "\n",
        "#endif",
        "errno = 0;",
        "errno = 0",
        "errno",
        "=",
        "0",
        ";",
        "switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }",
        "switch",
        "(type)",
        "(",
        "type",
        ")",
        "{\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }",
        "{",
        "case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_SCHAR",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_schar;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_schar",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_schar",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_schar",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_UCHAR",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_uchar;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_uchar",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_uchar",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_uchar",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_SHORT",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_short;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_short",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_short",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_short",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_USHORT",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_ushort;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ushort",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ushort",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ushort",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_INT",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_int;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_int",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_UINT",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_uint;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_uint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_uint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_uint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGINT",
        ":",
        "{\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long int arg = a.arg[dp->arg_index].a.a_longint;",
        "long int",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_longint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_ULONGINT",
        ":",
        "{\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;",
        "unsigned long int",
        "unsigned",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ulongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ulongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ulongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_LONG_LONG_INT",
        "\n",
        "case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGLONGINT",
        ":",
        "{\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long long int arg = a.arg[dp->arg_index].a.a_longlongint;",
        "long long int",
        "long",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_longlongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longlongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longlongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_ULONGLONGINT",
        ":",
        "{\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;",
        "unsigned long long int",
        "unsigned",
        "long",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ulonglongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ulonglongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ulonglongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_DOUBLE",
        ":",
        "{\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "double arg = a.arg[dp->arg_index].a.a_double;",
        "double",
        "arg = a.arg[dp->arg_index].a.a_double",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_double",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_double",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGDOUBLE",
        ":",
        "{\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long double arg = a.arg[dp->arg_index].a.a_longdouble;",
        "long double",
        "long",
        "double",
        "arg = a.arg[dp->arg_index].a.a_longdouble",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longdouble",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longdouble",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_CHAR",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_char;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_char",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_char",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_char",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_WINT_T",
        "\n",
        "case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_WIDE_CHAR",
        ":",
        "{\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "wint_t arg = a.arg[dp->arg_index].a.a_wide_char;",
        "wint_t",
        "arg = a.arg[dp->arg_index].a.a_wide_char",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_wide_char",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_wide_char",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_STRING",
        ":",
        "{\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "const char *arg = a.arg[dp->arg_index].a.a_string;",
        "const",
        "const",
        "char",
        "*arg = a.arg[dp->arg_index].a.a_string",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_string",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_string",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_WCHAR_T",
        "\n",
        "case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_WIDE_STRING",
        ":",
        "{\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;",
        "const",
        "const",
        "wchar_t",
        "*arg = a.arg[dp->arg_index].a.a_wide_string",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_wide_string",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_wide_string",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_POINTER",
        ":",
        "{\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "void *arg = a.arg[dp->arg_index].a.a_pointer;",
        "void",
        "*arg = a.arg[dp->arg_index].a.a_pointer",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_pointer",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_pointer",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "default:\n                        abort ();",
        "default",
        ":",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "}",
        "#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */",
        "if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }",
        "if",
        "(count >= 0)",
        "(",
        "count >= 0",
        "count",
        ">=",
        "0",
        ")",
        "{\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }",
        "{",
        "/* Verify that snprintf() has NUL-terminated its\n                           result.  */",
        "if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();",
        "if",
        "(count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')",
        "(",
        "count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0'",
        "count < maxlen",
        "count",
        "<",
        "maxlen",
        "&&",
        "((TCHAR_T *) (result + length)) [count] != '\\0'",
        "((TCHAR_T *) (result + length)) [count]",
        "((TCHAR_T *) (result + length))",
        "(",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ")",
        "[",
        "count",
        "]",
        "!=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "/* Portability hack.  */",
        "if (retcount > count)\n                          count = retcount;",
        "if",
        "(retcount > count)",
        "(",
        "retcount > count",
        "retcount",
        ">",
        "count",
        ")",
        "count = retcount;",
        "count = retcount",
        "count",
        "=",
        "retcount",
        ";",
        "}",
        "else",
        "{\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }",
        "{",
        "/* snprintf() doesn't understand the '%n'\n                           directive.  */",
        "if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }",
        "if",
        "(fbp[1] != '\\0')",
        "(",
        "fbp[1] != '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "!=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ")",
        "{\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }",
        "{",
        "/* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "else",
        "{\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }",
        "{",
        "/* Look at the snprintf() return value.  */",
        "if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;",
        "if",
        "(retcount < 0)",
        "(",
        "retcount < 0",
        "retcount",
        "<",
        "0",
        ")",
        "{\n# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }",
        "{",
        "# if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif",
        "# if",
        "!HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "USE_MSVC__SNPRINTF",
        "\n",
        "/* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */",
        "size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);",
        "size_t",
        "tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "tmp_length",
        "=",
        "MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "MAX_ROOM_NEEDED",
        "(&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "(",
        "&a",
        "&",
        "a",
        ",",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        ",",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ",",
        "type",
        ",",
        "flags",
        ",",
        "width",
        ",",
        "has_precision",
        ",",
        "precision",
        ",",
        "pad_ourselves",
        ")",
        ";",
        "if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }",
        "if",
        "(maxlen < tmp_length)",
        "(",
        "maxlen < tmp_length",
        "maxlen",
        "<",
        "tmp_length",
        ")",
        "{\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }",
        "{",
        "/* Make more room.  But try to do through\n                                       this reallocation only once.  */",
        "size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);",
        "size_t",
        "bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "bigger_need",
        "=",
        "xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR",
        "xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)",
        "xsum",
        "(tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)",
        "(",
        "tmp_length",
        ",",
        "TCHARS_PER_DCHAR - 1",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ";",
        "/* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */",
        "size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);",
        "size_t",
        "bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12)",
        "bigger_need2",
        "=",
        "xsum (xtimes (allocated, 2), 12)",
        "xsum",
        "(xtimes (allocated, 2), 12)",
        "(",
        "xtimes (allocated, 2)",
        "xtimes",
        "(allocated, 2)",
        "(",
        "allocated",
        ",",
        "2",
        ")",
        ",",
        "12",
        ")",
        ";",
        "if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;",
        "if",
        "(bigger_need < bigger_need2)",
        "(",
        "bigger_need < bigger_need2",
        "bigger_need",
        "<",
        "bigger_need2",
        ")",
        "bigger_need = bigger_need2;",
        "bigger_need = bigger_need2",
        "bigger_need",
        "=",
        "bigger_need2",
        ";",
        "ENSURE_ALLOCATION (bigger_need);",
        "ENSURE_ALLOCATION (bigger_need)",
        "ENSURE_ALLOCATION",
        "(bigger_need)",
        "(",
        "bigger_need",
        ")",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "# endif",
        "}",
        "else",
        "count = retcount;",
        "count = retcount",
        "count",
        "=",
        "retcount",
        ";",
        "}",
        "}",
        "#endif",
        "/* Attempt to handle failure.  */",
        "if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }",
        "if",
        "(count < 0)",
        "(",
        "count < 0",
        "count",
        "<",
        "0",
        ")",
        "{\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }",
        "{",
        "/* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */",
        "int saved_errno = errno;",
        "int",
        "saved_errno = errno",
        "saved_errno",
        "=",
        "errno",
        ";",
        "if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }",
        "if",
        "(saved_errno == 0)",
        "(",
        "saved_errno == 0",
        "saved_errno",
        "==",
        "0",
        ")",
        "{\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }",
        "{",
        "if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;",
        "if",
        "(dp->conversion == 'c' || dp->conversion == 's')",
        "(",
        "dp->conversion == 'c' || dp->conversion == 's'",
        "dp->conversion == 'c'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'c'",
        "'",
        "'",
        "||",
        "dp->conversion == 's'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'s'",
        "'",
        "'",
        ")",
        "saved_errno = EILSEQ;",
        "saved_errno = EILSEQ",
        "saved_errno",
        "=",
        "EILSEQ",
        ";",
        "else",
        "saved_errno = EINVAL;",
        "saved_errno = EINVAL",
        "saved_errno",
        "=",
        "EINVAL",
        ";",
        "}",
        "if (!(result == resultbuf || result == NULL))\n                          free (result);",
        "if",
        "(!(result == resultbuf || result == NULL))",
        "(",
        "!(result == resultbuf || result == NULL)",
        "!",
        "(result == resultbuf || result == NULL)",
        "(",
        "result == resultbuf || result == NULL",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        "||",
        "result == NULL",
        "result",
        "==",
        "NULL",
        ")",
        ")",
        "free (result);",
        "free (result)",
        "free",
        "(result)",
        "(",
        "result",
        ")",
        ";",
        "if (buf_malloced != NULL)\n                          free (buf_malloced);",
        "if",
        "(buf_malloced != NULL)",
        "(",
        "buf_malloced != NULL",
        "buf_malloced",
        "!=",
        "NULL",
        ")",
        "free (buf_malloced);",
        "free (buf_malloced)",
        "free",
        "(buf_malloced)",
        "(",
        "buf_malloced",
        ")",
        ";",
        "CLEANUP ();",
        "CLEANUP ()",
        "CLEANUP",
        "()",
        "(",
        ")",
        ";",
        "errno = saved_errno;",
        "errno = saved_errno",
        "errno",
        "=",
        "saved_errno",
        ";",
        "return NULL;",
        "return",
        "NULL",
        ";",
        "}",
        "#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */",
        "if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }",
        "if",
        "((unsigned int) count + 1 >= maxlen)",
        "(",
        "(unsigned int) count + 1 >= maxlen",
        "(unsigned int) count + 1",
        "(unsigned int) count",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "count",
        "+",
        "1",
        ">=",
        "maxlen",
        ")",
        "{\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }",
        "{",
        "/* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */",
        "if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }",
        "if",
        "(maxlen == INT_MAX / TCHARS_PER_DCHAR)",
        "(",
        "maxlen == INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        "==",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        "goto overflow;",
        "goto",
        "overflow",
        ";",
        "else",
        "{\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }",
        "{",
        "/* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */",
        "size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));",
        "size_t",
        "n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "n",
        "=",
        "xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "xmax",
        "(xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "(",
        "xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR",
        "((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)",
        "(",
        "(unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1",
        "(unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR",
        "(unsigned int) count + 2",
        "(unsigned int) count",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "count",
        "+",
        "2",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ",",
        "xtimes (allocated, 2)",
        "xtimes",
        "(allocated, 2)",
        "(",
        "allocated",
        ",",
        "2",
        ")",
        ")",
        ";",
        "ENSURE_ALLOCATION (n);",
        "ENSURE_ALLOCATION (n)",
        "ENSURE_ALLOCATION",
        "(n)",
        "(",
        "n",
        ")",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "}",
        "#endif",
        "#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif",
        "#if",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }",
        "if",
        "(prec_ourselves)",
        "(",
        "prec_ourselves",
        ")",
        "{\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }",
        "{",
        "/* Handle the precision.  */",
        "TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);",
        "TCHAR_T",
        "*prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length)",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "=",
        "# if",
        "# if",
        "USE_SNPRINTF\n                          (TCHAR_T *) (result + length)",
        "USE_SNPRINTF\n                          (TCHAR_T *)",
        "USE_SNPRINTF",
        "(TCHAR_T *)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# else\n                          tmp;\n",
        "# else",
        "\n                          tmp;",
        "\n",
        "# endif\n                        size_t prefix_count;\n",
        "# endif",
        "\n                        size_t prefix_count;",
        "\n",
        "size_t move;",
        "size_t",
        "move",
        ";",
        "prefix_count = 0;",
        "prefix_count = 0",
        "prefix_count",
        "=",
        "0",
        ";",
        "/* Put the additional zeroes after the sign.  */",
        "if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;",
        "if",
        "(count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))",
        "(",
        "count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' ')",
        "count >= 1",
        "count",
        ">=",
        "1",
        "&&",
        "(*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' ')",
        "(",
        "*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '",
        "*prec_ptr == '-' || *prec_ptr == '+'",
        "*prec_ptr == '-'",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "'-'",
        "'",
        "'",
        "||",
        "*prec_ptr == '+'",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "'+'",
        "'",
        "'",
        "||",
        "*prec_ptr == ' '",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "' '",
        "'",
        "'",
        ")",
        ")",
        "prefix_count = 1;",
        "prefix_count = 1",
        "prefix_count",
        "=",
        "1",
        ";",
        "/* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */",
        "else",
        "if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;",
        "if",
        "(count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))",
        "(",
        "count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X')",
        "count >= 2\n                                 && prec_ptr[0] == '0'",
        "count >= 2",
        "count",
        ">=",
        "2",
        "&&",
        "prec_ptr[0] == '0'",
        "prec_ptr[0]",
        "prec_ptr",
        "[",
        "0",
        "]",
        "==",
        "'0'",
        "'",
        "'",
        "&&",
        "(prec_ptr[1] == 'x' || prec_ptr[1] == 'X')",
        "(",
        "prec_ptr[1] == 'x' || prec_ptr[1] == 'X'",
        "prec_ptr[1] == 'x'",
        "prec_ptr[1]",
        "prec_ptr",
        "[",
        "1",
        "]",
        "==",
        "'x'",
        "'",
        "'",
        "||",
        "prec_ptr[1] == 'X'",
        "prec_ptr[1]",
        "prec_ptr",
        "[",
        "1",
        "]",
        "==",
        "'X'",
        "'",
        "'",
        ")",
        ")",
        "prefix_count = 2;",
        "prefix_count = 2",
        "prefix_count",
        "=",
        "2",
        ";",
        "move = count - prefix_count;",
        "move = count - prefix_count",
        "move",
        "=",
        "count - prefix_count",
        "count",
        "-",
        "prefix_count",
        ";",
        "if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }",
        "if",
        "(precision > move)",
        "(",
        "precision > move",
        "precision",
        ">",
        "move",
        ")",
        "{\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }",
        "{",
        "/* Insert zeroes.  */",
        "size_t insert = precision - move;",
        "size_t",
        "insert = precision - move",
        "insert",
        "=",
        "precision - move",
        "precision",
        "-",
        "move",
        ";",
        "TCHAR_T *prec_end;",
        "TCHAR_T",
        "*prec_end",
        "*",
        "prec_end",
        ";",
        "# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);",
        "size_t",
        "n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "n",
        "=",
        "xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "(count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR",
        "(count + insert + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + insert + TCHARS_PER_DCHAR - 1",
        "count + insert + TCHARS_PER_DCHAR",
        "count + insert",
        "count",
        "+",
        "insert",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ";",
        "length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;",
        "length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "length",
        "+=",
        "(count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "(count + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + TCHARS_PER_DCHAR - 1",
        "count + TCHARS_PER_DCHAR",
        "count",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "ENSURE_ALLOCATION (n);",
        "ENSURE_ALLOCATION (n)",
        "ENSURE_ALLOCATION",
        "(n)",
        "(",
        "n",
        ")",
        ";",
        "length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;",
        "length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "length",
        "-=",
        "(count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "(count + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + TCHARS_PER_DCHAR - 1",
        "count + TCHARS_PER_DCHAR",
        "count",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "prec_ptr = (TCHAR_T *) (result + length);",
        "prec_ptr = (TCHAR_T *) (result + length)",
        "prec_ptr",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# endif",
        "prec_end = prec_ptr + count;",
        "prec_end = prec_ptr + count",
        "prec_end",
        "=",
        "prec_ptr + count",
        "prec_ptr",
        "+",
        "count",
        ";",
        "prec_ptr += prefix_count;",
        "prec_ptr += prefix_count",
        "prec_ptr",
        "+=",
        "prefix_count",
        ";",
        "while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }",
        "while",
        "(prec_end > prec_ptr)",
        "(",
        "prec_end > prec_ptr",
        "prec_end",
        ">",
        "prec_ptr",
        ")",
        "{\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }",
        "{",
        "prec_end--;",
        "prec_end--",
        "prec_end",
        "--",
        ";",
        "prec_end[insert] = prec_end[0];",
        "prec_end[insert] = prec_end[0]",
        "prec_end[insert]",
        "prec_end",
        "[",
        "insert",
        "]",
        "=",
        "prec_end[0]",
        "prec_end",
        "[",
        "0",
        "]",
        ";",
        "}",
        "prec_end += insert;",
        "prec_end += insert",
        "prec_end",
        "+=",
        "insert",
        ";",
        "do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);",
        "do",
        "*--prec_end = '0';",
        "*--prec_end = '0'",
        "*--prec_end",
        "*",
        "--prec_end",
        "--",
        "prec_end",
        "=",
        "'0'",
        "'",
        "'",
        ";",
        "while",
        "(prec_end > prec_ptr)",
        "(",
        "prec_end > prec_ptr",
        "prec_end",
        ">",
        "prec_ptr",
        ")",
        ";",
        "count += insert;",
        "count += insert",
        "count",
        "+=",
        "insert",
        ";",
        "}",
        "}",
        "#endif",
        "#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();",
        "if",
        "(count >= tmp_length)",
        "(",
        "count >= tmp_length",
        "count",
        ">=",
        "tmp_length",
        ")",
        "/* tmp_length was incorrectly calculated - fix the\n                         code above!  */",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "#endif",
        "#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "\n",
        "/* Convert from TCHAR_T[] to DCHAR_T[].  */",
        "if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }",
        "if",
        "(dp->conversion == 'c' || dp->conversion == 's')",
        "(",
        "dp->conversion == 'c' || dp->conversion == 's'",
        "dp->conversion == 'c'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'c'",
        "'",
        "'",
        "||",
        "dp->conversion == 's'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'s'",
        "'",
        "'",
        ")",
        "{\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }",
        "{",
        "/* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */",
        "const TCHAR_T *tmpsrc;",
        "const",
        "const",
        "TCHAR_T",
        "*tmpsrc",
        "*",
        "tmpsrc",
        ";",
        "DCHAR_T *tmpdst;",
        "DCHAR_T",
        "*tmpdst",
        "*",
        "tmpdst",
        ";",
        "size_t tmpdst_len;",
        "size_t",
        "tmpdst_len",
        ";",
        "/* This code assumes that TCHAR_T is 'char'.  */",
        "verify (sizeof (TCHAR_T) == 1);",
        "verify (sizeof (TCHAR_T) == 1)",
        "verify",
        "(sizeof (TCHAR_T) == 1)",
        "(",
        "sizeof (TCHAR_T) == 1",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        "==",
        "1",
        ")",
        ";",
        "# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "tmpsrc = (TCHAR_T *) (result + length);",
        "tmpsrc = (TCHAR_T *) (result + length)",
        "tmpsrc",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# else\n                        tmpsrc = tmp;",
        "# else",
        "tmpsrc = tmp;",
        "tmpsrc = tmp",
        "tmpsrc",
        "=",
        "tmp",
        ";",
        "# endif",
        "tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);",
        "tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "tmpdst",
        "=",
        "DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "DCHAR_CONV_FROM_ENCODING",
        "(locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "(",
        "locale_charset ()",
        "locale_charset",
        "()",
        "(",
        ")",
        ",",
        "iconveh_question_mark",
        ",",
        "tmpsrc",
        ",",
        "count",
        ",",
        "NULL",
        ",",
        "NULL",
        ",",
        "&tmpdst_len",
        "&",
        "tmpdst_len",
        ")",
        ";",
        "if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }",
        "if",
        "(tmpdst == NULL)",
        "(",
        "tmpdst == NULL",
        "tmpdst",
        "==",
        "NULL",
        ")",
        "{\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }",
        "{",
        "int saved_errno = errno;",
        "int",
        "saved_errno = errno",
        "saved_errno",
        "=",
        "errno",
        ";",
        "if (!(result == resultbuf || result == NULL))\n                              free (result);",
        "if",
        "(!(result == resultbuf || result == NULL))",
        "(",
        "!(result == resultbuf || result == NULL)",
        "!",
        "(result == resultbuf || result == NULL)",
        "(",
        "result == resultbuf || result == NULL",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        "||",
        "result == NULL",
        "result",
        "==",
        "NULL",
        ")",
        ")",
        "free (result);",
        "free (result)",
        "free",
        "(result)",
        "(",
        "result",
        ")",
        ";",
        "if (buf_malloced != NULL)\n                              free (buf_malloced);",
        "if",
        "(buf_malloced != NULL)",
        "(",
        "buf_malloced != NULL",
        "buf_malloced",
        "!=",
        "NULL",
        ")",
        "free (buf_malloced);",
        "free (buf_malloced)",
        "free",
        "(buf_malloced)",
        "(",
        "buf_malloced",
        ")",
        ";",
        "CLEANUP ();",
        "CLEANUP ()",
        "CLEANUP",
        "()",
        "(",
        ")",
        ";",
        "errno = saved_errno;",
        "errno = saved_errno",
        "errno",
        "=",
        "saved_errno",
        ";",
        "return NULL;",
        "return",
        "NULL",
        ";",
        "}",
        "ENSURE_ALLOCATION (xsum (length, tmpdst_len));",
        "ENSURE_ALLOCATION (xsum (length, tmpdst_len))",
        "ENSURE_ALLOCATION",
        "(xsum (length, tmpdst_len))",
        "(",
        "xsum (length, tmpdst_len)",
        "xsum",
        "(length, tmpdst_len)",
        "(",
        "length",
        ",",
        "tmpdst_len",
        ")",
        ")",
        ";",
        "DCHAR_CPY (result + length, tmpdst, tmpdst_len);",
        "DCHAR_CPY (result + length, tmpdst, tmpdst_len)",
        "DCHAR_CPY",
        "(result + length, tmpdst, tmpdst_len)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ",",
        "tmpdst",
        ",",
        "tmpdst_len",
        ")",
        ";",
        "free (tmpdst);",
        "free (tmpdst)",
        "free",
        "(tmpdst)",
        "(",
        "tmpdst",
        ")",
        ";",
        "count = tmpdst_len;",
        "count = tmpdst_len",
        "count",
        "=",
        "tmpdst_len",
        ";",
        "}",
        "else",
        "{\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }",
        "{",
        "/* The result string is ASCII.\n                           Simple 1:1 conversion.  */",
        "# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "/* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */",
        "if (sizeof (DCHAR_T) != sizeof (TCHAR_T))",
        "if",
        "(sizeof (DCHAR_T) != sizeof (TCHAR_T))",
        "(",
        "sizeof (DCHAR_T) != sizeof (TCHAR_T)",
        "sizeof (DCHAR_T)",
        "sizeof",
        "(DCHAR_T)",
        "(",
        "DCHAR_T",
        ")",
        "!=",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "",
        "",
        "# endif",
        "{\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }",
        "{",
        "const TCHAR_T *tmpsrc;",
        "const",
        "const",
        "TCHAR_T",
        "*tmpsrc",
        "*",
        "tmpsrc",
        ";",
        "DCHAR_T *tmpdst;",
        "DCHAR_T",
        "*tmpdst",
        "*",
        "tmpdst",
        ";",
        "size_t n;",
        "size_t",
        "n",
        ";",
        "# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }",
        "if",
        "(result == resultbuf)",
        "(",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        ")",
        "{\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }",
        "{",
        "tmpsrc = (TCHAR_T *) (result + length);",
        "tmpsrc = (TCHAR_T *) (result + length)",
        "tmpsrc",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "/* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */",
        "ENSURE_ALLOCATION (xsum (length, count));",
        "ENSURE_ALLOCATION",
        "(xsum (length, count))",
        "("
      ]
    }
  },
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/vasnprintf.h": {},
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/vasprintf.c": {
    "vasprintf": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nvasprintf (char **resultp, const char *format, va_list args)\n{\n  size_t length;\n  char *result = vasnprintf (NULL, &length, format, args);\n  if (result == NULL)\n    return -1;\n\n  if (length > INT_MAX)\n    {\n      free (result);\n      errno = EOVERFLOW;\n      return -1;\n    }\n\n  *resultp = result;\n  /* Return the number of resulting bytes, excluding the trailing NUL.  */\n  return length;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/verify.h": {},
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/warn-on-use.h": {},
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/wchar.in.h": {},
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/xsize.c": {},
  "texinfo/texinfo-6.5/tp/Texinfo/Convert/XSParagraph/lib/xsize.h": {
    "size_t": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "__attribute__ ((__pure__))\n#endif\nxsum (size_t size1, size_t size2)\n{\n  size_t sum = size1 + size2;\n  return (sum >= size1 ? sum : SIZE_MAX);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": null
    },
    "__pure__": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "__attribute__ ((__pure__))\n#endif\nxmax (size_t size1, size_t size2)\n{\n  /* No explicit check is needed here, because for any n:\n     max (SIZE_MAX, n) == SIZE_MAX and max (n, SIZE_MAX) == SIZE_MAX.  */\n  return (size1 >= size2 ? size1 : size2);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": null
    }
  },
  "texinfo/texinfo-6.5/tp/Texinfo/MiscXS/misc.c": {
    "xs_abort_empty_line": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        249,
        1
      ],
      "content": "int\nxs_abort_empty_line (HV *self, HV *current, SV *additional_text_in)\n{\n  char *additional_text;\n  AV *contents_array;\n  SV **svp;\n  int contents_num;\n  HV *last_elt;\n  char *type;\n  SV *existing_text_sv;\n\n  dTHX;\n\n  /* Get additional text in UTF-8. */\n  if (additional_text_in)\n    {\n      STRLEN len;\n      static char *new_string;\n      additional_text = SvPV (additional_text_in, len);\n      if (!SvUTF8 (additional_text_in))\n        {\n          free (new_string);\n          new_string = bytes_to_utf8 (additional_text, &len);\n          additional_text = new_string;\n        }\n    }\n  else\n    additional_text = \"\";\n\n  svp = hv_fetch (current, \"contents\", strlen(\"contents\"), 0);\n  if (!svp)\n    return 0;\n  contents_array = (AV *)SvRV(*svp);\n\n  contents_num = av_len(contents_array) + 1;\n  if (contents_num == 0)\n    return 0;\n\n  last_elt = (HV *) SvRV (*av_fetch (contents_array, contents_num - 1, 0));\n\n  svp = hv_fetch (last_elt, \"type\", strlen (\"type\"), 0);\n  if (!svp)\n    return 0;\n\n  type = SvPV_nolen (*svp);\n  if (!type)\n    return 0;\n\n  /* Must be one of these types to continue. */\n  if (strcmp (type, \"empty_line\")\n       && strcmp (type, \"empty_line_after_command\")\n       && strcmp (type, \"empty_spaces_before_argument\")\n       && strcmp (type, \"empty_spaces_after_close_brace\"))\n    {\n      return 0;\n    }\n  \n  //fprintf (stderr, \"ABORT EMPTY\\n\");\n\n  svp = hv_fetch (last_elt, \"text\", strlen (\"text\"), 0);\n  if (!svp)\n    return 0; /* or create it? change last arg from 0 to 1 */\n  existing_text_sv = *svp;\n\n  /* Append the 'additional_text' argument. */\n  sv_utf8_upgrade (existing_text_sv);\n  sv_catpv (existing_text_sv, additional_text);\n\n  if (!*SvPV_nolen (existing_text_sv)) /* existing text is empty */\n    {\n      HV *test_extra;\n      char *key;\n      HV *test_elt;\n\n      /* Look for another reference to last_elt. */\n\n      test_elt = current;\n\n      svp = hv_fetch (test_elt, \"extra\", strlen (\"extra\"), 0);\n      if (svp)\n        {\n          test_extra = (HV *) SvRV (*svp);\n          key = \"spaces_before_argument\";\n          svp = hv_fetch (test_extra, key, strlen (key), 0);\n          if (svp)\n            {\n              if ((HV *) SvRV (*svp) == last_elt)\n                goto found;\n            }\n\n          key = \"spaces_after_command\";\n          svp = hv_fetch (test_extra, key, strlen (key), 0);\n          if (svp)\n            {\n              if ((HV *) SvRV (*svp) == last_elt)\n                goto found;\n            }\n        }\n\n      svp = hv_fetch (current, \"parent\", strlen (\"parent\"), 0);\n      if (svp)\n        {\n          test_elt = (HV *) SvRV (*svp);\n          svp = hv_fetch (test_elt, \"extra\", strlen (\"extra\"), 0);\n          if (svp)\n            {\n              test_extra = (HV *) SvRV (*svp);\n              key = \"spaces_before_argument\";\n              svp = hv_fetch (test_extra, key, strlen (key), 0);\n              if (svp)\n                {\n                  if ((HV *) SvRV (*svp) == last_elt)\n                    goto found;\n                }\n\n              key = \"spaces_after_command\";\n              svp = hv_fetch (test_extra, key, strlen (key), 0);\n              if (svp)\n                {\n                  if ((HV *) SvRV (*svp) == last_elt)\n                    goto found;\n                }\n            }\n        }\n\n      if (0)\n        {\nfound:\n          /* We found an \"extra\" reference to this element.  Remove it. */\n          hv_delete (test_extra, key, strlen (key), G_DISCARD);\n\n          /* If the extra hash now empty, remove it as well. */\n          hv_iterinit (test_extra);\n          if (!hv_iternext (test_extra))\n            hv_delete (test_elt, \"extra\", strlen (\"extra\"), G_DISCARD);\n        }\n\n      /* Remove last_elt */\n      av_pop (contents_array);\n    }\n  else if (!strcmp (type, \"empty_line\"))\n    {\n      char *current_type;\n      AV *context_stack;\n      SV *top_context_sv;\n      char *top_context;\n      int top_index;\n      \n      svp = hv_fetch (current, \"type\", strlen (\"type\"), 0);\n      if (!svp)\n        current_type = 0;\n      else\n        current_type = SvPV_nolen (*svp);\n\n      /* \"Types with paragraphs\".  Remove the type unless we are inside\n         one of these types. */\n      if (current_type\n          && strcmp (current_type, \"before_item\")\n          && strcmp (current_type, \"text_root\")\n          && strcmp (current_type, \"document_root\")\n          && strcmp (current_type, \"brace_command_context\"))\n        goto delete_type;\n\n      /* Check the context stack. */\n      svp = hv_fetch (self, \"context_stack\", strlen (\"context_stack\"), 0);\n      if (!svp)\n        goto delete_type; /* shouldn't happen */\n      context_stack = (AV *) SvRV (*svp);\n      top_index = av_len (context_stack);\n      if (top_index < 0)\n        goto delete_type; /* shouldn't happen */\n      svp = av_fetch (context_stack, top_index, 0);\n      if (!svp)\n        goto delete_type; /* shouldn't happen */\n      top_context_sv = *svp;\n      top_context = SvPV_nolen (top_context_sv);\n\n      /* Change type to \"empty_spaces_before_paragraph\" unless we are in\n         one of these contexts. */\n      if (strcmp (top_context, \"math\")\n          && strcmp (top_context, \"menu\")\n          && strcmp (top_context, \"preformatted\")\n          && strcmp (top_context, \"rawpreformatted\")\n          && strcmp (top_context, \"def\")\n          && strcmp (top_context, \"inlineraw\"))\n        {\n          hv_store (last_elt, \"type\", strlen (\"type\"),\n                    newSVpv (\"empty_spaces_before_paragraph\", 0), 0);\n        }\n      else\n        {\ndelete_type:\n          hv_delete (last_elt, \"type\", strlen (\"type\"), G_DISCARD);\n        }\n    }\n  else if (!strcmp (type, \"empty_line_after_command\"))\n    {\n      hv_store (last_elt, \"type\", strlen (\"type\"),\n                newSVpv (\"empty_spaces_after_command\", 0), 0);\n    }\n  return 1;\n}",
      "lines": 202,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "xs_merge_text": {
      "start_point": [
        251,
        0
      ],
      "end_point": [
        409,
        1
      ],
      "content": "HV *\nxs_merge_text (HV *self, HV *current, SV *text_in)\n{\n  AV *contents_array;\n\n  int no_merge_with_following_text = 0;\n  char *text;\n  int leading_spaces;\n  SV *leading_spaces_sv = 0;\n  int call_ret;\n  SV *returned_sv;\n\n  SV *contents_ref;\n  int contents_num;\n  HV *last_elt;\n  SV *existing_text_sv;\n  char *existing_text;\n  SV **svp;\n\n  dTHX;\n\n  dSP;\n\n  /* Get text in UTF-8. */\n  {\n    STRLEN len;\n    static char *new_string;\n    text = SvPV (text_in, len);\n    if (!SvUTF8 (text_in))\n      {\n        free (new_string);\n        new_string = bytes_to_utf8 (text, &len);\n        text = new_string;\n      }\n  }\n\n  leading_spaces = strspn (text, whitespace_chars);\n  if (text[leading_spaces])\n    {\n      int contents_num;\n\n      if (leading_spaces > 0)\n        {\n          leading_spaces_sv = newSVpv (text, leading_spaces);\n        }\n\n      svp = hv_fetch (current,\n                      \"contents\", strlen (\"contents\"), 0);\n      contents_array = (AV *)SvRV(*svp);\n      \n      contents_num = av_len(contents_array) + 1;\n      if (contents_num > 0)\n        {\n          HV *last_elt;\n          char *type = 0;\n\n          last_elt = (HV *)\n            SvRV (*av_fetch (contents_array, contents_num - 1, 0));\n\n          svp = hv_fetch (last_elt, \"type\", strlen (\"type\"), 0);\n          if (svp)\n            type = SvPV_nolen (*svp);\n          if (type\n              && (!strcmp (type, \"empty_line_after_command\")\n                  || !strcmp (type, \"empty_spaces_after_command\")\n                  || !strcmp (type, \"empty_spaces_before_argument\")\n                  || !strcmp (type, \"empty_spaces_after_close_brace\")))\n            {\n              no_merge_with_following_text = 1;\n            }\n        }\n\n      if (xs_abort_empty_line(self, current, leading_spaces_sv))\n        {\n          text += leading_spaces;\n        }\n\n      /************************/\n      /* See 'perlcall' man page. */\n      ENTER;\n      SAVETMPS;\n\n\n      PUSHMARK(SP);\n      XPUSHs(sv_2mortal(newRV_inc((SV *)self)));\n      XPUSHs(sv_2mortal(newRV_inc((SV *)current)));\n      PUTBACK;\n\n      call_ret = call_pv (\"Texinfo::Parser::_begin_paragraph\", G_SCALAR);\n\n      SPAGAIN;\n\n      returned_sv = POPs;\n\n      /************************/\n\n      if (returned_sv && SvRV(returned_sv))\n        {\n          current = (HV *)SvRV(returned_sv);\n        }\n\n      FREETMPS;\n      LEAVE;\n    }\n\n  svp = hv_fetch (current, \"contents\", strlen (\"contents\"), 0);\n  if (!svp)\n    {\n      contents_array = newAV ();\n      contents_ref = newRV_inc ((SV *) contents_array);\n      hv_store (current, \"contents\", strlen (\"contents\"),\n                contents_ref, 0);\n      fprintf (stderr, \"NEW CONTENTS %p\\n\", contents_array);\n      goto NEW_TEXT;\n    }\n  else\n    {\n      contents_ref = *svp;\n      contents_array = (AV *)SvRV(contents_ref);\n    }\n\n  if (no_merge_with_following_text)\n    goto NEW_TEXT;\n\n  contents_num = av_len(contents_array) + 1;\n  if (contents_num == 0)\n    goto NEW_TEXT;\n\n  last_elt = (HV *)\n    SvRV (*av_fetch (contents_array, contents_num - 1, 0));\n  svp = hv_fetch (last_elt, \"text\", strlen (\"text\"), 0);\n  if (!svp)\n    goto NEW_TEXT;\n  existing_text_sv = *svp;\n  existing_text = SvPV_nolen (existing_text_sv);\n  if (strchr (existing_text, '\\n'))\n    goto NEW_TEXT;\n\nMERGED_TEXT:\n  sv_catpv (existing_text_sv, text);\n  //fprintf (stderr, \"MERGED TEXT: %s|||\\n\", text);\n\n  if (0)\n    {\n      HV *hv;\n      SV *sv;\nNEW_TEXT:\n      hv = newHV ();\n      sv = newSVpv (text, 0);\n      hv_store (hv, \"text\", strlen (\"text\"), sv, 0);\n      SvUTF8_on (sv);\n      hv_store (hv, \"parent\", strlen (\"parent\"),\n                newRV_inc ((SV *)current), 0);\n      av_push (contents_array, newRV_inc ((SV *)hv));\n      //fprintf (stderr, \"NEW TEXT: %s|||\\n\", text);\n    }\n\n  return current;\n}",
      "lines": 159,
      "depth": 18,
      "decorators": [
        "HV",
        "*\nxs_merge_text (HV *self, HV *current, SV *text_in)",
        "*"
      ]
    },
    "xs_process_text": {
      "start_point": [
        411,
        0
      ],
      "end_point": [
        460,
        1
      ],
      "content": "char *\nxs_process_text (char *text)\n{\n  char *new, *p, *q;\n\n  new = strdup (text);\n\n  p = q = new;\n  while (*p)\n    {\n      if (*p == '-' && p[1] == '-')\n        {\n          if (p[2] == '-')\n            {\n              *q = '-'; q[1] = '-';\n              p += 3; q += 2;\n            }\n          else\n            {\n              *q = '-';\n              p += 2; q += 1;\n            }\n        }\n      else if (*p == '\\'' && p[1] == '\\'')\n        {\n          *q = '\"';\n          p += 2; q += 1;\n        }\n      else if (*p == '`')\n        {\n          if (p[1] == '`')\n            {\n              *q = '\"';\n              p += 2; q += 1;\n            }\n          else\n            {\n              *q = '\\'';\n              p += 1; q += 1;\n            }\n        }\n      else\n        {\n          *q++ = *p++;\n        }\n    }\n  *q = '\\0';\n\n  return new;\n}",
      "lines": 50,
      "depth": 14,
      "decorators": [
        "char",
        "*\nxs_process_text (char *text)",
        "*"
      ]
    },
    "xs_unicode_text": {
      "start_point": [
        462,
        0
      ],
      "end_point": [
        562,
        1
      ],
      "content": "char *\nxs_unicode_text (char *text, int in_code)\n{\n  char *p, *q;\n  char *new;\n  int new_space, new_len;\n\n  dTHX; /* Perl boilerplate. */\n\n  if (in_code)\n    return text;\n\n  p = text;\n  new_space = strlen (text);\n  new = malloc (new_space + 1);\n  new_len = 0;\n#define ADD3(s) \\\n  if (new_len + 2 >= new_space - 1)               \\\n    {                                             \\\n      new_space += 2;                             \\\n      new = realloc (new, new_space *= 2);        \\\n    }                                             \\\n  new[new_len++] = s[0];                          \\\n  new[new_len++] = s[1];                          \\\n  new[new_len++] = s[2];\n\n#define ADD1(s) \\\n  if (new_len >= new_space - 1)                   \\\n    new = realloc (new, (new_space *= 2) + 1);    \\\n  new[new_len++] = s;\n\n#define ADDN(s, n) \\\n  if (new_len + n - 1 >= new_space - 1)           \\\n    {                                             \\\n      new_space += n;                             \\\n      new = realloc (new, (new_space *= 2) + 1);  \\\n    }                                             \\\n  memcpy(new + new_len, s, n);                    \\\n  new_len += n;\n\n  while (1)\n    {\n      q = p + strcspn (p, \"-`'\");\n      ADDN(p, q - p);\n      if (!*q)\n        break;\n      switch (*q)\n        {\n        case '-':\n          if (!memcmp (q, \"---\", 3))\n            {\n              p = q + 3;\n              /* Unicode em dash U+2014 (0xE2 0x80 0x94) */\n              ADD3(\"\\xE2\\x80\\x94\");\n            }\n          else if (!memcmp (q, \"--\", 2))\n            {\n              p = q + 2;\n              /* Unicode en dash U+2013 (0xE2 0x80 0x93) */\n              ADD3(\"\\xE2\\x80\\x93\");\n            }\n          else\n            {\n              p = q + 1;\n              ADD1(*q);\n            }\n          break;\n        case '`':\n          if (!memcmp (q, \"``\", 2))\n            {\n              p = q + 2;\n              /* U+201C E2 80 9C */\n              ADD3(\"\\xE2\\x80\\x9C\");\n            }\n          else\n            {\n              p = q + 1;\n              /* U+2018 E2 80 98 */\n              ADD3(\"\\xE2\\x80\\x98\");\n            }\n          break;\n        case '\\'':\n          if (!memcmp (q, \"''\", 2))\n            {\n              p = q + 2;\n              /* U+201D E2 80 9D */\n              ADD3(\"\\xE2\\x80\\x9D\");\n            }\n          else\n            {\n              p = q + 1;\n              /* U+2019 E2 80 99 */\n              ADD3(\"\\xE2\\x80\\x99\");\n            }\n          break;\n        }\n    }\n\n  new[new_len] = '\\0';\n  return new;\n}",
      "lines": 101,
      "depth": 15,
      "decorators": [
        "char",
        "*\nxs_unicode_text (char *text, int in_code)",
        "*"
      ]
    },
    "xs_parse_texi_regex": {
      "start_point": [
        566,
        0
      ],
      "end_point": [
        645,
        1
      ],
      "content": "void xs_parse_texi_regex (SV *text_in,\n                          char **at_command,\n                          char **open_brace,\n                          char **asterisk,\n                          char **single_letter_command,\n                          char **separator_match,\n                          char **new_text)\n{\n  char *text;\n\n  dTHX;\n\n  /* Make sure the input is in UTF8. */\n  if (!SvUTF8 (text_in))\n    sv_utf8_upgrade (text_in);\n  text = SvPV_nolen (text_in);\n\n  *at_command = *open_brace = *asterisk = *single_letter_command\n          = *separator_match = *new_text = 0;\n\n  if (*text == '@' && isalnum(text[1]))\n    {\n      char *p, *q;\n\n      p = text + 1;\n      q = text + 2;\n      while (isalnum (*q) || *q == '-' || *q == '_')\n        q++;\n      *at_command = malloc (q - p + 1);\n      memcpy (*at_command, p, q - p);\n      (*at_command)[q - p] = '\\0';\n    }\n  else\n    {\n      if (*text == '{')\n        {\n          *open_brace = strdup (\"{\");\n          *separator_match = strdup (\"{\");\n        }\n\n      else if (*text == '@'\n                 && text[1] && strchr (\"([\\\"'~@}{,.!?\"\n                                       \" \\t\\n\"\n                                       \"*-^`=:|/\\\\\",\n                                       text[1]))\n        {\n          *single_letter_command = malloc (2);\n          (*single_letter_command)[0] = text[1];\n          (*single_letter_command)[1] = '\\0';\n        }\n\n      else if (strchr (\"{}@,:\\t.\\f\", *text))\n        {\n          *separator_match = malloc (2);\n          (*separator_match)[0] = *text;\n          (*separator_match)[1] = '\\0';\n        }\n\n      else\n        {\n          char *p;\n\n          if (*text == '*')\n            {\n              *asterisk = strdup (\"*\");\n            }\n\n          p = text;\n          p += strcspn (p, \"{}@,:\\t.\\n\\f\");\n          if (p > text)\n            {\n              *new_text = malloc (p - text + 1);\n              memcpy (*new_text, text, p - text);\n              (*new_text)[p - text] = '\\0';\n            }\n        }\n    }\n\n  return;\n}",
      "lines": 80,
      "depth": 17,
      "decorators": [
        "void"
      ]
    }
  },
  "texinfo/texinfo-6.5/tp/Texinfo/MiscXS/MiscXS.c": {
    "S_croak_xs_usage": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "STATIC void\nS_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)\n{\n    const GV *const gv = CvGV(cv);\n\n    PERL_ARGS_ASSERT_CROAK_XS_USAGE;\n\n    if (gv) {\n        const char *const gvname = GvNAME(gv);\n        const HV *const stash = GvSTASH(gv);\n        const char *const hvname = stash ? HvNAME(stash) : NULL;\n\n        if (hvname)\n            Perl_croak(aTHX_ \"Usage: %s::%s(%s)\", hvname, gvname, params);\n        else\n            Perl_croak(aTHX_ \"Usage: %s(%s)\", gvname, params);\n    } else {\n        /* Pants. I don't think that it should be possible to get here. */\n        Perl_croak(aTHX_ \"Usage: CODE(0x%\"UVxf\")(%s)\", PTR2UV(cv), params);\n    }\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "STATIC",
        "void",
        "void"
      ]
    },
    "XS_Texinfo__MiscXSXS_abort_empty_line": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "XS_EUPXS(XS_Texinfo__MiscXSXS_abort_empty_line)\n{\n    dVAR; dXSARGS;\n    if (items < 2)\n       croak_xs_usage(cv,  \"self, current, ...\");\n    {\n\tHV *\tself;\n\tHV *\tcurrent;\n#line 38 \"MiscXS.xs\"\n     SV *additional_text = 0;\n#line 179 \"MiscXS.c\"\n\tint\tRETVAL;\n\tdXSTARG;\n\n\tSTMT_START {\n\t\tSV* const xsub_tmp_sv = ST(0);\n\t\tSvGETMAGIC(xsub_tmp_sv);\n\t\tif (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){\n\t\t    self = (HV*)SvRV(xsub_tmp_sv);\n\t\t}\n\t\telse{\n\t\t    Perl_croak(aTHX_ \"%s: %s is not a HASH reference\",\n\t\t\t\t\"Texinfo::MiscXSXS::abort_empty_line\",\n\t\t\t\t\"self\");\n\t\t}\n\t} STMT_END\n;\n\n\tSTMT_START {\n\t\tSV* const xsub_tmp_sv = ST(1);\n\t\tSvGETMAGIC(xsub_tmp_sv);\n\t\tif (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){\n\t\t    current = (HV*)SvRV(xsub_tmp_sv);\n\t\t}\n\t\telse{\n\t\t    Perl_croak(aTHX_ \"%s: %s is not a HASH reference\",\n\t\t\t\t\"Texinfo::MiscXSXS::abort_empty_line\",\n\t\t\t\t\"current\");\n\t\t}\n\t} STMT_END\n;\n#line 40 \"MiscXS.xs\"\n     items -= 2;\n     if (items > 0 && SvOK(ST(2)))\n       {\n         additional_text = ST(2);\n       }\n     RETVAL = xs_abort_empty_line (self, current, additional_text);\n#line 217 \"MiscXS.c\"\n\tXSprePUSH; PUSHi((IV)RETVAL);\n    }\n    XSRETURN(1);\n}",
      "lines": 53,
      "depth": 13,
      "decorators": null
    },
    "XS_Texinfo__MiscXSXS_merge_text": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "XS_EUPXS(XS_Texinfo__MiscXSXS_merge_text)\n{\n    dVAR; dXSARGS;\n    if (items != 3)\n       croak_xs_usage(cv,  \"self, current, text_in\");\n    {\n\tHV *\tself;\n\tHV *\tcurrent;\n\tSV *\ttext_in = ST(2)\n;\n\tHV *\tRETVAL;\n\n\tSTMT_START {\n\t\tSV* const xsub_tmp_sv = ST(0);\n\t\tSvGETMAGIC(xsub_tmp_sv);\n\t\tif (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){\n\t\t    self = (HV*)SvRV(xsub_tmp_sv);\n\t\t}\n\t\telse{\n\t\t    Perl_croak(aTHX_ \"%s: %s is not a HASH reference\",\n\t\t\t\t\"Texinfo::MiscXSXS::merge_text\",\n\t\t\t\t\"self\");\n\t\t}\n\t} STMT_END\n;\n\n\tSTMT_START {\n\t\tSV* const xsub_tmp_sv = ST(1);\n\t\tSvGETMAGIC(xsub_tmp_sv);\n\t\tif (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){\n\t\t    current = (HV*)SvRV(xsub_tmp_sv);\n\t\t}\n\t\telse{\n\t\t    Perl_croak(aTHX_ \"%s: %s is not a HASH reference\",\n\t\t\t\t\"Texinfo::MiscXSXS::merge_text\",\n\t\t\t\t\"current\");\n\t\t}\n\t} STMT_END\n;\n\n\tRETVAL = xs_merge_text(self, current, text_in);\n\tST(0) = newRV((SV*)RETVAL);\n\tsv_2mortal(ST(0));\n    }\n    XSRETURN(1);\n}",
      "lines": 46,
      "depth": 13,
      "decorators": null
    },
    "XS_Texinfo__MiscXSXS_process_text": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "XS_EUPXS(XS_Texinfo__MiscXSXS_process_text)\n{\n    dVAR; dXSARGS;\n    if (items != 1)\n       croak_xs_usage(cv,  \"text_in\");\n    {\n\tSV *\ttext_in = ST(0)\n;\n#line 59 \"MiscXS.xs\"\n     char *text;\n     char *retval;\n#line 285 \"MiscXS.c\"\n\tSV *\tRETVAL;\n#line 62 \"MiscXS.xs\"\n     /* Make sure the input is in UTF8. */\n     if (!SvUTF8 (text_in))\n       sv_utf8_upgrade (text_in);\n\n     text = SvPV_nolen (text_in);\n\n     retval = xs_process_text (text);\n\n     RETVAL = newSVpv (retval, 0);\n     SvUTF8_on (RETVAL);\n#line 298 \"MiscXS.c\"\n\tST(0) = RETVAL;\n\tsv_2mortal(ST(0));\n    }\n    XSRETURN(1);\n}",
      "lines": 30,
      "depth": 9,
      "decorators": null
    },
    "XS_Texinfo__MiscXSXS_unicode_text": {
      "start_point": [
        305,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "XS_EUPXS(XS_Texinfo__MiscXSXS_unicode_text)\n{\n    dVAR; dXSARGS;\n    if (items < 1)\n       croak_xs_usage(cv,  \"text_in, ...\");\n    {\n\tSV *\ttext_in = ST(0)\n;\n#line 79 \"MiscXS.xs\"\n     int in_code = 0;\n     char *text;\n     char *retval;\n#line 319 \"MiscXS.c\"\n\tSV *\tRETVAL;\n#line 83 \"MiscXS.xs\"\n     items--;\n     if (items > 0)\n       {\n         if (SvOK(ST(1)))\n           in_code = (int) SvIV(ST(1));\n       }\n     /* Make sure the input is in UTF8. */\n     if (!SvUTF8 (text_in))\n       sv_utf8_upgrade (text_in);\n\n     text = SvPV_nolen (text_in);\n\n     retval = xs_unicode_text (text, in_code);\n\n     RETVAL = newSVpv (retval, 0);\n     SvUTF8_on (RETVAL);\n\n#line 339 \"MiscXS.c\"\n\tST(0) = RETVAL;\n\tsv_2mortal(ST(0));\n    }\n    XSRETURN(1);\n}",
      "lines": 38,
      "depth": 14,
      "decorators": null
    },
    "XS_Texinfo__MiscXSXS_parse_texi_regex": {
      "start_point": [
        346,
        0
      ],
      "end_point": [
        390,
        1
      ],
      "content": "XS_EUPXS(XS_Texinfo__MiscXSXS_parse_texi_regex)\n{\n    dVAR; dXSARGS;\n    if (items != 1)\n       croak_xs_usage(cv,  \"text\");\n    PERL_UNUSED_VAR(ax); /* -Wall */\n    SP -= items;\n    {\n\tSV *\ttext = ST(0)\n;\n#line 107 \"MiscXS.xs\"\n     char *at_command;\n     char *open_brace;\n     char *asterisk;\n     char *single_letter_command;\n     char *separator_match;\n     char *new_text;\n#line 365 \"MiscXS.c\"\n#line 114 \"MiscXS.xs\"\n     xs_parse_texi_regex(text, &at_command, &open_brace, &asterisk, \n                         &single_letter_command, &separator_match, &new_text);\n     EXTEND(SP,6);\n     PUSHs(sv_newmortal());\n     sv_setpv((SV*)ST(0), at_command);\n     SvUTF8_on(ST(0));\n     PUSHs(sv_newmortal());\n     sv_setpv((SV*)ST(1), open_brace);\n     SvUTF8_on(ST(1));\n     PUSHs(sv_newmortal());\n     sv_setpv((SV*)ST(2), asterisk);\n     SvUTF8_on(ST(2));\n     PUSHs(sv_newmortal());\n     sv_setpv((SV*)ST(3), single_letter_command);\n     SvUTF8_on(ST(3));\n     PUSHs(sv_newmortal());\n     sv_setpv((SV*)ST(4), separator_match);\n     SvUTF8_on(ST(4));\n     PUSHs(sv_newmortal());\n     sv_setpv((SV*)ST(5), new_text);\n     SvUTF8_on(ST(5));\n#line 388 \"MiscXS.c\"\n\tPUTBACK;\n\treturn;\n    }\n}",
      "lines": 45,
      "depth": 10,
      "decorators": null
    },
    "boot_Texinfo__MiscXSXS": {
      "start_point": [
        396,
        0
      ],
      "end_point": [
        422,
        1
      ],
      "content": "XS_EXTERNAL(boot_Texinfo__MiscXSXS)\n{\n    dVAR; dXSARGS;\n#if (PERL_REVISION == 5 && PERL_VERSION < 9)\n    char* file = __FILE__;\n#else\n    const char* file = __FILE__;\n#endif\n\n    PERL_UNUSED_VAR(cv); /* -W */\n    PERL_UNUSED_VAR(items); /* -W */\n#ifdef XS_APIVERSION_BOOTCHECK\n    XS_APIVERSION_BOOTCHECK;\n#endif\n    XS_VERSION_BOOTCHECK;\n\n        newXS(\"Texinfo::MiscXSXS::abort_empty_line\", XS_Texinfo__MiscXSXS_abort_empty_line, file);\n        newXS(\"Texinfo::MiscXSXS::merge_text\", XS_Texinfo__MiscXSXS_merge_text, file);\n        newXS(\"Texinfo::MiscXSXS::process_text\", XS_Texinfo__MiscXSXS_process_text, file);\n        newXS(\"Texinfo::MiscXSXS::unicode_text\", XS_Texinfo__MiscXSXS_unicode_text, file);\n        newXS(\"Texinfo::MiscXSXS::parse_texi_regex\", XS_Texinfo__MiscXSXS_parse_texi_regex, file);\n#if (PERL_REVISION == 5 && PERL_VERSION >= 9)\n  if (PL_unitcheckav)\n       call_list(PL_scopestack_ix, PL_unitcheckav);\n#endif\n    XSRETURN_YES;\n}",
      "lines": 27,
      "depth": 8,
      "decorators": null
    }
  },
  "texinfo/texinfo-6.5/tp/Texinfo/MiscXS/miscxs.h": {},
  "texinfo/texinfo-6.5/tp/Texinfo/MiscXS/ppport.h": {
    "DPPP_": [
      {
        "start_point": [
          4493,
          0
        ],
        "end_point": [
          4511,
          1
        ],
        "content": "SV*\nDPPP_(my_eval_pv)(char *p, I32 croak_on_error)\n{\n    dSP;\n    SV* sv = newSVpv(p, 0);\n\n    PUSHMARK(sp);\n    eval_sv(sv, G_SCALAR);\n    SvREFCNT_dec(sv);\n\n    SPAGAIN;\n    sv = POPs;\n    PUTBACK;\n\n    if (croak_on_error && SvTRUE(GvSV(errgv)))\n\tcroak(SvPVx(GvSV(errgv), na));\n\n    return sv;\n}",
        "lines": 19,
        "depth": 11,
        "decorators": [
          "SV",
          "*\nDPPP_(my_eval_pv)(char *p, I32 croak_on_error)",
          "*"
        ]
      },
      {
        "start_point": [
          4532,
          0
        ],
        "end_point": [
          4583,
          1
        ],
        "content": "void\nDPPP_(my_vload_module)(U32 flags, SV *name, SV *ver, va_list *args)\n{\n    dTHR;\n    dVAR;\n    OP *veop, *imop;\n\n    OP * const modname = newSVOP(OP_CONST, 0, name);\n    /* 5.005 has a somewhat hacky force_normal that doesn't croak on\n       SvREADONLY() if PL_compling is true. Current perls take care in\n       ck_require() to correctly turn off SvREADONLY before calling\n       force_normal_flags(). This seems a better fix than fudging PL_compling\n     */\n    SvREADONLY_off(((SVOP*)modname)->op_sv);\n    modname->op_private |= OPpCONST_BARE;\n    if (ver) {\n\tveop = newSVOP(OP_CONST, 0, ver);\n    }\n    else\n\tveop = NULL;\n    if (flags & PERL_LOADMOD_NOIMPORT) {\n\timop = sawparens(newNULLLIST());\n    }\n    else if (flags & PERL_LOADMOD_IMPORT_OPS) {\n\timop = va_arg(*args, OP*);\n    }\n    else {\n\tSV *sv;\n\timop = NULL;\n\tsv = va_arg(*args, SV*);\n\twhile (sv) {\n\t    imop = append_elem(OP_LIST, imop, newSVOP(OP_CONST, 0, sv));\n\t    sv = va_arg(*args, SV*);\n\t}\n    }\n    {\n\tconst line_t ocopline = PL_copline;\n\tCOP * const ocurcop = PL_curcop;\n\tconst int oexpect = PL_expect;\n\n#if (PERL_BCDVERSION >= 0x5004000)\n\tutilize(!(flags & PERL_LOADMOD_DENY), start_subparse(FALSE, 0),\n\t\tveop, modname, imop);\n#else\n\tutilize(!(flags & PERL_LOADMOD_DENY), start_subparse(),\n\t\tmodname, imop);\n#endif\n\tPL_expect = oexpect;\n\tPL_copline = ocopline;\n\tPL_curcop = ocurcop;\n    }\n}",
        "lines": 52,
        "depth": 14,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          4604,
          0
        ],
        "end_point": [
          4611,
          1
        ],
        "content": "void\nDPPP_(my_load_module)(U32 flags, SV *name, SV *ver, ...)\n{\n    va_list args;\n    va_start(args, ver);\n    vload_module(flags, name, ver, &args);\n    va_end(args);\n}",
        "lines": 8,
        "depth": 7,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          4634,
          0
        ],
        "end_point": [
          4640,
          1
        ],
        "content": "SV *\nDPPP_(my_newRV_noinc)(SV *sv)\n{\n  SV *rv = (SV *)newRV(sv);\n  SvREFCNT_dec(sv);\n  return rv;\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "SV",
          "*\nDPPP_(my_newRV_noinc)(SV *sv)",
          "*"
        ]
      },
      {
        "start_point": [
          4931,
          0
        ],
        "end_point": [
          4937,
          1
        ],
        "content": "SV*\nDPPP_(my_newSV_type)(pTHX_ svtype const t)\n{\n  SV* const sv = newSV(0);\n  sv_upgrade(sv, t);\n  return sv;\n}",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "SV",
          "*\nDPPP_(my_newSV_type)(pTHX_ svtype const t)",
          "*"
        ]
      },
      {
        "start_point": [
          4977,
          0
        ],
        "end_point": [
          4983,
          1
        ],
        "content": "SV *\nDPPP_(my_newSVpvn_flags)(pTHX_ const char *s, STRLEN len, U32 flags)\n{\n  SV *sv = newSVpvn(D_PPP_CONSTPV_ARG(s), len);\n  SvFLAGS(sv) |= (flags & SVf_UTF8);\n  return (flags & SVs_TEMP) ? sv_2mortal(sv) : sv;\n}",
        "lines": 7,
        "depth": 9,
        "decorators": [
          "SV",
          "*\nDPPP_(my_newSVpvn_flags)(pTHX_ const char *s, STRLEN len, U32 flags)",
          "*"
        ]
      },
      {
        "start_point": [
          5028,
          0
        ],
        "end_point": [
          5033,
          1
        ],
        "content": "char *\nDPPP_(my_sv_2pvbyte)(pTHX_ SV *sv, STRLEN *lp)\n{\n  sv_utf8_downgrade(sv,0);\n  return SvPV(sv,*lp);\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "char",
          "*\nDPPP_(my_sv_2pvbyte)(pTHX_ SV *sv, STRLEN *lp)",
          "*"
        ]
      },
      {
        "start_point": [
          5125,
          0
        ],
        "end_point": [
          5130,
          1
        ],
        "content": "char *\nDPPP_(my_sv_2pv_flags)(pTHX_ SV *sv, STRLEN *lp, I32 flags)\n{\n  STRLEN n_a = (STRLEN) flags;\n  return sv_2pv(sv, lp ? lp : &n_a);\n}",
        "lines": 6,
        "depth": 8,
        "decorators": [
          "char",
          "*\nDPPP_(my_sv_2pv_flags)(pTHX_ SV *sv, STRLEN *lp, I32 flags)",
          "*"
        ]
      },
      {
        "start_point": [
          5149,
          0
        ],
        "end_point": [
          5154,
          1
        ],
        "content": "char *\nDPPP_(my_sv_pvn_force_flags)(pTHX_ SV *sv, STRLEN *lp, I32 flags)\n{\n  STRLEN n_a = (STRLEN) flags;\n  return sv_pvn_force(sv, lp ? lp : &n_a);\n}",
        "lines": 6,
        "depth": 8,
        "decorators": [
          "char",
          "*\nDPPP_(my_sv_pvn_force_flags)(pTHX_ SV *sv, STRLEN *lp, I32 flags)",
          "*"
        ]
      },
      {
        "start_point": [
          5330,
          0
        ],
        "end_point": [
          5336,
          1
        ],
        "content": "SV *\nDPPP_(my_vnewSVpvf)(pTHX_ const char *pat, va_list *args)\n{\n  register SV *sv = newSV(0);\n  sv_vsetpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*));\n  return sv;\n}",
        "lines": 7,
        "depth": 10,
        "decorators": [
          "SV",
          "*\nDPPP_(my_vnewSVpvf)(pTHX_ const char *pat, va_list *args)",
          "*"
        ]
      },
      {
        "start_point": [
          5361,
          0
        ],
        "end_point": [
          5369,
          1
        ],
        "content": "void\nDPPP_(my_sv_catpvf_mg)(pTHX_ SV *sv, const char *pat, ...)\n{\n  va_list args;\n  va_start(args, pat);\n  sv_vcatpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));\n  SvSETMAGIC(sv);\n  va_end(args);\n}",
        "lines": 9,
        "depth": 10,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          5388,
          0
        ],
        "end_point": [
          5397,
          1
        ],
        "content": "void\nDPPP_(my_sv_catpvf_mg_nocontext)(SV *sv, const char *pat, ...)\n{\n  dTHX;\n  va_list args;\n  va_start(args, pat);\n  sv_vcatpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));\n  SvSETMAGIC(sv);\n  va_end(args);\n}",
        "lines": 10,
        "depth": 10,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          5432,
          0
        ],
        "end_point": [
          5440,
          1
        ],
        "content": "void\nDPPP_(my_sv_setpvf_mg)(pTHX_ SV *sv, const char *pat, ...)\n{\n  va_list args;\n  va_start(args, pat);\n  sv_vsetpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));\n  SvSETMAGIC(sv);\n  va_end(args);\n}",
        "lines": 9,
        "depth": 10,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          5459,
          0
        ],
        "end_point": [
          5468,
          1
        ],
        "content": "void\nDPPP_(my_sv_setpvf_mg_nocontext)(SV *sv, const char *pat, ...)\n{\n  dTHX;\n  va_list args;\n  va_start(args, pat);\n  sv_vsetpvfn(sv, pat, strlen(pat), &args, Null(SV**), 0, Null(bool*));\n  SvSETMAGIC(sv);\n  va_end(args);\n}",
        "lines": 10,
        "depth": 10,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          5514,
          0
        ],
        "end_point": [
          5528,
          1
        ],
        "content": "SV *\nDPPP_(my_newSVpvn_share)(pTHX_ const char *src, I32 len, U32 hash)\n{\n  SV *sv;\n  if (len < 0)\n    len = -len;\n  if (!hash)\n    PERL_HASH(hash, (char*) src, len);\n  sv = newSVpvn((char *) src, len);\n  sv_upgrade(sv, SVt_PVIV);\n  SvIVX(sv) = hash;\n  SvREADONLY_on(sv);\n  SvPOK_on(sv);\n  return sv;\n}",
        "lines": 15,
        "depth": 10,
        "decorators": [
          "SV",
          "*\nDPPP_(my_newSVpvn_share)(pTHX_ const char *src, I32 len, U32 hash)",
          "*"
        ]
      },
      {
        "start_point": [
          5771,
          0
        ],
        "end_point": [
          5784,
          1
        ],
        "content": "void\nDPPP_(my_warner)(U32 err, const char *pat, ...)\n{\n  SV *sv;\n  va_list args;\n\n  PERL_UNUSED_ARG(err);\n\n  va_start(args, pat);\n  sv = vnewSVpvf(pat, &args);\n  va_end(args);\n  sv_2mortal(sv);\n  warn(\"%s\", SvPV_nolen(sv));\n}",
        "lines": 14,
        "depth": 8,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          6316,
          0
        ],
        "end_point": [
          6353,
          1
        ],
        "content": "bool\nDPPP_(my_grok_numeric_radix)(pTHX_ const char **sp, const char *send)\n{\n#ifdef USE_LOCALE_NUMERIC\n#ifdef PL_numeric_radix_sv\n    if (PL_numeric_radix_sv && IN_LOCALE) {\n        STRLEN len;\n        char* radix = SvPV(PL_numeric_radix_sv, len);\n        if (*sp + len <= send && memEQ(*sp, radix, len)) {\n            *sp += len;\n            return TRUE;\n        }\n    }\n#else\n    /* older perls don't have PL_numeric_radix_sv so the radix\n     * must manually be requested from locale.h\n     */\n#include <locale.h>\n    dTHR;  /* needed for older threaded perls */\n    struct lconv *lc = localeconv();\n    char *radix = lc->decimal_point;\n    if (radix && IN_LOCALE) {\n        STRLEN len = strlen(radix);\n        if (*sp + len <= send && memEQ(*sp, radix, len)) {\n            *sp += len;\n            return TRUE;\n        }\n    }\n#endif\n#endif /* USE_LOCALE_NUMERIC */\n    /* always try \".\" if numeric radix didn't match because\n     * we may have data from different locales mixed */\n    if (*sp < send && **sp == '.') {\n        ++*sp;\n        return TRUE;\n    }\n    return FALSE;\n}",
        "lines": 38,
        "depth": 14,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          6372,
          0
        ],
        "end_point": [
          6561,
          1
        ],
        "content": "int\nDPPP_(my_grok_number)(pTHX_ const char *pv, STRLEN len, UV *valuep)\n{\n  const char *s = pv;\n  const char *send = pv + len;\n  const UV max_div_10 = UV_MAX / 10;\n  const char max_mod_10 = UV_MAX % 10;\n  int numtype = 0;\n  int sawinf = 0;\n  int sawnan = 0;\n\n  while (s < send && isSPACE(*s))\n    s++;\n  if (s == send) {\n    return 0;\n  } else if (*s == '-') {\n    s++;\n    numtype = IS_NUMBER_NEG;\n  }\n  else if (*s == '+')\n  s++;\n\n  if (s == send)\n    return 0;\n\n  /* next must be digit or the radix separator or beginning of infinity */\n  if (isDIGIT(*s)) {\n    /* UVs are at least 32 bits, so the first 9 decimal digits cannot\n       overflow.  */\n    UV value = *s - '0';\n    /* This construction seems to be more optimiser friendly.\n       (without it gcc does the isDIGIT test and the *s - '0' separately)\n       With it gcc on arm is managing 6 instructions (6 cycles) per digit.\n       In theory the optimiser could deduce how far to unroll the loop\n       before checking for overflow.  */\n    if (++s < send) {\n      int digit = *s - '0';\n      if (digit >= 0 && digit <= 9) {\n        value = value * 10 + digit;\n        if (++s < send) {\n          digit = *s - '0';\n          if (digit >= 0 && digit <= 9) {\n            value = value * 10 + digit;\n            if (++s < send) {\n              digit = *s - '0';\n              if (digit >= 0 && digit <= 9) {\n                value = value * 10 + digit;\n\t\tif (++s < send) {\n                  digit = *s - '0';\n                  if (digit >= 0 && digit <= 9) {\n                    value = value * 10 + digit;\n                    if (++s < send) {\n                      digit = *s - '0';\n                      if (digit >= 0 && digit <= 9) {\n                        value = value * 10 + digit;\n                        if (++s < send) {\n                          digit = *s - '0';\n                          if (digit >= 0 && digit <= 9) {\n                            value = value * 10 + digit;\n                            if (++s < send) {\n                              digit = *s - '0';\n                              if (digit >= 0 && digit <= 9) {\n                                value = value * 10 + digit;\n                                if (++s < send) {\n                                  digit = *s - '0';\n                                  if (digit >= 0 && digit <= 9) {\n                                    value = value * 10 + digit;\n                                    if (++s < send) {\n                                      /* Now got 9 digits, so need to check\n                                         each time for overflow.  */\n                                      digit = *s - '0';\n                                      while (digit >= 0 && digit <= 9\n                                             && (value < max_div_10\n                                                 || (value == max_div_10\n                                                     && digit <= max_mod_10))) {\n                                        value = value * 10 + digit;\n                                        if (++s < send)\n                                          digit = *s - '0';\n                                        else\n                                          break;\n                                      }\n                                      if (digit >= 0 && digit <= 9\n                                          && (s < send)) {\n                                        /* value overflowed.\n                                           skip the remaining digits, don't\n                                           worry about setting *valuep.  */\n                                        do {\n                                          s++;\n                                        } while (s < send && isDIGIT(*s));\n                                        numtype |=\n                                          IS_NUMBER_GREATER_THAN_UV_MAX;\n                                        goto skip_value;\n                                      }\n                                    }\n                                  }\n\t\t\t\t}\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n\t}\n      }\n    }\n    numtype |= IS_NUMBER_IN_UV;\n    if (valuep)\n      *valuep = value;\n\n  skip_value:\n    if (GROK_NUMERIC_RADIX(&s, send)) {\n      numtype |= IS_NUMBER_NOT_INT;\n      while (s < send && isDIGIT(*s))  /* optional digits after the radix */\n        s++;\n    }\n  }\n  else if (GROK_NUMERIC_RADIX(&s, send)) {\n    numtype |= IS_NUMBER_NOT_INT | IS_NUMBER_IN_UV; /* valuep assigned below */\n    /* no digits before the radix means we need digits after it */\n    if (s < send && isDIGIT(*s)) {\n      do {\n        s++;\n      } while (s < send && isDIGIT(*s));\n      if (valuep) {\n        /* integer approximation is valid - it's 0.  */\n        *valuep = 0;\n      }\n    }\n    else\n      return 0;\n  } else if (*s == 'I' || *s == 'i') {\n    s++; if (s == send || (*s != 'N' && *s != 'n')) return 0;\n    s++; if (s == send || (*s != 'F' && *s != 'f')) return 0;\n    s++; if (s < send && (*s == 'I' || *s == 'i')) {\n      s++; if (s == send || (*s != 'N' && *s != 'n')) return 0;\n      s++; if (s == send || (*s != 'I' && *s != 'i')) return 0;\n      s++; if (s == send || (*s != 'T' && *s != 't')) return 0;\n      s++; if (s == send || (*s != 'Y' && *s != 'y')) return 0;\n      s++;\n    }\n    sawinf = 1;\n  } else if (*s == 'N' || *s == 'n') {\n    /* XXX TODO: There are signaling NaNs and quiet NaNs. */\n    s++; if (s == send || (*s != 'A' && *s != 'a')) return 0;\n    s++; if (s == send || (*s != 'N' && *s != 'n')) return 0;\n    s++;\n    sawnan = 1;\n  } else\n    return 0;\n\n  if (sawinf) {\n    numtype &= IS_NUMBER_NEG; /* Keep track of sign  */\n    numtype |= IS_NUMBER_INFINITY | IS_NUMBER_NOT_INT;\n  } else if (sawnan) {\n    numtype &= IS_NUMBER_NEG; /* Keep track of sign  */\n    numtype |= IS_NUMBER_NAN | IS_NUMBER_NOT_INT;\n  } else if (s < send) {\n    /* we can have an optional exponent part */\n    if (*s == 'e' || *s == 'E') {\n      /* The only flag we keep is sign.  Blow away any \"it's UV\"  */\n      numtype &= IS_NUMBER_NEG;\n      numtype |= IS_NUMBER_NOT_INT;\n      s++;\n      if (s < send && (*s == '-' || *s == '+'))\n        s++;\n      if (s < send && isDIGIT(*s)) {\n        do {\n          s++;\n        } while (s < send && isDIGIT(*s));\n      }\n      else\n      return 0;\n    }\n  }\n  while (s < send && isSPACE(*s))\n    s++;\n  if (s >= send)\n    return numtype;\n  if (len == 10 && memEQ(pv, \"0 but true\", 10)) {\n    if (valuep)\n      *valuep = 0;\n    return IS_NUMBER_IN_UV;\n  }\n  return 0;\n}",
        "lines": 190,
        "depth": 47,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          6586,
          0
        ],
        "end_point": [
          6669,
          1
        ],
        "content": "UV\nDPPP_(my_grok_bin)(pTHX_ const char *start, STRLEN *len_p, I32 *flags, NV *result)\n{\n    const char *s = start;\n    STRLEN len = *len_p;\n    UV value = 0;\n    NV value_nv = 0;\n\n    const UV max_div_2 = UV_MAX / 2;\n    bool allow_underscores = *flags & PERL_SCAN_ALLOW_UNDERSCORES;\n    bool overflowed = FALSE;\n\n    if (!(*flags & PERL_SCAN_DISALLOW_PREFIX)) {\n        /* strip off leading b or 0b.\n           for compatibility silently suffer \"b\" and \"0b\" as valid binary\n           numbers. */\n        if (len >= 1) {\n            if (s[0] == 'b') {\n                s++;\n                len--;\n            }\n            else if (len >= 2 && s[0] == '0' && s[1] == 'b') {\n                s+=2;\n                len-=2;\n            }\n        }\n    }\n\n    for (; len-- && *s; s++) {\n        char bit = *s;\n        if (bit == '0' || bit == '1') {\n            /* Write it in this wonky order with a goto to attempt to get the\n               compiler to make the common case integer-only loop pretty tight.\n               With gcc seems to be much straighter code than old scan_bin.  */\n          redo:\n            if (!overflowed) {\n                if (value <= max_div_2) {\n                    value = (value << 1) | (bit - '0');\n                    continue;\n                }\n                /* Bah. We're just overflowed.  */\n                warn(\"Integer overflow in binary number\");\n                overflowed = TRUE;\n                value_nv = (NV) value;\n            }\n            value_nv *= 2.0;\n\t    /* If an NV has not enough bits in its mantissa to\n\t     * represent a UV this summing of small low-order numbers\n\t     * is a waste of time (because the NV cannot preserve\n\t     * the low-order bits anyway): we could just remember when\n\t     * did we overflow and in the end just multiply value_nv by the\n\t     * right amount. */\n            value_nv += (NV)(bit - '0');\n            continue;\n        }\n        if (bit == '_' && len && allow_underscores && (bit = s[1])\n            && (bit == '0' || bit == '1'))\n\t    {\n\t\t--len;\n\t\t++s;\n                goto redo;\n\t    }\n        if (!(*flags & PERL_SCAN_SILENT_ILLDIGIT))\n            warn(\"Illegal binary digit '%c' ignored\", *s);\n        break;\n    }\n\n    if (   ( overflowed && value_nv > 4294967295.0)\n#if UVSIZE > 4\n\t|| (!overflowed && value > 0xffffffff  )\n#endif\n\t) {\n\twarn(\"Binary number > 0b11111111111111111111111111111111 non-portable\");\n    }\n    *len_p = s - start;\n    if (!overflowed) {\n        *flags = 0;\n        return value;\n    }\n    *flags = PERL_SCAN_GREATER_THAN_UV_MAX;\n    if (result)\n        *result = value_nv;\n    return UV_MAX;\n}",
        "lines": 84,
        "depth": 18,
        "decorators": [
          "UV"
        ]
      },
      {
        "start_point": [
          6688,
          0
        ],
        "end_point": [
          6771,
          1
        ],
        "content": "UV\nDPPP_(my_grok_hex)(pTHX_ const char *start, STRLEN *len_p, I32 *flags, NV *result)\n{\n    const char *s = start;\n    STRLEN len = *len_p;\n    UV value = 0;\n    NV value_nv = 0;\n\n    const UV max_div_16 = UV_MAX / 16;\n    bool allow_underscores = *flags & PERL_SCAN_ALLOW_UNDERSCORES;\n    bool overflowed = FALSE;\n    const char *xdigit;\n\n    if (!(*flags & PERL_SCAN_DISALLOW_PREFIX)) {\n        /* strip off leading x or 0x.\n           for compatibility silently suffer \"x\" and \"0x\" as valid hex numbers.\n        */\n        if (len >= 1) {\n            if (s[0] == 'x') {\n                s++;\n                len--;\n            }\n            else if (len >= 2 && s[0] == '0' && s[1] == 'x') {\n                s+=2;\n                len-=2;\n            }\n        }\n    }\n\n    for (; len-- && *s; s++) {\n\txdigit = strchr((char *) PL_hexdigit, *s);\n        if (xdigit) {\n            /* Write it in this wonky order with a goto to attempt to get the\n               compiler to make the common case integer-only loop pretty tight.\n               With gcc seems to be much straighter code than old scan_hex.  */\n          redo:\n            if (!overflowed) {\n                if (value <= max_div_16) {\n                    value = (value << 4) | ((xdigit - PL_hexdigit) & 15);\n                    continue;\n                }\n                warn(\"Integer overflow in hexadecimal number\");\n                overflowed = TRUE;\n                value_nv = (NV) value;\n            }\n            value_nv *= 16.0;\n\t    /* If an NV has not enough bits in its mantissa to\n\t     * represent a UV this summing of small low-order numbers\n\t     * is a waste of time (because the NV cannot preserve\n\t     * the low-order bits anyway): we could just remember when\n\t     * did we overflow and in the end just multiply value_nv by the\n\t     * right amount of 16-tuples. */\n            value_nv += (NV)((xdigit - PL_hexdigit) & 15);\n            continue;\n        }\n        if (*s == '_' && len && allow_underscores && s[1]\n\t\t&& (xdigit = strchr((char *) PL_hexdigit, s[1])))\n\t    {\n\t\t--len;\n\t\t++s;\n                goto redo;\n\t    }\n        if (!(*flags & PERL_SCAN_SILENT_ILLDIGIT))\n            warn(\"Illegal hexadecimal digit '%c' ignored\", *s);\n        break;\n    }\n\n    if (   ( overflowed && value_nv > 4294967295.0)\n#if UVSIZE > 4\n\t|| (!overflowed && value > 0xffffffff  )\n#endif\n\t) {\n\twarn(\"Hexadecimal number > 0xffffffff non-portable\");\n    }\n    *len_p = s - start;\n    if (!overflowed) {\n        *flags = 0;\n        return value;\n    }\n    *flags = PERL_SCAN_GREATER_THAN_UV_MAX;\n    if (result)\n        *result = value_nv;\n    return UV_MAX;\n}",
        "lines": 84,
        "depth": 19,
        "decorators": [
          "UV"
        ]
      },
      {
        "start_point": [
          6790,
          0
        ],
        "end_point": [
          6864,
          1
        ],
        "content": "UV\nDPPP_(my_grok_oct)(pTHX_ const char *start, STRLEN *len_p, I32 *flags, NV *result)\n{\n    const char *s = start;\n    STRLEN len = *len_p;\n    UV value = 0;\n    NV value_nv = 0;\n\n    const UV max_div_8 = UV_MAX / 8;\n    bool allow_underscores = *flags & PERL_SCAN_ALLOW_UNDERSCORES;\n    bool overflowed = FALSE;\n\n    for (; len-- && *s; s++) {\n         /* gcc 2.95 optimiser not smart enough to figure that this subtraction\n            out front allows slicker code.  */\n        int digit = *s - '0';\n        if (digit >= 0 && digit <= 7) {\n            /* Write it in this wonky order with a goto to attempt to get the\n               compiler to make the common case integer-only loop pretty tight.\n            */\n          redo:\n            if (!overflowed) {\n                if (value <= max_div_8) {\n                    value = (value << 3) | digit;\n                    continue;\n                }\n                /* Bah. We're just overflowed.  */\n                warn(\"Integer overflow in octal number\");\n                overflowed = TRUE;\n                value_nv = (NV) value;\n            }\n            value_nv *= 8.0;\n\t    /* If an NV has not enough bits in its mantissa to\n\t     * represent a UV this summing of small low-order numbers\n\t     * is a waste of time (because the NV cannot preserve\n\t     * the low-order bits anyway): we could just remember when\n\t     * did we overflow and in the end just multiply value_nv by the\n\t     * right amount of 8-tuples. */\n            value_nv += (NV)digit;\n            continue;\n        }\n        if (digit == ('_' - '0') && len && allow_underscores\n            && (digit = s[1] - '0') && (digit >= 0 && digit <= 7))\n\t    {\n\t\t--len;\n\t\t++s;\n                goto redo;\n\t    }\n        /* Allow \\octal to work the DWIM way (that is, stop scanning\n         * as soon as non-octal characters are seen, complain only iff\n         * someone seems to want to use the digits eight and nine). */\n        if (digit == 8 || digit == 9) {\n            if (!(*flags & PERL_SCAN_SILENT_ILLDIGIT))\n                warn(\"Illegal octal digit '%c' ignored\", *s);\n        }\n        break;\n    }\n\n    if (   ( overflowed && value_nv > 4294967295.0)\n#if UVSIZE > 4\n\t|| (!overflowed && value > 0xffffffff  )\n#endif\n\t) {\n\twarn(\"Octal number > 037777777777 non-portable\");\n    }\n    *len_p = s - start;\n    if (!overflowed) {\n        *flags = 0;\n        return value;\n    }\n    *flags = PERL_SCAN_GREATER_THAN_UV_MAX;\n    if (result)\n        *result = value_nv;\n    return UV_MAX;\n}",
        "lines": 75,
        "depth": 17,
        "decorators": [
          "UV"
        ]
      },
      {
        "start_point": [
          6881,
          0
        ],
        "end_point": [
          6897,
          1
        ],
        "content": "int\nDPPP_(my_my_snprintf)(char *buffer, const Size_t len, const char *format, ...)\n{\n    dTHX;\n    int retval;\n    va_list ap;\n    va_start(ap, format);\n#ifdef HAS_VSNPRINTF\n    retval = vsnprintf(buffer, len, format, ap);\n#else\n    retval = vsprintf(buffer, format, ap);\n#endif\n    va_end(ap);\n    if (retval < 0 || (len > 0 && (Size_t)retval >= len))\n\tPerl_croak(aTHX_ \"panic: my_snprintf buffer overflow\");\n    return retval;\n}",
        "lines": 17,
        "depth": 11,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          6915,
          0
        ],
        "end_point": [
          6923,
          1
        ],
        "content": "int\nDPPP_(my_my_sprintf)(char *buffer, const char* pat, ...)\n{\n    va_list args;\n    va_start(args, pat);\n    vsprintf(buffer, pat, args);\n    va_end(args);\n    return strlen(buffer);\n}",
        "lines": 9,
        "depth": 6,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          6957,
          0
        ],
        "end_point": [
          6970,
          1
        ],
        "content": "Size_t\nDPPP_(my_my_strlcat)(char *dst, const char *src, Size_t size)\n{\n    Size_t used, length, copy;\n\n    used = strlen(dst);\n    length = strlen(src);\n    if (size > 0 && used < size - 1) {\n        copy = (length >= size - used) ? size - used - 1 : length;\n        memcpy(dst + used, src, copy);\n        dst[used + copy] = '\\0';\n    }\n    return used + length;\n}",
        "lines": 14,
        "depth": 11,
        "decorators": [
          "Size_t"
        ]
      },
      {
        "start_point": [
          6987,
          0
        ],
        "end_point": [
          6999,
          1
        ],
        "content": "Size_t\nDPPP_(my_my_strlcpy)(char *dst, const char *src, Size_t size)\n{\n    Size_t length, copy;\n\n    length = strlen(src);\n    if (size > 0) {\n        copy = (length >= size) ? size - 1 : length;\n        memcpy(dst, src, copy);\n        dst[copy] = '\\0';\n    }\n    return length;\n}",
        "lines": 13,
        "depth": 10,
        "decorators": [
          "Size_t"
        ]
      },
      {
        "start_point": [
          7080,
          0
        ],
        "end_point": [
          7168,
          1
        ],
        "content": "char *\nDPPP_(my_pv_escape)(pTHX_ SV *dsv, char const * const str,\n  const STRLEN count, const STRLEN max,\n  STRLEN * const escaped, const U32 flags)\n{\n    const char esc = flags & PERL_PV_ESCAPE_RE ? '%' : '\\\\';\n    const char dq = flags & PERL_PV_ESCAPE_QUOTE ? '\"' : esc;\n    char octbuf[32] = \"%123456789ABCDF\";\n    STRLEN wrote = 0;\n    STRLEN chsize = 0;\n    STRLEN readsize = 1;\n#if defined(is_utf8_string) && defined(utf8_to_uvchr)\n    bool isuni = flags & PERL_PV_ESCAPE_UNI ? 1 : 0;\n#endif\n    const char *pv  = str;\n    const char * const end = pv + count;\n    octbuf[0] = esc;\n\n    if (!(flags & PERL_PV_ESCAPE_NOCLEAR))\n\tsv_setpvs(dsv, \"\");\n\n#if defined(is_utf8_string) && defined(utf8_to_uvchr)\n    if ((flags & PERL_PV_ESCAPE_UNI_DETECT) && is_utf8_string((U8*)pv, count))\n        isuni = 1;\n#endif\n\n    for (; pv < end && (!max || wrote < max) ; pv += readsize) {\n        const UV u =\n#if defined(is_utf8_string) && defined(utf8_to_uvchr)\n\t\t     isuni ? utf8_to_uvchr((U8*)pv, &readsize) :\n#endif\n\t\t\t     (U8)*pv;\n        const U8 c = (U8)u & 0xFF;\n\n        if (u > 255 || (flags & PERL_PV_ESCAPE_ALL)) {\n            if (flags & PERL_PV_ESCAPE_FIRSTCHAR)\n                chsize = my_snprintf(octbuf, sizeof octbuf,\n                                      \"%\"UVxf, u);\n            else\n                chsize = my_snprintf(octbuf, sizeof octbuf,\n                                      \"%cx{%\"UVxf\"}\", esc, u);\n        } else if (flags & PERL_PV_ESCAPE_NOBACKSLASH) {\n            chsize = 1;\n        } else {\n            if (c == dq || c == esc || !isPRINT(c)) {\n\t        chsize = 2;\n                switch (c) {\n\t\tcase '\\\\' : /* fallthrough */\n\t\tcase '%'  : if (c == esc)\n\t\t                octbuf[1] = esc;\n\t\t            else\n\t\t                chsize = 1;\n\t\t            break;\n\t\tcase '\\v' : octbuf[1] = 'v'; break;\n\t\tcase '\\t' : octbuf[1] = 't'; break;\n\t\tcase '\\r' : octbuf[1] = 'r'; break;\n\t\tcase '\\n' : octbuf[1] = 'n'; break;\n\t\tcase '\\f' : octbuf[1] = 'f'; break;\n                case '\"'  : if (dq == '\"')\n\t\t\t\toctbuf[1] = '\"';\n\t\t\t    else\n\t\t\t\tchsize = 1;\n\t\t\t    break;\n\t\tdefault:    chsize = my_snprintf(octbuf, sizeof octbuf,\n\t\t\t\tpv < end && isDIGIT((U8)*(pv+readsize))\n\t\t\t\t? \"%c%03o\" : \"%c%o\", esc, c);\n                }\n            } else {\n                chsize = 1;\n            }\n\t}\n\tif (max && wrote + chsize > max) {\n\t    break;\n        } else if (chsize > 1) {\n            sv_catpvn(dsv, octbuf, chsize);\n            wrote += chsize;\n\t} else {\n\t    char tmp[2];\n\t    my_snprintf(tmp, sizeof tmp, \"%c\", c);\n            sv_catpvn(dsv, tmp, 1);\n\t    wrote++;\n\t}\n        if (flags & PERL_PV_ESCAPE_FIRSTCHAR)\n            break;\n    }\n    if (escaped != NULL)\n        *escaped= pv - str;\n    return SvPVX(dsv);\n}",
        "lines": 89,
        "depth": 25,
        "decorators": [
          "char",
          "*\nDPPP_(my_pv_escape)(pTHX_ SV *dsv, char const * const str,\n  const STRLEN count, const STRLEN max,\n  STRLEN * const escaped, const U32 flags)",
          "*"
        ]
      },
      {
        "start_point": [
          7189,
          0
        ],
        "end_point": [
          7222,
          1
        ],
        "content": "char *\nDPPP_(my_pv_pretty)(pTHX_ SV *dsv, char const * const str, const STRLEN count,\n  const STRLEN max, char const * const start_color, char const * const end_color,\n  const U32 flags)\n{\n    const U8 dq = (flags & PERL_PV_PRETTY_QUOTE) ? '\"' : '%';\n    STRLEN escaped;\n\n    if (!(flags & PERL_PV_PRETTY_NOCLEAR))\n\tsv_setpvs(dsv, \"\");\n\n    if (dq == '\"')\n        sv_catpvs(dsv, \"\\\"\");\n    else if (flags & PERL_PV_PRETTY_LTGT)\n        sv_catpvs(dsv, \"<\");\n\n    if (start_color != NULL)\n        sv_catpv(dsv, D_PPP_CONSTPV_ARG(start_color));\n\n    pv_escape(dsv, str, count, max, &escaped, flags | PERL_PV_ESCAPE_NOCLEAR);\n\n    if (end_color != NULL)\n        sv_catpv(dsv, D_PPP_CONSTPV_ARG(end_color));\n\n    if (dq == '\"')\n\tsv_catpvs(dsv, \"\\\"\");\n    else if (flags & PERL_PV_PRETTY_LTGT)\n        sv_catpvs(dsv, \">\");\n\n    if ((flags & PERL_PV_PRETTY_ELLIPSES) && escaped < count)\n\tsv_catpvs(dsv, \"...\");\n\n    return SvPVX(dsv);\n}",
        "lines": 34,
        "depth": 9,
        "decorators": [
          "char",
          "*\nDPPP_(my_pv_pretty)(pTHX_ SV *dsv, char const * const str, const STRLEN count,\n  const STRLEN max, char const * const start_color, char const * const end_color,\n  const U32 flags)",
          "*"
        ]
      },
      {
        "start_point": [
          7243,
          0
        ],
        "end_point": [
          7250,
          1
        ],
        "content": "char *\nDPPP_(my_pv_display)(pTHX_ SV *dsv, const char *pv, STRLEN cur, STRLEN len, STRLEN pvlim)\n{\n    pv_pretty(dsv, pv, cur, pvlim, NULL, NULL, PERL_PV_PRETTY_DUMP);\n    if (len > cur && pv[cur] == '\\0')\n\tsv_catpvs(dsv, \"\\\\0\");\n    return SvPVX(dsv);\n}",
        "lines": 8,
        "depth": 8,
        "decorators": [
          "char",
          "*\nDPPP_(my_pv_display)(pTHX_ SV *dsv, const char *pv, STRLEN cur, STRLEN len, STRLEN pvlim)",
          "*"
        ]
      }
    ]
  }
}