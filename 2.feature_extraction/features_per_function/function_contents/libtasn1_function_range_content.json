{
  "libtasn1/libtasn1-4.13/build-aux/snippet/arg-nonnull.h": {},
  "libtasn1/libtasn1-4.13/build-aux/snippet/c++defs.h": {},
  "libtasn1/libtasn1-4.13/build-aux/snippet/warn-on-use.h": {},
  "libtasn1/libtasn1-4.13/build-aux/snippet/_Noreturn.h": {},
  "libtasn1/libtasn1-4.13/examples/CertificateExample.c": {
    "my_ltostr": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "static char *\nmy_ltostr (long v, char *str)\n{\n  long d, r;\n  char temp[20];\n  int count, k, start;\n\n  if (v < 0)\n    {\n      str[0] = '-';\n      start = 1;\n      v = -v;\n    }\n  else\n    start = 0;\n\n  count = 0;\n  do\n    {\n      d = v / 10;\n      r = v - d * 10;\n      temp[start + count] = '0' + (char) r;\n      count++;\n      v = d;\n    }\n  while (v);\n\n  for (k = 0; k < count; k++)\n    str[k + start] = temp[start + count - k - 1];\n  str[count + start] = 0;\n  return str;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nmy_ltostr (long v, char *str)",
        "*"
      ]
    },
    "get_Name_type": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "static void\nget_Name_type (ASN1_TYPE cert_def, ASN1_TYPE cert, const char *root,\n\t       unsigned char *ans)\n{\n  int k, k2, result, len;\n  char name[128], str[1024], str2[1024], name2[128], counter[5], name3[128];\n  ASN1_TYPE value = ASN1_TYPE_EMPTY;\n  char errorDescription[ASN1_MAX_ERROR_DESCRIPTION_SIZE];\n  char *answer = (char *) ans;\n  answer[0] = 0;\n  k = 1;\n  do\n    {\n      strcpy (name, root);\n      strcat (name, \".rdnSequence.?\");\n      my_ltostr (k, counter);\n      strcat (name, counter);\n      len = sizeof (str) - 1;\n      result = asn1_read_value (cert, name, str, &len);\n      if (result == ASN1_ELEMENT_NOT_FOUND)\n\tbreak;\n      k2 = 1;\n      do\n\t{\n\t  strcpy (name2, name);\n\t  strcat (name2, \".?\");\n\t  my_ltostr (k2, counter);\n\t  strcat (name2, counter);\n\t  len = sizeof (str) - 1;\n\t  result = asn1_read_value (cert, name2, str, &len);\n\t  if (result == ASN1_ELEMENT_NOT_FOUND)\n\t    break;\n\t  strcpy (name3, name2);\n\t  strcat (name3, \".type\");\n\t  len = sizeof (str) - 1;\n\t  result = asn1_read_value (cert, name3, str, &len);\n\t  strcpy (name3, name2);\n\t  strcat (name3, \".value\");\n\t  if (result == ASN1_SUCCESS)\n\t    {\n\t      len = sizeof (str2) - 1;\n\t      result =\n\t\tasn1_read_value (cert_def,\n\t\t\t\t \"PKIX1Implicit88.id-at-countryName\", str2,\n\t\t\t\t &len);\n\t      if (!strcmp (str, str2))\n\t\t{\n\t\t  asn1_create_element (cert_def,\n\t\t\t\t       \"PKIX1Implicit88.X520OrganizationName\",\n\t\t\t\t       &value);\n\t\t  len = sizeof (str) - 1;\n\t\t  asn1_read_value (cert, name3, str, &len);\n\t\t  asn1_der_decoding (&value, str, len, errorDescription);\n\t\t  len = sizeof (str) - 1;\n\t\t  asn1_read_value (value, \"\", str, &len);\t/* CHOICE */\n\t\t  strcpy (name3, str);\n\t\t  len = sizeof (str) - 1;\n\t\t  asn1_read_value (value, name3, str, &len);\n\t\t  str[len] = 0;\n\t\t  strcat (answer, \" C=\");\n\t\t  strcat (answer, str);\n\t\t  asn1_delete_structure (&value);\n\t\t}\n\t      else\n\t\t{\n\t\t  len = sizeof (str2) - 1;\n\t\t  result =\n\t\t    asn1_read_value (cert_def,\n\t\t\t\t     \"PKIX1Implicit88.id-at-organizationName\",\n\t\t\t\t     str2, &len);\n\t\t  if (!strcmp (str, str2))\n\t\t    {\n\t\t      asn1_create_element (cert_def,\n\t\t\t\t\t   \"PKIX1Implicit88.X520OrganizationName\",\n\t\t\t\t\t   &value);\n\t\t      len = sizeof (str) - 1;\n\t\t      asn1_read_value (cert, name3, str, &len);\n\t\t      asn1_der_decoding (&value, str, len, errorDescription);\n\t\t      len = sizeof (str) - 1;\n\t\t      asn1_read_value (value, \"\", str, &len);\t/* CHOICE */\n\t\t      strcpy (name3, str);\n\t\t      len = sizeof (str) - 1;\n\t\t      asn1_read_value (value, name3, str, &len);\n\t\t      str[len] = 0;\n\t\t      strcat (answer, \" O=\");\n\t\t      strcat (answer, str);\n\t\t      asn1_delete_structure (&value);\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      len = sizeof (str2) - 1;\n\t\t      result =\n\t\t\tasn1_read_value (cert_def,\n\t\t\t\t\t \"PKIX1Implicit88.id-at-organizationalUnitName\",\n\t\t\t\t\t str2, &len);\n\t\t      if (!strcmp (str, str2))\n\t\t\t{\n\t\t\t  asn1_create_element (cert_def,\n\t\t\t\t\t       \"PKIX1Implicit88.X520OrganizationalUnitName\",\n\t\t\t\t\t       &value);\n\t\t\t  len = sizeof (str) - 1;\n\t\t\t  asn1_read_value (cert, name3, str, &len);\n\t\t\t  asn1_der_decoding (&value, str, len,\n\t\t\t\t\t     errorDescription);\n\t\t\t  len = sizeof (str) - 1;\n\t\t\t  asn1_read_value (value, \"\", str, &len);\t/* CHOICE */\n\t\t\t  strcpy (name3, str);\n\t\t\t  len = sizeof (str) - 1;\n\t\t\t  asn1_read_value (value, name3, str, &len);\n\t\t\t  str[len] = 0;\n\t\t\t  strcat (answer, \" OU=\");\n\t\t\t  strcat (answer, str);\n\t\t\t  asn1_delete_structure (&value);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t  k2++;\n\t}\n      while (1);\n      k++;\n    }\n  while (1);\n}",
      "lines": 124,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_certificate": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        554,
        1
      ],
      "content": "static void\ncreate_certificate (ASN1_TYPE cert_def, unsigned char *der, int *der_len)\n{\n  int result, k, len;\n  unsigned char str[1024];\n  const unsigned char *str2;\n  ASN1_TYPE cert1 = ASN1_TYPE_EMPTY;\n  ASN1_TYPE value = ASN1_TYPE_EMPTY;\n  ASN1_TYPE param = ASN1_TYPE_EMPTY;\n  ASN1_TYPE constr = ASN1_TYPE_EMPTY;\n  char errorDescription[ASN1_MAX_ERROR_DESCRIPTION_SIZE];\n  int max_len;\n\n  max_len = *der_len;\n\n  result =\n    asn1_create_element (cert_def, \"PKIX1Implicit88.Certificate\", &cert1);\n\n  /* Use the next 3 lines to visit the empty certificate */\n  /* printf(\"-----------------\\n\");\n     asn1_visit_tree(cert1,\"\");\n     printf(\"-----------------\\n\"); */\n\n  /* version: v3(2) */\n  result = asn1_write_value (cert1, \"tbsCertificate.version\", \"v3\", 0);\n\n  /* serialNumber: 17 */\n  result = asn1_write_value (cert1, \"tbsCertificate.serialNumber\", \"17\", 0);\n\n  /* signature: dsa-with-sha1 */\n  len = sizeof (str) - 1;\n  result =\n    asn1_read_value (cert_def, \"PKIX1Implicit88.id-dsa-with-sha1\", str, &len);\n  result =\n    asn1_write_value (cert1, \"tbsCertificate.signature.algorithm\", str, 1);\n\n  result = asn1_write_value (cert1, \"tbsCertificate.signature.parameters\",\n\t\t\t     NULL, 0);\n\n\n  /* issuer: Country=\"US\" Organization=\"gov\" OrganizationUnit=\"nist\" */\n  result =\n    asn1_write_value (cert1, \"tbsCertificate.issuer\", \"rdnSequence\", 12);\n\n  result =\n    asn1_write_value (cert1, \"tbsCertificate.issuer.rdnSequence\", \"NEW\", 1);\n  result =\n    asn1_write_value (cert1, \"tbsCertificate.issuer.rdnSequence.?LAST\", \"NEW\",\n\t\t      1);\n  /* C */\n  len = sizeof (str) - 1;\n  result =\n    asn1_read_value (cert_def, \"PKIX1Implicit88.id-at-countryName\", str,\n\t\t     &len);\n  result =\n    asn1_write_value (cert1,\n\t\t      \"tbsCertificate.issuer.rdnSequence.?LAST.?LAST.type\",\n\t\t      str, 1);\n  result =\n    asn1_create_element (cert_def, \"PKIX1Implicit88.X520countryName\", &value);\n  result = asn1_write_value (value, \"\", \"US\", 2);\n  *der_len = max_len;\n  result = asn1_der_coding (value, \"\", der, der_len, errorDescription);\n  asn1_delete_structure (&value);\n  result =\n    asn1_write_value (cert1,\n\t\t      \"tbsCertificate.issuer.rdnSequence.?LAST.?LAST.value\",\n\t\t      der, *der_len);\n\n\n  result =\n    asn1_write_value (cert1, \"tbsCertificate.issuer.rdnSequence\", \"NEW\", 1);\n  result =\n    asn1_write_value (cert1, \"tbsCertificate.issuer.rdnSequence.?LAST\", \"NEW\",\n\t\t      1);\n  /* O */\n  len = sizeof (str) - 1;\n  result =\n    asn1_read_value (cert_def, \"PKIX1Implicit88.id-at-organizationName\", str,\n\t\t     &len);\n  result =\n    asn1_write_value (cert1,\n\t\t      \"tbsCertificate.issuer.rdnSequence.?LAST.?LAST.type\",\n\t\t      str, 1);\n  result =\n    asn1_create_element (cert_def, \"PKIX1Implicit88.X520OrganizationName\",\n\t\t\t &value);\n  result = asn1_write_value (value, \"\", \"printableString\", 1);\n  result = asn1_write_value (value, \"printableString\", \"gov\", 3);\n  *der_len = max_len;\n  result = asn1_der_coding (value, \"\", der, der_len, errorDescription);\n  asn1_delete_structure (&value);\n  result =\n    asn1_write_value (cert1,\n\t\t      \"tbsCertificate.issuer.rdnSequence.?LAST.?LAST.value\",\n\t\t      der, *der_len);\n\n\n  result =\n    asn1_write_value (cert1, \"tbsCertificate.issuer.rdnSequence\", \"NEW\", 1);\n  result =\n    asn1_write_value (cert1, \"tbsCertificate.issuer.rdnSequence.?LAST\", \"NEW\",\n\t\t      1);\n\n  /* OU */\n  len = sizeof (str) - 1;\n  result =\n    asn1_read_value (cert_def, \"PKIX1Implicit88.id-at-organizationalUnitName\",\n\t\t     str, &len);\n  result =\n    asn1_write_value (cert1,\n\t\t      \"tbsCertificate.issuer.rdnSequence.?LAST.?LAST.type\",\n\t\t      str, 1);\n  result =\n    asn1_create_element (cert_def,\n\t\t\t \"PKIX1Implicit88.X520OrganizationalUnitName\",\n\t\t\t &value);\n  result = asn1_write_value (value, \"\", \"printableString\", 1);\n  result = asn1_write_value (value, \"printableString\", \"nist\", 4);\n  *der_len = max_len;\n  result = asn1_der_coding (value, \"\", der, der_len, errorDescription);\n  asn1_delete_structure (&value);\n  result =\n    asn1_write_value (cert1,\n\t\t      \"tbsCertificate.issuer.rdnSequence.?LAST.?LAST.value\",\n\t\t      der, *der_len);\n\n\n  /* validity */\n  result =\n    asn1_write_value (cert1, \"tbsCertificate.validity.notBefore\", \"utcTime\",\n\t\t      1);\n  result =\n    asn1_write_value (cert1, \"tbsCertificate.validity.notBefore.utcTime\",\n\t\t      \"970630000000Z\", 1);\n\n  result =\n    asn1_write_value (cert1, \"tbsCertificate.validity.notAfter\", \"utcTime\",\n\t\t      1);\n  result =\n    asn1_write_value (cert1, \"tbsCertificate.validity.notAfter.utcTime\",\n\t\t      \"971231000000Z\", 1);\n\n\n\n  /* subject: Country=\"US\" Organization=\"gov\" OrganizationUnit=\"nist\" */\n  result =\n    asn1_write_value (cert1, \"tbsCertificate.subject\", \"rdnSequence\", 1);\n\n  result =\n    asn1_write_value (cert1, \"tbsCertificate.subject.rdnSequence\", \"NEW\", 1);\n  result =\n    asn1_write_value (cert1, \"tbsCertificate.subject.rdnSequence.?LAST\",\n\t\t      \"NEW\", 1);\n  /* C */\n  len = sizeof (str) - 1;\n  result =\n    asn1_read_value (cert_def, \"PKIX1Implicit88.id-at-countryName\", str,\n\t\t     &len);\n  result =\n    asn1_write_value (cert1,\n\t\t      \"tbsCertificate.subject.rdnSequence.?LAST.?LAST.type\",\n\t\t      str, 1);\n  result =\n    asn1_create_element (cert_def, \"PKIX1Implicit88.X520countryName\", &value);\n  result = asn1_write_value (value, \"\", \"US\", 2);\n  *der_len = max_len;\n  result = asn1_der_coding (value, \"\", der, der_len, errorDescription);\n  asn1_delete_structure (&value);\n  result =\n    asn1_write_value (cert1,\n\t\t      \"tbsCertificate.subject.rdnSequence.?LAST.?LAST.value\",\n\t\t      der, *der_len);\n\n\n  result =\n    asn1_write_value (cert1, \"tbsCertificate.subject.rdnSequence\", \"NEW\", 4);\n  result =\n    asn1_write_value (cert1, \"tbsCertificate.subject.rdnSequence.?LAST\",\n\t\t      \"NEW\", 4);\n  /* O */\n  len = sizeof (str) - 1;\n  result =\n    asn1_read_value (cert_def, \"PKIX1Implicit88.id-at-organizationName\", str,\n\t\t     &len);\n  result =\n    asn1_write_value (cert1,\n\t\t      \"tbsCertificate.subject.rdnSequence.?LAST.?LAST.type\",\n\t\t      str, 1);\n  result =\n    asn1_create_element (cert_def, \"PKIX1Implicit88.X520OrganizationName\",\n\t\t\t &value);\n  result = asn1_write_value (value, \"\", \"printableString\", 1);\n  result = asn1_write_value (value, \"printableString\", \"gov\", 3);\n  *der_len = max_len;\n  result = asn1_der_coding (value, \"\", der, der_len, errorDescription);\n  asn1_delete_structure (&value);\n  result =\n    asn1_write_value (cert1,\n\t\t      \"tbsCertificate.subject.rdnSequence.?LAST.?LAST.value\",\n\t\t      der, *der_len);\n\n\n  result =\n    asn1_write_value (cert1, \"tbsCertificate.subject.rdnSequence\", \"NEW\", 4);\n  result =\n    asn1_write_value (cert1, \"tbsCertificate.subject.rdnSequence.?LAST\",\n\t\t      \"NEW\", 4);\n  /* OU */\n  len = sizeof (str) - 1;\n  result =\n    asn1_read_value (cert_def, \"PKIX1Implicit88.id-at-organizationalUnitName\",\n\t\t     str, &len);\n  result =\n    asn1_write_value (cert1,\n\t\t      \"tbsCertificate.subject.rdnSequence.?LAST.?LAST.type\",\n\t\t      str, 1);\n  result =\n    asn1_create_element (cert_def,\n\t\t\t \"PKIX1Implicit88.X520OrganizationalUnitName\",\n\t\t\t &value);\n  result = asn1_write_value (value, \"\", \"printableString\", 1);\n  result = asn1_write_value (value, \"printableString\", \"nist\", 4);\n  *der_len = max_len;\n  result = asn1_der_coding (value, \"\", der, der_len, errorDescription);\n  asn1_delete_structure (&value);\n  result =\n    asn1_write_value (cert1,\n\t\t      \"tbsCertificate.subject.rdnSequence.?LAST.?LAST.value\",\n\t\t      der, *der_len);\n\n\n  /* subjectPublicKeyInfo: dsa with parameters=Dss-Parms */\n  len = sizeof (str) - 1;\n  result = asn1_read_value (cert_def, \"PKIX1Implicit88.id-dsa\", str, &len);\n  result =\n    asn1_write_value (cert1,\n\t\t      \"tbsCertificate.subjectPublicKeyInfo.algorithm.algorithm\",\n\t\t      str, 1);\n  result =\n    asn1_create_element (cert_def, \"PKIX1Implicit88.Dss-Parms\", &param);\n  str2 = (const unsigned char *) \"\\xd4\\x38\";\t/* only an example */\n  result = asn1_write_value (param, \"p\", str2, 128);\n  str2 = (const unsigned char *) \"\\xd4\\x38\";\t/* only an example */\n  result = asn1_write_value (param, \"q\", str2, 20);\n  str2 = (const unsigned char *) \"\\xd4\\x38\";\t/* only an example */\n  result = asn1_write_value (param, \"g\", str2, 128);\n  *der_len = max_len;\n  result = asn1_der_coding (param, \"\", der, der_len, errorDescription);\n  asn1_delete_structure (&param);\n  result =\n    asn1_write_value (cert1,\n\t\t      \"tbsCertificate.subjectPublicKeyInfo.algorithm.parameters\",\n\t\t      der, *der_len);\n\n\n  /* subjectPublicKey */\n  str2 = (const unsigned char *) \"\\x02\\x81\";\t/* only an example */\n  result =\n    asn1_write_value (cert1,\n\t\t      \"tbsCertificate.subjectPublicKeyInfo.subjectPublicKey\",\n\t\t      str2, 1048);\n\n  result = asn1_write_value (cert1, \"tbsCertificate.issuerUniqueID\", NULL, 0);\t/* NO OPTION */\n  result = asn1_write_value (cert1, \"tbsCertificate.subjectUniqueID\", NULL, 0);\t/* NO OPTION */\n\n  /* extensions */\n  result = asn1_write_value (cert1, \"tbsCertificate.extensions\", \"NEW\", 1);\n  len = sizeof (str) - 1;\n  result =\n    asn1_read_value (cert_def, \"PKIX1Implicit88.id-ce-basicConstraints\", str,\n\t\t     &len);\n  result = asn1_write_value (cert1, \"tbsCertificate.extensions.?LAST.extnID\", str, 1);\t/*   basicConstraints */\n  result =\n    asn1_write_value (cert1, \"tbsCertificate.extensions.?LAST.critical\",\n\t\t      \"TRUE\", 1);\n  result =\n    asn1_create_element (cert_def, \"PKIX1Implicit88.BasicConstraints\",\n\t\t\t &constr);\n  result = asn1_write_value (constr, \"cA\", \"TRUE\", 1);\n  result = asn1_write_value (constr, \"pathLenConstraint\", NULL, 0);\n  *der_len = max_len;\n  result = asn1_der_coding (constr, \"\", der, der_len, errorDescription);\n  result = asn1_delete_structure (&constr);\n  result =\n    asn1_write_value (cert1, \"tbsCertificate.extensions.?LAST.extnValue\", der,\n\t\t      *der_len);\n\n\n  result = asn1_write_value (cert1, \"tbsCertificate.extensions\", \"NEW\", 1);\n  len = sizeof (str) - 1;\n  result =\n    asn1_read_value (cert_def, \"PKIX1Implicit88.id-ce-subjectKeyIdentifier\",\n\t\t     str, &len);\n  result = asn1_write_value (cert1, \"tbsCertificate.extensions.?LAST.extnID\", str, 1);\t/* subjectKeyIdentifier */\n  result =\n    asn1_write_value (cert1, \"tbsCertificate.extensions.?LAST.critical\",\n\t\t      \"FALSE\", 1);\n  str2 = (const unsigned char *) \"\\x04\\x14\\xe7\\x26\\xc5\";\t/* only an example */\n  result =\n    asn1_write_value (cert1, \"tbsCertificate.extensions.?LAST.extnValue\",\n\t\t      str2, 22);\n\n\n  /* signatureAlgorithm: dsa-with-sha  */\n  len = sizeof (str) - 1;\n  result =\n    asn1_read_value (cert_def, \"PKIX1Implicit88.id-dsa-with-sha1\", str, &len);\n  result = asn1_write_value (cert1, \"signatureAlgorithm.algorithm\", str, 1);\n  result = asn1_write_value (cert1, \"signatureAlgorithm.parameters\", NULL, 0);\t/* NO OPTION */\n\n\n  /* signature */\n  *der_len = max_len;\n  result =\n    asn1_der_coding (cert1, \"tbsCertificate\", der, der_len, errorDescription);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"\\n'tbsCertificate' encoding creation: ERROR\\n\");\n    }\n  /* add the lines for the signature on der[0]..der[der_len-1]: result in str2 */\n  result = asn1_write_value (cert1, \"signature\", str2, 368);\t/* dsa-with-sha */\n\n\n  /* Use the next 3 lines to visit the certificate */\n  /* printf(\"-----------------\\n\");\n     asn1_visit_tree(cert1,\"\");\n     printf(\"-----------------\\n\"); */\n\n  *der_len = max_len;\n  result = asn1_der_coding (cert1, \"\", der, der_len, errorDescription);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"\\n'certificate' encoding creation: ERROR\\n\");\n      return;\n    }\n\n  /* Print the 'Certificate1' DER encoding */\n  printf (\"-----------------\\nCertificate Encoding:\\nNumber of bytes=%i\\n\",\n\t  *der_len);\n  for (k = 0; k < *der_len; k++)\n    printf (\"%02x \", der[k]);\n  printf (\"\\n-----------------\\n\");\n\n  /* Clear the \"certificate1\" structure */\n  asn1_delete_structure (&cert1);\n}",
      "lines": 347,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_certificate": {
      "start_point": [
        567,
        0
      ],
      "end_point": [
        624,
        1
      ],
      "content": "static void\nget_certificate (ASN1_TYPE cert_def, unsigned char *der, int der_len)\n{\n  int result, len, start, end;\n  unsigned char str[1024], str2[1024];\n  ASN1_TYPE cert2 = ASN1_TYPE_EMPTY;\n  char errorDescription[ASN1_MAX_ERROR_DESCRIPTION_SIZE];\n\n  asn1_create_element (cert_def, \"PKIX1Implicit88.Certificate\", &cert2);\n\n  result = asn1_der_decoding (&cert2, der, der_len, errorDescription);\n\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"Problems with DER encoding\\n\");\n      return;\n    }\n\n\n  /* issuer */\n  get_Name_type (cert_def, cert2, \"tbsCertificate.issuer\", str);\n  printf (\"certificate:\\nissuer :%s\\n\", str);\n  /* subject */\n  get_Name_type (cert_def, cert2, \"tbsCertificate.subject\", str);\n  printf (\"subject:%s\\n\", str);\n\n\n  /* Verify sign */\n  len = sizeof (str) - 1;\n  result = asn1_read_value (cert2, \"signatureAlgorithm.algorithm\", str, &len);\n\n  len = sizeof (str2) - 1;\n  result =\n    asn1_read_value (cert_def, \"PKIX1Implicit88.id-dsa-with-sha1\", str2,\n\t\t     &len);\n  if (!strcmp ((char *) str, (char *) str2))\n    {\t\t\t\t/* dsa-with-sha */\n\n      result = asn1_der_decoding_startEnd (cert2, der, der_len,\n\t\t\t\t\t   \"tbsCertificate\", &start, &end);\n\n      /* add the lines to calculate the sha on der[start]..der[end] */\n\n      len = sizeof (str) - 1;\n      result = asn1_read_value (cert2, \"signature\", str, &len);\n\n      /* compare the previous value to signature ( with issuer public key) */\n    }\n\n  /* Use the next 3 lines to visit the certificate */\n  /*   printf(\"-----------------\\n\");\n     asn1_visit_tree(cert2,\"\");\n     printf(\"-----------------\\n\"); */\n\n\n  /* Clear the \"certificate2\" structure */\n  asn1_delete_structure (&cert2);\n}",
      "lines": 58,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        635,
        0
      ],
      "end_point": [
        672,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int result, der_len;\n  unsigned char der[1024];\n  ASN1_TYPE PKIX1Implicit88 = ASN1_TYPE_EMPTY;\n  char errorDescription[ASN1_MAX_ERROR_DESCRIPTION_SIZE];\n\n  if (1)\n    result =\n      asn1_array2tree (pkix_asn1_tab, &PKIX1Implicit88, errorDescription);\n  else\n    result =\n      asn1_parser2tree (\"pkix.asn\", &PKIX1Implicit88, errorDescription);\n\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"%s\", errorDescription);\n      exit (1);\n    }\n\n\n  /* Use the following 3 lines to visit the PKIX1Implicit structures */\n  /* printf(\"-----------------\\n\");\n     asn1_visit_tree(PKIX1Implicit88,\"PKIX1Implicit88\");\n     printf(\"-----------------\\n\"); */\n\n  der_len = 1024;\n  create_certificate (PKIX1Implicit88, der, &der_len);\n\n  get_certificate (PKIX1Implicit88, der, der_len);\n\n  /* Clear the \"PKIX1Implicit88\" structures */\n  asn1_delete_structure (&PKIX1Implicit88);\n\n  return 0;\n}",
      "lines": 38,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/examples/CrlExample.c": {
    "my_ltostr": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "static char *\nmy_ltostr (long v, char *str)\n{\n  long d, r;\n  char temp[20];\n  int count, k, start;\n\n  if (v < 0)\n    {\n      str[0] = '-';\n      start = 1;\n      v = -v;\n    }\n  else\n    start = 0;\n\n  count = 0;\n  do\n    {\n      d = v / 10;\n      r = v - d * 10;\n      temp[start + count] = '0' + (char) r;\n      count++;\n      v = d;\n    }\n  while (v);\n\n  for (k = 0; k < count; k++)\n    str[k + start] = temp[start + count - k - 1];\n  str[count + start] = 0;\n  return str;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nmy_ltostr (long v, char *str)",
        "*"
      ]
    },
    "get_Name_type": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        208,
        1
      ],
      "content": "static void\nget_Name_type (ASN1_TYPE cert_def, ASN1_TYPE cert, const char *root,\n\t       unsigned char *ans)\n{\n  int k, k2, result, len;\n  char name[128], str[1024], str2[1024], name2[128], counter[5], name3[128];\n  ASN1_TYPE value = ASN1_TYPE_EMPTY;\n  char errorDescription[ASN1_MAX_ERROR_DESCRIPTION_SIZE];\n  char *answer = (char *) ans;\n\n  answer[0] = 0;\n  k = 1;\n  do\n    {\n      strcpy (name, root);\n      strcat (name, \".rdnSequence.?\");\n      my_ltostr (k, counter);\n      strcat (name, counter);\n\n      len = sizeof (str) - 1;\n      result = asn1_read_value (cert, name, str, &len);\n      if (result == ASN1_ELEMENT_NOT_FOUND)\n\tbreak;\n      k2 = 1;\n      do\n\t{\n\t  strcpy (name2, name);\n\t  strcat (name2, \".?\");\n\t  my_ltostr (k2, counter);\n\t  strcat (name2, counter);\n\n\t  len = sizeof (str) - 1;\n\t  result = asn1_read_value (cert, name2, str, &len);\n\t  if (result == ASN1_ELEMENT_NOT_FOUND)\n\t    break;\n\t  strcpy (name3, name2);\n\t  strcat (name3, \".type\");\n\n\t  len = sizeof (str) - 1;\n\t  result = asn1_read_value (cert, name3, str, &len);\n\t  strcpy (name3, name2);\n\t  strcat (name3, \".value\");\n\t  if (result == ASN1_SUCCESS)\n\t    {\n\t      len = sizeof (str2);\n\t      result =\n\t\tasn1_read_value (cert_def,\n\t\t\t\t \"PKIX1Implicit88.id-at-countryName\", str2,\n\t\t\t\t &len);\n\t      if (!strcmp (str, str2))\n\t\t{\n\t\t  asn1_create_element (cert_def,\n\t\t\t\t       \"PKIX1Implicit88.X520OrganizationName\",\n\t\t\t\t       &value);\n\t\t  len = sizeof (str) - 1;\n\t\t  asn1_read_value (cert, name3, str, &len);\n\t\t  result =\n\t\t    asn1_der_decoding (&value, str, len, errorDescription);\n\n\t\t  len = sizeof (str) - 1;\n\t\t  asn1_read_value (value, \"\", str, &len);\t/* CHOICE */\n\n\t\t  strcpy (name3, str);\n\n\t\t  len = sizeof (str) - 1;\n\t\t  asn1_read_value (value, name3, str, &len);\n\t\t  str[len] = 0;\n\t\t  strcat (answer, \" C=\");\n\t\t  strcat (answer, str);\n\n\t\t  asn1_delete_structure (&value);\n\t\t}\n\t      else\n\t\t{\n\t\t  len = sizeof (str2);\n\t\t  result =\n\t\t    asn1_read_value (cert_def,\n\t\t\t\t     \"PKIX1Implicit88.id-at-organizationName\",\n\t\t\t\t     str2, &len);\n\t\t  if (!strcmp (str, str2))\n\t\t    {\n\t\t      asn1_create_element (cert_def,\n\t\t\t\t\t   \"PKIX1Implicit88.X520OrganizationName\",\n\t\t\t\t\t   &value);\n\n\t\t      len = sizeof (str) - 1;\n\t\t      asn1_read_value (cert, name3, str, &len);\n\t\t      asn1_der_decoding (&value, str, len, errorDescription);\n\t\t      len = sizeof (str) - 1;\n\t\t      asn1_read_value (value, \"\", str, &len);\t/* CHOICE */\n\t\t      strcpy (name3, str);\n\t\t      len = sizeof (str) - 1;\n\t\t      asn1_read_value (value, name3, str, &len);\n\t\t      str[len] = 0;\n\t\t      strcat (answer, \" O=\");\n\t\t      strcat (answer, str);\n\t\t      asn1_delete_structure (&value);\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      len = sizeof (str2);\n\t\t      result =\n\t\t\tasn1_read_value (cert_def,\n\t\t\t\t\t \"PKIX1Implicit88.id-at-organizationalUnitName\",\n\t\t\t\t\t str2, &len);\n\t\t      if (!strcmp (str, str2))\n\t\t\t{\n\t\t\t  asn1_create_element (cert_def,\n\t\t\t\t\t       \"PKIX1Implicit88.X520OrganizationalUnitName\",\n\t\t\t\t\t       &value);\n\t\t\t  len = sizeof (str) - 1;\n\t\t\t  asn1_read_value (cert, name3, str, &len);\n\t\t\t  asn1_der_decoding (&value, str, len,\n\t\t\t\t\t     errorDescription);\n\t\t\t  len = sizeof (str) - 1;\n\t\t\t  asn1_read_value (value, \"\", str, &len);\t/* CHOICE */\n\t\t\t  strcpy (name3, str);\n\t\t\t  len = sizeof (str) - 1;\n\t\t\t  asn1_read_value (value, name3, str, &len);\n\t\t\t  str[len] = 0;\n\t\t\t  strcat (answer, \" OU=\");\n\t\t\t  strcat (answer, str);\n\t\t\t  asn1_delete_structure (&value);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t  k2++;\n\t}\n      while (1);\n      k++;\n    }\n  while (1);\n}",
      "lines": 134,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_CRL": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        425,
        1
      ],
      "content": "static void\ncreate_CRL (ASN1_TYPE cert_def, unsigned char *der, int *der_len)\n{\n  int result, k, len;\n  unsigned char str[1024];\n  const unsigned char *str2;\n  ASN1_TYPE crl = ASN1_TYPE_EMPTY;\n  ASN1_TYPE value = ASN1_TYPE_EMPTY;\n  char errorDescription[ASN1_MAX_ERROR_DESCRIPTION_SIZE];\n  int max_len;\n\n  max_len = *der_len;\n\n  result =\n    asn1_create_element (cert_def, \"PKIX1Implicit88.CertificateList\", &crl);\n\n  /* Use the next 3 lines to visit the empty certificate */\n  /*  printf(\"-----------------\\n\");\n     asn1_visit_tree(crl,\"\");\n     printf(\"-----------------\\n\"); */\n\n\n  /* version: v2(1) */\n  result = asn1_write_value (crl, \"tbsCertList.version\", \"v2\", 0);\n\n\n  /* signature: dsa-with-sha */\n  len = sizeof (str) - 1;\n  result =\n    asn1_read_value (cert_def, \"PKIX1Implicit88.id-dsa-with-sha1\", str, &len);\n  result = asn1_write_value (crl, \"tbsCertList.signature.algorithm\", str, 1);\n  result =\n    asn1_write_value (crl, \"tbsCertList.signature.parameters\", NULL, 0);\n\n\n  /* issuer: Country=\"US\" Organization=\"gov\" OrganizationUnit=\"nist\" */\n  result = asn1_write_value (crl, \"tbsCertList.issuer\", \"rdnSequence\", 1);\n\n  result = asn1_write_value (crl, \"tbsCertList.issuer.rdnSequence\", \"NEW\", 1);\n  result =\n    asn1_write_value (crl, \"tbsCertList.issuer.rdnSequence.?LAST\", \"NEW\", 1);\n  /* C */\n  len = sizeof (str) - 1;\n  result =\n    asn1_read_value (cert_def, \"PKIX1Implicit88.id-at-countryName\", str,\n\t\t     &len);\n  result =\n    asn1_write_value (crl, \"tbsCertList.issuer.rdnSequence.?LAST.?LAST.type\",\n\t\t      str, 1);\n  result =\n    asn1_create_element (cert_def, \"PKIX1Implicit88.X520countryName\", &value);\n  result = asn1_write_value (value, \"\", \"US\", 2);\n  *der_len = max_len;\n  result = asn1_der_coding (value, \"\", der, der_len, errorDescription);\n\n  asn1_delete_structure (&value);\n  result =\n    asn1_write_value (crl, \"tbsCertList.issuer.rdnSequence.?LAST.?LAST.value\",\n\t\t      der, *der_len);\n\n\n  result = asn1_write_value (crl, \"tbsCertList.issuer.rdnSequence\", \"NEW\", 4);\n  result =\n    asn1_write_value (crl, \"tbsCertList.issuer.rdnSequence.?LAST\", \"NEW\", 4);\n  /* O */\n  len = sizeof (str) - 1;\n  result =\n    asn1_read_value (cert_def, \"PKIX1Implicit88.id-at-organizationName\", str,\n\t\t     &len);\n  result =\n    asn1_write_value (crl, \"tbsCertList.issuer.rdnSequence.?LAST.?LAST.type\",\n\t\t      str, 8);\n  result =\n    asn1_create_element (cert_def, \"PKIX1Implicit88.X520OrganizationName\",\n\t\t\t &value);\n  result = asn1_write_value (value, \"\", \"printableString\", 1);\n  result = asn1_write_value (value, \"printableString\", \"gov\", 3);\n  *der_len = max_len;\n  result = asn1_der_coding (value, \"\", der, der_len, errorDescription);\n  asn1_delete_structure (&value);\n  result =\n    asn1_write_value (crl, \"tbsCertList.issuer.rdnSequence.?LAST.?LAST.value\",\n\t\t      der, *der_len);\n\n\n  result = asn1_write_value (crl, \"tbsCertList.issuer.rdnSequence\", \"NEW\", 1);\n  result =\n    asn1_write_value (crl, \"tbsCertList.issuer.rdnSequence.?LAST\", \"NEW\", 1);\n  /* OU */\n  len = sizeof (str) - 1;\n  result =\n    asn1_read_value (cert_def, \"PKIX1Implicit88.id-at-organizationalUnitName\",\n\t\t     str, &len);\n  result =\n    asn1_write_value (crl, \"tbsCertList.issuer.rdnSequence.?LAST.?LAST.type\",\n\t\t      str, 1);\n  result =\n    asn1_create_element (cert_def,\n\t\t\t \"PKIX1Implicit88.X520OrganizationalUnitName\",\n\t\t\t &value);\n  result = asn1_write_value (value, \"\", \"printableString\", 1);\n  result = asn1_write_value (value, \"printableString\", \"nist\", 4);\n  *der_len = max_len;\n  result = asn1_der_coding (value, \"\", der, der_len, errorDescription);\n  asn1_delete_structure (&value);\n  result =\n    asn1_write_value (crl, \"tbsCertList.issuer.rdnSequence.?LAST.?LAST.value\",\n\t\t      der, *der_len);\n\n\n  /* validity */\n  result = asn1_write_value (crl, \"tbsCertList.thisUpdate\", \"utcTime\", 1);\n  result =\n    asn1_write_value (crl, \"tbsCertList.thisUpdate.utcTime\", \"970801000000Z\",\n\t\t      1);\n\n  result = asn1_write_value (crl, \"tbsCertList.nextUpdate\", \"utcTime\", 1);\n  result =\n    asn1_write_value (crl, \"tbsCertList.nextUpdate.utcTime\", \"970808000000Z\",\n\t\t      1);\n\n\n  /* revokedCertificates */\n  result =\n    asn1_write_value (crl, \"tbsCertList.revokedCertificates\", \"NEW\", 1);\n  str[0] = 18;\n  result =\n    asn1_write_value (crl,\n\t\t      \"tbsCertList.revokedCertificates.?LAST.userCertificate\",\n\t\t      str, 1);\n  result =\n    asn1_write_value (crl,\n\t\t      \"tbsCertList.revokedCertificates.?LAST.revocationDate\",\n\t\t      \"utcTime\", 1);\n  result =\n    asn1_write_value (crl,\n\t\t      \"tbsCertList.revokedCertificates.?LAST.revocationDate.utcTime\",\n\t\t      \"970731000000Z\", 1);\n\n  result =\n    asn1_write_value (crl,\n\t\t      \"tbsCertList.revokedCertificates.?LAST.crlEntryExtensions\",\n\t\t      \"NEW\", 1);\n  len = sizeof (str) - 1;\n  result = asn1_read_value (cert_def, \"PKIX1Implicit88.id-ce-cRLReasons\",\n\t\t\t    str, &len);\n  result = asn1_write_value (crl, \"tbsCertList.revokedCertificates.?LAST.crlEntryExtensions.?LAST.extnID\", str, 1);\t/* reasonCode */\n  result =\n    asn1_write_value (crl,\n\t\t      \"tbsCertList.revokedCertificates.?LAST.crlEntryExtensions.?LAST.critical\",\n\t\t      \"FALSE\", 1);\n  str2 = (const unsigned char *) \"\\x0a\\x01\\x01\";\n  result =\n    asn1_write_value (crl,\n\t\t      \"tbsCertList.revokedCertificates.?LAST.crlEntryExtensions.?LAST.extnValue\",\n\t\t      str2, 3);\n\n\n  /* crlExtensions */\n  result = asn1_write_value (crl, \"tbsCertList.crlExtensions\", NULL, 0);\n\n\n  /* signatureAlgorithm: dsa-with-sha  */\n  len = sizeof (str) - 1;\n  result =\n    asn1_read_value (cert_def, \"PKIX1Implicit88.id-dsa-with-sha1\", str, &len);\n  result = asn1_write_value (crl, \"signatureAlgorithm.algorithm\", str, 1);\n  result = asn1_write_value (crl, \"signatureAlgorithm.parameters\", NULL, 0);\t/* NO OPTION */\n\n  /* signature */\n  *der_len = max_len;\n  result =\n    asn1_der_coding (crl, \"tbsCertList\", der, der_len, errorDescription);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"\\n'tbsCertList' encoding creation: ERROR\\n\");\n      return;\n    }\n\n  /* add the lines for the signature on der[0]..der[der_len-1]: result in str2 */\n  result = asn1_write_value (crl, \"signature\", str2, 46 * 8);\n\n\n  /* Use the next 3 lines to visit the certificate */\n  /* printf(\"-----------------\\n\");\n     asn1_visit_tree(crl,\"\");\n     printf(\"-----------------\\n\"); */\n\n  *der_len = max_len;\n  result = asn1_der_coding (crl, \"\", der, der_len, errorDescription);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"\\n'crl1' encoding creation: ERROR\\n\");\n      return;\n    }\n\n  /* Print the 'Certificate1' DER encoding */\n  printf (\"-----------------\\nCrl1 Encoding:\\nNumber of bytes=%i\\n\",\n\t  *der_len);\n  for (k = 0; k < *der_len; k++)\n    printf (\"%02x \", der[k]);\n  printf (\"\\n-----------------\\n\");\n\n  /* Clear the \"certificate1\" structure */\n  asn1_delete_structure (&crl);\n}",
      "lines": 206,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_CRL": {
      "start_point": [
        438,
        0
      ],
      "end_point": [
        491,
        1
      ],
      "content": "static void\nget_CRL (ASN1_TYPE cert_def, unsigned char *der, int der_len)\n{\n  int result, len, start, end;\n  unsigned char str[1024], str2[1024];\n  ASN1_TYPE crl2 = ASN1_TYPE_EMPTY;\n  char errorDescription[ASN1_MAX_ERROR_DESCRIPTION_SIZE];\n\n\n  asn1_create_element (cert_def, \"PKIX1Implicit88.CertificateList\", &crl2);\n\n  result = asn1_der_decoding (&crl2, der, der_len, errorDescription);\n\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"Problems with DER encoding\\n\");\n      return;\n    }\n\n\n  /* issuer */\n  get_Name_type (cert_def, crl2, \"tbsCertList.issuer\", str);\n  printf (\"crl2:\\nissuer: %s\\n\", str);\n\n\n  /* Verify sign */\n  len = sizeof (str) - 1;\n  result = asn1_read_value (crl2, \"signatureAlgorithm.algorithm\", str, &len);\n\n  result =\n    asn1_read_value (cert_def, \"PKIX1Implicit88.id-dsa-with-sha1\", str2,\n\t\t     &len);\n  if (!strcmp ((char *) str, (char *) str2))\n    {\t\t\t\t/* dsa-with-sha */\n\n      result = asn1_der_decoding_startEnd (crl2, der, der_len,\n\t\t\t\t\t   \"tbsCertList\", &start, &end);\n\n      /* add the lines to calculate the sha on der[start]..der[end] */\n\n      result = asn1_read_value (crl2, \"signature\", str, &len);\n\n      /* compare the previous value to signature ( with issuer public key) */\n    }\n\n  /* Use the next 3 lines to visit the certificate */\n  /* printf(\"-----------------\\n\");\n     asn1_visit_tree(crl2,\"\");\n     printf(\"-----------------\\n\"); */\n\n\n  /* Clear the \"crl2\" structure */\n  asn1_delete_structure (&crl2);\n}",
      "lines": 54,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        502,
        0
      ],
      "end_point": [
        539,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int result, der_len;\n  unsigned char der[1024];\n  ASN1_TYPE PKIX1Implicit88 = ASN1_TYPE_EMPTY;\n  char errorDescription[ASN1_MAX_ERROR_DESCRIPTION_SIZE];\n\n  if (1)\n    result =\n      asn1_array2tree (pkix_asn1_tab, &PKIX1Implicit88, errorDescription);\n  else\n    result =\n      asn1_parser2tree (\"pkix.asn\", &PKIX1Implicit88, errorDescription);\n\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"%s\\n\", errorDescription);\n      exit (1);\n    }\n\n  /* Use the following 3 lines to visit the PKIX1Implicit structures */\n  /* printf(\"-----------------\\n\");\n     asn1_visit_tree(cert_def,\"PKIX1Implicit88\");\n     printf(\"-----------------\\n\"); */\n\n  der_len = 1024;\n  create_CRL (PKIX1Implicit88, der, &der_len);\n\n\n  get_CRL (PKIX1Implicit88, der, der_len);\n\n  /* Clear the \"PKIX1Implicit88\" structures */\n  asn1_delete_structure (&PKIX1Implicit88);\n\n  return 0;\n}",
      "lines": 38,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/examples/pkix_asn1_tab.c": {},
  "libtasn1/libtasn1-4.13/gl/errno.in.h": {},
  "libtasn1/libtasn1-4.13/gl/fstat.c": {
    "orig_fstat": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static int\norig_fstat (int fd, struct stat *buf)\n{\n  return fstat (fd, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fstat_nothrow": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        61,
        5
      ],
      "content": "static int\nfstat_nothrow (int fd, struct stat *buf)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = orig_fstat (fd, buf);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_fstat": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "int\nrpl_fstat (int fd, struct stat *buf)\n{\n#if REPLACE_FCHDIR && REPLACE_OPEN_DIRECTORY\n  /* Handle the case when rpl_open() used a dummy file descriptor to work\n     around an open() that can't normally visit directories.  */\n  const char *name = _gl_directory_name (fd);\n  if (name != NULL)\n    return stat (name, buf);\n#endif\n\n  return fstat_nothrow (fd, buf);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/gl/ftell.c": {
    "ftell": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "long\nftell (FILE *fp)\n{\n  /* Use the replacement ftello function with all its workarounds.  */\n  off_t offset = ftello (fp);\n  if (LONG_MIN <= offset && offset <= LONG_MAX)\n    return /* (long) */ offset;\n  else\n    {\n      errno = EOVERFLOW;\n      return -1;\n    }\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "long",
        "long"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/gl/ftello.c": {},
  "libtasn1/libtasn1-4.13/gl/getopt.c": {
    "exchange": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "static void\nexchange (char **argv, struct _getopt_data *d)\n{\n  int bottom = d->__first_nonopt;\n  int middle = d->__last_nonopt;\n  int top = d->optind;\n  char *tem;\n\n  /* Exchange the shorter segment with the far end of the longer segment.\n     That puts the shorter segment into the right place.\n     It leaves the longer segment in the right place overall,\n     but it consists of two parts that need to be swapped next.  */\n\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n  /* First make sure the handling of the '__getopt_nonoption_flags'\n     string can work normally.  Our top argument must be in the range\n     of the string.  */\n  if (d->__nonoption_flags_len > 0 && top >= d->__nonoption_flags_max_len)\n    {\n      /* We must extend the array.  The user plays games with us and\n         presents new arguments.  */\n      char *new_str = malloc (top + 1);\n      if (new_str == NULL)\n        d->__nonoption_flags_len = d->__nonoption_flags_max_len = 0;\n      else\n        {\n          memset (__mempcpy (new_str, __getopt_nonoption_flags,\n                             d->__nonoption_flags_max_len),\n                  '\\0', top + 1 - d->__nonoption_flags_max_len);\n          d->__nonoption_flags_max_len = top + 1;\n          __getopt_nonoption_flags = new_str;\n        }\n    }\n#endif\n\n  while (top > middle && middle > bottom)\n    {\n      if (top - middle > middle - bottom)\n        {\n          /* Bottom segment is the short one.  */\n          int len = middle - bottom;\n          register int i;\n\n          /* Swap it with the top part of the top segment.  */\n          for (i = 0; i < len; i++)\n            {\n              tem = argv[bottom + i];\n              argv[bottom + i] = argv[top - (middle - bottom) + i];\n              argv[top - (middle - bottom) + i] = tem;\n              SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);\n            }\n          /* Exclude the moved bottom segment from further swapping.  */\n          top -= len;\n        }\n      else\n        {\n          /* Top segment is the short one.  */\n          int len = top - middle;\n          register int i;\n\n          /* Swap it with the bottom part of the bottom segment.  */\n          for (i = 0; i < len; i++)\n            {\n              tem = argv[bottom + i];\n              argv[bottom + i] = argv[middle + i];\n              argv[middle + i] = tem;\n              SWAP_FLAGS (bottom + i, middle + i);\n            }\n          /* Exclude the moved top segment from further swapping.  */\n          bottom += len;\n        }\n    }\n\n  /* Update records for the slots the non-options now occupy.  */\n\n  d->__first_nonopt += (d->optind - d->__last_nonopt);\n  d->__last_nonopt = d->optind;\n}",
      "lines": 78,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_getopt_initialize": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "static const char *\n_getopt_initialize (int argc _GL_UNUSED,\n                    char **argv _GL_UNUSED, const char *optstring,\n                    struct _getopt_data *d, int posixly_correct)\n{\n  /* Start processing options with ARGV-element 1 (since ARGV-element 0\n     is the program name); the sequence of previously skipped\n     non-option ARGV-elements is empty.  */\n\n  d->__first_nonopt = d->__last_nonopt = d->optind;\n\n  d->__nextchar = NULL;\n\n  d->__posixly_correct = posixly_correct || !!getenv (\"POSIXLY_CORRECT\");\n\n  /* Determine how to handle the ordering of options and nonoptions.  */\n\n  if (optstring[0] == '-')\n    {\n      d->__ordering = RETURN_IN_ORDER;\n      ++optstring;\n    }\n  else if (optstring[0] == '+')\n    {\n      d->__ordering = REQUIRE_ORDER;\n      ++optstring;\n    }\n  else if (d->__posixly_correct)\n    d->__ordering = REQUIRE_ORDER;\n  else\n    d->__ordering = PERMUTE;\n\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n  if (!d->__posixly_correct\n      && argc == __libc_argc && argv == __libc_argv)\n    {\n      if (d->__nonoption_flags_max_len == 0)\n        {\n          if (__getopt_nonoption_flags == NULL\n              || __getopt_nonoption_flags[0] == '\\0')\n            d->__nonoption_flags_max_len = -1;\n          else\n            {\n              const char *orig_str = __getopt_nonoption_flags;\n              int len = d->__nonoption_flags_max_len = strlen (orig_str);\n              if (d->__nonoption_flags_max_len < argc)\n                d->__nonoption_flags_max_len = argc;\n              __getopt_nonoption_flags =\n                (char *) malloc (d->__nonoption_flags_max_len);\n              if (__getopt_nonoption_flags == NULL)\n                d->__nonoption_flags_max_len = -1;\n              else\n                memset (__mempcpy (__getopt_nonoption_flags, orig_str, len),\n                        '\\0', d->__nonoption_flags_max_len - len);\n            }\n        }\n      d->__nonoption_flags_len = d->__nonoption_flags_max_len;\n    }\n  else\n    d->__nonoption_flags_len = 0;\n#endif\n\n  return optstring;\n}",
      "lines": 64,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\n_getopt_initialize (int argc _GL_UNUSED,\n                    char **argv _GL_UNUSED, const char *optstring,\n                    struct _getopt_data *d, int posixly_correct)",
        "*"
      ]
    },
    "_getopt_internal_r": {
      "start_point": [
        344,
        0
      ],
      "end_point": [
        1154,
        1
      ],
      "content": "int\n_getopt_internal_r (int argc, char **argv, const char *optstring,\n                    const struct option *longopts, int *longind,\n                    int long_only, struct _getopt_data *d, int posixly_correct)\n{\n  int print_errors = d->opterr;\n\n  if (argc < 1)\n    return -1;\n\n  d->optarg = NULL;\n\n  if (d->optind == 0 || !d->__initialized)\n    {\n      if (d->optind == 0)\n        d->optind = 1;  /* Don't scan ARGV[0], the program name.  */\n      optstring = _getopt_initialize (argc, argv, optstring, d,\n                                      posixly_correct);\n      d->__initialized = 1;\n    }\n  else if (optstring[0] == '-' || optstring[0] == '+')\n    optstring++;\n  if (optstring[0] == ':')\n    print_errors = 0;\n\n  /* Test whether ARGV[optind] points to a non-option argument.\n     Either it does not have option syntax, or there is an environment flag\n     from the shell indicating it is not an option.  The later information\n     is only used when the used in the GNU libc.  */\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n# define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0' \\\n                      || (d->optind < d->__nonoption_flags_len                \\\n                          && __getopt_nonoption_flags[d->optind] == '1'))\n#else\n# define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0')\n#endif\n\n  if (d->__nextchar == NULL || *d->__nextchar == '\\0')\n    {\n      /* Advance to the next ARGV-element.  */\n\n      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been\n         moved back by the user (who may also have changed the arguments).  */\n      if (d->__last_nonopt > d->optind)\n        d->__last_nonopt = d->optind;\n      if (d->__first_nonopt > d->optind)\n        d->__first_nonopt = d->optind;\n\n      if (d->__ordering == PERMUTE)\n        {\n          /* If we have just processed some options following some non-options,\n             exchange them so that the options come first.  */\n\n          if (d->__first_nonopt != d->__last_nonopt\n              && d->__last_nonopt != d->optind)\n            exchange ((char **) argv, d);\n          else if (d->__last_nonopt != d->optind)\n            d->__first_nonopt = d->optind;\n\n          /* Skip any additional non-options\n             and extend the range of non-options previously skipped.  */\n\n          while (d->optind < argc && NONOPTION_P)\n            d->optind++;\n          d->__last_nonopt = d->optind;\n        }\n\n      /* The special ARGV-element '--' means premature end of options.\n         Skip it like a null option,\n         then exchange with previous non-options as if it were an option,\n         then skip everything else like a non-option.  */\n\n      if (d->optind != argc && !strcmp (argv[d->optind], \"--\"))\n        {\n          d->optind++;\n\n          if (d->__first_nonopt != d->__last_nonopt\n              && d->__last_nonopt != d->optind)\n            exchange ((char **) argv, d);\n          else if (d->__first_nonopt == d->__last_nonopt)\n            d->__first_nonopt = d->optind;\n          d->__last_nonopt = argc;\n\n          d->optind = argc;\n        }\n\n      /* If we have done all the ARGV-elements, stop the scan\n         and back over any non-options that we skipped and permuted.  */\n\n      if (d->optind == argc)\n        {\n          /* Set the next-arg-index to point at the non-options\n             that we previously skipped, so the caller will digest them.  */\n          if (d->__first_nonopt != d->__last_nonopt)\n            d->optind = d->__first_nonopt;\n          return -1;\n        }\n\n      /* If we have come to a non-option and did not permute it,\n         either stop the scan or describe it to the caller and pass it by.  */\n\n      if (NONOPTION_P)\n        {\n          if (d->__ordering == REQUIRE_ORDER)\n            return -1;\n          d->optarg = argv[d->optind++];\n          return 1;\n        }\n\n      /* We have found another option-ARGV-element.\n         Skip the initial punctuation.  */\n\n      d->__nextchar = (argv[d->optind] + 1\n                  + (longopts != NULL && argv[d->optind][1] == '-'));\n    }\n\n  /* Decode the current option-ARGV-element.  */\n\n  /* Check whether the ARGV-element is a long option.\n\n     If long_only and the ARGV-element has the form \"-f\", where f is\n     a valid short option, don't consider it an abbreviated form of\n     a long option that starts with f.  Otherwise there would be no\n     way to give the -f short option.\n\n     On the other hand, if there's a long option \"fubar\" and\n     the ARGV-element is \"-fu\", do consider that an abbreviation of\n     the long option, just like \"--fu\", and not \"-f\" with arg \"u\".\n\n     This distinction seems to be the most useful approach.  */\n\n  if (longopts != NULL\n      && (argv[d->optind][1] == '-'\n          || (long_only && (argv[d->optind][2]\n                            || !strchr (optstring, argv[d->optind][1])))))\n    {\n      char *nameend;\n      unsigned int namelen;\n      const struct option *p;\n      const struct option *pfound = NULL;\n      struct option_list\n      {\n        const struct option *p;\n        struct option_list *next;\n      } *ambig_list = NULL;\n#ifdef _LIBC\n/* malloc() not used for _LIBC to simplify failure messages.  */\n# define free_option_list(l)\n#else\n# define free_option_list(l)\t\t\t\\\n      while (l != NULL)\t\t\t\t\\\n        {\t\t\t\t\t\\\n          struct option_list *pn = l->next;\t\\\n          free (l);\t\t\t\t\\\n          l = pn;\t\t\t\t\\\n        }\n#endif\n      int exact = 0;\n      int ambig = 0;\n      int indfound = -1;\n      int option_index;\n\n      for (nameend = d->__nextchar; *nameend && *nameend != '='; nameend++)\n        /* Do nothing.  */ ;\n      namelen = nameend - d->__nextchar;\n\n      /* Test all long options for either exact match\n         or abbreviated matches.  */\n      for (p = longopts, option_index = 0; p->name; p++, option_index++)\n        if (!strncmp (p->name, d->__nextchar, namelen))\n          {\n            if (namelen == (unsigned int) strlen (p->name))\n              {\n                /* Exact match found.  */\n                pfound = p;\n                indfound = option_index;\n                exact = 1;\n                break;\n              }\n            else if (pfound == NULL)\n              {\n                /* First nonexact match found.  */\n                pfound = p;\n                indfound = option_index;\n              }\n            else if (ambig)\n              ; /* Taking simpler path to handling ambiguities.  */\n            else if (long_only\n                     || pfound->has_arg != p->has_arg\n                     || pfound->flag != p->flag\n                     || pfound->val != p->val)\n              {\n                /* Second or later nonexact match found.  */\n#ifdef _LIBC\n                struct option_list *newp = alloca (sizeof (*newp));\n#else\n                struct option_list *newp = malloc (sizeof (*newp));\n                if (newp == NULL)\n                  {\n                    free_option_list (ambig_list);\n                    ambig_list = NULL;\n                    ambig = 1; /* Use simpler fallback message.  */\n                  }\n                else\n#endif\n                  {\n                    newp->p = p;\n                    newp->next = ambig_list;\n                    ambig_list = newp;\n                  }\n              }\n          }\n\n      if ((ambig || ambig_list) && !exact)\n        {\n          if (print_errors && ambig_list)\n            {\n              struct option_list first;\n              first.p = pfound;\n              first.next = ambig_list;\n              ambig_list = &first;\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf = NULL;\n              size_t buflen = 0;\n\n              FILE *fp = open_memstream (&buf, &buflen);\n              if (fp != NULL)\n                {\n                  fprintf (fp,\n                           _(\"%s: option '%s' is ambiguous; possibilities:\"),\n                           argv[0], argv[d->optind]);\n\n                  do\n                    {\n                      fprintf (fp, \" '--%s'\", ambig_list->p->name);\n                      ambig_list = ambig_list->next;\n                    }\n                  while (ambig_list != NULL);\n\n                  fputc_unlocked ('\\n', fp);\n\n                  if (__builtin_expect (fclose (fp) != EOF, 1))\n                    {\n                      _IO_flockfile (stderr);\n\n                      int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                      ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                      __fxprintf (NULL, \"%s\", buf);\n\n                      ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                      _IO_funlockfile (stderr);\n\n                      free (buf);\n                    }\n                }\n#else\n              fprintf (stderr,\n                       _(\"%s: option '%s' is ambiguous; possibilities:\"),\n                       argv[0], argv[d->optind]);\n              do\n                {\n                  fprintf (stderr, \" '--%s'\", ambig_list->p->name);\n                  ambig_list = ambig_list->next;\n                }\n              while (ambig_list != NULL);\n\n              fputc ('\\n', stderr);\n#endif\n            }\n          else if (print_errors && ambig)\n            {\n              fprintf (stderr,\n                       _(\"%s: option '%s' is ambiguous\\n\"),\n                       argv[0], argv[d->optind]);\n            }\n          d->__nextchar += strlen (d->__nextchar);\n          d->optind++;\n          d->optopt = 0;\n          free_option_list (ambig_list);\n          return '?';\n        }\n\n      free_option_list (ambig_list);\n\n      if (pfound != NULL)\n        {\n          option_index = indfound;\n          d->optind++;\n          if (*nameend)\n            {\n              /* Don't test has_arg with >, because some C compilers don't\n                 allow it to be used on enums.  */\n              if (pfound->has_arg)\n                d->optarg = nameend + 1;\n              else\n                {\n                  if (print_errors)\n                    {\n#if defined _LIBC && defined USE_IN_LIBIO\n                      char *buf;\n                      int n;\n#endif\n\n                      if (argv[d->optind - 1][1] == '-')\n                        {\n                          /* --option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                          n = __asprintf (&buf, _(\"\\\n%s: option '--%s' doesn't allow an argument\\n\"),\n                                          argv[0], pfound->name);\n#else\n                          fprintf (stderr, _(\"\\\n%s: option '--%s' doesn't allow an argument\\n\"),\n                                   argv[0], pfound->name);\n#endif\n                        }\n                      else\n                        {\n                          /* +option or -option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                          n = __asprintf (&buf, _(\"\\\n%s: option '%c%s' doesn't allow an argument\\n\"),\n                                          argv[0], argv[d->optind - 1][0],\n                                          pfound->name);\n#else\n                          fprintf (stderr, _(\"\\\n%s: option '%c%s' doesn't allow an argument\\n\"),\n                                   argv[0], argv[d->optind - 1][0],\n                                   pfound->name);\n#endif\n                        }\n\n#if defined _LIBC && defined USE_IN_LIBIO\n                      if (n >= 0)\n                        {\n                          _IO_flockfile (stderr);\n\n                          int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                          ((_IO_FILE *) stderr)->_flags2\n                            |= _IO_FLAGS2_NOTCANCEL;\n\n                          __fxprintf (NULL, \"%s\", buf);\n\n                          ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                          _IO_funlockfile (stderr);\n\n                          free (buf);\n                        }\n#endif\n                    }\n\n                  d->__nextchar += strlen (d->__nextchar);\n\n                  d->optopt = pfound->val;\n                  return '?';\n                }\n            }\n          else if (pfound->has_arg == 1)\n            {\n              if (d->optind < argc)\n                d->optarg = argv[d->optind++];\n              else\n                {\n                  if (print_errors)\n                    {\n#if defined _LIBC && defined USE_IN_LIBIO\n                      char *buf;\n\n                      if (__asprintf (&buf, _(\"\\\n%s: option '--%s' requires an argument\\n\"),\n                                      argv[0], pfound->name) >= 0)\n                        {\n                          _IO_flockfile (stderr);\n\n                          int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                          ((_IO_FILE *) stderr)->_flags2\n                            |= _IO_FLAGS2_NOTCANCEL;\n\n                          __fxprintf (NULL, \"%s\", buf);\n\n                          ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                          _IO_funlockfile (stderr);\n\n                          free (buf);\n                        }\n#else\n                      fprintf (stderr,\n                               _(\"%s: option '--%s' requires an argument\\n\"),\n                               argv[0], pfound->name);\n#endif\n                    }\n                  d->__nextchar += strlen (d->__nextchar);\n                  d->optopt = pfound->val;\n                  return optstring[0] == ':' ? ':' : '?';\n                }\n            }\n          d->__nextchar += strlen (d->__nextchar);\n          if (longind != NULL)\n            *longind = option_index;\n          if (pfound->flag)\n            {\n              *(pfound->flag) = pfound->val;\n              return 0;\n            }\n          return pfound->val;\n        }\n\n      /* Can't find it as a long option.  If this is not getopt_long_only,\n         or the option starts with '--' or is not a valid short\n         option, then it's an error.\n         Otherwise interpret it as a short option.  */\n      if (!long_only || argv[d->optind][1] == '-'\n          || strchr (optstring, *d->__nextchar) == NULL)\n        {\n          if (print_errors)\n            {\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf;\n              int n;\n#endif\n\n              if (argv[d->optind][1] == '-')\n                {\n                  /* --option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                  n = __asprintf (&buf, _(\"%s: unrecognized option '--%s'\\n\"),\n                                  argv[0], d->__nextchar);\n#else\n                  fprintf (stderr, _(\"%s: unrecognized option '--%s'\\n\"),\n                           argv[0], d->__nextchar);\n#endif\n                }\n              else\n                {\n                  /* +option or -option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                  n = __asprintf (&buf, _(\"%s: unrecognized option '%c%s'\\n\"),\n                                  argv[0], argv[d->optind][0], d->__nextchar);\n#else\n                  fprintf (stderr, _(\"%s: unrecognized option '%c%s'\\n\"),\n                           argv[0], argv[d->optind][0], d->__nextchar);\n#endif\n                }\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              if (n >= 0)\n                {\n                  _IO_flockfile (stderr);\n\n                  int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                  ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                  __fxprintf (NULL, \"%s\", buf);\n\n                  ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                  _IO_funlockfile (stderr);\n\n                  free (buf);\n                }\n#endif\n            }\n          d->__nextchar = (char *) \"\";\n          d->optind++;\n          d->optopt = 0;\n          return '?';\n        }\n    }\n\n  /* Look at and handle the next short option-character.  */\n\n  {\n    char c = *d->__nextchar++;\n    const char *temp = strchr (optstring, c);\n\n    /* Increment 'optind' when we start to process its last character.  */\n    if (*d->__nextchar == '\\0')\n      ++d->optind;\n\n    if (temp == NULL || c == ':' || c == ';')\n      {\n        if (print_errors)\n          {\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf;\n              int n;\n#endif\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              n = __asprintf (&buf, _(\"%s: invalid option -- '%c'\\n\"),\n                              argv[0], c);\n#else\n              fprintf (stderr, _(\"%s: invalid option -- '%c'\\n\"), argv[0], c);\n#endif\n\n#if defined _LIBC && defined USE_IN_LIBIO\n            if (n >= 0)\n              {\n                _IO_flockfile (stderr);\n\n                int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                __fxprintf (NULL, \"%s\", buf);\n\n                ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                _IO_funlockfile (stderr);\n\n                free (buf);\n              }\n#endif\n          }\n        d->optopt = c;\n        return '?';\n      }\n    /* Convenience. Treat POSIX -W foo same as long option --foo */\n    if (temp[0] == 'W' && temp[1] == ';')\n      {\n        char *nameend;\n        const struct option *p;\n        const struct option *pfound = NULL;\n        int exact = 0;\n        int ambig = 0;\n        int indfound = 0;\n        int option_index;\n\n        if (longopts == NULL)\n          goto no_longs;\n\n        /* This is an option that requires an argument.  */\n        if (*d->__nextchar != '\\0')\n          {\n            d->optarg = d->__nextchar;\n            /* If we end this ARGV-element by taking the rest as an arg,\n               we must advance to the next element now.  */\n            d->optind++;\n          }\n        else if (d->optind == argc)\n          {\n            if (print_errors)\n              {\n#if defined _LIBC && defined USE_IN_LIBIO\n                char *buf;\n\n                if (__asprintf (&buf,\n                                _(\"%s: option requires an argument -- '%c'\\n\"),\n                                argv[0], c) >= 0)\n                  {\n                    _IO_flockfile (stderr);\n\n                    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                    __fxprintf (NULL, \"%s\", buf);\n\n                    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                    _IO_funlockfile (stderr);\n\n                    free (buf);\n                  }\n#else\n                fprintf (stderr,\n                         _(\"%s: option requires an argument -- '%c'\\n\"),\n                         argv[0], c);\n#endif\n              }\n            d->optopt = c;\n            if (optstring[0] == ':')\n              c = ':';\n            else\n              c = '?';\n            return c;\n          }\n        else\n          /* We already incremented 'd->optind' once;\n             increment it again when taking next ARGV-elt as argument.  */\n          d->optarg = argv[d->optind++];\n\n        /* optarg is now the argument, see if it's in the\n           table of longopts.  */\n\n        for (d->__nextchar = nameend = d->optarg; *nameend && *nameend != '=';\n             nameend++)\n          /* Do nothing.  */ ;\n\n        /* Test all long options for either exact match\n           or abbreviated matches.  */\n        for (p = longopts, option_index = 0; p->name; p++, option_index++)\n          if (!strncmp (p->name, d->__nextchar, nameend - d->__nextchar))\n            {\n              if ((unsigned int) (nameend - d->__nextchar) == strlen (p->name))\n                {\n                  /* Exact match found.  */\n                  pfound = p;\n                  indfound = option_index;\n                  exact = 1;\n                  break;\n                }\n              else if (pfound == NULL)\n                {\n                  /* First nonexact match found.  */\n                  pfound = p;\n                  indfound = option_index;\n                }\n              else if (long_only\n                       || pfound->has_arg != p->has_arg\n                       || pfound->flag != p->flag\n                       || pfound->val != p->val)\n                /* Second or later nonexact match found.  */\n                ambig = 1;\n            }\n        if (ambig && !exact)\n          {\n            if (print_errors)\n              {\n#if defined _LIBC && defined USE_IN_LIBIO\n                char *buf;\n\n                if (__asprintf (&buf, _(\"%s: option '-W %s' is ambiguous\\n\"),\n                                argv[0], d->optarg) >= 0)\n                  {\n                    _IO_flockfile (stderr);\n\n                    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                    __fxprintf (NULL, \"%s\", buf);\n\n                    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                    _IO_funlockfile (stderr);\n\n                    free (buf);\n                  }\n#else\n                fprintf (stderr, _(\"%s: option '-W %s' is ambiguous\\n\"),\n                         argv[0], d->optarg);\n#endif\n              }\n            d->__nextchar += strlen (d->__nextchar);\n            d->optind++;\n            return '?';\n          }\n        if (pfound != NULL)\n          {\n            option_index = indfound;\n            if (*nameend)\n              {\n                /* Don't test has_arg with >, because some C compilers don't\n                   allow it to be used on enums.  */\n                if (pfound->has_arg)\n                  d->optarg = nameend + 1;\n                else\n                  {\n                    if (print_errors)\n                      {\n#if defined _LIBC && defined USE_IN_LIBIO\n                        char *buf;\n\n                        if (__asprintf (&buf, _(\"\\\n%s: option '-W %s' doesn't allow an argument\\n\"),\n                                        argv[0], pfound->name) >= 0)\n                          {\n                            _IO_flockfile (stderr);\n\n                            int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                            ((_IO_FILE *) stderr)->_flags2\n                              |= _IO_FLAGS2_NOTCANCEL;\n\n                            __fxprintf (NULL, \"%s\", buf);\n\n                            ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                            _IO_funlockfile (stderr);\n\n                            free (buf);\n                          }\n#else\n                        fprintf (stderr, _(\"\\\n%s: option '-W %s' doesn't allow an argument\\n\"),\n                                 argv[0], pfound->name);\n#endif\n                      }\n\n                    d->__nextchar += strlen (d->__nextchar);\n                    return '?';\n                  }\n              }\n            else if (pfound->has_arg == 1)\n              {\n                if (d->optind < argc)\n                  d->optarg = argv[d->optind++];\n                else\n                  {\n                    if (print_errors)\n                      {\n#if defined _LIBC && defined USE_IN_LIBIO\n                        char *buf;\n\n                        if (__asprintf (&buf, _(\"\\\n%s: option '-W %s' requires an argument\\n\"),\n                                        argv[0], pfound->name) >= 0)\n                          {\n                            _IO_flockfile (stderr);\n\n                            int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                            ((_IO_FILE *) stderr)->_flags2\n                              |= _IO_FLAGS2_NOTCANCEL;\n\n                            __fxprintf (NULL, \"%s\", buf);\n\n                            ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                            _IO_funlockfile (stderr);\n\n                            free (buf);\n                          }\n#else\n                        fprintf (stderr, _(\"\\\n%s: option '-W %s' requires an argument\\n\"),\n                                 argv[0], pfound->name);\n#endif\n                      }\n                    d->__nextchar += strlen (d->__nextchar);\n                    return optstring[0] == ':' ? ':' : '?';\n                  }\n              }\n            else\n              d->optarg = NULL;\n            d->__nextchar += strlen (d->__nextchar);\n            if (longind != NULL)\n              *longind = option_index;\n            if (pfound->flag)\n              {\n                *(pfound->flag) = pfound->val;\n                return 0;\n              }\n            return pfound->val;\n          }\n\n      no_longs:\n        d->__nextchar = NULL;\n        return 'W';   /* Let the application handle it.   */\n      }\n    if (temp[1] == ':')\n      {\n        if (temp[2] == ':')\n          {\n            /* This is an option that accepts an argument optionally.  */\n            if (*d->__nextchar != '\\0')\n              {\n                d->optarg = d->__nextchar;\n                d->optind++;\n              }\n            else\n              d->optarg = NULL;\n            d->__nextchar = NULL;\n          }\n        else\n          {\n            /* This is an option that requires an argument.  */\n            if (*d->__nextchar != '\\0')\n              {\n                d->optarg = d->__nextchar;\n                /* If we end this ARGV-element by taking the rest as an arg,\n                   we must advance to the next element now.  */\n                d->optind++;\n              }\n            else if (d->optind == argc)\n              {\n                if (print_errors)\n                  {\n#if defined _LIBC && defined USE_IN_LIBIO\n                    char *buf;\n\n                    if (__asprintf (&buf, _(\"\\\n%s: option requires an argument -- '%c'\\n\"),\n                                    argv[0], c) >= 0)\n                      {\n                        _IO_flockfile (stderr);\n\n                        int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                        ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                        __fxprintf (NULL, \"%s\", buf);\n\n                        ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                        _IO_funlockfile (stderr);\n\n                        free (buf);\n                      }\n#else\n                    fprintf (stderr,\n                             _(\"%s: option requires an argument -- '%c'\\n\"),\n                             argv[0], c);\n#endif\n                  }\n                d->optopt = c;\n                if (optstring[0] == ':')\n                  c = ':';\n                else\n                  c = '?';\n              }\n            else\n              /* We already incremented 'optind' once;\n                 increment it again when taking next ARGV-elt as argument.  */\n              d->optarg = argv[d->optind++];\n            d->__nextchar = NULL;\n          }\n      }\n    return c;\n  }\n}",
      "lines": 811,
      "depth": 25,
      "decorators": [
        "int"
      ]
    },
    "_getopt_internal": {
      "start_point": [
        1156,
        0
      ],
      "end_point": [
        1175,
        1
      ],
      "content": "int\n_getopt_internal (int argc, char **argv, const char *optstring,\n                  const struct option *longopts, int *longind, int long_only,\n                  int posixly_correct)\n{\n  int result;\n\n  getopt_data.optind = optind;\n  getopt_data.opterr = opterr;\n\n  result = _getopt_internal_r (argc, argv, optstring, longopts,\n                               longind, long_only, &getopt_data,\n                               posixly_correct);\n\n  optind = getopt_data.optind;\n  optarg = getopt_data.optarg;\n  optopt = getopt_data.optopt;\n\n  return result;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "getopt": {
      "start_point": [
        1185,
        0
      ],
      "end_point": [
        1192,
        1
      ],
      "content": "int\ngetopt (int argc, char *const *argv, const char *optstring)\n{\n  return _getopt_internal (argc, (char **) argv, optstring,\n                           (const struct option *) 0,\n                           (int *) 0,\n                           0, POSIXLY_CORRECT);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "__posix_getopt": {
      "start_point": [
        1195,
        0
      ],
      "end_point": [
        1202,
        1
      ],
      "content": "int\n__posix_getopt (int argc, char *const *argv, const char *optstring)\n{\n  return _getopt_internal (argc, argv, optstring,\n                           (const struct option *) 0,\n                           (int *) 0,\n                           0, 1);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        1211,
        0
      ],
      "end_point": [
        1272,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n\n      c = getopt (argc, argv, \"abc:d:0123456789\");\n      if (c == -1)\n        break;\n\n      switch (c)\n        {\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (digit_optind != 0 && digit_optind != this_option_optind)\n            printf (\"digits occur in two different argv-elements.\\n\");\n          digit_optind = this_option_optind;\n          printf (\"option %c\\n\", c);\n          break;\n\n        case 'a':\n          printf (\"option a\\n\");\n          break;\n\n        case 'b':\n          printf (\"option b\\n\");\n          break;\n\n        case 'c':\n          printf (\"option c with value '%s'\\n\", optarg);\n          break;\n\n        case '?':\n          break;\n\n        default:\n          printf (\"?? getopt returned character code 0%o ??\\n\", c);\n        }\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n        printf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/gl/getopt.in.h": {},
  "libtasn1/libtasn1-4.13/gl/getopt1.c": {
    "getopt_long": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "int\ngetopt_long (int argc, char *__getopt_argv_const *argv, const char *options,\n             const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n                           opt_index, 0, 0);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_r": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\n_getopt_long_r (int argc, char **argv, const char *options,\n                const struct option *long_options, int *opt_index,\n                struct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n                             0, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "getopt_long_only": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\ngetopt_long_only (int argc, char *__getopt_argv_const *argv,\n                  const char *options,\n                  const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n                           opt_index, 1, 0);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_only_r": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "int\n_getopt_long_only_r (int argc, char **argv, const char *options,\n                     const struct option *long_options, int *opt_index,\n                     struct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n                             1, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n      int option_index = 0;\n      static const struct option long_options[] =\n      {\n        {\"add\", 1, 0, 0},\n        {\"append\", 0, 0, 0},\n        {\"delete\", 1, 0, 0},\n        {\"verbose\", 0, 0, 0},\n        {\"create\", 0, 0, 0},\n        {\"file\", 1, 0, 0},\n        {0, 0, 0, 0}\n      };\n\n      c = getopt_long (argc, argv, \"abc:d:0123456789\",\n                       long_options, &option_index);\n      if (c == -1)\n        break;\n\n      switch (c)\n        {\n        case 0:\n          printf (\"option %s\", long_options[option_index].name);\n          if (optarg)\n            printf (\" with arg %s\", optarg);\n          printf (\"\\n\");\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (digit_optind != 0 && digit_optind != this_option_optind)\n            printf (\"digits occur in two different argv-elements.\\n\");\n          digit_optind = this_option_optind;\n          printf (\"option %c\\n\", c);\n          break;\n\n        case 'a':\n          printf (\"option a\\n\");\n          break;\n\n        case 'b':\n          printf (\"option b\\n\");\n          break;\n\n        case 'c':\n          printf (\"option c with value '%s'\\n\", optarg);\n          break;\n\n        case 'd':\n          printf (\"option d with value '%s'\\n\", optarg);\n          break;\n\n        case '?':\n          break;\n\n        default:\n          printf (\"?? getopt returned character code 0%o ??\\n\", c);\n        }\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n        printf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 85,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/gl/getopt_int.h": {},
  "libtasn1/libtasn1-4.13/gl/gettext.h": {
    "pgettext_aux": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static const char *\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)\n{\n  const char *translation = dcgettext (domain, msg_ctxt_id, category);\n  if (translation == msg_ctxt_id)\n    return msgid;\n  else\n    return translation;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)",
        "*"
      ]
    },
    "npgettext_aux": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "static const char *\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)\n{\n  const char *translation =\n    dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n  if (translation == msg_ctxt_id || translation == msgid_plural)\n    return (n == 1 ? msgid : msgid_plural);\n  else\n    return translation;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)",
        "*"
      ]
    },
    "dcpgettext_expr": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "static const char *\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      int found_translation;\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcgettext (domain, msg_ctxt_id, category);\n      found_translation = (translation != msg_ctxt_id);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (found_translation)\n        return translation;\n    }\n  return msgid;\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)",
        "*"
      ]
    },
    "dcnpgettext_expr": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "static const char *\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      int found_translation;\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n      found_translation = !(translation == msg_ctxt_id || translation == msgid_plural);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (found_translation)\n        return translation;\n    }\n  return (n == 1 ? msgid : msgid_plural);\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)",
        "*"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/gl/gettime.c": {
    "gettime": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "void\ngettime (struct timespec *ts)\n{\n#if HAVE_NANOTIME\n  nanotime (ts);\n#else\n\n# if defined CLOCK_REALTIME && HAVE_CLOCK_GETTIME\n  if (clock_gettime (CLOCK_REALTIME, ts) == 0)\n    return;\n# endif\n\n  {\n    struct timeval tv;\n    gettimeofday (&tv, NULL);\n    ts->tv_sec = tv.tv_sec;\n    ts->tv_nsec = tv.tv_usec * 1000;\n  }\n\n#endif\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/gl/gettimeofday.c": {
    "rpl_localtime": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "struct tm *\nrpl_localtime (time_t const *timep)\n{\n  struct tm *tm = localtime (timep);\n\n  if (localtime_buffer_addr == &tm_zero_buffer)\n    localtime_buffer_addr = tm;\n\n  return tm;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nrpl_localtime (time_t const *timep)",
        "*"
      ]
    },
    "rpl_gmtime": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "struct tm *\nrpl_gmtime (time_t const *timep)\n{\n  struct tm *tm = gmtime (timep);\n\n  if (localtime_buffer_addr == &tm_zero_buffer)\n    localtime_buffer_addr = tm;\n\n  return tm;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nrpl_gmtime (time_t const *timep)",
        "*"
      ]
    },
    "rpl_tzset": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "void\nrpl_tzset (void)\n{\n  /* Save and restore the contents of the buffer used for localtime's\n     result around the call to tzset.  */\n  struct tm save = *localtime_buffer_addr;\n  tzset ();\n  *localtime_buffer_addr = save;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gettimeofday": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "int\ngettimeofday (struct timeval *restrict tv, void *restrict tz)\n{\n#undef gettimeofday\n#if HAVE_GETTIMEOFDAY\n# if GETTIMEOFDAY_CLOBBERS_LOCALTIME\n  /* Save and restore the contents of the buffer used for localtime's\n     result around the call to gettimeofday.  */\n  struct tm save = *localtime_buffer_addr;\n# endif\n\n# if defined timeval /* 'struct timeval' overridden by gnulib?  */\n#  undef timeval\n  struct timeval otv;\n  int result = gettimeofday (&otv, (struct timezone *) tz);\n  if (result == 0)\n    {\n      tv->tv_sec = otv.tv_sec;\n      tv->tv_usec = otv.tv_usec;\n    }\n# else\n  int result = gettimeofday (tv, (struct timezone *) tz);\n# endif\n\n# if GETTIMEOFDAY_CLOBBERS_LOCALTIME\n  *localtime_buffer_addr = save;\n# endif\n\n  return result;\n\n#else\n\n# if HAVE__FTIME\n\n  struct _timeb timebuf;\n  _ftime (&timebuf);\n  tv->tv_sec = timebuf.time;\n  tv->tv_usec = timebuf.millitm * 1000;\n\n# else\n\n#  if !defined OK_TO_USE_1S_CLOCK\n#   error \"Only 1-second nominal clock resolution found.  Is that intended?\" \\\n          \"If so, compile with the -DOK_TO_USE_1S_CLOCK option.\"\n#  endif\n  tv->tv_sec = time (NULL);\n  tv->tv_usec = 0;\n\n# endif\n\n  return 0;\n\n#endif\n}",
      "lines": 54,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/gl/limits.in.h": {},
  "libtasn1/libtasn1-4.13/gl/lseek.c": {
    "rpl_lseek": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "off_t\nrpl_lseek (int fd, off_t offset, int whence)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* mingw lseek mistakenly succeeds on pipes, sockets, and terminals.  */\n  HANDLE h = (HANDLE) _get_osfhandle (fd);\n  if (h == INVALID_HANDLE_VALUE)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  if (GetFileType (h) != FILE_TYPE_DISK)\n    {\n      errno = ESPIPE;\n      return -1;\n    }\n#else\n  /* BeOS lseek mistakenly succeeds on pipes...  */\n  struct stat statbuf;\n  if (fstat (fd, &statbuf) < 0)\n    return -1;\n  if (!S_ISREG (statbuf.st_mode))\n    {\n      errno = ESPIPE;\n      return -1;\n    }\n#endif\n#if _GL_WINDOWS_64_BIT_OFF_T\n  return _lseeki64 (fd, offset, whence);\n#else\n  return lseek (fd, offset, whence);\n#endif\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "off_t"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/gl/malloc.c": {
    "rpl_malloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void *\nrpl_malloc (size_t n)\n{\n  void *result;\n\n#if NEED_MALLOC_GNU\n  if (n == 0)\n    n = 1;\n#endif\n\n  result = malloc (n);\n\n#if !HAVE_MALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "void",
        "*\nrpl_malloc (size_t n)",
        "*"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/gl/msvc-inval.c": {
    "gl_msvc_invalid_parameter_handler": [
      {
        "start_point": [
          30,
          0
        ],
        "end_point": [
          37,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n}",
        "lines": 8,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          47,
          0
        ],
        "end_point": [
          55,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 9,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          96,
          0
        ],
        "end_point": [
          110,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  struct gl_msvc_inval_per_thread *current = gl_msvc_inval_current ();\n  if (current->restart_valid)\n    longjmp (current->restart, 1);\n  else\n    /* An invalid parameter notification from outside the gnulib code.\n       Give the caller a chance to intervene.  */\n    RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      }
    ],
    "gl_msvc_inval_current": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "struct gl_msvc_inval_per_thread *\ngl_msvc_inval_current (void)\n{\n  if (!tls_initialized)\n    {\n      tls_index = TlsAlloc ();\n      tls_initialized = 1;\n    }\n  if (tls_index == TLS_OUT_OF_INDEXES)\n    /* TlsAlloc had failed.  */\n    return &not_per_thread;\n  else\n    {\n      struct gl_msvc_inval_per_thread *pointer =\n        (struct gl_msvc_inval_per_thread *) TlsGetValue (tls_index);\n      if (pointer == NULL)\n        {\n          /* First call.  Allocate a new 'struct gl_msvc_inval_per_thread'.  */\n          pointer =\n            (struct gl_msvc_inval_per_thread *)\n            malloc (sizeof (struct gl_msvc_inval_per_thread));\n          if (pointer == NULL)\n            /* Could not allocate memory.  Use the global storage.  */\n            pointer = &not_per_thread;\n          TlsSetValue (tls_index, pointer);\n        }\n      return pointer;\n    }\n}",
      "lines": 29,
      "depth": 15,
      "decorators": [
        "struct gl_msvc_inval_per_thread",
        "struct",
        "gl_msvc_inval_per_thread",
        "*\ngl_msvc_inval_current (void)",
        "*"
      ]
    },
    "gl_msvc_inval_ensure_handler": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "void\ngl_msvc_inval_ensure_handler (void)\n{\n  if (gl_msvc_inval_initialized == 0)\n    {\n      _set_invalid_parameter_handler (gl_msvc_invalid_parameter_handler);\n      gl_msvc_inval_initialized = 1;\n    }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/gl/msvc-inval.h": {},
  "libtasn1/libtasn1-4.13/gl/msvc-nothrow.c": {
    "_gl_nothrow_get_osfhandle": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        39,
        5
      ],
      "content": "intptr_t\n_gl_nothrow_get_osfhandle (int fd)\n{\n  intptr_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _get_osfhandle (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "intptr_t"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/gl/msvc-nothrow.h": {},
  "libtasn1/libtasn1-4.13/gl/progname.c": {
    "set_program_name": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "void\nset_program_name (const char *argv0)\n{\n  /* libtool creates a temporary executable whose name is sometimes prefixed\n     with \"lt-\" (depends on the platform).  It also makes argv[0] absolute.\n     But the name of the temporary executable is a detail that should not be\n     visible to the end user and to the test suite.\n     Remove this \"<dirname>/.libs/\" or \"<dirname>/.libs/lt-\" prefix here.  */\n  const char *slash;\n  const char *base;\n\n  /* Sanity check.  POSIX requires the invoking process to pass a non-NULL\n     argv[0].  */\n  if (argv0 == NULL)\n    {\n      /* It's a bug in the invoking program.  Help diagnosing it.  */\n      fputs (\"A NULL argv[0] was passed through an exec system call.\\n\",\n             stderr);\n      abort ();\n    }\n\n  slash = strrchr (argv0, '/');\n  base = (slash != NULL ? slash + 1 : argv0);\n  if (base - argv0 >= 7 && strncmp (base - 7, \"/.libs/\", 7) == 0)\n    {\n      argv0 = base;\n      if (strncmp (base, \"lt-\", 3) == 0)\n        {\n          argv0 = base + 3;\n          /* On glibc systems, remove the \"lt-\" prefix from the variable\n             program_invocation_short_name.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME\n          program_invocation_short_name = (char *) argv0;\n#endif\n        }\n    }\n\n  /* But don't strip off a leading <dirname>/ in general, because when the user\n     runs\n         /some/hidden/place/bin/cp foo foo\n     he should get the error message\n         /some/hidden/place/bin/cp: `foo' and `foo' are the same file\n     not\n         cp: `foo' and `foo' are the same file\n   */\n\n  program_name = argv0;\n\n  /* On glibc systems, the error() function comes from libc and uses the\n     variable program_invocation_name, not program_name.  So set this variable\n     as well.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_NAME\n  program_invocation_name = (char *) argv0;\n#endif\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/gl/progname.h": {},
  "libtasn1/libtasn1-4.13/gl/read-file.c": {
    "fread_file": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "char *\nfread_file (FILE *stream, size_t *length)\n{\n  char *buf = NULL;\n  size_t alloc = BUFSIZ;\n\n  /* For a regular file, allocate a buffer that has exactly the right\n     size.  This avoids the need to do dynamic reallocations later.  */\n  {\n    struct stat st;\n\n    if (fstat (fileno (stream), &st) >= 0 && S_ISREG (st.st_mode))\n      {\n        off_t pos = ftello (stream);\n\n        if (pos >= 0 && pos < st.st_size)\n          {\n            off_t alloc_off = st.st_size - pos;\n\n            /* '1' below, accounts for the trailing NUL.  */\n            if (SIZE_MAX - 1 < alloc_off)\n              {\n                errno = ENOMEM;\n                return NULL;\n              }\n\n            alloc = alloc_off + 1;\n          }\n      }\n  }\n\n  if (!(buf = malloc (alloc)))\n    return NULL; /* errno is ENOMEM.  */\n\n  {\n    size_t size = 0; /* number of bytes read so far */\n    int save_errno;\n\n    for (;;)\n      {\n        /* This reads 1 more than the size of a regular file\n           so that we get eof immediately.  */\n        size_t requested = alloc - size;\n        size_t count = fread (buf + size, 1, requested, stream);\n        size += count;\n\n        if (count != requested)\n          {\n            save_errno = errno;\n            if (ferror (stream))\n              break;\n\n            /* Shrink the allocated memory if possible.  */\n            if (size < alloc - 1)\n              {\n                char *smaller_buf = realloc (buf, size + 1);\n                if (smaller_buf != NULL)\n                  buf = smaller_buf;\n              }\n\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n          }\n\n        {\n          char *new_buf;\n\n          if (alloc == SIZE_MAX)\n            {\n              save_errno = ENOMEM;\n              break;\n            }\n\n          if (alloc < SIZE_MAX - alloc / 2)\n            alloc = alloc + alloc / 2;\n          else\n            alloc = SIZE_MAX;\n\n          if (!(new_buf = realloc (buf, alloc)))\n            {\n              save_errno = errno;\n              break;\n            }\n\n          buf = new_buf;\n        }\n      }\n\n    free (buf);\n    errno = save_errno;\n    return NULL;\n  }\n}",
      "lines": 94,
      "depth": 15,
      "decorators": [
        "char",
        "*\nfread_file (FILE *stream, size_t *length)",
        "*"
      ]
    },
    "internal_read_file": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "static char *\ninternal_read_file (const char *filename, size_t *length, const char *mode)\n{\n  FILE *stream = fopen (filename, mode);\n  char *out;\n  int save_errno;\n\n  if (!stream)\n    return NULL;\n\n  out = fread_file (stream, length);\n\n  save_errno = errno;\n\n  if (fclose (stream) != 0)\n    {\n      if (out)\n        {\n          save_errno = errno;\n          free (out);\n        }\n      errno = save_errno;\n      return NULL;\n    }\n\n  return out;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ninternal_read_file (const char *filename, size_t *length, const char *mode)",
        "*"
      ]
    },
    "read_file": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "char *\nread_file (const char *filename, size_t *length)\n{\n  return internal_read_file (filename, length, \"r\");\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nread_file (const char *filename, size_t *length)",
        "*"
      ]
    },
    "read_binary_file": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "char *\nread_binary_file (const char *filename, size_t *length)\n{\n  return internal_read_file (filename, length, \"rb\");\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nread_binary_file (const char *filename, size_t *length)",
        "*"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/gl/read-file.h": {},
  "libtasn1/libtasn1-4.13/gl/realloc.c": {
    "rpl_realloc": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void *\nrpl_realloc (void *p, size_t n)\n{\n  void *result;\n\n#if NEED_REALLOC_GNU\n  if (n == 0)\n    {\n      n = 1;\n\n      /* In theory realloc might fail, so don't rely on it to free.  */\n      free (p);\n      p = NULL;\n    }\n#endif\n\n  if (p == NULL)\n    {\n#if GNULIB_REALLOC_GNU && !NEED_REALLOC_GNU && !SYSTEM_MALLOC_GLIBC_COMPATIBLE\n      if (n == 0)\n        n = 1;\n#endif\n      result = malloc (n);\n    }\n  else\n    result = realloc (p, n);\n\n#if !HAVE_REALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "void",
        "*\nrpl_realloc (void *p, size_t n)",
        "*"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/gl/stdarg.in.h": {},
  "libtasn1/libtasn1-4.13/gl/stddef.in.h": {},
  "libtasn1/libtasn1-4.13/gl/stdint.in.h": {},
  "libtasn1/libtasn1-4.13/gl/stdio-impl.h": {},
  "libtasn1/libtasn1-4.13/gl/stdio.in.h": {},
  "libtasn1/libtasn1-4.13/gl/stdlib.in.h": {},
  "libtasn1/libtasn1-4.13/gl/sys_stat.in.h": {
    "rpl_mkdir": {
      "start_point": [
        503,
        0
      ],
      "end_point": [
        507,
        1
      ],
      "content": "static int\nrpl_mkdir (char const *name, mode_t mode)\n{\n  return _mkdir (name);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/gl/sys_time.in.h": {
    "GNULIB_NAMESPACE": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "namespace GNULIB_NAMESPACE {\n  typedef ::timeval\n#undef timeval\n    timeval;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": null
    }
  },
  "libtasn1/libtasn1-4.13/gl/sys_types.in.h": {},
  "libtasn1/libtasn1-4.13/gl/time.in.h": {},
  "libtasn1/libtasn1-4.13/gl/timespec.c": {},
  "libtasn1/libtasn1-4.13/gl/timespec.h": {
    "make_timespec": {
      "start_point": [
        39,
        27
      ],
      "end_point": [
        46,
        1
      ],
      "content": "timespec\nmake_timespec (time_t s, long int ns)\n{\n  struct timespec r;\n  r.tv_sec = s;\n  r.tv_nsec = ns;\n  return r;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "timespec"
      ]
    },
    "timespec_cmp": {
      "start_point": [
        76,
        24
      ],
      "end_point": [
        82,
        1
      ],
      "content": "_GL_ATTRIBUTE_PURE\ntimespec_cmp (struct timespec a, struct timespec b)\n{\n  return (a.tv_sec < b.tv_sec ? -1\n          : a.tv_sec > b.tv_sec ? 1\n          : (int) (a.tv_nsec - b.tv_nsec));\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "timespec_sign": {
      "start_point": [
        86,
        24
      ],
      "end_point": [
        90,
        1
      ],
      "content": "_GL_ATTRIBUTE_PURE\ntimespec_sign (struct timespec a)\n{\n  return a.tv_sec < 0 ? -1 : a.tv_sec || a.tv_nsec;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "timespectod": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "_GL_TIMESPEC_INLINE double\ntimespectod (struct timespec a)\n{\n  return a.tv_sec + a.tv_nsec / 1e9;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "_GL_TIMESPEC_INLINE",
        "double",
        "double"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/gl/unistd.c": {},
  "libtasn1/libtasn1-4.13/gl/unistd.in.h": {
    "rpl_environ": {
      "start_point": [
        427,
        0
      ],
      "end_point": [
        431,
        1
      ],
      "content": "_GL_UNISTD_INLINE char ***\nrpl_environ (void)\n{\n  return &environ;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "char",
        "char",
        "***\nrpl_environ (void)",
        "*",
        "**\nrpl_environ (void)",
        "*",
        "*\nrpl_environ (void)",
        "*"
      ]
    },
    "getpagesize": {
      "start_point": [
        894,
        0
      ],
      "end_point": [
        898,
        1
      ],
      "content": "_GL_UNISTD_INLINE int\ngetpagesize ()\n{\n  return _gl_getpagesize ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "int",
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/gl/version-etc-fsf.c": {},
  "libtasn1/libtasn1-4.13/gl/version-etc.c": {
    "version_etc_arn": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "void\nversion_etc_arn (FILE *stream,\n                 const char *command_name, const char *package,\n                 const char *version,\n                 const char * const * authors, size_t n_authors)\n{\n  if (command_name)\n    fprintf (stream, \"%s (%s) %s\\n\", command_name, package, version);\n  else\n    fprintf (stream, \"%s %s\\n\", package, version);\n\n#ifdef PACKAGE_PACKAGER\n# ifdef PACKAGE_PACKAGER_VERSION\n  fprintf (stream, _(\"Packaged by %s (%s)\\n\"), PACKAGE_PACKAGER,\n           PACKAGE_PACKAGER_VERSION);\n# else\n  fprintf (stream, _(\"Packaged by %s\\n\"), PACKAGE_PACKAGER);\n# endif\n#endif\n\n  /* TRANSLATORS: Translate \"(C)\" to the copyright symbol\n     (C-in-a-circle), if this symbol is available in the user's\n     locale.  Otherwise, do not translate \"(C)\"; leave it as-is.  */\n  fprintf (stream, version_etc_copyright, _(\"(C)\"), COPYRIGHT_YEAR);\n\n  fputs (_(\"\\\n\\n\\\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\\n\\\nThis is free software: you are free to change and redistribute it.\\n\\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\\n\\n\\\n\"),\n         stream);\n\n  switch (n_authors)\n    {\n    case 0:\n      /* The caller must provide at least one author name.  */\n      abort ();\n    case 1:\n      /* TRANSLATORS: %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s.\\n\"), authors[0]);\n      break;\n    case 2:\n      /* TRANSLATORS: Each %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s and %s.\\n\"), authors[0], authors[1]);\n      break;\n    case 3:\n      /* TRANSLATORS: Each %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2]);\n      break;\n    case 4:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\nand %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3]);\n      break;\n    case 5:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4]);\n      break;\n    case 6:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5]);\n      break;\n    case 7:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5], authors[6]);\n      break;\n    case 8:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\"),\n                authors[0], authors[1], authors[2], authors[3], authors[4],\n                authors[5], authors[6], authors[7]);\n      break;\n    case 9:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5], authors[6], authors[7], authors[8]);\n      break;\n    default:\n      /* 10 or more authors.  Use an abbreviation, since the human reader\n         will probably not want to read the entire list anyway.  */\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\"),\n                authors[0], authors[1], authors[2], authors[3], authors[4],\n                authors[5], authors[6], authors[7], authors[8]);\n      break;\n    }\n}",
      "lines": 113,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "version_etc_ar": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "void\nversion_etc_ar (FILE *stream,\n                const char *command_name, const char *package,\n                const char *version, const char * const * authors)\n{\n  size_t n_authors;\n\n  for (n_authors = 0; authors[n_authors]; n_authors++)\n    ;\n  version_etc_arn (stream, command_name, package, version, authors, n_authors);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "version_etc_va": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "void\nversion_etc_va (FILE *stream,\n                const char *command_name, const char *package,\n                const char *version, va_list authors)\n{\n  size_t n_authors;\n  const char *authtab[10];\n\n  for (n_authors = 0;\n       n_authors < 10\n         && (authtab[n_authors] = va_arg (authors, const char *)) != NULL;\n       n_authors++)\n    ;\n  version_etc_arn (stream, command_name, package, version,\n                   authtab, n_authors);\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "version_etc": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "void\nversion_etc (FILE *stream,\n             const char *command_name, const char *package,\n             const char *version, /* const char *author1, ...*/ ...)\n{\n  va_list authors;\n\n  va_start (authors, version);\n  version_etc_va (stream, command_name, package, version, authors);\n  va_end (authors);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "emit_bug_reporting_address": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "void\nemit_bug_reporting_address (void)\n{\n  /* TRANSLATORS: The placeholder indicates the bug-reporting address\n     for this package.  Please add _another line_ saying\n     \"Report translation bugs to <...>\\n\" with the address for translation\n     bugs (typically your translation team's web or email address).  */\n  printf (_(\"\\nReport bugs to: %s\\n\"), PACKAGE_BUGREPORT);\n#ifdef PACKAGE_PACKAGER_BUG_REPORTS\n  printf (_(\"Report %s bugs to: %s\\n\"), PACKAGE_PACKAGER,\n          PACKAGE_PACKAGER_BUG_REPORTS);\n#endif\n#ifdef PACKAGE_URL\n  printf (_(\"%s home page: <%s>\\n\"), PACKAGE_NAME, PACKAGE_URL);\n#else\n  printf (_(\"%s home page: <http://www.gnu.org/software/%s/>\\n\"),\n          PACKAGE_NAME, PACKAGE);\n#endif\n  fputs (_(\"General help using GNU software: <http://www.gnu.org/gethelp/>\\n\"),\n         stdout);\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/gl/version-etc.h": {},
  "libtasn1/libtasn1-4.13/lib/ASN1.c": {
    "yy_symbol_value_print": {
      "start_point": [
        933,
        0
      ],
      "end_point": [
        945,
        1
      ],
      "content": "static void\nyy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)\n{\n  FILE *yyo = yyoutput;\n  YYUSE (yyo);\n  if (!yyvaluep)\n    return;\n# ifdef YYPRINT\n  if (yytype < YYNTOKENS)\n    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);\n# endif\n  YYUSE (yytype);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_symbol_print": {
      "start_point": [
        952,
        0
      ],
      "end_point": [
        960,
        1
      ],
      "content": "static void\nyy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)\n{\n  YYFPRINTF (yyoutput, \"%s %s (\",\n             yytype < YYNTOKENS ? \"token\" : \"nterm\", yytname[yytype]);\n\n  yy_symbol_value_print (yyoutput, yytype, yyvaluep);\n  YYFPRINTF (yyoutput, \")\");\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_stack_print": {
      "start_point": [
        967,
        0
      ],
      "end_point": [
        977,
        1
      ],
      "content": "static void\nyy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)\n{\n  YYFPRINTF (stderr, \"Stack now\");\n  for (; yybottom <= yytop; yybottom++)\n    {\n      int yybot = *yybottom;\n      YYFPRINTF (stderr, \" %d\", yybot);\n    }\n  YYFPRINTF (stderr, \"\\n\");\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_reduce_print": {
      "start_point": [
        990,
        0
      ],
      "end_point": [
        1008,
        1
      ],
      "content": "static void\nyy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule)\n{\n  unsigned long int yylno = yyrline[yyrule];\n  int yynrhs = yyr2[yyrule];\n  int yyi;\n  YYFPRINTF (stderr, \"Reducing stack by rule %d (line %lu):\\n\",\n             yyrule - 1, yylno);\n  /* The symbols being reduced.  */\n  for (yyi = 0; yyi < yynrhs; yyi++)\n    {\n      YYFPRINTF (stderr, \"   $%d = \", yyi + 1);\n      yy_symbol_print (stderr,\n                       yystos[yyssp[yyi + 1 - yynrhs]],\n                       &(yyvsp[(yyi + 1) - (yynrhs)])\n                                              );\n      YYFPRINTF (stderr, \"\\n\");\n    }\n}",
      "lines": 19,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yystrlen": {
      "start_point": [
        1051,
        0
      ],
      "end_point": [
        1058,
        1
      ],
      "content": "static YYSIZE_T\nyystrlen (const char *yystr)\n{\n  YYSIZE_T yylen;\n  for (yylen = 0; yystr[yylen]; yylen++)\n    continue;\n  return yylen;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "yystpcpy": {
      "start_point": [
        1068,
        0
      ],
      "end_point": [
        1078,
        1
      ],
      "content": "static char *\nyystpcpy (char *yydest, const char *yysrc)\n{\n  char *yyd = yydest;\n  const char *yys = yysrc;\n\n  while ((*yyd++ = *yys++) != '\\0')\n    continue;\n\n  return yyd - 1;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nyystpcpy (char *yydest, const char *yysrc)",
        "*"
      ]
    },
    "yytnamerr": {
      "start_point": [
        1090,
        0
      ],
      "end_point": [
        1127,
        1
      ],
      "content": "static YYSIZE_T\nyytnamerr (char *yyres, const char *yystr)\n{\n  if (*yystr == '\"')\n    {\n      YYSIZE_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n        switch (*++yyp)\n          {\n          case '\\'':\n          case ',':\n            goto do_not_strip_quotes;\n\n          case '\\\\':\n            if (*++yyp != '\\\\')\n              goto do_not_strip_quotes;\n            /* Fall through.  */\n          default:\n            if (yyres)\n              yyres[yyn] = *yyp;\n            yyn++;\n            break;\n\n          case '\"':\n            if (yyres)\n              yyres[yyn] = '\\0';\n            return yyn;\n          }\n    do_not_strip_quotes: ;\n    }\n\n  if (! yyres)\n    return yystrlen (yystr);\n\n  return yystpcpy (yyres, yystr) - yyres;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "yysyntax_error": {
      "start_point": [
        1138,
        0
      ],
      "end_point": [
        1263,
        1
      ],
      "content": "static int\nyysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,\n                yytype_int16 *yyssp, int yytoken)\n{\n  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);\n  YYSIZE_T yysize = yysize0;\n  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n  /* Internationalized format string. */\n  const char *yyformat = YY_NULLPTR;\n  /* Arguments of yyformat. */\n  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n  /* Number of reported tokens (one for the \"unexpected\", one per\n     \"expected\"). */\n  int yycount = 0;\n\n  /* There are many possibilities here to consider:\n     - If this state is a consistent state with a default action, then\n       the only way this function was invoked is if the default action\n       is an error action.  In that case, don't check for expected\n       tokens because there are none.\n     - The only way there can be no lookahead present (in yychar) is if\n       this state is a consistent state with a default action.  Thus,\n       detecting the absence of a lookahead is sufficient to determine\n       that there is no unexpected or expected token to report.  In that\n       case, just report a simple \"syntax error\".\n     - Don't assume there isn't a lookahead just because this state is a\n       consistent state with a default action.  There might have been a\n       previous inconsistent state, consistent state with a non-default\n       action, or user semantic action that manipulated yychar.\n     - Of course, the expected token list depends on states to have\n       correct lookahead information, and it depends on the parser not\n       to perform extra reductions after fetching a lookahead from the\n       scanner and before detecting a syntax error.  Thus, state merging\n       (from LALR or IELR) and default reductions corrupt the expected\n       token list.  However, the list is correct for canonical LR with\n       one exception: it will still contain any token that will not be\n       accepted due to an error action in a later state.\n  */\n  if (yytoken != YYEMPTY)\n    {\n      int yyn = yypact[*yyssp];\n      yyarg[yycount++] = yytname[yytoken];\n      if (!yypact_value_is_default (yyn))\n        {\n          /* Start YYX at -YYN if negative to avoid negative indexes in\n             YYCHECK.  In other words, skip the first -YYN actions for\n             this state because they are default actions.  */\n          int yyxbegin = yyn < 0 ? -yyn : 0;\n          /* Stay within bounds of both yycheck and yytname.  */\n          int yychecklim = YYLAST - yyn + 1;\n          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n          int yyx;\n\n          for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR\n                && !yytable_value_is_error (yytable[yyx + yyn]))\n              {\n                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n                  {\n                    yycount = 1;\n                    yysize = yysize0;\n                    break;\n                  }\n                yyarg[yycount++] = yytname[yyx];\n                {\n                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);\n                  if (! (yysize <= yysize1\n                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n                    return 2;\n                  yysize = yysize1;\n                }\n              }\n        }\n    }\n\n  switch (yycount)\n    {\n# define YYCASE_(N, S)                      \\\n      case N:                               \\\n        yyformat = S;                       \\\n      break\n      YYCASE_(0, YY_(\"syntax error\"));\n      YYCASE_(1, YY_(\"syntax error, unexpected %s\"));\n      YYCASE_(2, YY_(\"syntax error, unexpected %s, expecting %s\"));\n      YYCASE_(3, YY_(\"syntax error, unexpected %s, expecting %s or %s\"));\n      YYCASE_(4, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\"));\n      YYCASE_(5, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\"));\n# undef YYCASE_\n    }\n\n  {\n    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);\n    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n      return 2;\n    yysize = yysize1;\n  }\n\n  if (*yymsg_alloc < yysize)\n    {\n      *yymsg_alloc = 2 * yysize;\n      if (! (yysize <= *yymsg_alloc\n             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))\n        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;\n      return 1;\n    }\n\n  /* Avoid sprintf, as that infringes on the user's name space.\n     Don't have undefined behavior even if the translation\n     produced a string with the wrong number of \"%s\"s.  */\n  {\n    char *yyp = *yymsg;\n    int yyi = 0;\n    while ((*yyp = *yyformat) != '\\0')\n      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)\n        {\n          yyp += yytnamerr (yyp, yyarg[yyi++]);\n          yyformat += 2;\n        }\n      else\n        {\n          yyp++;\n          yyformat++;\n        }\n  }\n  return 0;\n}",
      "lines": 126,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yydestruct": {
      "start_point": [
        1270,
        0
      ],
      "end_point": [
        1281,
        1
      ],
      "content": "static void\nyydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)\n{\n  YYUSE (yyvaluep);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  YYUSE (yytype);\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yyparse": {
      "start_point": [
        1299,
        0
      ],
      "end_point": [
        2577,
        1
      ],
      "content": "int\nyyparse (void)\n{\n    int yystate;\n    /* Number of tokens to shift before error messages enabled.  */\n    int yyerrstatus;\n\n    /* The stacks and their tools:\n       'yyss': related to states.\n       'yyvs': related to semantic values.\n\n       Refer to the stacks through separate pointers, to allow yyoverflow\n       to reallocate them elsewhere.  */\n\n    /* The state stack.  */\n    yytype_int16 yyssa[YYINITDEPTH];\n    yytype_int16 *yyss;\n    yytype_int16 *yyssp;\n\n    /* The semantic value stack.  */\n    YYSTYPE yyvsa[YYINITDEPTH];\n    YYSTYPE *yyvs;\n    YYSTYPE *yyvsp;\n\n    YYSIZE_T yystacksize;\n\n  int yyn;\n  int yyresult;\n  /* Lookahead token as an internal (translated) token number.  */\n  int yytoken = 0;\n  /* The variables used to return semantic value and location from the\n     action routines.  */\n  YYSTYPE yyval;\n\n#if YYERROR_VERBOSE\n  /* Buffer for error messages, and its allocated size.  */\n  char yymsgbuf[128];\n  char *yymsg = yymsgbuf;\n  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n\n  /* The number of symbols on the RHS of the reduced rule.\n     Keep to zero when no symbol should be popped.  */\n  int yylen = 0;\n\n  yyssp = yyss = yyssa;\n  yyvsp = yyvs = yyvsa;\n  yystacksize = YYINITDEPTH;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY; /* Cause a token to be read.  */\n  goto yysetstate;\n\n/*------------------------------------------------------------.\n| yynewstate -- Push a new state, which is found in yystate.  |\n`------------------------------------------------------------*/\n yynewstate:\n  /* In all cases, when you get here, the value and location stacks\n     have just been pushed.  So pushing a state here evens the stacks.  */\n  yyssp++;\n\n yysetstate:\n  *yyssp = yystate;\n\n  if (yyss + yystacksize - 1 <= yyssp)\n    {\n      /* Get the current used size of the three stacks, in elements.  */\n      YYSIZE_T yysize = yyssp - yyss + 1;\n\n#ifdef yyoverflow\n      {\n        /* Give user a chance to reallocate the stack.  Use copies of\n           these so that the &'s don't force the real ones into\n           memory.  */\n        YYSTYPE *yyvs1 = yyvs;\n        yytype_int16 *yyss1 = yyss;\n\n        /* Each stack pointer address is followed by the size of the\n           data in use in that stack, in bytes.  This used to be a\n           conditional around just the two extra args, but that might\n           be undefined if yyoverflow is a macro.  */\n        yyoverflow (YY_(\"memory exhausted\"),\n                    &yyss1, yysize * sizeof (*yyssp),\n                    &yyvs1, yysize * sizeof (*yyvsp),\n                    &yystacksize);\n\n        yyss = yyss1;\n        yyvs = yyvs1;\n      }\n#else /* no yyoverflow */\n# ifndef YYSTACK_RELOCATE\n      goto yyexhaustedlab;\n# else\n      /* Extend the stack our own way.  */\n      if (YYMAXDEPTH <= yystacksize)\n        goto yyexhaustedlab;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n        yystacksize = YYMAXDEPTH;\n\n      {\n        yytype_int16 *yyss1 = yyss;\n        union yyalloc *yyptr =\n          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));\n        if (! yyptr)\n          goto yyexhaustedlab;\n        YYSTACK_RELOCATE (yyss_alloc, yyss);\n        YYSTACK_RELOCATE (yyvs_alloc, yyvs);\n#  undef YYSTACK_RELOCATE\n        if (yyss1 != yyssa)\n          YYSTACK_FREE (yyss1);\n      }\n# endif\n#endif /* no yyoverflow */\n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n\n      YYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",\n                  (unsigned long int) yystacksize));\n\n      if (yyss + yystacksize - 1 <= yyssp)\n        YYABORT;\n    }\n\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n\n  if (yystate == YYFINAL)\n    YYACCEPT;\n\n  goto yybackup;\n\n/*-----------.\n| yybackup.  |\n`-----------*/\nyybackup:\n\n  /* Do appropriate processing given the current state.  Read a\n     lookahead token if we need one and don't already have one.  */\n\n  /* First try to decide what to do without reference to lookahead token.  */\n  yyn = yypact[yystate];\n  if (yypact_value_is_default (yyn))\n    goto yydefault;\n\n  /* Not known => get a lookahead token if don't already have one.  */\n\n  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */\n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token: \"));\n      yychar = yylex ();\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = yytoken = YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n  /* If the proper action on seeing token YYTOKEN is to reduce or to\n     detect an error, take that action.  */\n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yytable_value_is_error (yyn))\n        goto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n  /* Count tokens shifted since error; after three, turn off error\n     status.  */\n  if (yyerrstatus)\n    yyerrstatus--;\n\n  /* Shift the lookahead token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n\n  /* Discard the shifted token.  */\n  yychar = YYEMPTY;\n\n  yystate = yyn;\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n  goto yynewstate;\n\n\n/*-----------------------------------------------------------.\n| yydefault -- do the default action for the current state.  |\n`-----------------------------------------------------------*/\nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n/*-----------------------------.\n| yyreduce -- Do a reduction.  |\n`-----------------------------*/\nyyreduce:\n  /* yyn is the number of a rule to reduce with.  */\n  yylen = yyr2[yyn];\n\n  /* If YYLEN is nonzero, implement the default value of the action:\n     '$$ = $1'.\n\n     Otherwise, the following line sets YYVAL to garbage.\n     This behavior is undocumented and Bison\n     users should not rely upon it.  Assigning to YYVAL\n     unconditionally makes the parser a bit smaller, and it avoids a\n     GCC warning that YYVAL may be used uninitialized.  */\n  yyval = yyvsp[1-yylen];\n\n\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n        case 2:\n#line 138 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_DEFINITIONS|(yyvsp[-5].constant));\n                    _asn1_set_name((yyval.node),_asn1_get_name((yyvsp[-7].node)));\n                    _asn1_set_name((yyvsp[-7].node),\"\");\n                    _asn1_set_right((yyvsp[-7].node),(yyvsp[-1].node));\n                    _asn1_set_down((yyval.node),(yyvsp[-7].node));\n\n\t\t    p_tree=(yyval.node);\n\t\t    }\n#line 1546 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 3:\n#line 148 \"ASN1.y\" /* yacc.c:1646  */\n    {snprintf((yyval.str),sizeof((yyval.str)),\"%s\",(yyvsp[0].str));}\n#line 1552 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 4:\n#line 149 \"ASN1.y\" /* yacc.c:1646  */\n    {snprintf((yyval.str),sizeof((yyval.str)),\"%s\",(yyvsp[0].str));}\n#line 1558 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 5:\n#line 152 \"ASN1.y\" /* yacc.c:1646  */\n    {snprintf((yyval.str),sizeof((yyval.str)),\"-%s\",(yyvsp[0].str));}\n#line 1564 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 6:\n#line 155 \"ASN1.y\" /* yacc.c:1646  */\n    {snprintf((yyval.str),sizeof((yyval.str)),\"%s\",(yyvsp[0].str));}\n#line 1570 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 7:\n#line 156 \"ASN1.y\" /* yacc.c:1646  */\n    {snprintf((yyval.str),sizeof((yyval.str)),\"%s\",(yyvsp[0].str));}\n#line 1576 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 8:\n#line 159 \"ASN1.y\" /* yacc.c:1646  */\n    {snprintf((yyval.str),sizeof((yyval.str)),\"%s\",(yyvsp[0].str));}\n#line 1582 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 9:\n#line 160 \"ASN1.y\" /* yacc.c:1646  */\n    {snprintf((yyval.str),sizeof((yyval.str)),\"%s\",(yyvsp[0].str));}\n#line 1588 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 10:\n#line 163 \"ASN1.y\" /* yacc.c:1646  */\n    {snprintf((yyval.str),sizeof((yyval.str)),\"%s\",(yyvsp[0].str));}\n#line 1594 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 11:\n#line 164 \"ASN1.y\" /* yacc.c:1646  */\n    {snprintf((yyval.str),sizeof((yyval.str)),\"-%s\",(yyvsp[0].str));}\n#line 1600 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 12:\n#line 165 \"ASN1.y\" /* yacc.c:1646  */\n    {snprintf((yyval.str),sizeof((yyval.str)),\"%s\",(yyvsp[0].str));}\n#line 1606 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 13:\n#line 168 \"ASN1.y\" /* yacc.c:1646  */\n    {snprintf((yyval.str),sizeof((yyval.str)),\"%s\",(yyvsp[0].str));}\n#line 1612 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 14:\n#line 169 \"ASN1.y\" /* yacc.c:1646  */\n    {snprintf((yyval.str),sizeof((yyval.str)),\"%s\",(yyvsp[0].str));}\n#line 1618 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 15:\n#line 172 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_CONSTANT);\n                                       _asn1_set_value((yyval.node),(yyvsp[-1].str),strlen((yyvsp[-1].str))+1);}\n#line 1625 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 16:\n#line 174 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_CONSTANT);\n\t                               _asn1_set_name((yyval.node),(yyvsp[-3].str));\n                                       _asn1_set_value((yyval.node),(yyvsp[-1].str),strlen((yyvsp[-1].str))+1);}\n#line 1633 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 17:\n#line 179 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 1639 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 18:\n#line 180 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[-2].node);\n                                            _asn1_set_right(_asn1_get_last_right((yyvsp[-2].node)),(yyvsp[0].node));}\n#line 1646 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 19:\n#line 184 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_CONSTANT);\n                                   _asn1_set_value((yyval.node),(yyvsp[0].str),strlen((yyvsp[0].str))+1);}\n#line 1653 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 20:\n#line 186 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_CONSTANT);\n\t                            _asn1_set_name((yyval.node),(yyvsp[-3].str));\n                                    _asn1_set_value((yyval.node),(yyvsp[-1].str),strlen((yyvsp[-1].str))+1);}\n#line 1661 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 21:\n#line 191 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 1667 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 22:\n#line 192 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[-1].node);\n                                                    _asn1_set_right(_asn1_get_last_right((yyvsp[-1].node)),(yyvsp[0].node));}\n#line 1674 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 23:\n#line 196 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.constant)=CONST_UNIVERSAL;}\n#line 1680 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 24:\n#line 197 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.constant)=CONST_PRIVATE;}\n#line 1686 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 25:\n#line 198 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.constant)=CONST_APPLICATION;}\n#line 1692 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 26:\n#line 201 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_TAG);\n                            _asn1_set_value((yyval.node),(yyvsp[-1].str),strlen((yyvsp[-1].str))+1);}\n#line 1699 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 27:\n#line 203 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_TAG | (yyvsp[-2].constant));\n                                _asn1_set_value((yyval.node),(yyvsp[-1].str),strlen((yyvsp[-1].str))+1);}\n#line 1706 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 28:\n#line 207 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 1712 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 29:\n#line 208 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_mod_type((yyvsp[-1].node),CONST_EXPLICIT);}\n#line 1718 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 30:\n#line 209 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_mod_type((yyvsp[-1].node),CONST_IMPLICIT);}\n#line 1724 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 31:\n#line 212 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_DEFAULT);\n                                       _asn1_set_value((yyval.node),(yyvsp[0].str),strlen((yyvsp[0].str))+1);}\n#line 1731 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 32:\n#line 214 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_DEFAULT|CONST_TRUE);}\n#line 1737 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 33:\n#line 215 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_DEFAULT|CONST_FALSE);}\n#line 1743 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 36:\n#line 224 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_INTEGER);}\n#line 1749 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 37:\n#line 225 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_INTEGER|CONST_LIST);\n\t                                 _asn1_set_down((yyval.node),(yyvsp[-1].node));}\n#line 1756 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 38:\n#line 227 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_INTEGER);}\n#line 1762 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 39:\n#line 229 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_INTEGER|CONST_MIN_MAX);\n                                         _asn1_set_down((yyval.node),_asn1_add_static_node(ASN1_ETYPE_SIZE));\n                                         _asn1_set_value(_asn1_get_down((yyval.node)),(yyvsp[-1].str),strlen((yyvsp[-1].str))+1);\n                                         _asn1_set_name(_asn1_get_down((yyval.node)),(yyvsp[-4].str));}\n#line 1771 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 40:\n#line 235 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_BOOLEAN);}\n#line 1777 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 41:\n#line 238 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_UTC_TIME);}\n#line 1783 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 42:\n#line 239 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_GENERALIZED_TIME);}\n#line 1789 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 43:\n#line 242 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_SIZE|CONST_1_PARAM);\n\t                              _asn1_set_value((yyval.node),(yyvsp[-1].str),strlen((yyvsp[-1].str))+1);}\n#line 1796 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 44:\n#line 245 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_SIZE|CONST_MIN_MAX);\n\t                              _asn1_set_value((yyval.node),(yyvsp[-4].str),strlen((yyvsp[-4].str))+1);\n                                      _asn1_set_name((yyval.node),(yyvsp[-1].str));}\n#line 1804 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 45:\n#line 250 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 1810 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 46:\n#line 251 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[-1].node);}\n#line 1816 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 47:\n#line 254 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_GENERALSTRING);}\n#line 1822 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 48:\n#line 255 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_GENERALSTRING|CONST_SIZE);\n\t\t\t\t\t  _asn1_set_down((yyval.node),(yyvsp[0].node));}\n#line 1829 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 49:\n#line 259 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_NUMERIC_STRING|CONST_UNIVERSAL);}\n#line 1835 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 50:\n#line 260 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_NUMERIC_STRING|CONST_SIZE);\n\t\t\t\t\t  _asn1_set_down((yyval.node),(yyvsp[0].node));}\n#line 1842 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 51:\n#line 264 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_IA5_STRING);}\n#line 1848 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 52:\n#line 265 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_IA5_STRING|CONST_SIZE);\n\t\t\t\t\t  _asn1_set_down((yyval.node),(yyvsp[0].node));}\n#line 1855 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 53:\n#line 269 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_TELETEX_STRING);}\n#line 1861 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 54:\n#line 270 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_TELETEX_STRING|CONST_SIZE);\n\t\t\t\t\t  _asn1_set_down((yyval.node),(yyvsp[0].node));}\n#line 1868 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 55:\n#line 274 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_PRINTABLE_STRING);}\n#line 1874 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 56:\n#line 275 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_PRINTABLE_STRING|CONST_SIZE);\n\t\t\t\t\t  _asn1_set_down((yyval.node),(yyvsp[0].node));}\n#line 1881 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 57:\n#line 279 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_UNIVERSAL_STRING);}\n#line 1887 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 58:\n#line 280 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_UNIVERSAL_STRING|CONST_SIZE);\n\t\t\t\t\t  _asn1_set_down((yyval.node),(yyvsp[0].node));}\n#line 1894 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 59:\n#line 284 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_BMP_STRING);}\n#line 1900 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 60:\n#line 285 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_BMP_STRING|CONST_SIZE);\n\t\t\t\t\t  _asn1_set_down((yyval.node),(yyvsp[0].node));}\n#line 1907 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 61:\n#line 289 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_UTF8_STRING);}\n#line 1913 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 62:\n#line 290 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_UTF8_STRING|CONST_SIZE);\n\t\t\t\t\t  _asn1_set_down((yyval.node),(yyvsp[0].node));}\n#line 1920 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 63:\n#line 294 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_VISIBLE_STRING);}\n#line 1926 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 64:\n#line 295 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_VISIBLE_STRING|CONST_SIZE);\n\t\t\t\t\t  _asn1_set_down((yyval.node),(yyvsp[0].node));}\n#line 1933 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 65:\n#line 299 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_OCTET_STRING);}\n#line 1939 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 66:\n#line 300 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_OCTET_STRING|CONST_SIZE);\n                                           _asn1_set_down((yyval.node),(yyvsp[0].node));}\n#line 1946 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 67:\n#line 304 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_CONSTANT);\n\t                           _asn1_set_name((yyval.node),(yyvsp[-3].str));\n                                    _asn1_set_value((yyval.node),(yyvsp[-1].str),strlen((yyvsp[-1].str))+1);}\n#line 1954 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 68:\n#line 309 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 1960 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 69:\n#line 310 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[-2].node);\n                                                       _asn1_set_right(_asn1_get_last_right((yyvsp[-2].node)),(yyvsp[0].node));}\n#line 1967 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 70:\n#line 314 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_BIT_STRING);}\n#line 1973 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 71:\n#line 315 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_BIT_STRING|CONST_SIZE);}\n#line 1979 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 72:\n#line 317 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_BIT_STRING|CONST_LIST);\n                                _asn1_set_down((yyval.node),(yyvsp[-1].node));}\n#line 1986 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 73:\n#line 322 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_ENUMERATED|CONST_LIST);\n                                _asn1_set_down((yyval.node),(yyvsp[-1].node));}\n#line 1993 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 74:\n#line 327 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_OBJECT_ID);}\n#line 1999 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 75:\n#line 330 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_IDENTIFIER);\n                                       _asn1_set_value((yyval.node),(yyvsp[0].str),strlen((yyvsp[0].str))+1);}\n#line 2006 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 76:\n#line 332 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_IDENTIFIER|CONST_SIZE);\n                                       _asn1_set_value((yyval.node),(yyvsp[-1].str),strlen((yyvsp[-1].str))+1);\n                                       _asn1_set_down((yyval.node),(yyvsp[0].node));}\n#line 2014 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 77:\n#line 335 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 2020 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 78:\n#line 336 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 2026 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 79:\n#line 337 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 2032 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 81:\n#line 339 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 2038 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 82:\n#line 340 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 2044 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 83:\n#line 341 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 2050 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 84:\n#line 342 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 2056 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 85:\n#line 343 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 2062 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 86:\n#line 344 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 2068 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 87:\n#line 345 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 2074 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 88:\n#line 346 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 2080 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 89:\n#line 347 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 2086 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 90:\n#line 348 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 2092 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 91:\n#line 349 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 2098 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 92:\n#line 350 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 2104 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 93:\n#line 351 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 2110 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 94:\n#line 352 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 2116 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 95:\n#line 353 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 2122 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 96:\n#line 354 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 2128 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 97:\n#line 355 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_NULL);}\n#line 2134 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 98:\n#line 358 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 2140 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 99:\n#line 359 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_mod_type((yyvsp[0].node),CONST_TAG);\n                                               _asn1_set_right((yyvsp[-1].node),_asn1_get_down((yyval.node)));\n                                               _asn1_set_down((yyval.node),(yyvsp[-1].node));}\n#line 2148 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 100:\n#line 364 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 2154 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 101:\n#line 365 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_mod_type((yyvsp[-1].node),CONST_DEFAULT);\n                                                       _asn1_set_right((yyvsp[0].node),_asn1_get_down((yyval.node)));\n\t\t\t\t\t\t       _asn1_set_down((yyval.node),(yyvsp[0].node));}\n#line 2162 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 102:\n#line 368 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_mod_type((yyvsp[-1].node),CONST_OPTION);}\n#line 2168 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 103:\n#line 371 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_set_name((yyvsp[0].node),(yyvsp[-1].str));}\n#line 2174 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 104:\n#line 374 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 2180 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 105:\n#line 375 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[-2].node);\n                                                _asn1_set_right(_asn1_get_last_right((yyvsp[-2].node)),(yyvsp[0].node));}\n#line 2187 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 106:\n#line 379 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_SEQUENCE);\n                                              _asn1_set_down((yyval.node),(yyvsp[-1].node));}\n#line 2194 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 107:\n#line 381 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_SEQUENCE_OF);\n                                              _asn1_set_down((yyval.node),(yyvsp[0].node));}\n#line 2201 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 108:\n#line 383 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_SEQUENCE_OF|CONST_SIZE);\n                                            _asn1_set_right((yyvsp[-2].node),(yyvsp[0].node));\n                                            _asn1_set_down((yyval.node),(yyvsp[-2].node));}\n#line 2209 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 109:\n#line 388 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_SET);\n                                     _asn1_set_down((yyval.node),(yyvsp[-1].node));}\n#line 2216 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 110:\n#line 390 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_SET_OF);\n                                     _asn1_set_down((yyval.node),(yyvsp[0].node));}\n#line 2223 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 111:\n#line 392 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_SET_OF|CONST_SIZE);\n                                       _asn1_set_right((yyvsp[-2].node),(yyvsp[0].node));\n                                       _asn1_set_down((yyval.node),(yyvsp[-2].node));}\n#line 2231 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 112:\n#line 397 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_CHOICE);\n                                             _asn1_set_down((yyval.node),(yyvsp[-1].node));}\n#line 2238 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 113:\n#line 401 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_ANY);}\n#line 2244 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 114:\n#line 402 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_ANY|CONST_DEFINED_BY);\n                                        _asn1_set_down((yyval.node),_asn1_add_static_node(ASN1_ETYPE_CONSTANT));\n\t                                _asn1_set_name(_asn1_get_down((yyval.node)),(yyvsp[0].str));}\n#line 2252 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 115:\n#line 407 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_set_name((yyvsp[0].node),(yyvsp[-2].str));}\n#line 2258 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 116:\n#line 409 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_set_name((yyvsp[0].node), last_error_token);}\n#line 2264 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 117:\n#line 413 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_OBJECT_ID|CONST_ASSIGN);\n                         _asn1_set_name((yyval.node),(yyvsp[-6].str));\n                         _asn1_set_down((yyval.node),(yyvsp[-1].node));}\n#line 2272 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 118:\n#line 417 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_OBJECT_ID|CONST_ASSIGN|CONST_1_PARAM);\n                         _asn1_set_name((yyval.node),(yyvsp[-5].str));\n                         _asn1_set_value((yyval.node),(yyvsp[-4].str),strlen((yyvsp[-4].str))+1);\n                         _asn1_set_down((yyval.node),(yyvsp[-1].node));}\n#line 2281 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 119:\n#line 422 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_INTEGER|CONST_ASSIGN);\n                         _asn1_set_name((yyval.node),(yyvsp[-3].str));\n                         _asn1_set_value((yyval.node),(yyvsp[0].str),strlen((yyvsp[0].str))+1);}\n#line 2289 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 120:\n#line 427 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 2295 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 121:\n#line 428 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 2301 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 122:\n#line 431 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[0].node);}\n#line 2307 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 123:\n#line 432 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=(yyvsp[-1].node);\n                                                          _asn1_set_right(_asn1_get_last_right((yyvsp[-1].node)),(yyvsp[0].node));}\n#line 2314 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 124:\n#line 436 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_OBJECT_ID);\n                                                          _asn1_set_down((yyval.node),(yyvsp[-1].node));\n                                                          _asn1_set_name((yyval.node),(yyvsp[-3].str));}\n#line 2322 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 125:\n#line 439 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_OBJECT_ID);\n                                                          _asn1_set_name((yyval.node),(yyvsp[-2].str));}\n#line 2329 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 126:\n#line 441 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.node)=_asn1_add_static_node(ASN1_ETYPE_OBJECT_ID);\n                                                          _asn1_set_name((yyval.node),(yyvsp[0].str));}\n#line 2336 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 127:\n#line 465 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.constant)=CONST_EXPLICIT;}\n#line 2342 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n  case 128:\n#line 466 \"ASN1.y\" /* yacc.c:1646  */\n    {(yyval.constant)=CONST_IMPLICIT;}\n#line 2348 \"ASN1.c\" /* yacc.c:1646  */\n    break;\n\n\n#line 2352 \"ASN1.c\" /* yacc.c:1646  */\n      default: break;\n    }\n  /* User semantic actions sometimes alter yychar, and that requires\n     that yytoken be updated with the new translation.  We take the\n     approach of translating immediately before every use of yytoken.\n     One alternative is translating here after every semantic action,\n     but that translation would be missed if the semantic action invokes\n     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or\n     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an\n     incorrect destructor might then be invoked immediately.  In the\n     case of YYERROR or YYBACKUP, subsequent parser actions might lead\n     to an incorrect destructor call or verbose syntax error message\n     before the lookahead is translated.  */\n  YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n\n  *++yyvsp = yyval;\n\n  /* Now 'shift' the result of the reduction.  Determine what state\n     that goes to, based on the state we popped back to and the rule\n     number reduced by.  */\n\n  yyn = yyr1[yyn];\n\n  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;\n  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)\n    yystate = yytable[yystate];\n  else\n    yystate = yydefgoto[yyn - YYNTOKENS];\n\n  goto yynewstate;\n\n\n/*--------------------------------------.\n| yyerrlab -- here on detecting error.  |\n`--------------------------------------*/\nyyerrlab:\n  /* Make sure we have latest lookahead translation.  See comments at\n     user semantic actions for why this is necessary.  */\n  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);\n\n  /* If not already recovering from an error, report this error.  */\n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n#if ! YYERROR_VERBOSE\n      yyerror (YY_(\"syntax error\"));\n#else\n# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\\n                                        yyssp, yytoken)\n      {\n        char const *yymsgp = YY_(\"syntax error\");\n        int yysyntax_error_status;\n        yysyntax_error_status = YYSYNTAX_ERROR;\n        if (yysyntax_error_status == 0)\n          yymsgp = yymsg;\n        else if (yysyntax_error_status == 1)\n          {\n            if (yymsg != yymsgbuf)\n              YYSTACK_FREE (yymsg);\n            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);\n            if (!yymsg)\n              {\n                yymsg = yymsgbuf;\n                yymsg_alloc = sizeof yymsgbuf;\n                yysyntax_error_status = 2;\n              }\n            else\n              {\n                yysyntax_error_status = YYSYNTAX_ERROR;\n                yymsgp = yymsg;\n              }\n          }\n        yyerror (yymsgp);\n        if (yysyntax_error_status == 2)\n          goto yyexhaustedlab;\n      }\n# undef YYSYNTAX_ERROR\n#endif\n    }\n\n\n\n  if (yyerrstatus == 3)\n    {\n      /* If just tried and failed to reuse lookahead token after an\n         error, discard it.  */\n\n      if (yychar <= YYEOF)\n        {\n          /* Return failure if at end of input.  */\n          if (yychar == YYEOF)\n            YYABORT;\n        }\n      else\n        {\n          yydestruct (\"Error: discarding\",\n                      yytoken, &yylval);\n          yychar = YYEMPTY;\n        }\n    }\n\n  /* Else will try to reuse lookahead token after shifting the error\n     token.  */\n  goto yyerrlab1;\n\n\n/*---------------------------------------------------.\n| yyerrorlab -- error raised explicitly by YYERROR.  |\n`---------------------------------------------------*/\nyyerrorlab:\n\n  /* Pacify compilers like GCC when the user code never invokes\n     YYERROR and the label yyerrorlab therefore never appears in user\n     code.  */\n  if (/*CONSTCOND*/ 0)\n     goto yyerrorlab;\n\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYERROR.  */\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n  yystate = *yyssp;\n  goto yyerrlab1;\n\n\n/*-------------------------------------------------------------.\n| yyerrlab1 -- common code for both syntax error and YYERROR.  |\n`-------------------------------------------------------------*/\nyyerrlab1:\n  yyerrstatus = 3;      /* Each real token shifted decrements this.  */\n\n  for (;;)\n    {\n      yyn = yypact[yystate];\n      if (!yypact_value_is_default (yyn))\n        {\n          yyn += YYTERROR;\n          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)\n            {\n              yyn = yytable[yyn];\n              if (0 < yyn)\n                break;\n            }\n        }\n\n      /* Pop the current state because it cannot handle the error token.  */\n      if (yyssp == yyss)\n        YYABORT;\n\n\n      yydestruct (\"Error: popping\",\n                  yystos[yystate], yyvsp);\n      YYPOPSTACK (1);\n      yystate = *yyssp;\n      YY_STACK_PRINT (yyss, yyssp);\n    }\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n\n  /* Shift the error token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n/*-------------------------------------.\n| yyacceptlab -- YYACCEPT comes here.  |\n`-------------------------------------*/\nyyacceptlab:\n  yyresult = 0;\n  goto yyreturn;\n\n/*-----------------------------------.\n| yyabortlab -- YYABORT comes here.  |\n`-----------------------------------*/\nyyabortlab:\n  yyresult = 1;\n  goto yyreturn;\n\n#if !defined yyoverflow || YYERROR_VERBOSE\n/*-------------------------------------------------.\n| yyexhaustedlab -- memory exhaustion comes here.  |\n`-------------------------------------------------*/\nyyexhaustedlab:\n  yyerror (YY_(\"memory exhausted\"));\n  yyresult = 2;\n  /* Fall through.  */\n#endif\n\nyyreturn:\n  if (yychar != YYEMPTY)\n    {\n      /* Make sure we have latest lookahead translation.  See comments at\n         user semantic actions for why this is necessary.  */\n      yytoken = YYTRANSLATE (yychar);\n      yydestruct (\"Cleanup: discarding lookahead\",\n                  yytoken, &yylval);\n    }\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYABORT or YYACCEPT.  */\n  YYPOPSTACK (yylen);\n  YY_STACK_PRINT (yyss, yyssp);\n  while (yyssp != yyss)\n    {\n      yydestruct (\"Cleanup: popping\",\n                  yystos[*yyssp], yyvsp);\n      YYPOPSTACK (1);\n    }\n#ifndef yyoverflow\n  if (yyss != yyssa)\n    YYSTACK_FREE (yyss);\n#endif\n#if YYERROR_VERBOSE\n  if (yymsg != yymsgbuf)\n    YYSTACK_FREE (yymsg);\n#endif\n  return yyresult;\n}",
      "lines": 1279,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "_asn1_yylex": {
      "start_point": [
        2610,
        0
      ],
      "end_point": [
        2704,
        1
      ],
      "content": "static int\n_asn1_yylex ()\n{\n  int c, counter = 0, k, lastc;\n  char string[ASN1_MAX_NAME_SIZE + 1];  /* will contain the next token */\n  size_t i;\n\n  while (1)\n    {\n      while ((c = fgetc (file_asn1)) == ' ' || c == '\\t' || c == '\\n')\n        if (c == '\\n')\n          line_number++;\n\n      if (c == EOF)\n        {\n          snprintf (last_token, sizeof(last_token), \"End Of File\");\n          return 0;\n        }\n\n      if (c == '(' || c == ')' || c == '[' || c == ']' ||\n          c == '{' || c == '}' || c == ',' || c == '.' ||\n          c == '+' || c == '|')\n        {\n          last_token[0] = c;\n          last_token[1] = 0;\n          return c;\n        }\n      if (c == '-')\n        {                       /* Maybe the first '-' of a comment */\n          if ((c = fgetc (file_asn1)) != '-')\n            {\n              ungetc (c, file_asn1);\n              last_token[0] = '-';\n              last_token[1] = 0;\n              return '-';\n            }\n          else\n            {                   /* Comments */\n              lastc = 0;\n              counter = 0;\n              /* A comment finishes at the next double hypen or the end of line */\n              while ((c = fgetc (file_asn1)) != EOF && c != '\\n' &&\n                     (lastc != '-' || (lastc == '-' && c != '-')))\n                lastc = c;\n              if (c == EOF)\n                {\n                  snprintf (last_token, sizeof(last_token), \"End Of File\");\n                  return 0;\n                }\n              else\n                {\n                  if (c == '\\n')\n                    line_number++;\n                  continue;     /* next char, please! (repeat the search) */\n                }\n            }\n        }\n      string[counter++] = c;\n      /* Till the end of the token */\n      while (!\n             ((c = fgetc (file_asn1)) == EOF || c == ' ' || c == '\\t'\n              || c == '\\n' || c == '(' || c == ')' || c == '[' || c == ']'\n              || c == '{' || c == '}' || c == ',' || c == '.'))\n        {\n          if (counter >= ASN1_MAX_NAME_SIZE)\n            {\n              result_parse = ASN1_NAME_TOO_LONG;\n              return 0;\n            }\n          string[counter++] = c;\n        }\n      ungetc (c, file_asn1);\n      string[counter] = 0;\n      snprintf (last_token, sizeof(last_token), \"%s\", string);\n\n      /* Is STRING a number? */\n      for (k = 0; k < counter; k++)\n        if (!isdigit ((int)string[k]))\n          break;\n      if (k >= counter)\n        {\n          snprintf (yylval.str, sizeof(yylval.str), \"%s\", string);\n          return NUM;           /* return the number */\n        }\n\n      /* Is STRING a keyword? */\n      for (i = 0; i < (sizeof (key_word) / sizeof (char *)); i++)\n        if (!strcmp (string, key_word[i]))\n          return key_word_token[i];\n\n      /* STRING is an IDENTIFIER */\n      snprintf (yylval.str, sizeof(yylval.str), \"%s\", string);\n      return IDENTIFIER;\n    }\n}",
      "lines": 95,
      "depth": 25,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_asn1_create_errorDescription": {
      "start_point": [
        2715,
        0
      ],
      "end_point": [
        2745,
        1
      ],
      "content": "static void\n_asn1_create_errorDescription (int error, char *error_desc)\n{\n  if (error_desc == NULL)\n    return;\n\n\n  switch (error)\n    {\n    case ASN1_FILE_NOT_FOUND:\n      snprintf(error_desc, ASN1_MAX_ERROR_DESCRIPTION_SIZE, \"%s file was not found\", file_name);\n      break;\n    case ASN1_SYNTAX_ERROR:\n      snprintf(error_desc, ASN1_MAX_ERROR_DESCRIPTION_SIZE, \"%s\", last_error);\n      break;\n    case ASN1_NAME_TOO_LONG:\n      snprintf (error_desc, ASN1_MAX_ERROR_DESCRIPTION_SIZE,\n                \"%s:%u: name too long (more than %u characters)\", file_name,\n                line_number, (unsigned)ASN1_MAX_NAME_SIZE);\n      break;\n    case ASN1_IDENTIFIER_NOT_FOUND:\n      snprintf (error_desc, ASN1_MAX_ERROR_DESCRIPTION_SIZE,\n                \"%s:: identifier '%s' not found\", file_name,\n                _asn1_identifierMissing);\n      break;\n    default:\n      error_desc[0] = 0;\n      break;\n    }\n\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "asn1_parser2tree": {
      "start_point": [
        2768,
        0
      ],
      "end_point": [
        2829,
        1
      ],
      "content": "int\nasn1_parser2tree (const char *file, asn1_node * definitions,\n                  char *error_desc)\n{\n\n  p_tree = NULL;\n\n  if (*definitions != NULL)\n    return ASN1_ELEMENT_NOT_EMPTY;\n\n  *definitions = NULL;\n\n  file_name = file;\n\n  /* open the file to parse */\n  file_asn1 = fopen (file, \"r\");\n\n  if (file_asn1 == NULL)\n    {\n      result_parse = ASN1_FILE_NOT_FOUND;\n    }\n  else\n    {\n      result_parse = ASN1_SUCCESS;\n\n      line_number = 1;\n      yyparse ();\n\n      fclose (file_asn1);\n\n      if (result_parse == ASN1_SUCCESS)\n        {                       /* syntax OK */\n          /* set IMPLICIT or EXPLICIT property */\n          _asn1_set_default_tag (p_tree);\n          /* set CONST_SET and CONST_NOT_USED */\n          _asn1_type_set_config (p_tree);\n          /* check the identifier definitions */\n          result_parse = _asn1_check_identifier (p_tree);\n          if (result_parse == ASN1_SUCCESS)\n            {                   /* all identifier defined */\n              /* Delete the list and keep the ASN1 structure */\n              _asn1_delete_list ();\n              /* Convert into DER coding the value assign to INTEGER constants */\n              _asn1_change_integer_value (p_tree);\n              /* Expand the IDs of OBJECT IDENTIFIER constants */\n              _asn1_expand_object_id (p_tree);\n\n              *definitions = p_tree;\n            }\n          else                  /* some identifiers not defined */\n            /* Delete the list and the ASN1 structure */\n            _asn1_delete_list_and_nodes ();\n        }\n      else                      /* syntax error */\n        /* Delete the list and the ASN1 structure */\n        _asn1_delete_list_and_nodes ();\n    }\n\n  _asn1_create_errorDescription (result_parse, error_desc);\n\n  return result_parse;\n}",
      "lines": 62,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "asn1_parser2array": {
      "start_point": [
        2856,
        0
      ],
      "end_point": [
        2962,
        1
      ],
      "content": "int\nasn1_parser2array (const char *inputFileName, const char *outputFileName,\n                   const char *vectorName, char *error_desc)\n{\n  char *file_out_name = NULL;\n  char *vector_name = NULL;\n  const char *char_p, *slash_p, *dot_p;\n\n  p_tree = NULL;\n\n  file_name = inputFileName;\n\n  /* open the file to parse */\n  file_asn1 = fopen (inputFileName, \"r\");\n\n  if (file_asn1 == NULL)\n    result_parse = ASN1_FILE_NOT_FOUND;\n  else\n    {\n      result_parse = ASN1_SUCCESS;\n\n      line_number = 1;\n      yyparse ();\n\n      fclose (file_asn1);\n\n      if (result_parse == ASN1_SUCCESS)\n        {                       /* syntax OK */\n          /* set IMPLICIT or EXPLICIT property */\n          _asn1_set_default_tag (p_tree);\n          /* set CONST_SET and CONST_NOT_USED */\n          _asn1_type_set_config (p_tree);\n          /* check the identifier definitions */\n          result_parse = _asn1_check_identifier (p_tree);\n\n          if (result_parse == ASN1_SUCCESS)\n            {                   /* all identifier defined */\n\n              /* searching the last '/' and '.' in inputFileName */\n              char_p = inputFileName;\n              slash_p = inputFileName;\n              while ((char_p = strchr (char_p, '/')))\n                {\n                  char_p++;\n                  slash_p = char_p;\n                }\n\n              char_p = slash_p;\n              dot_p = inputFileName + strlen (inputFileName);\n\n              while ((char_p = strchr (char_p, '.')))\n                {\n                  dot_p = char_p;\n                  char_p++;\n                }\n\n              if (outputFileName == NULL)\n                {\n                  /* file_out_name = inputFileName + _asn1_tab.c */\n                  file_out_name = malloc (dot_p - inputFileName + 1 +\n                                          strlen (\"_asn1_tab.c\"));\n                  memcpy (file_out_name, inputFileName,\n                          dot_p - inputFileName);\n                  file_out_name[dot_p - inputFileName] = 0;\n                  strcat (file_out_name, \"_asn1_tab.c\");\n                }\n              else\n                {\n                  /* file_out_name = inputFileName */\n                  file_out_name =\n                      (char *) malloc (strlen (outputFileName) + 1);\n                  strcpy (file_out_name, outputFileName);\n                }\n\n              if (vectorName == NULL)\n                {\n                  /* vector_name = file name + _asn1_tab */\n                  vector_name = malloc (dot_p - slash_p + 1 +\n                                        strlen (\"_asn1_tab\"));\n                  memcpy (vector_name, slash_p, dot_p - slash_p);\n                  vector_name[dot_p - slash_p] = 0;\n                  strcat (vector_name, \"_asn1_tab\");\n                }\n              else\n                {\n                  /* vector_name = vectorName */\n                  vector_name = (char *) malloc (strlen (vectorName) + 1);\n                  strcpy (vector_name, vectorName);\n                }\n\n              /* Save structure in a file */\n              _asn1_create_static_structure (p_tree,\n                                             file_out_name, vector_name);\n\n              free (file_out_name);\n              free (vector_name);\n            }                   /* result == OK */\n        }                       /* result == OK */\n\n      /* Delete the list and the ASN1 structure */\n      _asn1_delete_list_and_nodes ();\n    }                           /* inputFile exist */\n\n  _asn1_create_errorDescription (result_parse, error_desc);\n\n  return result_parse;\n}",
      "lines": 107,
      "depth": 19,
      "decorators": [
        "int"
      ]
    },
    "_asn1_yyerror": {
      "start_point": [
        2972,
        0
      ],
      "end_point": [
        3003,
        1
      ],
      "content": "static void\n_asn1_yyerror (const char *s)\n{\n  /* Sends the error description to the std_out */\n\n  if (strcmp (last_token, \"VisibleString\") == 0 ||\n      strcmp (last_token, \"PrintableString\") == 0 ||\n      strcmp (last_token, \"UniversalString\") == 0 ||\n      strcmp (last_token, \"IA5String\") == 0 ||\n      strcmp (last_token, \"UTF8String\") == 0 ||\n      strcmp (last_token, \"NumericString\") == 0 ||\n      strcmp (last_token, \"TeletexString\") == 0 ||\n      strcmp (last_token, \"BMPString\") == 0)\n    {\n      snprintf (last_error_token, sizeof(last_error_token),\n                \"%s\", last_token);\n      fprintf(stderr, \"%s:%u: Warning: %s is a built-in ASN.1 type.\\n\",\n               file_name, line_number, last_token);\n      return;\n    }\n  last_error_token[0] = 0;\n\n  if (result_parse != ASN1_NAME_TOO_LONG)\n    {\n      snprintf (last_error, sizeof(last_error),\n                \"%s:%u: Error: %s near '%s'\", file_name,\n                line_number, s, last_token);\n      result_parse = ASN1_SYNTAX_ERROR;\n    }\n\n  return;\n}",
      "lines": 32,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/lib/ASN1.y": {
    "explicit_implicit": {
      "start_point": [
        191,
        20
      ],
      "end_point": [
        192,
        98
      ],
      "content": "obj_constant_list obj_constant {$$=$1;\n                                                    _asn1_set_right(_asn1_get_last_right($1),$2);}",
      "lines": 2,
      "depth": 5,
      "decorators": null
    },
    "NUM": [
      {
        "start_point": [
          207,
          7
        ],
        "end_point": [
          207,
          65
        ],
        "content": "tag_type EXPLICIT  {$$=_asn1_mod_type($1,CONST_EXPLICIT);}",
        "lines": 1,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          208,
          7
        ],
        "end_point": [
          208,
          65
        ],
        "content": "tag_type IMPLICIT  {$$=_asn1_mod_type($1,CONST_IMPLICIT);}",
        "lines": 1,
        "depth": 7,
        "decorators": null
      }
    ]
  },
  "libtasn1/libtasn1-4.13/lib/coding.c": {
    "_asn1_error_description_value_not_found": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static void\n_asn1_error_description_value_not_found (asn1_node node,\n\t\t\t\t\t char *ErrorDescription)\n{\n\n  if (ErrorDescription == NULL)\n    return;\n\n  Estrcpy (ErrorDescription, \":: value of element '\");\n  _asn1_hierarchical_name (node, ErrorDescription + strlen (ErrorDescription),\n\t\t\t   ASN1_MAX_ERROR_DESCRIPTION_SIZE - 40);\n  Estrcat (ErrorDescription, \"' not found\");\n\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "asn1_length_der": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "void\nasn1_length_der (unsigned long int len, unsigned char *der, int *der_len)\n{\n  int k;\n  unsigned char temp[ASN1_MAX_LENGTH_SIZE];\n#if SIZEOF_UNSIGNED_LONG_INT > 8\n  len &= 0xFFFFFFFFFFFFFFFF;\n#endif\n\n  if (len < 128)\n    {\n      /* short form */\n      if (der != NULL)\n\tder[0] = (unsigned char) len;\n      *der_len = 1;\n    }\n  else\n    {\n      /* Long form */\n      k = 0;\n      while (len)\n\t{\n\t  temp[k++] = len & 0xFF;\n\t  len = len >> 8;\n\t}\n      *der_len = k + 1;\n      if (der != NULL)\n\t{\n\t  der[0] = ((unsigned char) k & 0x7F) + 128;\n\t  while (k--)\n\t    der[*der_len - 1 - k] = temp[k];\n\t}\n    }\n}",
      "lines": 34,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "_asn1_tag_der": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "static void\n_asn1_tag_der (unsigned char class, unsigned int tag_value,\n\t       unsigned char *ans, int *ans_len)\n{\n  int k;\n  unsigned char temp[ASN1_MAX_TAG_SIZE];\n\n  if (tag_value < 31)\n    {\n      /* short form */\n      ans[0] = (class & 0xE0) + ((unsigned char) (tag_value & 0x1F));\n      *ans_len = 1;\n    }\n  else\n    {\n      /* Long form */\n      ans[0] = (class & 0xE0) + 31;\n      k = 0;\n      while (tag_value != 0)\n\t{\n\t  temp[k++] = tag_value & 0x7F;\n\t  tag_value >>= 7;\n\n\t  if (k > ASN1_MAX_TAG_SIZE - 1)\n\t    break;\t\t/* will not encode larger tags */\n\t}\n      *ans_len = k + 1;\n      while (k--)\n\tans[*ans_len - 1 - k] = temp[k] + 128;\n      ans[*ans_len - 1] -= 128;\n    }\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "asn1_octet_der": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "void\nasn1_octet_der (const unsigned char *str, int str_len,\n\t\tunsigned char *der, int *der_len)\n{\n  int len_len;\n\n  if (der == NULL || str_len < 0)\n    return;\n\n  asn1_length_der (str_len, der, &len_len);\n  memcpy (der + len_len, str, str_len);\n  *der_len = str_len + len_len;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "asn1_encode_simple_der": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "int\nasn1_encode_simple_der (unsigned int etype, const unsigned char *str,\n\t\t\tunsigned int str_len, unsigned char *tl,\n\t\t\tunsigned int *tl_len)\n{\n  int tag_len, len_len;\n  unsigned tlen;\n  unsigned char der_tag[ASN1_MAX_TAG_SIZE];\n  unsigned char der_length[ASN1_MAX_LENGTH_SIZE];\n  unsigned char *p;\n\n  if (str == NULL)\n    return ASN1_VALUE_NOT_VALID;\n\n  if (ETYPE_OK (etype) == 0)\n    return ASN1_VALUE_NOT_VALID;\n\n  /* doesn't handle constructed classes */\n  if (ETYPE_CLASS (etype) != ASN1_CLASS_UNIVERSAL)\n    return ASN1_VALUE_NOT_VALID;\n\n  _asn1_tag_der (ETYPE_CLASS (etype), ETYPE_TAG (etype), der_tag, &tag_len);\n\n  asn1_length_der (str_len, der_length, &len_len);\n\n  if (tag_len <= 0 || len_len <= 0)\n    return ASN1_VALUE_NOT_VALID;\n\n  tlen = tag_len + len_len;\n\n  if (*tl_len < tlen)\n    return ASN1_MEM_ERROR;\n\n  p = tl;\n  memcpy (p, der_tag, tag_len);\n  p += tag_len;\n  memcpy (p, der_length, len_len);\n\n  *tl_len = tlen;\n\n  return ASN1_SUCCESS;\n}",
      "lines": 42,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "_asn1_time_der": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        279,
        1
      ],
      "content": "static int\n_asn1_time_der (unsigned char *str, int str_len, unsigned char *der,\n\t\tint *der_len)\n{\n  int len_len;\n  int max_len;\n\n  max_len = *der_len;\n\n  asn1_length_der (str_len, (max_len > 0) ? der : NULL, &len_len);\n\n  if ((len_len + str_len) <= max_len)\n    memcpy (der + len_len, str, str_len);\n  *der_len = len_len + str_len;\n\n  if ((*der_len) > max_len)\n    return ASN1_MEM_ERROR;\n\n  return ASN1_SUCCESS;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_asn1_objectid_der": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        403,
        1
      ],
      "content": "static int\n_asn1_objectid_der (unsigned char *str, unsigned char *der, int *der_len)\n{\n  int len_len, counter, k, first, max_len;\n  char *temp, *n_end, *n_start;\n  unsigned char bit7;\n  uint64_t val, val1 = 0;\n  int str_len = _asn1_strlen (str);\n\n  max_len = *der_len;\n\n  temp = malloc (str_len + 2);\n  if (temp == NULL)\n    return ASN1_MEM_ALLOC_ERROR;\n\n  memcpy (temp, str, str_len);\n  temp[str_len] = '.';\n  temp[str_len + 1] = 0;\n\n  counter = 0;\n  n_start = temp;\n  while ((n_end = strchr (n_start, '.')))\n    {\n      *n_end = 0;\n      val = _asn1_strtou64 (n_start, NULL, 10);\n      counter++;\n\n      if (counter == 1)\n\tval1 = val;\n      else if (counter == 2)\n\t{\n\t  if (max_len > 0)\n\t    der[0] = 40 * val1 + val;\n\t  *der_len = 1;\n\t}\n      else\n\t{\n\t  first = 0;\n\t  for (k = sizeof(val); k >= 0; k--)\n\t    {\n\t      bit7 = (val >> (k * 7)) & 0x7F;\n\t      if (bit7 || first || !k)\n\t\t{\n\t\t  if (k)\n\t\t    bit7 |= 0x80;\n\t\t  if (max_len > (*der_len))\n\t\t    der[*der_len] = bit7;\n\t\t  (*der_len)++;\n\t\t  first = 1;\n\t\t}\n\t    }\n\n\t}\n      n_start = n_end + 1;\n    }\n\n  asn1_length_der (*der_len, NULL, &len_len);\n  if (max_len >= (*der_len + len_len))\n    {\n      memmove (der + len_len, der, *der_len);\n      asn1_length_der (*der_len, der, &len_len);\n    }\n  *der_len += len_len;\n\n  free (temp);\n\n  if (max_len < (*der_len))\n    return ASN1_MEM_ERROR;\n\n  return ASN1_SUCCESS;\n}",
      "lines": 71,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "asn1_bit_der": {
      "start_point": [
        428,
        0
      ],
      "end_point": [
        450,
        1
      ],
      "content": "void\nasn1_bit_der (const unsigned char *str, int bit_len,\n\t      unsigned char *der, int *der_len)\n{\n  int len_len, len_byte, len_pad;\n\n  if (der == NULL)\n    return;\n\n  len_byte = bit_len >> 3;\n  len_pad = 8 - (bit_len & 7);\n  if (len_pad == 8)\n    len_pad = 0;\n  else\n    len_byte++;\n  asn1_length_der (len_byte + 1, der, &len_len);\n  der[len_len] = len_pad;\n\n  if (str)\n    memcpy (der + len_len + 1, str, len_byte);\n  der[len_len + len_byte] &= bit_mask[len_pad];\n  *der_len = len_byte + len_len + 1;\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_asn1_complete_explicit_tag": {
      "start_point": [
        467,
        0
      ],
      "end_point": [
        525,
        1
      ],
      "content": "static int\n_asn1_complete_explicit_tag (asn1_node node, unsigned char *der,\n\t\t\t     int *counter, int *max_len)\n{\n  asn1_node p;\n  int is_tag_implicit, len2, len3;\n  unsigned char temp[SIZEOF_UNSIGNED_INT];\n\n  is_tag_implicit = 0;\n\n  if (node->type & CONST_TAG)\n    {\n      p = node->down;\n      if (p == NULL)\n        return ASN1_DER_ERROR;\n      /* When there are nested tags we must complete them reverse to\n         the order they were created. This is because completing a tag\n         modifies all data within it, including the incomplete tags\n         which store buffer positions -- simon@josefsson.org 2002-09-06\n       */\n      while (p->right)\n\tp = p->right;\n      while (p && p != node->down->left)\n\t{\n\t  if (type_field (p->type) == ASN1_ETYPE_TAG)\n\t    {\n\t      if (p->type & CONST_EXPLICIT)\n\t\t{\n\t\t  len2 = strtol (p->name, NULL, 10);\n\t\t  _asn1_set_name (p, NULL);\n\n\t\t  asn1_length_der (*counter - len2, temp, &len3);\n\t\t  if (len3 <= (*max_len))\n\t\t    {\n\t\t      memmove (der + len2 + len3, der + len2,\n\t\t\t       *counter - len2);\n\t\t      memcpy (der + len2, temp, len3);\n\t\t    }\n\t\t  *max_len -= len3;\n\t\t  *counter += len3;\n\t\t  is_tag_implicit = 0;\n\t\t}\n\t      else\n\t\t{\t\t/* CONST_IMPLICIT */\n\t\t  if (!is_tag_implicit)\n\t\t    {\n\t\t      is_tag_implicit = 1;\n\t\t    }\n\t\t}\n\t    }\n\t  p = p->left;\n\t}\n    }\n\n  if (*max_len < 0)\n    return ASN1_MEM_ERROR;\n\n  return ASN1_SUCCESS;\n}",
      "lines": 59,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_asn1_insert_tag_der": {
      "start_point": [
        593,
        0
      ],
      "end_point": [
        692,
        1
      ],
      "content": "static int\n_asn1_insert_tag_der (asn1_node node, unsigned char *der, int *counter,\n\t\t      int *max_len)\n{\n  asn1_node p;\n  int tag_len, is_tag_implicit;\n  unsigned char class, class_implicit = 0, temp[MAX(SIZEOF_UNSIGNED_INT * 3 + 1, LTOSTR_MAX_SIZE)];\n  unsigned long tag_implicit = 0;\n  unsigned char tag_der[MAX_TAG_LEN];\n\n  is_tag_implicit = 0;\n\n  if (node->type & CONST_TAG)\n    {\n      p = node->down;\n      while (p)\n\t{\n\t  if (type_field (p->type) == ASN1_ETYPE_TAG)\n\t    {\n\t      if (p->type & CONST_APPLICATION)\n\t\tclass = ASN1_CLASS_APPLICATION;\n\t      else if (p->type & CONST_UNIVERSAL)\n\t\tclass = ASN1_CLASS_UNIVERSAL;\n\t      else if (p->type & CONST_PRIVATE)\n\t\tclass = ASN1_CLASS_PRIVATE;\n\t      else\n\t\tclass = ASN1_CLASS_CONTEXT_SPECIFIC;\n\n\t      if (p->type & CONST_EXPLICIT)\n\t\t{\n\t\t  if (is_tag_implicit)\n\t\t    _asn1_tag_der (class_implicit, tag_implicit, tag_der,\n\t\t\t\t   &tag_len);\n\t\t  else\n\t\t    _asn1_tag_der (class | ASN1_CLASS_STRUCTURED,\n\t\t\t\t   _asn1_strtoul (p->value, NULL, 10),\n\t\t\t\t   tag_der, &tag_len);\n\n\t\t  *max_len -= tag_len;\n\t\t  if (der && *max_len >= 0)\n\t\t    memcpy (der + *counter, tag_der, tag_len);\n\t\t  *counter += tag_len;\n\n\t\t  _asn1_ltostr (*counter, (char *) temp);\n\t\t  _asn1_set_name (p, (const char *) temp);\n\n\t\t  is_tag_implicit = 0;\n\t\t}\n\t      else\n\t\t{\t\t/* CONST_IMPLICIT */\n\t\t  if (!is_tag_implicit)\n\t\t    {\n\t\t      if ((type_field (node->type) == ASN1_ETYPE_SEQUENCE) ||\n\t\t\t  (type_field (node->type) == ASN1_ETYPE_SEQUENCE_OF)\n\t\t\t  || (type_field (node->type) == ASN1_ETYPE_SET)\n\t\t\t  || (type_field (node->type) == ASN1_ETYPE_SET_OF))\n\t\t\tclass |= ASN1_CLASS_STRUCTURED;\n\t\t      class_implicit = class;\n\t\t      tag_implicit = _asn1_strtoul (p->value, NULL, 10);\n\t\t      is_tag_implicit = 1;\n\t\t    }\n\t\t}\n\t    }\n\t  p = p->right;\n\t}\n    }\n\n  if (is_tag_implicit)\n    {\n      _asn1_tag_der (class_implicit, tag_implicit, tag_der, &tag_len);\n    }\n  else\n    {\n      unsigned type = type_field (node->type);\n      switch (type)\n\t{\n\tCASE_HANDLED_ETYPES:\n\t  _asn1_tag_der (_asn1_tags[type].class, _asn1_tags[type].tag,\n\t\t\t tag_der, &tag_len);\n\t  break;\n\tcase ASN1_ETYPE_TAG:\n\tcase ASN1_ETYPE_CHOICE:\n\tcase ASN1_ETYPE_ANY:\n\t  tag_len = 0;\n\t  break;\n\tdefault:\n\t  return ASN1_GENERIC_ERROR;\n\t}\n    }\n\n  *max_len -= tag_len;\n  if (der && *max_len >= 0)\n    memcpy (der + *counter, tag_der, tag_len);\n  *counter += tag_len;\n\n  if (*max_len < 0)\n    return ASN1_MEM_ERROR;\n\n  return ASN1_SUCCESS;\n}",
      "lines": 100,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_asn1_ordering_set": {
      "start_point": [
        705,
        0
      ],
      "end_point": [
        830,
        1
      ],
      "content": "static int\n_asn1_ordering_set (unsigned char *der, int der_len, asn1_node node)\n{\n  struct vet\n  {\n    int end;\n    unsigned long value;\n    struct vet *next, *prev;\n  };\n\n  int counter, len, len2;\n  struct vet *first, *last, *p_vet, *p2_vet;\n  asn1_node p;\n  unsigned char class, *temp;\n  unsigned long tag, t;\n  int err;\n\n  counter = 0;\n\n  if (type_field (node->type) != ASN1_ETYPE_SET)\n    return ASN1_VALUE_NOT_VALID;\n\n  p = node->down;\n  while (p && ((type_field (p->type) == ASN1_ETYPE_TAG) ||\n\t (type_field (p->type) == ASN1_ETYPE_SIZE)))\n    p = p->right;\n\n  if ((p == NULL) || (p->right == NULL))\n    return ASN1_SUCCESS;\n\n  first = last = NULL;\n  while (p)\n    {\n      p_vet = malloc (sizeof (struct vet));\n      if (p_vet == NULL)\n        {\n\t  err = ASN1_MEM_ALLOC_ERROR;\n\t  goto error;\n\t}\n\n      p_vet->next = NULL;\n      p_vet->prev = last;\n      if (first == NULL)\n\tfirst = p_vet;\n      else\n\tlast->next = p_vet;\n      last = p_vet;\n\n      /* tag value calculation */\n      err = asn1_get_tag_der (der + counter, der_len - counter, &class, &len2,\n\t\t\t      &tag);\n      if (err != ASN1_SUCCESS)\n\tgoto error;\n\n      t = ((unsigned int)class) << 24;\n      p_vet->value = t | tag;\n      counter += len2;\n\n      /* extraction and length */\n      len2 = asn1_get_length_der (der + counter, der_len - counter, &len);\n      if (len2 < 0)\n\t{\n\t  err = ASN1_DER_ERROR;\n\t  goto error;\n\t}\n      counter += len + len2;\n\n      p_vet->end = counter;\n      p = p->right;\n    }\n\n  p_vet = first;\n\n  while (p_vet)\n    {\n      p2_vet = p_vet->next;\n      counter = 0;\n      while (p2_vet)\n\t{\n\t  if (p_vet->value > p2_vet->value)\n\t    {\n\t      /* change position */\n\t      temp = malloc (p_vet->end - counter);\n\t      if (temp == NULL)\n\t\t{\n\t\t  err = ASN1_MEM_ALLOC_ERROR;\n\t\t  goto error;\n\t\t}\n\n\t      memcpy (temp, der + counter, p_vet->end - counter);\n\t      memcpy (der + counter, der + p_vet->end,\n\t\t      p2_vet->end - p_vet->end);\n\t      memcpy (der + counter + p2_vet->end - p_vet->end, temp,\n\t\t      p_vet->end - counter);\n\t      free (temp);\n\n\t      tag = p_vet->value;\n\t      p_vet->value = p2_vet->value;\n\t      p2_vet->value = tag;\n\n\t      p_vet->end = counter + (p2_vet->end - p_vet->end);\n\t    }\n\t  counter = p_vet->end;\n\n\t  p2_vet = p2_vet->next;\n\t  p_vet = p_vet->next;\n\t}\n\n      if (p_vet != first)\n\tp_vet->prev->next = NULL;\n      else\n\tfirst = NULL;\n      free (p_vet);\n      p_vet = first;\n    }\n  return ASN1_SUCCESS;\n\nerror:\n  while (first != NULL)\n    {\n      p_vet = first;\n      first = first->next;\n      free(p_vet);\n    }\n  return err;\n}",
      "lines": 126,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_asn1_ordering_set_of": {
      "start_point": [
        843,
        0
      ],
      "end_point": [
        989,
        1
      ],
      "content": "static int\n_asn1_ordering_set_of (unsigned char *der, int der_len, asn1_node node)\n{\n  struct vet\n  {\n    int end;\n    struct vet *next, *prev;\n  };\n\n  int counter, len, len2, change;\n  struct vet *first, *last, *p_vet, *p2_vet;\n  asn1_node p;\n  unsigned char *temp, class;\n  unsigned long k, length;\n  int err;\n\n  counter = 0;\n\n  if (type_field (node->type) != ASN1_ETYPE_SET_OF)\n    return ASN1_VALUE_NOT_VALID;\n\n  p = node->down;\n  while (p && ((type_field (p->type) == ASN1_ETYPE_TAG) ||\n\t (type_field (p->type) == ASN1_ETYPE_SIZE)))\n    p = p->right;\n  if (p == NULL)\n    return ASN1_VALUE_NOT_VALID;\n  p = p->right;\n\n  if ((p == NULL) || (p->right == NULL))\n    return ASN1_SUCCESS;\n\n  first = last = NULL;\n  while (p)\n    {\n      p_vet = malloc (sizeof (struct vet));\n      if (p_vet == NULL)\n\t{\n\t  err = ASN1_MEM_ALLOC_ERROR;\n\t  goto error;\n\t}\n\n      p_vet->next = NULL;\n      p_vet->prev = last;\n      if (first == NULL)\n\tfirst = p_vet;\n      else\n\tlast->next = p_vet;\n      last = p_vet;\n\n      /* extraction of tag and length */\n      if (der_len - counter > 0)\n\t{\n\n\t  err = asn1_get_tag_der (der + counter, der_len - counter, &class,\n\t                          &len, NULL);\n\t  if (err != ASN1_SUCCESS)\n\t    goto error;\n\t  counter += len;\n\n\t  len2 = asn1_get_length_der (der + counter, der_len - counter, &len);\n\t  if (len2 < 0)\n\t    {\n\t      err = ASN1_DER_ERROR;\n\t      goto error;\n\t    }\n\t  counter += len + len2;\n\t}\n      else\n\t{\n\t  err = ASN1_DER_ERROR;\n\t  goto error;\n\t}\n\n      p_vet->end = counter;\n      p = p->right;\n    }\n\n  p_vet = first;\n\n  while (p_vet)\n    {\n      p2_vet = p_vet->next;\n      counter = 0;\n      while (p2_vet)\n\t{\n\t  length = MIN(p_vet->end - counter, p2_vet->end - p_vet->end);\n\t  change = -1;\n\t  for (k = 0; k < length; k++)\n\t    if (der[counter + k] > der[p_vet->end + k])\n\t      {\n\t\tchange = 1;\n\t\tbreak;\n\t      }\n\t    else if (der[counter + k] < der[p_vet->end + k])\n\t      {\n\t\tchange = 0;\n\t\tbreak;\n\t      }\n\n\t  if ((change == -1)\n\t      && ((p_vet->end - counter) > (p2_vet->end - p_vet->end)))\n\t    change = 1;\n\n\t  if (change == 1)\n\t    {\n\t      /* change position */\n\t      temp = malloc (p_vet->end - counter);\n\t      if (temp == NULL)\n\t\t{\n\t\t  err = ASN1_MEM_ALLOC_ERROR;\n\t\t  goto error;\n\t\t}\n\n\t      memcpy (temp, der + counter, (p_vet->end) - counter);\n\t      memcpy (der + counter, der + (p_vet->end),\n\t\t      (p2_vet->end) - (p_vet->end));\n\t      memcpy (der + counter + (p2_vet->end) - (p_vet->end), temp,\n\t\t      (p_vet->end) - counter);\n\t      free (temp);\n\n\t      p_vet->end = counter + (p2_vet->end - p_vet->end);\n\t    }\n\t  counter = p_vet->end;\n\n\t  p2_vet = p2_vet->next;\n\t  p_vet = p_vet->next;\n\t}\n\n      if (p_vet != first)\n\tp_vet->prev->next = NULL;\n      else\n\tfirst = NULL;\n      free (p_vet);\n      p_vet = first;\n    }\n  return ASN1_SUCCESS;\n\nerror:\n  while (first != NULL)\n    {\n      p_vet = first;\n      first = first->next;\n      free(p_vet);\n    }\n  return err;\n}",
      "lines": 147,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "asn1_der_coding": {
      "start_point": [
        1012,
        0
      ],
      "end_point": [
        1346,
        1
      ],
      "content": "int\nasn1_der_coding (asn1_node element, const char *name, void *ider, int *len,\n\t\t char *ErrorDescription)\n{\n  asn1_node node, p, p2;\n  unsigned char temp[MAX(LTOSTR_MAX_SIZE, SIZEOF_UNSIGNED_LONG_INT * 3 + 1)];\n  int counter, counter_old, len2, len3, move, max_len, max_len_old;\n  int err;\n  unsigned char *der = ider;\n\n  if (ErrorDescription)\n    ErrorDescription[0] = 0;\n\n  node = asn1_find_node (element, name);\n  if (node == NULL)\n    return ASN1_ELEMENT_NOT_FOUND;\n\n  /* Node is now a locally allocated variable.\n   * That is because in some point we modify the\n   * structure, and I don't know why! --nmav\n   */\n  node = _asn1_copy_structure3 (node);\n  if (node == NULL)\n    return ASN1_ELEMENT_NOT_FOUND;\n\n  max_len = *len;\n\n  counter = 0;\n  move = DOWN;\n  p = node;\n\n  while (1)\n    {\n\n      counter_old = counter;\n      max_len_old = max_len;\n      if (move != UP)\n\t{\n          p->start = counter;\n\t  err = _asn1_insert_tag_der (p, der, &counter, &max_len);\n\t  if (err != ASN1_SUCCESS && err != ASN1_MEM_ERROR)\n\t    goto error;\n\t}\n      switch (type_field (p->type))\n\t{\n\tcase ASN1_ETYPE_NULL:\n\t  max_len--;\n\t  if (max_len >= 0)\n\t    der[counter] = 0;\n\t  counter++;\n\t  move = RIGHT;\n\t  break;\n\tcase ASN1_ETYPE_BOOLEAN:\n\t  if ((p->type & CONST_DEFAULT) && (p->value == NULL))\n\t    {\n\t      counter = counter_old;\n\t      max_len = max_len_old;\n\t    }\n\t  else\n\t    {\n\t      if (p->value == NULL)\n\t\t{\n\t\t  _asn1_error_description_value_not_found (p,\n\t\t\t\t\t\t\t   ErrorDescription);\n\t\t  err = ASN1_VALUE_NOT_FOUND;\n\t\t  goto error;\n\t\t}\n\t      max_len -= 2;\n\t      if (max_len >= 0)\n\t\t{\n\t\t  der[counter++] = 1;\n\t\t  if (p->value[0] == 'F')\n\t\t    der[counter++] = 0;\n\t\t  else\n\t\t    der[counter++] = 0xFF;\n\t\t}\n\t      else\n\t\tcounter += 2;\n\t    }\n\t  move = RIGHT;\n\t  break;\n\tcase ASN1_ETYPE_INTEGER:\n\tcase ASN1_ETYPE_ENUMERATED:\n\t  if ((p->type & CONST_DEFAULT) && (p->value == NULL))\n\t    {\n\t      counter = counter_old;\n\t      max_len = max_len_old;\n\t    }\n\t  else\n\t    {\n\t      if (p->value == NULL)\n\t\t{\n\t\t  _asn1_error_description_value_not_found (p,\n\t\t\t\t\t\t\t   ErrorDescription);\n\t\t  err = ASN1_VALUE_NOT_FOUND;\n\t\t  goto error;\n\t\t}\n\t      len2 = asn1_get_length_der (p->value, p->value_len, &len3);\n\t      if (len2 < 0)\n\t\t{\n\t\t  err = ASN1_DER_ERROR;\n\t\t  goto error;\n\t\t}\n\t      max_len -= len2 + len3;\n\t      if (max_len >= 0)\n\t\tmemcpy (der + counter, p->value, len3 + len2);\n\t      counter += len3 + len2;\n\t    }\n\t  move = RIGHT;\n\t  break;\n\tcase ASN1_ETYPE_OBJECT_ID:\n\t  if ((p->type & CONST_DEFAULT) && (p->value == NULL))\n\t    {\n\t      counter = counter_old;\n\t      max_len = max_len_old;\n\t    }\n\t  else\n\t    {\n\t      if (p->value == NULL)\n\t\t{\n\t\t  _asn1_error_description_value_not_found (p,\n\t\t\t\t\t\t\t   ErrorDescription);\n\t\t  err = ASN1_VALUE_NOT_FOUND;\n\t\t  goto error;\n\t\t}\n\t      len2 = max_len;\n\t      err = _asn1_objectid_der (p->value, der + counter, &len2);\n\t      if (err != ASN1_SUCCESS && err != ASN1_MEM_ERROR)\n\t\tgoto error;\n\n\t      max_len -= len2;\n\t      counter += len2;\n\t    }\n\t  move = RIGHT;\n\t  break;\n\tcase ASN1_ETYPE_GENERALIZED_TIME:\n\tcase ASN1_ETYPE_UTC_TIME:\n\t  if (p->value == NULL)\n\t    {\n\t      _asn1_error_description_value_not_found (p, ErrorDescription);\n\t      err = ASN1_VALUE_NOT_FOUND;\n\t      goto error;\n\t    }\n\t  len2 = max_len;\n\t  err = _asn1_time_der (p->value, p->value_len, der + counter, &len2);\n\t  if (err != ASN1_SUCCESS && err != ASN1_MEM_ERROR)\n\t    goto error;\n\n\t  max_len -= len2;\n\t  counter += len2;\n\t  move = RIGHT;\n\t  break;\n\tcase ASN1_ETYPE_OCTET_STRING:\n\tcase ASN1_ETYPE_GENERALSTRING:\n\tcase ASN1_ETYPE_NUMERIC_STRING:\n\tcase ASN1_ETYPE_IA5_STRING:\n\tcase ASN1_ETYPE_TELETEX_STRING:\n\tcase ASN1_ETYPE_PRINTABLE_STRING:\n\tcase ASN1_ETYPE_UNIVERSAL_STRING:\n\tcase ASN1_ETYPE_BMP_STRING:\n\tcase ASN1_ETYPE_UTF8_STRING:\n\tcase ASN1_ETYPE_VISIBLE_STRING:\n\tcase ASN1_ETYPE_BIT_STRING:\n\t  if (p->value == NULL)\n\t    {\n\t      _asn1_error_description_value_not_found (p, ErrorDescription);\n\t      err = ASN1_VALUE_NOT_FOUND;\n\t      goto error;\n\t    }\n\t  len2 = asn1_get_length_der (p->value, p->value_len, &len3);\n\t  if (len2 < 0)\n\t    {\n\t      err = ASN1_DER_ERROR;\n\t      goto error;\n\t    }\n\t  max_len -= len2 + len3;\n\t  if (max_len >= 0)\n\t    memcpy (der + counter, p->value, len3 + len2);\n\t  counter += len3 + len2;\n\t  move = RIGHT;\n\t  break;\n\tcase ASN1_ETYPE_SEQUENCE:\n\tcase ASN1_ETYPE_SET:\n\t  if (move != UP)\n\t    {\n\t      p->tmp_ival = counter;\n\t      if (p->down == NULL)\n\t\t{\n\t\t  move = UP;\n\t\t  continue;\n\t\t}\n\t      else\n\t\t{\n\t\t  p2 = p->down;\n\t\t  while (p2 && (type_field (p2->type) == ASN1_ETYPE_TAG))\n\t\t    p2 = p2->right;\n\t\t  if (p2)\n\t\t    {\n\t\t      p = p2;\n\t\t      move = RIGHT;\n\t\t      continue;\n\t\t    }\n\t\t  move = UP;\n\t\t  continue;\n\t\t}\n\t    }\n\t  else\n\t    {\t\t\t/* move==UP */\n\t      len2 = p->tmp_ival;\n\t      p->tmp_ival = 0;\n\t      if ((type_field (p->type) == ASN1_ETYPE_SET) && (max_len >= 0))\n\t\t{\n\t\t  err = _asn1_ordering_set (der + len2, counter - len2, p);\n\t\t  if (err != ASN1_SUCCESS)\n\t\t    goto error;\n\t\t}\n\t      asn1_length_der (counter - len2, temp, &len3);\n\t      max_len -= len3;\n\t      if (max_len >= 0)\n\t\t{\n\t\t  memmove (der + len2 + len3, der + len2, counter - len2);\n\t\t  memcpy (der + len2, temp, len3);\n\t\t}\n\t      counter += len3;\n\t      move = RIGHT;\n\t    }\n\t  break;\n\tcase ASN1_ETYPE_SEQUENCE_OF:\n\tcase ASN1_ETYPE_SET_OF:\n\t  if (move != UP)\n\t    {\n\t      p->tmp_ival = counter;\n\t      p = p->down;\n\t      while ((type_field (p->type) == ASN1_ETYPE_TAG)\n\t\t     || (type_field (p->type) == ASN1_ETYPE_SIZE))\n\t\tp = p->right;\n\t      if (p->right)\n\t\t{\n\t\t  p = p->right;\n\t\t  move = RIGHT;\n\t\t  continue;\n\t\t}\n\t      else\n\t\tp = _asn1_find_up (p);\n\t      move = UP;\n\t    }\n\t  if (move == UP)\n\t    {\n\t      len2 = p->tmp_ival;\n\t      p->tmp_ival = 0;\n\t      if ((type_field (p->type) == ASN1_ETYPE_SET_OF)\n\t\t  && (counter - len2 > 0) && (max_len >= 0))\n\t\t{\n\t\t  err = _asn1_ordering_set_of (der + len2, counter - len2, p);\n\t\t  if (err != ASN1_SUCCESS)\n\t\t    goto error;\n\t\t}\n\t      asn1_length_der (counter - len2, temp, &len3);\n\t      max_len -= len3;\n\t      if (max_len >= 0)\n\t\t{\n\t\t  memmove (der + len2 + len3, der + len2, counter - len2);\n\t\t  memcpy (der + len2, temp, len3);\n\t\t}\n\t      counter += len3;\n\t      move = RIGHT;\n\t    }\n\t  break;\n\tcase ASN1_ETYPE_ANY:\n\t  if (p->value == NULL)\n\t    {\n\t      _asn1_error_description_value_not_found (p, ErrorDescription);\n\t      err = ASN1_VALUE_NOT_FOUND;\n\t      goto error;\n\t    }\n\t  len2 = asn1_get_length_der (p->value, p->value_len, &len3);\n\t  if (len2 < 0)\n\t    {\n\t      err = ASN1_DER_ERROR;\n\t      goto error;\n\t    }\n\t  max_len -= len2;\n\t  if (max_len >= 0)\n\t    memcpy (der + counter, p->value + len3, len2);\n\t  counter += len2;\n\t  move = RIGHT;\n\t  break;\n\tdefault:\n\t  move = (move == UP) ? RIGHT : DOWN;\n\t  break;\n\t}\n\n      if ((move != DOWN) && (counter != counter_old))\n\t{\n          p->end = counter - 1;\n\t  err = _asn1_complete_explicit_tag (p, der, &counter, &max_len);\n\t  if (err != ASN1_SUCCESS && err != ASN1_MEM_ERROR)\n\t    goto error;\n\t}\n\n      if (p == node && move != DOWN)\n\tbreak;\n\n      if (move == DOWN)\n\t{\n\t  if (p->down)\n\t    p = p->down;\n\t  else\n\t    move = RIGHT;\n\t}\n      if (move == RIGHT)\n\t{\n\t  if (p->right)\n\t    p = p->right;\n\t  else\n\t    move = UP;\n\t}\n      if (move == UP)\n\tp = _asn1_find_up (p);\n    }\n\n  *len = counter;\n\n  if (max_len < 0)\n    {\n      err = ASN1_MEM_ERROR;\n      goto error;\n    }\n\n  err = ASN1_SUCCESS;\n\nerror:\n  asn1_delete_structure (&node);\n  return err;\n}",
      "lines": 335,
      "depth": 20,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/lib/decoding.c": {
    "_asn1_error_description_tag_error": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "static void\n_asn1_error_description_tag_error (asn1_node node, char *ErrorDescription)\n{\n\n  Estrcpy (ErrorDescription, \":: tag error near element '\");\n  _asn1_hierarchical_name (node, ErrorDescription + strlen (ErrorDescription),\n\t\t\t   ASN1_MAX_ERROR_DESCRIPTION_SIZE - 40);\n  Estrcat (ErrorDescription, \"'\");\n\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "asn1_get_length_der": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "long\nasn1_get_length_der (const unsigned char *der, int der_len, int *len)\n{\n  unsigned int ans;\n  int k, punt, sum;\n\n  *len = 0;\n  if (der_len <= 0)\n    return 0;\n\n  if (!(der[0] & 128))\n    {\n      /* short form */\n      *len = 1;\n      ans = der[0];\n    }\n  else\n    {\n      /* Long form */\n      k = der[0] & 0x7F;\n      punt = 1;\n      if (k)\n\t{ /* definite length method */\n\t  ans = 0;\n\t  while (punt <= k && punt < der_len)\n\t    {\n\t      if (INT_MULTIPLY_OVERFLOW (ans, 256))\n\t\treturn -2;\n\t      ans *= 256;\n\n\t      if (INT_ADD_OVERFLOW (ans, ((unsigned) der[punt])))\n\t\treturn -2;\n\t      ans += der[punt];\n\t      punt++;\n\t    }\n\t}\n      else\n\t{\t\t\t/* indefinite length method */\n\t  *len = punt;\n\t  return -1;\n\t}\n\n      *len = punt;\n    }\n\n  sum = ans;\n  if (ans >= INT_MAX || INT_ADD_OVERFLOW (sum, (*len)))\n    return -2;\n  sum += *len;\n\n  if (sum > der_len)\n    return -4;\n\n  return ans;\n}",
      "lines": 55,
      "depth": 17,
      "decorators": [
        "long",
        "long"
      ]
    },
    "asn1_get_tag_der": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "int\nasn1_get_tag_der (const unsigned char *der, int der_len,\n\t\t  unsigned char *cls, int *len, unsigned long *tag)\n{\n  unsigned int ris;\n  int punt;\n\n  if (der == NULL || der_len < 2 || len == NULL)\n    return ASN1_DER_ERROR;\n\n  *cls = der[0] & 0xE0;\n  if ((der[0] & 0x1F) != 0x1F)\n    {\n      /* short form */\n      *len = 1;\n      ris = der[0] & 0x1F;\n    }\n  else\n    {\n      /* Long form */\n      punt = 1;\n      ris = 0;\n      while (punt < der_len && der[punt] & 128)\n\t{\n\n\t  if (INT_MULTIPLY_OVERFLOW (ris, 128))\n\t    return ASN1_DER_ERROR;\n\t  ris *= 128;\n\n\t  if (INT_ADD_OVERFLOW (ris, ((unsigned) (der[punt] & 0x7F))))\n\t    return ASN1_DER_ERROR;\n\t  ris += (der[punt] & 0x7F);\n\t  punt++;\n\t}\n\n      if (punt >= der_len)\n\treturn ASN1_DER_ERROR;\n\n      if (INT_MULTIPLY_OVERFLOW (ris, 128))\n\treturn ASN1_DER_ERROR;\n      ris *= 128;\n\n      if (INT_ADD_OVERFLOW (ris, ((unsigned) (der[punt] & 0x7F))))\n\treturn ASN1_DER_ERROR;\n      ris += (der[punt] & 0x7F);\n      punt++;\n\n      *len = punt;\n    }\n\n  if (tag)\n    *tag = ris;\n  return ASN1_SUCCESS;\n}",
      "lines": 54,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "asn1_get_length_ber": {
      "start_point": [
        246,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "long\nasn1_get_length_ber (const unsigned char *ber, int ber_len, int *len)\n{\n  int ret;\n  long err;\n\n  ret = asn1_get_length_der (ber, ber_len, len);\n  if (ret == -1 && ber_len > 1)\n    {\t\t\t\t/* indefinite length method */\n      err = _asn1_get_indefinite_length_string (ber + 1, ber_len-1, &ret);\n      if (err != ASN1_SUCCESS)\n\treturn -3;\n    }\n\n  return ret;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "long",
        "long"
      ]
    },
    "asn1_get_octet_der": {
      "start_point": [
        278,
        0
      ],
      "end_point": [
        305,
        1
      ],
      "content": "int\nasn1_get_octet_der (const unsigned char *der, int der_len,\n\t\t    int *ret_len, unsigned char *str, int str_size,\n\t\t    int *str_len)\n{\n  int len_len = 0;\n\n  if (der_len <= 0)\n    return ASN1_GENERIC_ERROR;\n\n  *str_len = asn1_get_length_der (der, der_len, &len_len);\n\n  if (*str_len < 0)\n    return ASN1_DER_ERROR;\n\n  *ret_len = *str_len + len_len;\n  if (str_size >= *str_len)\n    {\n      if (*str_len > 0 && str != NULL)\n        memcpy (str, der + len_len, *str_len);\n    }\n  else\n    {\n      return ASN1_MEM_ERROR;\n    }\n\n  return ASN1_SUCCESS;\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_asn1_get_time_der": {
      "start_point": [
        324,
        0
      ],
      "end_point": [
        390,
        1
      ],
      "content": "static int\n_asn1_get_time_der (unsigned type, const unsigned char *der, int der_len, int *ret_len,\n\t\t    char *str, int str_size, unsigned flags)\n{\n  int len_len, str_len;\n  unsigned i;\n  unsigned sign_count = 0;\n  unsigned dot_count = 0;\n  const unsigned char *p;\n\n  if (der_len <= 0 || str == NULL)\n    return ASN1_DER_ERROR;\n\n  str_len = asn1_get_length_der (der, der_len, &len_len);\n  if (str_len <= 0 || str_size < str_len)\n    return ASN1_DER_ERROR;\n\n  /* perform some sanity checks on the data */\n  if (str_len < 8)\n    {\n      warn();\n      return ASN1_TIME_ENCODING_ERROR;\n    }\n\n  if ((flags & ASN1_DECODE_FLAG_STRICT_DER) && !(flags & ASN1_DECODE_FLAG_ALLOW_INCORRECT_TIME))\n    {\n      p = &der[len_len];\n      for (i=0;i<(unsigned)(str_len-1);i++)\n         {\n           if (isdigit(p[i]) == 0)\n             {\n               if (type == ASN1_ETYPE_GENERALIZED_TIME)\n                 {\n                   /* tolerate lax encodings */\n                   if (p[i] == '.' && dot_count == 0)\n                     {\n                       dot_count++;\n                       continue;\n                     }\n\n               /* This is not really valid DER, but there are\n                * structures using that */\n                   if (!(flags & ASN1_DECODE_FLAG_STRICT_DER) &&\n                       (p[i] == '+' || p[i] == '-') && sign_count == 0)\n                     {\n                       sign_count++;\n                       continue;\n                     }\n                 }\n\n               warn();\n               return ASN1_TIME_ENCODING_ERROR;\n             }\n         }\n\n      if (sign_count == 0 && p[str_len-1] != 'Z')\n        {\n          warn();\n          return ASN1_TIME_ENCODING_ERROR;\n        }\n    }\n  memcpy (str, der + len_len, str_len);\n  str[str_len] = 0;\n  *ret_len = str_len + len_len;\n\n  return ASN1_SUCCESS;\n}",
      "lines": 67,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "asn1_get_object_id_der": {
      "start_point": [
        405,
        0
      ],
      "end_point": [
        465,
        1
      ],
      "content": "int\nasn1_get_object_id_der (const unsigned char *der, int der_len, int *ret_len,\n\t\t\tchar *str, int str_size)\n{\n  int len_len, len, k;\n  int leading;\n  char temp[LTOSTR_MAX_SIZE];\n  uint64_t val, val1;\n\n  *ret_len = 0;\n  if (str && str_size > 0)\n    str[0] = 0;\t\t\t/* no oid */\n\n  if (str == NULL || der_len <= 0)\n    return ASN1_GENERIC_ERROR;\n\n  len = asn1_get_length_der (der, der_len, &len_len);\n\n  if (len <= 0 || len + len_len > der_len)\n    return ASN1_DER_ERROR;\n\n  val1 = der[len_len] / 40;\n  val = der[len_len] - val1 * 40;\n\n  _asn1_str_cpy (str, str_size, _asn1_ltostr (val1, temp));\n  _asn1_str_cat (str, str_size, \".\");\n  _asn1_str_cat (str, str_size, _asn1_ltostr (val, temp));\n\n  val = 0;\n  leading = 1;\n  for (k = 1; k < len; k++)\n    {\n      /* X.690 mandates that the leading byte must never be 0x80\n       */\n      if (leading != 0 && der[len_len + k] == 0x80)\n\treturn ASN1_DER_ERROR;\n      leading = 0;\n\n      /* check for wrap around */\n      if (INT_LEFT_SHIFT_OVERFLOW (val, 7))\n\treturn ASN1_DER_ERROR;\n\n      val = val << 7;\n      val |= der[len_len + k] & 0x7F;\n\n      if (!(der[len_len + k] & 0x80))\n\t{\n\t  _asn1_str_cat (str, str_size, \".\");\n\t  _asn1_str_cat (str, str_size, _asn1_ltostr (val, temp));\n\t  val = 0;\n\t  leading = 1;\n\t}\n    }\n\n  if (INT_ADD_OVERFLOW (len, len_len))\n    return ASN1_DER_ERROR;\n\n  *ret_len = len + len_len;\n\n  return ASN1_SUCCESS;\n}",
      "lines": 61,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "asn1_get_bit_der": {
      "start_point": [
        480,
        0
      ],
      "end_point": [
        511,
        1
      ],
      "content": "int\nasn1_get_bit_der (const unsigned char *der, int der_len,\n\t\t  int *ret_len, unsigned char *str, int str_size,\n\t\t  int *bit_len)\n{\n  int len_len = 0, len_byte;\n\n  if (der_len <= 0)\n    return ASN1_GENERIC_ERROR;\n\n  len_byte = asn1_get_length_der (der, der_len, &len_len) - 1;\n  if (len_byte < 0)\n    return ASN1_DER_ERROR;\n\n  *ret_len = len_byte + len_len + 1;\n  *bit_len = len_byte * 8 - der[len_len];\n\n  if (*bit_len < 0)\n    return ASN1_DER_ERROR;\n\n  if (str_size >= len_byte)\n    {\n      if (len_byte > 0 && str)\n        memcpy (str, der + len_len + 1, len_byte);\n    }\n  else\n    {\n      return ASN1_MEM_ERROR;\n    }\n\n  return ASN1_SUCCESS;\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_asn1_extract_tag_der": {
      "start_point": [
        516,
        0
      ],
      "end_point": [
        698,
        1
      ],
      "content": "static int\n_asn1_extract_tag_der (asn1_node node, const unsigned char *der, int der_len,\n\t\t       int *tag_len, int *inner_tag_len, unsigned flags)\n{\n  asn1_node p;\n  int counter, len2, len3, is_tag_implicit;\n  int result;\n  unsigned long tag, tag_implicit = 0;\n  unsigned char class, class2, class_implicit = 0;\n\n  if (der_len <= 0)\n    return ASN1_GENERIC_ERROR;\n\n  counter = is_tag_implicit = 0;\n\n  if (node->type & CONST_TAG)\n    {\n      p = node->down;\n      while (p)\n\t{\n\t  if (type_field (p->type) == ASN1_ETYPE_TAG)\n\t    {\n\t      if (p->type & CONST_APPLICATION)\n\t\tclass2 = ASN1_CLASS_APPLICATION;\n\t      else if (p->type & CONST_UNIVERSAL)\n\t\tclass2 = ASN1_CLASS_UNIVERSAL;\n\t      else if (p->type & CONST_PRIVATE)\n\t\tclass2 = ASN1_CLASS_PRIVATE;\n\t      else\n\t\tclass2 = ASN1_CLASS_CONTEXT_SPECIFIC;\n\n\t      if (p->type & CONST_EXPLICIT)\n\t\t{\n\t\t  if (asn1_get_tag_der\n\t\t      (der + counter, der_len, &class, &len2,\n\t\t       &tag) != ASN1_SUCCESS)\n\t\t    return ASN1_DER_ERROR;\n\n                  DECR_LEN(der_len, len2);\n\t\t  counter += len2;\n\n\t\t  if (flags & ASN1_DECODE_FLAG_STRICT_DER)\n\t\t    len3 =\n\t\t      asn1_get_length_der (der + counter, der_len,\n\t\t\t\t\t &len2);\n\t\t  else\n\t\t    len3 =\n\t\t      asn1_get_length_ber (der + counter, der_len,\n\t\t\t\t\t &len2);\n\t\t  if (len3 < 0)\n\t\t    return ASN1_DER_ERROR;\n\n                  DECR_LEN(der_len, len2);\n\t\t  counter += len2;\n\n\t\t  if (!is_tag_implicit)\n\t\t    {\n\t\t      if ((class != (class2 | ASN1_CLASS_STRUCTURED)) ||\n\t\t\t  (tag != strtoul ((char *) p->value, NULL, 10)))\n\t\t\treturn ASN1_TAG_ERROR;\n\t\t    }\n\t\t  else\n\t\t    {\t\t/* ASN1_TAG_IMPLICIT */\n\t\t      if ((class != class_implicit) || (tag != tag_implicit))\n\t\t\treturn ASN1_TAG_ERROR;\n\t\t    }\n\t\t  is_tag_implicit = 0;\n\t\t}\n\t      else\n\t\t{\t\t/* ASN1_TAG_IMPLICIT */\n\t\t  if (!is_tag_implicit)\n\t\t    {\n\t\t      if ((type_field (node->type) == ASN1_ETYPE_SEQUENCE) ||\n\t\t\t  (type_field (node->type) == ASN1_ETYPE_SEQUENCE_OF)\n\t\t\t  || (type_field (node->type) == ASN1_ETYPE_SET)\n\t\t\t  || (type_field (node->type) == ASN1_ETYPE_SET_OF))\n\t\t\tclass2 |= ASN1_CLASS_STRUCTURED;\n\t\t      class_implicit = class2;\n\t\t      tag_implicit = strtoul ((char *) p->value, NULL, 10);\n\t\t      is_tag_implicit = 1;\n\t\t    }\n\t\t}\n\t    }\n\t  p = p->right;\n\t}\n    }\n\n  if (is_tag_implicit)\n    {\n      if (asn1_get_tag_der\n\t  (der + counter, der_len, &class, &len2,\n\t   &tag) != ASN1_SUCCESS)\n\treturn ASN1_DER_ERROR;\n\n      DECR_LEN(der_len, len2);\n\n      if ((class != class_implicit) || (tag != tag_implicit))\n\t{\n\t  if (type_field (node->type) == ASN1_ETYPE_OCTET_STRING)\n\t    {\n\t      class_implicit |= ASN1_CLASS_STRUCTURED;\n\t      if ((class != class_implicit) || (tag != tag_implicit))\n\t\treturn ASN1_TAG_ERROR;\n\t    }\n\t  else\n\t    return ASN1_TAG_ERROR;\n\t}\n    }\n  else\n    {\n      unsigned type = type_field (node->type);\n      if (type == ASN1_ETYPE_TAG)\n\t{\n\t  *tag_len = 0;\n\t  if (inner_tag_len)\n\t    *inner_tag_len = 0;\n\t  return ASN1_SUCCESS;\n\t}\n\n      if (asn1_get_tag_der\n\t  (der + counter, der_len, &class, &len2,\n\t   &tag) != ASN1_SUCCESS)\n\treturn ASN1_DER_ERROR;\n\n      DECR_LEN(der_len, len2);\n\n      switch (type)\n\t{\n\tcase ASN1_ETYPE_NULL:\n\tcase ASN1_ETYPE_BOOLEAN:\n\tcase ASN1_ETYPE_INTEGER:\n\tcase ASN1_ETYPE_ENUMERATED:\n\tcase ASN1_ETYPE_OBJECT_ID:\n\tcase ASN1_ETYPE_GENERALSTRING:\n\tcase ASN1_ETYPE_NUMERIC_STRING:\n\tcase ASN1_ETYPE_IA5_STRING:\n\tcase ASN1_ETYPE_TELETEX_STRING:\n\tcase ASN1_ETYPE_PRINTABLE_STRING:\n\tcase ASN1_ETYPE_UNIVERSAL_STRING:\n\tcase ASN1_ETYPE_BMP_STRING:\n\tcase ASN1_ETYPE_UTF8_STRING:\n\tcase ASN1_ETYPE_VISIBLE_STRING:\n\tcase ASN1_ETYPE_BIT_STRING:\n\tcase ASN1_ETYPE_SEQUENCE:\n\tcase ASN1_ETYPE_SEQUENCE_OF:\n\tcase ASN1_ETYPE_SET:\n\tcase ASN1_ETYPE_SET_OF:\n\tcase ASN1_ETYPE_GENERALIZED_TIME:\n\tcase ASN1_ETYPE_UTC_TIME:\n\t  if ((class != _asn1_tags[type].class)\n\t      || (tag != _asn1_tags[type].tag))\n\t    return ASN1_DER_ERROR;\n\t  break;\n\n\tcase ASN1_ETYPE_OCTET_STRING:\n\t  /* OCTET STRING is handled differently to allow\n\t   * BER encodings (structured class). */\n\t  if (((class != ASN1_CLASS_UNIVERSAL)\n\t       && (class != (ASN1_CLASS_UNIVERSAL | ASN1_CLASS_STRUCTURED)))\n\t      || (tag != ASN1_TAG_OCTET_STRING))\n\t    return ASN1_DER_ERROR;\n\t  break;\n\tcase ASN1_ETYPE_ANY:\n\t  counter -= len2;\n\t  break;\n\tcase ASN1_ETYPE_CHOICE:\n\t  counter -= len2;\n\t  break;\n\tdefault:\n\t  return ASN1_DER_ERROR;\n\t  break;\n\t}\n    }\n\n  counter += len2;\n  *tag_len = counter;\n  if (inner_tag_len)\n    *inner_tag_len = len2;\n  return ASN1_SUCCESS;\n\ncleanup:\n  return result;\n}",
      "lines": 183,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "extract_tag_der_recursive": {
      "start_point": [
        700,
        0
      ],
      "end_point": [
        723,
        1
      ],
      "content": "static int\nextract_tag_der_recursive(asn1_node node, const unsigned char *der, int der_len,\n\t\t       int *ret_len, int *inner_len, unsigned flags)\n{\nasn1_node p;\nint ris = ASN1_DER_ERROR;\n\n  if (type_field (node->type) == ASN1_ETYPE_CHOICE)\n    {\n      p = node->down;\n      while (p)\n        {\n          ris = _asn1_extract_tag_der (p, der, der_len, ret_len, inner_len, flags);\n          if (ris == ASN1_SUCCESS)\n            break;\n          p = p->right;\n\t}\n\n      *ret_len = 0;\n      return ris;\n    }\n  else\n    return _asn1_extract_tag_der (node, der, der_len, ret_len, inner_len, flags);\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_asn1_delete_not_used": {
      "start_point": [
        725,
        0
      ],
      "end_point": [
        782,
        1
      ],
      "content": "static int\n_asn1_delete_not_used (asn1_node node)\n{\n  asn1_node p, p2;\n\n  if (node == NULL)\n    return ASN1_ELEMENT_NOT_FOUND;\n\n  p = node;\n  while (p)\n    {\n      if (p->type & CONST_NOT_USED)\n\t{\n\t  p2 = NULL;\n\t  if (p != node)\n\t    {\n\t      p2 = _asn1_find_left (p);\n\t      if (!p2)\n\t\tp2 = _asn1_find_up (p);\n\t    }\n\t  asn1_delete_structure (&p);\n\t  p = p2;\n\t}\n\n      if (!p)\n\tbreak;\t\t\t/* reach node */\n\n      if (p->down)\n\t{\n\t  p = p->down;\n\t}\n      else\n\t{\n\t  if (p == node)\n\t    p = NULL;\n\t  else if (p->right)\n\t    p = p->right;\n\t  else\n\t    {\n\t      while (1)\n\t\t{\n\t\t  p = _asn1_find_up (p);\n\t\t  if (p == node)\n\t\t    {\n\t\t      p = NULL;\n\t\t      break;\n\t\t    }\n\t\t  if (p->right)\n\t\t    {\n\t\t      p = p->right;\n\t\t      break;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n  return ASN1_SUCCESS;\n}",
      "lines": 58,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_asn1_get_indefinite_length_string": {
      "start_point": [
        784,
        0
      ],
      "end_point": [
        839,
        1
      ],
      "content": "static int\n_asn1_get_indefinite_length_string (const unsigned char *der,\n\t\t\t\t    int der_len, int *len)\n{\n  int len2, len3, counter, indefinite;\n  int result;\n  unsigned long tag;\n  unsigned char class;\n\n  counter = indefinite = 0;\n\n  while (1)\n    {\n      if (HAVE_TWO(der_len) && (der[counter] == 0) && (der[counter + 1] == 0))\n\t{\n\t  counter += 2;\n\t  DECR_LEN(der_len, 2);\n\n\t  indefinite--;\n\t  if (indefinite <= 0)\n\t    break;\n\t  else\n\t    continue;\n\t}\n\n      if (asn1_get_tag_der\n\t  (der + counter, der_len, &class, &len2,\n\t   &tag) != ASN1_SUCCESS)\n\treturn ASN1_DER_ERROR;\n\n      DECR_LEN(der_len, len2);\n      counter += len2;\n\n      len2 = asn1_get_length_der (der + counter, der_len, &len3);\n      if (len2 < -1)\n\treturn ASN1_DER_ERROR;\n\n      if (len2 == -1)\n\t{\n\t  indefinite++;\n\t  counter += 1;\n          DECR_LEN(der_len, 1);\n\t}\n      else\n\t{\n\t  counter += len2 + len3;\n          DECR_LEN(der_len, len2+len3);\n\t}\n    }\n\n  *len = counter;\n  return ASN1_SUCCESS;\n\ncleanup:\n  return result;\n}",
      "lines": 56,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "delete_unneeded_choice_fields": {
      "start_point": [
        841,
        0
      ],
      "end_point": [
        850,
        1
      ],
      "content": "static void delete_unneeded_choice_fields(asn1_node p)\n{\n  asn1_node p2;\n\n  while (p->right)\n    {\n      p2 = p->right;\n      asn1_delete_structure (&p2);\n    }\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "asn1_der_decoding2": {
      "start_point": [
        879,
        0
      ],
      "end_point": [
        1544,
        1
      ],
      "content": "int\nasn1_der_decoding2 (asn1_node *element, const void *ider, int *max_ider_len,\n\t\t    unsigned int flags, char *errorDescription)\n{\n  asn1_node node, p, p2, p3;\n  char temp[128];\n  int counter, len2, len3, len4, move, ris, tlen;\n  struct node_tail_cache_st tcache = {NULL, NULL};\n  unsigned char class;\n  unsigned long tag;\n  int tag_len;\n  int indefinite, result, total_len = *max_ider_len, ider_len = *max_ider_len;\n  int inner_tag_len;\n  unsigned char *ptmp;\n  const unsigned char *ptag;\n  const unsigned char *der = ider;\n\n  node = *element;\n\n  if (errorDescription != NULL)\n    errorDescription[0] = 0;\n\n  if (node == NULL)\n    return ASN1_ELEMENT_NOT_FOUND;\n\n  if (node->type & CONST_OPTION)\n    {\n      result = ASN1_GENERIC_ERROR;\n      warn();\n      goto cleanup;\n    }\n\n  counter = 0;\n  move = DOWN;\n  p = node;\n  while (1)\n    {\n      tag_len = 0;\n      inner_tag_len = 0;\n      ris = ASN1_SUCCESS;\n      if (move != UP)\n\t{\n\t  if (p->type & CONST_SET)\n\t    {\n\t      p2 = _asn1_find_up (p);\n\t      len2 = p2->tmp_ival;\n\t      if (len2 == -1)\n\t\t{\n\t\t  if (HAVE_TWO(ider_len) && !der[counter] && !der[counter + 1])\n\t\t    {\n\t\t      p = p2;\n\t\t      move = UP;\n\t\t      counter += 2;\n\t\t      DECR_LEN(ider_len, 2);\n\t\t      continue;\n\t\t    }\n\t\t}\n\t      else if (counter == len2)\n\t\t{\n\t\t  p = p2;\n\t\t  move = UP;\n\t\t  continue;\n\t\t}\n\t      else if (counter > len2)\n\t\t{\n\t\t  result = ASN1_DER_ERROR;\n                  warn();\n\t\t  goto cleanup;\n\t\t}\n\t      p2 = p2->down;\n\t      while (p2)\n\t\t{\n\t\t  if ((p2->type & CONST_SET) && (p2->type & CONST_NOT_USED))\n\t\t    {\n\t\t      ris =\n\t\t\t  extract_tag_der_recursive (p2, der + counter,\n\t\t\t\t\t\t     ider_len, &len2, NULL, flags);\n\t\t      if (ris == ASN1_SUCCESS)\n\t\t\t{\n\t\t\t  p2->type &= ~CONST_NOT_USED;\n\t\t\t  p = p2;\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t  p2 = p2->right;\n\t\t}\n\t      if (p2 == NULL)\n\t\t{\n\t\t  result = ASN1_DER_ERROR;\n                  warn();\n\t\t  goto cleanup;\n\t\t}\n\t    }\n\n\t  /* the position in the DER structure this starts */\n\t  p->start = counter;\n\t  p->end = total_len - 1;\n\n\t  if ((p->type & CONST_OPTION) || (p->type & CONST_DEFAULT))\n\t    {\n\t      p2 = _asn1_find_up (p);\n\t      len2 = p2->tmp_ival;\n\t      if (counter == len2)\n\t\t{\n\t\t  if (p->right)\n\t\t    {\n\t\t      p2 = p->right;\n\t\t      move = RIGHT;\n\t\t    }\n\t\t  else\n\t\t    move = UP;\n\n\t\t  if (p->type & CONST_OPTION)\n\t\t    asn1_delete_structure (&p);\n\n\t\t  p = p2;\n\t\t  continue;\n\t\t}\n\t    }\n\n\t  if (type_field (p->type) == ASN1_ETYPE_CHOICE)\n\t    {\n\t      while (p->down)\n\t\t{\n\t\t  ris =\n\t\t      extract_tag_der_recursive (p->down, der + counter,\n\t\t\t\t\t         ider_len, &len2, NULL, flags);\n\n\t\t  if (ris == ASN1_SUCCESS)\n\t\t    {\n\t\t      delete_unneeded_choice_fields(p->down);\n\t\t      break;\n\t\t    }\n\t\t  else if (ris == ASN1_ERROR_TYPE_ANY)\n\t\t    {\n\t\t      result = ASN1_ERROR_TYPE_ANY;\n                      warn();\n\t\t      goto cleanup;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      p2 = p->down;\n\t\t      asn1_delete_structure (&p2);\n\t\t    }\n\t\t}\n\n\t      if (p->down == NULL)\n\t\t{\n\t\t  if (!(p->type & CONST_OPTION))\n\t\t    {\n\t\t      result = ASN1_DER_ERROR;\n                      warn();\n\t\t      goto cleanup;\n\t\t    }\n\t\t}\n\t      else if (type_field (p->type) != ASN1_ETYPE_CHOICE)\n\t\tp = p->down;\n\n\t      p->start = counter;\n\t    }\n\n\t  if ((p->type & CONST_OPTION) || (p->type & CONST_DEFAULT))\n\t    {\n\t      p2 = _asn1_find_up (p);\n\t      len2 = p2->tmp_ival;\n\n\t      if ((len2 != -1) && (counter > len2))\n\t\tris = ASN1_TAG_ERROR;\n\t    }\n\n\t  if (ris == ASN1_SUCCESS)\n\t    ris =\n\t      extract_tag_der_recursive (p, der + counter, ider_len, \n\t                                 &tag_len, &inner_tag_len, flags);\n\n\t  if (ris != ASN1_SUCCESS)\n\t    {\n\t      if (p->type & CONST_OPTION)\n\t\t{\n\t\t  p->type |= CONST_NOT_USED;\n\t\t  move = RIGHT;\n\t\t}\n\t      else if (p->type & CONST_DEFAULT)\n\t\t{\n\t\t  _asn1_set_value (p, NULL, 0);\n\t\t  move = RIGHT;\n\t\t}\n\t      else\n\t\t{\n\t\t  if (errorDescription != NULL)\n\t\t    _asn1_error_description_tag_error (p, errorDescription);\n\n\t\t  result = ASN1_TAG_ERROR;\n                  warn();\n\t\t  goto cleanup;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      DECR_LEN(ider_len, tag_len);\n\t      counter += tag_len;\n\t    }\n\t}\n\n      if (ris == ASN1_SUCCESS)\n\t{\n\t  switch (type_field (p->type))\n\t    {\n\t    case ASN1_ETYPE_NULL:\n\t      DECR_LEN(ider_len, 1);\n\t      if (der[counter])\n\t\t{\n\t\t  result = ASN1_DER_ERROR;\n                  warn();\n\t\t  goto cleanup;\n\t\t}\n\t      counter++;\n\t      move = RIGHT;\n\t      break;\n\t    case ASN1_ETYPE_BOOLEAN:\n\t      DECR_LEN(ider_len, 2);\n\n\t      if (der[counter++] != 1)\n\t\t{\n\t\t  result = ASN1_DER_ERROR;\n                  warn();\n\t\t  goto cleanup;\n\t\t}\n\t      if (der[counter++] == 0)\n\t\t_asn1_set_value (p, \"F\", 1);\n\t      else\n\t\t_asn1_set_value (p, \"T\", 1);\n\t      move = RIGHT;\n\t      break;\n\t    case ASN1_ETYPE_INTEGER:\n\t    case ASN1_ETYPE_ENUMERATED:\n\t      len2 =\n\t\tasn1_get_length_der (der + counter, ider_len, &len3);\n\t      if (len2 < 0)\n\t\t{\n\t\t  result = ASN1_DER_ERROR;\n                  warn();\n\t\t  goto cleanup;\n\t\t}\n\n\t      DECR_LEN(ider_len, len3+len2);\n\n\t      _asn1_set_value (p, der + counter, len3 + len2);\n\t      counter += len3 + len2;\n\t      move = RIGHT;\n\t      break;\n\t    case ASN1_ETYPE_OBJECT_ID:\n\t      result =\n\t\tasn1_get_object_id_der (der + counter, ider_len, &len2,\n\t\t\t\t\ttemp, sizeof (temp));\n\t      if (result != ASN1_SUCCESS)\n\t        {\n                  warn();\n\t\t  goto cleanup;\n\t\t}\n\n\t      DECR_LEN(ider_len, len2);\n\n\t      tlen = strlen (temp);\n\t      if (tlen > 0)\n\t\t_asn1_set_value (p, temp, tlen + 1);\n\n\t      counter += len2;\n\t      move = RIGHT;\n\t      break;\n\t    case ASN1_ETYPE_GENERALIZED_TIME:\n\t    case ASN1_ETYPE_UTC_TIME:\n\t      result =\n\t\t_asn1_get_time_der (type_field (p->type), der + counter, ider_len, &len2, temp,\n\t\t\t\t    sizeof (temp) - 1, flags);\n\t      if (result != ASN1_SUCCESS)\n\t        {\n                  warn();\n                  goto cleanup;\n                }\n\n\t      DECR_LEN(ider_len, len2);\n\n\t      tlen = strlen (temp);\n\t      if (tlen > 0)\n\t\t_asn1_set_value (p, temp, tlen);\n\n\t      counter += len2;\n\t      move = RIGHT;\n\t      break;\n\t    case ASN1_ETYPE_OCTET_STRING:\n\t      if (counter < inner_tag_len)\n\t        {\n\t\t  result = ASN1_DER_ERROR;\n                  warn();\n\t\t  goto cleanup;\n\t        }\n\n              ptag = der + counter - inner_tag_len;\n              if (flags & ASN1_DECODE_FLAG_STRICT_DER || !(ptag[0] & ASN1_CLASS_STRUCTURED))\n                {\n\t          len2 =\n\t\t    asn1_get_length_der (der + counter, ider_len, &len3);\n\t          if (len2 < 0)\n\t\t    {\n\t\t      result = ASN1_DER_ERROR;\n                      warn();\n\t\t      goto cleanup;\n\t\t    }\n\n\t          DECR_LEN(ider_len, len3+len2);\n\n\t          _asn1_set_value (p, der + counter, len3 + len2);\n\t          counter += len3 + len2;\n                }\n              else\n                {\n                  unsigned dflags = 0, vlen, ber_len;\n\n                  if (ptag[0] & ASN1_CLASS_STRUCTURED)\n                    dflags |= DECODE_FLAG_INDEFINITE;\n\n                  result = _asn1_decode_simple_ber(type_field (p->type), der+counter, ider_len, &ptmp, &vlen, &ber_len, dflags);\n                  if (result != ASN1_SUCCESS)\n\t            {\n                      warn();\n\t\t      goto cleanup;\n\t\t    }\n\n\t\t  DECR_LEN(ider_len, ber_len);\n\n\t\t  _asn1_set_value_lv (p, ptmp, vlen);\n\n\t          counter += ber_len;\n\t          free(ptmp);\n                }\n\t      move = RIGHT;\n\t      break;\n\t    case ASN1_ETYPE_GENERALSTRING:\n\t    case ASN1_ETYPE_NUMERIC_STRING:\n\t    case ASN1_ETYPE_IA5_STRING:\n\t    case ASN1_ETYPE_TELETEX_STRING:\n\t    case ASN1_ETYPE_PRINTABLE_STRING:\n\t    case ASN1_ETYPE_UNIVERSAL_STRING:\n\t    case ASN1_ETYPE_BMP_STRING:\n\t    case ASN1_ETYPE_UTF8_STRING:\n\t    case ASN1_ETYPE_VISIBLE_STRING:\n\t    case ASN1_ETYPE_BIT_STRING:\n\t      len2 =\n\t\tasn1_get_length_der (der + counter, ider_len, &len3);\n\t      if (len2 < 0)\n\t\t{\n\t\t  result = ASN1_DER_ERROR;\n                  warn();\n\t\t  goto cleanup;\n\t\t}\n\n\t      DECR_LEN(ider_len, len3+len2);\n\n\t      _asn1_set_value (p, der + counter, len3 + len2);\n\t      counter += len3 + len2;\n\t      move = RIGHT;\n\t      break;\n\t    case ASN1_ETYPE_SEQUENCE:\n\t    case ASN1_ETYPE_SET:\n\t      if (move == UP)\n\t\t{\n\t\t  len2 = p->tmp_ival;\n\t\t  p->tmp_ival = 0;\n\t\t  if (len2 == -1)\n\t\t    {\t\t/* indefinite length method */\n\t\t      DECR_LEN(ider_len, 2);\n\t\t      if ((der[counter]) || der[counter + 1])\n\t\t        {\n\t\t          result = ASN1_DER_ERROR;\n                          warn();\n\t\t          goto cleanup;\n\t\t\t}\n\t\t      counter += 2;\n\t\t    }\n\t\t  else\n\t\t    {\t\t/* definite length method */\n\t\t      if (len2 != counter)\n\t\t\t{\n\t\t\t  result = ASN1_DER_ERROR;\n                          warn();\n\t\t\t  goto cleanup;\n\t\t\t}\n\t\t    }\n\t\t  move = RIGHT;\n\t\t}\n\t      else\n\t\t{\t\t/* move==DOWN || move==RIGHT */\n\t\t  len3 =\n\t\t    asn1_get_length_der (der + counter, ider_len, &len2);\n                  if (IS_ERR(len3, flags))\n\t\t    {\n\t\t      result = ASN1_DER_ERROR;\n                      warn();\n\t\t      goto cleanup;\n\t\t    }\n\n\t          DECR_LEN(ider_len, len2);\n\t\t  counter += len2;\n\n\t\t  if (len3 > 0)\n\t\t    {\n\t\t      p->tmp_ival = counter + len3;\n\t\t      move = DOWN;\n\t\t    }\n\t\t  else if (len3 == 0)\n\t\t    {\n\t\t      p2 = p->down;\n\t\t      while (p2)\n\t\t\t{\n\t\t\t  if (type_field (p2->type) != ASN1_ETYPE_TAG)\n\t\t\t    {\n\t\t\t      p3 = p2->right;\n\t\t\t      asn1_delete_structure (&p2);\n\t\t\t      p2 = p3;\n\t\t\t    }\n\t\t\t  else\n\t\t\t    p2 = p2->right;\n\t\t\t}\n\t\t      move = RIGHT;\n\t\t    }\n\t\t  else\n\t\t    {\t\t/* indefinite length method */\n\t\t      p->tmp_ival = -1;\n\t\t      move = DOWN;\n\t\t    }\n\t\t}\n\t      break;\n\t    case ASN1_ETYPE_SEQUENCE_OF:\n\t    case ASN1_ETYPE_SET_OF:\n\t      if (move == UP)\n\t\t{\n\t\t  len2 = p->tmp_ival;\n\t\t  if (len2 == -1)\n\t\t    {\t\t/* indefinite length method */\n\t\t      if (!HAVE_TWO(ider_len) || ((der[counter]) || der[counter + 1]))\n\t\t\t{\n\t\t\t  result = _asn1_append_sequence_set (p, &tcache);\n\t\t\t  if (result != 0)\n\t\t\t    {\n                              warn();\n\t\t              goto cleanup;\n\t\t            }\n\t\t\t  p = tcache.tail;\n\t\t\t  move = RIGHT;\n\t\t\t  continue;\n\t\t\t}\n\n\t\t      p->tmp_ival = 0;\n\t\t      tcache.tail = NULL; /* finished decoding this structure */\n\t\t      tcache.head = NULL;\n\t\t      DECR_LEN(ider_len, 2);\n\t\t      counter += 2;\n\t\t    }\n\t\t  else\n\t\t    {\t\t/* definite length method */\n\t\t      if (len2 > counter)\n\t\t\t{\n\t\t\t  result = _asn1_append_sequence_set (p, &tcache);\n\t\t\t  if (result != 0)\n\t\t\t    {\n                              warn();\n\t\t              goto cleanup;\n\t\t            }\n\t\t\t  p = tcache.tail;\n\t\t\t  move = RIGHT;\n\t\t\t  continue;\n\t\t\t}\n\n\t\t      p->tmp_ival = 0;\n\t\t      tcache.tail = NULL; /* finished decoding this structure */\n\t\t      tcache.head = NULL;\n\n\t\t      if (len2 != counter)\n\t\t\t{\n\t\t\t  result = ASN1_DER_ERROR;\n                          warn();\n\t\t\t  goto cleanup;\n\t\t\t}\n\t\t    }\n\t\t}\n\t      else\n\t\t{\t\t/* move==DOWN || move==RIGHT */\n\t\t  len3 =\n\t\t    asn1_get_length_der (der + counter, ider_len, &len2);\n                  if (IS_ERR(len3, flags))\n\t\t    {\n\t\t      result = ASN1_DER_ERROR;\n                      warn();\n\t\t      goto cleanup;\n\t\t    }\n\n\t\t  DECR_LEN(ider_len, len2);\n\t\t  counter += len2;\n\t\t  if (len3)\n\t\t    {\n\t\t      if (len3 > 0)\n\t\t\t{\t/* definite length method */\n\t\t          p->tmp_ival = counter + len3;\n\t\t\t}\n\t\t      else\n\t\t\t{\t/* indefinite length method */\n\t\t          p->tmp_ival = -1;\n\t\t\t}\n\n\t\t      p2 = p->down;\n                      if (p2 == NULL)\n\t\t        {\n\t\t          result = ASN1_DER_ERROR;\n                          warn();\n\t\t          goto cleanup;\n\t\t        }\n\n\t\t      while ((type_field (p2->type) == ASN1_ETYPE_TAG)\n\t\t\t     || (type_field (p2->type) == ASN1_ETYPE_SIZE))\n\t\t\tp2 = p2->right;\n\t\t      if (p2->right == NULL)\n\t\t        {\n\t\t\t  result = _asn1_append_sequence_set (p, &tcache);\n\t\t\t  if (result != 0)\n\t\t\t    {\n                              warn();\n\t\t              goto cleanup;\n\t\t            }\n\t\t\t}\n\t\t      p = p2;\n\t\t    }\n\t\t}\n\t      move = RIGHT;\n\t      break;\n\t    case ASN1_ETYPE_ANY:\n\t      /* Check indefinite lenth method in an EXPLICIT TAG */\n              \n\t      if (!(flags & ASN1_DECODE_FLAG_STRICT_DER) && (p->type & CONST_TAG) && \n\t          tag_len == 2 && (der[counter - 1] == 0x80))\n\t\tindefinite = 1;\n\t      else\n\t        indefinite = 0;\n\n\t      if (asn1_get_tag_der\n\t\t  (der + counter, ider_len, &class, &len2,\n\t\t   &tag) != ASN1_SUCCESS)\n\t\t{\n\t\t  result = ASN1_DER_ERROR;\n                  warn();\n\t\t  goto cleanup;\n\t\t}\n\n\t      DECR_LEN(ider_len, len2);\n\n\t      len4 =\n\t\tasn1_get_length_der (der + counter + len2,\n\t\t\t\t     ider_len, &len3);\n              if (IS_ERR(len4, flags))\n\t\t{\n\t\t  result = ASN1_DER_ERROR;\n                  warn();\n\t\t  goto cleanup;\n\t\t}\n\t      if (len4 != -1) /* definite */\n\t\t{\n\t\t  len2 += len4;\n\n\t          DECR_LEN(ider_len, len4+len3);\n\t\t  _asn1_set_value_lv (p, der + counter, len2 + len3);\n\t\t  counter += len2 + len3;\n\t\t}\n\t      else /* == -1 */\n\t\t{\t\t/* indefinite length */\n\t\t  ider_len += len2; /* undo DECR_LEN */\n\n\t\t  if (counter == 0)\n\t\t    {\n\t\t      result = ASN1_DER_ERROR;\n                      warn();\n\t\t      goto cleanup;\n\t\t    }\n\n\t\t  result =\n\t\t    _asn1_get_indefinite_length_string (der + counter, ider_len, &len2);\n\t\t  if (result != ASN1_SUCCESS)\n\t\t    {\n                      warn();\n                      goto cleanup;\n                    }\n\n\t          DECR_LEN(ider_len, len2);\n\t\t  _asn1_set_value_lv (p, der + counter, len2);\n\t\t  counter += len2;\n\n\t\t}\n\n\t        /* Check if a couple of 0x00 are present due to an EXPLICIT TAG with\n\t           an indefinite length method. */\n\t        if (indefinite)\n\t\t  {\n\t            DECR_LEN(ider_len, 2);\n\t\t    if (!der[counter] && !der[counter + 1])\n\t\t      {\n\t\t        counter += 2;\n\t\t      }\n\t\t    else\n\t\t      {\n\t\t        result = ASN1_DER_ERROR;\n                        warn();\n\t\t        goto cleanup;\n\t\t      }\n\t\t  }\n\n\t      move = RIGHT;\n\t      break;\n\t    default:\n\t      move = (move == UP) ? RIGHT : DOWN;\n\t      break;\n\t    }\n\t}\n\n      if (p)\n        {\n          p->end = counter - 1;\n        }\n\n      if (p == node && move != DOWN)\n\tbreak;\n\n      if (move == DOWN)\n\t{\n\t  if (p->down)\n\t    p = p->down;\n\t  else\n\t    move = RIGHT;\n\t}\n      if ((move == RIGHT) && !(p->type & CONST_SET))\n\t{\n\t  if (p->right)\n\t    p = p->right;\n\t  else\n\t    move = UP;\n\t}\n      if (move == UP)\n\tp = _asn1_find_up (p);\n    }\n\n  _asn1_delete_not_used (*element);\n\n  if ((ider_len < 0) ||\n      (!(flags & ASN1_DECODE_FLAG_ALLOW_PADDING) && (ider_len != 0)))\n    {\n      warn();\n      result = ASN1_DER_ERROR;\n      goto cleanup;\n    }\n\n  *max_ider_len = total_len - ider_len;\n\n  return ASN1_SUCCESS;\n\ncleanup:\n  asn1_delete_structure (element);\n  return result;\n}",
      "lines": 666,
      "depth": 23,
      "decorators": [
        "int"
      ]
    },
    "asn1_der_decoding": {
      "start_point": [
        1567,
        0
      ],
      "end_point": [
        1572,
        1
      ],
      "content": "int\nasn1_der_decoding (asn1_node * element, const void *ider, int ider_len,\n\t\t   char *errorDescription)\n{\n  return asn1_der_decoding2 (element, ider, &ider_len, 0, errorDescription);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "asn1_der_decoding_element": {
      "start_point": [
        1598,
        0
      ],
      "end_point": [
        1603,
        1
      ],
      "content": "int\nasn1_der_decoding_element (asn1_node * structure, const char *elementName,\n\t\t\t   const void *ider, int len, char *errorDescription)\n{\n  return asn1_der_decoding(structure, ider, len, errorDescription);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "asn1_der_decoding_startEnd": {
      "start_point": [
        1633,
        0
      ],
      "end_point": [
        1678,
        1
      ],
      "content": "int\nasn1_der_decoding_startEnd (asn1_node element, const void *ider, int ider_len,\n\t\t\t    const char *name_element, int *start, int *end)\n{\n  asn1_node node, node_to_find;\n  int result = ASN1_DER_ERROR;\n\n  node = element;\n\n  if (node == NULL)\n    return ASN1_ELEMENT_NOT_FOUND;\n\n  node_to_find = asn1_find_node (node, name_element);\n\n  if (node_to_find == NULL)\n    return ASN1_ELEMENT_NOT_FOUND;\n\n  *start = node_to_find->start;\n  *end = node_to_find->end;\n\n  if (*start == 0 && *end == 0)\n    {\n      if (ider == NULL || ider_len == 0)\n        return ASN1_GENERIC_ERROR;\n\n      /* it seems asn1_der_decoding() wasn't called before. Do it now */\n      result = asn1_der_decoding (&node, ider, ider_len, NULL);\n      if (result != ASN1_SUCCESS)\n        {\n          warn();\n          return result;\n        }\n\n      node_to_find = asn1_find_node (node, name_element);\n      if (node_to_find == NULL)\n        return ASN1_ELEMENT_NOT_FOUND;\n\n      *start = node_to_find->start;\n      *end = node_to_find->end;\n    }\n\n  if (*end < *start)\n    return ASN1_GENERIC_ERROR;\n\n  return ASN1_SUCCESS;\n}",
      "lines": 46,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "asn1_expand_any_defined_by": {
      "start_point": [
        1696,
        0
      ],
      "end_point": [
        1904,
        1
      ],
      "content": "int\nasn1_expand_any_defined_by (asn1_node definitions, asn1_node * element)\n{\n  char name[2 * ASN1_MAX_NAME_SIZE + 1],\n    value[ASN1_MAX_NAME_SIZE];\n  int retCode = ASN1_SUCCESS, result;\n  int len, len2, len3;\n  asn1_node p, p2, p3, aux = NULL;\n  char errorDescription[ASN1_MAX_ERROR_DESCRIPTION_SIZE];\n  const char *definitionsName;\n\n  if ((definitions == NULL) || (*element == NULL))\n    return ASN1_ELEMENT_NOT_FOUND;\n\n  definitionsName = definitions->name;\n\n  p = *element;\n  while (p)\n    {\n\n      switch (type_field (p->type))\n\t{\n\tcase ASN1_ETYPE_ANY:\n\t  if ((p->type & CONST_DEFINED_BY) && (p->value))\n\t    {\n\t      /* search the \"DEF_BY\" element */\n\t      p2 = p->down;\n\t      while ((p2) && (type_field (p2->type) != ASN1_ETYPE_CONSTANT))\n\t\tp2 = p2->right;\n\n\t      if (!p2)\n\t\t{\n\t\t  retCode = ASN1_ERROR_TYPE_ANY;\n\t\t  break;\n\t\t}\n\n\t      p3 = _asn1_find_up (p);\n\n\t      if (!p3)\n\t\t{\n\t\t  retCode = ASN1_ERROR_TYPE_ANY;\n\t\t  break;\n\t\t}\n\n\t      p3 = p3->down;\n\t      while (p3)\n\t\t{\n\t\t  if (!(strcmp (p3->name, p2->name)))\n\t\t    break;\n\t\t  p3 = p3->right;\n\t\t}\n\n\t      if ((!p3) || (type_field (p3->type) != ASN1_ETYPE_OBJECT_ID) ||\n\t\t  (p3->value == NULL))\n\t\t{\n\n\t\t  p3 = _asn1_find_up (p);\n\t\t  p3 = _asn1_find_up (p3);\n\n\t\t  if (!p3)\n\t\t    {\n\t\t      retCode = ASN1_ERROR_TYPE_ANY;\n\t\t      break;\n\t\t    }\n\n\t\t  p3 = p3->down;\n\n\t\t  while (p3)\n\t\t    {\n\t\t      if (!(strcmp (p3->name, p2->name)))\n\t\t\tbreak;\n\t\t      p3 = p3->right;\n\t\t    }\n\n\t\t  if ((!p3) || (type_field (p3->type) != ASN1_ETYPE_OBJECT_ID)\n\t\t      || (p3->value == NULL))\n\t\t    {\n\t\t      retCode = ASN1_ERROR_TYPE_ANY;\n\t\t      break;\n\t\t    }\n\t\t}\n\n\t      /* search the OBJECT_ID into definitions */\n\t      p2 = definitions->down;\n\t      while (p2)\n\t\t{\n\t\t  if ((type_field (p2->type) == ASN1_ETYPE_OBJECT_ID) &&\n\t\t      (p2->type & CONST_ASSIGN))\n\t\t    {\n\t\t      snprintf(name, sizeof(name), \"%s.%s\", definitionsName, p2->name);\n\n\t\t      len = ASN1_MAX_NAME_SIZE;\n\t\t      result =\n\t\t\tasn1_read_value (definitions, name, value, &len);\n\n\t\t      if ((result == ASN1_SUCCESS)\n\t\t\t  && (!_asn1_strcmp (p3->value, value)))\n\t\t\t{\n\t\t\t  p2 = p2->right;\t/* pointer to the structure to\n\t\t\t\t\t\t   use for expansion */\n\t\t\t  while ((p2) && (p2->type & CONST_ASSIGN))\n\t\t\t    p2 = p2->right;\n\n\t\t\t  if (p2)\n\t\t\t    {\n\t\t\t      snprintf(name, sizeof(name), \"%s.%s\", definitionsName, p2->name);\n\n\t\t\t      result =\n\t\t\t\tasn1_create_element (definitions, name, &aux);\n\t\t\t      if (result == ASN1_SUCCESS)\n\t\t\t\t{\n\t\t\t\t  _asn1_cpy_name (aux, p);\n\t\t\t\t  len2 =\n\t\t\t\t    asn1_get_length_der (p->value,\n\t\t\t\t\t\t\t p->value_len, &len3);\n\t\t\t\t  if (len2 < 0)\n\t\t\t\t    return ASN1_DER_ERROR;\n\n\t\t\t\t  result =\n\t\t\t\t    asn1_der_decoding (&aux, p->value + len3,\n\t\t\t\t\t\t       len2,\n\t\t\t\t\t\t       errorDescription);\n\t\t\t\t  if (result == ASN1_SUCCESS)\n\t\t\t\t    {\n\n\t\t\t\t      _asn1_set_right (aux, p->right);\n\t\t\t\t      _asn1_set_right (p, aux);\n\n\t\t\t\t      result = asn1_delete_structure (&p);\n\t\t\t\t      if (result == ASN1_SUCCESS)\n\t\t\t\t\t{\n\t\t\t\t\t  p = aux;\n\t\t\t\t\t  aux = NULL;\n\t\t\t\t\t  break;\n\t\t\t\t\t}\n\t\t\t\t      else\n\t\t\t\t\t{\t/* error with asn1_delete_structure */\n\t\t\t\t\t  asn1_delete_structure (&aux);\n\t\t\t\t\t  retCode = result;\n\t\t\t\t\t  break;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t  else\n\t\t\t\t    {\t/* error with asn1_der_decoding */\n\t\t\t\t      retCode = result;\n\t\t\t\t      break;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t      else\n\t\t\t\t{\t/* error with asn1_create_element */\n\t\t\t\t  retCode = result;\n\t\t\t\t  break;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t  else\n\t\t\t    {\t/* error with the pointer to the structure to exapand */\n\t\t\t      retCode = ASN1_ERROR_TYPE_ANY;\n\t\t\t      break;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t  p2 = p2->right;\n\t\t}\t\t/* end while */\n\n\t      if (!p2)\n\t\t{\n\t\t  retCode = ASN1_ERROR_TYPE_ANY;\n\t\t  break;\n\t\t}\n\n\t    }\n\t  break;\n\tdefault:\n\t  break;\n\t}\n\n\n      if (p->down)\n\t{\n\t  p = p->down;\n\t}\n      else if (p == *element)\n\t{\n\t  p = NULL;\n\t  break;\n\t}\n      else if (p->right)\n\tp = p->right;\n      else\n\t{\n\t  while (1)\n\t    {\n\t      p = _asn1_find_up (p);\n\t      if (p == *element)\n\t\t{\n\t\t  p = NULL;\n\t\t  break;\n\t\t}\n\t      if (p->right)\n\t\t{\n\t\t  p = p->right;\n\t\t  break;\n\t\t}\n\t    }\n\t}\n    }\n\n  return retCode;\n}",
      "lines": 209,
      "depth": 28,
      "decorators": [
        "int"
      ]
    },
    "asn1_expand_octet_string": {
      "start_point": [
        1924,
        0
      ],
      "end_point": [
        2046,
        1
      ],
      "content": "int\nasn1_expand_octet_string (asn1_node definitions, asn1_node * element,\n\t\t\t  const char *octetName, const char *objectName)\n{\n  char name[2 * ASN1_MAX_NAME_SIZE + 1], value[ASN1_MAX_NAME_SIZE];\n  int retCode = ASN1_SUCCESS, result;\n  int len, len2, len3;\n  asn1_node p2, aux = NULL;\n  asn1_node octetNode = NULL, objectNode = NULL;\n  char errorDescription[ASN1_MAX_ERROR_DESCRIPTION_SIZE];\n\n  if ((definitions == NULL) || (*element == NULL))\n    return ASN1_ELEMENT_NOT_FOUND;\n\n  octetNode = asn1_find_node (*element, octetName);\n  if (octetNode == NULL)\n    return ASN1_ELEMENT_NOT_FOUND;\n  if (type_field (octetNode->type) != ASN1_ETYPE_OCTET_STRING)\n    return ASN1_ELEMENT_NOT_FOUND;\n  if (octetNode->value == NULL)\n    return ASN1_VALUE_NOT_FOUND;\n\n  objectNode = asn1_find_node (*element, objectName);\n  if (objectNode == NULL)\n    return ASN1_ELEMENT_NOT_FOUND;\n\n  if (type_field (objectNode->type) != ASN1_ETYPE_OBJECT_ID)\n    return ASN1_ELEMENT_NOT_FOUND;\n\n  if (objectNode->value == NULL)\n    return ASN1_VALUE_NOT_FOUND;\n\n\n  /* search the OBJECT_ID into definitions */\n  p2 = definitions->down;\n  while (p2)\n    {\n      if ((type_field (p2->type) == ASN1_ETYPE_OBJECT_ID) &&\n\t  (p2->type & CONST_ASSIGN))\n\t{\n\t  strcpy (name, definitions->name);\n\t  strcat (name, \".\");\n\t  strcat (name, p2->name);\n\n\t  len = sizeof (value);\n\t  result = asn1_read_value (definitions, name, value, &len);\n\n\t  if ((result == ASN1_SUCCESS)\n\t      && (!_asn1_strcmp (objectNode->value, value)))\n\t    {\n\n\t      p2 = p2->right;\t/* pointer to the structure to\n\t\t\t\t   use for expansion */\n\t      while ((p2) && (p2->type & CONST_ASSIGN))\n\t\tp2 = p2->right;\n\n\t      if (p2)\n\t\t{\n\t\t  strcpy (name, definitions->name);\n\t\t  strcat (name, \".\");\n\t\t  strcat (name, p2->name);\n\n\t\t  result = asn1_create_element (definitions, name, &aux);\n\t\t  if (result == ASN1_SUCCESS)\n\t\t    {\n\t\t      _asn1_cpy_name (aux, octetNode);\n\t\t      len2 =\n\t\t\tasn1_get_length_der (octetNode->value,\n\t\t\t\t\t     octetNode->value_len, &len3);\n\t\t      if (len2 < 0)\n\t\t\treturn ASN1_DER_ERROR;\n\n\t\t      result =\n\t\t\tasn1_der_decoding (&aux, octetNode->value + len3,\n\t\t\t\t\t   len2, errorDescription);\n\t\t      if (result == ASN1_SUCCESS)\n\t\t\t{\n\n\t\t\t  _asn1_set_right (aux, octetNode->right);\n\t\t\t  _asn1_set_right (octetNode, aux);\n\n\t\t\t  result = asn1_delete_structure (&octetNode);\n\t\t\t  if (result == ASN1_SUCCESS)\n\t\t\t    {\n\t\t\t      aux = NULL;\n\t\t\t      break;\n\t\t\t    }\n\t\t\t  else\n\t\t\t    {\t/* error with asn1_delete_structure */\n\t\t\t      asn1_delete_structure (&aux);\n\t\t\t      retCode = result;\n\t\t\t      break;\n\t\t\t    }\n\t\t\t}\n\t\t      else\n\t\t\t{\t/* error with asn1_der_decoding */\n\t\t\t  retCode = result;\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t  else\n\t\t    {\t\t/* error with asn1_create_element */\n\t\t      retCode = result;\n\t\t      break;\n\t\t    }\n\t\t}\n\t      else\n\t\t{\t\t/* error with the pointer to the structure to exapand */\n\t\t  retCode = ASN1_VALUE_NOT_VALID;\n\t\t  break;\n\t\t}\n\t    }\n\t}\n\n      p2 = p2->right;\n\n    }\n\n  if (!p2)\n    retCode = ASN1_VALUE_NOT_VALID;\n\n  return retCode;\n}",
      "lines": 123,
      "depth": 21,
      "decorators": [
        "int"
      ]
    },
    "_asn1_decode_simple_der": {
      "start_point": [
        2062,
        0
      ],
      "end_point": [
        2118,
        1
      ],
      "content": "static int\n_asn1_decode_simple_der (unsigned int etype, const unsigned char *der,\n\t\t\tunsigned int _der_len, const unsigned char **str,\n\t\t\tunsigned int *str_len, unsigned dflags)\n{\n  int tag_len, len_len;\n  const unsigned char *p;\n  int der_len = _der_len;\n  unsigned char class;\n  unsigned long tag;\n  long ret;\n\n  if (der == NULL || der_len == 0)\n    return ASN1_VALUE_NOT_VALID;\n\n  if (ETYPE_OK (etype) == 0 || ETYPE_IS_STRING(etype) == 0)\n    return ASN1_VALUE_NOT_VALID;\n\n  /* doesn't handle constructed classes */\n  class = ETYPE_CLASS(etype);\n  if (class != ASN1_CLASS_UNIVERSAL)\n    return ASN1_VALUE_NOT_VALID;\n\n  p = der;\n\n  if (dflags & DECODE_FLAG_HAVE_TAG)\n    {\n      ret = asn1_get_tag_der (p, der_len, &class, &tag_len, &tag);\n      if (ret != ASN1_SUCCESS)\n        return ret;\n\n      if (class != ETYPE_CLASS (etype) || tag != ETYPE_TAG (etype))\n        {\n          warn();\n          return ASN1_DER_ERROR;\n        }\n\n      p += tag_len;\n      der_len -= tag_len;\n      if (der_len <= 0)\n        return ASN1_DER_ERROR;\n    }\n\n  ret = asn1_get_length_der (p, der_len, &len_len);\n  if (ret < 0)\n    return ASN1_DER_ERROR;\n\n  p += len_len;\n  der_len -= len_len;\n  if (der_len <= 0)\n    return ASN1_DER_ERROR;\n\n  *str_len = ret;\n  *str = p;\n\n  return ASN1_SUCCESS;\n}",
      "lines": 57,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "asn1_decode_simple_der": {
      "start_point": [
        2133,
        0
      ],
      "end_point": [
        2139,
        1
      ],
      "content": "int\nasn1_decode_simple_der (unsigned int etype, const unsigned char *der,\n\t\t\tunsigned int _der_len, const unsigned char **str,\n\t\t\tunsigned int *str_len)\n{\n  return _asn1_decode_simple_der(etype, der, _der_len, str, str_len, DECODE_FLAG_HAVE_TAG);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "append": {
      "start_point": [
        2141,
        0
      ],
      "end_point": [
        2149,
        1
      ],
      "content": "static int append(uint8_t **dst, unsigned *dst_size, const unsigned char *src, unsigned src_size)\n{\n  *dst = _asn1_realloc(*dst, *dst_size+src_size);\n  if (*dst == NULL)\n    return ASN1_MEM_ERROR;\n  memcpy(*dst + *dst_size, src, src_size);\n  *dst_size += src_size;\n  return ASN1_SUCCESS;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_asn1_decode_simple_ber": {
      "start_point": [
        2167,
        0
      ],
      "end_point": [
        2352,
        1
      ],
      "content": "static int\n_asn1_decode_simple_ber (unsigned int etype, const unsigned char *der,\n\t\t\tunsigned int _der_len, unsigned char **str,\n\t\t\tunsigned int *str_len, unsigned int *ber_len,\n\t\t\tunsigned dflags)\n{\n  int tag_len, len_len;\n  const unsigned char *p;\n  int der_len = _der_len;\n  uint8_t *total = NULL;\n  unsigned total_size = 0;\n  unsigned char class;\n  unsigned long tag;\n  unsigned char *out = NULL;\n  const unsigned char *cout = NULL;\n  unsigned out_len;\n  long result;\n\n  if (ber_len) *ber_len = 0;\n\n  if (der == NULL || der_len == 0)\n    {\n      warn();\n      return ASN1_VALUE_NOT_VALID;\n    }\n\n  if (ETYPE_OK (etype) == 0)\n    {\n      warn();\n      return ASN1_VALUE_NOT_VALID;\n    }\n\n  /* doesn't handle constructed + definite classes */\n  class = ETYPE_CLASS (etype);\n  if (class != ASN1_CLASS_UNIVERSAL)\n    {\n      warn();\n      return ASN1_VALUE_NOT_VALID;\n    }\n\n  p = der;\n\n  if (dflags & DECODE_FLAG_HAVE_TAG)\n    {\n      result = asn1_get_tag_der (p, der_len, &class, &tag_len, &tag);\n        if (result != ASN1_SUCCESS)\n          {\n            warn();\n            return result;\n          }\n\n        if (tag != ETYPE_TAG (etype))\n          {\n            warn();\n            return ASN1_DER_ERROR;\n          }\n\n        p += tag_len;\n\n        DECR_LEN(der_len, tag_len);\n\n        if (ber_len) *ber_len += tag_len;\n    }\n\n  /* indefinite constructed */\n  if ((((dflags & DECODE_FLAG_INDEFINITE) || class == ASN1_CLASS_STRUCTURED) && ETYPE_IS_STRING(etype)) &&\n      !(dflags & DECODE_FLAG_LEVEL3))\n    {\n      len_len = 1;\n\n      DECR_LEN(der_len, len_len);\n      if (p[0] != 0x80)\n        {\n          warn();\n          result = ASN1_DER_ERROR;\n          goto cleanup;\n        }\n\n      p += len_len;\n\n      if (ber_len) *ber_len += len_len;\n\n      /* decode the available octet strings */\n      do\n        {\n          unsigned tmp_len;\n          unsigned flags = DECODE_FLAG_HAVE_TAG;\n\n          if (dflags & DECODE_FLAG_LEVEL1)\n                flags |= DECODE_FLAG_LEVEL2;\n          else if (dflags & DECODE_FLAG_LEVEL2)\n\t\tflags |= DECODE_FLAG_LEVEL3;\n\t  else\n\t\tflags |= DECODE_FLAG_LEVEL1;\n\n          result = _asn1_decode_simple_ber(etype, p, der_len, &out, &out_len, &tmp_len,\n                                           flags);\n          if (result != ASN1_SUCCESS)\n            {\n              warn();\n              goto cleanup;\n            }\n\n          p += tmp_len;\n          DECR_LEN(der_len, tmp_len);\n\n          if (ber_len) *ber_len += tmp_len;\n\n          DECR_LEN(der_len, 2); /* we need the EOC */\n\n\t  if (out_len > 0)\n\t    {\n              result = append(&total, &total_size, out, out_len);\n              if (result != ASN1_SUCCESS)\n                {\n                  warn();\n                  goto cleanup;\n                }\n\t    }\n\n          free(out);\n          out = NULL;\n\n\t  if (p[0] == 0 && p[1] == 0) /* EOC */\n\t    {\n              if (ber_len) *ber_len += 2;\n              break;\n            }\n\n          /* no EOC */\n          der_len += 2;\n\n          if (der_len == 2)\n            {\n              warn();\n              result = ASN1_DER_ERROR;\n              goto cleanup;\n            }\n        }\n      while(1);\n    }\n  else if (class == ETYPE_CLASS(etype))\n    {\n      if (ber_len)\n        {\n          result = asn1_get_length_der (p, der_len, &len_len);\n          if (result < 0)\n            {\n              warn();\n              result = ASN1_DER_ERROR;\n              goto cleanup;\n            }\n          *ber_len += result + len_len;\n        }\n\n      /* non-string values are decoded as DER */\n      result = _asn1_decode_simple_der(etype, der, _der_len, &cout, &out_len, dflags);\n      if (result != ASN1_SUCCESS)\n        {\n          warn();\n          goto cleanup;\n        }\n\n      result = append(&total, &total_size, cout, out_len);\n      if (result != ASN1_SUCCESS)\n        {\n          warn();\n          goto cleanup;\n        }\n    }\n  else\n    {\n      warn();\n      result = ASN1_DER_ERROR;\n      goto cleanup;\n    }\n\n  *str = total;\n  *str_len = total_size;\n\n  return ASN1_SUCCESS;\ncleanup:\n  free(out);\n  free(total);\n  return result;\n}",
      "lines": 186,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "asn1_decode_simple_ber": {
      "start_point": [
        2369,
        0
      ],
      "end_point": [
        2375,
        1
      ],
      "content": "int\nasn1_decode_simple_ber (unsigned int etype, const unsigned char *der,\n\t\t\tunsigned int _der_len, unsigned char **str,\n\t\t\tunsigned int *str_len, unsigned int *ber_len)\n{\n  return _asn1_decode_simple_ber(etype, der, _der_len, str, str_len, ber_len, DECODE_FLAG_HAVE_TAG);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/lib/element.c": {
    "_asn1_hierarchical_name": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "void\n_asn1_hierarchical_name (asn1_node node, char *name, int name_size)\n{\n  asn1_node p;\n  char tmp_name[64];\n\n  p = node;\n\n  name[0] = 0;\n\n  while (p != NULL)\n    {\n      if (p->name[0] != 0)\n\t{\n\t  _asn1_str_cpy (tmp_name, sizeof (tmp_name), name),\n\t    _asn1_str_cpy (name, name_size, p->name);\n\t  _asn1_str_cat (name, name_size, \".\");\n\t  _asn1_str_cat (name, name_size, tmp_name);\n\t}\n      p = _asn1_find_up (p);\n    }\n\n  if (name[0] == 0)\n    _asn1_str_cpy (name, name_size, \"ROOT\");\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_asn1_convert_integer": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "int\n_asn1_convert_integer (const unsigned char *value, unsigned char *value_out,\n\t\t       int value_out_size, int *len)\n{\n  char negative;\n  unsigned char val[SIZEOF_UNSIGNED_LONG_INT];\n  long valtmp;\n  int k, k2;\n\n  valtmp = _asn1_strtol (value, NULL, 10);\n\n  for (k = 0; k < SIZEOF_UNSIGNED_LONG_INT; k++)\n    {\n      val[SIZEOF_UNSIGNED_LONG_INT - k - 1] = (valtmp >> (8 * k)) & 0xFF;\n    }\n\n  if (val[0] & 0x80)\n    negative = 1;\n  else\n    negative = 0;\n\n  for (k = 0; k < SIZEOF_UNSIGNED_LONG_INT - 1; k++)\n    {\n      if (negative && (val[k] != 0xFF))\n\tbreak;\n      else if (!negative && val[k])\n\tbreak;\n    }\n\n  if ((negative && !(val[k] & 0x80)) || (!negative && (val[k] & 0x80)))\n    k--;\n\n  *len = SIZEOF_UNSIGNED_LONG_INT - k;\n\n  if (SIZEOF_UNSIGNED_LONG_INT - k > value_out_size)\n    /* VALUE_OUT is too short to contain the value conversion */\n    return ASN1_MEM_ERROR;\n\n  if (value_out != NULL)\n    {\n      for (k2 = k; k2 < SIZEOF_UNSIGNED_LONG_INT; k2++)\n        value_out[k2 - k] = val[k2];\n    }\n\n#if 0\n  printf (\"_asn1_convert_integer: valueIn=%s, lenOut=%d\", value, *len);\n  for (k = 0; k < SIZEOF_UNSIGNED_LONG_INT; k++)\n    printf (\", vOut[%d]=%d\", k, value_out[k]);\n  printf (\"\\n\");\n#endif\n\n  return ASN1_SUCCESS;\n}",
      "lines": 53,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "_asn1_append_sequence_set": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        191,
        1
      ],
      "content": "int\n_asn1_append_sequence_set (asn1_node node, struct node_tail_cache_st *pcache)\n{\n  asn1_node p, p2;\n  char temp[LTOSTR_MAX_SIZE];\n  long n;\n\n  if (!node || !(node->down))\n    return ASN1_GENERIC_ERROR;\n\n  p = node->down;\n  while ((type_field (p->type) == ASN1_ETYPE_TAG)\n\t || (type_field (p->type) == ASN1_ETYPE_SIZE))\n    p = p->right;\n\n  p2 = _asn1_copy_structure3 (p);\n  if (p2 == NULL)\n    return ASN1_GENERIC_ERROR;\n\n  if (pcache == NULL || pcache->tail == NULL || pcache->head != node)\n    {\n      while (p->right)\n        {\n          p = p->right;\n        }\n    }\n  else\n    {\n      p = pcache->tail;\n    }\n\n  _asn1_set_right (p, p2);\n  if (pcache)\n    {\n      pcache->head = node;\n      pcache->tail = p2;\n    }\n\n  if (p->name[0] == 0)\n    _asn1_str_cpy (temp, sizeof (temp), \"?1\");\n  else\n    {\n      n = strtol (p->name + 1, NULL, 0);\n      n++;\n      temp[0] = '?';\n      _asn1_ltostr (n, temp + 1);\n    }\n  _asn1_set_name (p2, temp);\n  /*  p2->type |= CONST_OPTION; */\n\n  return ASN1_SUCCESS;\n}",
      "lines": 52,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "asn1_write_value": {
      "start_point": [
        300,
        0
      ],
      "end_point": [
        646,
        1
      ],
      "content": "int\nasn1_write_value (asn1_node node_root, const char *name,\n\t\t  const void *ivalue, int len)\n{\n  asn1_node node, p, p2;\n  unsigned char *temp, *value_temp = NULL, *default_temp = NULL;\n  int len2, k, k2, negative;\n  size_t i;\n  const unsigned char *value = ivalue;\n  unsigned int type;\n\n  node = asn1_find_node (node_root, name);\n  if (node == NULL)\n    return ASN1_ELEMENT_NOT_FOUND;\n\n  if ((node->type & CONST_OPTION) && (value == NULL) && (len == 0))\n    {\n      asn1_delete_structure (&node);\n      return ASN1_SUCCESS;\n    }\n\n  type = type_field (node->type);\n\n  if ((type == ASN1_ETYPE_SEQUENCE_OF || type == ASN1_ETYPE_SET_OF) && (value == NULL) && (len == 0))\n    {\n      p = node->down;\n      while ((type_field (p->type) == ASN1_ETYPE_TAG)\n\t     || (type_field (p->type) == ASN1_ETYPE_SIZE))\n\tp = p->right;\n\n      while (p->right)\n\tasn1_delete_structure (&p->right);\n\n      return ASN1_SUCCESS;\n    }\n\n  /* Don't allow element deletion for other types */\n  if (value == NULL)\n    {\n      return ASN1_VALUE_NOT_VALID;\n    }\n\n  switch (type)\n    {\n    case ASN1_ETYPE_BOOLEAN:\n      if (!_asn1_strcmp (value, \"TRUE\"))\n\t{\n\t  if (node->type & CONST_DEFAULT)\n\t    {\n\t      p = node->down;\n\t      while (type_field (p->type) != ASN1_ETYPE_DEFAULT)\n\t\tp = p->right;\n\t      if (p->type & CONST_TRUE)\n\t\t_asn1_set_value (node, NULL, 0);\n\t      else\n\t\t_asn1_set_value (node, \"T\", 1);\n\t    }\n\t  else\n\t    _asn1_set_value (node, \"T\", 1);\n\t}\n      else if (!_asn1_strcmp (value, \"FALSE\"))\n\t{\n\t  if (node->type & CONST_DEFAULT)\n\t    {\n\t      p = node->down;\n\t      while (type_field (p->type) != ASN1_ETYPE_DEFAULT)\n\t\tp = p->right;\n\t      if (p->type & CONST_FALSE)\n\t\t_asn1_set_value (node, NULL, 0);\n\t      else\n\t\t_asn1_set_value (node, \"F\", 1);\n\t    }\n\t  else\n\t    _asn1_set_value (node, \"F\", 1);\n\t}\n      else\n\treturn ASN1_VALUE_NOT_VALID;\n      break;\n    case ASN1_ETYPE_INTEGER:\n    case ASN1_ETYPE_ENUMERATED:\n      if (len == 0)\n\t{\n\t  if ((isdigit (value[0])) || (value[0] == '-'))\n\t    {\n\t      value_temp = malloc (SIZEOF_UNSIGNED_LONG_INT);\n\t      if (value_temp == NULL)\n\t\treturn ASN1_MEM_ALLOC_ERROR;\n\n\t      _asn1_convert_integer (value, value_temp,\n\t\t\t\t     SIZEOF_UNSIGNED_LONG_INT, &len);\n\t    }\n\t  else\n\t    {\t\t\t/* is an identifier like v1 */\n\t      if (!(node->type & CONST_LIST))\n\t\treturn ASN1_VALUE_NOT_VALID;\n\t      p = node->down;\n\t      while (p)\n\t\t{\n\t\t  if (type_field (p->type) == ASN1_ETYPE_CONSTANT)\n\t\t    {\n\t\t      if (!_asn1_strcmp (p->name, value))\n\t\t\t{\n\t\t\t  value_temp = malloc (SIZEOF_UNSIGNED_LONG_INT);\n\t\t\t  if (value_temp == NULL)\n\t\t\t    return ASN1_MEM_ALLOC_ERROR;\n\n\t\t\t  _asn1_convert_integer (p->value,\n\t\t\t\t\t\t value_temp,\n\t\t\t\t\t\t SIZEOF_UNSIGNED_LONG_INT,\n\t\t\t\t\t\t &len);\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t  p = p->right;\n\t\t}\n\t      if (p == NULL)\n\t\treturn ASN1_VALUE_NOT_VALID;\n\t    }\n\t}\n      else\n\t{\t\t\t/* len != 0 */\n\t  value_temp = malloc (len);\n\t  if (value_temp == NULL)\n\t    return ASN1_MEM_ALLOC_ERROR;\n\t  memcpy (value_temp, value, len);\n\t}\n\n      if (value_temp[0] & 0x80)\n\tnegative = 1;\n      else\n\tnegative = 0;\n\n      if (negative && (type_field (node->type) == ASN1_ETYPE_ENUMERATED))\n\t{\n\t  free (value_temp);\n\t  return ASN1_VALUE_NOT_VALID;\n\t}\n\n      for (k = 0; k < len - 1; k++)\n\tif (negative && (value_temp[k] != 0xFF))\n\t  break;\n\telse if (!negative && value_temp[k])\n\t  break;\n\n      if ((negative && !(value_temp[k] & 0x80)) ||\n\t  (!negative && (value_temp[k] & 0x80)))\n\tk--;\n\n      _asn1_set_value_lv (node, value_temp + k, len - k);\n\n      if (node->type & CONST_DEFAULT)\n\t{\n\t  p = node->down;\n\t  while (type_field (p->type) != ASN1_ETYPE_DEFAULT)\n\t    p = p->right;\n\t  if ((isdigit (p->value[0])) || (p->value[0] == '-'))\n\t    {\n\t      default_temp = malloc (SIZEOF_UNSIGNED_LONG_INT);\n\t      if (default_temp == NULL)\n\t\t{\n\t\t  free (value_temp);\n\t\t  return ASN1_MEM_ALLOC_ERROR;\n\t\t}\n\n\t      _asn1_convert_integer (p->value, default_temp,\n\t\t\t\t     SIZEOF_UNSIGNED_LONG_INT, &len2);\n\t    }\n\t  else\n\t    {\t\t\t/* is an identifier like v1 */\n\t      if (!(node->type & CONST_LIST))\n\t\t{\n\t\t  free (value_temp);\n\t\t  return ASN1_VALUE_NOT_VALID;\n\t\t}\n\t      p2 = node->down;\n\t      while (p2)\n\t\t{\n\t\t  if (type_field (p2->type) == ASN1_ETYPE_CONSTANT)\n\t\t    {\n\t\t      if (!_asn1_strcmp (p2->name, p->value))\n\t\t\t{\n\t\t\t  default_temp = malloc (SIZEOF_UNSIGNED_LONG_INT);\n\t\t\t  if (default_temp == NULL)\n\t\t\t    {\n\t\t\t      free (value_temp);\n\t\t\t      return ASN1_MEM_ALLOC_ERROR;\n\t\t\t    }\n\n\t\t\t  _asn1_convert_integer (p2->value,\n\t\t\t\t\t\t default_temp,\n\t\t\t\t\t\t SIZEOF_UNSIGNED_LONG_INT,\n\t\t\t\t\t\t &len2);\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t  p2 = p2->right;\n\t\t}\n\t      if (p2 == NULL)\n\t\t{\n\t\t  free (value_temp);\n\t\t  return ASN1_VALUE_NOT_VALID;\n\t\t}\n\t    }\n\n\n\t  if ((len - k) == len2)\n\t    {\n\t      for (k2 = 0; k2 < len2; k2++)\n\t\tif (value_temp[k + k2] != default_temp[k2])\n\t\t  {\n\t\t    break;\n\t\t  }\n\t      if (k2 == len2)\n\t\t_asn1_set_value (node, NULL, 0);\n\t    }\n\t  free (default_temp);\n\t}\n      free (value_temp);\n      break;\n    case ASN1_ETYPE_OBJECT_ID:\n      for (i = 0; i < _asn1_strlen (value); i++)\n\tif ((!isdigit (value[i])) && (value[i] != '.') && (value[i] != '+'))\n\t  return ASN1_VALUE_NOT_VALID;\n      if (node->type & CONST_DEFAULT)\n\t{\n\t  p = node->down;\n\t  while (type_field (p->type) != ASN1_ETYPE_DEFAULT)\n\t    p = p->right;\n\t  if (!_asn1_strcmp (value, p->value))\n\t    {\n\t      _asn1_set_value (node, NULL, 0);\n\t      break;\n\t    }\n\t}\n      _asn1_set_value (node, value, _asn1_strlen (value) + 1);\n      break;\n    case ASN1_ETYPE_UTC_TIME:\n      {\n\tlen = _asn1_strlen (value);\n\tif (len < 11)\n\t  return ASN1_VALUE_NOT_VALID;\n\tfor (k = 0; k < 10; k++)\n\t  if (!isdigit (value[k]))\n\t    return ASN1_VALUE_NOT_VALID;\n\tswitch (len)\n\t  {\n\t  case 11:\n\t    if (value[10] != 'Z')\n\t      return ASN1_VALUE_NOT_VALID;\n\t    break;\n\t  case 13:\n\t    if ((!isdigit (value[10])) || (!isdigit (value[11])) ||\n\t\t(value[12] != 'Z'))\n\t      return ASN1_VALUE_NOT_VALID;\n\t    break;\n\t  case 15:\n\t    if ((value[10] != '+') && (value[10] != '-'))\n\t      return ASN1_VALUE_NOT_VALID;\n\t    for (k = 11; k < 15; k++)\n\t      if (!isdigit (value[k]))\n\t\treturn ASN1_VALUE_NOT_VALID;\n\t    break;\n\t  case 17:\n\t    if ((!isdigit (value[10])) || (!isdigit (value[11])))\n\t      return ASN1_VALUE_NOT_VALID;\n\t    if ((value[12] != '+') && (value[12] != '-'))\n\t      return ASN1_VALUE_NOT_VALID;\n\t    for (k = 13; k < 17; k++)\n\t      if (!isdigit (value[k]))\n\t\treturn ASN1_VALUE_NOT_VALID;\n\t    break;\n\t  default:\n\t    return ASN1_VALUE_NOT_FOUND;\n\t  }\n\t_asn1_set_value (node, value, len);\n      }\n      break;\n    case ASN1_ETYPE_GENERALIZED_TIME:\n      len = _asn1_strlen (value);\n      _asn1_set_value (node, value, len);\n      break;\n    case ASN1_ETYPE_OCTET_STRING:\n    case ASN1_ETYPE_GENERALSTRING:\n    case ASN1_ETYPE_NUMERIC_STRING:\n    case ASN1_ETYPE_IA5_STRING:\n    case ASN1_ETYPE_TELETEX_STRING:\n    case ASN1_ETYPE_PRINTABLE_STRING:\n    case ASN1_ETYPE_UNIVERSAL_STRING:\n    case ASN1_ETYPE_BMP_STRING:\n    case ASN1_ETYPE_UTF8_STRING:\n    case ASN1_ETYPE_VISIBLE_STRING:\n      if (len == 0)\n\tlen = _asn1_strlen (value);\n      _asn1_set_value_lv (node, value, len);\n      break;\n    case ASN1_ETYPE_BIT_STRING:\n      if (len == 0)\n\tlen = _asn1_strlen (value);\n      asn1_length_der ((len >> 3) + 2, NULL, &len2);\n      temp = malloc ((len >> 3) + 2 + len2);\n      if (temp == NULL)\n\treturn ASN1_MEM_ALLOC_ERROR;\n\n      asn1_bit_der (value, len, temp, &len2);\n      _asn1_set_value_m (node, temp, len2);\n      temp = NULL;\n      break;\n    case ASN1_ETYPE_CHOICE:\n      p = node->down;\n      while (p)\n\t{\n\t  if (!_asn1_strcmp (p->name, value))\n\t    {\n\t      p2 = node->down;\n\t      while (p2)\n\t\t{\n\t\t  if (p2 != p)\n\t\t    {\n\t\t      asn1_delete_structure (&p2);\n\t\t      p2 = node->down;\n\t\t    }\n\t\t  else\n\t\t    p2 = p2->right;\n\t\t}\n\t      break;\n\t    }\n\t  p = p->right;\n\t}\n      if (!p)\n\treturn ASN1_ELEMENT_NOT_FOUND;\n      break;\n    case ASN1_ETYPE_ANY:\n      _asn1_set_value_lv (node, value, len);\n      break;\n    case ASN1_ETYPE_SEQUENCE_OF:\n    case ASN1_ETYPE_SET_OF:\n      if (_asn1_strcmp (value, \"NEW\"))\n\treturn ASN1_VALUE_NOT_VALID;\n      _asn1_append_sequence_set (node, NULL);\n      break;\n    default:\n      return ASN1_ELEMENT_NOT_FOUND;\n      break;\n    }\n\n  return ASN1_SUCCESS;\n}",
      "lines": 347,
      "depth": 21,
      "decorators": [
        "int"
      ]
    },
    "asn1_read_value": {
      "start_point": [
        758,
        0
      ],
      "end_point": [
        762,
        1
      ],
      "content": "int\nasn1_read_value (asn1_node root, const char *name, void *ivalue, int *len)\n{\n  return asn1_read_value_type (root, name, ivalue, len, NULL);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "asn1_read_value_type": {
      "start_point": [
        832,
        0
      ],
      "end_point": [
        1008,
        1
      ],
      "content": "int\nasn1_read_value_type (asn1_node root, const char *name, void *ivalue,\n\t\t      int *len, unsigned int *etype)\n{\n  asn1_node node, p, p2;\n  int len2, len3, result;\n  int value_size = *len;\n  unsigned char *value = ivalue;\n  unsigned type;\n\n  node = asn1_find_node (root, name);\n  if (node == NULL)\n    return ASN1_ELEMENT_NOT_FOUND;\n\n  type = type_field (node->type);\n\n  if ((type != ASN1_ETYPE_NULL) &&\n      (type != ASN1_ETYPE_CHOICE) &&\n      !(node->type & CONST_DEFAULT) && !(node->type & CONST_ASSIGN) &&\n      (node->value == NULL))\n    return ASN1_VALUE_NOT_FOUND;\n\n  if (etype)\n    *etype = type;\n  switch (type)\n    {\n    case ASN1_ETYPE_NULL:\n      PUT_STR_VALUE (value, value_size, \"NULL\");\n      break;\n    case ASN1_ETYPE_BOOLEAN:\n      if ((node->type & CONST_DEFAULT) && (node->value == NULL))\n\t{\n\t  p = node->down;\n\t  while (type_field (p->type) != ASN1_ETYPE_DEFAULT)\n\t    p = p->right;\n\t  if (p->type & CONST_TRUE)\n\t    {\n\t      PUT_STR_VALUE (value, value_size, \"TRUE\");\n\t    }\n\t  else\n\t    {\n\t      PUT_STR_VALUE (value, value_size, \"FALSE\");\n\t    }\n\t}\n      else if (node->value[0] == 'T')\n\t{\n\t  PUT_STR_VALUE (value, value_size, \"TRUE\");\n\t}\n      else\n\t{\n\t  PUT_STR_VALUE (value, value_size, \"FALSE\");\n\t}\n      break;\n    case ASN1_ETYPE_INTEGER:\n    case ASN1_ETYPE_ENUMERATED:\n      if ((node->type & CONST_DEFAULT) && (node->value == NULL))\n\t{\n\t  p = node->down;\n\t  while (type_field (p->type) != ASN1_ETYPE_DEFAULT)\n\t    p = p->right;\n\t  if ((isdigit (p->value[0])) || (p->value[0] == '-')\n\t      || (p->value[0] == '+'))\n\t    {\n\t      result = _asn1_convert_integer\n\t\t  (p->value, value, value_size, len);\n              if (result != ASN1_SUCCESS)\n\t\treturn result;\n\t    }\n\t  else\n\t    {\t\t\t/* is an identifier like v1 */\n\t      p2 = node->down;\n\t      while (p2)\n\t\t{\n\t\t  if (type_field (p2->type) == ASN1_ETYPE_CONSTANT)\n\t\t    {\n\t\t      if (!_asn1_strcmp (p2->name, p->value))\n\t\t\t{\n\t\t\t  result = _asn1_convert_integer\n\t\t\t      (p2->value, value, value_size,\n\t\t\t       len);\n\t\t\t  if (result != ASN1_SUCCESS)\n\t\t\t    return result;\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t  p2 = p2->right;\n\t\t}\n\t    }\n\t}\n      else\n\t{\n\t  len2 = -1;\n\t  result = asn1_get_octet_der\n\t      (node->value, node->value_len, &len2, value, value_size,\n\t       len);\n          if (result != ASN1_SUCCESS)\n\t    return result;\n\t}\n      break;\n    case ASN1_ETYPE_OBJECT_ID:\n      if (node->type & CONST_ASSIGN)\n\t{\n\t  *len = 0;\n\t  if (value)\n\t    value[0] = 0;\n\t  p = node->down;\n\t  while (p)\n\t    {\n\t      if (type_field (p->type) == ASN1_ETYPE_CONSTANT)\n\t\t{\n\t\t  ADD_STR_VALUE (value, value_size, p->value);\n\t\t  if (p->right)\n\t\t    {\n\t\t      ADD_STR_VALUE (value, value_size, \".\");\n\t\t    }\n\t\t}\n\t      p = p->right;\n\t    }\n\t  (*len)++;\n\t}\n      else if ((node->type & CONST_DEFAULT) && (node->value == NULL))\n\t{\n\t  p = node->down;\n\t  while (type_field (p->type) != ASN1_ETYPE_DEFAULT)\n\t    p = p->right;\n\t  PUT_STR_VALUE (value, value_size, p->value);\n\t}\n      else\n\t{\n\t  PUT_STR_VALUE (value, value_size, node->value);\n\t}\n      break;\n    case ASN1_ETYPE_GENERALIZED_TIME:\n    case ASN1_ETYPE_UTC_TIME:\n      PUT_AS_STR_VALUE (value, value_size, node->value, node->value_len);\n      break;\n    case ASN1_ETYPE_OCTET_STRING:\n    case ASN1_ETYPE_GENERALSTRING:\n    case ASN1_ETYPE_NUMERIC_STRING:\n    case ASN1_ETYPE_IA5_STRING:\n    case ASN1_ETYPE_TELETEX_STRING:\n    case ASN1_ETYPE_PRINTABLE_STRING:\n    case ASN1_ETYPE_UNIVERSAL_STRING:\n    case ASN1_ETYPE_BMP_STRING:\n    case ASN1_ETYPE_UTF8_STRING:\n    case ASN1_ETYPE_VISIBLE_STRING:\n      len2 = -1;\n      result = asn1_get_octet_der\n\t  (node->value, node->value_len, &len2, value, value_size,\n\t   len);\n      if (result != ASN1_SUCCESS)\n\treturn result;\n      break;\n    case ASN1_ETYPE_BIT_STRING:\n      len2 = -1;\n      result = asn1_get_bit_der\n\t  (node->value, node->value_len, &len2, value, value_size,\n\t   len);\n      if (result != ASN1_SUCCESS)\n\treturn result;\n      break;\n    case ASN1_ETYPE_CHOICE:\n      PUT_STR_VALUE (value, value_size, node->down->name);\n      break;\n    case ASN1_ETYPE_ANY:\n      len3 = -1;\n      len2 = asn1_get_length_der (node->value, node->value_len, &len3);\n      if (len2 < 0)\n\treturn ASN1_DER_ERROR;\n      PUT_VALUE (value, value_size, node->value + len3, len2);\n      break;\n    default:\n      return ASN1_ELEMENT_NOT_FOUND;\n      break;\n    }\n  return ASN1_SUCCESS;\n}",
      "lines": 177,
      "depth": 21,
      "decorators": [
        "int"
      ]
    },
    "asn1_read_tag": {
      "start_point": [
        1026,
        0
      ],
      "end_point": [
        1089,
        1
      ],
      "content": "int\nasn1_read_tag (asn1_node root, const char *name, int *tagValue,\n\t       int *classValue)\n{\n  asn1_node node, p, pTag;\n\n  node = asn1_find_node (root, name);\n  if (node == NULL)\n    return ASN1_ELEMENT_NOT_FOUND;\n\n  p = node->down;\n\n  /* pTag will points to the IMPLICIT TAG */\n  pTag = NULL;\n  if (node->type & CONST_TAG)\n    {\n      while (p)\n\t{\n\t  if (type_field (p->type) == ASN1_ETYPE_TAG)\n\t    {\n\t      if ((p->type & CONST_IMPLICIT) && (pTag == NULL))\n\t\tpTag = p;\n\t      else if (p->type & CONST_EXPLICIT)\n\t\tpTag = NULL;\n\t    }\n\t  p = p->right;\n\t}\n    }\n\n  if (pTag)\n    {\n      *tagValue = _asn1_strtoul (pTag->value, NULL, 10);\n\n      if (pTag->type & CONST_APPLICATION)\n\t*classValue = ASN1_CLASS_APPLICATION;\n      else if (pTag->type & CONST_UNIVERSAL)\n\t*classValue = ASN1_CLASS_UNIVERSAL;\n      else if (pTag->type & CONST_PRIVATE)\n\t*classValue = ASN1_CLASS_PRIVATE;\n      else\n\t*classValue = ASN1_CLASS_CONTEXT_SPECIFIC;\n    }\n  else\n    {\n      unsigned type = type_field (node->type);\n      *classValue = ASN1_CLASS_UNIVERSAL;\n\n      switch (type)\n\t{\n\tCASE_HANDLED_ETYPES:\n\t  *tagValue = _asn1_tags[type].tag;\n\t  break;\n\tcase ASN1_ETYPE_TAG:\n\tcase ASN1_ETYPE_CHOICE:\n\tcase ASN1_ETYPE_ANY:\n\t  *tagValue = -1;\n\t  break;\n\tdefault:\n\t  break;\n\t}\n    }\n\n  return ASN1_SUCCESS;\n}",
      "lines": 64,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "asn1_read_node_value": {
      "start_point": [
        1101,
        0
      ],
      "end_point": [
        1110,
        1
      ],
      "content": "int\nasn1_read_node_value (asn1_node node, asn1_data_node_st * data)\n{\n  data->name = node->name;\n  data->value = node->value;\n  data->value_len = node->value_len;\n  data->type = type_field (node->type);\n\n  return ASN1_SUCCESS;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/lib/element.h": {},
  "libtasn1/libtasn1-4.13/lib/errors.c": {
    "asn1_perror": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "void\nasn1_perror (int error)\n{\n  const char *str = asn1_strerror (error);\n  fprintf (stderr, \"LIBTASN1 ERROR: %s\\n\", str ? str : \"(null)\");\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "asn1_strerror": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "const char *\nasn1_strerror (int error)\n{\n  const libtasn1_error_entry *p;\n\n  for (p = error_algorithms; p->name != NULL; p++)\n    if (p->number == error)\n      return p->name + sizeof (\"ASN1_\") - 1;\n\n  return NULL;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nasn1_strerror (int error)",
        "*"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/lib/gstr.c": {
    "_asn1_str_cat": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\n_asn1_str_cat (char *dest, size_t dest_tot_size, const char *src)\n{\n  size_t str_size = strlen (src);\n  size_t dest_size = strlen (dest);\n\n  if (dest_tot_size - dest_size > str_size)\n    {\n      strcat (dest, src);\n    }\n  else\n    {\n      if (dest_tot_size - dest_size > 0)\n\t{\n\t  strncat (dest, src, (dest_tot_size - dest_size) - 1);\n\t  dest[dest_tot_size - 1] = 0;\n\t}\n    }\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_asn1_str_cpy": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "unsigned int\n_asn1_str_cpy (char *dest, size_t dest_tot_size, const char *src)\n{\n  size_t str_size = strlen (src);\n\n  if (dest_tot_size > str_size)\n    {\n      strcpy (dest, src);\n      return str_size;\n    }\n  else\n    {\n      if (dest_tot_size > 0)\n\t{\n\t  str_size = dest_tot_size - 1;\n\t  memcpy (dest, src, str_size);\n\t  dest[str_size] = 0;\n\t  return str_size;\n\t}\n      else\n\treturn 0;\n    }\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/lib/gstr.h": {
    "safe_memset": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "inline static\nvoid safe_memset(void *data, int c, size_t size)\n{\n\tvolatile unsigned volatile_zero = 0;\n\tvolatile char *vdata = (volatile char*)data;\n\n\t/* This is based on a nice trick for safe memset,\n\t * sent by David Jacobson in the openssl-dev mailing list.\n\t */\n\n\tif (size > 0) do {\n\t\tmemset(data, c, size);\n\t} while(vdata[volatile_zero] != c);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "inline",
        "inline",
        "static",
        "static",
        "void"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/lib/int.h": {
    "type_field": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "inline static unsigned int\ntype_field (unsigned int ntype)\n{\n  return (ntype & 0xff);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "inline",
        "inline",
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "convert_old_type": {
      "start_point": [
        184,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "inline static unsigned int\nconvert_old_type (unsigned int ntype)\n{\n  unsigned int type = ntype & 0xff;\n  if (type == ASN1_ETYPE_TIME)\n    {\n      if (ntype & CONST_UTC)\n\ttype = ASN1_ETYPE_UTC_TIME;\n      else\n\ttype = ASN1_ETYPE_GENERALIZED_TIME;\n\n      ntype &= ~(CONST_UTC | CONST_GENERALIZED);\n      ntype &= 0xffffff00;\n      ntype |= type;\n\n      return ntype;\n    }\n  else\n    return ntype;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "inline",
        "inline",
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "_asn1_realloc": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "static inline\nvoid *_asn1_realloc(void *ptr, size_t size)\n{\n  void *ret;\n\n  if (size == 0)\n    return ptr;\n\n  ret = realloc(ptr, size);\n  if (ret == NULL)\n    {\n      free(ptr);\n    }\n  return ret;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void",
        "*_asn1_realloc(void *ptr, size_t size)",
        "*"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/lib/libtasn1.h": {},
  "libtasn1/libtasn1-4.13/lib/parser_aux.c": {
    "_asn1_add_static_node": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "asn1_node\n_asn1_add_static_node (unsigned int type)\n{\n  list_type *listElement;\n  asn1_node punt;\n\n  punt = calloc (1, sizeof (struct asn1_node_st));\n  if (punt == NULL)\n    return NULL;\n\n  listElement = malloc (sizeof (list_type));\n  if (listElement == NULL)\n    {\n      free (punt);\n      return NULL;\n    }\n\n  listElement->node = punt;\n  listElement->next = firstElement;\n  firstElement = listElement;\n\n  punt->type = type;\n\n  return punt;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "asn1_node"
      ]
    },
    "asn1_find_node": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "asn1_node\nasn1_find_node (asn1_node pointer, const char *name)\n{\n  asn1_node p;\n  char *n_end, n[ASN1_MAX_NAME_SIZE + 1];\n  const char *n_start;\n  unsigned int nsize;\n  unsigned int nhash;\n\n  if (pointer == NULL)\n    return NULL;\n\n  if (name == NULL)\n    return NULL;\n\n  p = pointer;\n  n_start = name;\n\n  if (name[0] == '?' && name[1] == 'C' && p->name[0] == '?')\n    { /* ?CURRENT */\n      n_start = strchr(n_start, '.');\n      if (n_start)\n        n_start++;\n    }\n  else if (p->name[0] != 0)\n    {\t\t\t\t/* has *pointer got a name ? */\n      n_end = strchr (n_start, '.');\t/* search the first dot */\n      if (n_end)\n\t{\n\t  nsize = n_end - n_start;\n\t  if (nsize >= sizeof(n))\n\t\treturn NULL;\n\n\t  memcpy (n, n_start, nsize);\n\t  n[nsize] = 0;\n\t  n_start = n_end;\n\t  n_start++;\n\n\t  nhash = hash_pjw_bare (n, nsize);\n\t}\n      else\n\t{\n\t  nsize = _asn1_str_cpy (n, sizeof (n), n_start);\n\t  nhash = hash_pjw_bare (n, nsize);\n\n\t  n_start = NULL;\n\t}\n\n      while (p)\n\t{\n\t  if (nhash == p->name_hash && (!strcmp (p->name, n)))\n\t    break;\n\t  else\n\t    p = p->right;\n\t}\t\t\t/* while */\n\n      if (p == NULL)\n\treturn NULL;\n    }\n  else\n    {\t\t\t\t/* *pointer doesn't have a name */\n      if (n_start[0] == 0)\n\treturn p;\n    }\n\n  while (n_start)\n    {\t\t\t\t/* Has the end of NAME been reached? */\n      n_end = strchr (n_start, '.');\t/* search the next dot */\n      if (n_end)\n\t{\n\t  nsize = n_end - n_start;\n\t  if (nsize >= sizeof(n))\n\t\treturn NULL;\n\n\t  memcpy (n, n_start, nsize);\n\t  n[nsize] = 0;\n\t  n_start = n_end;\n\t  n_start++;\n\n\t  nhash = hash_pjw_bare (n, nsize);\n\t}\n      else\n\t{\n\t  nsize = _asn1_str_cpy (n, sizeof (n), n_start);\n\t  nhash = hash_pjw_bare (n, nsize);\n\t  n_start = NULL;\n\t}\n\n      if (p->down == NULL)\n\treturn NULL;\n\n      p = p->down;\n      if (p == NULL)\n        return NULL;\n\n      /* The identifier \"?LAST\" indicates the last element\n         in the right chain. */\n      if (n[0] == '?' && n[1] == 'L') /* ?LAST */\n\t{\n\t  while (p->right)\n\t    p = p->right;\n\t}\n      else\n\t{\t\t\t/* no \"?LAST\" */\n\t  while (p)\n\t    {\n\t      if (p->name_hash == nhash && !strcmp (p->name, n))\n\t\tbreak;\n\t      else\n\t\tp = p->right;\n\t    }\n\t}\n      if (p == NULL)\n        return NULL;\n    }\t\t\t\t/* while */\n\n  return p;\n}",
      "lines": 118,
      "depth": 16,
      "decorators": [
        "asn1_node"
      ]
    },
    "_asn1_set_value": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "asn1_node\n_asn1_set_value (asn1_node node, const void *value, unsigned int len)\n{\n  if (node == NULL)\n    return node;\n  if (node->value)\n    {\n      if (node->value != node->small_value)\n\tfree (node->value);\n      node->value = NULL;\n      node->value_len = 0;\n    }\n\n  if (!len)\n    return node;\n\n  if (len < sizeof (node->small_value))\n    {\n      node->value = node->small_value;\n    }\n  else\n    {\n      node->value = malloc (len);\n      if (node->value == NULL)\n\treturn NULL;\n    }\n  node->value_len = len;\n\n  memcpy (node->value, value, len);\n  return node;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "asn1_node"
      ]
    },
    "_asn1_set_value_lv": {
      "start_point": [
        265,
        0
      ],
      "end_point": [
        281,
        1
      ],
      "content": "asn1_node\n_asn1_set_value_lv (asn1_node node, const void *value, unsigned int len)\n{\n  int len2;\n  void *temp;\n\n  if (node == NULL)\n    return node;\n\n  asn1_length_der (len, NULL, &len2);\n  temp = malloc (len + len2);\n  if (temp == NULL)\n    return NULL;\n\n  asn1_octet_der (value, len, temp, &len2);\n  return _asn1_set_value_m (node, temp, len2);\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "asn1_node"
      ]
    },
    "_asn1_set_value_m": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        307,
        1
      ],
      "content": "asn1_node\n_asn1_set_value_m (asn1_node node, void *value, unsigned int len)\n{\n  if (node == NULL)\n    return node;\n\n  if (node->value)\n    {\n      if (node->value != node->small_value)\n\tfree (node->value);\n      node->value = NULL;\n      node->value_len = 0;\n    }\n\n  if (!len)\n    return node;\n\n  node->value = value;\n  node->value_len = len;\n\n  return node;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "asn1_node"
      ]
    },
    "_asn1_append_value": {
      "start_point": [
        319,
        0
      ],
      "end_point": [
        367,
        1
      ],
      "content": "asn1_node\n_asn1_append_value (asn1_node node, const void *value, unsigned int len)\n{\n  if (node == NULL)\n    return node;\n\n  if (node->value == NULL)\n    return _asn1_set_value (node, value, len);\n\n  if (len == 0)\n    return node;\n\n  if (node->value == node->small_value)\n    {\n      /* value is in node */\n      int prev_len = node->value_len;\n      node->value_len += len;\n      node->value = malloc (node->value_len);\n      if (node->value == NULL)\n\t{\n\t  node->value_len = 0;\n\t  return NULL;\n\t}\n\n      if (prev_len > 0)\n        memcpy (node->value, node->small_value, prev_len);\n\n      memcpy (&node->value[prev_len], value, len);\n\n      return node;\n    }\n  else /* if (node->value != NULL && node->value != node->small_value) */\n    {\n      /* value is allocated */\n      int prev_len = node->value_len;\n      node->value_len += len;\n\n      node->value = _asn1_realloc (node->value, node->value_len);\n      if (node->value == NULL)\n\t{\n\t  node->value_len = 0;\n\t  return NULL;\n\t}\n\n      memcpy (&node->value[prev_len], value, len);\n\n      return node;\n    }\n}",
      "lines": 49,
      "depth": 11,
      "decorators": [
        "asn1_node"
      ]
    },
    "_asn1_set_name": {
      "start_point": [
        379,
        0
      ],
      "end_point": [
        398,
        1
      ],
      "content": "asn1_node\n_asn1_set_name (asn1_node node, const char *name)\n{\n  unsigned int nsize;\n\n  if (node == NULL)\n    return node;\n\n  if (name == NULL)\n    {\n      node->name[0] = 0;\n      node->name_hash = hash_pjw_bare (node->name, 0);\n      return node;\n    }\n\n  nsize = _asn1_str_cpy (node->name, sizeof (node->name), name);\n  node->name_hash = hash_pjw_bare (node->name, nsize);\n\n  return node;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "asn1_node"
      ]
    },
    "_asn1_cpy_name": {
      "start_point": [
        408,
        0
      ],
      "end_point": [
        425,
        1
      ],
      "content": "asn1_node\n_asn1_cpy_name (asn1_node dst, asn1_node src)\n{\n  if (dst == NULL)\n    return dst;\n\n  if (src == NULL)\n    {\n      dst->name[0] = 0;\n      dst->name_hash = hash_pjw_bare (dst->name, 0);\n      return dst;\n    }\n\n  _asn1_str_cpy (dst->name, sizeof (dst->name), src->name);\n  dst->name_hash = src->name_hash;\n\n  return dst;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "asn1_node"
      ]
    },
    "_asn1_set_right": {
      "start_point": [
        436,
        0
      ],
      "end_point": [
        445,
        1
      ],
      "content": "asn1_node\n_asn1_set_right (asn1_node node, asn1_node right)\n{\n  if (node == NULL)\n    return node;\n  node->right = right;\n  if (right)\n    right->left = node;\n  return node;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "asn1_node"
      ]
    },
    "_asn1_get_last_right": {
      "start_point": [
        455,
        0
      ],
      "end_point": [
        466,
        1
      ],
      "content": "asn1_node\n_asn1_get_last_right (asn1_node node)\n{\n  asn1_node p;\n\n  if (node == NULL)\n    return NULL;\n  p = node;\n  while (p->right)\n    p = p->right;\n  return p;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "asn1_node"
      ]
    },
    "_asn1_remove_node": {
      "start_point": [
        476,
        0
      ],
      "end_point": [
        493,
        1
      ],
      "content": "void\n_asn1_remove_node (asn1_node node, unsigned int flags)\n{\n  if (node == NULL)\n    return;\n\n  if (node->value != NULL)\n    {\n      if (flags & ASN1_DELETE_FLAG_ZEROIZE)\n        {\n          safe_memset(node->value, 0, node->value_len);\n        }\n\n      if (node->value != node->small_value)\n        free (node->value);\n    }\n  free (node);\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "_asn1_find_up": {
      "start_point": [
        502,
        0
      ],
      "end_point": [
        516,
        1
      ],
      "content": "asn1_node\n_asn1_find_up (asn1_node node)\n{\n  asn1_node p;\n\n  if (node == NULL)\n    return NULL;\n\n  p = node;\n\n  while ((p->left != NULL) && (p->left->right == p))\n    p = p->left;\n\n  return p->left;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "asn1_node"
      ]
    },
    "_asn1_delete_list": {
      "start_point": [
        523,
        0
      ],
      "end_point": [
        534,
        1
      ],
      "content": "void\n_asn1_delete_list (void)\n{\n  list_type *listElement;\n\n  while (firstElement)\n    {\n      listElement = firstElement;\n      firstElement = firstElement->next;\n      free (listElement);\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "_asn1_delete_list_and_nodes": {
      "start_point": [
        541,
        0
      ],
      "end_point": [
        553,
        1
      ],
      "content": "void\n_asn1_delete_list_and_nodes (void)\n{\n  list_type *listElement;\n\n  while (firstElement)\n    {\n      listElement = firstElement;\n      firstElement = firstElement->next;\n      _asn1_remove_node (listElement->node, 0);\n      free (listElement);\n    }\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_asn1_ltostr": {
      "start_point": [
        556,
        0
      ],
      "end_point": [
        591,
        1
      ],
      "content": "char *\n_asn1_ltostr (int64_t v, char str[LTOSTR_MAX_SIZE])\n{\n  uint64_t d, r;\n  char temp[LTOSTR_MAX_SIZE];\n  int count, k, start;\n  uint64_t val;\n\n  if (v < 0)\n    {\n      str[0] = '-';\n      start = 1;\n      val = -((uint64_t)v);\n    }\n  else\n    {\n      val = v;\n      start = 0;\n    }\n\n  count = 0;\n  do\n    {\n      d = val / 10;\n      r = val - d * 10;\n      temp[start + count] = '0' + (char) r;\n      count++;\n      val = d;\n    }\n  while (val && ((start+count) < LTOSTR_MAX_SIZE-1));\n\n  for (k = 0; k < count; k++)\n    str[k + start] = temp[start + count - k - 1];\n  str[count + start] = 0;\n  return str;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "char",
        "*\n_asn1_ltostr (int64_t v, char str[LTOSTR_MAX_SIZE])",
        "*"
      ]
    },
    "_asn1_change_integer_value": {
      "start_point": [
        604,
        0
      ],
      "end_point": [
        660,
        1
      ],
      "content": "int\n_asn1_change_integer_value (asn1_node node)\n{\n  asn1_node p;\n  unsigned char val[SIZEOF_UNSIGNED_LONG_INT];\n  unsigned char val2[SIZEOF_UNSIGNED_LONG_INT + 1];\n  int len;\n\n  if (node == NULL)\n    return ASN1_ELEMENT_NOT_FOUND;\n\n  p = node;\n  while (p)\n    {\n      if ((type_field (p->type) == ASN1_ETYPE_INTEGER)\n\t  && (p->type & CONST_ASSIGN))\n\t{\n\t  if (p->value)\n\t    {\n\t      _asn1_convert_integer (p->value, val, sizeof (val), &len);\n\t      asn1_octet_der (val, len, val2, &len);\n\t      _asn1_set_value (p, val2, len);\n\t    }\n\t}\n\n      if (p->down)\n\t{\n\t  p = p->down;\n\t}\n      else\n\t{\n\t  if (p == node)\n\t    p = NULL;\n\t  else if (p->right)\n\t    p = p->right;\n\t  else\n\t    {\n\t      while (1)\n\t\t{\n\t\t  p = _asn1_find_up (p);\n\t\t  if (p == node)\n\t\t    {\n\t\t      p = NULL;\n\t\t      break;\n\t\t    }\n\t\t  if (p && p->right)\n\t\t    {\n\t\t      p = p->right;\n\t\t      break;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n  return ASN1_SUCCESS;\n}",
      "lines": 57,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "_asn1_expand_object_id": {
      "start_point": [
        672,
        0
      ],
      "end_point": [
        850,
        1
      ],
      "content": "int\n_asn1_expand_object_id (asn1_node node)\n{\n  asn1_node p, p2, p3, p4, p5;\n  char name_root[ASN1_MAX_NAME_SIZE], name2[2 * ASN1_MAX_NAME_SIZE + 1];\n  int move, tlen;\n\n  if (node == NULL)\n    return ASN1_ELEMENT_NOT_FOUND;\n\n  _asn1_str_cpy (name_root, sizeof (name_root), node->name);\n\n  p = node;\n  move = DOWN;\n\n  while (!((p == node) && (move == UP)))\n    {\n      if (move != UP)\n\t{\n\t  if ((type_field (p->type) == ASN1_ETYPE_OBJECT_ID)\n\t      && (p->type & CONST_ASSIGN))\n\t    {\n\t      p2 = p->down;\n\t      if (p2 && (type_field (p2->type) == ASN1_ETYPE_CONSTANT))\n\t\t{\n\t\t  if (p2->value && !isdigit (p2->value[0]))\n\t\t    {\n\t\t      _asn1_str_cpy (name2, sizeof (name2), name_root);\n\t\t      _asn1_str_cat (name2, sizeof (name2), \".\");\n\t\t      _asn1_str_cat (name2, sizeof (name2),\n\t\t\t\t     (char *) p2->value);\n\t\t      p3 = asn1_find_node (node, name2);\n\t\t      if (!p3\n\t\t\t  || (type_field (p3->type) != ASN1_ETYPE_OBJECT_ID)\n\t\t\t  || !(p3->type & CONST_ASSIGN))\n\t\t\treturn ASN1_ELEMENT_NOT_FOUND;\n\t\t      _asn1_set_down (p, p2->right);\n\t\t      _asn1_remove_node (p2, 0);\n\t\t      p2 = p;\n\t\t      p4 = p3->down;\n\t\t      while (p4)\n\t\t\t{\n\t\t\t  if (type_field (p4->type) == ASN1_ETYPE_CONSTANT)\n\t\t\t    {\n\t\t\t      p5 =\n\t\t\t\t_asn1_add_single_node (ASN1_ETYPE_CONSTANT);\n\t\t\t      _asn1_set_name (p5, p4->name);\n\t\t\t      if (p4->value)\n\t\t\t        {\n\t\t\t          tlen = _asn1_strlen (p4->value);\n\t\t\t          if (tlen > 0)\n\t\t\t            _asn1_set_value (p5, p4->value, tlen + 1);\n\t\t\t        }\n\t\t\t      if (p2 == p)\n\t\t\t\t{\n\t\t\t\t  _asn1_set_right (p5, p->down);\n\t\t\t\t  _asn1_set_down (p, p5);\n\t\t\t\t}\n\t\t\t      else\n\t\t\t\t{\n\t\t\t\t  _asn1_set_right (p5, p2->right);\n\t\t\t\t  _asn1_set_right (p2, p5);\n\t\t\t\t}\n\t\t\t      p2 = p5;\n\t\t\t    }\n\t\t\t  p4 = p4->right;\n\t\t\t}\n\t\t      move = DOWN;\n\t\t      continue;\n\t\t    }\n\t\t}\n\t    }\n\t  move = DOWN;\n\t}\n      else\n\tmove = RIGHT;\n\n      if (move == DOWN)\n\t{\n\t  if (p->down)\n\t    p = p->down;\n\t  else\n\t    move = RIGHT;\n\t}\n\n      if (p == node)\n\t{\n\t  move = UP;\n\t  continue;\n\t}\n\n      if (move == RIGHT)\n\t{\n\t  if (p && p->right)\n\t    p = p->right;\n\t  else\n\t    move = UP;\n\t}\n      if (move == UP)\n\tp = _asn1_find_up (p);\n    }\n\n\n  /*******************************/\n  /*       expand DEFAULT        */\n  /*******************************/\n  p = node;\n  move = DOWN;\n\n  while (!((p == node) && (move == UP)))\n    {\n      if (move != UP)\n\t{\n\t  if ((type_field (p->type) == ASN1_ETYPE_OBJECT_ID) &&\n\t      (p->type & CONST_DEFAULT))\n\t    {\n\t      p2 = p->down;\n\t      if (p2 && (type_field (p2->type) == ASN1_ETYPE_DEFAULT))\n\t\t{\n\t\t  _asn1_str_cpy (name2, sizeof (name2), name_root);\n\t\t  _asn1_str_cat (name2, sizeof (name2), \".\");\n\t\t  _asn1_str_cat (name2, sizeof (name2), (char *) p2->value);\n\t\t  p3 = asn1_find_node (node, name2);\n\t\t  if (!p3 || (type_field (p3->type) != ASN1_ETYPE_OBJECT_ID)\n\t\t      || !(p3->type & CONST_ASSIGN))\n\t\t    return ASN1_ELEMENT_NOT_FOUND;\n\t\t  p4 = p3->down;\n\t\t  name2[0] = 0;\n\t\t  while (p4)\n\t\t    {\n\t\t      if (type_field (p4->type) == ASN1_ETYPE_CONSTANT)\n\t\t\t{\n\t\t\t  if (p4->value == NULL)\n\t\t\t    return ASN1_VALUE_NOT_FOUND;\n\n\t\t\t  if (name2[0])\n\t\t\t    _asn1_str_cat (name2, sizeof (name2), \".\");\n\t\t\t  _asn1_str_cat (name2, sizeof (name2),\n\t\t\t\t\t (char *) p4->value);\n\t\t\t}\n\t\t      p4 = p4->right;\n\t\t    }\n\t\t  tlen = strlen (name2);\n\t\t  if (tlen > 0)\n\t\t    _asn1_set_value (p2, name2, tlen + 1);\n\t\t}\n\t    }\n\t  move = DOWN;\n\t}\n      else\n\tmove = RIGHT;\n\n      if (move == DOWN)\n\t{\n\t  if (p->down)\n\t    p = p->down;\n\t  else\n\t    move = RIGHT;\n\t}\n\n      if (p == node)\n\t{\n\t  move = UP;\n\t  continue;\n\t}\n\n      if (move == RIGHT)\n\t{\n\t  if (p && p->right)\n\t    p = p->right;\n\t  else\n\t    move = UP;\n\t}\n      if (move == UP)\n\tp = _asn1_find_up (p);\n    }\n\n  return ASN1_SUCCESS;\n}",
      "lines": 179,
      "depth": 24,
      "decorators": [
        "int"
      ]
    },
    "_asn1_type_set_config": {
      "start_point": [
        863,
        0
      ],
      "end_point": [
        920,
        1
      ],
      "content": "int\n_asn1_type_set_config (asn1_node node)\n{\n  asn1_node p, p2;\n  int move;\n\n  if (node == NULL)\n    return ASN1_ELEMENT_NOT_FOUND;\n\n  p = node;\n  move = DOWN;\n\n  while (!((p == node) && (move == UP)))\n    {\n      if (move != UP)\n\t{\n\t  if (type_field (p->type) == ASN1_ETYPE_SET)\n\t    {\n\t      p2 = p->down;\n\t      while (p2)\n\t\t{\n\t\t  if (type_field (p2->type) != ASN1_ETYPE_TAG)\n\t\t    p2->type |= CONST_SET | CONST_NOT_USED;\n\t\t  p2 = p2->right;\n\t\t}\n\t    }\n\t  move = DOWN;\n\t}\n      else\n\tmove = RIGHT;\n\n      if (move == DOWN)\n\t{\n\t  if (p->down)\n\t    p = p->down;\n\t  else\n\t    move = RIGHT;\n\t}\n\n      if (p == node)\n\t{\n\t  move = UP;\n\t  continue;\n\t}\n\n      if (move == RIGHT)\n\t{\n\t  if (p && p->right)\n\t    p = p->right;\n\t  else\n\t    move = UP;\n\t}\n      if (move == UP)\n\tp = _asn1_find_up (p);\n    }\n\n  return ASN1_SUCCESS;\n}",
      "lines": 58,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "_asn1_check_identifier": {
      "start_point": [
        936,
        0
      ],
      "end_point": [
        1036,
        1
      ],
      "content": "int\n_asn1_check_identifier (asn1_node node)\n{\n  asn1_node p, p2;\n  char name2[ASN1_MAX_NAME_SIZE * 2 + 2];\n\n  if (node == NULL)\n    return ASN1_ELEMENT_NOT_FOUND;\n\n  p = node;\n  while (p)\n    {\n      if (p->value && type_field (p->type) == ASN1_ETYPE_IDENTIFIER)\n\t{\n\t  _asn1_str_cpy (name2, sizeof (name2), node->name);\n\t  _asn1_str_cat (name2, sizeof (name2), \".\");\n\t  _asn1_str_cat (name2, sizeof (name2), (char *) p->value);\n\t  p2 = asn1_find_node (node, name2);\n\t  if (p2 == NULL)\n\t    {\n\t      if (p->value)\n\t\t_asn1_str_cpy (_asn1_identifierMissing, sizeof(_asn1_identifierMissing), (char*)p->value);\n\t      else\n\t\t_asn1_strcpy (_asn1_identifierMissing, \"(null)\");\n\t      return ASN1_IDENTIFIER_NOT_FOUND;\n\t    }\n\t}\n      else if ((type_field (p->type) == ASN1_ETYPE_OBJECT_ID) &&\n\t       (p->type & CONST_DEFAULT))\n\t{\n\t  p2 = p->down;\n\t  if (p2 && (type_field (p2->type) == ASN1_ETYPE_DEFAULT))\n\t    {\n\t      _asn1_str_cpy (name2, sizeof (name2), node->name);\n\t      if (p2->value)\n\t        {\n\t          _asn1_str_cat (name2, sizeof (name2), \".\");\n\t          _asn1_str_cat (name2, sizeof (name2), (char *) p2->value);\n\t          _asn1_str_cpy (_asn1_identifierMissing, sizeof(_asn1_identifierMissing), (char*)p2->value);\n\t        }\n\t      else\n\t\t_asn1_strcpy (_asn1_identifierMissing, \"(null)\");\n\n\t      p2 = asn1_find_node (node, name2);\n\t      if (!p2 || (type_field (p2->type) != ASN1_ETYPE_OBJECT_ID) ||\n\t\t  !(p2->type & CONST_ASSIGN))\n\t\treturn ASN1_IDENTIFIER_NOT_FOUND;\n\t      else\n\t\t_asn1_identifierMissing[0] = 0;\n\t    }\n\t}\n      else if ((type_field (p->type) == ASN1_ETYPE_OBJECT_ID) &&\n\t       (p->type & CONST_ASSIGN))\n\t{\n\t  p2 = p->down;\n\t  if (p2 && (type_field (p2->type) == ASN1_ETYPE_CONSTANT))\n\t    {\n\t      if (p2->value && !isdigit (p2->value[0]))\n\t\t{\n\t\t  _asn1_str_cpy (name2, sizeof (name2), node->name);\n\t\t  _asn1_str_cat (name2, sizeof (name2), \".\");\n\t\t  _asn1_str_cat (name2, sizeof (name2), (char *) p2->value);\n\t\t  _asn1_str_cpy (_asn1_identifierMissing, sizeof(_asn1_identifierMissing), (char*)p2->value);\n\n\t\t  p2 = asn1_find_node (node, name2);\n\t\t  if (!p2 || (type_field (p2->type) != ASN1_ETYPE_OBJECT_ID)\n\t\t      || !(p2->type & CONST_ASSIGN))\n\t\t    return ASN1_IDENTIFIER_NOT_FOUND;\n\t\t  else\n\t\t    _asn1_identifierMissing[0] = 0;\n\t\t}\n\t    }\n\t}\n\n      if (p->down)\n\t{\n\t  p = p->down;\n\t}\n      else if (p->right)\n\tp = p->right;\n      else\n\t{\n\t  while (1)\n\t    {\n\t      p = _asn1_find_up (p);\n\t      if (p == node)\n\t\t{\n\t\t  p = NULL;\n\t\t  break;\n\t\t}\n\t      if (p && p->right)\n\t\t{\n\t\t  p = p->right;\n\t\t  break;\n\t\t}\n\t    }\n\t}\n    }\n\n  return ASN1_SUCCESS;\n}",
      "lines": 101,
      "depth": 22,
      "decorators": [
        "int"
      ]
    },
    "_asn1_set_default_tag": {
      "start_point": [
        1050,
        0
      ],
      "end_point": [
        1096,
        1
      ],
      "content": "int\n_asn1_set_default_tag (asn1_node node)\n{\n  asn1_node p;\n\n  if ((node == NULL) || (type_field (node->type) != ASN1_ETYPE_DEFINITIONS))\n    return ASN1_ELEMENT_NOT_FOUND;\n\n  p = node;\n  while (p)\n    {\n      if ((type_field (p->type) == ASN1_ETYPE_TAG) &&\n\t  !(p->type & CONST_EXPLICIT) && !(p->type & CONST_IMPLICIT))\n\t{\n\t  if (node->type & CONST_EXPLICIT)\n\t    p->type |= CONST_EXPLICIT;\n\t  else\n\t    p->type |= CONST_IMPLICIT;\n\t}\n\n      if (p->down)\n\t{\n\t  p = p->down;\n\t}\n      else if (p->right)\n\tp = p->right;\n      else\n\t{\n\t  while (1)\n\t    {\n\t      p = _asn1_find_up (p);\n\t      if (p == node)\n\t\t{\n\t\t  p = NULL;\n\t\t  break;\n\t\t}\n\t      if (p && p->right)\n\t\t{\n\t\t  p = p->right;\n\t\t  break;\n\t\t}\n\t    }\n\t}\n    }\n\n  return ASN1_SUCCESS;\n}",
      "lines": 47,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/lib/parser_aux.h": {
    "_asn1_get_right": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "inline static asn1_node\n_asn1_get_right (asn1_node node)\n{\n  if (node == NULL)\n    return NULL;\n  return node->right;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "inline",
        "inline",
        "static",
        "static",
        "asn1_node"
      ]
    },
    "_asn1_set_down": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "inline static asn1_node\n_asn1_set_down (asn1_node node, asn1_node down)\n{\n  if (node == NULL)\n    return node;\n  node->down = down;\n  if (down)\n    down->left = node;\n  return node;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "inline",
        "inline",
        "static",
        "static",
        "asn1_node"
      ]
    },
    "_asn1_get_down": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "inline static asn1_node\n_asn1_get_down (asn1_node node)\n{\n  if (node == NULL)\n    return NULL;\n  return node->down;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "inline",
        "inline",
        "static",
        "static",
        "asn1_node"
      ]
    },
    "_asn1_get_name": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "inline static char *\n_asn1_get_name (asn1_node node)\n{\n  if (node == NULL)\n    return NULL;\n  return node->name;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "inline",
        "inline",
        "static",
        "static",
        "char",
        "*\n_asn1_get_name (asn1_node node)",
        "*"
      ]
    },
    "_asn1_mod_type": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "inline static asn1_node\n_asn1_mod_type (asn1_node node, unsigned int value)\n{\n  if (node == NULL)\n    return node;\n  node->type |= value;\n  return node;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "inline",
        "inline",
        "static",
        "static",
        "asn1_node"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/lib/structure.c": {
    "_asn1_add_single_node": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "asn1_node\n_asn1_add_single_node (unsigned int type)\n{\n  asn1_node punt;\n\n  punt = calloc (1, sizeof (struct asn1_node_st));\n  if (punt == NULL)\n    return NULL;\n\n  punt->type = type;\n\n  return punt;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "asn1_node"
      ]
    },
    "_asn1_find_left": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "asn1_node\n_asn1_find_left (asn1_node node)\n{\n  if ((node == NULL) || (node->left == NULL) || (node->left->down == node))\n    return NULL;\n\n  return node->left;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "asn1_node"
      ]
    },
    "_asn1_create_static_structure": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "int\n_asn1_create_static_structure (asn1_node pointer, char *output_file_name,\n\t\t\t       char *vector_name)\n{\n  FILE *file;\n  asn1_node p;\n  unsigned long t;\n\n  file = fopen (output_file_name, \"w\");\n\n  if (file == NULL)\n    return ASN1_FILE_NOT_FOUND;\n\n  fprintf (file, \"#if HAVE_CONFIG_H\\n\");\n  fprintf (file, \"# include \\\"config.h\\\"\\n\");\n  fprintf (file, \"#endif\\n\\n\");\n\n  fprintf (file, \"#include <libtasn1.h>\\n\\n\");\n\n  fprintf (file, \"const asn1_static_node %s[] = {\\n\", vector_name);\n\n  p = pointer;\n\n  while (p)\n    {\n      fprintf (file, \"  { \");\n\n      if (p->name[0] != 0)\n\tfprintf (file, \"\\\"%s\\\", \", p->name);\n      else\n\tfprintf (file, \"NULL, \");\n\n      t = p->type;\n      if (p->down)\n\tt |= CONST_DOWN;\n      if (p->right)\n\tt |= CONST_RIGHT;\n\n      fprintf (file, \"%lu, \", t);\n\n      if (p->value)\n\tfprintf (file, \"\\\"%s\\\"},\\n\", p->value);\n      else\n\tfprintf (file, \"NULL },\\n\");\n\n      if (p->down)\n\t{\n\t  p = p->down;\n\t}\n      else if (p->right)\n\t{\n\t  p = p->right;\n\t}\n      else\n\t{\n\t  while (1)\n\t    {\n\t      p = _asn1_find_up (p);\n\t      if (p == pointer)\n\t\t{\n\t\t  p = NULL;\n\t\t  break;\n\t\t}\n\t      if (p->right)\n\t\t{\n\t\t  p = p->right;\n\t\t  break;\n\t\t}\n\t    }\n\t}\n    }\n\n  fprintf (file, \"  { NULL, 0, NULL }\\n};\\n\");\n\n  fclose (file);\n\n  return ASN1_SUCCESS;\n}",
      "lines": 78,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "asn1_array2tree": {
      "start_point": [
        175,
        0
      ],
      "end_point": [
        276,
        1
      ],
      "content": "int\nasn1_array2tree (const asn1_static_node * array, asn1_node * definitions,\n\t\t char *errorDescription)\n{\n  asn1_node p, p_last = NULL;\n  unsigned long k;\n  int move;\n  int result;\n  unsigned int type;\n\n  if (errorDescription)\n    errorDescription[0] = 0;\n\n  if (*definitions != NULL)\n    return ASN1_ELEMENT_NOT_EMPTY;\n\n  move = UP;\n\n  k = 0;\n  while (array[k].value || array[k].type || array[k].name)\n    {\n      type = convert_old_type (array[k].type);\n\n      p = _asn1_add_static_node (type & (~CONST_DOWN));\n      if (array[k].name)\n\t_asn1_set_name (p, array[k].name);\n      if (array[k].value)\n\t_asn1_set_value (p, array[k].value, strlen (array[k].value) + 1);\n\n      if (*definitions == NULL)\n\t*definitions = p;\n\n      if (move == DOWN)\n\t_asn1_set_down (p_last, p);\n      else if (move == RIGHT)\n\t_asn1_set_right (p_last, p);\n\n      p_last = p;\n\n      if (type & CONST_DOWN)\n\tmove = DOWN;\n      else if (type & CONST_RIGHT)\n\tmove = RIGHT;\n      else\n\t{\n\t  while (1)\n\t    {\n\t      if (p_last == *definitions)\n\t\tbreak;\n\n\t      p_last = _asn1_find_up (p_last);\n\n\t      if (p_last == NULL)\n\t\tbreak;\n\n\t      if (p_last->type & CONST_RIGHT)\n\t\t{\n\t\t  p_last->type &= ~CONST_RIGHT;\n\t\t  move = RIGHT;\n\t\t  break;\n\t\t}\n\t    }\t\t\t/* while */\n\t}\n      k++;\n    }\t\t\t\t/* while */\n\n  if (p_last == *definitions)\n    {\n      result = _asn1_check_identifier (*definitions);\n      if (result == ASN1_SUCCESS)\n\t{\n\t  _asn1_change_integer_value (*definitions);\n\t  _asn1_expand_object_id (*definitions);\n\t}\n    }\n  else\n    {\n      result = ASN1_ARRAY_ERROR;\n    }\n\n  if (errorDescription != NULL)\n    {\n      if (result == ASN1_IDENTIFIER_NOT_FOUND)\n\t{\n\t  Estrcpy (errorDescription, \":: identifier '\");\n\t  Estrcat (errorDescription, _asn1_identifierMissing);\n\t  Estrcat (errorDescription, \"' not found\");\n\t}\n      else\n\terrorDescription[0] = 0;\n    }\n\n  if (result != ASN1_SUCCESS)\n    {\n      _asn1_delete_list_and_nodes ();\n      *definitions = NULL;\n    }\n  else\n    _asn1_delete_list ();\n\n  return result;\n}",
      "lines": 102,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "asn1_delete_structure": {
      "start_point": [
        288,
        0
      ],
      "end_point": [
        292,
        1
      ],
      "content": "int\nasn1_delete_structure (asn1_node * structure)\n{\n  return asn1_delete_structure2(structure, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "asn1_delete_structure2": {
      "start_point": [
        305,
        0
      ],
      "end_point": [
        354,
        1
      ],
      "content": "int\nasn1_delete_structure2 (asn1_node * structure, unsigned int flags)\n{\n  asn1_node p, p2, p3;\n\n  if (*structure == NULL)\n    return ASN1_ELEMENT_NOT_FOUND;\n\n  p = *structure;\n  while (p)\n    {\n      if (p->down)\n\t{\n\t  p = p->down;\n\t}\n      else\n\t{\t\t\t/* no down */\n\t  p2 = p->right;\n\t  if (p != *structure)\n\t    {\n\t      p3 = _asn1_find_up (p);\n\t      _asn1_set_down (p3, p2);\n\t      _asn1_remove_node (p, flags);\n\t      p = p3;\n\t    }\n\t  else\n\t    {\t\t\t/* p==root */\n\t      p3 = _asn1_find_left (p);\n\t      if (!p3)\n\t\t{\n\t\t  p3 = _asn1_find_up (p);\n\t\t  if (p3)\n\t\t    _asn1_set_down (p3, p2);\n\t\t  else\n\t\t    {\n\t\t      if (p->right)\n\t\t\tp->right->left = NULL;\n\t\t    }\n\t\t}\n\t      else\n\t\t_asn1_set_right (p3, p2);\n\t      _asn1_remove_node (p, flags);\n\t      p = NULL;\n\t    }\n\t}\n    }\n\n  *structure = NULL;\n  return ASN1_SUCCESS;\n}",
      "lines": 50,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "asn1_delete_element": {
      "start_point": [
        369,
        0
      ],
      "end_point": [
        393,
        1
      ],
      "content": "int\nasn1_delete_element (asn1_node structure, const char *element_name)\n{\n  asn1_node p2, p3, source_node;\n\n  source_node = asn1_find_node (structure, element_name);\n\n  if (source_node == NULL)\n    return ASN1_ELEMENT_NOT_FOUND;\n\n  p2 = source_node->right;\n  p3 = _asn1_find_left (source_node);\n  if (!p3)\n    {\n      p3 = _asn1_find_up (source_node);\n      if (p3)\n\t_asn1_set_down (p3, p2);\n      else if (source_node->right)\n\tsource_node->right->left = NULL;\n    }\n  else\n    _asn1_set_right (p3, p2);\n\n  return asn1_delete_structure (&source_node);\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_asn1_copy_structure3": {
      "start_point": [
        395,
        0
      ],
      "end_point": [
        452,
        1
      ],
      "content": "asn1_node\n_asn1_copy_structure3 (asn1_node source_node)\n{\n  asn1_node dest_node, p_s, p_d, p_d_prev;\n  int move;\n\n  if (source_node == NULL)\n    return NULL;\n\n  dest_node = _asn1_add_single_node (source_node->type);\n\n  p_s = source_node;\n  p_d = dest_node;\n\n  move = DOWN;\n\n  do\n    {\n      if (move != UP)\n\t{\n\t  if (p_s->name[0] != 0)\n\t    _asn1_cpy_name (p_d, p_s);\n\t  if (p_s->value)\n\t    _asn1_set_value (p_d, p_s->value, p_s->value_len);\n\t  if (p_s->down)\n\t    {\n\t      p_s = p_s->down;\n\t      p_d_prev = p_d;\n\t      p_d = _asn1_add_single_node (p_s->type);\n\t      _asn1_set_down (p_d_prev, p_d);\n\t      continue;\n\t    }\n\t  p_d->start = p_s->start;\n\t  p_d->end = p_s->end;\n\t}\n\n      if (p_s == source_node)\n\tbreak;\n\n      if (p_s->right)\n\t{\n\t  move = RIGHT;\n\t  p_s = p_s->right;\n\t  p_d_prev = p_d;\n\t  p_d = _asn1_add_single_node (p_s->type);\n\t  _asn1_set_right (p_d_prev, p_d);\n\t}\n      else\n\t{\n\t  move = UP;\n\t  p_s = _asn1_find_up (p_s);\n\t  p_d = _asn1_find_up (p_d);\n\t}\n    }\n  while (p_s != source_node);\n\n  return dest_node;\n}",
      "lines": 58,
      "depth": 14,
      "decorators": [
        "asn1_node"
      ]
    },
    "_asn1_copy_structure2": {
      "start_point": [
        455,
        0
      ],
      "end_point": [
        464,
        1
      ],
      "content": "static asn1_node\n_asn1_copy_structure2 (asn1_node root, const char *source_name)\n{\n  asn1_node source_node;\n\n  source_node = asn1_find_node (root, source_name);\n\n  return _asn1_copy_structure3 (source_node);\n\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "asn1_node"
      ]
    },
    "_asn1_type_choice_config": {
      "start_point": [
        467,
        0
      ],
      "end_point": [
        550,
        1
      ],
      "content": "static int\n_asn1_type_choice_config (asn1_node node)\n{\n  asn1_node p, p2, p3, p4;\n  int move, tlen;\n\n  if (node == NULL)\n    return ASN1_ELEMENT_NOT_FOUND;\n\n  p = node;\n  move = DOWN;\n\n  while (!((p == node) && (move == UP)))\n    {\n      if (move != UP)\n\t{\n\t  if ((type_field (p->type) == ASN1_ETYPE_CHOICE)\n\t      && (p->type & CONST_TAG))\n\t    {\n\t      p2 = p->down;\n\t      while (p2)\n\t\t{\n\t\t  if (type_field (p2->type) != ASN1_ETYPE_TAG)\n\t\t    {\n\t\t      p2->type |= CONST_TAG;\n\t\t      p3 = _asn1_find_left (p2);\n\t\t      while (p3)\n\t\t\t{\n\t\t\t  if (type_field (p3->type) == ASN1_ETYPE_TAG)\n\t\t\t    {\n\t\t\t      p4 = _asn1_add_single_node (p3->type);\n\t\t\t      tlen = _asn1_strlen (p3->value);\n\t\t\t      if (tlen > 0)\n\t\t\t\t_asn1_set_value (p4, p3->value, tlen + 1);\n\t\t\t      _asn1_set_right (p4, p2->down);\n\t\t\t      _asn1_set_down (p2, p4);\n\t\t\t    }\n\t\t\t  p3 = _asn1_find_left (p3);\n\t\t\t}\n\t\t    }\n\t\t  p2 = p2->right;\n\t\t}\n\t      p->type &= ~(CONST_TAG);\n\t      p2 = p->down;\n\t      while (p2)\n\t\t{\n\t\t  p3 = p2->right;\n\t\t  if (type_field (p2->type) == ASN1_ETYPE_TAG)\n\t\t    asn1_delete_structure (&p2);\n\t\t  p2 = p3;\n\t\t}\n\t    }\n\t  move = DOWN;\n\t}\n      else\n\tmove = RIGHT;\n\n      if (move == DOWN)\n\t{\n\t  if (p->down)\n\t    p = p->down;\n\t  else\n\t    move = RIGHT;\n\t}\n\n      if (p == node)\n\t{\n\t  move = UP;\n\t  continue;\n\t}\n\n      if (move == RIGHT)\n\t{\n\t  if (p->right)\n\t    p = p->right;\n\t  else\n\t    move = UP;\n\t}\n      if (move == UP)\n\tp = _asn1_find_up (p);\n    }\n\n  return ASN1_SUCCESS;\n}",
      "lines": 84,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_asn1_expand_identifier": {
      "start_point": [
        553,
        0
      ],
      "end_point": [
        657,
        1
      ],
      "content": "static int\n_asn1_expand_identifier (asn1_node * node, asn1_node root)\n{\n  asn1_node p, p2, p3;\n  char name2[ASN1_MAX_NAME_SIZE + 2];\n  int move;\n\n  if (node == NULL)\n    return ASN1_ELEMENT_NOT_FOUND;\n\n  p = *node;\n  move = DOWN;\n\n  while (!((p == *node) && (move == UP)))\n    {\n      if (move != UP)\n\t{\n\t  if (type_field (p->type) == ASN1_ETYPE_IDENTIFIER)\n\t    {\n\t      snprintf (name2, sizeof (name2), \"%s.%s\", root->name, p->value);\n\t      p2 = _asn1_copy_structure2 (root, name2);\n\t      if (p2 == NULL)\n\t\t{\n\t\t  return ASN1_IDENTIFIER_NOT_FOUND;\n\t\t}\n\t      _asn1_cpy_name (p2, p);\n\t      p2->right = p->right;\n\t      p2->left = p->left;\n\t      if (p->right)\n\t\tp->right->left = p2;\n\t      p3 = p->down;\n\t      if (p3)\n\t\t{\n\t\t  while (p3->right)\n\t\t    p3 = p3->right;\n\t\t  _asn1_set_right (p3, p2->down);\n\t\t  _asn1_set_down (p2, p->down);\n\t\t}\n\n\t      p3 = _asn1_find_left (p);\n\t      if (p3)\n\t\t_asn1_set_right (p3, p2);\n\t      else\n\t\t{\n\t\t  p3 = _asn1_find_up (p);\n\t\t  if (p3)\n\t\t    _asn1_set_down (p3, p2);\n\t\t  else\n\t\t    {\n\t\t      p2->left = NULL;\n\t\t    }\n\t\t}\n\n\t      if (p->type & CONST_SIZE)\n\t\tp2->type |= CONST_SIZE;\n\t      if (p->type & CONST_TAG)\n\t\tp2->type |= CONST_TAG;\n\t      if (p->type & CONST_OPTION)\n\t\tp2->type |= CONST_OPTION;\n\t      if (p->type & CONST_DEFAULT)\n\t\tp2->type |= CONST_DEFAULT;\n\t      if (p->type & CONST_SET)\n\t\tp2->type |= CONST_SET;\n\t      if (p->type & CONST_NOT_USED)\n\t\tp2->type |= CONST_NOT_USED;\n\n\t      if (p == *node)\n\t\t*node = p2;\n\t      _asn1_remove_node (p, 0);\n\t      p = p2;\n\t      move = DOWN;\n\t      continue;\n\t    }\n\t  move = DOWN;\n\t}\n      else\n\tmove = RIGHT;\n\n      if (move == DOWN)\n\t{\n\t  if (p->down)\n\t    p = p->down;\n\t  else\n\t    move = RIGHT;\n\t}\n\n      if (p == *node)\n\t{\n\t  move = UP;\n\t  continue;\n\t}\n\n      if (move == RIGHT)\n\t{\n\t  if (p->right)\n\t    p = p->right;\n\t  else\n\t    move = UP;\n\t}\n      if (move == UP)\n\tp = _asn1_find_up (p);\n    }\n\n  return ASN1_SUCCESS;\n}",
      "lines": 105,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "asn1_create_element": {
      "start_point": [
        675,
        0
      ],
      "end_point": [
        695,
        1
      ],
      "content": "int\nasn1_create_element (asn1_node definitions, const char *source_name,\n\t\t     asn1_node * element)\n{\n  asn1_node dest_node;\n  int res;\n\n  dest_node = _asn1_copy_structure2 (definitions, source_name);\n\n  if (dest_node == NULL)\n    return ASN1_ELEMENT_NOT_FOUND;\n\n  _asn1_set_name (dest_node, \"\");\n\n  res = _asn1_expand_identifier (&dest_node, definitions);\n  _asn1_type_choice_config (dest_node);\n\n  *element = dest_node;\n\n  return res;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "asn1_print_structure": {
      "start_point": [
        710,
        0
      ],
      "end_point": [
        1036,
        1
      ],
      "content": "void\nasn1_print_structure (FILE * out, asn1_node structure, const char *name,\n\t\t      int mode)\n{\n  asn1_node p, root;\n  int k, indent = 0, len, len2, len3;\n\n  if (out == NULL)\n    return;\n\n  root = asn1_find_node (structure, name);\n\n  if (root == NULL)\n    return;\n\n  p = root;\n  while (p)\n    {\n      if (mode == ASN1_PRINT_ALL)\n\t{\n\t  for (k = 0; k < indent; k++)\n\t    fprintf (out, \" \");\n\t  fprintf (out, \"name:\");\n\t  if (p->name[0] != 0)\n\t    fprintf (out, \"%s  \", p->name);\n\t  else\n\t    fprintf (out, \"NULL  \");\n\t}\n      else\n\t{\n\t  switch (type_field (p->type))\n\t    {\n\t    case ASN1_ETYPE_CONSTANT:\n\t    case ASN1_ETYPE_TAG:\n\t    case ASN1_ETYPE_SIZE:\n\t      break;\n\t    default:\n\t      for (k = 0; k < indent; k++)\n\t\tfprintf (out, \" \");\n\t      fprintf (out, \"name:\");\n\t      if (p->name[0] != 0)\n\t\tfprintf (out, \"%s  \", p->name);\n\t      else\n\t\tfprintf (out, \"NULL  \");\n\t    }\n\t}\n\n      if (mode != ASN1_PRINT_NAME)\n\t{\n\t  unsigned type = type_field (p->type);\n\t  switch (type)\n\t    {\n\t    case ASN1_ETYPE_CONSTANT:\n\t      if (mode == ASN1_PRINT_ALL)\n\t\tfprintf (out, \"type:CONST\");\n\t      break;\n\t    case ASN1_ETYPE_TAG:\n\t      if (mode == ASN1_PRINT_ALL)\n\t\tfprintf (out, \"type:TAG\");\n\t      break;\n\t    case ASN1_ETYPE_SIZE:\n\t      if (mode == ASN1_PRINT_ALL)\n\t\tfprintf (out, \"type:SIZE\");\n\t      break;\n\t    case ASN1_ETYPE_DEFAULT:\n\t      fprintf (out, \"type:DEFAULT\");\n\t      break;\n\t    case ASN1_ETYPE_IDENTIFIER:\n\t      fprintf (out, \"type:IDENTIFIER\");\n\t      break;\n\t    case ASN1_ETYPE_ANY:\n\t      fprintf (out, \"type:ANY\");\n\t      break;\n\t    case ASN1_ETYPE_CHOICE:\n\t      fprintf (out, \"type:CHOICE\");\n\t      break;\n\t    case ASN1_ETYPE_DEFINITIONS:\n\t      fprintf (out, \"type:DEFINITIONS\");\n\t      break;\n\t    CASE_HANDLED_ETYPES:\n\t      fprintf (out, \"%s\", _asn1_tags[type].desc);\n\t      break;\n\t    default:\n\t      break;\n\t    }\n\t}\n\n      if ((mode == ASN1_PRINT_NAME_TYPE_VALUE) || (mode == ASN1_PRINT_ALL))\n\t{\n\t  switch (type_field (p->type))\n\t    {\n\t    case ASN1_ETYPE_CONSTANT:\n\t      if (mode == ASN1_PRINT_ALL)\n\t\tif (p->value)\n\t\t  fprintf (out, \"  value:%s\", p->value);\n\t      break;\n\t    case ASN1_ETYPE_TAG:\n\t      if (mode == ASN1_PRINT_ALL)\n\t\tif (p->value)\n\t\t  fprintf (out, \"  value:%s\", p->value);\n\t      break;\n\t    case ASN1_ETYPE_SIZE:\n\t      if (mode == ASN1_PRINT_ALL)\n\t\tif (p->value)\n\t\t  fprintf (out, \"  value:%s\", p->value);\n\t      break;\n\t    case ASN1_ETYPE_DEFAULT:\n\t      if (p->value)\n\t\tfprintf (out, \"  value:%s\", p->value);\n\t      else if (p->type & CONST_TRUE)\n\t\tfprintf (out, \"  value:TRUE\");\n\t      else if (p->type & CONST_FALSE)\n\t\tfprintf (out, \"  value:FALSE\");\n\t      break;\n\t    case ASN1_ETYPE_IDENTIFIER:\n\t      if (p->value)\n\t\tfprintf (out, \"  value:%s\", p->value);\n\t      break;\n\t    case ASN1_ETYPE_INTEGER:\n\t      if (p->value)\n\t\t{\n\t\t  len2 = -1;\n\t\t  len = asn1_get_length_der (p->value, p->value_len, &len2);\n\t\t  fprintf (out, \"  value:0x\");\n\t\t  if (len > 0)\n\t\t    for (k = 0; k < len; k++)\n\t\t      fprintf (out, \"%02x\", (unsigned) (p->value)[k + len2]);\n\t\t}\n\t      break;\n\t    case ASN1_ETYPE_ENUMERATED:\n\t      if (p->value)\n\t\t{\n\t\t  len2 = -1;\n\t\t  len = asn1_get_length_der (p->value, p->value_len, &len2);\n\t\t  fprintf (out, \"  value:0x\");\n\t\t  if (len > 0)\n\t\t    for (k = 0; k < len; k++)\n\t\t      fprintf (out, \"%02x\", (unsigned) (p->value)[k + len2]);\n\t\t}\n\t      break;\n\t    case ASN1_ETYPE_BOOLEAN:\n\t      if (p->value)\n\t\t{\n\t\t  if (p->value[0] == 'T')\n\t\t    fprintf (out, \"  value:TRUE\");\n\t\t  else if (p->value[0] == 'F')\n\t\t    fprintf (out, \"  value:FALSE\");\n\t\t}\n\t      break;\n\t    case ASN1_ETYPE_BIT_STRING:\n\t      if (p->value)\n\t\t{\n\t\t  len2 = -1;\n\t\t  len = asn1_get_length_der (p->value, p->value_len, &len2);\n\t\t  if (len > 0)\n\t\t    {\n\t\t      fprintf (out, \"  value(%i):\",\n\t\t\t       (len - 1) * 8 - (p->value[len2]));\n\t\t      for (k = 1; k < len; k++)\n\t\t\tfprintf (out, \"%02x\", (unsigned) (p->value)[k + len2]);\n\t\t    }\n\t\t}\n\t      break;\n\t    case ASN1_ETYPE_GENERALIZED_TIME:\n\t    case ASN1_ETYPE_UTC_TIME:\n\t      if (p->value)\n\t\t{\n\t\t  fprintf (out, \"  value:\");\n\t\t  for (k = 0; k < p->value_len; k++)\n\t\t    fprintf (out, \"%c\", (p->value)[k]);\n\t\t}\n\t      break;\n\t    case ASN1_ETYPE_GENERALSTRING:\n\t    case ASN1_ETYPE_NUMERIC_STRING:\n\t    case ASN1_ETYPE_IA5_STRING:\n\t    case ASN1_ETYPE_TELETEX_STRING:\n\t    case ASN1_ETYPE_PRINTABLE_STRING:\n\t    case ASN1_ETYPE_UNIVERSAL_STRING:\n\t    case ASN1_ETYPE_UTF8_STRING:\n\t    case ASN1_ETYPE_VISIBLE_STRING:\n\t      if (p->value)\n\t\t{\n\t\t  len2 = -1;\n\t\t  len = asn1_get_length_der (p->value, p->value_len, &len2);\n\t\t  fprintf (out, \"  value:\");\n\t\t  if (len > 0)\n\t\t    for (k = 0; k < len; k++)\n\t\t      fprintf (out, \"%c\", (p->value)[k + len2]);\n\t\t}\n\t      break;\n\t    case ASN1_ETYPE_BMP_STRING:\n\t    case ASN1_ETYPE_OCTET_STRING:\n\t      if (p->value)\n\t\t{\n\t\t  len2 = -1;\n\t\t  len = asn1_get_length_der (p->value, p->value_len, &len2);\n\t\t  fprintf (out, \"  value:\");\n\t\t  if (len > 0)\n\t\t    for (k = 0; k < len; k++)\n\t\t      fprintf (out, \"%02x\", (unsigned) (p->value)[k + len2]);\n\t\t}\n\t      break;\n\t    case ASN1_ETYPE_OBJECT_ID:\n\t      if (p->value)\n\t\tfprintf (out, \"  value:%s\", p->value);\n\t      break;\n\t    case ASN1_ETYPE_ANY:\n\t      if (p->value)\n\t\t{\n\t\t  len3 = -1;\n\t\t  len2 = asn1_get_length_der (p->value, p->value_len, &len3);\n\t\t  fprintf (out, \"  value:\");\n\t\t  if (len2 > 0)\n\t\t    for (k = 0; k < len2; k++)\n\t\t      fprintf (out, \"%02x\", (unsigned) (p->value)[k + len3]);\n\t\t}\n\t      break;\n\t    case ASN1_ETYPE_SET:\n\t    case ASN1_ETYPE_SET_OF:\n\t    case ASN1_ETYPE_CHOICE:\n\t    case ASN1_ETYPE_DEFINITIONS:\n\t    case ASN1_ETYPE_SEQUENCE_OF:\n\t    case ASN1_ETYPE_SEQUENCE:\n\t    case ASN1_ETYPE_NULL:\n\t      break;\n\t    default:\n\t      break;\n\t    }\n\t}\n\n      if (mode == ASN1_PRINT_ALL)\n\t{\n\t  if (p->type & 0x1FFFFF00)\n\t    {\n\t      fprintf (out, \"  attr:\");\n\t      if (p->type & CONST_UNIVERSAL)\n\t\tfprintf (out, \"UNIVERSAL,\");\n\t      if (p->type & CONST_PRIVATE)\n\t\tfprintf (out, \"PRIVATE,\");\n\t      if (p->type & CONST_APPLICATION)\n\t\tfprintf (out, \"APPLICATION,\");\n\t      if (p->type & CONST_EXPLICIT)\n\t\tfprintf (out, \"EXPLICIT,\");\n\t      if (p->type & CONST_IMPLICIT)\n\t\tfprintf (out, \"IMPLICIT,\");\n\t      if (p->type & CONST_TAG)\n\t\tfprintf (out, \"TAG,\");\n\t      if (p->type & CONST_DEFAULT)\n\t\tfprintf (out, \"DEFAULT,\");\n\t      if (p->type & CONST_TRUE)\n\t\tfprintf (out, \"TRUE,\");\n\t      if (p->type & CONST_FALSE)\n\t\tfprintf (out, \"FALSE,\");\n\t      if (p->type & CONST_LIST)\n\t\tfprintf (out, \"LIST,\");\n\t      if (p->type & CONST_MIN_MAX)\n\t\tfprintf (out, \"MIN_MAX,\");\n\t      if (p->type & CONST_OPTION)\n\t\tfprintf (out, \"OPTION,\");\n\t      if (p->type & CONST_1_PARAM)\n\t\tfprintf (out, \"1_PARAM,\");\n\t      if (p->type & CONST_SIZE)\n\t\tfprintf (out, \"SIZE,\");\n\t      if (p->type & CONST_DEFINED_BY)\n\t\tfprintf (out, \"DEF_BY,\");\n\t      if (p->type & CONST_GENERALIZED)\n\t\tfprintf (out, \"GENERALIZED,\");\n\t      if (p->type & CONST_UTC)\n\t\tfprintf (out, \"UTC,\");\n\t      if (p->type & CONST_SET)\n\t\tfprintf (out, \"SET,\");\n\t      if (p->type & CONST_NOT_USED)\n\t\tfprintf (out, \"NOT_USED,\");\n\t      if (p->type & CONST_ASSIGN)\n\t\tfprintf (out, \"ASSIGNMENT,\");\n\t    }\n\t}\n\n      if (mode == ASN1_PRINT_ALL)\n\t{\n\t  fprintf (out, \"\\n\");\n\t}\n      else\n\t{\n\t  switch (type_field (p->type))\n\t    {\n\t    case ASN1_ETYPE_CONSTANT:\n\t    case ASN1_ETYPE_TAG:\n\t    case ASN1_ETYPE_SIZE:\n\t      break;\n\t    default:\n\t      fprintf (out, \"\\n\");\n\t    }\n\t}\n\n      if (p->down)\n\t{\n\t  p = p->down;\n\t  indent += 2;\n\t}\n      else if (p == root)\n\t{\n\t  p = NULL;\n\t  break;\n\t}\n      else if (p->right)\n\tp = p->right;\n      else\n\t{\n\t  while (1)\n\t    {\n\t      p = _asn1_find_up (p);\n\t      if (p == root)\n\t\t{\n\t\t  p = NULL;\n\t\t  break;\n\t\t}\n\t      indent -= 2;\n\t      if (p->right)\n\t\t{\n\t\t  p = p->right;\n\t\t  break;\n\t\t}\n\t    }\n\t}\n    }\n}",
      "lines": 327,
      "depth": 22,
      "decorators": [
        "void"
      ]
    },
    "asn1_number_of_elements": {
      "start_point": [
        1052,
        0
      ],
      "end_point": [
        1076,
        1
      ],
      "content": "int\nasn1_number_of_elements (asn1_node element, const char *name, int *num)\n{\n  asn1_node node, p;\n\n  if (num == NULL)\n    return ASN1_GENERIC_ERROR;\n\n  *num = 0;\n\n  node = asn1_find_node (element, name);\n  if (node == NULL)\n    return ASN1_ELEMENT_NOT_FOUND;\n\n  p = node->down;\n\n  while (p)\n    {\n      if (p->name[0] == '?')\n\t(*num)++;\n      p = p->right;\n    }\n\n  return ASN1_SUCCESS;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "asn1_find_structure_from_oid": {
      "start_point": [
        1090,
        0
      ],
      "end_point": [
        1130,
        1
      ],
      "content": "const char *\nasn1_find_structure_from_oid (asn1_node definitions, const char *oidValue)\n{\n  char name[2 * ASN1_MAX_NAME_SIZE + 1];\n  char value[ASN1_MAX_NAME_SIZE];\n  asn1_node p;\n  int len;\n  int result;\n  const char *definitionsName;\n\n  if ((definitions == NULL) || (oidValue == NULL))\n    return NULL;\t\t/* ASN1_ELEMENT_NOT_FOUND; */\n\n  definitionsName = definitions->name;\n\n  /* search the OBJECT_ID into definitions */\n  p = definitions->down;\n  while (p)\n    {\n      if ((type_field (p->type) == ASN1_ETYPE_OBJECT_ID) &&\n\t  (p->type & CONST_ASSIGN))\n\t{\n          snprintf(name, sizeof(name), \"%s.%s\", definitionsName, p->name);\n\n\t  len = ASN1_MAX_NAME_SIZE;\n\t  result = asn1_read_value (definitions, name, value, &len);\n\n\t  if ((result == ASN1_SUCCESS) && (!strcmp (oidValue, value)))\n\t    {\n\t      p = p->right;\n\t      if (p == NULL)\t/* reach the end of ASN1 definitions */\n\t\treturn NULL;\t/* ASN1_ELEMENT_NOT_FOUND; */\n\n\t      return p->name;\n\t    }\n\t}\n      p = p->right;\n    }\n\n  return NULL;\t\t\t/* ASN1_ELEMENT_NOT_FOUND; */\n}",
      "lines": 41,
      "depth": 14,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nasn1_find_structure_from_oid (asn1_node definitions, const char *oidValue)",
        "*"
      ]
    },
    "asn1_copy_node": {
      "start_point": [
        1144,
        0
      ],
      "end_point": [
        1180,
        1
      ],
      "content": "int\nasn1_copy_node (asn1_node dst, const char *dst_name,\n\t\tasn1_node src, const char *src_name)\n{\n  int result;\n  asn1_node dst_node;\n  void *data = NULL;\n  int size = 0;\n\n  result = asn1_der_coding (src, src_name, NULL, &size, NULL);\n  if (result != ASN1_MEM_ERROR)\n    return result;\n\n  data = malloc (size);\n  if (data == NULL)\n    return ASN1_MEM_ERROR;\n\n  result = asn1_der_coding (src, src_name, data, &size, NULL);\n  if (result != ASN1_SUCCESS)\n    {\n      free (data);\n      return result;\n    }\n\n  dst_node = asn1_find_node (dst, dst_name);\n  if (dst_node == NULL)\n    {\n      free (data);\n      return ASN1_ELEMENT_NOT_FOUND;\n    }\n\n  result = asn1_der_decoding (&dst_node, data, size, NULL);\n\n  free (data);\n\n  return result;\n}",
      "lines": 37,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "asn1_dup_node": {
      "start_point": [
        1192,
        0
      ],
      "end_point": [
        1196,
        1
      ],
      "content": "asn1_node\nasn1_dup_node (asn1_node src, const char *src_name)\n{\n  return _asn1_copy_structure2(src, src_name);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "asn1_node"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/lib/structure.h": {},
  "libtasn1/libtasn1-4.13/lib/version.c": {
    "asn1_check_version": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "const char *\nasn1_check_version (const char *req_version)\n{\n  if (!req_version || strverscmp (req_version, ASN1_VERSION) <= 0)\n    return ASN1_VERSION;\n\n  return NULL;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nasn1_check_version (const char *req_version)",
        "*"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/lib/gllib/hash-pjw-bare.c": {
    "hash_pjw_bare": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "size_t\nhash_pjw_bare (const void *x, size_t n)\n{\n  const unsigned char *s = x;\n  size_t h = 0;\n  unsigned i;\n\n  for (i = 0; i < n; i++)\n    h = s[i] + ((h << 9) | (h >> (SIZE_BITS - 9)));\n\n  return h;\n}",
      "lines": 12,
      "depth": 13,
      "decorators": [
        "size_t"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/lib/gllib/hash-pjw-bare.h": {},
  "libtasn1/libtasn1-4.13/lib/gllib/intprops.h": {},
  "libtasn1/libtasn1-4.13/lib/gllib/limits.in.h": {},
  "libtasn1/libtasn1-4.13/lib/gllib/minmax.h": {},
  "libtasn1/libtasn1-4.13/lib/gllib/stddef.in.h": {},
  "libtasn1/libtasn1-4.13/lib/gllib/stdint.in.h": {},
  "libtasn1/libtasn1-4.13/lib/gllib/string.in.h": {},
  "libtasn1/libtasn1-4.13/lib/gllib/strverscmp.c": {
    "__strverscmp": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "int\n__strverscmp (const char *s1, const char *s2)\n{\n  const unsigned char *p1 = (const unsigned char *) s1;\n  const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n  int state;\n  int diff;\n\n  /* Symbol(s)    0       [1-9]   others\n     Transition   (10) 0  (01) d  (00) x   */\n  static const unsigned char next_state[] =\n  {\n      /* state    x    d    0  */\n      /* S_N */  S_N, S_I, S_Z,\n      /* S_I */  S_N, S_I, S_I,\n      /* S_F */  S_N, S_F, S_F,\n      /* S_Z */  S_N, S_F, S_Z\n  };\n\n  static const signed char result_type[] =\n  {\n      /* state   x/x  x/d  x/0  d/x  d/d  d/0  0/x  0/d  0/0  */\n\n      /* S_N */  CMP, CMP, CMP, CMP, LEN, CMP, CMP, CMP, CMP,\n      /* S_I */  CMP, -1,  -1,  +1,  LEN, LEN, +1,  LEN, LEN,\n      /* S_F */  CMP, CMP, CMP, CMP, CMP, CMP, CMP, CMP, CMP,\n      /* S_Z */  CMP, +1,  +1,  -1,  CMP, CMP, -1,  CMP, CMP\n  };\n\n  if (p1 == p2)\n    return 0;\n\n  c1 = *p1++;\n  c2 = *p2++;\n  /* Hint: '0' is a digit too.  */\n  state = S_N + ((c1 == '0') + (isdigit (c1) != 0));\n\n  while ((diff = c1 - c2) == 0)\n    {\n      if (c1 == '\\0')\n        return diff;\n\n      state = next_state[state];\n      c1 = *p1++;\n      c2 = *p2++;\n      state += (c1 == '0') + (isdigit (c1) != 0);\n    }\n\n  state = result_type[state * 3 + (((c2 == '0') + (isdigit (c2) != 0)))];\n\n  switch (state)\n    {\n    case CMP:\n      return diff;\n\n    case LEN:\n      while (isdigit (*p1++))\n        if (!isdigit (*p2++))\n          return 1;\n\n      return isdigit (*p2) ? -1 : diff;\n\n    default:\n      return state;\n    }\n}",
      "lines": 67,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/lib/gllib/sys_types.in.h": {},
  "libtasn1/libtasn1-4.13/lib/gllib/verify.h": {},
  "libtasn1/libtasn1-4.13/src/asn1Coding.c": {
    "usage": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "ATTR_NO_RETRUN static void\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    fprintf (stderr, \"Try `%s --help' for more information.\\n\", program_name);\n  else\n    {\n      printf (\"\\\nUsage: %s [OPTION] DEFINITIONS ASSIGNMENTS\\n\", program_name);\n      printf (\"\\\nGenerates a DER encoding of ASN.1 DEFINITIONS file\\n\\\nand ASSIGNMENTS file with value assignments.\\n\\\n\\n\");\n      printf (\"\\\nMandatory arguments to long options are mandatory for short options too.\\n\\\n  -c, --check           checks the syntax only\\n\\\n  -o, --output=FILE     output file\\n\\\n  -h, --help            display this help and exit\\n\\\n  -v, --version         output version information and exit\\n\");\n      emit_bug_reporting_address ();\n    }\n  exit (status);\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "ATTR_NO_RETRUN",
        "static",
        "static",
        "void",
        "void"
      ]
    },
    "readAssignment": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static int\nreadAssignment (FILE * file, char *varName, char *value)\n{\n\n  int ret;\n\n  ret = fscanf (file, \"%s\", varName);\n  if (ret == EOF)\n    return ASSIGNMENT_EOF;\n  if (!strcmp (varName, \"''\"))\n    varName[0] = 0;\n\n  ret = fscanf (file, \"%s\", value);\n  if (ret == EOF)\n    return ASSIGNMENT_ERROR;\n\n  return ASSIGNMENT_SUCCESS;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "createFileName": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "static void\ncreateFileName (char *inputFileName, char **outputFileName)\n{\n  char *char_p, *slash_p, *dot_p;\n\n  /* searching the last '/' and '.' in inputFileAssignmentName */\n  char_p = inputFileName;\n  slash_p = inputFileName;\n  while ((char_p = strchr (char_p, '/')))\n    {\n      char_p++;\n      slash_p = char_p;\n    }\n\n  char_p = slash_p;\n  dot_p = inputFileName + strlen (inputFileName);\n\n  while ((char_p = strchr (char_p, '.')))\n    {\n      dot_p = char_p;\n      char_p++;\n    }\n\n  /* outputFileName= inputFileName + .out */\n  *outputFileName = (char *) malloc (dot_p - inputFileName + 1 +\n\t\t\t\t     strlen (\".out\"));\n  memcpy (*outputFileName, inputFileName, dot_p - inputFileName);\n  (*outputFileName)[dot_p - inputFileName] = 0;\n  strcat (*outputFileName, \".out\");\n  return;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        358,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  static const struct option long_options[] = {\n    {\"help\", no_argument, 0, 'h'},\n    {\"version\", no_argument, 0, 'v'},\n    {\"check\", no_argument, 0, 'c'},\n    {\"output\", required_argument, 0, 'o'},\n    {0, 0, 0, 0}\n  };\n  int option_index = 0;\n  int option_result;\n  char *outputFileName = NULL;\n  char *inputFileAsnName = NULL;\n  char *inputFileAssignmentName = NULL;\n  int checkSyntaxOnly = 0;\n  asn1_node definitions = NULL;\n  asn1_node structure = NULL;\n  char errorDescription[ASN1_MAX_ERROR_DESCRIPTION_SIZE];\n  int asn1_result = ASN1_SUCCESS;\n  FILE *outputFile;\n  FILE *inputFile;\n  char varName[1024];\n  char value[1024];\n  unsigned char *der = NULL;\n  int der_len;\n  int k;\n  int last_ra;\n\n  set_program_name (argv[0]);\n\n  opterr = 0;\t\t\t/* disable error messages from getopt */\n\n  while (1)\n    {\n\n      option_result =\n\tgetopt_long (argc, argv, \"hvco:\", long_options, &option_index);\n\n      if (option_result == -1)\n\tbreak;\n\n      switch (option_result)\n\t{\n\tcase 'h':\t\t/* HELP */\n\t  free (outputFileName);\n\t  usage (EXIT_SUCCESS);\n\t  break;\n\tcase 'v':\t\t/* VERSION */\n\t  version_etc (stdout, program_name, PACKAGE, VERSION,\n\t\t       \"Fabio Fiorina\", NULL);\n\t  free (outputFileName);\n\t  exit (0);\n\t  break;\n\tcase 'c':\t\t/* CHECK SYNTAX */\n\t  checkSyntaxOnly = 1;\n\t  break;\n\tcase 'o':\t\t/* OUTPUT */\n\t  outputFileName = (char *) malloc (strlen (optarg) + 1);\n\t  strcpy (outputFileName, optarg);\n\t  break;\n\tcase '?':\t\t/* UNKNOW OPTION */\n\t  free (outputFileName);\n\t  fprintf (stderr,\n\t\t   \"asn1Coding: option '%s' not recognized or without argument.\\n\\n\",\n\t\t   argv[optind - 1]);\n\t  usage (EXIT_FAILURE);\n\t  break;\n\tdefault:\n\t  fprintf (stderr,\n\t\t   \"asn1Coding: ?? getopt returned character code Ox%x ??\\n\",\n\t\t   (unsigned)option_result);\n\t}\n    }\n\n  if (optind == argc || optind == argc - 1)\n    {\n      free (outputFileName);\n      fputs (\"asn1Coding: input files missing\\n\", stderr);\n      usage (EXIT_FAILURE);\n    }\n\n  inputFileAsnName = (char *) malloc (strlen (argv[optind]) + 1);\n  strcpy (inputFileAsnName, argv[optind]);\n\n  inputFileAssignmentName = (char *) malloc (strlen (argv[optind + 1]) + 1);\n  strcpy (inputFileAssignmentName, argv[optind + 1]);\n\n  asn1_result =\n    asn1_parser2tree (inputFileAsnName, &definitions, errorDescription);\n\n  switch (asn1_result)\n    {\n    case ASN1_SUCCESS:\n      fputs (\"Parse: done.\\n\", stderr);\n      break;\n    case ASN1_FILE_NOT_FOUND:\n      fprintf (stderr, \"asn1Coding: FILE %s NOT FOUND\\n\", inputFileAsnName);\n      break;\n    case ASN1_SYNTAX_ERROR:\n    case ASN1_IDENTIFIER_NOT_FOUND:\n    case ASN1_NAME_TOO_LONG:\n      fprintf (stderr, \"asn1Coding: %s\\n\", errorDescription);\n      break;\n    default:\n      fprintf (stderr, \"libtasn1 ERROR: %s\\n\", asn1_strerror (asn1_result));\n    }\n\n  if (asn1_result != ASN1_SUCCESS)\n    {\n      free (inputFileAsnName);\n      free (inputFileAssignmentName);\n      exit (1);\n    }\n\n\n  inputFile = fopen (inputFileAssignmentName, \"r\");\n\n  if (inputFile == NULL)\n    {\n      fprintf (stderr, \"asn1Coding: file '%s' not found\\n\",\n\t       inputFileAssignmentName);\n      free (inputFileAsnName);\n      free (inputFileAssignmentName);\n      exit (1);\n    }\n\n\n  putc ('\\n', stderr);\n\n  while ((last_ra = readAssignment (inputFile, varName, value))\n\t == ASSIGNMENT_SUCCESS)\n    {\n      fprintf (stderr, \"var=%s, value=%s\\n\", varName, value);\n      if (structure == NULL)\n\t{\n\t  asn1_result = asn1_create_element (definitions, value, &structure);\n\t}\n      else\n        {\n\t  if (strcmp(value, \"(NULL)\") == 0)\n\t    asn1_result = asn1_write_value (structure, varName, NULL, 0);\n\t  else\n\t    asn1_result = asn1_write_value (structure, varName, value, 0);\n\t}\n\n      if (asn1_result != ASN1_SUCCESS)\n\t{\n\t  fprintf (stderr, \"libtasn1 ERROR: %s\\n\",\n\t\t   asn1_strerror (asn1_result));\n\n\t  asn1_delete_structure (&definitions);\n\t  asn1_delete_structure (&structure);\n\n\t  free (inputFileAsnName);\n\t  free (inputFileAssignmentName);\n\n\t  fclose (inputFile);\n\t  exit (1);\n\t}\n    }\n  if (last_ra != ASSIGNMENT_EOF)\n    {\n      fprintf (stderr, \"asn1Coding: error reading assignment file\\n\");\n      exit (1);\n    }\n  fclose (inputFile);\n\n  putc ('\\n', stderr);\n  asn1_print_structure (stderr, structure, \"\", ASN1_PRINT_NAME_TYPE_VALUE);\n\n  der_len = 0;\n  asn1_result = asn1_der_coding (structure, \"\", der, &der_len,\n\t\t\t\t errorDescription);\n  if (asn1_result == ASN1_MEM_ERROR)\n    {\n      der = malloc (der_len);\n      asn1_result = asn1_der_coding (structure, \"\", der, &der_len,\n\t\t\t\t     errorDescription);\n    }\n  fprintf (stderr, \"\\nCoding: %s\\n\\n\", asn1_strerror (asn1_result));\n  if (asn1_result != ASN1_SUCCESS)\n    {\n      fprintf (stderr, \"asn1Coding: %s\\n\", errorDescription);\n\n      free (der);\n\n      asn1_delete_structure (&definitions);\n      asn1_delete_structure (&structure);\n\n      free (inputFileAsnName);\n      free (inputFileAssignmentName);\n\n      exit (1);\n    }\n\n  /* Print the 'Certificate1' DER encoding */\n  fprintf (stderr, \"-----------------\\nNumber of bytes=%i\\n\", der_len);\n  for (k = 0; k < der_len; k++)\n    fprintf (stderr, \"%02x \", der[k]);\n  fputs (\"\\n-----------------\\n\", stderr);\n\n  asn1_delete_structure (&definitions);\n  asn1_delete_structure (&structure);\n\n  if (!checkSyntaxOnly)\n    {\n      if (outputFileName == NULL)\n\tcreateFileName (inputFileAssignmentName, &outputFileName);\n\n      fprintf (stderr, \"\\nOutputFile=%s\\n\", outputFileName);\n\n      outputFile = fopen (outputFileName, \"w\");\n\n      if (outputFile == NULL)\n\t{\n\t  fprintf (stderr,\n\t\t   \"asn1Coding: output file '%s' not available\\n\",\n\t\t   outputFileName);\n\t  free (der);\n\t  free (inputFileAsnName);\n\t  free (inputFileAssignmentName);\n\t  free (outputFileName);\n\t  exit (1);\n\t}\n\n      for (k = 0; k < der_len; k++)\n\tfprintf (outputFile, \"%c\", der[k]);\n      fclose (outputFile);\n      fputs (\"\\nWriting: done.\\n\", stderr);\n    }\n\n  free (der);\n\n  free (inputFileAsnName);\n  free (inputFileAssignmentName);\n  free (outputFileName);\n\n  exit (0);\n}",
      "lines": 240,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/src/asn1Decoding.c": {
    "usage": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "ATTR_NO_RETRUN static void\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    fprintf (stderr, \"Try `%s --help' for more information.\\n\", program_name);\n  else\n    {\n      printf (\"\\\nUsage: %s [OPTION] DEFINITIONS ENCODED ASN1TYPE\\n\", program_name);\n      printf (\"\\\nDecodes DER data in ENCODED file, for the ASN1TYPE element\\n\\\ndescribed in ASN.1 DEFINITIONS file, and print decoded structures.\\n\\\n\\n\");\n      printf (\"\\\n  -b, --benchmark       perform a benchmark on decoding\\n\\\n  -s, --strict          use strict DER decoding\\n\\\n  -t, --no-time-strict  use strict DER decoding but not in time fields\\n\\\n  -h, --help            display this help and exit\\n\\\n  -v, --version         output version information and exit\\n\");\n      emit_bug_reporting_address ();\n    }\n  exit (status);\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "ATTR_NO_RETRUN",
        "static",
        "static",
        "void",
        "void"
      ]
    },
    "main": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  static const struct option long_options[] = {\n    {\"help\", no_argument, 0, 'h'},\n    {\"strict\", no_argument, 0, 's'},\n    {\"no-time-strict\", no_argument, 0, 't'},\n    {\"debug\", no_argument, 0, 'd'},\n    {\"benchmark\", no_argument, 0, 'b'},\n    {\"version\", no_argument, 0, 'v'},\n    {0, 0, 0, 0}\n  };\n  int option_index = 0;\n  int option_result;\n  char *inputFileAsnName = NULL;\n  char *inputFileDerName = NULL;\n  char *typeName = NULL;\n  asn1_node definitions = NULL;\n  char errorDescription[ASN1_MAX_ERROR_DESCRIPTION_SIZE];\n  int asn1_result = ASN1_SUCCESS;\n  unsigned char *der;\n  int der_len = 0, benchmark = 0;\n  int flags = 0, debug = 0;\n  /* FILE *outputFile; */\n\n  set_program_name (argv[0]);\n\n  opterr = 0;\t\t\t/* disable error messages from getopt */\n\n  while (1)\n    {\n\n      option_result =\n\tgetopt_long (argc, argv, \"hbdsvtc\", long_options, &option_index);\n\n      if (option_result == -1)\n\tbreak;\n\n      switch (option_result)\n\t{\n\tcase 'h':\t\t/* HELP */\n\t  usage (EXIT_SUCCESS);\n\t  break;\n\tcase 'b':\n\t  benchmark = 1;\n\t  break;\n\tcase 'd':\n\t  debug = 1;\n\t  break;\n\tcase 's':\n\tcase 't':\n\t  flags |= ASN1_DECODE_FLAG_STRICT_DER;\n\t  if (option_result == 't')\n\t    flags |= ASN1_DECODE_FLAG_ALLOW_INCORRECT_TIME;\n\t  break;\n\tcase 'v':\t\t/* VERSION */\n\t  version_etc (stdout, program_name, PACKAGE, VERSION,\n\t\t       \"Fabio Fiorina\", NULL);\n\t  exit (0);\n\t  break;\n\tcase '?':\t\t/* UNKNOW OPTION */\n\t  fprintf (stderr,\n\t\t   \"asn1Decoding: option '%s' not recognized or without argument.\\n\\n\",\n\t\t   argv[optind - 1]);\n\t  usage (EXIT_FAILURE);\n\t  break;\n\tdefault:\n\t  fprintf (stderr,\n\t\t   \"asn1Decoding: ?? getopt returned character code Ox%x ??\\n\",\n\t\t   (unsigned)option_result);\n\t}\n    }\n\n  if (optind == argc || optind == argc - 1 || optind == argc - 2)\n    {\n      fprintf (stderr, \"asn1Decoding: input files or ASN.1 type \"\n\t       \"name missing\\n\");\n      usage (EXIT_FAILURE);\n    }\n\n  inputFileAsnName = strdup(argv[optind]);\n  inputFileDerName = strdup(argv[optind + 1]);\n  typeName = strdup(argv[optind + 2]);\n\n  if (!(inputFileAsnName && inputFileDerName && typeName))\n    {\n      fprintf(stderr, \"allocation failed\\n\");\n      free(inputFileAsnName);\n      free(inputFileDerName);\n      free(typeName);\n      exit(1);\n    }\n\n  asn1_result =\n    asn1_parser2tree (inputFileAsnName, &definitions, errorDescription);\n\n  switch (asn1_result)\n    {\n    case ASN1_SUCCESS:\n      fprintf (stderr, \"Parse: done.\\n\");\n      break;\n    case ASN1_FILE_NOT_FOUND:\n      fprintf (stderr, \"asn1Decoding: FILE %s NOT FOUND\\n\", inputFileAsnName);\n      break;\n    case ASN1_SYNTAX_ERROR:\n    case ASN1_IDENTIFIER_NOT_FOUND:\n    case ASN1_NAME_TOO_LONG:\n      fprintf (stderr, \"asn1Decoding: %s\\n\", errorDescription);\n      break;\n    default:\n      fprintf (stderr, \"libtasn1 ERROR: %s\\n\", asn1_strerror (asn1_result));\n    }\n\n  if (asn1_result != ASN1_SUCCESS)\n    {\n      free (inputFileAsnName);\n      free (inputFileDerName);\n      free (typeName);\n      exit (1);\n    }\n\n\n  {\n    size_t tmplen;\n    der = (unsigned char *) read_binary_file (inputFileDerName, &tmplen);\n    der_len = tmplen;\n  }\n\n  /* read_binary_file() returns a buffer with more data than required,\n   * with this reallocation we ensure that memory accesses outside the\n   * boundaries are detected */\n  if (der != NULL && debug != 0)\n    der = realloc(der, der_len);\n\n  if (der == NULL)\n    {\n      fprintf (stderr, \"asn1Decoding: could not read '%s'\\n\",\n\t       inputFileDerName);\n      asn1_delete_structure (&definitions);\n\n      free (inputFileAsnName);\n      free (inputFileDerName);\n      free (typeName);\n      exit (1);\n    }\n\n /*****************************************/\n  /* ONLY FOR TEST                         */\n /*****************************************/\n  /*\n     der_len=0;\n     outputFile=fopen(\"data.p12\",\"w\");\n     while(fscanf(inputFile,\"%c\",der+der_len) != EOF){\n     if((der_len>=0x11) && (der_len<=(0xe70)))\n     fprintf(outputFile,\"%c\",der[der_len]);\n     der_len++;\n     }\n     fclose(outputFile);\n     fclose(inputFile);\n   */\n\n  if (decode (definitions, typeName, der, der_len, benchmark, flags) != ASN1_SUCCESS)\n    {\n      asn1_delete_structure (&definitions);\n      free (inputFileAsnName);\n      free (inputFileDerName);\n      free (typeName);\n      free (der);\n      exit (1);\n    }\n\n  asn1_delete_structure (&definitions);\n\n  free (der);\n\n  free (inputFileAsnName);\n  free (inputFileDerName);\n  free (typeName);\n\n  if (asn1_result != ASN1_SUCCESS)\n    exit (1);\n\n  exit (0);\n}",
      "lines": 184,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "simple_decode": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        300,
        1
      ],
      "content": "static int\nsimple_decode (asn1_node definitions, const char *typeName, void *der,\n\t       int der_len, int benchmark, int flags)\n{\n\n  int asn1_result;\n  asn1_node structure = NULL;\n  char errorDescription[ASN1_MAX_ERROR_DESCRIPTION_SIZE];\n\n  asn1_result = asn1_create_element (definitions, typeName, &structure);\n\n  /* asn1_print_structure(stdout,structure,\"\",ASN1_PRINT_ALL); */\n\n\n  if (asn1_result != ASN1_SUCCESS)\n    {\n      fprintf (stderr, \"Structure creation: %s\\n\",\n\t       asn1_strerror (asn1_result));\n      asn1_delete_structure (&structure);\n      return asn1_result;\n    }\n\n  if (flags != 0)\n    asn1_result =\n      asn1_der_decoding2(&structure, der, &der_len, flags, errorDescription);\n  else\n    asn1_result =\n      asn1_der_decoding (&structure, der, der_len, errorDescription);\n\n  if (!benchmark)\n    fprintf (stderr, \"\\nDecoding: %s\\n\", asn1_strerror (asn1_result));\n  if (asn1_result != ASN1_SUCCESS)\n    {\n      fprintf (stderr, \"asn1Decoding: %s\\n\", errorDescription);\n      asn1_delete_structure (&structure);\n      return asn1_result;\n    }\n\n  if (!benchmark)\n    {\n      fprintf (stderr, \"\\nDECODING RESULT:\\n\");\n      asn1_print_structure (stdout, structure, \"\",\n\t\t\t    ASN1_PRINT_NAME_TYPE_VALUE);\n    }\n  asn1_delete_structure (&structure);\n  return ASN1_SUCCESS;\n}",
      "lines": 47,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "decode": {
      "start_point": [
        302,
        0
      ],
      "end_point": [
        326,
        1
      ],
      "content": "static int\ndecode (asn1_node definitions, const char *typeName, void *der, int der_len,\n\tint benchmark, int flags)\n{\n  struct benchmark_st st;\n\n  if (benchmark == 0)\n    return simple_decode (definitions, typeName, der, der_len, benchmark, flags);\n  else\n    {\n      start_benchmark (&st);\n\n      do\n\t{\n\t  simple_decode (definitions, typeName, der, der_len, benchmark, flags);\n\t  st.size++;\n\t}\n      while (benchmark_must_finish == 0);\n\n      stop_benchmark (&st, \"structures\");\n      fprintf (stdout, \"\\n\");\n\n    }\n  return ASN1_SUCCESS;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/src/asn1Parser.c": {
    "usage": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "ATTR_NO_RETRUN static void\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    fprintf (stderr, \"Try `%s --help' for more information.\\n\", program_name);\n  else\n    {\n      printf (\"\\\nUsage: %s [OPTION] FILE\\n\", program_name);\n      printf (\"\\\nRead FILE with ASN.1 definitions and generate\\n\\\na C array that is used with libtasn1 functions.\\n\\\n\\n\");\n      printf (\"\\\nMandatory arguments to long options are mandatory for short options too.\\n\\\n  -c, --check           checks the syntax only\\n\\\n  -o, --output=FILE     output file\\n\\\n  -n, --name=NAME       array name\\n\\\n  -h, --help            display this help and exit\\n\\\n  -v, --version         output version information and exit\\n\");\n      emit_bug_reporting_address ();\n    }\n  exit (status);\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "ATTR_NO_RETRUN",
        "static",
        "static",
        "void",
        "void"
      ]
    },
    "main": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  static const struct option long_options[] = {\n    {\"help\", no_argument, 0, 'h'},\n    {\"version\", no_argument, 0, 'v'},\n    {\"check\", no_argument, 0, 'c'},\n    {\"output\", required_argument, 0, 'o'},\n    {\"name\", required_argument, 0, 'n'},\n    {0, 0, 0, 0}\n  };\n  int option_index = 0;\n  int option_result;\n  char *outputFileName = NULL;\n  char *inputFileName = NULL;\n  char *vectorName = NULL;\n  int checkSyntaxOnly = 0;\n  asn1_node pointer = NULL;\n  char errorDescription[ASN1_MAX_ERROR_DESCRIPTION_SIZE];\n  int parse_result = ASN1_SUCCESS;\n\n  set_program_name (argv[0]);\n\n  opterr = 0;\t\t\t/* disable error messages from getopt */\n\n  while (1)\n    {\n\n      option_result =\n\tgetopt_long (argc, argv, \"hvco:n:\", long_options, &option_index);\n\n      if (option_result == -1)\n\tbreak;\n\n      switch (option_result)\n\t{\n\tcase 0:\n\t  fprintf (stderr, \"option %s\", long_options[option_index].name);\n\t  if (optarg)\n\t    fprintf (stderr, \" with arg %s\", optarg);\n\t  putc ('\\n', stderr);\n\t  break;\n\tcase 'h':\t\t/* HELP */\n\t  free (outputFileName);\n\t  free (vectorName);\n\t  usage (EXIT_SUCCESS);\n\t  break;\n\tcase 'v':\t\t/* VERSION */\n\t  version_etc (stdout, program_name, PACKAGE, VERSION,\n\t\t       \"Fabio Fiorina\", NULL);\n\t  free (outputFileName);\n\t  free (vectorName);\n\t  exit (0);\n\t  break;\n\tcase 'c':\t\t/* CHECK SYNTAX */\n\t  checkSyntaxOnly = 1;\n\t  break;\n\tcase 'o':\t\t/* OUTPUT */\n\t  outputFileName = (char *) malloc (strlen (optarg) + 1);\n\t  strcpy (outputFileName, optarg);\n\t  break;\n\tcase 'n':\t\t/* VECTOR NAME */\n\t  vectorName = (char *) malloc (strlen (optarg) + 1);\n\t  strcpy (vectorName, optarg);\n\t  break;\n\tcase '?':\t\t/* UNKNOW OPTION */\n\t  fprintf (stderr,\n\t\t   \"asn1Parser: option '%s' not recognized or without argument.\\n\\n\",\n\t\t   argv[optind - 1]);\n\t  free (outputFileName);\n\t  free (vectorName);\n\t  usage (EXIT_FAILURE);\n\t  break;\n\tdefault:\n\t  fprintf (stderr,\n\t\t   \"asn1Parser: ?? getopt returned character code Ox%x ??\\n\",\n\t\t   (unsigned)option_result);\n\t}\n\n    }\n\n  if (optind == argc)\n    {\n      free (outputFileName);\n      free (vectorName);\n      usage (EXIT_SUCCESS);\n    }\n  else\n    {\n      inputFileName = (char *) malloc (strlen (argv[optind]) + 1);\n      strcpy (inputFileName, argv[optind]);\n    }\n\n  if (checkSyntaxOnly == 1)\n    {\n      parse_result =\n\tasn1_parser2tree (inputFileName, &pointer, errorDescription);\n      asn1_delete_structure (&pointer);\n    }\n  else\t\t\t\t/* C VECTOR CREATION */\n    parse_result = asn1_parser2array (inputFileName,\n\t\t\t\t      outputFileName, vectorName,\n\t\t\t\t      errorDescription);\n\n  switch (parse_result)\n    {\n    case ASN1_SUCCESS:\n      fputs (\"Done.\\n\", stderr);\n      break;\n    case ASN1_FILE_NOT_FOUND:\n      fprintf (stderr, \"asn1Parser: file %s was not found\\n\", inputFileName);\n      break;\n    case ASN1_SYNTAX_ERROR:\n    case ASN1_IDENTIFIER_NOT_FOUND:\n    case ASN1_NAME_TOO_LONG:\n      fprintf (stderr, \"asn1Parser: %s\\n\", errorDescription);\n      break;\n    default:\n      fprintf (stderr, \"libtasn1 ERROR: %s\\n\", asn1_strerror (parse_result));\n    }\n\n\n  free (inputFileName);\n  free (outputFileName);\n  free (vectorName);\n\n  if (parse_result != ASN1_SUCCESS)\n    exit (1);\n  exit (0);\n}",
      "lines": 130,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/src/benchmark.c": {
    "alarm_handler": [
      {
        "start_point": [
          32,
          0
        ],
        "end_point": [
          39,
          1
        ],
        "content": "static DWORD WINAPI\nalarm_handler (LPVOID lpParameter)\n{\n  HANDLE wtimer = *((HANDLE *) lpParameter);\n  WaitForSingleObject (wtimer, INFINITE);\n  benchmark_must_finish = 1;\n  return 0;\n}",
        "lines": 8,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "DWORD",
          "WINAPI",
          "WINAPI"
        ]
      },
      {
        "start_point": [
          41,
          0
        ],
        "end_point": [
          45,
          1
        ],
        "content": "static void\nalarm_handler (int signo)\n{\n  benchmark_must_finish = 1;\n}",
        "lines": 5,
        "depth": 5,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      }
    ],
    "value2human": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static void\nvalue2human (unsigned long bytes, double secs, double *data, double *speed,\n\t     char *metric)\n{\n  if (bytes > 1000 && bytes < 1000 * 1000)\n    {\n      *data = ((double) bytes) / 1000;\n      *speed = *data / secs;\n      strcpy (metric, \"KB\");\n      return;\n    }\n  else if (bytes >= 1000 * 1000 && bytes < 1000 * 1000 * 1000)\n    {\n      *data = ((double) bytes) / (1000 * 1000);\n      *speed = *data / secs;\n      strcpy (metric, \"MB\");\n      return;\n    }\n  else if (bytes >= 1000 * 1000 * 1000)\n    {\n      *data = ((double) bytes) / (1000 * 1000 * 1000);\n      *speed = *data / secs;\n      strcpy (metric, \"GB\");\n      return;\n    }\n  else\n    {\n      *data = (double) bytes;\n      *speed = *data / secs;\n      strcpy (metric, \"bytes\");\n      return;\n    }\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "start_benchmark": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "void\nstart_benchmark (struct benchmark_st *st)\n{\n  memset (st, 0, sizeof (*st));\n#ifndef _WIN32\n  st->old_handler = signal (SIGALRM, alarm_handler);\n#endif\n  gettime (&st->start);\n  benchmark_must_finish = 0;\n\n#if defined _WIN32\n  st->wtimer = CreateWaitableTimer (NULL, TRUE, NULL);\n  if (st->wtimer == NULL)\n    {\n      fprintf (stderr, \"error: CreateWaitableTimer %u\\n\", GetLastError ());\n      exit (1);\n    }\n  st->wthread = CreateThread (NULL, 0, alarm_handler, &st->wtimer, 0, NULL);\n  if (st->wthread == NULL)\n    {\n      fprintf (stderr, \"error: CreateThread %u\\n\", GetLastError ());\n      exit (1);\n    }\n  st->alarm_timeout.QuadPart = (5) * 10000000;\n  if (SetWaitableTimer (st->wtimer, &st->alarm_timeout, 0, NULL, NULL, FALSE)\n      == 0)\n    {\n      fprintf (stderr, \"error: SetWaitableTimer %u\\n\", GetLastError ());\n      exit (1);\n    }\n#else\n  alarm (5);\n#endif\n\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "stop_benchmark": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "double\nstop_benchmark (struct benchmark_st *st, const char *metric)\n{\n  double secs;\n  unsigned long lsecs;\n  struct timespec stop;\n  double dspeed, ddata;\n  char imetric[16];\n\n#if defined _WIN32\n  if (st->wtimer != NULL)\n    CloseHandle (st->wtimer);\n  if (st->wthread != NULL)\n    CloseHandle (st->wthread);\n#else\n  signal (SIGALRM, st->old_handler);\n#endif\n\n  gettime (&stop);\n\n  lsecs = (stop.tv_sec * 1000 + stop.tv_nsec / (1000 * 1000) -\n\t   (st->start.tv_sec * 1000 + st->start.tv_nsec / (1000 * 1000)));\n  secs = lsecs;\n  secs /= 1000;\n\n  if (metric == NULL)\n    {\t\t\t\t/* assume bytes/sec */\n      value2human (st->size, secs, &ddata, &dspeed, imetric);\n      printf (\"  Processed %.2f %s in %.2f secs: \", ddata, imetric, secs);\n      printf (\"%.2f %s/sec\\n\", dspeed, imetric);\n    }\n  else\n    {\n      ddata = (double) st->size;\n      dspeed = ddata / secs;\n      printf (\"  Processed %.2f %s in %.2f secs: \", ddata, metric, secs);\n      printf (\"%.2f %s/sec\\n\", dspeed, metric);\n    }\n\n  return secs;\n}",
      "lines": 41,
      "depth": 12,
      "decorators": [
        "double"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/src/benchmark.h": {
    "timespec_sub_ms": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "inline static unsigned int\ntimespec_sub_ms (struct timespec *a, struct timespec *b)\n{\n  return (a->tv_sec * 1000 + a->tv_nsec / (1000 * 1000) -\n\t  (b->tv_sec * 1000 + b->tv_nsec / (1000 * 1000)));\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "inline",
        "inline",
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/tests/coding-decoding2.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "int\nmain (int argc, char** argv)\n{\n  int result = 0;\n  asn1_node definitions = NULL, node1 = NULL, node2 = NULL;\n  char errorDescription[ASN1_MAX_ERROR_DESCRIPTION_SIZE];\n  const char *choicefile = getenv (\"ASN1CODINGDECODING2\");\n  int start, end;\n\n  char data[1024];\n  int data_size = sizeof (data);\n\n  if (!choicefile)\n    choicefile = \"coding-decoding2.asn\";\n\n  /* Encode */\n  result = asn1_parser2tree (choicefile, &definitions, errorDescription);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"error in %d\\n\", __LINE__);\n      exit (1);\n    }\n\n  result = asn1_create_element (definitions, \"TEST.Main\", &node1);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"error in %d\\n\", __LINE__);\n      exit (1);\n    }\n\n  result = asn1_write_value (node1, \"pad1\", \"\\x01\\x02\\x03\", 3);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"error in %d\\n\", __LINE__);\n      exit (1);\n    }\n\n  result = asn1_write_value (node1, \"pad2\", \"\\x00\\x01\", 2);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"error in %d\\n\", __LINE__);\n      exit (1);\n    }\n\n  result = asn1_write_value (node1, \"choice0\", \"choice1\", 1);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"error in %d\\n\", __LINE__);\n      exit (1);\n    }\n\n  result = asn1_write_value (node1, \"choice0.choice1\", \"choice2\", 1);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"error in %d\\n\", __LINE__);\n      exit (1);\n    }\n\n  result = asn1_write_value (node1, \"choice0.choice1.choice2\", \"int1\", 1);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"error in %d\\n\", __LINE__);\n      exit (1);\n    }\n\n  result = asn1_write_value (node1, \"choice0.choice1.choice2.int1\", \"1234\", 0);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"error in %d\\n\", __LINE__);\n      exit (1);\n    }\n\n  result = asn1_der_coding (node1, \"\", data, &data_size, errorDescription);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"error in %d\\n\", __LINE__);\n      exit (1);\n    }\n\n  /*asn1_print_structure(stdout, node1, \"\", ASN1_PRINT_ALL);*/\n\n  result = asn1_der_decoding_startEnd (node1, data, data_size, \"choice0.choice1.choice2.int1\", &start, &end);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"Cannot find start End: %d\\n\", __LINE__);\n      exit (1);\n    }\n  if (start != 7 && end != 10)\n    {\n      printf(\"Error in start and end values for choice1.choice2.int1. Have: %d..%d\\n\", start, end);\n      exit(1);\n    }\n\n  result = asn1_der_decoding_startEnd (node1, data, data_size, \"choice0.choice1\", &start, &end);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"Cannot find start End: %d\\n\", __LINE__);\n      exit (1);\n    }\n  if (start != 7 && end != 10)\n    {\n      printf(\"Error in start and end values for choice1. Have: %d..%d\\n\", start, end);\n      exit(1);\n    }\n\n  result = asn1_der_decoding_startEnd (node1, data, data_size, \"pad2\", &start, &end);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"Cannot find start End\\n\");\n      exit (1);\n    }\n  if (start != 11 && end != 13)\n    {\n      printf(\"Error in start and end values for pad2. Have: %d..%d\\n\", start, end);\n      exit(1);\n    }\n\n  asn1_delete_structure (&node1);\n\n  /* Decode */\n  result = asn1_create_element (definitions, \"TEST.Main\", &node2);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"error in %d\\n\", __LINE__);\n      exit (1);\n    }\n\n#if 0\n  printf (\"der:\");\n  for (i = 0; i < data_size; i++)\n    printf (\"%.2x \", (unsigned char) (data[i]));\n  printf (\"\\n\");\n#endif\n\n  result = asn1_der_decoding (&node2, data, data_size, errorDescription);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"error in %d: %s\\n\", __LINE__, errorDescription);\n      exit (1);\n    }\n\n  result = asn1_der_decoding_startEnd (node2, data, data_size, \"choice0.choice1.choice2.int1\", &start, &end);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"Cannot find start End: %d\\n\", __LINE__);\n      exit (1);\n    }\n  if (start != 7 && end != 10)\n    {\n      printf(\"Error in start and end values for choice0.choice1.choice2.int1. Have: %d..%d\\n\", start, end);\n      exit(1);\n    }\n\n  result = asn1_der_decoding_startEnd (node2, data, data_size, \"pad2\", &start, &end);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"Cannot find start End: %d\\n\", __LINE__);\n      exit (1);\n    }\n  if (start != 11 && end != 13)\n    {\n      printf(\"Error in start and end values for pad2. Have: %d..%d\\n\", start, end);\n      exit(1);\n    }\n\n  asn1_delete_structure (&node2);\n  asn1_delete_structure (&definitions);\n\n  return 0;\n}",
      "lines": 175,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/tests/coding-long-oid.c": {
    "main": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "int\nmain (int argc, char** argv)\n{\n  int result = 0;\n  asn1_node definitions = NULL, node1 = NULL;\n  char errorDescription[ASN1_MAX_ERROR_DESCRIPTION_SIZE];\n  const char *pkixfile = getenv (\"ASN1PKIX\");\n  int new_data_size;\n\n  if (!pkixfile)\n    pkixfile = \"pkix.asn\";\n\n  /* Encode */\n  result = asn1_parser2tree (pkixfile, &definitions, errorDescription);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"error in %d: %s\\n\", __LINE__, errorDescription);\n      exit (1);\n    }\n\n  result = asn1_create_element (definitions, \"PKIX1.Certificate\", &node1);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"error in %d\\n\", __LINE__);\n      exit (1);\n    }\n\n  result = asn1_der_decoding (&node1, der_data, der_data_size, errorDescription);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"error in %d: %s\\n\", __LINE__, errorDescription);\n      exit (1);\n    }\n\n  new_data_size = sizeof(new_data);\n  result = asn1_der_coding (node1, \"\", new_data, &new_data_size, errorDescription);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"error in %d\\n\", __LINE__);\n      exit (1);\n    }\n\n  if (new_data_size != der_data_size)\n    {\n      printf (\"error in %d\\n\", __LINE__);\n      printf (\"new_size is %d, expected: %d\\n\", new_data_size, der_data_size);\n      exit (1);\n    }\n\n  if (memcmp(new_data, der_data, der_data_size) != 0)\n    {\n      printf (\"error in %d\\n\", __LINE__);\n      exit (1);\n    }\n\n  asn1_delete_structure (&node1);\n  asn1_delete_structure (&definitions);\n\n  return 0;\n}",
      "lines": 60,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/tests/copynode.c": {
    "main": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int result;\n  char buffer[5 * 1024];\n  char buffer2[5 * 1024];\n  asn1_node definitions = NULL;\n  asn1_node asn1_element = NULL, cpy_node = NULL;\n  char errorDescription[ASN1_MAX_ERROR_DESCRIPTION_SIZE];\n  FILE *out, *fd;\n  int start, end;\n  ssize_t size;\n  int size2;\n  const char *treefile = getenv (\"ASN1PKIX\");\n  const char *derfile = getenv (\"ASN1CRLDER\");\n  int verbose = 0;\n\n  if (argc > 1)\n    verbose = 1;\n\n  if (!treefile)\n    treefile = \"pkix.asn\";\n\n  if (!derfile)\n    derfile = \"crl.der\";\n\n  if (verbose)\n    {\n      printf (\"\\n\\n/****************************************/\\n\");\n      printf (\"/*     Test sequence : Test_indefinite  */\\n\");\n      printf (\"/****************************************/\\n\\n\");\n      printf (\"ASN1TREE: %s\\n\", treefile);\n    }\n\n  /* Check version */\n  if (asn1_check_version (\"0.3.3\") == NULL)\n    printf (\"\\nLibrary version check ERROR:\\n actual version: %s\\n\\n\",\n\t    asn1_check_version (NULL));\n\n  result = asn1_parser2tree (treefile, &definitions, errorDescription);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"ErrorDescription = %s\\n\\n\", errorDescription);\n      exit (1);\n    }\n\n  out = stdout;\n\n  fd = fopen (derfile, \"rb\");\n  if (fd == NULL)\n    {\n      printf (\"Cannot read file %s\\n\", derfile);\n      exit (1);\n    }\n  size = fread (buffer, 1, sizeof (buffer), fd);\n  if (size <= 0)\n    {\n      printf (\"Cannot read from file %s\\n\", derfile);\n      exit (1);\n    }\n\n  fclose (fd);\n\n  result =\n    asn1_create_element (definitions, \"PKIX1.CertificateList\", &asn1_element);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"Cannot create CRL element\\n\");\n      exit (1);\n    }\n\n  result = asn1_der_decoding (&asn1_element, buffer, size, errorDescription);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"Cannot decode DER data (size %ld)\\n\", (long) size);\n      exit (1);\n    }\n\n  /* test asn1_copy_node */\n  result =\n    asn1_create_element (definitions, \"PKIX1.CertificateList\", &cpy_node);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"Cannot create CRL element\\n\");\n      exit (1);\n    }\n\n  result = asn1_copy_node(cpy_node, \"\", asn1_element, \"\");\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"Cannot copy node\\n\");\n      exit (1);\n    }\n\n  /* test whether the copied node encodes the same */\n  size2 = sizeof(buffer2);\n  result = asn1_der_coding (cpy_node, \"\", buffer2, &size2, NULL);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"Cannot encode data (size %ld)\\n\", (long) size);\n      exit (1);\n    }\n \n  if (size2 != size || memcmp(buffer, buffer2, size) != 0) \n    {\n      printf(\"DER encoded data differ!\\n\");\n      exit(1);\n    }\n\n  asn1_delete_structure (&cpy_node);\n\n  /* Test asn1_dup_node */\n  cpy_node = asn1_dup_node(asn1_element, \"\");\n  if (cpy_node == NULL)\n    {\n      printf (\"Cannot copy node (dup_node)\\n\");\n      exit (1);\n    }\n\n  /* test whether the copied node encodes the same */\n  size2 = sizeof(buffer2);\n  result = asn1_der_coding (cpy_node, \"\", buffer2, &size2, NULL);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"Cannot encode data (size %ld)\\n\", (long) size);\n      exit (1);\n    }\n \n  if (size2 != size || memcmp(buffer, buffer2, size) != 0) \n    {\n      printf(\"DER encoded data differ!\\n\");\n      exit(1);\n    }\n\n  result = asn1_der_decoding_startEnd (asn1_element, buffer, size, \"tbsCertList.issuer\", &start, &end);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"Cannot find start End\\n\");\n      exit (1);\n    }\n  if (start != 24 && end != 291)\n    {\n      printf(\"Error in start and end values for issuer. Have: %d..%d\\n\", start, end);\n      exit(1);\n    }\n\n  result = asn1_der_decoding_startEnd (asn1_element, buffer, size, \"signature\", &start, &end);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"Cannot find start End\\n\");\n      exit (1);\n    }\n  if (start != 372 && end != 503)\n    {\n      printf(\"Error in start and end values for signature. Have: %d..%d\\n\", start, end);\n      exit(1);\n    }\n\n  /* Clear the definition structures */\n  asn1_delete_structure (&asn1_element);\n  asn1_delete_structure (&cpy_node);\n  asn1_delete_structure (&definitions);\n\n  if (out != stdout)\n    fclose (out);\n\n  exit (0);\n}",
      "lines": 177,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/tests/object-id-decoding.c": {
    "main": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  char str[128];\n  int ret, ret_len;\n  size_t i;\n\n  for (i = 0; i < sizeof (tv) / sizeof (tv[0]); i++)\n    {\n      /* decode */\n      ret =\n\tasn1_get_object_id_der (tv[i].der_str+1,\n\t\t\t\ttv[i].der_len-1, &ret_len, str,\n\t\t\t\tsizeof (str));\n      if (ret != tv[i].expected_error)\n\t{\n\t  fprintf (stderr,\n\t\t   \"%d: asn1_get_object_id_der iter %lu: got %d expected %d\\n\",\n\t\t   __LINE__, (unsigned long) i, ret, tv[i].expected_error);\n\t  return 1;\n\t}\n\n      if (ret_len != tv[i].der_len-1)\n\t{\n\t  fprintf (stderr,\n\t\t   \"%d: iter %lu: error in DER, length returned is %d, had %d\\n\",\n\t\t   __LINE__, (unsigned long)i, ret_len, tv[i].der_len-1);\n\t  return 1;\n\t}\n\n      if (strcmp (tv[i].oid, str) != 0)\n\t{\n\t  fprintf (stderr,\n\t\t   \"%d: strcmp iter %lu: got invalid OID: %s, expected: %s\\n\",\n\t\t   __LINE__, (unsigned long) i, str, tv[i].oid);\n\t  return 1;\n\t}\n\n    }\n\n  return 0;\n}",
      "lines": 42,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/tests/ocsp-basic-response.c": {
    "main": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "int\nmain (int argc, char** argv)\n{\n  int result = 0, len;\n  asn1_node definitions = NULL, node1 = NULL;\n  char errorDescription[ASN1_MAX_ERROR_DESCRIPTION_SIZE];\n  const char *choicefile = getenv (\"ASN1CHOICE_OCSP\");\n  const char *datafile = getenv (\"ASN1_RESPONSE_OCSP_DATA\");\n  FILE *fp;\n  char data[1024];\n  int data_size = sizeof (data);\n  unsigned etype;\n\n  if (!choicefile)\n    choicefile = \"pkix.asn\";\n\n  if (!datafile)\n    datafile = \"ocsp-basic-response.der\";\n\n  result = asn1_parser2tree (choicefile, &definitions, errorDescription);\n  if (result != ASN1_SUCCESS)\n    {\n      fprintf (stderr, \"error in %d: %s\\n\", __LINE__, errorDescription);\n      exit (1);\n    }\n\n  result = asn1_create_element (definitions, \"PKIX1.BasicOCSPResponse\", &node1);\n  if (result != ASN1_SUCCESS)\n    {\n      fprintf (stderr, \"error in %d\\n\", __LINE__);\n      exit (1);\n    }\n\n  fp = fopen(datafile, \"rb\");\n  if (fp == NULL)\n    {\n      fprintf (stderr, \"error in %d\\n\", __LINE__);\n      exit (1);\n    }\n  data_size = fread(data, 1, sizeof(data), fp);\n  fclose(fp);\n\n  result = asn1_der_decoding2 (&node1, data, &data_size, ASN1_DECODE_FLAG_STRICT_DER, errorDescription);\n  if (result != ASN1_SUCCESS)\n    {\n      fprintf (stderr, \"error in %d: decoding: %s\\n\", __LINE__, errorDescription);\n      exit (1);\n    }\n\n  len = sizeof(data);\n  result = asn1_read_value(node1, \"tbsResponseData.responderID\", data, &len);\n  if (result != ASN1_SUCCESS)\n    {\n      fprintf (stderr, \"error in %d: %s\\n\", __LINE__, errorDescription);\n      exit (1);\n    }\n\n  if (strcmp(data, \"byKey\") != 0)\n    {\n      fprintf (stderr, \"error in %d: %s\\n\", __LINE__, data);\n      exit (1);\n    }\n\n  len = 0;\n  result = asn1_read_value_type(node1, \"tbsResponseData.responderID.byKey\", NULL, &len, &etype);\n  if (result != ASN1_MEM_ERROR)\n    {\n      fprintf (stderr, \"error in %d: result is: %s\\n\", __LINE__, asn1_strerror(result));\n      exit (1);\n    }\n\n  if (etype != ASN1_ETYPE_OCTET_STRING)\n    {\n      fprintf (stderr, \"error in %d: The type (%d) doesn't match octet string.\\n\", __LINE__, (int)etype);\n      exit (1);\n    }\n\n  if (len != 20)\n    {\n      fprintf (stderr, \"length doesn't match the expected (got: %d, should be: 20)\\n\", len);\n      exit (1);\n    }\n\n  \n\n  len = sizeof(data);\n  result = asn1_read_value(node1, \"tbsResponseData.responderID.byKey\", data, &len);\n  if (result != ASN1_SUCCESS)\n    {\n      fprintf (stderr, \"error in %d: %s\\n\", __LINE__, errorDescription);\n      exit (1);\n    }\n\n  if (memcmp(data, \"\\x50\\xEA\\x73\\x89\\xDB\\x29\\xFB\\x10\\x8F\\x9E\\xE5\\x01\\x20\\xD4\\xDE\\x79\\x99\\x48\\x83\\xF7\", len) != 0)\n    {\n      fprintf (stderr, \"contents don't match\\n\");\n      exit (1);\n    }\n\n  asn1_delete_structure (&node1);\n  asn1_delete_structure (&definitions);\n\n  return 0;\n}",
      "lines": 104,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/tests/octet-string.c": {
    "main": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  unsigned char str[100];\n  unsigned char der[100];\n  int der_len = sizeof (der);\n  int str_size = sizeof (str);\n  unsigned char *tmp = NULL;\n  int ret, ret_len;\n  size_t i;\n\n  for (i = 0; i < sizeof (tv) / sizeof (tv[0]); i++)\n    {\n      /* Decode */\n\n      if (tv[i].ber == 0)\n\t{\n\t  str_size = sizeof (str);\n\t  ret =\n\t    asn1_get_octet_der (tv[i].der_str + 1,\n\t\t\t\ttv[i].der_len - 1, &ret_len, str,\n\t\t\t\tsizeof (str), &str_size);\n\t  if (ret != tv[i].expected_error)\n\t    {\n\t      fprintf (stderr,\n\t\t       \"%d: asn1_get_octet_der iter %lu: got %d expected %d\\n\",\n\t\t       __LINE__, (unsigned long) i, ret,\n\t\t       tv[i].expected_error);\n\t      return 1;\n\t    }\n\t  if (tv[i].expected_error)\n\t    continue;\n\n\t  if (ret_len != tv[i].der_len - 1)\n\t    {\n\t      fprintf (stderr,\n\t\t       \"%d: error in DER, length returned is %d, had %d\\n\",\n\t\t       __LINE__, ret_len, tv[i].der_len - 1);\n\t      return 1;\n\t    }\n\n\t  if (str_size != tv[i].len\n\t      || memcmp (tv[i].string, str, tv[i].len) != 0)\n\t    {\n\t      fprintf (stderr,\n\t\t       \"%d: memcmp iter %lu: got invalid decoding\\n\",\n\t\t       __LINE__, (unsigned long) i);\n\t      return 1;\n\t    }\n\n\t  /* Encode */\n\t  der_len = sizeof (der);\n\t  asn1_octet_der (str, str_size, der, &der_len);\n\n\t  if (der_len != tv[i].der_len - 1\n\t      || memcmp (tv[i].der_str + 1, der, tv[i].der_len - 1) != 0)\n\t    {\n\t      fprintf (stderr,\n\t\t       \"encoding iter %lu: got invalid encoding\\n\",\n\t\t       (unsigned long) i);\n\t      return 1;\n\t    }\n\t}\n\n      ret =\n\tasn1_decode_simple_ber (ASN1_ETYPE_OCTET_STRING,\n\t\t\t\ttv[i].der_str, tv[i].der_len,\n\t\t\t\t&tmp, (unsigned int*)&str_size, (unsigned int*)&der_len);\n      if (ret != tv[i].expected_error)\n\t{\n\t  fprintf (stderr,\n\t\t   \"%d: asn1_decode_simple_ber iter %lu: got %s expected %s\\n\",\n\t\t   __LINE__, (unsigned long) i, asn1_strerror(ret), asn1_strerror(tv[i].expected_error));\n\t  return 1;\n\t}\n      if (tv[i].expected_error)\n        continue;\n\n      if (der_len != tv[i].der_len)\n\t{\n\t  fprintf (stderr,\n\t\t   \"%d: error in iter %lu: DER, length returned is %d, had %d\\n\",\n\t\t   __LINE__, (unsigned long)i, der_len, tv[i].der_len);\n\t  return 1;\n\t}\n\n      if (str_size != tv[i].len || memcmp (tv[i].string, tmp, tv[i].len) != 0)\n\t{\n\t  fprintf (stderr,\n\t\t   \"%d: memcmp iter %lu: got invalid decoding\\n\",\n\t\t   __LINE__, (unsigned long) i);\n\t  return 1;\n\t}\n      free (tmp);\n      tmp = NULL;\n\n    }\n\n  return 0;\n}",
      "lines": 100,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/tests/spc_pe_image_data.c": {
    "main": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "int main (int argc, char** argv)\n{\n\tint result = 0, len;\n\tasn1_node definitions = NULL, node1 = NULL;\n\tchar errorDescription[ASN1_MAX_ERROR_DESCRIPTION_SIZE];\n\tconst char *choicefile = getenv (\"ASN1_MSCAT\");\n\tconst char *datafile = getenv (\"ASN1_SPC_PE_IMAGE_DATA\");\n\tFILE *fp;\n\tchar data[1024];\n\tint data_size = sizeof (data);\n\tunsigned etype;\n\tint cmp;\n\n\tif (choicefile == NULL) {\n\t\tchoicefile = \"mscat.asn\";\n\t}\n\n\tif (datafile == NULL) {\n\t\tdatafile = \"spc_pe_image_data.der\";\n\t}\n\n\tresult = asn1_parser2tree(choicefile, &definitions, errorDescription);\n\tif (result != ASN1_SUCCESS) {\n\t\tfprintf(stderr, \"error in %d: %s\\n\", __LINE__, errorDescription);\n\t\texit (1);\n\t}\n\n\tresult = asn1_create_element(definitions,\n\t\t\t\t     \"CATALOG.SpcPEImageData\",\n\t\t\t\t     &node1);\n\tif (result != ASN1_SUCCESS) {\n\t\tfprintf(stderr, \"error in %d\\n\", __LINE__);\n\t\texit (1);\n\t}\n\n\tfp = fopen(datafile, \"rb\");\n\tif (fp == NULL) {\n\t\tfprintf (stderr, \"error in %d\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tdata_size = fread(data, 1, sizeof(data), fp);\n\tfclose(fp);\n\n\tresult = asn1_der_decoding2(&node1,\n\t\t\t\t    data,\n\t\t\t\t    &data_size,\n\t\t\t\t    ASN1_DECODE_FLAG_STRICT_DER,\n\t\t\t\t    errorDescription);\n\tif (result != ASN1_SUCCESS) {\n\t\tfprintf(stderr, \"error in %d: decoding: %s\\n\", __LINE__, errorDescription);\n\t\texit(1);\n\t}\n\n\tlen = 0;\n\tresult = asn1_read_value_type(node1,\n\t\t\t\t      \"flags\",\n\t\t\t\t      NULL,\n\t\t\t\t      &len,\n\t\t\t\t      &etype);\n\tif (result != ASN1_MEM_ERROR) {\n\t\tfprintf(stderr, \"error in %d: %s\\n\", __LINE__, errorDescription);\n\t\texit(1);\n\t}\n\n\tif ((size_t)len >= sizeof(data)) {\n\t\tfprintf(stderr,\n\t\t\t\"error len=%d, sizeof(data)=%zu\\n\",\n\t\t\tlen,\n\t\t\tsizeof(data));\n\t\texit(1);\n\t}\n\n\tresult = asn1_read_value(node1, \"flags\", data, &len);\n\tif (result != ASN1_SUCCESS) {\n\t\tfprintf(stderr, \"error in %d: %s\\n\", __LINE__, errorDescription);\n\t\texit (1);\n\t}\n\n\tetype = 0;\n\tlen = 0;\n\tresult = asn1_read_value_type(node1, \"link\", NULL, &len, &etype);\n\tif (result != ASN1_MEM_ERROR)\n\t{\n\t\tfprintf(stderr,\n\t\t\t\"error in %d: result is: %s\\n\",\n\t\t\t__LINE__,\n\t\t\tasn1_strerror(result));\n\t\texit(1);\n\t}\n\n\tif (etype != ASN1_ETYPE_CHOICE) {\n\t\tfprintf(stderr,\n\t\t\t\"error in %d: The type (%u) doesn't match choice.\\n\",\n\t\t\t__LINE__,\n\t\t\tetype);\n\t\texit(1);\n\t}\n\n\tif (len != 5) {\n\t\tfprintf (stderr, \"length doesn't match the expected (got: %d, should be: 20)\\n\", len);\n\t\texit (1);\n\t}\n\n\tlen = sizeof(data);\n\tresult = asn1_read_value(node1, \"link\", data, &len);\n\tif (result != ASN1_SUCCESS) {\n\t\tfprintf(stderr, \"error in %d: %s\\n\", __LINE__, errorDescription);\n\t\texit (1);\n\t}\n\n\tcmp = memcmp(data, \"file\", len);\n\tif (cmp != 0) {\n\t\tfprintf(stderr, \"contents don't match\\n\");\n\t\texit(1);\n\t}\n\n\tprintf(\"SUCCESS\\n\");\n\n\tasn1_delete_structure (&node1);\n\tasn1_delete_structure (&definitions);\n\n\treturn 0;\n}",
      "lines": 123,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/tests/strict-der.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int result;\n  char buffer[10 * 1024];\n  asn1_node definitions = NULL;\n  asn1_node asn1_element = NULL;\n  char errorDescription[ASN1_MAX_ERROR_DESCRIPTION_SIZE];\n  FILE *out, *fd;\n  int size;\n  const char *treefile = getenv (\"ASN1PKIX\");\n  const char *indeffile = getenv (\"ASN1INDEF\");\n  int verbose = 0;\n\n  if (argc > 1)\n    verbose = 1;\n\n  if (!treefile)\n    treefile = \"pkix.asn\";\n\n  if (!indeffile)\n    indeffile = \"TestIndef.p12\";\n\n  if (verbose)\n    {\n      printf (\"\\n\\n/****************************************/\\n\");\n      printf (\"/*     Test sequence : strict DER decoding  */\\n\");\n      printf (\"/****************************************/\\n\\n\");\n      printf (\"ASN1TREE: %s\\n\", treefile);\n    }\n\n  /* Check version */\n  if (asn1_check_version (\"0.2.11\") == NULL)\n    printf (\"\\nLibrary version check ERROR:\\n actual version: %s\\n\\n\",\n\t    asn1_check_version (NULL));\n\n  result = asn1_parser2tree (treefile, &definitions, errorDescription);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"ErrorDescription = %s\\n\\n\", errorDescription);\n      exit (1);\n    }\n\n  out = stdout;\n\n  fd = fopen (indeffile, \"rb\");\n  if (fd == NULL)\n    {\n      printf (\"Cannot read file %s\\n\", indeffile);\n      exit (1);\n    }\n  size = fread (buffer, 1, sizeof (buffer), fd);\n  if (size <= 0)\n    {\n      printf (\"Cannot read from file %s\\n\", indeffile);\n      exit (1);\n    }\n\n  fclose (fd);\n\n  result =\n    asn1_create_element (definitions, \"PKIX1.pkcs-12-PFX\", &asn1_element);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"Cannot create PKCS12 element\\n\");\n      exit (1);\n    }\n\n  result = asn1_der_decoding2 (&asn1_element, buffer, &size, 0, errorDescription);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"Cannot decode BER data (size %ld) in %s: %s\\n\", (long) size, indeffile, errorDescription);\n      exit (1);\n    }\n\n  asn1_delete_structure (&asn1_element);\n\n  /* Now try with strict DER */\n  result =\n    asn1_create_element (definitions, \"PKIX1.pkcs-12-PFX\", &asn1_element);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"Cannot create PKCS12 element\\n\");\n      exit (1);\n    }\n\n  result = asn1_der_decoding2 (&asn1_element, buffer, &size, ASN1_DECODE_FLAG_STRICT_DER, errorDescription);\n  if (result == ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"Should not have decoded DER data (size %ld) in %s: %s\\n\", (long) size, indeffile, errorDescription);\n      exit (1);\n    }\n\n  asn1_delete_structure (&asn1_element);\n\n  /* Clear the definition structures */\n  asn1_delete_structure (&definitions);\n\n  if (out != stdout)\n    fclose (out);\n\n  exit (0);\n}",
      "lines": 108,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/tests/Test_choice.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "int\nmain (int argc, char** argv)\n{\n  int result = 0;\n  asn1_node definitions = NULL, node1 = NULL, node2 = NULL;\n  char errorDescription[ASN1_MAX_ERROR_DESCRIPTION_SIZE];\n  const char *choicefile = getenv (\"ASN1CHOICE\");\n\n  char data[1024];\n  int data_size = sizeof (data);\n\n  if (!choicefile)\n    choicefile = \"pkix.asn\";\n\n  /* Encode */\n  result = asn1_parser2tree (choicefile, &definitions, errorDescription);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"error in %d\\n\", __LINE__);\n      exit (1);\n    }\n\n  result = asn1_create_element (definitions, \"TEST.Choice0\", &node1);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"error in %d\\n\", __LINE__);\n      exit (1);\n    }\n\n  result = asn1_write_value (node1, \"\", \"choice1\", 1);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"error in %d\\n\", __LINE__);\n      exit (1);\n    }\n\n  result = asn1_write_value (node1, \"choice1\", \"choice2\", 1);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"error in %d\\n\", __LINE__);\n      exit (1);\n    }\n\n  result = asn1_write_value (node1, \"choice1.choice2\", \"int1\", 1);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"error in %d\\n\", __LINE__);\n      exit (1);\n    }\n\n  result = asn1_write_value (node1, \"choice1.choice2.int1\", \"1234\", 0);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"error in %d\\n\", __LINE__);\n      exit (1);\n    }\n\n  result = asn1_der_coding (node1, \"\", data, &data_size, errorDescription);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"error in %d\\n\", __LINE__);\n      exit (1);\n    }\n\n  asn1_delete_structure (&node1);\n\n  /* Decode */\n  result = asn1_create_element (definitions, \"TEST.Choice0\", &node2);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"error in %d\\n\", __LINE__);\n      exit (1);\n    }\n\n#if 0\n  printf (\"der:\");\n  for (i = 0; i < data_size; i++)\n    printf (\"%.2x \", (unsigned char) (data[i]));\n  printf (\"\\n\");\n#endif\n\n  result = asn1_der_decoding (&node2, data, data_size, errorDescription);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"error in %d\\n\", __LINE__);\n      exit (1);\n    }\n\n  asn1_delete_structure (&node2);\n  asn1_delete_structure (&definitions);\n\n  return 0;\n}",
      "lines": 93,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/tests/Test_choice_ocsp.c": {
    "main": {
      "start_point": [
        5,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "int\nmain (int argc, char** argv)\n{\n  int result = 0, len;\n  asn1_node definitions = NULL, node1 = NULL;\n  char errorDescription[ASN1_MAX_ERROR_DESCRIPTION_SIZE];\n  const char *choicefile = getenv (\"ASN1CHOICE_OCSP\");\n  const char *datafile = getenv (\"ASN1CHOICE_OCSP_DATA\");\n  FILE *fp;\n  char data[1024];\n  char data2[1024];\n  int data_size = sizeof (data);\n\n  if (!choicefile)\n    choicefile = \"pkix.asn\";\n\n  if (!datafile)\n    datafile = \"ocsp.der\";\n\n  /* Encode */\n  result = asn1_parser2tree (choicefile, &definitions, errorDescription);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"error in %d: %s\\n\", __LINE__, errorDescription);\n      exit (1);\n    }\n\n  result = asn1_create_element (definitions, \"PKIX1.ResponseData\", &node1);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"error in %d\\n\", __LINE__);\n      exit (1);\n    }\n\n  fp = fopen(datafile, \"rb\");\n  if (fp == NULL)\n    {\n      printf (\"error in %d\\n\", __LINE__);\n      exit (1);\n    }\n  data_size = fread(data, 1, sizeof(data), fp);\n  fclose(fp);\n\n  result = asn1_der_decoding (&node1, data, data_size, errorDescription);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"error in %d: %s\\n\", __LINE__, errorDescription);\n      exit (1);\n    }\n\n  len = sizeof(data2);\n  result = asn1_der_coding (node1, \"\", data2, &len, errorDescription);\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"error in %d: %s\\n\", __LINE__, errorDescription);\n      exit (1);\n    }\n\n  if (len != data_size)\n    {\n      printf (\"length doesn't match (got: %d, should be: %d)\\n\", len, data_size);\n      exit (1);\n    }\n\n  if (memcmp(data, data2, len) != 0)\n    {\n      printf (\"contents don't match\\n\");\n      exit (1);\n    }\n\n  asn1_delete_structure (&node1);\n  asn1_delete_structure (&definitions);\n\n  return 0;\n}",
      "lines": 75,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/tests/Test_encdec.c": {
    "main": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int result;\n  char buffer[5 * 1024];\n  char buffer2[5 * 1024];\n  asn1_node definitions = NULL;\n  asn1_node asn1_element = NULL;\n  char errorDescription[ASN1_MAX_ERROR_DESCRIPTION_SIZE];\n  FILE *out, *fd;\n  ssize_t size;\n  int start, end;\n  int size2;\n  const char *treefile = getenv (\"ASN1PKIX\");\n  const char *derfile = getenv (\"ASN1CRLDER\");\n  int verbose = 0;\n\n  if (argc > 1)\n    verbose = 1;\n\n  if (!treefile)\n    treefile = \"pkix.asn\";\n\n  if (!derfile)\n    derfile = \"crl.der\";\n\n  if (verbose)\n    {\n      printf (\"\\n\\n/****************************************/\\n\");\n      printf (\"/*     Test sequence : Test_indefinite  */\\n\");\n      printf (\"/****************************************/\\n\\n\");\n      printf (\"ASN1TREE: %s\\n\", treefile);\n    }\n\n  /* Check version */\n  if (asn1_check_version (\"0.3.3\") == NULL)\n    printf (\"\\nLibrary version check ERROR:\\n actual version: %s\\n\\n\",\n\t    asn1_check_version (NULL));\n\n  result = asn1_parser2tree (treefile, &definitions, errorDescription);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"ErrorDescription = %s\\n\\n\", errorDescription);\n      exit (1);\n    }\n\n  out = stdout;\n\n  fd = fopen (derfile, \"rb\");\n  if (fd == NULL)\n    {\n      printf (\"Cannot read file %s\\n\", derfile);\n      exit (1);\n    }\n  size = fread (buffer, 1, sizeof (buffer), fd);\n  if (size <= 0)\n    {\n      printf (\"Cannot read from file %s\\n\", derfile);\n      exit (1);\n    }\n\n  fclose (fd);\n\n  result =\n    asn1_create_element (definitions, \"PKIX1.CertificateList\", &asn1_element);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"Cannot create CRL element\\n\");\n      exit (1);\n    }\n\n  result = asn1_der_decoding (&asn1_element, buffer, size, errorDescription);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"Cannot decode DER data (size %ld)\\n\", (long) size);\n      exit (1);\n    }\n\n  result = asn1_der_decoding_startEnd (asn1_element, buffer, size, \"tbsCertList\", &start, &end);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"Cannot find start End\\n\");\n      exit (1);\n    }\n  if (start != 4 && end != 358)\n    {\n      printf(\"Error in start and end values. Have: %d..%d\\n\", start, end);\n      exit(1);\n    }\n\n  result = asn1_der_decoding_startEnd (asn1_element, buffer, size, \"signature\", &start, &end);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"Cannot find start End\\n\");\n      exit (1);\n    }\n  if (start != 372 && end != 503)\n    {\n      printf(\"Error in start and end values for signature. Have: %d..%d\\n\", start, end);\n      exit(1);\n    }\n\n  result = asn1_der_decoding_startEnd (asn1_element, buffer, size, \"tbsCertList.revokedCertificates.?1.userCertificate\", &start, &end);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"Cannot find start End\\n\");\n      exit (1);\n    }\n  if (start != 326 && end != 343)\n    {\n      printf(\"Error in start and end values for userCertificate. Have: %d..%d\\n\", start, end);\n      exit(1);\n    }\n\n  size2 = sizeof(buffer2);\n  result = asn1_der_coding (asn1_element, \"\", buffer2, &size2, NULL);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"Cannot encode data (size %ld)\\n\", (long) size);\n      exit (1);\n    }\n \n  if (size2 != size || memcmp(buffer, buffer2, size) != 0) \n    {\n      printf(\"DER encoded data differ!\\n\");\n      exit(1);\n    }\n\n  /* Clear the definition structures */\n  asn1_delete_structure (&definitions);\n  asn1_delete_structure (&asn1_element);\n\n  if (out != stdout)\n    fclose (out);\n\n  exit (0);\n}",
      "lines": 144,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/tests/Test_encoding.c": {
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int result, verbose = 0;\n  asn1_node definitions = NULL;\n  asn1_node asn1_element = NULL;\n  char errorDescription[ASN1_MAX_ERROR_DESCRIPTION_SIZE];\n  const char *treefile = getenv (\"ASN1ENCODING\");\n\n  if (argc > 1)\n    verbose = 1;\n\n  if (!treefile)\n    treefile = \"Test_encoding.asn\";\n\n  if (verbose != 0)\n    {\n      printf (\"\\n\\n/****************************************/\\n\");\n      printf (\"/*     Test sequence : coding-decoding  */\\n\");\n      printf (\"/****************************************/\\n\\n\");\n    }\n\n  /* Check version */\n  if (asn1_check_version (\"0.3.3\") == NULL)\n    printf (\"\\nLibrary version check ERROR:\\n actual version: %s\\n\\n\",\n\t    asn1_check_version (NULL));\n\n  result = asn1_parser2tree (treefile, &definitions, errorDescription);\n\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"ErrorDescription = %s\\n\\n\", errorDescription);\n      exit (1);\n    }\n\n  result = asn1_create_element (definitions, \"TEST_TREE.Koko\", &asn1_element);\n  if (result != ASN1_SUCCESS)\n    {\n      fprintf (stderr, \"asn1_create_element(): \");\n      asn1_perror (result);\n      exit (1);\n    }\n\n  result = asn1_write_value (asn1_element, \"seqint\", \"NEW\", 1);\n  if (result != ASN1_SUCCESS)\n    {\n      fprintf (stderr, \"asn1_write_value(): seqint \");\n      asn1_perror (result);\n      exit (1);\n    }\n\n  result = asn1_write_value (asn1_element, \"seqint.?LAST\", \"1234\", 0);\n  if (result != ASN1_SUCCESS)\n    {\n      fprintf (stderr, \"asn1_write_value(): seqint.?LAST \");\n      asn1_perror (result);\n      exit (1);\n    }\n\n  result = asn1_write_value (asn1_element, \"int\", \"\\x0f\\xff\\x01\", 3);\n  if (result != ASN1_SUCCESS)\n    {\n      fprintf (stderr, \"asn1_write_value(): int \");\n      asn1_perror (result);\n      exit (1);\n    }\n\n  result = asn1_write_value (asn1_element, \"str\", \"string\", 6);\n  if (result != ASN1_SUCCESS)\n    {\n      fprintf (stderr, \"asn1_write_value(): str \");\n      asn1_perror (result);\n      exit (1);\n    }\n\n  result = asn1_write_value (asn1_element, \"a\", \"string1\", 7);\n  if (result != ASN1_SUCCESS)\n    {\n      fprintf (stderr, \"asn1_write_value(): str \");\n      asn1_perror (result);\n      exit (1);\n    }\n\n  result = asn1_write_value (asn1_element, \"b\", \"string2\", 7);\n  if (result != ASN1_SUCCESS)\n    {\n      fprintf (stderr, \"asn1_write_value(): str \");\n      asn1_perror (result);\n      exit (1);\n    }\n\n  result = asn1_write_value (asn1_element, \"c\", \"string3\", 7);\n  if (result != ASN1_SUCCESS)\n    {\n      fprintf (stderr, \"asn1_write_value(): str \");\n      asn1_perror (result);\n      exit (1);\n    }\n\n  result = asn1_write_value (asn1_element, \"exp\", \"string4\", 7);\n  if (result != ASN1_SUCCESS)\n    {\n      fprintf (stderr, \"asn1_write_value(): str \");\n      asn1_perror (result);\n      exit (1);\n    }\n\n  /* Clear the definition structures */\n  asn1_delete_structure (&definitions);\n\n  result = asn1_der_coding (asn1_element, \"\", data, &data_size, NULL);\n  if (result != ASN1_SUCCESS)\n    {\n      fprintf (stderr, \"Encoding error.\\n\");\n      asn1_perror (result);\n      exit (1);\n    }\n\n  result = asn1_der_decoding (&asn1_element, data, data_size, NULL);\n  if (result != ASN1_SUCCESS)\n    {\n      fprintf (stderr, \"Decoding error.\\n\");\n      asn1_perror (result);\n      exit (1);\n    }\n\n  asn1_delete_structure (&asn1_element);\n\n  if (verbose)\n    printf (\"Success\\n\");\n  exit (0);\n}",
      "lines": 133,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/tests/Test_errors.c": {
    "main": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int ec = 0;\n  const char *errstr;\n  int verbose = 0;\n\n  if (argc > 1)\n    verbose = 1;\n\n  do\n    {\n      errstr = asn1_strerror (ec);\n      if (verbose != 0)\n\tasn1_perror (ec);\n      ec++;\n    }\n  while (errstr);\n\n  return 0;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/tests/Test_indefinite.c": {
    "main": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int result;\n  char buffer[10 * 1024];\n  asn1_node definitions = NULL;\n  asn1_node asn1_element = NULL;\n  char errorDescription[ASN1_MAX_ERROR_DESCRIPTION_SIZE];\n  FILE *out, *fd;\n  ssize_t size;\n  const char *treefile = getenv (\"ASN1PKIX\");\n  const char *indeffile = getenv (\"ASN1INDEF\");\n  const char *indeffile2 = getenv (\"ASN1INDEF2\");\n  const char *indeffile3 = getenv (\"ASN1INDEF3\");\n  int verbose = 0;\n\n  if (argc > 1)\n    verbose = 1;\n\n  if (!treefile)\n    treefile = \"pkix.asn\";\n\n  if (!indeffile)\n    indeffile = \"TestIndef.p12\";\n\n  if (!indeffile2)\n    indeffile2 = \"TestIndef2.p12\";\n\n  if (!indeffile3)\n    indeffile3 = \"TestIndef3.der\";\n\n  if (verbose)\n    {\n      printf (\"\\n\\n/****************************************/\\n\");\n      printf (\"/*     Test sequence : Test_indefinite  */\\n\");\n      printf (\"/****************************************/\\n\\n\");\n      printf (\"ASN1TREE: %s\\n\", treefile);\n    }\n\n  /* Check version */\n  if (asn1_check_version (\"0.2.11\") == NULL)\n    printf (\"\\nLibrary version check ERROR:\\n actual version: %s\\n\\n\",\n\t    asn1_check_version (NULL));\n\n  result = asn1_parser2tree (treefile, &definitions, errorDescription);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"ErrorDescription = %s\\n\\n\", errorDescription);\n      exit (1);\n    }\n\n  out = stdout;\n\n  fd = fopen (indeffile, \"rb\");\n  if (fd == NULL)\n    {\n      printf (\"Cannot read file %s\\n\", indeffile);\n      exit (1);\n    }\n  size = fread (buffer, 1, sizeof (buffer), fd);\n  if (size <= 0)\n    {\n      printf (\"Cannot read from file %s\\n\", indeffile);\n      exit (1);\n    }\n\n  fclose (fd);\n\n  result =\n    asn1_create_element (definitions, \"PKIX1.pkcs-12-PFX\", &asn1_element);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"Cannot create PKCS12 element\\n\");\n      exit (1);\n    }\n\n  result = asn1_der_decoding (&asn1_element, buffer, size, errorDescription);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"Cannot decode BER data (size %ld) in %s: %s\\n\", (long) size, indeffile, errorDescription);\n      exit (1);\n    }\n\n  asn1_delete_structure (&asn1_element);\n\n  /* second test */\n  fd = fopen (indeffile2, \"rb\");\n  if (fd == NULL)\n    {\n      printf (\"Cannot read file %s\\n\", indeffile2);\n      exit (1);\n    }\n  size = fread (buffer, 1, sizeof (buffer), fd);\n  if (size <= 0)\n    {\n      printf (\"Cannot read from file %s\\n\", indeffile2);\n      exit (1);\n    }\n\n  fclose (fd);\n\n  result =\n    asn1_create_element (definitions, \"PKIX1.pkcs-12-PFX\", &asn1_element);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"Cannot create PKCS12 element\\n\");\n      exit (1);\n    }\n\n  result = asn1_der_decoding (&asn1_element, buffer, size, errorDescription);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"Cannot decode BER data (size %ld) in %s: %s\\n\", (long) size, indeffile2, errorDescription);\n      exit (1);\n    }\n\n  asn1_delete_structure (&asn1_element);\n\n  /* third test */\n  fd = fopen (indeffile3, \"rb\");\n  if (fd == NULL)\n    {\n      printf (\"Cannot read file %s\\n\", indeffile3);\n      exit (1);\n    }\n  size = fread (buffer, 1, sizeof (buffer), fd);\n  if (size <= 0)\n    {\n      printf (\"Cannot read from file %s\\n\", indeffile3);\n      exit (1);\n    }\n\n  fclose (fd);\n\n  result =\n    asn1_create_element (definitions, \"PKIX1.pkcs-12-CertBag\", &asn1_element);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"Cannot create CertBag element\\n\");\n      exit (1);\n    }\n\n  result = asn1_der_decoding (&asn1_element, buffer, size, errorDescription);\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"Cannot decode DER data (size %ld) in %s: %s\\n\", (long) size, indeffile3, errorDescription);\n      exit (1);\n    }\n\n  asn1_delete_structure (&asn1_element);\n\n  /* Clear the definition structures */\n  asn1_delete_structure (&definitions);\n\n  if (out != stdout)\n    fclose (out);\n\n  exit (0);\n}",
      "lines": 166,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/tests/Test_overflow.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  /* Test that values larger than long are rejected.  This has worked\n     fine with all versions of libtasn1. */\n  int verbose = 0;\n\n  if (argc > 1)\n    verbose = 1;\n\n  {\n    unsigned char der[] = \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\";\n    long l;\n    int len;\n\n    l = asn1_get_length_der (der, sizeof der, &len);\n\n    if (l == -2L)\n      {\n\tif (verbose)\n\t  puts (\"OK: asn1_get_length_der bignum\");\n      }\n    else\n      {\n\tprintf (\"ERROR: asn1_get_length_der bignum (l %ld len %d)\\n\", l, len);\n\treturn 1;\n      }\n  }\n\n  /* Test that values larger than int but smaller than long are\n     rejected.  This limitation was introduced with libtasn1 2.12. */\n  if (LONG_MAX > INT_MAX)\n    {\n      unsigned long num = ((long) UINT_MAX) << 2;\n      unsigned char der[20];\n      int der_len;\n      long l;\n      int len;\n\n      asn1_length_der (num, der, &der_len);\n\n      l = asn1_get_length_der (der, der_len, &len);\n\n      if (l == -2L)\n\t{\n\t  if (verbose)\n\t    puts (\"OK: asn1_get_length_der intnum\");\n\t}\n      else\n\t{\n\t  printf (\"ERROR: asn1_get_length_der intnum (l %ld len %d)\\n\", l,\n\t\t  len);\n\t  return 1;\n\t}\n    }\n\n  /* Test that values larger than would fit in the input string are\n     rejected.  This problem was fixed in libtasn1 2.12. */\n  {\n    unsigned long num = 64;\n    unsigned char der[20];\n    int der_len;\n    long l;\n    int len;\n\n    asn1_length_der (num, der, &der_len);\n\n    der_len = sizeof (der);\n    l = asn1_get_length_der (der, der_len, &len);\n\n    if (l == -4L)\n      {\n\tif (verbose)\n\t  puts (\"OK: asn1_get_length_der overflow-small\");\n      }\n    else\n      {\n\tprintf (\"ERROR: asn1_get_length_der overflow-small (l %ld len %d)\\n\",\n\t\tl, len);\n\treturn 1;\n      }\n  }\n\n  /* Test that values larger than would fit in the input string are\n     rejected.  This problem was fixed in libtasn1 2.12. */\n  {\n    unsigned long num = 1073741824;\n    unsigned char der[20];\n    int der_len;\n    long l;\n    int len;\n\n    asn1_length_der (num, der, &der_len);\n\n    der_len = sizeof (der);\n    l = asn1_get_length_der (der, der_len, &len);\n\n    if (l == -4L)\n      {\n\tif (verbose)\n\t  puts (\"OK: asn1_get_length_der overflow-large1\");\n      }\n    else\n      {\n\tprintf (\"ERROR: asn1_get_length_der overflow-large1 (l %ld len %d)\\n\",\n\t\tl, len);\n\treturn 1;\n      }\n  }\n\n  /* Test that values larger than would fit in the input string are\n     rejected.  This problem was fixed in libtasn1 2.12. */\n  {\n    unsigned long num = 2147483649;\n    unsigned char der[20];\n    int der_len;\n    long l;\n    int len;\n\n    asn1_length_der (num, der, &der_len);\n\n    der_len = sizeof (der);\n    l = asn1_get_length_der (der, der_len, &len);\n\n    if (l == -2L)\n      {\n\tif (verbose)\n\t  puts (\"OK: asn1_get_length_der overflow-large2\");\n      }\n    else\n      {\n\tprintf (\"ERROR: asn1_get_length_der overflow-large2 (l %ld len %d)\\n\",\n\t\tl, len);\n\treturn 1;\n      }\n  }\n\n  return 0;\n}",
      "lines": 139,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/tests/Test_parser.c": {
    "readLine": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "static int\nreadLine (FILE * file, char *line)\n{\n  int c;\n\n  while (((c = fgetc (file)) != EOF) && (c != '\\n'))\n    {\n      *line = c;\n      line++;\n    }\n\n  *line = 0;\n\n  return c;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "createFile": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "static void\ncreateFile (int lineNumber, const char *line)\n{\n  FILE *fileIn, *fileOut;\n  char lineRead[1024];\n  int fileInLineNumber = 0;\n\n  fileIn = fopen (fileCorrectName, \"r\");\n  fileOut = fopen (fileErroredName, \"w\");\n\n  while (readLine (fileIn, lineRead) != EOF)\n    {\n      fileInLineNumber++;\n      if (fileInLineNumber == lineNumber)\n\tfprintf (fileOut, \"%s\\n\", line);\n      else\n\tfprintf (fileOut, \"%s\\n\", lineRead);\n    }\n\n  fclose (fileOut);\n  fclose (fileIn);\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int result;\n  asn1_node definitions = NULL;\n  char errorDescription[ASN1_MAX_ERROR_DESCRIPTION_SIZE];\n  test_type *test;\n  int errorCounter = 0, testCounter = 0;\n  int verbose = 0;\n\n  if (argc > 1)\n    verbose = 1;\n\n  fileCorrectName = getenv (\"ASN1PARSER\");\n  if (!fileCorrectName)\n    fileCorrectName = \"Test_parser.asn\";\n\n  if (verbose != 0)\n    {\n      printf (\"\\n\\n/****************************************/\\n\");\n      printf (\"/*     Test sequence : Test_parser      */\\n\");\n      printf (\"/****************************************/\\n\\n\");\n      printf (\"ASN1PARSER: %s\\n\", fileCorrectName);\n    }\n\n  result = asn1_parser2tree (fileCorrectName, &definitions, errorDescription);\n\n  if (result != ASN1_SUCCESS)\n    {\n      printf (\"File '%s' not correct\\n\", fileCorrectName);\n      asn1_perror (result);\n      printf (\"ErrorDescription = %s\\n\\n\", errorDescription);\n      exit (1);\n    }\n\n  /* Only for Test */\n  /* asn1_visit_tree(stdout,definitions,\"TEST_PARSER\",ASN1_PRINT_ALL); */\n\n  /* Clear the definitions structures */\n  asn1_delete_structure (&definitions);\n\n\n  test = test_array;\n\n  while (test->lineNumber != 0)\n    {\n      testCounter++;\n\n      createFile (test->lineNumber, test->line);\n\n      result =\n\tasn1_parser2tree (fileErroredName, &definitions, errorDescription);\n      asn1_delete_structure (&definitions);\n\n      if ((result != test->errorNumber) ||\n\t  (strcmp (errorDescription, test->errorDescription)))\n\t{\n\t  errorCounter++;\n\t  printf (\"ERROR N. %d:\\n\", errorCounter);\n\t  printf (\"  Line %d - %s\\n\", test->lineNumber, test->line);\n\t  printf (\"  Error expected: %s - %s\\n\",\n\t\t  asn1_strerror (test->errorNumber), test->errorDescription);\n\t  printf (\"  Error detected: %s - %s\\n\\n\", asn1_strerror (result),\n\t\t  errorDescription);\n\t  exit (1);\n\t}\n\n      test++;\n    }\n\n\n  if (verbose != 0)\n    {\n      printf (\"Total tests : %d\\n\", testCounter);\n      printf (\"Total errors: %d\\n\", errorCounter);\n    }\n\n  if (errorCounter > 0)\n    return 1;\n\n  exit (0);\n}",
      "lines": 82,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/tests/Test_simple.c": {
    "main": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        208,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int result;\n  unsigned char der[100];\n  unsigned char str[100];\n  int der_len = sizeof (der);\n  int str_size = sizeof (str);\n  int ret_len, bit_len;\n  size_t i;\n\n  /* Dummy test */\n\n  asn1_bit_der (NULL, 0, der, &der_len);\n  result = asn1_get_bit_der (der, 0, &ret_len, str, str_size, &bit_len);\n  if (result != ASN1_GENERIC_ERROR)\n    {\n      fprintf (stderr, \"asn1_get_bit_der zero\\n\");\n      return 1;\n    }\n\n  /* Encode short strings with increasing bit lengths */\n\n  for (i = 0; i < sizeof (tv) / sizeof (tv[0]); i++)\n    {\n      /* Encode */\n\n      asn1_bit_der ((const unsigned char *) tv[i].bitstr, tv[i].bitlen,\n\t\t    der, &der_len);\n\n#if 0\n      {\n\tsize_t j;\n\tfor (j = 0; j < der_len; j++)\n\t  printf (\"\\\\x%02x\", der[j]);\n\tprintf (\"\\n\");\n      }\n#endif\n\n      if (der_len != tv[i].derlen || memcmp (der, tv[i].der, der_len) != 0)\n\t{\n\t  fprintf (stderr, \"asn1_bit_der iter %lu\\n\", (unsigned long) i);\n\t  return 1;\n\t}\n\n      /* Decode it */\n\n      result = asn1_get_bit_der (der, der_len, &ret_len, str,\n\t\t\t\t str_size, &bit_len);\n      if (result != ASN1_SUCCESS || ret_len != tv[i].derlen\n\t  || bit_len != tv[i].bitlen)\n\t{\n\t  fprintf (stderr, \"asn1_get_bit_der iter %lu, err: %d\\n\", (unsigned long) i, result);\n\t  return 1;\n\t}\n    }\n\n\n  /* Decode sample from \"A Layman's Guide to a Subset of ASN.1, BER,\n     and DER\" section 5.4 \"BIT STRING\": \"The BER encoding of the BIT\n     STRING value \"011011100101110111\" can be any of the following,\n     among others, depending on the choice of padding bits, the form\n     of length octets [...]\".\n   */\n\n  /* 03 04 06 6e 5d c0  DER encoding */\n\n  memcpy (der, \"\\x04\\x06\\x6e\\x5d\\xc0\", 5);\n  der_len = 5;\n\n  result = asn1_get_bit_der (der, der_len, &ret_len, str, str_size, &bit_len);\n  if (result != ASN1_SUCCESS || ret_len != 5\n      || bit_len != 18 || memcmp (str, \"\\x6e\\x5d\\xc0\", 3) != 0)\n    {\n      fprintf (stderr, \"asn1_get_bit_der example\\n\");\n      return 1;\n    }\n\n  der_len = sizeof (der);\n  asn1_bit_der (str, bit_len, der, &der_len);\n  if (der_len != 5 || memcmp (der, \"\\x04\\x06\\x6e\\x5d\\xc0\", 5) != 0)\n    {\n      fprintf (stderr, \"asn1_bit_der example roundtrip\\n\");\n      return 1;\n    }\n\n  /* 03 04 06 6e 5d e0 padded with \"100000\" */\n\n  memcpy (der, \"\\x04\\x06\\x6e\\x5d\\xe0\", 5);\n  der_len = 5;\n\n  result = asn1_get_bit_der (der, der_len, &ret_len, str, str_size, &bit_len);\n  if (result != ASN1_SUCCESS || ret_len != 5\n      || bit_len != 18 || memcmp (str, \"\\x6e\\x5d\\xe0\", 3) != 0)\n    {\n      fprintf (stderr, \"asn1_get_bit_der example padded\\n\");\n      return 1;\n    }\n\n  der_len = sizeof (der);\n  asn1_bit_der (str, bit_len, der, &der_len);\n  if (der_len != 5 || memcmp (der, \"\\x04\\x06\\x6e\\x5d\\xc0\", 5) != 0)\n    {\n      fprintf (stderr, \"asn1_bit_der example roundtrip\\n\");\n      return 1;\n    }\n\n  /* 03 81 04 06 6e 5d c0 long form of length octets */\n\n  memcpy (der, \"\\x81\\x04\\x06\\x6e\\x5d\\xc0\", 6);\n  der_len = 6;\n\n  result = asn1_get_bit_der (der, der_len, &ret_len, str, str_size, &bit_len);\n\n  if (result != ASN1_SUCCESS || ret_len != 6\n      || bit_len != 18 || memcmp (str, \"\\x6e\\x5d\\xc0\", 3) != 0)\n    {\n      fprintf (stderr, \"asn1_get_bit_der example long form\\n\");\n      return 1;\n    }\n\n  der_len = sizeof (der);\n  asn1_bit_der (str, bit_len, der, &der_len);\n  if (der_len != 5 || memcmp (der, \"\\x04\\x06\\x6e\\x5d\\xc0\", 5) != 0)\n    {\n      fprintf (stderr, \"asn1_bit_der example roundtrip\\n\");\n      return 1;\n    }\n\n  return 0;\n}",
      "lines": 131,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/tests/Test_strings.c": {
    "main": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int ret;\n  unsigned char tl[ASN1_MAX_TL_SIZE];\n  unsigned int tl_len, der_len, str_len;\n  const unsigned char *str;\n  unsigned char *b;\n  unsigned int i;\n\n  /* Dummy test */\n\n  for (i = 0; i < sizeof (tv) / sizeof (tv[0]); i++)\n    {\n      /* Encode */\n      tl_len = sizeof (tl);\n      ret = asn1_encode_simple_der (tv[i].etype, tv[i].str, tv[i].str_len,\n\t\t\t\t    tl, &tl_len);\n      if (ret != ASN1_SUCCESS)\n\t{\n\t  fprintf (stderr, \"Encoding error in %u: %s\\n\", i,\n\t\t   asn1_strerror (ret));\n\t  return 1;\n\t}\n      der_len = tl_len + tv[i].str_len;\n\n      if (der_len != tv[i].der_len || memcmp (tl, tv[i].der, tl_len) != 0)\n\t{\n\t  fprintf (stderr,\n\t\t   \"DER encoding differs in %u! (size: %u, expected: %u)\\n\",\n\t\t   i, der_len, tv[i].der_len);\n\t  return 1;\n\t}\n\n      /* decoding */\n      ret =\n\tasn1_decode_simple_der (tv[i].etype, tv[i].der, tv[i].der_len, &str,\n\t\t\t\t&str_len);\n      if (ret != ASN1_SUCCESS)\n\t{\n\t  fprintf (stderr, \"Decoding error in %u: %s\\n\", i,\n\t\t   asn1_strerror (ret));\n\t  return 1;\n\t}\n\n      if (str_len != tv[i].str_len || memcmp (str, tv[i].str, str_len) != 0)\n\t{\n\t  fprintf (stderr,\n\t\t   \"DER decoded data differ in %u! (size: %u, expected: %u)\\n\",\n\t\t   i, der_len, tv[i].str_len);\n\t  return 1;\n\t}\n    }\n\n  /* BER decoding */\n  for (i = 0; i < sizeof (ber) / sizeof (ber[0]); i++)\n    {\n      /* decoding */\n      ret =\n\tasn1_decode_simple_ber (ber[i].etype, ber[i].der, ber[i].der_len, &b,\n\t\t\t\t&str_len, NULL);\n      if (ret != ASN1_SUCCESS)\n\t{\n\t  fprintf (stderr, \"BER decoding error in %u: %s\\n\", i,\n\t\t   asn1_strerror (ret));\n\t  return 1;\n\t}\n\n      if (str_len != ber[i].str_len || memcmp (b, ber[i].str, str_len) != 0)\n\t{\n\t  fprintf (stderr,\n\t\t   \"BER decoded data differ in %u! (size: %u, expected: %u)\\n\",\n\t\t   i, str_len, ber[i].str_len);\n\t  return 1;\n\t}\n      free(b);\n    }\n\n\n  return 0;\n}",
      "lines": 81,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/tests/Test_tree.c": {
    "main": {
      "start_point": [
        459,
        0
      ],
      "end_point": [
        828,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int result;\n  asn1_node definitions = NULL;\n  asn1_node asn1_element = NULL;\n  char errorDescription[ASN1_MAX_ERROR_DESCRIPTION_SIZE];\n  FILE *out;\n  test_type *test;\n  int errorCounter = 0, testCounter = 0, der_len;\n  unsigned char value[1024], der[1024];\n  int valueLen, tag = 0, class = 0;\n  int k;\n  int start, end, verbose = 0;\n  const char *str_p = NULL;\n  const char *treefile = getenv (\"ASN1TREE\");\n\n  if (argc > 1)\n    verbose = 1;\n\n  if (!treefile)\n    treefile = \"Test_tree.asn\";\n\n  if (verbose != 0)\n    {\n      printf (\"\\n\\n/****************************************/\\n\");\n      printf (\"/*     Test sequence : Test_tree        */\\n\");\n      printf (\"/****************************************/\\n\\n\");\n      printf (\"ASN1TREE: %s\\n\", treefile);\n    }\n\n  /* Check version */\n  if (asn1_check_version (\"0.2.11\") == NULL)\n    printf (\"\\nLibrary version check ERROR:\\n actual version: %s\\n\\n\",\n\t    asn1_check_version (NULL));\n\n  if (1)\n    result = asn1_parser2tree (treefile, &definitions, errorDescription);\n  else\n    result =\n      asn1_array2tree (Test_tree_asn1_tab, &definitions, errorDescription);\n\n  if (result != ASN1_SUCCESS)\n    {\n      asn1_perror (result);\n      printf (\"ErrorDescription = %s\\n\\n\", errorDescription);\n      exit (1);\n    }\n\n  if (1)\n    out = stdout;\n  else\n    out = fopen (\"Test_tree.out\", \"w\");\n\n  if (out == NULL)\n    {\n      printf (\"Output file ERROR\\n\");\n      exit (1);\n    }\n\n  if (0)\n    {\n      asn1_print_structure (out, definitions, \"TEST_TREE\", ASN1_PRINT_ALL);\n      fprintf (out, \"\\n\");\n    }\n\n  test = test_array;\n\n  while (test->action != ACT_NULL)\n    {\n      testCounter++;\n\n      switch (test->action)\n\t{\n\tcase ACT_CREATE:\n\t  result =\n\t    asn1_create_element (definitions, test->par1, &asn1_element);\n\t  break;\n\tcase ACT_DELETE:\n\t  result = asn1_delete_structure (&asn1_element);\n\t  break;\n\tcase ACT_DELETE2:\n\t  result = asn1_delete_structure2 (&asn1_element, ASN1_DELETE_FLAG_ZEROIZE);\n\t  break;\n\tcase ACT_DELETE_ELEMENT:\n\t  result = asn1_delete_element (asn1_element, test->par1);\n\t  break;\n\tcase ACT_WRITE:\n\t  if ((test->par2) && (!strcmp (\"DER\", test->par2)))\n\t    result =\n\t      asn1_write_value (asn1_element, test->par1, der, der_len);\n\t  else\n\t    result =\n\t      asn1_write_value (asn1_element, test->par1, test->par2,\n\t\t\t\ttest->par3);\n\t  break;\n\tcase ACT_READ:\n\tcase ACT_READ_BIT:\n\t  valueLen = test->par3;\n\t  result =\n\t    asn1_read_value (asn1_element, test->par1, value, &valueLen);\n\t  break;\n\tcase ACT_READ_LENGTH:\n\t  valueLen = 0;\n\t  result =\n\t    asn1_read_value (asn1_element, test->par1, NULL, &valueLen);\n\t  break;\n\tcase ACT_READ_DEFINITIONS:\n\t  valueLen = 1024;\n\t  result =\n\t    asn1_read_value (definitions, test->par1, value, &valueLen);\n\t  break;\n\tcase ACT_READ_TAG_CLASS:\n\t  result = asn1_read_tag (asn1_element, test->par1, &tag, &class);\n\t  break;\n\tcase ACT_ENCODING:\n\t  der_len = test->par3;\n\t  result = asn1_der_coding (asn1_element, test->par1, der, &der_len,\n\t\t\t\t    errorDescription);\n\t  break;\n\tcase ACT_ENCODING_LENGTH:\n\t  der_len = 0;\n\t  result = asn1_der_coding (asn1_element, test->par1, NULL, &der_len,\n\t\t\t\t    errorDescription);\n\t  break;\n\tcase ACT_DECODING:\n\t  result = asn1_der_decoding (&asn1_element, der, der_len,\n\t\t\t\t      errorDescription);\n\t  break;\n\tcase ACT_DECODING_ELEMENT:\n\t  result =\n\t    asn1_der_decoding_element (&asn1_element, test->par1, der,\n\t\t\t\t       der_len, errorDescription);\n\t  break;\n\tcase ACT_DECODING_START_END:\n\t  result =\n\t    asn1_der_decoding_startEnd (asn1_element, der, der_len,\n\t\t\t\t\ttest->par1, &start, &end);\n\t  break;\n\tcase ACT_EXPAND_ANY:\n\t  result = asn1_expand_any_defined_by (definitions, &asn1_element);\n\t  break;\n\tcase ACT_EXPAND_OCTET:\n\t  result =\n\t    asn1_expand_octet_string (definitions, &asn1_element, test->par1,\n\t\t\t\t      test->par2);\n\t  break;\n\tcase ACT_OID_2_STRUCTURE:\n\t  str_p = asn1_find_structure_from_oid (definitions, test->par1);\n\t  break;\n\tcase ACT_VISIT:\n\t  if (verbose)\n\t    {\n\t      asn1_print_structure (out, asn1_element, test->par1,\n\t\t\t\t    test->par3);\n\t      fprintf (out, \"\\n\");\n\t    }\n\t  result = ASN1_SUCCESS;\n\t  break;\n\tcase ACT_PRINT_DER:\n\t  if (verbose)\n\t    {\n\t      printf (\"DER encoding len:%i\\n\", der_len);\n\t      printf (\"DER encoding: \");\n\t      for (k = 0; k < der_len; k++)\n\t\tprintf (\"%02x \", der[k]);\n\t      printf (\"\\n\\n\");\n\t    }\n\t  result = ASN1_SUCCESS;\n\t  break;\n\tcase ACT_SET_DER:\n\t  der_len = test->par3;\n\t  memcpy (der, test->par1, der_len);\n\t  result = ASN1_SUCCESS;\n\t  break;\n\tcase ACT_NUMBER_OF_ELEMENTS:\n\t  result =\n\t    asn1_number_of_elements (asn1_element, test->par1, &valueLen);\n\t  break;\n\tdefault:\n\t  break;\n\t}\n\n\n      switch (test->action)\n\t{\n\tcase ACT_CREATE:\n\tcase ACT_DELETE:\n\tcase ACT_DELETE_ELEMENT:\n\tcase ACT_WRITE:\n\tcase ACT_VISIT:\n\tcase ACT_ENCODING:\n\tcase ACT_DECODING:\n\tcase ACT_PRINT_DER:\n\tcase ACT_EXPAND_ANY:\n\tcase ACT_EXPAND_OCTET:\n\tcase ACT_SET_DER:\n\t  if (result != test->errorNumber)\n\t    {\n\t      errorCounter++;\n\t      printf (\"ERROR in %d:\\n\", test->line);\n\t      printf (\"  Action %d - %s - %s - %d\\n\", test->action,\n\t\t      test->par1, test->par2, test->par3);\n\t      printf (\"  Error expected: %s\\n\",\n\t\t      asn1_strerror (test->errorNumber));\n\t      printf (\"  Error detected: %s\\n\\n\", asn1_strerror (result));\n\t      error ();\n\t    }\n\t  break;\n\tcase ACT_DECODING_ELEMENT:\n\t  if (result != test->errorNumber)\n\t    {\n\t      errorCounter++;\n\t      printf (\"ERROR in %d:\\n\", test->line);\n\t      printf (\"  Action %d - %s - %s - %d\\n\", test->action,\n\t\t      test->par1, test->par2, test->par3);\n\t      printf (\"  Error expected: %s\\n\",\n\t\t      asn1_strerror (test->errorNumber));\n\t      printf (\"  Error detected: %s\\n\", asn1_strerror (result));\n\t      printf (\"  Error description : %s\\n\\n\", errorDescription);\n\t      error ();\n\t    }\n\t  break;\n\tcase ACT_NUMBER_OF_ELEMENTS:\n\tcase ACT_READ_LENGTH:\n\t  if ((result != test->errorNumber) || (valueLen != test->par3))\n\t    {\n\t      errorCounter++;\n\t      printf (\"ERROR in %d:\\n\", test->line);\n\t      printf (\"  Action %d - %s\\n\", test->action, test->par1);\n\t      printf (\"  Error expected: %s - %d\\n\",\n\t\t      asn1_strerror (test->errorNumber), test->par3);\n\t      printf (\"  Error detected: %s - %d\\n\\n\", asn1_strerror (result),\n\t\t      valueLen);\n\t      error ();\n\t    }\n\t  break;\n\tcase ACT_ENCODING_LENGTH:\n\t  if ((result != test->errorNumber) || (der_len != test->par3))\n\t    {\n\t      errorCounter++;\n\t      printf (\"ERROR in %d:\\n\", test->line);\n\t      printf (\"  Action %d - %s\\n\", test->action, test->par1);\n\t      printf (\"  Error expected: %s - %d\\n\",\n\t\t      asn1_strerror (test->errorNumber), test->par3);\n\t      printf (\"  Error detected: %s - %d\\n\\n\", asn1_strerror (result),\n\t\t      der_len);\n\t      error ();\n\t    }\n\t  break;\n\tcase ACT_OID_2_STRUCTURE:\n\t  if (((test->errorNumber != ASN1_SUCCESS) && (str_p != NULL)) ||\n\t      ((test->errorNumber == ASN1_SUCCESS) && (str_p == NULL)) ||\n\t      ((test->errorNumber == ASN1_SUCCESS)\n\t       && (strcmp (str_p, test->par2))))\n\t    {\n\t      errorCounter++;\n\t      printf (\"ERROR in %d:\\n\", test->line);\n\t      printf (\"  Action %d - %s\\n\", test->action, test->par1);\n\t      printf (\"  Error expected: %s - %s\\n\",\n\t\t      asn1_strerror (test->errorNumber), test->par2);\n\t      printf (\"  Value detected: %s\\n\\n\", str_p);\n\t      error ();\n\t    }\n\t  break;\n\tcase ACT_DECODING_START_END:\n\t  if ((result != test->errorNumber) ||\n\t      ((!strcmp (test->par2, \"START\")) && (start != test->par3)) ||\n\t      ((!strcmp (test->par2, \"END\")) && (end != test->par3)))\n\t    {\n\t      errorCounter++;\n\t      printf (\"ERROR in %d:\\n\", test->line);\n\t      printf (\"  Action %d - %s - %d\\n\", test->action, test->par1,\n\t\t      test->par3);\n\t      printf (\"  Error expected: %s - %s - %d\\n\",\n\t\t      asn1_strerror (test->errorNumber), test->par2,\n\t\t      test->par3);\n\t      printf (\"  Error detected: %s - %d - %d\\n\\n\",\n\t\t      asn1_strerror (result), start, end);\n\t      error ();\n\t    }\n\t  break;\n\n\tcase ACT_READ_TAG_CLASS:\n\t  if ((result != test->errorNumber) ||\n\t      ((!strcmp (test->par2, \"TAG\")) && (tag != test->par3)) ||\n\t      ((!strcmp (test->par2, \"CLASS\")) && (class != test->par3)))\n\t    {\n\t      errorCounter++;\n\t      printf (\"ERROR in %d:\\n\", test->line);\n\t      printf (\"  Action %d - %s - %d\\n\", test->action, test->par1,\n\t\t      test->par3);\n\t      printf (\"  Error expected: %s - %s - %d\\n\",\n\t\t      asn1_strerror (test->errorNumber), test->par2,\n\t\t      test->par3);\n\t      printf (\"  Error detected: %s - %d - %d\\n\\n\",\n\t\t      asn1_strerror (result), tag, class);\n\t      error ();\n\t    }\n\n\t  break;\n\n\tcase ACT_READ:\n\tcase ACT_READ_DEFINITIONS:\n\tcase ACT_READ_BIT:\n\t  if (test->action == ACT_READ_BIT)\n\t    {\n\t      if (valueLen % 8 == 0)\n\t\ttag = valueLen / 8;\n\t      else\n\t\ttag = (valueLen / 8) + 1;\n\t      if (test->par3 % 8 == 0)\n\t\tclass = test->par3 / 8;\n\t      else\n\t\tclass = (test->par3 / 8) + 1;\n\t    }\n\n\t  for (k = 0; k < class; k++)\n\t    if ((unsigned char) test->par2[k] != value[k])\n\t      {\n\t\tk = -1;\n\t\tbreak;\n\t      }\n\n\t  if ((result != test->errorNumber) ||\n\t      (valueLen != test->par3) || (k == -1))\n\t    {\n\t      errorCounter++;\n\t      printf (\"ERROR in %d:\\n\", test->line);\n\t      printf (\"  Action %d - %s\\n\", test->action, test->par1);\n\t      printf (\"  Error expected: %s - %d - \",\n\t\t      asn1_strerror (test->errorNumber), test->par3);\n\t      for (k = 0; k < test->par3; k++)\n\t\tprintf (\"%02x\", test->par2[k]);\n\t      printf (\"\\n  Error detected: %s - %d - \",\n\t\t      asn1_strerror (result), valueLen);\n\t      for (k = 0; k < valueLen; k++)\n\t\tprintf (\"%02x\", value[k]);\n\t      printf (\"\\n\\n\");\n\n\t      error ();\n\t    }\n\n\t  break;\n\tdefault:\n\t  break;\n\t}\n\n      test++;\n    }\n\n\n  if (verbose != 0)\n    {\n      printf (\"Total tests : %d\\n\", testCounter);\n      printf (\"Total errors: %d\\n\", errorCounter);\n    }\n\n  /* Clear the definition structures */\n  asn1_delete_structure (&definitions);\n\n\n  if (out != stdout)\n    fclose (out);\n\n  if (errorCounter > 0)\n    return 1;\n\n  exit (0);\n}",
      "lines": 370,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "libtasn1/libtasn1-4.13/tests/Test_tree_asn1_tab.c": {},
  "libtasn1/libtasn1-4.13/windows/asn1-parser/config.h": {},
  "libtasn1/libtasn1-4.13/windows/gnulib/getopt.h": {}
}