{
  "cppi/cppi-1.18/build-aux/snippet/arg-nonnull.h": {},
  "cppi/cppi-1.18/build-aux/snippet/c++defs.h": {},
  "cppi/cppi-1.18/build-aux/snippet/warn-on-use.h": {},
  "cppi/cppi-1.18/build-aux/snippet/_Noreturn.h": {},
  "cppi/cppi-1.18/lib/c-ctype.c": {
    "c_isascii": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "bool\nc_isascii (int c)\n{\n  return (c >= 0x00 && c <= 0x7f);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    },
    "c_isalnum": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "bool\nc_isalnum (int c)\n{\n#if C_CTYPE_CONSECUTIVE_DIGITS \\\n    && C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n#if C_CTYPE_ASCII\n  return ((c >= '0' && c <= '9')\n          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z'));\n#else\n  return ((c >= '0' && c <= '9')\n          || (c >= 'A' && c <= 'Z')\n          || (c >= 'a' && c <= 'z'));\n#endif\n#else\n  switch (c)\n    {\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 34,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    },
    "c_isalpha": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "bool\nc_isalpha (int c)\n{\n#if C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n#if C_CTYPE_ASCII\n  return ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');\n#else\n  return ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'));\n#endif\n#else\n  switch (c)\n    {\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    },
    "c_isblank": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "bool\nc_isblank (int c)\n{\n  return (c == ' ' || c == '\\t');\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "c_iscntrl": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "bool\nc_iscntrl (int c)\n{\n#if C_CTYPE_ASCII\n  return ((c & ~0x1f) == 0 || c == 0x7f);\n#else\n  switch (c)\n    {\n    case ' ': case '!': case '\"': case '#': case '$': case '%':\n    case '&': case '\\'': case '(': case ')': case '*': case '+':\n    case ',': case '-': case '.': case '/':\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case ':': case ';': case '<': case '=': case '>': case '?':\n    case '@':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case '[': case '\\\\': case ']': case '^': case '_': case '`':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n    case '{': case '|': case '}': case '~':\n      return 0;\n    default:\n      return 1;\n    }\n#endif\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "c_isdigit": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "bool\nc_isdigit (int c)\n{\n#if C_CTYPE_CONSECUTIVE_DIGITS\n  return (c >= '0' && c <= '9');\n#else\n  switch (c)\n    {\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_islower": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "bool\nc_islower (int c)\n{\n#if C_CTYPE_CONSECUTIVE_LOWERCASE\n  return (c >= 'a' && c <= 'z');\n#else\n  switch (c)\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_isgraph": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "bool\nc_isgraph (int c)\n{\n#if C_CTYPE_ASCII\n  return (c >= '!' && c <= '~');\n#else\n  switch (c)\n    {\n    case '!': case '\"': case '#': case '$': case '%': case '&':\n    case '\\'': case '(': case ')': case '*': case '+': case ',':\n    case '-': case '.': case '/':\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case ':': case ';': case '<': case '=': case '>': case '?':\n    case '@':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case '[': case '\\\\': case ']': case '^': case '_': case '`':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n    case '{': case '|': case '}': case '~':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_isprint": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "bool\nc_isprint (int c)\n{\n#if C_CTYPE_ASCII\n  return (c >= ' ' && c <= '~');\n#else\n  switch (c)\n    {\n    case ' ': case '!': case '\"': case '#': case '$': case '%':\n    case '&': case '\\'': case '(': case ')': case '*': case '+':\n    case ',': case '-': case '.': case '/':\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case ':': case ';': case '<': case '=': case '>': case '?':\n    case '@':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case '[': case '\\\\': case ']': case '^': case '_': case '`':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n    case '{': case '|': case '}': case '~':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_ispunct": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "bool\nc_ispunct (int c)\n{\n#if C_CTYPE_ASCII\n  return ((c >= '!' && c <= '~')\n          && !((c >= '0' && c <= '9')\n               || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z')));\n#else\n  switch (c)\n    {\n    case '!': case '\"': case '#': case '$': case '%': case '&':\n    case '\\'': case '(': case ')': case '*': case '+': case ',':\n    case '-': case '.': case '/':\n    case ':': case ';': case '<': case '=': case '>': case '?':\n    case '@':\n    case '[': case '\\\\': case ']': case '^': case '_': case '`':\n    case '{': case '|': case '}': case '~':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 23,
      "depth": 16,
      "decorators": [
        "bool"
      ]
    },
    "c_isspace": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "bool\nc_isspace (int c)\n{\n  return (c == ' ' || c == '\\t'\n          || c == '\\n' || c == '\\v' || c == '\\f' || c == '\\r');\n}",
      "lines": 6,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "c_isupper": {
      "start_point": [
        271,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "bool\nc_isupper (int c)\n{\n#if C_CTYPE_CONSECUTIVE_UPPERCASE\n  return (c >= 'A' && c <= 'Z');\n#else\n  switch (c)\n    {\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_isxdigit": {
      "start_point": [
        291,
        0
      ],
      "end_point": [
        316,
        1
      ],
      "content": "bool\nc_isxdigit (int c)\n{\n#if C_CTYPE_CONSECUTIVE_DIGITS \\\n    && C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n#if C_CTYPE_ASCII\n  return ((c >= '0' && c <= '9')\n          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));\n#else\n  return ((c >= '0' && c <= '9')\n          || (c >= 'A' && c <= 'F')\n          || (c >= 'a' && c <= 'f'));\n#endif\n#else\n  switch (c)\n    {\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 26,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    },
    "c_tolower": {
      "start_point": [
        318,
        0
      ],
      "end_point": [
        355,
        1
      ],
      "content": "int\nc_tolower (int c)\n{\n#if C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);\n#else\n  switch (c)\n    {\n    case 'A': return 'a';\n    case 'B': return 'b';\n    case 'C': return 'c';\n    case 'D': return 'd';\n    case 'E': return 'e';\n    case 'F': return 'f';\n    case 'G': return 'g';\n    case 'H': return 'h';\n    case 'I': return 'i';\n    case 'J': return 'j';\n    case 'K': return 'k';\n    case 'L': return 'l';\n    case 'M': return 'm';\n    case 'N': return 'n';\n    case 'O': return 'o';\n    case 'P': return 'p';\n    case 'Q': return 'q';\n    case 'R': return 'r';\n    case 'S': return 's';\n    case 'T': return 't';\n    case 'U': return 'u';\n    case 'V': return 'v';\n    case 'W': return 'w';\n    case 'X': return 'x';\n    case 'Y': return 'y';\n    case 'Z': return 'z';\n    default: return c;\n    }\n#endif\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "c_toupper": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        394,
        1
      ],
      "content": "int\nc_toupper (int c)\n{\n#if C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n  return (c >= 'a' && c <= 'z' ? c - 'a' + 'A' : c);\n#else\n  switch (c)\n    {\n    case 'a': return 'A';\n    case 'b': return 'B';\n    case 'c': return 'C';\n    case 'd': return 'D';\n    case 'e': return 'E';\n    case 'f': return 'F';\n    case 'g': return 'G';\n    case 'h': return 'H';\n    case 'i': return 'I';\n    case 'j': return 'J';\n    case 'k': return 'K';\n    case 'l': return 'L';\n    case 'm': return 'M';\n    case 'n': return 'N';\n    case 'o': return 'O';\n    case 'p': return 'P';\n    case 'q': return 'Q';\n    case 'r': return 'R';\n    case 's': return 'S';\n    case 't': return 'T';\n    case 'u': return 'U';\n    case 'v': return 'V';\n    case 'w': return 'W';\n    case 'x': return 'X';\n    case 'y': return 'Y';\n    case 'z': return 'Z';\n    default: return c;\n    }\n#endif\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "cppi/cppi-1.18/lib/c-ctype.h": {},
  "cppi/cppi-1.18/lib/c-strcase.h": {},
  "cppi/cppi-1.18/lib/c-strcasecmp.c": {
    "c_strcasecmp": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nc_strcasecmp (const char *s1, const char *s2)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2)\n    return 0;\n\n  do\n    {\n      c1 = c_tolower (*p1);\n      c2 = c_tolower (*p2);\n\n      if (c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "cppi/cppi-1.18/lib/c-strcaseeq.h": {
    "strcaseeq9": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "static inline int\nstrcaseeq9 (const char *s1, const char *s2)\n{\n  return c_strcasecmp (s1 + 9, s2 + 9) == 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq8": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static inline int\nstrcaseeq8 (const char *s1, const char *s2, char s28)\n{\n  if (CASEEQ (s1[8], s28))\n    {\n      if (s28 == 0)\n        return 1;\n      else\n        return strcaseeq9 (s1, s2);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq7": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "static inline int\nstrcaseeq7 (const char *s1, const char *s2, char s27, char s28)\n{\n  if (CASEEQ (s1[7], s27))\n    {\n      if (s27 == 0)\n        return 1;\n      else\n        return strcaseeq8 (s1, s2, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq6": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static inline int\nstrcaseeq6 (const char *s1, const char *s2, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[6], s26))\n    {\n      if (s26 == 0)\n        return 1;\n      else\n        return strcaseeq7 (s1, s2, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq5": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static inline int\nstrcaseeq5 (const char *s1, const char *s2, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[5], s25))\n    {\n      if (s25 == 0)\n        return 1;\n      else\n        return strcaseeq6 (s1, s2, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq4": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "static inline int\nstrcaseeq4 (const char *s1, const char *s2, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[4], s24))\n    {\n      if (s24 == 0)\n        return 1;\n      else\n        return strcaseeq5 (s1, s2, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq3": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "static inline int\nstrcaseeq3 (const char *s1, const char *s2, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[3], s23))\n    {\n      if (s23 == 0)\n        return 1;\n      else\n        return strcaseeq4 (s1, s2, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq2": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "static inline int\nstrcaseeq2 (const char *s1, const char *s2, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[2], s22))\n    {\n      if (s22 == 0)\n        return 1;\n      else\n        return strcaseeq3 (s1, s2, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq1": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "static inline int\nstrcaseeq1 (const char *s1, const char *s2, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[1], s21))\n    {\n      if (s21 == 0)\n        return 1;\n      else\n        return strcaseeq2 (s1, s2, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq0": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "static inline int\nstrcaseeq0 (const char *s1, const char *s2, char s20, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[0], s20))\n    {\n      if (s20 == 0)\n        return 1;\n      else\n        return strcaseeq1 (s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "cppi/cppi-1.18/lib/c-strncasecmp.c": {
    "c_strncasecmp": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nc_strncasecmp (const char *s1, const char *s2, size_t n)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2 || n == 0)\n    return 0;\n\n  do\n    {\n      c1 = c_tolower (*p1);\n      c2 = c_tolower (*p2);\n\n      if (--n == 0 || c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "cppi/cppi-1.18/lib/calloc.c": {
    "rpl_calloc": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "void *\nrpl_calloc (size_t n, size_t s)\n{\n  void *result;\n\n#if NEED_CALLOC_GNU\n  if (n == 0 || s == 0)\n    {\n      n = 1;\n      s = 1;\n    }\n  else\n    {\n      /* Defend against buggy calloc implementations that mishandle\n         size_t overflow.  */\n      size_t bytes = n * s;\n      if (bytes / s != n)\n        {\n          errno = ENOMEM;\n          return NULL;\n        }\n    }\n#endif\n\n  result = calloc (n, s);\n\n#if !HAVE_CALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "void",
        "*\nrpl_calloc (size_t n, size_t s)",
        "*"
      ]
    }
  },
  "cppi/cppi-1.18/lib/close-stream.c": {
    "close_stream": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nclose_stream (FILE *stream)\n{\n  const bool some_pending = (__fpending (stream) != 0);\n  const bool prev_fail = (ferror (stream) != 0);\n  const bool fclose_fail = (fclose (stream) != 0);\n\n  /* Return an error indication if there was a previous failure or if\n     fclose failed, with one exception: ignore an fclose failure if\n     there was no previous error, no data remains to be flushed, and\n     fclose failed with EBADF.  That can happen when a program like cp\n     is invoked like this 'cp a b >&-' (i.e., with standard output\n     closed) and doesn't generate any output (hence no previous error\n     and nothing to be flushed).  */\n\n  if (prev_fail || (fclose_fail && (some_pending || errno != EBADF)))\n    {\n      if (! fclose_fail)\n        errno = 0;\n      return EOF;\n    }\n\n  return 0;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "cppi/cppi-1.18/lib/close-stream.h": {},
  "cppi/cppi-1.18/lib/closeout.c": {
    "close_stdout_set_file_name": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "void\nclose_stdout_set_file_name (const char *file)\n{\n  file_name = file;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "close_stdout_set_ignore_EPIPE": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "void\nclose_stdout_set_ignore_EPIPE (bool ignore)\n{\n  ignore_EPIPE = ignore;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "close_stdout": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "void\nclose_stdout (void)\n{\n  if (close_stream (stdout) != 0\n      && !(ignore_EPIPE && errno == EPIPE))\n    {\n      char const *write_error = _(\"write error\");\n      if (file_name)\n        error (0, errno, \"%s: %s\", quotearg_colon (file_name),\n               write_error);\n      else\n        error (0, errno, \"%s\", write_error);\n\n      _exit (exit_failure);\n    }\n\n   if (close_stream (stderr) != 0)\n     _exit (exit_failure);\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "cppi/cppi-1.18/lib/closeout.h": {},
  "cppi/cppi-1.18/lib/errno.in.h": {},
  "cppi/cppi-1.18/lib/error.c": {
    "is_open": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "static int\nis_open (int fd)\n{\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows: The initial state of unassigned standard file\n     descriptors is that they are open but point to an INVALID_HANDLE_VALUE.\n     There is no fcntl, and the gnulib replacement fcntl does not support\n     F_GETFL.  */\n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n# else\n#  ifndef F_GETFL\n#   error Please port fcntl to your platform\n#  endif\n  return 0 <= fcntl (fd, F_GETFL);\n# endif\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "flush_stdout": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "static void\nflush_stdout (void)\n{\n#if !_LIBC\n  int stdout_fd;\n\n# if GNULIB_FREOPEN_SAFER\n  /* Use of gnulib's freopen-safer module normally ensures that\n       fileno (stdout) == 1\n     whenever stdout is open.  */\n  stdout_fd = STDOUT_FILENO;\n# else\n  /* POSIX states that fileno (stdout) after fclose is unspecified.  But in\n     practice it is not a problem, because stdout is statically allocated and\n     the fd of a FILE stream is stored as a field in its allocated memory.  */\n  stdout_fd = fileno (stdout);\n# endif\n  /* POSIX states that fflush (stdout) after fclose is unspecified; it\n     is safe in glibc, but not on all other platforms.  fflush (NULL)\n     is always defined, but too draconian.  */\n  if (0 <= stdout_fd && is_open (stdout_fd))\n#endif\n    fflush (stdout);\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_errno_message": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "static void\nprint_errno_message (int errnum)\n{\n  char const *s;\n\n#if defined HAVE_STRERROR_R || _LIBC\n  char errbuf[1024];\n# if STRERROR_R_CHAR_P || _LIBC\n  s = __strerror_r (errnum, errbuf, sizeof errbuf);\n# else\n  if (__strerror_r (errnum, errbuf, sizeof errbuf) == 0)\n    s = errbuf;\n  else\n    s = 0;\n# endif\n#else\n  s = strerror (errnum);\n#endif\n\n#if !_LIBC\n  if (! s)\n    s = _(\"Unknown system error\");\n#endif\n\n#if _LIBC\n  __fxprintf (NULL, \": %s\", s);\n#else\n  fprintf (stderr, \": %s\", s);\n#endif\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "error_tail": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        281,
        1
      ],
      "content": "static void\nerror_tail (int status, int errnum, const char *message, va_list args)\n{\n#if _LIBC\n  if (_IO_fwide (stderr, 0) > 0)\n    {\n# define ALLOCA_LIMIT 2000\n      size_t len = strlen (message) + 1;\n      wchar_t *wmessage = NULL;\n      mbstate_t st;\n      size_t res;\n      const char *tmp;\n      bool use_malloc = false;\n\n      while (1)\n        {\n          if (__libc_use_alloca (len * sizeof (wchar_t)))\n            wmessage = (wchar_t *) alloca (len * sizeof (wchar_t));\n          else\n            {\n              if (!use_malloc)\n                wmessage = NULL;\n\n              wchar_t *p = (wchar_t *) realloc (wmessage,\n                                                len * sizeof (wchar_t));\n              if (p == NULL)\n                {\n                  free (wmessage);\n                  fputws_unlocked (L\"out of memory\\n\", stderr);\n                  return;\n                }\n              wmessage = p;\n              use_malloc = true;\n            }\n\n          memset (&st, '\\0', sizeof (st));\n          tmp = message;\n\n          res = mbsrtowcs (wmessage, &tmp, len, &st);\n          if (res != len)\n            break;\n\n          if (__builtin_expect (len >= SIZE_MAX / 2, 0))\n            {\n              /* This really should not happen if everything is fine.  */\n              res = (size_t) -1;\n              break;\n            }\n\n          len *= 2;\n        }\n\n      if (res == (size_t) -1)\n        {\n          /* The string cannot be converted.  */\n          if (use_malloc)\n            {\n              free (wmessage);\n              use_malloc = false;\n            }\n          wmessage = (wchar_t *) L\"???\";\n        }\n\n      __vfwprintf (stderr, wmessage, args);\n\n      if (use_malloc)\n        free (wmessage);\n    }\n  else\n#endif\n    vfprintf (stderr, message, args);\n  va_end (args);\n\n  ++error_message_count;\n  if (errnum)\n    print_errno_message (errnum);\n#if _LIBC\n  __fxprintf (NULL, \"\\n\");\n#else\n  putc ('\\n', stderr);\n#endif\n  fflush (stderr);\n  if (status)\n    exit (status);\n}",
      "lines": 85,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "error": {
      "start_point": [
        288,
        0
      ],
      "end_point": [
        325,
        1
      ],
      "content": "void\nerror (int status, int errnum, const char *message, ...)\n{\n  va_list args;\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s: \", program_name);\n#else\n      fprintf (stderr, \"%s: \", program_name);\n#endif\n    }\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "error_at_line": {
      "start_point": [
        331,
        0
      ],
      "end_point": [
        392,
        1
      ],
      "content": "void\nerror_at_line (int status, int errnum, const char *file_name,\n               unsigned int line_number, const char *message, ...)\n{\n  va_list args;\n\n  if (error_one_per_line)\n    {\n      static const char *old_file_name;\n      static unsigned int old_line_number;\n\n      if (old_line_number == line_number\n          && (file_name == old_file_name\n              || strcmp (old_file_name, file_name) == 0))\n        /* Simply return and print nothing.  */\n        return;\n\n      old_file_name = file_name;\n      old_line_number = line_number;\n    }\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s:\", program_name);\n#else\n      fprintf (stderr, \"%s:\", program_name);\n#endif\n    }\n\n#if _LIBC\n  __fxprintf (NULL, file_name != NULL ? \"%s:%d: \" : \" \",\n              file_name, line_number);\n#else\n  fprintf (stderr, file_name != NULL ? \"%s:%d: \" : \" \",\n           file_name, line_number);\n#endif\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "cppi/cppi-1.18/lib/error.h": {},
  "cppi/cppi-1.18/lib/exitfail.c": {},
  "cppi/cppi-1.18/lib/exitfail.h": {},
  "cppi/cppi-1.18/lib/fpending.c": {
    "__fpending": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "size_t\n__fpending (FILE *fp)\n{\n  return PENDING_OUTPUT_N_BYTES;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    }
  },
  "cppi/cppi-1.18/lib/fpending.h": {},
  "cppi/cppi-1.18/lib/getopt.c": {
    "exchange": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "static void\nexchange (char **argv, struct _getopt_data *d)\n{\n  int bottom = d->__first_nonopt;\n  int middle = d->__last_nonopt;\n  int top = d->optind;\n  char *tem;\n\n  /* Exchange the shorter segment with the far end of the longer segment.\n     That puts the shorter segment into the right place.\n     It leaves the longer segment in the right place overall,\n     but it consists of two parts that need to be swapped next.  */\n\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n  /* First make sure the handling of the '__getopt_nonoption_flags'\n     string can work normally.  Our top argument must be in the range\n     of the string.  */\n  if (d->__nonoption_flags_len > 0 && top >= d->__nonoption_flags_max_len)\n    {\n      /* We must extend the array.  The user plays games with us and\n         presents new arguments.  */\n      char *new_str = malloc (top + 1);\n      if (new_str == NULL)\n        d->__nonoption_flags_len = d->__nonoption_flags_max_len = 0;\n      else\n        {\n          memset (__mempcpy (new_str, __getopt_nonoption_flags,\n                             d->__nonoption_flags_max_len),\n                  '\\0', top + 1 - d->__nonoption_flags_max_len);\n          d->__nonoption_flags_max_len = top + 1;\n          __getopt_nonoption_flags = new_str;\n        }\n    }\n#endif\n\n  while (top > middle && middle > bottom)\n    {\n      if (top - middle > middle - bottom)\n        {\n          /* Bottom segment is the short one.  */\n          int len = middle - bottom;\n          register int i;\n\n          /* Swap it with the top part of the top segment.  */\n          for (i = 0; i < len; i++)\n            {\n              tem = argv[bottom + i];\n              argv[bottom + i] = argv[top - (middle - bottom) + i];\n              argv[top - (middle - bottom) + i] = tem;\n              SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);\n            }\n          /* Exclude the moved bottom segment from further swapping.  */\n          top -= len;\n        }\n      else\n        {\n          /* Top segment is the short one.  */\n          int len = top - middle;\n          register int i;\n\n          /* Swap it with the bottom part of the bottom segment.  */\n          for (i = 0; i < len; i++)\n            {\n              tem = argv[bottom + i];\n              argv[bottom + i] = argv[middle + i];\n              argv[middle + i] = tem;\n              SWAP_FLAGS (bottom + i, middle + i);\n            }\n          /* Exclude the moved top segment from further swapping.  */\n          bottom += len;\n        }\n    }\n\n  /* Update records for the slots the non-options now occupy.  */\n\n  d->__first_nonopt += (d->optind - d->__last_nonopt);\n  d->__last_nonopt = d->optind;\n}",
      "lines": 78,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_getopt_initialize": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "static const char *\n_getopt_initialize (int argc _GL_UNUSED,\n                    char **argv _GL_UNUSED, const char *optstring,\n                    struct _getopt_data *d, int posixly_correct)\n{\n  /* Start processing options with ARGV-element 1 (since ARGV-element 0\n     is the program name); the sequence of previously skipped\n     non-option ARGV-elements is empty.  */\n\n  d->__first_nonopt = d->__last_nonopt = d->optind;\n\n  d->__nextchar = NULL;\n\n  d->__posixly_correct = posixly_correct || !!getenv (\"POSIXLY_CORRECT\");\n\n  /* Determine how to handle the ordering of options and nonoptions.  */\n\n  if (optstring[0] == '-')\n    {\n      d->__ordering = RETURN_IN_ORDER;\n      ++optstring;\n    }\n  else if (optstring[0] == '+')\n    {\n      d->__ordering = REQUIRE_ORDER;\n      ++optstring;\n    }\n  else if (d->__posixly_correct)\n    d->__ordering = REQUIRE_ORDER;\n  else\n    d->__ordering = PERMUTE;\n\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n  if (!d->__posixly_correct\n      && argc == __libc_argc && argv == __libc_argv)\n    {\n      if (d->__nonoption_flags_max_len == 0)\n        {\n          if (__getopt_nonoption_flags == NULL\n              || __getopt_nonoption_flags[0] == '\\0')\n            d->__nonoption_flags_max_len = -1;\n          else\n            {\n              const char *orig_str = __getopt_nonoption_flags;\n              int len = d->__nonoption_flags_max_len = strlen (orig_str);\n              if (d->__nonoption_flags_max_len < argc)\n                d->__nonoption_flags_max_len = argc;\n              __getopt_nonoption_flags =\n                (char *) malloc (d->__nonoption_flags_max_len);\n              if (__getopt_nonoption_flags == NULL)\n                d->__nonoption_flags_max_len = -1;\n              else\n                memset (__mempcpy (__getopt_nonoption_flags, orig_str, len),\n                        '\\0', d->__nonoption_flags_max_len - len);\n            }\n        }\n      d->__nonoption_flags_len = d->__nonoption_flags_max_len;\n    }\n  else\n    d->__nonoption_flags_len = 0;\n#endif\n\n  return optstring;\n}",
      "lines": 64,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\n_getopt_initialize (int argc _GL_UNUSED,\n                    char **argv _GL_UNUSED, const char *optstring,\n                    struct _getopt_data *d, int posixly_correct)",
        "*"
      ]
    },
    "_getopt_internal_r": {
      "start_point": [
        344,
        0
      ],
      "end_point": [
        1124,
        1
      ],
      "content": "int\n_getopt_internal_r (int argc, char **argv, const char *optstring,\n                    const struct option *longopts, int *longind,\n                    int long_only, struct _getopt_data *d, int posixly_correct)\n{\n  int print_errors = d->opterr;\n\n  if (argc < 1)\n    return -1;\n\n  d->optarg = NULL;\n\n  if (d->optind == 0 || !d->__initialized)\n    {\n      if (d->optind == 0)\n        d->optind = 1;  /* Don't scan ARGV[0], the program name.  */\n      optstring = _getopt_initialize (argc, argv, optstring, d,\n                                      posixly_correct);\n      d->__initialized = 1;\n    }\n  else if (optstring[0] == '-' || optstring[0] == '+')\n    optstring++;\n  if (optstring[0] == ':')\n    print_errors = 0;\n\n  /* Test whether ARGV[optind] points to a non-option argument.\n     Either it does not have option syntax, or there is an environment flag\n     from the shell indicating it is not an option.  The later information\n     is only used when the used in the GNU libc.  */\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n# define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0' \\\n                      || (d->optind < d->__nonoption_flags_len                \\\n                          && __getopt_nonoption_flags[d->optind] == '1'))\n#else\n# define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0')\n#endif\n\n  if (d->__nextchar == NULL || *d->__nextchar == '\\0')\n    {\n      /* Advance to the next ARGV-element.  */\n\n      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been\n         moved back by the user (who may also have changed the arguments).  */\n      if (d->__last_nonopt > d->optind)\n        d->__last_nonopt = d->optind;\n      if (d->__first_nonopt > d->optind)\n        d->__first_nonopt = d->optind;\n\n      if (d->__ordering == PERMUTE)\n        {\n          /* If we have just processed some options following some non-options,\n             exchange them so that the options come first.  */\n\n          if (d->__first_nonopt != d->__last_nonopt\n              && d->__last_nonopt != d->optind)\n            exchange ((char **) argv, d);\n          else if (d->__last_nonopt != d->optind)\n            d->__first_nonopt = d->optind;\n\n          /* Skip any additional non-options\n             and extend the range of non-options previously skipped.  */\n\n          while (d->optind < argc && NONOPTION_P)\n            d->optind++;\n          d->__last_nonopt = d->optind;\n        }\n\n      /* The special ARGV-element '--' means premature end of options.\n         Skip it like a null option,\n         then exchange with previous non-options as if it were an option,\n         then skip everything else like a non-option.  */\n\n      if (d->optind != argc && !strcmp (argv[d->optind], \"--\"))\n        {\n          d->optind++;\n\n          if (d->__first_nonopt != d->__last_nonopt\n              && d->__last_nonopt != d->optind)\n            exchange ((char **) argv, d);\n          else if (d->__first_nonopt == d->__last_nonopt)\n            d->__first_nonopt = d->optind;\n          d->__last_nonopt = argc;\n\n          d->optind = argc;\n        }\n\n      /* If we have done all the ARGV-elements, stop the scan\n         and back over any non-options that we skipped and permuted.  */\n\n      if (d->optind == argc)\n        {\n          /* Set the next-arg-index to point at the non-options\n             that we previously skipped, so the caller will digest them.  */\n          if (d->__first_nonopt != d->__last_nonopt)\n            d->optind = d->__first_nonopt;\n          return -1;\n        }\n\n      /* If we have come to a non-option and did not permute it,\n         either stop the scan or describe it to the caller and pass it by.  */\n\n      if (NONOPTION_P)\n        {\n          if (d->__ordering == REQUIRE_ORDER)\n            return -1;\n          d->optarg = argv[d->optind++];\n          return 1;\n        }\n\n      /* We have found another option-ARGV-element.\n         Skip the initial punctuation.  */\n\n      d->__nextchar = (argv[d->optind] + 1\n                  + (longopts != NULL && argv[d->optind][1] == '-'));\n    }\n\n  /* Decode the current option-ARGV-element.  */\n\n  /* Check whether the ARGV-element is a long option.\n\n     If long_only and the ARGV-element has the form \"-f\", where f is\n     a valid short option, don't consider it an abbreviated form of\n     a long option that starts with f.  Otherwise there would be no\n     way to give the -f short option.\n\n     On the other hand, if there's a long option \"fubar\" and\n     the ARGV-element is \"-fu\", do consider that an abbreviation of\n     the long option, just like \"--fu\", and not \"-f\" with arg \"u\".\n\n     This distinction seems to be the most useful approach.  */\n\n  if (longopts != NULL\n      && (argv[d->optind][1] == '-'\n          || (long_only && (argv[d->optind][2]\n                            || !strchr (optstring, argv[d->optind][1])))))\n    {\n      char *nameend;\n      unsigned int namelen;\n      const struct option *p;\n      const struct option *pfound = NULL;\n      struct option_list\n      {\n        const struct option *p;\n        struct option_list *next;\n      } *ambig_list = NULL;\n      int exact = 0;\n      int indfound = -1;\n      int option_index;\n\n      for (nameend = d->__nextchar; *nameend && *nameend != '='; nameend++)\n        /* Do nothing.  */ ;\n      namelen = nameend - d->__nextchar;\n\n      /* Test all long options for either exact match\n         or abbreviated matches.  */\n      for (p = longopts, option_index = 0; p->name; p++, option_index++)\n        if (!strncmp (p->name, d->__nextchar, namelen))\n          {\n            if (namelen == (unsigned int) strlen (p->name))\n              {\n                /* Exact match found.  */\n                pfound = p;\n                indfound = option_index;\n                exact = 1;\n                break;\n              }\n            else if (pfound == NULL)\n              {\n                /* First nonexact match found.  */\n                pfound = p;\n                indfound = option_index;\n              }\n            else if (long_only\n                     || pfound->has_arg != p->has_arg\n                     || pfound->flag != p->flag\n                     || pfound->val != p->val)\n              {\n                /* Second or later nonexact match found.  */\n                struct option_list *newp = malloc (sizeof (*newp));\n                newp->p = p;\n                newp->next = ambig_list;\n                ambig_list = newp;\n              }\n          }\n\n      if (ambig_list != NULL && !exact)\n        {\n          if (print_errors)\n            {\n              struct option_list first;\n              first.p = pfound;\n              first.next = ambig_list;\n              ambig_list = &first;\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf = NULL;\n              size_t buflen = 0;\n\n              FILE *fp = open_memstream (&buf, &buflen);\n              if (fp != NULL)\n                {\n                  fprintf (fp,\n                           _(\"%s: option '%s' is ambiguous; possibilities:\"),\n                           argv[0], argv[d->optind]);\n\n                  do\n                    {\n                      fprintf (fp, \" '--%s'\", ambig_list->p->name);\n                      ambig_list = ambig_list->next;\n                    }\n                  while (ambig_list != NULL);\n\n                  fputc_unlocked ('\\n', fp);\n\n                  if (__builtin_expect (fclose (fp) != EOF, 1))\n                    {\n                      _IO_flockfile (stderr);\n\n                      int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                      ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                      __fxprintf (NULL, \"%s\", buf);\n\n                      ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                      _IO_funlockfile (stderr);\n\n                      free (buf);\n                    }\n                }\n#else\n              fprintf (stderr,\n                       _(\"%s: option '%s' is ambiguous; possibilities:\"),\n                       argv[0], argv[d->optind]);\n              do\n                {\n                  fprintf (stderr, \" '--%s'\", ambig_list->p->name);\n                  ambig_list = ambig_list->next;\n                }\n              while (ambig_list != NULL);\n\n              fputc ('\\n', stderr);\n#endif\n            }\n          d->__nextchar += strlen (d->__nextchar);\n          d->optind++;\n          d->optopt = 0;\n          return '?';\n        }\n\n      while (ambig_list != NULL)\n        {\n          struct option_list *pn = ambig_list->next;\n          free (ambig_list);\n          ambig_list = pn;\n        }\n\n      if (pfound != NULL)\n        {\n          option_index = indfound;\n          d->optind++;\n          if (*nameend)\n            {\n              /* Don't test has_arg with >, because some C compilers don't\n                 allow it to be used on enums.  */\n              if (pfound->has_arg)\n                d->optarg = nameend + 1;\n              else\n                {\n                  if (print_errors)\n                    {\n#if defined _LIBC && defined USE_IN_LIBIO\n                      char *buf;\n                      int n;\n#endif\n\n                      if (argv[d->optind - 1][1] == '-')\n                        {\n                          /* --option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                          n = __asprintf (&buf, _(\"\\\n%s: option '--%s' doesn't allow an argument\\n\"),\n                                          argv[0], pfound->name);\n#else\n                          fprintf (stderr, _(\"\\\n%s: option '--%s' doesn't allow an argument\\n\"),\n                                   argv[0], pfound->name);\n#endif\n                        }\n                      else\n                        {\n                          /* +option or -option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                          n = __asprintf (&buf, _(\"\\\n%s: option '%c%s' doesn't allow an argument\\n\"),\n                                          argv[0], argv[d->optind - 1][0],\n                                          pfound->name);\n#else\n                          fprintf (stderr, _(\"\\\n%s: option '%c%s' doesn't allow an argument\\n\"),\n                                   argv[0], argv[d->optind - 1][0],\n                                   pfound->name);\n#endif\n                        }\n\n#if defined _LIBC && defined USE_IN_LIBIO\n                      if (n >= 0)\n                        {\n                          _IO_flockfile (stderr);\n\n                          int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                          ((_IO_FILE *) stderr)->_flags2\n                            |= _IO_FLAGS2_NOTCANCEL;\n\n                          __fxprintf (NULL, \"%s\", buf);\n\n                          ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                          _IO_funlockfile (stderr);\n\n                          free (buf);\n                        }\n#endif\n                    }\n\n                  d->__nextchar += strlen (d->__nextchar);\n\n                  d->optopt = pfound->val;\n                  return '?';\n                }\n            }\n          else if (pfound->has_arg == 1)\n            {\n              if (d->optind < argc)\n                d->optarg = argv[d->optind++];\n              else\n                {\n                  if (print_errors)\n                    {\n#if defined _LIBC && defined USE_IN_LIBIO\n                      char *buf;\n\n                      if (__asprintf (&buf, _(\"\\\n%s: option '--%s' requires an argument\\n\"),\n                                      argv[0], pfound->name) >= 0)\n                        {\n                          _IO_flockfile (stderr);\n\n                          int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                          ((_IO_FILE *) stderr)->_flags2\n                            |= _IO_FLAGS2_NOTCANCEL;\n\n                          __fxprintf (NULL, \"%s\", buf);\n\n                          ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                          _IO_funlockfile (stderr);\n\n                          free (buf);\n                        }\n#else\n                      fprintf (stderr,\n                               _(\"%s: option '--%s' requires an argument\\n\"),\n                               argv[0], pfound->name);\n#endif\n                    }\n                  d->__nextchar += strlen (d->__nextchar);\n                  d->optopt = pfound->val;\n                  return optstring[0] == ':' ? ':' : '?';\n                }\n            }\n          d->__nextchar += strlen (d->__nextchar);\n          if (longind != NULL)\n            *longind = option_index;\n          if (pfound->flag)\n            {\n              *(pfound->flag) = pfound->val;\n              return 0;\n            }\n          return pfound->val;\n        }\n\n      /* Can't find it as a long option.  If this is not getopt_long_only,\n         or the option starts with '--' or is not a valid short\n         option, then it's an error.\n         Otherwise interpret it as a short option.  */\n      if (!long_only || argv[d->optind][1] == '-'\n          || strchr (optstring, *d->__nextchar) == NULL)\n        {\n          if (print_errors)\n            {\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf;\n              int n;\n#endif\n\n              if (argv[d->optind][1] == '-')\n                {\n                  /* --option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                  n = __asprintf (&buf, _(\"%s: unrecognized option '--%s'\\n\"),\n                                  argv[0], d->__nextchar);\n#else\n                  fprintf (stderr, _(\"%s: unrecognized option '--%s'\\n\"),\n                           argv[0], d->__nextchar);\n#endif\n                }\n              else\n                {\n                  /* +option or -option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                  n = __asprintf (&buf, _(\"%s: unrecognized option '%c%s'\\n\"),\n                                  argv[0], argv[d->optind][0], d->__nextchar);\n#else\n                  fprintf (stderr, _(\"%s: unrecognized option '%c%s'\\n\"),\n                           argv[0], argv[d->optind][0], d->__nextchar);\n#endif\n                }\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              if (n >= 0)\n                {\n                  _IO_flockfile (stderr);\n\n                  int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                  ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                  __fxprintf (NULL, \"%s\", buf);\n\n                  ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                  _IO_funlockfile (stderr);\n\n                  free (buf);\n                }\n#endif\n            }\n          d->__nextchar = (char *) \"\";\n          d->optind++;\n          d->optopt = 0;\n          return '?';\n        }\n    }\n\n  /* Look at and handle the next short option-character.  */\n\n  {\n    char c = *d->__nextchar++;\n    const char *temp = strchr (optstring, c);\n\n    /* Increment 'optind' when we start to process its last character.  */\n    if (*d->__nextchar == '\\0')\n      ++d->optind;\n\n    if (temp == NULL || c == ':' || c == ';')\n      {\n        if (print_errors)\n          {\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf;\n              int n;\n#endif\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              n = __asprintf (&buf, _(\"%s: invalid option -- '%c'\\n\"),\n                              argv[0], c);\n#else\n              fprintf (stderr, _(\"%s: invalid option -- '%c'\\n\"), argv[0], c);\n#endif\n\n#if defined _LIBC && defined USE_IN_LIBIO\n            if (n >= 0)\n              {\n                _IO_flockfile (stderr);\n\n                int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                __fxprintf (NULL, \"%s\", buf);\n\n                ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                _IO_funlockfile (stderr);\n\n                free (buf);\n              }\n#endif\n          }\n        d->optopt = c;\n        return '?';\n      }\n    /* Convenience. Treat POSIX -W foo same as long option --foo */\n    if (temp[0] == 'W' && temp[1] == ';')\n      {\n        char *nameend;\n        const struct option *p;\n        const struct option *pfound = NULL;\n        int exact = 0;\n        int ambig = 0;\n        int indfound = 0;\n        int option_index;\n\n        if (longopts == NULL)\n          goto no_longs;\n\n        /* This is an option that requires an argument.  */\n        if (*d->__nextchar != '\\0')\n          {\n            d->optarg = d->__nextchar;\n            /* If we end this ARGV-element by taking the rest as an arg,\n               we must advance to the next element now.  */\n            d->optind++;\n          }\n        else if (d->optind == argc)\n          {\n            if (print_errors)\n              {\n#if defined _LIBC && defined USE_IN_LIBIO\n                char *buf;\n\n                if (__asprintf (&buf,\n                                _(\"%s: option requires an argument -- '%c'\\n\"),\n                                argv[0], c) >= 0)\n                  {\n                    _IO_flockfile (stderr);\n\n                    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                    __fxprintf (NULL, \"%s\", buf);\n\n                    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                    _IO_funlockfile (stderr);\n\n                    free (buf);\n                  }\n#else\n                fprintf (stderr,\n                         _(\"%s: option requires an argument -- '%c'\\n\"),\n                         argv[0], c);\n#endif\n              }\n            d->optopt = c;\n            if (optstring[0] == ':')\n              c = ':';\n            else\n              c = '?';\n            return c;\n          }\n        else\n          /* We already incremented 'd->optind' once;\n             increment it again when taking next ARGV-elt as argument.  */\n          d->optarg = argv[d->optind++];\n\n        /* optarg is now the argument, see if it's in the\n           table of longopts.  */\n\n        for (d->__nextchar = nameend = d->optarg; *nameend && *nameend != '=';\n             nameend++)\n          /* Do nothing.  */ ;\n\n        /* Test all long options for either exact match\n           or abbreviated matches.  */\n        for (p = longopts, option_index = 0; p->name; p++, option_index++)\n          if (!strncmp (p->name, d->__nextchar, nameend - d->__nextchar))\n            {\n              if ((unsigned int) (nameend - d->__nextchar) == strlen (p->name))\n                {\n                  /* Exact match found.  */\n                  pfound = p;\n                  indfound = option_index;\n                  exact = 1;\n                  break;\n                }\n              else if (pfound == NULL)\n                {\n                  /* First nonexact match found.  */\n                  pfound = p;\n                  indfound = option_index;\n                }\n              else if (long_only\n                       || pfound->has_arg != p->has_arg\n                       || pfound->flag != p->flag\n                       || pfound->val != p->val)\n                /* Second or later nonexact match found.  */\n                ambig = 1;\n            }\n        if (ambig && !exact)\n          {\n            if (print_errors)\n              {\n#if defined _LIBC && defined USE_IN_LIBIO\n                char *buf;\n\n                if (__asprintf (&buf, _(\"%s: option '-W %s' is ambiguous\\n\"),\n                                argv[0], d->optarg) >= 0)\n                  {\n                    _IO_flockfile (stderr);\n\n                    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                    __fxprintf (NULL, \"%s\", buf);\n\n                    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                    _IO_funlockfile (stderr);\n\n                    free (buf);\n                  }\n#else\n                fprintf (stderr, _(\"%s: option '-W %s' is ambiguous\\n\"),\n                         argv[0], d->optarg);\n#endif\n              }\n            d->__nextchar += strlen (d->__nextchar);\n            d->optind++;\n            return '?';\n          }\n        if (pfound != NULL)\n          {\n            option_index = indfound;\n            if (*nameend)\n              {\n                /* Don't test has_arg with >, because some C compilers don't\n                   allow it to be used on enums.  */\n                if (pfound->has_arg)\n                  d->optarg = nameend + 1;\n                else\n                  {\n                    if (print_errors)\n                      {\n#if defined _LIBC && defined USE_IN_LIBIO\n                        char *buf;\n\n                        if (__asprintf (&buf, _(\"\\\n%s: option '-W %s' doesn't allow an argument\\n\"),\n                                        argv[0], pfound->name) >= 0)\n                          {\n                            _IO_flockfile (stderr);\n\n                            int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                            ((_IO_FILE *) stderr)->_flags2\n                              |= _IO_FLAGS2_NOTCANCEL;\n\n                            __fxprintf (NULL, \"%s\", buf);\n\n                            ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                            _IO_funlockfile (stderr);\n\n                            free (buf);\n                          }\n#else\n                        fprintf (stderr, _(\"\\\n%s: option '-W %s' doesn't allow an argument\\n\"),\n                                 argv[0], pfound->name);\n#endif\n                      }\n\n                    d->__nextchar += strlen (d->__nextchar);\n                    return '?';\n                  }\n              }\n            else if (pfound->has_arg == 1)\n              {\n                if (d->optind < argc)\n                  d->optarg = argv[d->optind++];\n                else\n                  {\n                    if (print_errors)\n                      {\n#if defined _LIBC && defined USE_IN_LIBIO\n                        char *buf;\n\n                        if (__asprintf (&buf, _(\"\\\n%s: option '-W %s' requires an argument\\n\"),\n                                        argv[0], pfound->name) >= 0)\n                          {\n                            _IO_flockfile (stderr);\n\n                            int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                            ((_IO_FILE *) stderr)->_flags2\n                              |= _IO_FLAGS2_NOTCANCEL;\n\n                            __fxprintf (NULL, \"%s\", buf);\n\n                            ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                            _IO_funlockfile (stderr);\n\n                            free (buf);\n                          }\n#else\n                        fprintf (stderr, _(\"\\\n%s: option '-W %s' requires an argument\\n\"),\n                                 argv[0], pfound->name);\n#endif\n                      }\n                    d->__nextchar += strlen (d->__nextchar);\n                    return optstring[0] == ':' ? ':' : '?';\n                  }\n              }\n            else\n              d->optarg = NULL;\n            d->__nextchar += strlen (d->__nextchar);\n            if (longind != NULL)\n              *longind = option_index;\n            if (pfound->flag)\n              {\n                *(pfound->flag) = pfound->val;\n                return 0;\n              }\n            return pfound->val;\n          }\n\n      no_longs:\n        d->__nextchar = NULL;\n        return 'W';   /* Let the application handle it.   */\n      }\n    if (temp[1] == ':')\n      {\n        if (temp[2] == ':')\n          {\n            /* This is an option that accepts an argument optionally.  */\n            if (*d->__nextchar != '\\0')\n              {\n                d->optarg = d->__nextchar;\n                d->optind++;\n              }\n            else\n              d->optarg = NULL;\n            d->__nextchar = NULL;\n          }\n        else\n          {\n            /* This is an option that requires an argument.  */\n            if (*d->__nextchar != '\\0')\n              {\n                d->optarg = d->__nextchar;\n                /* If we end this ARGV-element by taking the rest as an arg,\n                   we must advance to the next element now.  */\n                d->optind++;\n              }\n            else if (d->optind == argc)\n              {\n                if (print_errors)\n                  {\n#if defined _LIBC && defined USE_IN_LIBIO\n                    char *buf;\n\n                    if (__asprintf (&buf, _(\"\\\n%s: option requires an argument -- '%c'\\n\"),\n                                    argv[0], c) >= 0)\n                      {\n                        _IO_flockfile (stderr);\n\n                        int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                        ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                        __fxprintf (NULL, \"%s\", buf);\n\n                        ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                        _IO_funlockfile (stderr);\n\n                        free (buf);\n                      }\n#else\n                    fprintf (stderr,\n                             _(\"%s: option requires an argument -- '%c'\\n\"),\n                             argv[0], c);\n#endif\n                  }\n                d->optopt = c;\n                if (optstring[0] == ':')\n                  c = ':';\n                else\n                  c = '?';\n              }\n            else\n              /* We already incremented 'optind' once;\n                 increment it again when taking next ARGV-elt as argument.  */\n              d->optarg = argv[d->optind++];\n            d->__nextchar = NULL;\n          }\n      }\n    return c;\n  }\n}",
      "lines": 781,
      "depth": 25,
      "decorators": [
        "int"
      ]
    },
    "_getopt_internal": {
      "start_point": [
        1126,
        0
      ],
      "end_point": [
        1145,
        1
      ],
      "content": "int\n_getopt_internal (int argc, char **argv, const char *optstring,\n                  const struct option *longopts, int *longind, int long_only,\n                  int posixly_correct)\n{\n  int result;\n\n  getopt_data.optind = optind;\n  getopt_data.opterr = opterr;\n\n  result = _getopt_internal_r (argc, argv, optstring, longopts,\n                               longind, long_only, &getopt_data,\n                               posixly_correct);\n\n  optind = getopt_data.optind;\n  optarg = getopt_data.optarg;\n  optopt = getopt_data.optopt;\n\n  return result;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "getopt": {
      "start_point": [
        1155,
        0
      ],
      "end_point": [
        1162,
        1
      ],
      "content": "int\ngetopt (int argc, char *const *argv, const char *optstring)\n{\n  return _getopt_internal (argc, (char **) argv, optstring,\n                           (const struct option *) 0,\n                           (int *) 0,\n                           0, POSIXLY_CORRECT);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "__posix_getopt": {
      "start_point": [
        1165,
        0
      ],
      "end_point": [
        1172,
        1
      ],
      "content": "int\n__posix_getopt (int argc, char *const *argv, const char *optstring)\n{\n  return _getopt_internal (argc, argv, optstring,\n                           (const struct option *) 0,\n                           (int *) 0,\n                           0, 1);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        1181,
        0
      ],
      "end_point": [
        1242,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n\n      c = getopt (argc, argv, \"abc:d:0123456789\");\n      if (c == -1)\n        break;\n\n      switch (c)\n        {\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (digit_optind != 0 && digit_optind != this_option_optind)\n            printf (\"digits occur in two different argv-elements.\\n\");\n          digit_optind = this_option_optind;\n          printf (\"option %c\\n\", c);\n          break;\n\n        case 'a':\n          printf (\"option a\\n\");\n          break;\n\n        case 'b':\n          printf (\"option b\\n\");\n          break;\n\n        case 'c':\n          printf (\"option c with value '%s'\\n\", optarg);\n          break;\n\n        case '?':\n          break;\n\n        default:\n          printf (\"?? getopt returned character code 0%o ??\\n\", c);\n        }\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n        printf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "cppi/cppi-1.18/lib/getopt.in.h": {},
  "cppi/cppi-1.18/lib/getopt1.c": {
    "getopt_long": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "int\ngetopt_long (int argc, char *__getopt_argv_const *argv, const char *options,\n             const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n                           opt_index, 0, 0);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_r": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\n_getopt_long_r (int argc, char **argv, const char *options,\n                const struct option *long_options, int *opt_index,\n                struct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n                             0, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "getopt_long_only": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\ngetopt_long_only (int argc, char *__getopt_argv_const *argv,\n                  const char *options,\n                  const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n                           opt_index, 1, 0);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_only_r": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "int\n_getopt_long_only_r (int argc, char **argv, const char *options,\n                     const struct option *long_options, int *opt_index,\n                     struct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n                             1, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n      int option_index = 0;\n      static const struct option long_options[] =\n      {\n        {\"add\", 1, 0, 0},\n        {\"append\", 0, 0, 0},\n        {\"delete\", 1, 0, 0},\n        {\"verbose\", 0, 0, 0},\n        {\"create\", 0, 0, 0},\n        {\"file\", 1, 0, 0},\n        {0, 0, 0, 0}\n      };\n\n      c = getopt_long (argc, argv, \"abc:d:0123456789\",\n                       long_options, &option_index);\n      if (c == -1)\n        break;\n\n      switch (c)\n        {\n        case 0:\n          printf (\"option %s\", long_options[option_index].name);\n          if (optarg)\n            printf (\" with arg %s\", optarg);\n          printf (\"\\n\");\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (digit_optind != 0 && digit_optind != this_option_optind)\n            printf (\"digits occur in two different argv-elements.\\n\");\n          digit_optind = this_option_optind;\n          printf (\"option %c\\n\", c);\n          break;\n\n        case 'a':\n          printf (\"option a\\n\");\n          break;\n\n        case 'b':\n          printf (\"option b\\n\");\n          break;\n\n        case 'c':\n          printf (\"option c with value '%s'\\n\", optarg);\n          break;\n\n        case 'd':\n          printf (\"option d with value '%s'\\n\", optarg);\n          break;\n\n        case '?':\n          break;\n\n        default:\n          printf (\"?? getopt returned character code 0%o ??\\n\", c);\n        }\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n        printf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 85,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "cppi/cppi-1.18/lib/getopt_int.h": {},
  "cppi/cppi-1.18/lib/gettext.h": {
    "pgettext_aux": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static const char *\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)\n{\n  const char *translation = dcgettext (domain, msg_ctxt_id, category);\n  if (translation == msg_ctxt_id)\n    return msgid;\n  else\n    return translation;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)",
        "*"
      ]
    },
    "npgettext_aux": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "static const char *\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)\n{\n  const char *translation =\n    dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n  if (translation == msg_ctxt_id || translation == msgid_plural)\n    return (n == 1 ? msgid : msgid_plural);\n  else\n    return translation;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)",
        "*"
      ]
    },
    "dcpgettext_expr": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "static const char *\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcgettext (domain, msg_ctxt_id, category);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (translation != msg_ctxt_id)\n        return translation;\n    }\n  return msgid;\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)",
        "*"
      ]
    },
    "dcnpgettext_expr": {
      "start_point": [
        253,
        0
      ],
      "end_point": [
        285,
        1
      ],
      "content": "static const char *\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (!(translation == msg_ctxt_id || translation == msgid_plural))\n        return translation;\n    }\n  return (n == 1 ? msgid : msgid_plural);\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)",
        "*"
      ]
    }
  },
  "cppi/cppi-1.18/lib/intprops.h": {},
  "cppi/cppi-1.18/lib/inttypes.in.h": {},
  "cppi/cppi-1.18/lib/localcharset.c": {
    "get_charset_aliases": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        344,
        1
      ],
      "content": "static const char *\nget_charset_aliases (void)\n{\n  const char *cp;\n\n  cp = charset_aliases;\n  if (cp == NULL)\n    {\n#if !(defined DARWIN7 || defined VMS || defined WINDOWS_NATIVE || defined __CYGWIN__)\n      const char *dir;\n      const char *base = \"charset.alias\";\n      char *file_name;\n\n      /* Make it possible to override the charset.alias location.  This is\n         necessary for running the testsuite before \"make install\".  */\n      dir = getenv (\"CHARSETALIASDIR\");\n      if (dir == NULL || dir[0] == '\\0')\n        dir = relocate (LIBDIR);\n\n      /* Concatenate dir and base into freshly allocated file_name.  */\n      {\n        size_t dir_len = strlen (dir);\n        size_t base_len = strlen (base);\n        int add_slash = (dir_len > 0 && !ISSLASH (dir[dir_len - 1]));\n        file_name = (char *) malloc (dir_len + add_slash + base_len + 1);\n        if (file_name != NULL)\n          {\n            memcpy (file_name, dir, dir_len);\n            if (add_slash)\n              file_name[dir_len] = DIRECTORY_SEPARATOR;\n            memcpy (file_name + dir_len + add_slash, base, base_len + 1);\n          }\n      }\n\n      if (file_name == NULL)\n        /* Out of memory.  Treat the file as empty.  */\n        cp = \"\";\n      else\n        {\n          int fd;\n\n          /* Open the file.  Reject symbolic links on platforms that support\n             O_NOFOLLOW.  This is a security feature.  Without it, an attacker\n             could retrieve parts of the contents (namely, the tail of the\n             first line that starts with \"* \") of an arbitrary file by placing\n             a symbolic link to that file under the name \"charset.alias\" in\n             some writable directory and defining the environment variable\n             CHARSETALIASDIR to point to that directory.  */\n          fd = open (file_name,\n                     O_RDONLY | (HAVE_WORKING_O_NOFOLLOW ? O_NOFOLLOW : 0));\n          if (fd < 0)\n            /* File not found.  Treat it as empty.  */\n            cp = \"\";\n          else\n            {\n              FILE *fp;\n\n              fp = fdopen (fd, \"r\");\n              if (fp == NULL)\n                {\n                  /* Out of memory.  Treat the file as empty.  */\n                  close (fd);\n                  cp = \"\";\n                }\n              else\n                {\n                  /* Parse the file's contents.  */\n                  char *res_ptr = NULL;\n                  size_t res_size = 0;\n\n                  for (;;)\n                    {\n                      int c;\n                      char buf1[50+1];\n                      char buf2[50+1];\n                      size_t l1, l2;\n                      char *old_res_ptr;\n\n                      c = getc (fp);\n                      if (c == EOF)\n                        break;\n                      if (c == '\\n' || c == ' ' || c == '\\t')\n                        continue;\n                      if (c == '#')\n                        {\n                          /* Skip comment, to end of line.  */\n                          do\n                            c = getc (fp);\n                          while (!(c == EOF || c == '\\n'));\n                          if (c == EOF)\n                            break;\n                          continue;\n                        }\n                      ungetc (c, fp);\n                      if (fscanf (fp, \"%50s %50s\", buf1, buf2) < 2)\n                        break;\n                      l1 = strlen (buf1);\n                      l2 = strlen (buf2);\n                      old_res_ptr = res_ptr;\n                      if (res_size == 0)\n                        {\n                          res_size = l1 + 1 + l2 + 1;\n                          res_ptr = (char *) malloc (res_size + 1);\n                        }\n                      else\n                        {\n                          res_size += l1 + 1 + l2 + 1;\n                          res_ptr = (char *) realloc (res_ptr, res_size + 1);\n                        }\n                      if (res_ptr == NULL)\n                        {\n                          /* Out of memory. */\n                          res_size = 0;\n                          free (old_res_ptr);\n                          break;\n                        }\n                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);\n                      strcpy (res_ptr + res_size - (l2 + 1), buf2);\n                    }\n                  fclose (fp);\n                  if (res_size == 0)\n                    cp = \"\";\n                  else\n                    {\n                      *(res_ptr + res_size) = '\\0';\n                      cp = res_ptr;\n                    }\n                }\n            }\n\n          free (file_name);\n        }\n\n#else\n\n# if defined DARWIN7\n      /* To avoid the trouble of installing a file that is shared by many\n         GNU packages -- many packaging systems have problems with this --,\n         simply inline the aliases here.  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-4\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"ISO8859-13\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"ISO8859-15\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"KOI8-R\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"KOI8-U\" \"\\0\" \"KOI8-U\" \"\\0\"\n           \"CP866\" \"\\0\" \"CP866\" \"\\0\"\n           \"CP949\" \"\\0\" \"CP949\" \"\\0\"\n           \"CP1131\" \"\\0\" \"CP1131\" \"\\0\"\n           \"CP1251\" \"\\0\" \"CP1251\" \"\\0\"\n           \"eucCN\" \"\\0\" \"GB2312\" \"\\0\"\n           \"GB2312\" \"\\0\" \"GB2312\" \"\\0\"\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"eucKR\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"Big5\" \"\\0\" \"BIG5\" \"\\0\"\n           \"Big5HKSCS\" \"\\0\" \"BIG5-HKSCS\" \"\\0\"\n           \"GBK\" \"\\0\" \"GBK\" \"\\0\"\n           \"GB18030\" \"\\0\" \"GB18030\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"ARMSCII-8\" \"\\0\" \"ARMSCII-8\" \"\\0\"\n           \"PT154\" \"\\0\" \"PT154\" \"\\0\"\n         /*\"ISCII-DEV\" \"\\0\" \"?\" \"\\0\"*/\n           \"*\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n\n# if defined VMS\n      /* To avoid the troubles of an extra file charset.alias_vms in the\n         sources of many GNU packages, simply inline the aliases here.  */\n      /* The list of encodings is taken from the OpenVMS 7.3-1 documentation\n         \"Compaq C Run-Time Library Reference Manual for OpenVMS systems\"\n         section 10.7 \"Handling Different Character Sets\".  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-8\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           /* Japanese */\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"DECKANJI\" \"\\0\" \"DEC-KANJI\" \"\\0\"\n           \"SDECKANJI\" \"\\0\" \"EUC-JP\" \"\\0\"\n           /* Chinese */\n           \"eucTW\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"DECHANYU\" \"\\0\" \"DEC-HANYU\" \"\\0\"\n           \"DECHANZI\" \"\\0\" \"GB2312\" \"\\0\"\n           /* Korean */\n           \"DECKOREAN\" \"\\0\" \"EUC-KR\" \"\\0\";\n# endif\n\n# if defined WINDOWS_NATIVE || defined __CYGWIN__\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      cp = \"CP936\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP1361\" \"\\0\" \"JOHAB\" \"\\0\"\n           \"CP20127\" \"\\0\" \"ASCII\" \"\\0\"\n           \"CP20866\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP20936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP21866\" \"\\0\" \"KOI8-RU\" \"\\0\"\n           \"CP28591\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP28592\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP28593\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP28594\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP28595\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP28596\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP28597\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP28598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP28599\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP28605\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP38598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP51932\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP51936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP51949\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP51950\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP54936\" \"\\0\" \"GB18030\" \"\\0\"\n           \"CP65001\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n#endif\n\n      charset_aliases = cp;\n    }\n\n  return cp;\n}",
      "lines": 229,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nget_charset_aliases (void)",
        "*"
      ]
    },
    "locale_charset": {
      "start_point": [
        355,
        0
      ],
      "end_point": [
        552,
        1
      ],
      "content": "const char *\nlocale_charset (void)\n{\n  const char *codeset;\n  const char *aliases;\n\n#if !(defined WINDOWS_NATIVE || defined OS2)\n\n# if HAVE_LANGINFO_CODESET\n\n  /* Most systems support nl_langinfo (CODESET) nowadays.  */\n  codeset = nl_langinfo (CODESET);\n\n#  ifdef __CYGWIN__\n  /* Cygwin < 1.7 does not have locales.  nl_langinfo (CODESET) always\n     returns \"US-ASCII\".  Return the suffix of the locale name from the\n     environment variables (if present) or the codepage as a number.  */\n  if (codeset != NULL && strcmp (codeset, \"US-ASCII\") == 0)\n    {\n      const char *locale;\n      static char buf[2 + 10 + 1];\n\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n      if (locale != NULL && locale[0] != '\\0')\n        {\n          /* If the locale name contains an encoding after the dot, return\n             it.  */\n          const char *dot = strchr (locale, '.');\n\n          if (dot != NULL)\n            {\n              const char *modifier;\n\n              dot++;\n              /* Look for the possible @... trailer and remove it, if any.  */\n              modifier = strchr (dot, '@');\n              if (modifier == NULL)\n                return dot;\n              if (modifier - dot < sizeof (buf))\n                {\n                  memcpy (buf, dot, modifier - dot);\n                  buf [modifier - dot] = '\\0';\n                  return buf;\n                }\n            }\n        }\n\n      /* The Windows API has a function returning the locale's codepage as a\n         number: GetACP().  This encoding is used by Cygwin, unless the user\n         has set the environment variable CYGWIN=codepage:oem (which very few\n         people do).\n         Output directed to console windows needs to be converted (to\n         GetOEMCP() if the console is using a raster font, or to\n         GetConsoleOutputCP() if it is using a TrueType font).  Cygwin does\n         this conversion transparently (see winsup/cygwin/fhandler_console.cc),\n         converting to GetConsoleOutputCP().  This leads to correct results,\n         except when SetConsoleOutputCP has been called and a raster font is\n         in use.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n      codeset = buf;\n    }\n#  endif\n\n# else\n\n  /* On old systems which lack it, use setlocale or getenv.  */\n  const char *locale = NULL;\n\n  /* But most old systems don't have a complete set of locales.  Some\n     (like SunOS 4 or DJGPP) have only the C locale.  Therefore we don't\n     use setlocale here; it would return \"C\" when it doesn't support the\n     locale name the user has set.  */\n#  if 0\n  locale = setlocale (LC_CTYPE, NULL);\n#  endif\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n    }\n\n  /* On some old systems, one used to set locale = \"iso8859_1\". On others,\n     you set it to \"language_COUNTRY.charset\". In any case, we resolve it\n     through the charset.alias file.  */\n  codeset = locale;\n\n# endif\n\n#elif defined WINDOWS_NATIVE\n\n  static char buf[2 + 10 + 1];\n\n  /* The Windows API has a function returning the locale's codepage as a\n     number: GetACP().\n     When the output goes to a console window, it needs to be provided in\n     GetOEMCP() encoding if the console is using a raster font, or in\n     GetConsoleOutputCP() encoding if it is using a TrueType font.\n     But in GUI programs and for output sent to files and pipes, GetACP()\n     encoding is the best bet.  */\n  sprintf (buf, \"CP%u\", GetACP ());\n  codeset = buf;\n\n#elif defined OS2\n\n  const char *locale;\n  static char buf[2 + 10 + 1];\n  ULONG cp[3];\n  ULONG cplen;\n\n  /* Allow user to override the codeset, as set in the operating system,\n     with standard language environment variables.  */\n  locale = getenv (\"LC_ALL\");\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_CTYPE\");\n      if (locale == NULL || locale[0] == '\\0')\n        locale = getenv (\"LANG\");\n    }\n  if (locale != NULL && locale[0] != '\\0')\n    {\n      /* If the locale name contains an encoding after the dot, return it.  */\n      const char *dot = strchr (locale, '.');\n\n      if (dot != NULL)\n        {\n          const char *modifier;\n\n          dot++;\n          /* Look for the possible @... trailer and remove it, if any.  */\n          modifier = strchr (dot, '@');\n          if (modifier == NULL)\n            return dot;\n          if (modifier - dot < sizeof (buf))\n            {\n              memcpy (buf, dot, modifier - dot);\n              buf [modifier - dot] = '\\0';\n              return buf;\n            }\n        }\n\n      /* Resolve through the charset.alias file.  */\n      codeset = locale;\n    }\n  else\n    {\n      /* OS/2 has a function returning the locale's codepage as a number.  */\n      if (DosQueryCp (sizeof (cp), cp, &cplen))\n        codeset = \"\";\n      else\n        {\n          sprintf (buf, \"CP%u\", cp[0]);\n          codeset = buf;\n        }\n    }\n\n#endif\n\n  if (codeset == NULL)\n    /* The canonical name cannot be determined.  */\n    codeset = \"\";\n\n  /* Resolve alias. */\n  for (aliases = get_charset_aliases ();\n       *aliases != '\\0';\n       aliases += strlen (aliases) + 1, aliases += strlen (aliases) + 1)\n    if (strcmp (codeset, aliases) == 0\n        || (aliases[0] == '*' && aliases[1] == '\\0'))\n      {\n        codeset = aliases + strlen (aliases) + 1;\n        break;\n      }\n\n  /* Don't return an empty string.  GNU libc and GNU libiconv interpret\n     the empty string as denoting \"the locale's character encoding\",\n     thus GNU libiconv would call this function a second time.  */\n  if (codeset[0] == '\\0')\n    codeset = \"ASCII\";\n\n#ifdef DARWIN7\n  /* Mac OS X sets MB_CUR_MAX to 1 when LC_ALL=C, and \"UTF-8\"\n     (the default codeset) does not work when MB_CUR_MAX is 1.  */\n  if (strcmp (codeset, \"UTF-8\") == 0 && MB_CUR_MAX <= 1)\n    codeset = \"ASCII\";\n#endif\n\n  return codeset;\n}",
      "lines": 198,
      "depth": 18,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nlocale_charset (void)",
        "*"
      ]
    }
  },
  "cppi/cppi-1.18/lib/localcharset.h": {},
  "cppi/cppi-1.18/lib/malloc.c": {
    "rpl_malloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void *\nrpl_malloc (size_t n)\n{\n  void *result;\n\n#if NEED_MALLOC_GNU\n  if (n == 0)\n    n = 1;\n#endif\n\n  result = malloc (n);\n\n#if !HAVE_MALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "void",
        "*\nrpl_malloc (size_t n)",
        "*"
      ]
    }
  },
  "cppi/cppi-1.18/lib/mbrtowc.c": {
    "mbrtowc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "size_t\nmbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n  char *pstate = (char *)ps;\n\n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n\n  if (n == 0)\n    return (size_t)(-2);\n\n  /* Here n > 0.  */\n\n  if (pstate == NULL)\n    pstate = internal_state;\n\n  {\n    size_t nstate = pstate[0];\n    char buf[4];\n    const char *p;\n    size_t m;\n\n    switch (nstate)\n      {\n      case 0:\n        p = s;\n        m = n;\n        break;\n      case 3:\n        buf[2] = pstate[3];\n        /*FALLTHROUGH*/\n      case 2:\n        buf[1] = pstate[2];\n        /*FALLTHROUGH*/\n      case 1:\n        buf[0] = pstate[1];\n        p = buf;\n        m = nstate;\n        buf[m++] = s[0];\n        if (n >= 2 && m < 4)\n          {\n            buf[m++] = s[1];\n            if (n >= 3 && m < 4)\n              buf[m++] = s[2];\n          }\n        break;\n      default:\n        errno = EINVAL;\n        return (size_t)(-1);\n      }\n\n    /* Here m > 0.  */\n\n# if __GLIBC__ || defined __UCLIBC__\n    /* Work around bug <http://sourceware.org/bugzilla/show_bug.cgi?id=9674> */\n    mbtowc (NULL, NULL, 0);\n# endif\n    {\n      int res = mbtowc (pwc, p, m);\n\n      if (res >= 0)\n        {\n          if (pwc != NULL && ((*pwc == 0) != (res == 0)))\n            abort ();\n          if (nstate >= (res > 0 ? res : 1))\n            abort ();\n          res -= nstate;\n          pstate[0] = 0;\n          return res;\n        }\n\n      /* mbtowc does not distinguish between invalid and incomplete multibyte\n         sequences.  But mbrtowc needs to make this distinction.\n         There are two possible approaches:\n           - Use iconv() and its return value.\n           - Use built-in knowledge about the possible encodings.\n         Given the low quality of implementation of iconv() on the systems that\n         lack mbrtowc(), we use the second approach.\n         The possible encodings are:\n           - 8-bit encodings,\n           - EUC-JP, EUC-KR, GB2312, EUC-TW, BIG5, GB18030, SJIS,\n           - UTF-8.\n         Use specialized code for each.  */\n      if (m >= 4 || m >= MB_CUR_MAX)\n        goto invalid;\n      /* Here MB_CUR_MAX > 1 and 0 < m < 4.  */\n      {\n        const char *encoding = locale_charset ();\n\n        if (STREQ_OPT (encoding, \"UTF-8\", 'U', 'T', 'F', '-', '8', 0, 0, 0, 0))\n          {\n            /* Cf. unistr/u8-mblen.c.  */\n            unsigned char c = (unsigned char) p[0];\n\n            if (c >= 0xc2)\n              {\n                if (c < 0xe0)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                  }\n                else if (c < 0xf0)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                    if (m == 2)\n                      {\n                        unsigned char c2 = (unsigned char) p[1];\n\n                        if ((c2 ^ 0x80) < 0x40\n                            && (c >= 0xe1 || c2 >= 0xa0)\n                            && (c != 0xed || c2 < 0xa0))\n                          goto incomplete;\n                      }\n                  }\n                else if (c <= 0xf4)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                    else /* m == 2 || m == 3 */\n                      {\n                        unsigned char c2 = (unsigned char) p[1];\n\n                        if ((c2 ^ 0x80) < 0x40\n                            && (c >= 0xf1 || c2 >= 0x90)\n                            && (c < 0xf4 || (c == 0xf4 && c2 < 0x90)))\n                          {\n                            if (m == 2)\n                              goto incomplete;\n                            else /* m == 3 */\n                              {\n                                unsigned char c3 = (unsigned char) p[2];\n\n                                if ((c3 ^ 0x80) < 0x40)\n                                  goto incomplete;\n                              }\n                          }\n                      }\n                  }\n              }\n            goto invalid;\n          }\n\n        /* As a reference for this code, you can use the GNU libiconv\n           implementation.  Look for uses of the RET_TOOFEW macro.  */\n\n        if (STREQ_OPT (encoding,\n                       \"EUC-JP\", 'E', 'U', 'C', '-', 'J', 'P', 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0xa1 && c < 0xff) || c == 0x8e || c == 0x8f)\n                  goto incomplete;\n              }\n            if (m == 2)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c == 0x8f)\n                  {\n                    unsigned char c2 = (unsigned char) p[1];\n\n                    if (c2 >= 0xa1 && c2 < 0xff)\n                      goto incomplete;\n                  }\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"EUC-KR\", 'E', 'U', 'C', '-', 'K', 'R', 0, 0, 0)\n            || STREQ_OPT (encoding,\n                          \"GB2312\", 'G', 'B', '2', '3', '1', '2', 0, 0, 0)\n            || STREQ_OPT (encoding,\n                          \"BIG5\", 'B', 'I', 'G', '5', 0, 0, 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c >= 0xa1 && c < 0xff)\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"EUC-TW\", 'E', 'U', 'C', '-', 'T', 'W', 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0xa1 && c < 0xff) || c == 0x8e)\n                  goto incomplete;\n              }\n            else /* m == 2 || m == 3 */\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c == 0x8e)\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"GB18030\", 'G', 'B', '1', '8', '0', '3', '0', 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0x90 && c <= 0xe3) || (c >= 0xf8 && c <= 0xfe))\n                  goto incomplete;\n              }\n            else /* m == 2 || m == 3 */\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c >= 0x90 && c <= 0xe3)\n                  {\n                    unsigned char c2 = (unsigned char) p[1];\n\n                    if (c2 >= 0x30 && c2 <= 0x39)\n                      {\n                        if (m == 2)\n                          goto incomplete;\n                        else /* m == 3 */\n                          {\n                            unsigned char c3 = (unsigned char) p[2];\n\n                            if (c3 >= 0x81 && c3 <= 0xfe)\n                              goto incomplete;\n                          }\n                      }\n                  }\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding, \"SJIS\", 'S', 'J', 'I', 'S', 0, 0, 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0x81 && c <= 0x9f) || (c >= 0xe0 && c <= 0xea)\n                    || (c >= 0xf0 && c <= 0xf9))\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n\n        /* An unknown multibyte encoding.  */\n        goto incomplete;\n      }\n\n     incomplete:\n      {\n        size_t k = nstate;\n        /* Here 0 <= k < m < 4.  */\n        pstate[++k] = s[0];\n        if (k < m)\n          {\n            pstate[++k] = s[1];\n            if (k < m)\n              pstate[++k] = s[2];\n          }\n        if (k != m)\n          abort ();\n      }\n      pstate[0] = m;\n      return (size_t)(-2);\n\n     invalid:\n      errno = EILSEQ;\n      /* The conversion state is undefined, says POSIX.  */\n      return (size_t)(-1);\n    }\n  }\n}",
      "lines": 284,
      "depth": 25,
      "decorators": [
        "size_t"
      ]
    },
    "rpl_mbrtowc": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        399,
        1
      ],
      "content": "size_t\nrpl_mbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n# if MBRTOWC_NULL_ARG2_BUG || MBRTOWC_RETVAL_BUG\n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n# endif\n\n# if MBRTOWC_RETVAL_BUG\n  {\n    static mbstate_t internal_state;\n\n    /* Override mbrtowc's internal state.  We cannot call mbsinit() on the\n       hidden internal state, but we can call it on our variable.  */\n    if (ps == NULL)\n      ps = &internal_state;\n\n    if (!mbsinit (ps))\n      {\n        /* Parse the rest of the multibyte character byte for byte.  */\n        size_t count = 0;\n        for (; n > 0; s++, n--)\n          {\n            wchar_t wc;\n            size_t ret = mbrtowc (&wc, s, 1, ps);\n\n            if (ret == (size_t)(-1))\n              return (size_t)(-1);\n            count++;\n            if (ret != (size_t)(-2))\n              {\n                /* The multibyte character has been completed.  */\n                if (pwc != NULL)\n                  *pwc = wc;\n                return (wc == 0 ? 0 : count);\n              }\n          }\n        return (size_t)(-2);\n      }\n  }\n# endif\n\n# if MBRTOWC_NUL_RETVAL_BUG\n  {\n    wchar_t wc;\n    size_t ret = mbrtowc (&wc, s, n, ps);\n\n    if (ret != (size_t)(-1) && ret != (size_t)(-2))\n      {\n        if (pwc != NULL)\n          *pwc = wc;\n        if (wc == 0)\n          ret = 0;\n      }\n    return ret;\n  }\n# else\n  {\n#   if MBRTOWC_NULL_ARG1_BUG\n    wchar_t dummy;\n\n    if (pwc == NULL)\n      pwc = &dummy;\n#   endif\n\n    return mbrtowc (pwc, s, n, ps);\n  }\n# endif\n}",
      "lines": 73,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    }
  },
  "cppi/cppi-1.18/lib/mbsinit.c": {
    "mbsinit": [
      {
        "start_point": [
          28,
          0
        ],
        "end_point": [
          32,
          1
        ],
        "content": "int\nmbsinit (const mbstate_t *ps)\n{\n  return ps == NULL || *ps == 0;\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          52,
          0
        ],
        "end_point": [
          58,
          1
        ],
        "content": "int\nmbsinit (const mbstate_t *ps)\n{\n  const char *pstate = (const char *)ps;\n\n  return pstate == NULL || pstate[0] == 0;\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "cppi/cppi-1.18/lib/msvc-inval.c": {
    "gl_msvc_invalid_parameter_handler": [
      {
        "start_point": [
          30,
          0
        ],
        "end_point": [
          37,
          1
        ],
        "content": "static void cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n}",
        "lines": 8,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "cdecl",
          "cdecl"
        ]
      },
      {
        "start_point": [
          47,
          0
        ],
        "end_point": [
          55,
          1
        ],
        "content": "static void cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 9,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "cdecl",
          "cdecl"
        ]
      },
      {
        "start_point": [
          96,
          0
        ],
        "end_point": [
          110,
          1
        ],
        "content": "static void cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  struct gl_msvc_inval_per_thread *current = gl_msvc_inval_current ();\n  if (current->restart_valid)\n    longjmp (current->restart, 1);\n  else\n    /* An invalid parameter notification from outside the gnulib code.\n       Give the caller a chance to intervene.  */\n    RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void",
          "cdecl",
          "cdecl"
        ]
      }
    ],
    "gl_msvc_inval_current": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "struct gl_msvc_inval_per_thread *\ngl_msvc_inval_current (void)\n{\n  if (!tls_initialized)\n    {\n      tls_index = TlsAlloc ();\n      tls_initialized = 1;\n    }\n  if (tls_index == TLS_OUT_OF_INDEXES)\n    /* TlsAlloc had failed.  */\n    return &not_per_thread;\n  else\n    {\n      struct gl_msvc_inval_per_thread *pointer =\n        (struct gl_msvc_inval_per_thread *) TlsGetValue (tls_index);\n      if (pointer == NULL)\n        {\n          /* First call.  Allocate a new 'struct gl_msvc_inval_per_thread'.  */\n          pointer =\n            (struct gl_msvc_inval_per_thread *)\n            malloc (sizeof (struct gl_msvc_inval_per_thread));\n          if (pointer == NULL)\n            /* Could not allocate memory.  Use the global storage.  */\n            pointer = &not_per_thread;\n          TlsSetValue (tls_index, pointer);\n        }\n      return pointer;\n    }\n}",
      "lines": 29,
      "depth": 15,
      "decorators": [
        "struct gl_msvc_inval_per_thread",
        "struct",
        "gl_msvc_inval_per_thread",
        "*\ngl_msvc_inval_current (void)",
        "*"
      ]
    },
    "gl_msvc_inval_ensure_handler": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "void\ngl_msvc_inval_ensure_handler (void)\n{\n  if (gl_msvc_inval_initialized == 0)\n    {\n      _set_invalid_parameter_handler (gl_msvc_invalid_parameter_handler);\n      gl_msvc_inval_initialized = 1;\n    }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "cppi/cppi-1.18/lib/msvc-inval.h": {},
  "cppi/cppi-1.18/lib/msvc-nothrow.c": {
    "_gl_nothrow_get_osfhandle": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        39,
        5
      ],
      "content": "intptr_t\n_gl_nothrow_get_osfhandle (int fd)\n{\n  intptr_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _get_osfhandle (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "intptr_t"
      ]
    }
  },
  "cppi/cppi-1.18/lib/msvc-nothrow.h": {},
  "cppi/cppi-1.18/lib/obstack.c": {
    "_obstack_begin": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "int\n_obstack_begin (struct obstack *h,\n                int size, int alignment,\n                void *(*chunkfun) (long),\n                void (*freefun) (void *))\n{\n  register struct _obstack_chunk *chunk; /* points to new chunk */\n\n  if (alignment == 0)\n    alignment = DEFAULT_ALIGNMENT;\n  if (size == 0)\n    /* Default size is what GNU malloc can fit in a 4096-byte block.  */\n    {\n      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.\n         Use the values for range checking, because if range checking is off,\n         the extra bytes won't be missed terribly, but if range checking is on\n         and we used a larger request, a whole extra 4096 bytes would be\n         allocated.\n\n         These number are irrelevant to the new GNU malloc.  I suspect it is\n         less sensitive to the size of the request.  */\n      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))\n                    + 4 + DEFAULT_ROUNDING - 1)\n                   & ~(DEFAULT_ROUNDING - 1));\n      size = 4096 - extra;\n    }\n\n  h->chunkfun = (struct _obstack_chunk * (*)(void *, long)) chunkfun;\n  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;\n  h->chunk_size = size;\n  h->alignment_mask = alignment - 1;\n  h->use_extra_arg = 0;\n\n  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);\n  if (!chunk)\n    (*obstack_alloc_failed_handler) ();\n  h->next_free = h->object_base = __PTR_ALIGN ((char *) chunk, chunk->contents,\n                                               alignment - 1);\n  h->chunk_limit = chunk->limit\n    = (char *) chunk + h->chunk_size;\n  chunk->prev = 0;\n  /* The initial chunk now contains no empty object.  */\n  h->maybe_empty_object = 0;\n  h->alloc_failed = 0;\n  return 1;\n}",
      "lines": 46,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "_obstack_begin_1": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        232,
        1
      ],
      "content": "int\n_obstack_begin_1 (struct obstack *h, int size, int alignment,\n                  void *(*chunkfun) (void *, long),\n                  void (*freefun) (void *, void *),\n                  void *arg)\n{\n  register struct _obstack_chunk *chunk; /* points to new chunk */\n\n  if (alignment == 0)\n    alignment = DEFAULT_ALIGNMENT;\n  if (size == 0)\n    /* Default size is what GNU malloc can fit in a 4096-byte block.  */\n    {\n      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.\n         Use the values for range checking, because if range checking is off,\n         the extra bytes won't be missed terribly, but if range checking is on\n         and we used a larger request, a whole extra 4096 bytes would be\n         allocated.\n\n         These number are irrelevant to the new GNU malloc.  I suspect it is\n         less sensitive to the size of the request.  */\n      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))\n                    + 4 + DEFAULT_ROUNDING - 1)\n                   & ~(DEFAULT_ROUNDING - 1));\n      size = 4096 - extra;\n    }\n\n  h->chunkfun = (struct _obstack_chunk * (*)(void *,long)) chunkfun;\n  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;\n  h->chunk_size = size;\n  h->alignment_mask = alignment - 1;\n  h->extra_arg = arg;\n  h->use_extra_arg = 1;\n\n  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);\n  if (!chunk)\n    (*obstack_alloc_failed_handler) ();\n  h->next_free = h->object_base = __PTR_ALIGN ((char *) chunk, chunk->contents,\n                                               alignment - 1);\n  h->chunk_limit = chunk->limit\n    = (char *) chunk + h->chunk_size;\n  chunk->prev = 0;\n  /* The initial chunk now contains no empty object.  */\n  h->maybe_empty_object = 0;\n  h->alloc_failed = 0;\n  return 1;\n}",
      "lines": 47,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "_obstack_newchunk": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        304,
        1
      ],
      "content": "void\n_obstack_newchunk (struct obstack *h, int length)\n{\n  register struct _obstack_chunk *old_chunk = h->chunk;\n  register struct _obstack_chunk *new_chunk;\n  register long new_size;\n  register long obj_size = h->next_free - h->object_base;\n  register long i;\n  long already;\n  char *object_base;\n\n  /* Compute size for new chunk.  */\n  new_size = (obj_size + length) + (obj_size >> 3) + h->alignment_mask + 100;\n  if (new_size < h->chunk_size)\n    new_size = h->chunk_size;\n\n  /* Allocate and initialize the new chunk.  */\n  new_chunk = CALL_CHUNKFUN (h, new_size);\n  if (!new_chunk)\n    (*obstack_alloc_failed_handler) ();\n  h->chunk = new_chunk;\n  new_chunk->prev = old_chunk;\n  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;\n\n  /* Compute an aligned object_base in the new chunk */\n  object_base =\n    __PTR_ALIGN ((char *) new_chunk, new_chunk->contents, h->alignment_mask);\n\n  /* Move the existing object to the new chunk.\n     Word at a time is fast and is safe if the object\n     is sufficiently aligned.  */\n  if (h->alignment_mask + 1 >= DEFAULT_ALIGNMENT)\n    {\n      for (i = obj_size / sizeof (COPYING_UNIT) - 1;\n           i >= 0; i--)\n        ((COPYING_UNIT *)object_base)[i]\n          = ((COPYING_UNIT *)h->object_base)[i];\n      /* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,\n         but that can cross a page boundary on a machine\n         which does not do strict alignment for COPYING_UNITS.  */\n      already = obj_size / sizeof (COPYING_UNIT) * sizeof (COPYING_UNIT);\n    }\n  else\n    already = 0;\n  /* Copy remaining bytes one by one.  */\n  for (i = already; i < obj_size; i++)\n    object_base[i] = h->object_base[i];\n\n  /* If the object just copied was the only data in OLD_CHUNK,\n     free that chunk and remove it from the chain.\n     But not if that chunk might contain an empty object.  */\n  if (! h->maybe_empty_object\n      && (h->object_base\n          == __PTR_ALIGN ((char *) old_chunk, old_chunk->contents,\n                          h->alignment_mask)))\n    {\n      new_chunk->prev = old_chunk->prev;\n      CALL_FREEFUN (h, old_chunk);\n    }\n\n  h->object_base = object_base;\n  h->next_free = h->object_base + obj_size;\n  /* The new chunk certainly contains no empty object yet.  */\n  h->maybe_empty_object = 0;\n}",
      "lines": 65,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_obstack_allocated_p": {
      "start_point": [
        317,
        0
      ],
      "end_point": [
        333,
        1
      ],
      "content": "int\n_obstack_allocated_p (struct obstack *h, void *obj)\n{\n  register struct _obstack_chunk *lp;   /* below addr of any objects in this chunk */\n  register struct _obstack_chunk *plp;  /* point to previous chunk if any */\n\n  lp = (h)->chunk;\n  /* We use >= rather than > since the object cannot be exactly at\n     the beginning of the chunk but might be an empty object exactly\n     at the end of an adjacent chunk.  */\n  while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))\n    {\n      plp = lp->prev;\n      lp = plp;\n    }\n  return lp != 0;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "__obstack_free": {
      "start_point": [
        340,
        0
      ],
      "end_point": [
        368,
        1
      ],
      "content": "void\n__obstack_free (struct obstack *h, void *obj)\n{\n  register struct _obstack_chunk *lp;   /* below addr of any objects in this chunk */\n  register struct _obstack_chunk *plp;  /* point to previous chunk if any */\n\n  lp = h->chunk;\n  /* We use >= because there cannot be an object at the beginning of a chunk.\n     But there can be an empty object at that address\n     at the end of another chunk.  */\n  while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))\n    {\n      plp = lp->prev;\n      CALL_FREEFUN (h, lp);\n      lp = plp;\n      /* If we switch chunks, we can't tell whether the new current\n         chunk contains an empty object, so assume that it may.  */\n      h->maybe_empty_object = 1;\n    }\n  if (lp)\n    {\n      h->object_base = h->next_free = (char *) (obj);\n      h->chunk_limit = lp->limit;\n      h->chunk = lp;\n    }\n  else if (obj != 0)\n    /* obj is not in any of the chunks! */\n    abort ();\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "_obstack_memory_used": {
      "start_point": [
        376,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "int\n_obstack_memory_used (struct obstack *h)\n{\n  register struct _obstack_chunk* lp;\n  register int nbytes = 0;\n\n  for (lp = h->chunk; lp != 0; lp = lp->prev)\n    {\n      nbytes += lp->limit - (char *) lp;\n    }\n  return nbytes;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "print_and_abort": {
      "start_point": [
        403,
        0
      ],
      "end_point": [
        417,
        1
      ],
      "content": "static _Noreturn void\nprint_and_abort (void)\n{\n  /* Don't change any of these strings.  Yes, it would be possible to add\n     the newline to the string and use fputs or so.  But this must not\n     happen because the \"memory exhausted\" message appears in other places\n     like this and the translation should be reused instead of creating\n     a very similar string which requires a separate translation.  */\n# ifdef _LIBC\n  (void) __fxprintf (NULL, \"%s\\n\", _(\"memory exhausted\"));\n# else\n  fprintf (stderr, \"%s\\n\", _(\"memory exhausted\"));\n# endif\n  exit (obstack_exit_failure);\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "_Noreturn",
        "void",
        "void"
      ]
    }
  },
  "cppi/cppi-1.18/lib/obstack.h": {},
  "cppi/cppi-1.18/lib/progname.c": {
    "set_program_name": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "void\nset_program_name (const char *argv0)\n{\n  /* libtool creates a temporary executable whose name is sometimes prefixed\n     with \"lt-\" (depends on the platform).  It also makes argv[0] absolute.\n     But the name of the temporary executable is a detail that should not be\n     visible to the end user and to the test suite.\n     Remove this \"<dirname>/.libs/\" or \"<dirname>/.libs/lt-\" prefix here.  */\n  const char *slash;\n  const char *base;\n\n  /* Sanity check.  POSIX requires the invoking process to pass a non-NULL\n     argv[0].  */\n  if (argv0 == NULL)\n    {\n      /* It's a bug in the invoking program.  Help diagnosing it.  */\n      fputs (\"A NULL argv[0] was passed through an exec system call.\\n\",\n             stderr);\n      abort ();\n    }\n\n  slash = strrchr (argv0, '/');\n  base = (slash != NULL ? slash + 1 : argv0);\n  if (base - argv0 >= 7 && strncmp (base - 7, \"/.libs/\", 7) == 0)\n    {\n      argv0 = base;\n      if (strncmp (base, \"lt-\", 3) == 0)\n        {\n          argv0 = base + 3;\n          /* On glibc systems, remove the \"lt-\" prefix from the variable\n             program_invocation_short_name.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME\n          program_invocation_short_name = (char *) argv0;\n#endif\n        }\n    }\n\n  /* But don't strip off a leading <dirname>/ in general, because when the user\n     runs\n         /some/hidden/place/bin/cp foo foo\n     he should get the error message\n         /some/hidden/place/bin/cp: `foo' and `foo' are the same file\n     not\n         cp: `foo' and `foo' are the same file\n   */\n\n  program_name = argv0;\n\n  /* On glibc systems, the error() function comes from libc and uses the\n     variable program_invocation_name, not program_name.  So set this variable\n     as well.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_NAME\n  program_invocation_name = (char *) argv0;\n#endif\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "cppi/cppi-1.18/lib/progname.h": {},
  "cppi/cppi-1.18/lib/quote.h": {},
  "cppi/cppi-1.18/lib/quotearg.c": {
    "clone_quoting_options": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "struct quoting_options *\nclone_quoting_options (struct quoting_options *o)\n{\n  int e = errno;\n  struct quoting_options *p = xmemdup (o ? o : &default_quoting_options,\n                                       sizeof *o);\n  errno = e;\n  return p;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "struct quoting_options",
        "struct",
        "quoting_options",
        "*\nclone_quoting_options (struct quoting_options *o)",
        "*"
      ]
    },
    "get_quoting_style": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "enum quoting_style\nget_quoting_style (struct quoting_options *o)\n{\n  return (o ? o : &default_quoting_options)->style;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "enum quoting_style",
        "enum",
        "quoting_style"
      ]
    },
    "set_quoting_style": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "void\nset_quoting_style (struct quoting_options *o, enum quoting_style s)\n{\n  (o ? o : &default_quoting_options)->style = s;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "set_char_quoting": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "int\nset_char_quoting (struct quoting_options *o, char c, int i)\n{\n  unsigned char uc = c;\n  unsigned int *p =\n    (o ? o : &default_quoting_options)->quote_these_too + uc / INT_BITS;\n  int shift = uc % INT_BITS;\n  int r = (*p >> shift) & 1;\n  *p ^= ((i & 1) ^ r) << shift;\n  return r;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "set_quoting_flags": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "int\nset_quoting_flags (struct quoting_options *o, int i)\n{\n  int r;\n  if (!o)\n    o = &default_quoting_options;\n  r = o->flags;\n  o->flags = i;\n  return r;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "set_custom_quoting": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "void\nset_custom_quoting (struct quoting_options *o,\n                    char const *left_quote, char const *right_quote)\n{\n  if (!o)\n    o = &default_quoting_options;\n  o->style = custom_quoting_style;\n  if (!left_quote || !right_quote)\n    abort ();\n  o->left_quote = left_quote;\n  o->right_quote = right_quote;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "quoting_options_from_style": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "static struct quoting_options /* NOT PURE!! */\nquoting_options_from_style (enum quoting_style style)\n{\n  struct quoting_options o = { 0, 0, { 0 }, NULL, NULL };\n  if (style == custom_quoting_style)\n    abort ();\n  o.style = style;\n  return o;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct quoting_options",
        "struct",
        "quoting_options",
        "/* NOT PURE!! */"
      ]
    },
    "gettext_quote": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "static char const *\ngettext_quote (char const *msgid, enum quoting_style s)\n{\n  char const *translation = _(msgid);\n  char const *locale_code;\n\n  if (translation != msgid)\n    return translation;\n\n  /* For UTF-8 and GB-18030, use single quotes U+2018 and U+2019.\n     Here is a list of other locales that include U+2018 and U+2019:\n\n        ISO-8859-7   0xA1                 KOI8-T       0x91\n        CP869        0x8B                 CP874        0x91\n        CP932        0x81 0x65            CP936        0xA1 0xAE\n        CP949        0xA1 0xAE            CP950        0xA1 0xA5\n        CP1250       0x91                 CP1251       0x91\n        CP1252       0x91                 CP1253       0x91\n        CP1254       0x91                 CP1255       0x91\n        CP1256       0x91                 CP1257       0x91\n        EUC-JP       0xA1 0xC6            EUC-KR       0xA1 0xAE\n        EUC-TW       0xA1 0xE4            BIG5         0xA1 0xA5\n        BIG5-HKSCS   0xA1 0xA5            EUC-CN       0xA1 0xAE\n        GBK          0xA1 0xAE            Georgian-PS  0x91\n        PT154        0x91\n\n     None of these is still in wide use; using iconv is overkill.  */\n  locale_code = locale_charset ();\n  if (STRCASEEQ (locale_code, \"UTF-8\", 'U','T','F','-','8',0,0,0,0))\n    return msgid[0] == '`' ? \"\\xe2\\x80\\x98\": \"\\xe2\\x80\\x99\";\n  if (STRCASEEQ (locale_code, \"GB18030\", 'G','B','1','8','0','3','0',0,0))\n    return msgid[0] == '`' ? \"\\xa1\\ae\": \"\\xa1\\xaf\";\n\n  return (s == clocale_quoting_style ? \"\\\"\" : \"'\");\n}",
      "lines": 35,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ngettext_quote (char const *msgid, enum quoting_style s)",
        "*"
      ]
    },
    "quotearg_buffer_restyled": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        655,
        1
      ],
      "content": "static size_t\nquotearg_buffer_restyled (char *buffer, size_t buffersize,\n                          char const *arg, size_t argsize,\n                          enum quoting_style quoting_style, int flags,\n                          unsigned int const *quote_these_too,\n                          char const *left_quote,\n                          char const *right_quote)\n{\n  size_t i;\n  size_t len = 0;\n  char const *quote_string = 0;\n  size_t quote_string_len = 0;\n  bool backslash_escapes = false;\n  bool unibyte_locale = MB_CUR_MAX == 1;\n  bool elide_outer_quotes = (flags & QA_ELIDE_OUTER_QUOTES) != 0;\n\n#define STORE(c) \\\n    do \\\n      { \\\n        if (len < buffersize) \\\n          buffer[len] = (c); \\\n        len++; \\\n      } \\\n    while (0)\n\n  switch (quoting_style)\n    {\n    case c_maybe_quoting_style:\n      quoting_style = c_quoting_style;\n      elide_outer_quotes = true;\n      /* Fall through.  */\n    case c_quoting_style:\n      if (!elide_outer_quotes)\n        STORE ('\"');\n      backslash_escapes = true;\n      quote_string = \"\\\"\";\n      quote_string_len = 1;\n      break;\n\n    case escape_quoting_style:\n      backslash_escapes = true;\n      elide_outer_quotes = false;\n      break;\n\n    case locale_quoting_style:\n    case clocale_quoting_style:\n    case custom_quoting_style:\n      {\n        if (quoting_style != custom_quoting_style)\n          {\n            /* TRANSLATORS:\n               Get translations for open and closing quotation marks.\n               The message catalog should translate \"`\" to a left\n               quotation mark suitable for the locale, and similarly for\n               \"'\".  For example, a French Unicode local should translate\n               these to U+00AB (LEFT-POINTING DOUBLE ANGLE\n               QUOTATION MARK), and U+00BB (RIGHT-POINTING DOUBLE ANGLE\n               QUOTATION MARK), respectively.\n\n               If the catalog has no translation, we will try to\n               use Unicode U+2018 (LEFT SINGLE QUOTATION MARK) and\n               Unicode U+2019 (RIGHT SINGLE QUOTATION MARK).  If the\n               current locale is not Unicode, locale_quoting_style\n               will quote 'like this', and clocale_quoting_style will\n               quote \"like this\".  You should always include translations\n               for \"`\" and \"'\" even if U+2018 and U+2019 are appropriate\n               for your locale.\n\n               If you don't know what to put here, please see\n               <http://en.wikipedia.org/wiki/Quotation_marks_in_other_languages>\n               and use glyphs suitable for your language.  */\n            left_quote = gettext_quote (N_(\"`\"), quoting_style);\n            right_quote = gettext_quote (N_(\"'\"), quoting_style);\n          }\n        if (!elide_outer_quotes)\n          for (quote_string = left_quote; *quote_string; quote_string++)\n            STORE (*quote_string);\n        backslash_escapes = true;\n        quote_string = right_quote;\n        quote_string_len = strlen (quote_string);\n      }\n      break;\n\n    case shell_quoting_style:\n      quoting_style = shell_always_quoting_style;\n      elide_outer_quotes = true;\n      /* Fall through.  */\n    case shell_always_quoting_style:\n      if (!elide_outer_quotes)\n        STORE ('\\'');\n      quote_string = \"'\";\n      quote_string_len = 1;\n      break;\n\n    case literal_quoting_style:\n      elide_outer_quotes = false;\n      break;\n\n    default:\n      abort ();\n    }\n\n  for (i = 0;  ! (argsize == SIZE_MAX ? arg[i] == '\\0' : i == argsize);  i++)\n    {\n      unsigned char c;\n      unsigned char esc;\n      bool is_right_quote = false;\n\n      if (backslash_escapes\n          && quote_string_len\n          && i + quote_string_len <= argsize\n          && memcmp (arg + i, quote_string, quote_string_len) == 0)\n        {\n          if (elide_outer_quotes)\n            goto force_outer_quoting_style;\n          is_right_quote = true;\n        }\n\n      c = arg[i];\n      switch (c)\n        {\n        case '\\0':\n          if (backslash_escapes)\n            {\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n              STORE ('\\\\');\n              /* If quote_string were to begin with digits, we'd need to\n                 test for the end of the arg as well.  However, it's\n                 hard to imagine any locale that would use digits in\n                 quotes, and set_custom_quoting is documented not to\n                 accept them.  */\n              if (i + 1 < argsize && '0' <= arg[i + 1] && arg[i + 1] <= '9')\n                {\n                  STORE ('0');\n                  STORE ('0');\n                }\n              c = '0';\n              /* We don't have to worry that this last '0' will be\n                 backslash-escaped because, again, quote_string should\n                 not start with it and because quote_these_too is\n                 documented as not accepting it.  */\n            }\n          else if (flags & QA_ELIDE_NULL_BYTES)\n            continue;\n          break;\n\n        case '?':\n          switch (quoting_style)\n            {\n            case shell_always_quoting_style:\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n              break;\n\n            case c_quoting_style:\n              if ((flags & QA_SPLIT_TRIGRAPHS)\n                  && i + 2 < argsize && arg[i + 1] == '?')\n                switch (arg[i + 2])\n                  {\n                  case '!': case '\\'':\n                  case '(': case ')': case '-': case '/':\n                  case '<': case '=': case '>':\n                    /* Escape the second '?' in what would otherwise be\n                       a trigraph.  */\n                    if (elide_outer_quotes)\n                      goto force_outer_quoting_style;\n                    c = arg[i + 2];\n                    i += 2;\n                    STORE ('?');\n                    STORE ('\"');\n                    STORE ('\"');\n                    STORE ('?');\n                    break;\n\n                  default:\n                    break;\n                  }\n              break;\n\n            default:\n              break;\n            }\n          break;\n\n        case '\\a': esc = 'a'; goto c_escape;\n        case '\\b': esc = 'b'; goto c_escape;\n        case '\\f': esc = 'f'; goto c_escape;\n        case '\\n': esc = 'n'; goto c_and_shell_escape;\n        case '\\r': esc = 'r'; goto c_and_shell_escape;\n        case '\\t': esc = 't'; goto c_and_shell_escape;\n        case '\\v': esc = 'v'; goto c_escape;\n        case '\\\\': esc = c;\n          /* No need to escape the escape if we are trying to elide\n             outer quotes and nothing else is problematic.  */\n          if (backslash_escapes && elide_outer_quotes && quote_string_len)\n            goto store_c;\n\n        c_and_shell_escape:\n          if (quoting_style == shell_always_quoting_style\n              && elide_outer_quotes)\n            goto force_outer_quoting_style;\n          /* Fall through.  */\n        c_escape:\n          if (backslash_escapes)\n            {\n              c = esc;\n              goto store_escape;\n            }\n          break;\n\n        case '{': case '}': /* sometimes special if isolated */\n          if (! (argsize == SIZE_MAX ? arg[1] == '\\0' : argsize == 1))\n            break;\n          /* Fall through.  */\n        case '#': case '~':\n          if (i != 0)\n            break;\n          /* Fall through.  */\n        case ' ':\n        case '!': /* special in bash */\n        case '\"': case '$': case '&':\n        case '(': case ')': case '*': case ';':\n        case '<':\n        case '=': /* sometimes special in 0th or (with \"set -k\") later args */\n        case '>': case '[':\n        case '^': /* special in old /bin/sh, e.g. SunOS 4.1.4 */\n        case '`': case '|':\n          /* A shell special character.  In theory, '$' and '`' could\n             be the first bytes of multibyte characters, which means\n             we should check them with mbrtowc, but in practice this\n             doesn't happen so it's not worth worrying about.  */\n          if (quoting_style == shell_always_quoting_style\n              && elide_outer_quotes)\n            goto force_outer_quoting_style;\n          break;\n\n        case '\\'':\n          if (quoting_style == shell_always_quoting_style)\n            {\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n              STORE ('\\'');\n              STORE ('\\\\');\n              STORE ('\\'');\n            }\n          break;\n\n        case '%': case '+': case ',': case '-': case '.': case '/':\n        case '0': case '1': case '2': case '3': case '4': case '5':\n        case '6': case '7': case '8': case '9': case ':':\n        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n        case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n        case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n        case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n        case 'Y': case 'Z': case ']': case '_': case 'a': case 'b':\n        case 'c': case 'd': case 'e': case 'f': case 'g': case 'h':\n        case 'i': case 'j': case 'k': case 'l': case 'm': case 'n':\n        case 'o': case 'p': case 'q': case 'r': case 's': case 't':\n        case 'u': case 'v': case 'w': case 'x': case 'y': case 'z':\n          /* These characters don't cause problems, no matter what the\n             quoting style is.  They cannot start multibyte sequences.\n             A digit or a special letter would cause trouble if it\n             appeared at the beginning of quote_string because we'd then\n             escape by prepending a backslash.  However, it's hard to\n             imagine any locale that would use digits or letters as\n             quotes, and set_custom_quoting is documented not to accept\n             them.  Also, a digit or a special letter would cause\n             trouble if it appeared in quote_these_too, but that's also\n             documented as not accepting them.  */\n          break;\n\n        default:\n          /* If we have a multibyte sequence, copy it until we reach\n             its end, find an error, or come back to the initial shift\n             state.  For C-like styles, if the sequence has\n             unprintable characters, escape the whole sequence, since\n             we can't easily escape single characters within it.  */\n          {\n            /* Length of multibyte sequence found so far.  */\n            size_t m;\n\n            bool printable;\n\n            if (unibyte_locale)\n              {\n                m = 1;\n                printable = isprint (c) != 0;\n              }\n            else\n              {\n                mbstate_t mbstate;\n                memset (&mbstate, 0, sizeof mbstate);\n\n                m = 0;\n                printable = true;\n                if (argsize == SIZE_MAX)\n                  argsize = strlen (arg);\n\n                do\n                  {\n                    wchar_t w;\n                    size_t bytes = mbrtowc (&w, &arg[i + m],\n                                            argsize - (i + m), &mbstate);\n                    if (bytes == 0)\n                      break;\n                    else if (bytes == (size_t) -1)\n                      {\n                        printable = false;\n                        break;\n                      }\n                    else if (bytes == (size_t) -2)\n                      {\n                        printable = false;\n                        while (i + m < argsize && arg[i + m])\n                          m++;\n                        break;\n                      }\n                    else\n                      {\n                        /* Work around a bug with older shells that \"see\" a '\\'\n                           that is really the 2nd byte of a multibyte character.\n                           In practice the problem is limited to ASCII\n                           chars >= '@' that are shell special chars.  */\n                        if ('[' == 0x5b && elide_outer_quotes\n                            && quoting_style == shell_always_quoting_style)\n                          {\n                            size_t j;\n                            for (j = 1; j < bytes; j++)\n                              switch (arg[i + m + j])\n                                {\n                                case '[': case '\\\\': case '^':\n                                case '`': case '|':\n                                  goto force_outer_quoting_style;\n\n                                default:\n                                  break;\n                                }\n                          }\n\n                        if (! iswprint (w))\n                          printable = false;\n                        m += bytes;\n                      }\n                  }\n                while (! mbsinit (&mbstate));\n              }\n\n            if (1 < m || (backslash_escapes && ! printable))\n              {\n                /* Output a multibyte sequence, or an escaped\n                   unprintable unibyte character.  */\n                size_t ilim = i + m;\n\n                for (;;)\n                  {\n                    if (backslash_escapes && ! printable)\n                      {\n                        if (elide_outer_quotes)\n                          goto force_outer_quoting_style;\n                        STORE ('\\\\');\n                        STORE ('0' + (c >> 6));\n                        STORE ('0' + ((c >> 3) & 7));\n                        c = '0' + (c & 7);\n                      }\n                    else if (is_right_quote)\n                      {\n                        STORE ('\\\\');\n                        is_right_quote = false;\n                      }\n                    if (ilim <= i + 1)\n                      break;\n                    STORE (c);\n                    c = arg[++i];\n                  }\n\n                goto store_c;\n              }\n          }\n        }\n\n      if (! ((backslash_escapes || elide_outer_quotes)\n             && quote_these_too\n             && quote_these_too[c / INT_BITS] & (1 << (c % INT_BITS)))\n          && !is_right_quote)\n        goto store_c;\n\n    store_escape:\n      if (elide_outer_quotes)\n        goto force_outer_quoting_style;\n      STORE ('\\\\');\n\n    store_c:\n      STORE (c);\n    }\n\n  if (len == 0 && quoting_style == shell_always_quoting_style\n      && elide_outer_quotes)\n    goto force_outer_quoting_style;\n\n  if (quote_string && !elide_outer_quotes)\n    for (; *quote_string; quote_string++)\n      STORE (*quote_string);\n\n  if (len < buffersize)\n    buffer[len] = '\\0';\n  return len;\n\n force_outer_quoting_style:\n  /* Don't reuse quote_these_too, since the addition of outer quotes\n     sufficiently quotes the specified characters.  */\n  return quotearg_buffer_restyled (buffer, buffersize, arg, argsize,\n                                   quoting_style,\n                                   flags & ~QA_ELIDE_OUTER_QUOTES, NULL,\n                                   left_quote, right_quote);\n}",
      "lines": 416,
      "depth": 25,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "quotearg_buffer": {
      "start_point": [
        666,
        0
      ],
      "end_point": [
        678,
        1
      ],
      "content": "size_t\nquotearg_buffer (char *buffer, size_t buffersize,\n                 char const *arg, size_t argsize,\n                 struct quoting_options const *o)\n{\n  struct quoting_options const *p = o ? o : &default_quoting_options;\n  int e = errno;\n  size_t r = quotearg_buffer_restyled (buffer, buffersize, arg, argsize,\n                                       p->style, p->flags, p->quote_these_too,\n                                       p->left_quote, p->right_quote);\n  errno = e;\n  return r;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "quotearg_alloc": {
      "start_point": [
        681,
        0
      ],
      "end_point": [
        686,
        1
      ],
      "content": "char *\nquotearg_alloc (char const *arg, size_t argsize,\n                struct quoting_options const *o)\n{\n  return quotearg_alloc_mem (arg, argsize, NULL, o);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_alloc (char const *arg, size_t argsize,\n                struct quoting_options const *o)",
        "*"
      ]
    },
    "quotearg_alloc_mem": {
      "start_point": [
        694,
        0
      ],
      "end_point": [
        714,
        1
      ],
      "content": "char *\nquotearg_alloc_mem (char const *arg, size_t argsize, size_t *size,\n                    struct quoting_options const *o)\n{\n  struct quoting_options const *p = o ? o : &default_quoting_options;\n  int e = errno;\n  /* Elide embedded null bytes if we can't return a size.  */\n  int flags = p->flags | (size ? 0 : QA_ELIDE_NULL_BYTES);\n  size_t bufsize = quotearg_buffer_restyled (0, 0, arg, argsize, p->style,\n                                             flags, p->quote_these_too,\n                                             p->left_quote,\n                                             p->right_quote) + 1;\n  char *buf = xcharalloc (bufsize);\n  quotearg_buffer_restyled (buf, bufsize, arg, argsize, p->style, flags,\n                            p->quote_these_too,\n                            p->left_quote, p->right_quote);\n  errno = e;\n  if (size)\n    *size = bufsize - 1;\n  return buf;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "char",
        "*\nquotearg_alloc_mem (char const *arg, size_t argsize, size_t *size,\n                    struct quoting_options const *o)",
        "*"
      ]
    },
    "quotearg_free": {
      "start_point": [
        730,
        0
      ],
      "end_point": [
        749,
        1
      ],
      "content": "void\nquotearg_free (void)\n{\n  struct slotvec *sv = slotvec;\n  unsigned int i;\n  for (i = 1; i < nslots; i++)\n    free (sv[i].val);\n  if (sv[0].val != slot0)\n    {\n      free (sv[0].val);\n      slotvec0.size = sizeof slot0;\n      slotvec0.val = slot0;\n    }\n  if (sv != &slotvec0)\n    {\n      free (sv);\n      slotvec = &slotvec0;\n    }\n  nslots = 1;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "quotearg_n_options": {
      "start_point": [
        759,
        0
      ],
      "end_point": [
        817,
        1
      ],
      "content": "static char *\nquotearg_n_options (int n, char const *arg, size_t argsize,\n                    struct quoting_options const *options)\n{\n  int e = errno;\n\n  unsigned int n0 = n;\n  struct slotvec *sv = slotvec;\n\n  if (n < 0)\n    abort ();\n\n  if (nslots <= n0)\n    {\n      /* FIXME: technically, the type of n1 should be 'unsigned int',\n         but that evokes an unsuppressible warning from gcc-4.0.1 and\n         older.  If gcc ever provides an option to suppress that warning,\n         revert to the original type, so that the test in xalloc_oversized\n         is once again performed only at compile time.  */\n      size_t n1 = n0 + 1;\n      bool preallocated = (sv == &slotvec0);\n\n      if (xalloc_oversized (n1, sizeof *sv))\n        xalloc_die ();\n\n      slotvec = sv = xrealloc (preallocated ? NULL : sv, n1 * sizeof *sv);\n      if (preallocated)\n        *sv = slotvec0;\n      memset (sv + nslots, 0, (n1 - nslots) * sizeof *sv);\n      nslots = n1;\n    }\n\n  {\n    size_t size = sv[n].size;\n    char *val = sv[n].val;\n    /* Elide embedded null bytes since we don't return a size.  */\n    int flags = options->flags | QA_ELIDE_NULL_BYTES;\n    size_t qsize = quotearg_buffer_restyled (val, size, arg, argsize,\n                                             options->style, flags,\n                                             options->quote_these_too,\n                                             options->left_quote,\n                                             options->right_quote);\n\n    if (size <= qsize)\n      {\n        sv[n].size = size = qsize + 1;\n        if (val != slot0)\n          free (val);\n        sv[n].val = val = xcharalloc (size);\n        quotearg_buffer_restyled (val, size, arg, argsize, options->style,\n                                  flags, options->quote_these_too,\n                                  options->left_quote,\n                                  options->right_quote);\n      }\n\n    errno = e;\n    return val;\n  }\n}",
      "lines": 59,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nquotearg_n_options (int n, char const *arg, size_t argsize,\n                    struct quoting_options const *options)",
        "*"
      ]
    },
    "quotearg_n": {
      "start_point": [
        819,
        0
      ],
      "end_point": [
        823,
        1
      ],
      "content": "char *\nquotearg_n (int n, char const *arg)\n{\n  return quotearg_n_options (n, arg, SIZE_MAX, &default_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n (int n, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_mem": {
      "start_point": [
        825,
        0
      ],
      "end_point": [
        829,
        1
      ],
      "content": "char *\nquotearg_n_mem (int n, char const *arg, size_t argsize)\n{\n  return quotearg_n_options (n, arg, argsize, &default_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_mem (int n, char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg": {
      "start_point": [
        831,
        0
      ],
      "end_point": [
        835,
        1
      ],
      "content": "char *\nquotearg (char const *arg)\n{\n  return quotearg_n (0, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg (char const *arg)",
        "*"
      ]
    },
    "quotearg_mem": {
      "start_point": [
        837,
        0
      ],
      "end_point": [
        841,
        1
      ],
      "content": "char *\nquotearg_mem (char const *arg, size_t argsize)\n{\n  return quotearg_n_mem (0, arg, argsize);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_mem (char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_n_style": {
      "start_point": [
        843,
        0
      ],
      "end_point": [
        848,
        1
      ],
      "content": "char *\nquotearg_n_style (int n, enum quoting_style s, char const *arg)\n{\n  struct quoting_options const o = quoting_options_from_style (s);\n  return quotearg_n_options (n, arg, SIZE_MAX, &o);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_style (int n, enum quoting_style s, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_style_mem": {
      "start_point": [
        850,
        0
      ],
      "end_point": [
        856,
        1
      ],
      "content": "char *\nquotearg_n_style_mem (int n, enum quoting_style s,\n                      char const *arg, size_t argsize)\n{\n  struct quoting_options const o = quoting_options_from_style (s);\n  return quotearg_n_options (n, arg, argsize, &o);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_style_mem (int n, enum quoting_style s,\n                      char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_style": {
      "start_point": [
        858,
        0
      ],
      "end_point": [
        862,
        1
      ],
      "content": "char *\nquotearg_style (enum quoting_style s, char const *arg)\n{\n  return quotearg_n_style (0, s, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_style (enum quoting_style s, char const *arg)",
        "*"
      ]
    },
    "quotearg_style_mem": {
      "start_point": [
        864,
        0
      ],
      "end_point": [
        868,
        1
      ],
      "content": "char *\nquotearg_style_mem (enum quoting_style s, char const *arg, size_t argsize)\n{\n  return quotearg_n_style_mem (0, s, arg, argsize);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_style_mem (enum quoting_style s, char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_char_mem": {
      "start_point": [
        870,
        0
      ],
      "end_point": [
        877,
        1
      ],
      "content": "char *\nquotearg_char_mem (char const *arg, size_t argsize, char ch)\n{\n  struct quoting_options options;\n  options = default_quoting_options;\n  set_char_quoting (&options, ch, 1);\n  return quotearg_n_options (0, arg, argsize, &options);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_char_mem (char const *arg, size_t argsize, char ch)",
        "*"
      ]
    },
    "quotearg_char": {
      "start_point": [
        879,
        0
      ],
      "end_point": [
        883,
        1
      ],
      "content": "char *\nquotearg_char (char const *arg, char ch)\n{\n  return quotearg_char_mem (arg, SIZE_MAX, ch);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_char (char const *arg, char ch)",
        "*"
      ]
    },
    "quotearg_colon": {
      "start_point": [
        885,
        0
      ],
      "end_point": [
        889,
        1
      ],
      "content": "char *\nquotearg_colon (char const *arg)\n{\n  return quotearg_char (arg, ':');\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_colon (char const *arg)",
        "*"
      ]
    },
    "quotearg_colon_mem": {
      "start_point": [
        891,
        0
      ],
      "end_point": [
        895,
        1
      ],
      "content": "char *\nquotearg_colon_mem (char const *arg, size_t argsize)\n{\n  return quotearg_char_mem (arg, argsize, ':');\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_colon_mem (char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_n_custom": {
      "start_point": [
        897,
        0
      ],
      "end_point": [
        903,
        1
      ],
      "content": "char *\nquotearg_n_custom (int n, char const *left_quote,\n                   char const *right_quote, char const *arg)\n{\n  return quotearg_n_custom_mem (n, left_quote, right_quote, arg,\n                                SIZE_MAX);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_custom (int n, char const *left_quote,\n                   char const *right_quote, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_custom_mem": {
      "start_point": [
        905,
        0
      ],
      "end_point": [
        913,
        1
      ],
      "content": "char *\nquotearg_n_custom_mem (int n, char const *left_quote,\n                       char const *right_quote,\n                       char const *arg, size_t argsize)\n{\n  struct quoting_options o = default_quoting_options;\n  set_custom_quoting (&o, left_quote, right_quote);\n  return quotearg_n_options (n, arg, argsize, &o);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_custom_mem (int n, char const *left_quote,\n                       char const *right_quote,\n                       char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_custom": {
      "start_point": [
        915,
        0
      ],
      "end_point": [
        920,
        1
      ],
      "content": "char *\nquotearg_custom (char const *left_quote, char const *right_quote,\n                 char const *arg)\n{\n  return quotearg_n_custom (0, left_quote, right_quote, arg);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_custom (char const *left_quote, char const *right_quote,\n                 char const *arg)",
        "*"
      ]
    },
    "quotearg_custom_mem": {
      "start_point": [
        922,
        0
      ],
      "end_point": [
        928,
        1
      ],
      "content": "char *\nquotearg_custom_mem (char const *left_quote, char const *right_quote,\n                     char const *arg, size_t argsize)\n{\n  return quotearg_n_custom_mem (0, left_quote, right_quote, arg,\n                                argsize);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_custom_mem (char const *left_quote, char const *right_quote,\n                     char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quote_n_mem": {
      "start_point": [
        940,
        0
      ],
      "end_point": [
        944,
        1
      ],
      "content": "char const *\nquote_n_mem (int n, char const *arg, size_t argsize)\n{\n  return quotearg_n_options (n, arg, argsize, &quote_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote_n_mem (int n, char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quote_mem": {
      "start_point": [
        946,
        0
      ],
      "end_point": [
        950,
        1
      ],
      "content": "char const *\nquote_mem (char const *arg, size_t argsize)\n{\n  return quote_n_mem (0, arg, argsize);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote_mem (char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quote_n": {
      "start_point": [
        952,
        0
      ],
      "end_point": [
        956,
        1
      ],
      "content": "char const *\nquote_n (int n, char const *arg)\n{\n  return quote_n_mem (n, arg, SIZE_MAX);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote_n (int n, char const *arg)",
        "*"
      ]
    },
    "quote": {
      "start_point": [
        958,
        0
      ],
      "end_point": [
        962,
        1
      ],
      "content": "char const *\nquote (char const *arg)\n{\n  return quote_n (0, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote (char const *arg)",
        "*"
      ]
    }
  },
  "cppi/cppi-1.18/lib/quotearg.h": {},
  "cppi/cppi-1.18/lib/realloc.c": {
    "rpl_realloc": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void *\nrpl_realloc (void *p, size_t n)\n{\n  void *result;\n\n#if NEED_REALLOC_GNU\n  if (n == 0)\n    {\n      n = 1;\n\n      /* In theory realloc might fail, so don't rely on it to free.  */\n      free (p);\n      p = NULL;\n    }\n#endif\n\n  if (p == NULL)\n    {\n#if GNULIB_REALLOC_GNU && !NEED_REALLOC_GNU && !SYSTEM_MALLOC_GLIBC_COMPATIBLE\n      if (n == 0)\n        n = 1;\n#endif\n      result = malloc (n);\n    }\n  else\n    result = realloc (p, n);\n\n#if !HAVE_REALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "void",
        "*\nrpl_realloc (void *p, size_t n)",
        "*"
      ]
    }
  },
  "cppi/cppi-1.18/lib/stat-macros.h": {},
  "cppi/cppi-1.18/lib/stdarg.in.h": {},
  "cppi/cppi-1.18/lib/stdbool.in.h": {},
  "cppi/cppi-1.18/lib/stddef.in.h": {},
  "cppi/cppi-1.18/lib/stdint.in.h": {},
  "cppi/cppi-1.18/lib/stdlib.in.h": {},
  "cppi/cppi-1.18/lib/stpcpy.c": {
    "__stpcpy": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "char *\n__stpcpy (char *dest, const char *src)\n{\n  register char *d = dest;\n  register const char *s = src;\n\n  do\n    *d++ = *s;\n  while (*s++ != '\\0');\n\n  return d - 1;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "char",
        "*\n__stpcpy (char *dest, const char *src)",
        "*"
      ]
    }
  },
  "cppi/cppi-1.18/lib/streq.h": {
    "streq9": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static inline int\nstreq9 (const char *s1, const char *s2)\n{\n  return strcmp (s1 + 9, s2 + 9) == 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq8": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static inline int\nstreq8 (const char *s1, const char *s2, char s28)\n{\n  if (s1[8] == s28)\n    {\n      if (s28 == 0)\n        return 1;\n      else\n        return streq9 (s1, s2);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq7": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static inline int\nstreq7 (const char *s1, const char *s2, char s27, char s28)\n{\n  if (s1[7] == s27)\n    {\n      if (s27 == 0)\n        return 1;\n      else\n        return streq8 (s1, s2, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq6": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static inline int\nstreq6 (const char *s1, const char *s2, char s26, char s27, char s28)\n{\n  if (s1[6] == s26)\n    {\n      if (s26 == 0)\n        return 1;\n      else\n        return streq7 (s1, s2, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq5": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static inline int\nstreq5 (const char *s1, const char *s2, char s25, char s26, char s27, char s28)\n{\n  if (s1[5] == s25)\n    {\n      if (s25 == 0)\n        return 1;\n      else\n        return streq6 (s1, s2, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq4": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static inline int\nstreq4 (const char *s1, const char *s2, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[4] == s24)\n    {\n      if (s24 == 0)\n        return 1;\n      else\n        return streq5 (s1, s2, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq3": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static inline int\nstreq3 (const char *s1, const char *s2, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[3] == s23)\n    {\n      if (s23 == 0)\n        return 1;\n      else\n        return streq4 (s1, s2, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq2": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static inline int\nstreq2 (const char *s1, const char *s2, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[2] == s22)\n    {\n      if (s22 == 0)\n        return 1;\n      else\n        return streq3 (s1, s2, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq1": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "static inline int\nstreq1 (const char *s1, const char *s2, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[1] == s21)\n    {\n      if (s21 == 0)\n        return 1;\n      else\n        return streq2 (s1, s2, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq0": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "static inline int\nstreq0 (const char *s1, const char *s2, char s20, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[0] == s20)\n    {\n      if (s20 == 0)\n        return 1;\n      else\n        return streq1 (s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "cppi/cppi-1.18/lib/strerror-override.c": {
    "strerror_override": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "const char *\nstrerror_override (int errnum)\n{\n  /* These error messages are taken from glibc/sysdeps/gnu/errlist.c.  */\n  switch (errnum)\n    {\n#if REPLACE_STRERROR_0\n    case 0:\n      return \"Success\";\n#endif\n\n#if GNULIB_defined_ESOCK /* native Windows platforms with older <errno.h> */\n    case EINPROGRESS:\n      return \"Operation now in progress\";\n    case EALREADY:\n      return \"Operation already in progress\";\n    case ENOTSOCK:\n      return \"Socket operation on non-socket\";\n    case EDESTADDRREQ:\n      return \"Destination address required\";\n    case EMSGSIZE:\n      return \"Message too long\";\n    case EPROTOTYPE:\n      return \"Protocol wrong type for socket\";\n    case ENOPROTOOPT:\n      return \"Protocol not available\";\n    case EPROTONOSUPPORT:\n      return \"Protocol not supported\";\n    case EOPNOTSUPP:\n      return \"Operation not supported\";\n    case EAFNOSUPPORT:\n      return \"Address family not supported by protocol\";\n    case EADDRINUSE:\n      return \"Address already in use\";\n    case EADDRNOTAVAIL:\n      return \"Cannot assign requested address\";\n    case ENETDOWN:\n      return \"Network is down\";\n    case ENETUNREACH:\n      return \"Network is unreachable\";\n    case ECONNRESET:\n      return \"Connection reset by peer\";\n    case ENOBUFS:\n      return \"No buffer space available\";\n    case EISCONN:\n      return \"Transport endpoint is already connected\";\n    case ENOTCONN:\n      return \"Transport endpoint is not connected\";\n    case ETIMEDOUT:\n      return \"Connection timed out\";\n    case ECONNREFUSED:\n      return \"Connection refused\";\n    case ELOOP:\n      return \"Too many levels of symbolic links\";\n    case EHOSTUNREACH:\n      return \"No route to host\";\n    case EWOULDBLOCK:\n      return \"Operation would block\";\n#endif\n#if GNULIB_defined_ESTREAMS /* native Windows platforms with older <errno.h> */\n    case ETXTBSY:\n      return \"Text file busy\";\n    case ENODATA:\n      return \"No data available\";\n    case ENOSR:\n      return \"Out of streams resources\";\n    case ENOSTR:\n      return \"Device not a stream\";\n    case ETIME:\n      return \"Timer expired\";\n    case EOTHER:\n      return \"Other error\";\n#endif\n#if GNULIB_defined_EWINSOCK /* native Windows platforms */\n    case ESOCKTNOSUPPORT:\n      return \"Socket type not supported\";\n    case EPFNOSUPPORT:\n      return \"Protocol family not supported\";\n    case ESHUTDOWN:\n      return \"Cannot send after transport endpoint shutdown\";\n    case ETOOMANYREFS:\n      return \"Too many references: cannot splice\";\n    case EHOSTDOWN:\n      return \"Host is down\";\n    case EPROCLIM:\n      return \"Too many processes\";\n    case EUSERS:\n      return \"Too many users\";\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n    case ESTALE:\n      return \"Stale NFS file handle\";\n    case EREMOTE:\n      return \"Object is remote\";\n# if HAVE_WINSOCK2_H\n      /* WSA_INVALID_HANDLE maps to EBADF */\n      /* WSA_NOT_ENOUGH_MEMORY maps to ENOMEM */\n      /* WSA_INVALID_PARAMETER maps to EINVAL */\n    case WSA_OPERATION_ABORTED:\n      return \"Overlapped operation aborted\";\n    case WSA_IO_INCOMPLETE:\n      return \"Overlapped I/O event object not in signaled state\";\n    case WSA_IO_PENDING:\n      return \"Overlapped operations will complete later\";\n      /* WSAEINTR maps to EINTR */\n      /* WSAEBADF maps to EBADF */\n      /* WSAEACCES maps to EACCES */\n      /* WSAEFAULT maps to EFAULT */\n      /* WSAEINVAL maps to EINVAL */\n      /* WSAEMFILE maps to EMFILE */\n      /* WSAEWOULDBLOCK maps to EWOULDBLOCK */\n      /* WSAEINPROGRESS maps to EINPROGRESS */\n      /* WSAEALREADY maps to EALREADY */\n      /* WSAENOTSOCK maps to ENOTSOCK */\n      /* WSAEDESTADDRREQ maps to EDESTADDRREQ */\n      /* WSAEMSGSIZE maps to EMSGSIZE */\n      /* WSAEPROTOTYPE maps to EPROTOTYPE */\n      /* WSAENOPROTOOPT maps to ENOPROTOOPT */\n      /* WSAEPROTONOSUPPORT maps to EPROTONOSUPPORT */\n      /* WSAESOCKTNOSUPPORT is ESOCKTNOSUPPORT */\n      /* WSAEOPNOTSUPP maps to EOPNOTSUPP */\n      /* WSAEPFNOSUPPORT is EPFNOSUPPORT */\n      /* WSAEAFNOSUPPORT maps to EAFNOSUPPORT */\n      /* WSAEADDRINUSE maps to EADDRINUSE */\n      /* WSAEADDRNOTAVAIL maps to EADDRNOTAVAIL */\n      /* WSAENETDOWN maps to ENETDOWN */\n      /* WSAENETUNREACH maps to ENETUNREACH */\n      /* WSAENETRESET maps to ENETRESET */\n      /* WSAECONNABORTED maps to ECONNABORTED */\n      /* WSAECONNRESET maps to ECONNRESET */\n      /* WSAENOBUFS maps to ENOBUFS */\n      /* WSAEISCONN maps to EISCONN */\n      /* WSAENOTCONN maps to ENOTCONN */\n      /* WSAESHUTDOWN is ESHUTDOWN */\n      /* WSAETOOMANYREFS is ETOOMANYREFS */\n      /* WSAETIMEDOUT maps to ETIMEDOUT */\n      /* WSAECONNREFUSED maps to ECONNREFUSED */\n      /* WSAELOOP maps to ELOOP */\n      /* WSAENAMETOOLONG maps to ENAMETOOLONG */\n      /* WSAEHOSTDOWN is EHOSTDOWN */\n      /* WSAEHOSTUNREACH maps to EHOSTUNREACH */\n      /* WSAENOTEMPTY maps to ENOTEMPTY */\n      /* WSAEPROCLIM is EPROCLIM */\n      /* WSAEUSERS is EUSERS */\n      /* WSAEDQUOT is EDQUOT */\n      /* WSAESTALE is ESTALE */\n      /* WSAEREMOTE is EREMOTE */\n    case WSASYSNOTREADY:\n      return \"Network subsystem is unavailable\";\n    case WSAVERNOTSUPPORTED:\n      return \"Winsock.dll version out of range\";\n    case WSANOTINITIALISED:\n      return \"Successful WSAStartup not yet performed\";\n    case WSAEDISCON:\n      return \"Graceful shutdown in progress\";\n    case WSAENOMORE: case WSA_E_NO_MORE:\n      return \"No more results\";\n    case WSAECANCELLED: case WSA_E_CANCELLED:\n      return \"Call was canceled\";\n    case WSAEINVALIDPROCTABLE:\n      return \"Procedure call table is invalid\";\n    case WSAEINVALIDPROVIDER:\n      return \"Service provider is invalid\";\n    case WSAEPROVIDERFAILEDINIT:\n      return \"Service provider failed to initialize\";\n    case WSASYSCALLFAILURE:\n      return \"System call failure\";\n    case WSASERVICE_NOT_FOUND:\n      return \"Service not found\";\n    case WSATYPE_NOT_FOUND:\n      return \"Class type not found\";\n    case WSAEREFUSED:\n      return \"Database query was refused\";\n    case WSAHOST_NOT_FOUND:\n      return \"Host not found\";\n    case WSATRY_AGAIN:\n      return \"Nonauthoritative host not found\";\n    case WSANO_RECOVERY:\n      return \"Nonrecoverable error\";\n    case WSANO_DATA:\n      return \"Valid name, no data record of requested type\";\n      /* WSA_QOS_* omitted */\n# endif\n#endif\n\n#if GNULIB_defined_ENOMSG\n    case ENOMSG:\n      return \"No message of desired type\";\n#endif\n\n#if GNULIB_defined_EIDRM\n    case EIDRM:\n      return \"Identifier removed\";\n#endif\n\n#if GNULIB_defined_ENOLINK\n    case ENOLINK:\n      return \"Link has been severed\";\n#endif\n\n#if GNULIB_defined_EPROTO\n    case EPROTO:\n      return \"Protocol error\";\n#endif\n\n#if GNULIB_defined_EMULTIHOP\n    case EMULTIHOP:\n      return \"Multihop attempted\";\n#endif\n\n#if GNULIB_defined_EBADMSG\n    case EBADMSG:\n      return \"Bad message\";\n#endif\n\n#if GNULIB_defined_EOVERFLOW\n    case EOVERFLOW:\n      return \"Value too large for defined data type\";\n#endif\n\n#if GNULIB_defined_ENOTSUP\n    case ENOTSUP:\n      return \"Not supported\";\n#endif\n\n#if GNULIB_defined_ENETRESET\n    case ENETRESET:\n      return \"Network dropped connection on reset\";\n#endif\n\n#if GNULIB_defined_ECONNABORTED\n    case ECONNABORTED:\n      return \"Software caused connection abort\";\n#endif\n\n#if GNULIB_defined_ESTALE\n    case ESTALE:\n      return \"Stale NFS file handle\";\n#endif\n\n#if GNULIB_defined_EDQUOT\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n#endif\n\n#if GNULIB_defined_ECANCELED\n    case ECANCELED:\n      return \"Operation canceled\";\n#endif\n\n#if GNULIB_defined_EOWNERDEAD\n    case EOWNERDEAD:\n      return \"Owner died\";\n#endif\n\n#if GNULIB_defined_ENOTRECOVERABLE\n    case ENOTRECOVERABLE:\n      return \"State not recoverable\";\n#endif\n\n#if GNULIB_defined_EILSEQ\n    case EILSEQ:\n      return \"Invalid or incomplete multibyte or wide character\";\n#endif\n\n    default:\n      return NULL;\n    }\n}",
      "lines": 269,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nstrerror_override (int errnum)",
        "*"
      ]
    }
  },
  "cppi/cppi-1.18/lib/strerror-override.h": {},
  "cppi/cppi-1.18/lib/strerror.c": {},
  "cppi/cppi-1.18/lib/string.in.h": {},
  "cppi/cppi-1.18/lib/sys_types.in.h": {},
  "cppi/cppi-1.18/lib/time.in.h": {},
  "cppi/cppi-1.18/lib/timespec.c": {},
  "cppi/cppi-1.18/lib/timespec.h": {
    "timespec_cmp": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "_GL_TIMESPEC_INLINE int\ntimespec_cmp (struct timespec a, struct timespec b)\n{\n  return (a.tv_sec < b.tv_sec ? -1\n          : a.tv_sec > b.tv_sec ? 1\n          : (int) (a.tv_nsec - b.tv_nsec));\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "_GL_TIMESPEC_INLINE",
        "int",
        "int"
      ]
    },
    "timespec_sign": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "_GL_TIMESPEC_INLINE int\ntimespec_sign (struct timespec a)\n{\n  return a.tv_sec < 0 ? -1 : a.tv_sec || a.tv_nsec;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "_GL_TIMESPEC_INLINE",
        "int",
        "int"
      ]
    },
    "timespectod": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "_GL_TIMESPEC_INLINE double\ntimespectod (struct timespec a)\n{\n  return a.tv_sec + a.tv_nsec / 1e9;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "_GL_TIMESPEC_INLINE",
        "double",
        "double"
      ]
    }
  },
  "cppi/cppi-1.18/lib/unistd.c": {},
  "cppi/cppi-1.18/lib/unistd.in.h": {
    "rpl_environ": {
      "start_point": [
        400,
        0
      ],
      "end_point": [
        404,
        1
      ],
      "content": "_GL_UNISTD_INLINE char ***\nrpl_environ (void)\n{\n  return &environ;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "char",
        "char",
        "***\nrpl_environ (void)",
        "*",
        "**\nrpl_environ (void)",
        "*",
        "*\nrpl_environ (void)",
        "*"
      ]
    },
    "getpagesize": {
      "start_point": [
        858,
        0
      ],
      "end_point": [
        862,
        1
      ],
      "content": "_GL_UNISTD_INLINE int\ngetpagesize ()\n{\n  return _gl_getpagesize ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "int",
        "int"
      ]
    }
  },
  "cppi/cppi-1.18/lib/unlocked-io.h": {},
  "cppi/cppi-1.18/lib/verify.h": {},
  "cppi/cppi-1.18/lib/version-etc-fsf.c": {},
  "cppi/cppi-1.18/lib/version-etc.c": {
    "version_etc_arn": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "void\nversion_etc_arn (FILE *stream,\n                 const char *command_name, const char *package,\n                 const char *version,\n                 const char * const * authors, size_t n_authors)\n{\n  if (command_name)\n    fprintf (stream, \"%s (%s) %s\\n\", command_name, package, version);\n  else\n    fprintf (stream, \"%s %s\\n\", package, version);\n\n#ifdef PACKAGE_PACKAGER\n# ifdef PACKAGE_PACKAGER_VERSION\n  fprintf (stream, _(\"Packaged by %s (%s)\\n\"), PACKAGE_PACKAGER,\n           PACKAGE_PACKAGER_VERSION);\n# else\n  fprintf (stream, _(\"Packaged by %s\\n\"), PACKAGE_PACKAGER);\n# endif\n#endif\n\n  /* TRANSLATORS: Translate \"(C)\" to the copyright symbol\n     (C-in-a-circle), if this symbol is available in the user's\n     locale.  Otherwise, do not translate \"(C)\"; leave it as-is.  */\n  fprintf (stream, version_etc_copyright, _(\"(C)\"), COPYRIGHT_YEAR);\n\n  fputs (_(\"\\\n\\n\\\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\\n\\\nThis is free software: you are free to change and redistribute it.\\n\\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\\n\\n\\\n\"),\n         stream);\n\n  switch (n_authors)\n    {\n    case 0:\n      /* The caller must provide at least one author name.  */\n      abort ();\n    case 1:\n      /* TRANSLATORS: %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s.\\n\"), authors[0]);\n      break;\n    case 2:\n      /* TRANSLATORS: Each %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s and %s.\\n\"), authors[0], authors[1]);\n      break;\n    case 3:\n      /* TRANSLATORS: Each %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2]);\n      break;\n    case 4:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\nand %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3]);\n      break;\n    case 5:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4]);\n      break;\n    case 6:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5]);\n      break;\n    case 7:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5], authors[6]);\n      break;\n    case 8:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\"),\n                authors[0], authors[1], authors[2], authors[3], authors[4],\n                authors[5], authors[6], authors[7]);\n      break;\n    case 9:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5], authors[6], authors[7], authors[8]);\n      break;\n    default:\n      /* 10 or more authors.  Use an abbreviation, since the human reader\n         will probably not want to read the entire list anyway.  */\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\"),\n                authors[0], authors[1], authors[2], authors[3], authors[4],\n                authors[5], authors[6], authors[7], authors[8]);\n      break;\n    }\n}",
      "lines": 113,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "version_etc_ar": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "void\nversion_etc_ar (FILE *stream,\n                const char *command_name, const char *package,\n                const char *version, const char * const * authors)\n{\n  size_t n_authors;\n\n  for (n_authors = 0; authors[n_authors]; n_authors++)\n    ;\n  version_etc_arn (stream, command_name, package, version, authors, n_authors);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "version_etc_va": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "void\nversion_etc_va (FILE *stream,\n                const char *command_name, const char *package,\n                const char *version, va_list authors)\n{\n  size_t n_authors;\n  const char *authtab[10];\n\n  for (n_authors = 0;\n       n_authors < 10\n         && (authtab[n_authors] = va_arg (authors, const char *)) != NULL;\n       n_authors++)\n    ;\n  version_etc_arn (stream, command_name, package, version,\n                   authtab, n_authors);\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "version_etc": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "void\nversion_etc (FILE *stream,\n             const char *command_name, const char *package,\n             const char *version, /* const char *author1, ...*/ ...)\n{\n  va_list authors;\n\n  va_start (authors, version);\n  version_etc_va (stream, command_name, package, version, authors);\n  va_end (authors);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "emit_bug_reporting_address": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "void\nemit_bug_reporting_address (void)\n{\n  /* TRANSLATORS: The placeholder indicates the bug-reporting address\n     for this package.  Please add _another line_ saying\n     \"Report translation bugs to <...>\\n\" with the address for translation\n     bugs (typically your translation team's web or email address).  */\n  printf (_(\"\\nReport bugs to: %s\\n\"), PACKAGE_BUGREPORT);\n#ifdef PACKAGE_PACKAGER_BUG_REPORTS\n  printf (_(\"Report %s bugs to: %s\\n\"), PACKAGE_PACKAGER,\n          PACKAGE_PACKAGER_BUG_REPORTS);\n#endif\n#ifdef PACKAGE_URL\n  printf (_(\"%s home page: <%s>\\n\"), PACKAGE_NAME, PACKAGE_URL);\n#else\n  printf (_(\"%s home page: <http://www.gnu.org/software/%s/>\\n\"),\n          PACKAGE_NAME, PACKAGE);\n#endif\n  fputs (_(\"General help using GNU software: <http://www.gnu.org/gethelp/>\\n\"),\n         stdout);\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "cppi/cppi-1.18/lib/version-etc.h": {},
  "cppi/cppi-1.18/lib/wchar.in.h": {},
  "cppi/cppi-1.18/lib/wctype-h.c": {},
  "cppi/cppi-1.18/lib/wctype.in.h": {
    "rpl_towlower": {
      "start_point": [
        343,
        0
      ],
      "end_point": [
        347,
        1
      ],
      "content": "_GL_WCTYPE_INLINE wint_t\nrpl_towlower (wint_t wc)\n{\n  return (wint_t) (wchar_t) towlower (wc);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_WCTYPE_INLINE",
        "wint_t",
        "wint_t"
      ]
    },
    "rpl_towupper": {
      "start_point": [
        352,
        0
      ],
      "end_point": [
        356,
        1
      ],
      "content": "_GL_WCTYPE_INLINE wint_t\nrpl_towupper (wint_t wc)\n{\n  return (wint_t) (wchar_t) towupper (wc);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_WCTYPE_INLINE",
        "wint_t",
        "wint_t"
      ]
    }
  },
  "cppi/cppi-1.18/lib/xalloc-die.c": {
    "xalloc_die": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "void\nxalloc_die (void)\n{\n  error (exit_failure, 0, \"%s\", _(\"memory exhausted\"));\n\n  /* _Noreturn cannot be given to error, since it may return if\n     its first argument is 0.  To help compilers understand the\n     xalloc_die does not return, call abort.  Also, the abort is a\n     safety feature if exit_failure is 0 (which shouldn't happen).  */\n  abort ();\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "cppi/cppi-1.18/lib/xalloc-oversized.h": {},
  "cppi/cppi-1.18/lib/xalloc.h": {
    "xnmalloc": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "XALLOC_INLINE void *\nxnmalloc (size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xmalloc (n * s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "XALLOC_INLINE",
        "void",
        "void",
        "*\nxnmalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xnrealloc": [
      {
        "start_point": [
          111,
          0
        ],
        "end_point": [
          117,
          1
        ],
        "content": "XALLOC_INLINE void *\nxnrealloc (void *p, size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xrealloc (p, n * s);\n}",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "XALLOC_INLINE",
          "void",
          "void",
          "*\nxnrealloc (void *p, size_t n, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          232,
          29
        ],
        "end_point": [
          236,
          1
        ],
        "content": "T *\nxnrealloc (T *p, size_t n, size_t s)\n{\n  return (T *) xnrealloc ((void *) p, n, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nxnrealloc (T *p, size_t n, size_t s)",
          "*"
        ]
      }
    ],
    "x2nrealloc": [
      {
        "start_point": [
          174,
          0
        ],
        "end_point": [
          206,
          1
        ],
        "content": "XALLOC_INLINE void *\nx2nrealloc (void *p, size_t *pn, size_t s)\n{\n  size_t n = *pn;\n\n  if (! p)\n    {\n      if (! n)\n        {\n          /* The approximate size to use for initial small allocation\n             requests, when the invoking code specifies an old size of\n             zero.  This is the largest \"small\" request for the GNU C\n             library malloc.  */\n          enum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };\n\n          n = DEFAULT_MXFAST / s;\n          n += !n;\n        }\n    }\n  else\n    {\n      /* Set N = ceil (1.5 * N) so that progress is made if N == 1.\n         Check for overflow, so that N * S stays in size_t range.\n         The check is slightly conservative, but an exact check isn't\n         worth the trouble.  */\n      if ((size_t) -1 / 3 * 2 / s <= n)\n        xalloc_die ();\n      n += (n + 1) / 2;\n    }\n\n  *pn = n;\n  return xrealloc (p, n * s);\n}",
        "lines": 33,
        "depth": 14,
        "decorators": [
          "XALLOC_INLINE",
          "void",
          "void",
          "*\nx2nrealloc (void *p, size_t *pn, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          244,
          29
        ],
        "end_point": [
          248,
          1
        ],
        "content": "T *\nx2nrealloc (T *p, size_t *pn, size_t s)\n{\n  return (T *) x2nrealloc ((void *) p, pn, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nx2nrealloc (T *p, size_t *pn, size_t s)",
          "*"
        ]
      }
    ],
    "xcharalloc": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "XALLOC_INLINE char *\nxcharalloc (size_t n)\n{\n  return XNMALLOC (n, char);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "XALLOC_INLINE",
        "char",
        "char",
        "*\nxcharalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        226,
        29
      ],
      "end_point": [
        230,
        1
      ],
      "content": "T *\nxrealloc (T *p, size_t s)\n{\n  return (T *) xrealloc ((void *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxrealloc (T *p, size_t s)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        238,
        29
      ],
      "end_point": [
        242,
        1
      ],
      "content": "T *\nx2realloc (T *p, size_t *pn)\n{\n  return (T *) x2realloc ((void *) p, pn);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nx2realloc (T *p, size_t *pn)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        250,
        29
      ],
      "end_point": [
        254,
        1
      ],
      "content": "T *\nxmemdup (T const *p, size_t s)\n{\n  return (T *) xmemdup ((void const *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxmemdup (T const *p, size_t s)",
        "*"
      ]
    }
  },
  "cppi/cppi-1.18/lib/xmalloc.c": {
    "xmalloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void *\nxmalloc (size_t n)\n{\n  void *p = malloc (n);\n  if (!p && n != 0)\n    xalloc_die ();\n  return p;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void",
        "*\nxmalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void *\nxrealloc (void *p, size_t n)\n{\n  if (!n && p)\n    {\n      /* The GNU and C99 realloc behaviors disagree here.  Act like\n         GNU, even if the underlying realloc is C99.  */\n      free (p);\n      return NULL;\n    }\n\n  p = realloc (p, n);\n  if (!p && n)\n    xalloc_die ();\n  return p;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxrealloc (void *p, size_t n)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void *\nx2realloc (void *p, size_t *pn)\n{\n  return x2nrealloc (p, pn, 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void",
        "*\nx2realloc (void *p, size_t *pn)",
        "*"
      ]
    },
    "xzalloc": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "void *\nxzalloc (size_t s)\n{\n  return memset (xmalloc (s), 0, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxzalloc (size_t s)",
        "*"
      ]
    },
    "xcalloc": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "void *\nxcalloc (size_t n, size_t s)\n{\n  void *p;\n  /* Test for overflow, since some calloc implementations don't have\n     proper overflow checks.  But omit overflow and size-zero tests if\n     HAVE_GNU_CALLOC, since GNU calloc catches overflow and never\n     returns NULL if successful.  */\n  if ((! HAVE_GNU_CALLOC && xalloc_oversized (n, s))\n      || (! (p = calloc (n, s)) && (HAVE_GNU_CALLOC || n != 0)))\n    xalloc_die ();\n  return p;\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "void",
        "*\nxcalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void *\nxmemdup (void const *p, size_t s)\n{\n  return memcpy (xmalloc (s), p, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxmemdup (void const *p, size_t s)",
        "*"
      ]
    },
    "xstrdup": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "char *\nxstrdup (char const *string)\n{\n  return xmemdup (string, strlen (string) + 1);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "char",
        "*\nxstrdup (char const *string)",
        "*"
      ]
    }
  },
  "cppi/cppi-1.18/lib/xstrtol-error.c": {
    "xstrtol_error": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static void\nxstrtol_error (enum strtol_error err,\n               int opt_idx, char c, struct option const *long_options,\n               char const *arg,\n               int exit_status)\n{\n  char const *hyphens = \"--\";\n  char const *msgid;\n  char const *option;\n  char option_buffer[2];\n\n  switch (err)\n    {\n    default:\n      abort ();\n\n    case LONGINT_INVALID:\n      msgid = N_(\"invalid %s%s argument '%s'\");\n      break;\n\n    case LONGINT_INVALID_SUFFIX_CHAR:\n    case LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW:\n      msgid = N_(\"invalid suffix in %s%s argument '%s'\");\n      break;\n\n    case LONGINT_OVERFLOW:\n      msgid = N_(\"%s%s argument '%s' too large\");\n      break;\n    }\n\n  if (opt_idx < 0)\n    {\n      hyphens -= opt_idx;\n      option_buffer[0] = c;\n      option_buffer[1] = '\\0';\n      option = option_buffer;\n    }\n  else\n    option = long_options[opt_idx].name;\n\n  error (exit_status, 0, gettext (msgid), hyphens, option, arg);\n}",
      "lines": 42,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xstrtol_fatal": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "void\nxstrtol_fatal (enum strtol_error err,\n               int opt_idx, char c, struct option const *long_options,\n               char const *arg)\n{\n  xstrtol_error (err, opt_idx, c, long_options, arg, exit_failure);\n  abort ();\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "cppi/cppi-1.18/lib/xstrtol.c": {
    "bkm_scale": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "static strtol_error\nbkm_scale (__strtol_t *x, int scale_factor)\n{\n  if (TYPE_SIGNED (__strtol_t) && *x < STRTOL_T_MINIMUM / scale_factor)\n    {\n      *x = STRTOL_T_MINIMUM;\n      return LONGINT_OVERFLOW;\n    }\n  if (STRTOL_T_MAXIMUM / scale_factor < *x)\n    {\n      *x = STRTOL_T_MAXIMUM;\n      return LONGINT_OVERFLOW;\n    }\n  *x *= scale_factor;\n  return LONGINT_OK;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "strtol_error"
      ]
    },
    "bkm_scale_by_power": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "static strtol_error\nbkm_scale_by_power (__strtol_t *x, int base, int power)\n{\n  strtol_error err = LONGINT_OK;\n  while (power--)\n    err |= bkm_scale (x, base);\n  return err;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "strtol_error"
      ]
    },
    "__xstrtol": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        240,
        1
      ],
      "content": "strtol_error\n__xstrtol (const char *s, char **ptr, int strtol_base,\n           __strtol_t *val, const char *valid_suffixes)\n{\n  char *t_ptr;\n  char **p;\n  __strtol_t tmp;\n  strtol_error err = LONGINT_OK;\n\n  assert (0 <= strtol_base && strtol_base <= 36);\n\n  p = (ptr ? ptr : &t_ptr);\n\n  if (! TYPE_SIGNED (__strtol_t))\n    {\n      const char *q = s;\n      unsigned char ch = *q;\n      while (isspace (ch))\n        ch = *++q;\n      if (ch == '-')\n        return LONGINT_INVALID;\n    }\n\n  errno = 0;\n  tmp = __strtol (s, p, strtol_base);\n\n  if (*p == s)\n    {\n      /* If there is no number but there is a valid suffix, assume the\n         number is 1.  The string is invalid otherwise.  */\n      if (valid_suffixes && **p && strchr (valid_suffixes, **p))\n        tmp = 1;\n      else\n        return LONGINT_INVALID;\n    }\n  else if (errno != 0)\n    {\n      if (errno != ERANGE)\n        return LONGINT_INVALID;\n      err = LONGINT_OVERFLOW;\n    }\n\n  /* Let valid_suffixes == NULL mean \"allow any suffix\".  */\n  /* FIXME: update all callers except the ones that allow suffixes\n     after the number, changing last parameter NULL to \"\".  */\n  if (!valid_suffixes)\n    {\n      *val = tmp;\n      return err;\n    }\n\n  if (**p != '\\0')\n    {\n      int base = 1024;\n      int suffixes = 1;\n      strtol_error overflow;\n\n      if (!strchr (valid_suffixes, **p))\n        {\n          *val = tmp;\n          return err | LONGINT_INVALID_SUFFIX_CHAR;\n        }\n\n      if (strchr (valid_suffixes, '0'))\n        {\n          /* The \"valid suffix\" '0' is a special flag meaning that\n             an optional second suffix is allowed, which can change\n             the base.  A suffix \"B\" (e.g. \"100MB\") stands for a power\n             of 1000, whereas a suffix \"iB\" (e.g. \"100MiB\") stands for\n             a power of 1024.  If no suffix (e.g. \"100M\"), assume\n             power-of-1024.  */\n\n          switch (p[0][1])\n            {\n            case 'i':\n              if (p[0][2] == 'B')\n                suffixes += 2;\n              break;\n\n            case 'B':\n            case 'D': /* 'D' is obsolescent */\n              base = 1000;\n              suffixes++;\n              break;\n            }\n        }\n\n      switch (**p)\n        {\n        case 'b':\n          overflow = bkm_scale (&tmp, 512);\n          break;\n\n        case 'B':\n          overflow = bkm_scale (&tmp, 1024);\n          break;\n\n        case 'c':\n          overflow = 0;\n          break;\n\n        case 'E': /* exa or exbi */\n          overflow = bkm_scale_by_power (&tmp, base, 6);\n          break;\n\n        case 'G': /* giga or gibi */\n        case 'g': /* 'g' is undocumented; for compatibility only */\n          overflow = bkm_scale_by_power (&tmp, base, 3);\n          break;\n\n        case 'k': /* kilo */\n        case 'K': /* kibi */\n          overflow = bkm_scale_by_power (&tmp, base, 1);\n          break;\n\n        case 'M': /* mega or mebi */\n        case 'm': /* 'm' is undocumented; for compatibility only */\n          overflow = bkm_scale_by_power (&tmp, base, 2);\n          break;\n\n        case 'P': /* peta or pebi */\n          overflow = bkm_scale_by_power (&tmp, base, 5);\n          break;\n\n        case 'T': /* tera or tebi */\n        case 't': /* 't' is undocumented; for compatibility only */\n          overflow = bkm_scale_by_power (&tmp, base, 4);\n          break;\n\n        case 'w':\n          overflow = bkm_scale (&tmp, 2);\n          break;\n\n        case 'Y': /* yotta or 2**80 */\n          overflow = bkm_scale_by_power (&tmp, base, 8);\n          break;\n\n        case 'Z': /* zetta or 2**70 */\n          overflow = bkm_scale_by_power (&tmp, base, 7);\n          break;\n\n        default:\n          *val = tmp;\n          return err | LONGINT_INVALID_SUFFIX_CHAR;\n        }\n\n      err |= overflow;\n      *p += suffixes;\n      if (**p)\n        err |= LONGINT_INVALID_SUFFIX_CHAR;\n    }\n\n  *val = tmp;\n  return err;\n}",
      "lines": 155,
      "depth": 15,
      "decorators": [
        "strtol_error"
      ]
    }
  },
  "cppi/cppi-1.18/lib/xstrtol.h": {},
  "cppi/cppi-1.18/lib/xstrtoul.c": {},
  "cppi/cppi-1.18/src/cpp-cond.c": {
    "hash": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static unsigned int\nhash (register const char *str, register unsigned int len)\n{\n  static const unsigned char asso_values[] =\n    {\n      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,\n      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,\n      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,\n      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,\n      56, 56,  5, 56, 56, 56, 56, 56, 56, 56,\n      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,\n      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,\n      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,\n      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,\n      56, 56, 56, 56, 56, 56, 56,  0, 56, 56,\n       0, 15, 10,  0, 56, 10, 56, 56,  0,  0,\n       5, 56,  0, 56,  0,  0, 56, 56, 56, 56,\n      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,\n      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,\n      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,\n      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,\n      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,\n      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,\n      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,\n      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,\n      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,\n      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,\n      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,\n      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,\n      56, 56, 56, 56, 56, 56, 56, 56, 56, 56,\n      56, 56, 56, 56, 56, 56\n    };\n  register int hval = 0;\n\n  switch (len)\n    {\n      default:\n        hval += asso_values[(unsigned char)str[5]];\n      /*FALLTHROUGH*/\n      case 5:\n        hval += asso_values[(unsigned char)str[4]];\n      /*FALLTHROUGH*/\n      case 4:\n        hval += asso_values[(unsigned char)str[3]];\n      /*FALLTHROUGH*/\n      case 3:\n        hval += asso_values[(unsigned char)str[2]];\n      /*FALLTHROUGH*/\n      case 2:\n        hval += asso_values[(unsigned char)str[1]];\n      /*FALLTHROUGH*/\n      case 1:\n        hval += asso_values[(unsigned char)str[0]];\n        break;\n    }\n  return hval;\n}",
      "lines": 57,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "cpp_cond_lookup": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "static\nconst struct KW *\ncpp_cond_lookup (register const char *str, register unsigned int len)\n{\n  static const struct KW wordlist[] =\n    {\n#line 11 \"src/cpp.gp\"\n      {\"pragma\", EIC_PRAGMA},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 3 \"src/cpp.gp\"\n      {\"**\", EIC_INVALID},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 4 \"src/cpp.gp\"\n      {\"if\", EIC_IF},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 8 \"src/cpp.gp\"\n      {\"else\", EIC_ELSE},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 7 \"src/cpp.gp\"\n      {\"elif\", EIC_ELIF},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 9 \"src/cpp.gp\"\n      {\"endif\", EIC_ENDIF},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 5 \"src/cpp.gp\"\n      {\"ifdef\", EIC_IFDEF},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 6 \"src/cpp.gp\"\n      {\"ifndef\", EIC_IFNDEF},\n      {\"\"}, {\"\"}, {\"\"}, {\"\"},\n#line 10 \"src/cpp.gp\"\n      {\"define\", EIC_DEFINE}\n    };\n\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register int key = hash (str, len);\n\n      if (key <= MAX_HASH_VALUE && key >= 0)\n        {\n          register const char *s = wordlist[key].name;\n\n          if (*str == *s && !strcmp (str + 1, s + 1))\n            return &wordlist[key];\n        }\n    }\n  return 0;\n}",
      "lines": 48,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "struct KW",
        "struct",
        "KW",
        "*\ncpp_cond_lookup (register const char *str, register unsigned int len)",
        "*"
      ]
    }
  },
  "cppi/cppi-1.18/src/cppi.c": {
    "INPUT_AND_ECHO": {
      "start_point": [
        1221,
        0
      ],
      "end_point": [
        1228,
        1
      ],
      "content": "static int\nINPUT_AND_ECHO (void)\n{\n  int _c_ = input ();\n  if (_c_ != EOF && !inhibit_output)\n    fputc (_c_, yyout);\n  return _c_;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "lookup_cpp_keyword": {
      "start_point": [
        1234,
        0
      ],
      "end_point": [
        1257,
        1
      ],
      "content": "static enum Eic_type\nlookup_cpp_keyword (const char *prefix, size_t len, const char **kw)\n{\n  /* Find the beginning of the keyword.  */\n  const char *p;\n  for (p = prefix; ; ++p, --len)\n    {\n      switch (*p)\n        {\n        case '#':\n        case ' ':\n        case '\\t':\n          break;\n\n        default:\n          {\n            struct KW const *ent = cpp_cond_lookup (p, len);\n            *kw = p;\n            return (ent ? ent->code : EIC_OTHER);\n          }\n        }\n      assert (len > 0);\n    }\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "enum Eic_type",
        "enum",
        "Eic_type"
      ]
    },
    "kth_entry": {
      "start_point": [
        1259,
        0
      ],
      "end_point": [
        1265,
        1
      ],
      "content": "static inline struct KL_pair\nkth_entry (unsigned int k)\n{\n  struct KL_pair *s = (struct KL_pair *) obstack_base (&opener_stack);\n  assert (k < OPENER_STACK_HEIGHT);\n  return s[k];\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct KL_pair",
        "struct",
        "KL_pair"
      ]
    },
    "pop": {
      "start_point": [
        1267,
        0
      ],
      "end_point": [
        1273,
        1
      ],
      "content": "static inline void\npop (void)\n{\n  int pair_size = sizeof (struct KL_pair);\n  assert (OPENER_STACK_HEIGHT > 0);\n  obstack_blank (&opener_stack, -pair_size);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "push": {
      "start_point": [
        1275,
        0
      ],
      "end_point": [
        1283,
        1
      ],
      "content": "static inline void\npush (enum Eic_type opener_type, unsigned int line_number)\n{\n  struct KL_pair pair;\n  pair.opener_type = opener_type;\n  pair.line_number = line_number;\n\n  obstack_grow (&opener_stack, &pair, sizeof (struct KL_pair));\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "emit_or_check": {
      "start_point": [
        1285,
        0
      ],
      "end_point": [
        1334,
        1
      ],
      "content": "static int\nemit_or_check (enum Eic_type type, const char *text, const char *other)\n{\n  int fail = 1;\n\n  if (inhibit_output)\n    {\n      int n;\n      int depth = (i_depth < 0 ? 0 : i_depth);\n      if ((text[0] == '#'\n           && (n = strspn (text + 1, \" \")) == depth\n           && !isblank (text[1 + n]))\n          /* This allows pragmas to have exactly one space before the `#'.\n             E.g., ` #pragma alloca' or ` #  pragma alloca' .  */\n          || (text[0] == ' '\n              && text[1] == '#'\n              && type == EIC_PRAGMA\n              && (n = strspn (text + 2, \" \")) == depth - 1\n              && text[n + 2] == 'p'))\n        {\n          fail = 0;\n        }\n    }\n  else\n    {\n      int i;\n      const char *dir = (type == EIC_OTHER ? other : directive[type]);\n      int space_first = (type == EIC_PRAGMA && text[0] == ' ');\n\n      if (space_first)\n        {\n          fputc (' ', yyout);\n          fputc ('#', yyout);\n          for (i = 0; i < i_depth - 1; i++)\n            fputc (' ', yyout);\n        }\n      else\n        {\n          fputc ('#', yyout);\n          for (i = 0; i < i_depth; i++)\n            fputc (' ', yyout);\n        }\n\n      fputs (dir, yyout);\n\n      fail = 0;\n    }\n\n  return fail;\n}",
      "lines": 50,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "emit_indented_cpp": {
      "start_point": [
        1336,
        0
      ],
      "end_point": [
        1426,
        1
      ],
      "content": "static enum Eic_type\nemit_indented_cpp (char const *in_file, unsigned int line_number,\n                   char const *text, size_t len, int *fail)\n{\n  const char *keyword;\n  enum Eic_type t = lookup_cpp_keyword (text, len, &keyword);\n\n  *fail = 0;\n\n  switch (t)\n    {\n    case EIC_IF:\n    case EIC_IFDEF:\n    case EIC_IFNDEF:\n      /* Maintain a stack of (keyword, line number) pairs to better\n         report any `unterminated #if...' errors.  Put a new pair\n         on the stack.  */\n      push (t, line_number);\n\n      *fail = emit_or_check (t, yytext, keyword);\n      ++i_depth;\n      break;\n\n    case EIC_ELSE:\n    case EIC_ELIF:\n      if (i_depth <= initial_i_depth)\n        {\n          if (!list_files_only)\n            {\n              error (0, 0, _(\"%s: line %d: found #%s without matching #if\"),\n                     in_file, line_number, directive[t]);\n            }\n          i_depth = 0;\n          emit_or_check (t, yytext, keyword);\n          *fail = 2;\n        }\n      else\n        {\n          --i_depth;\n          *fail = emit_or_check (t, yytext, keyword);\n          ++i_depth;\n        }\n      break;\n\n    case EIC_ENDIF:\n      if (i_depth <= initial_i_depth)\n        {\n          if (!list_files_only)\n            {\n              error (0, 0, _(\"%s: line %d: found #%s without matching #if\"),\n                     in_file, line_number, directive[t]);\n            }\n          i_depth = initial_i_depth + 1;\n          *fail = 2;\n        }\n      else\n        {\n          /* We've just found an #endif.  Pop off and discard the\n             keyword,line-number pair that's on the top of the stack.\n             That pair identifies the matching #if, #ifdef, or #ifndef.  */\n          pop ();\n        }\n\n      --i_depth;\n      {\n        int tf = emit_or_check (t, yytext, keyword);\n        if (tf > *fail)\n          *fail = tf;\n      }\n      break;\n\n    case EIC_PRAGMA:\n    case EIC_DEFINE:\n    case EIC_OTHER:\n      *fail = emit_or_check (t, yytext, keyword);\n      break;\n\n    case EIC_INVALID:\n    default:\n      abort ();\n    }\n\n  if (*fail == EXIT_NOT_PROPERLY_INDENTED)\n    {\n      if (!list_files_only)\n        error (0, 0, _(\"%s: line %d: not properly indented\"),\n               in_file, line_number);\n    }\n\n  return t;\n}",
      "lines": 91,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "enum Eic_type",
        "enum",
        "Eic_type"
      ]
    },
    "yy_get_next_buffer": {
      "start_point": [
        2077,
        0
      ],
      "end_point": [
        2207,
        1
      ],
      "content": "static int yy_get_next_buffer (void)\n{\n    \tregister char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n\tregister char *source = (yytext_ptr);\n\tregister int number_to_move, i;\n\tint ret_val;\n\n\tif ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;\n\n\telse\n\t\t{\n\t\t\tyy_size_t num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) ((yy_c_buf_p) - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tyy_size_t new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tyyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->yy_ch_buf = 0;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\t(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n\t\t\t(yy_n_chars), num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tif ( (yy_n_chars) == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tyyrestart(yyin  );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\tif ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {\n\t\t/* Extend the array by 50%, plus the number we really need. */\n\t\tyy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );\n\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_get_next_buffer()\" );\n\t}\n\n\t(yy_n_chars) += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n\n\t(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n\n\treturn ret_val;\n}",
      "lines": 131,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yy_get_previous_state": {
      "start_point": [
        2211,
        4
      ],
      "end_point": [
        2230,
        1
      ],
      "content": "static yy_state_type yy_get_previous_state (void)\n{\n\tregister yy_state_type yy_current_state;\n\tregister char *yy_cp;\n    \n\tyy_current_state = (yy_start);\n\tyy_current_state += YY_AT_BOL();\n\n\tfor ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )\n\t\t{\n\t\tif ( *yy_cp )\n\t\t\t{\n\t\t\tyy_current_state = yy_nxt[yy_current_state][YY_SC_TO_UI(*yy_cp)];\n\t\t\t}\n\t\telse\n\t\t\tyy_current_state = yy_NUL_trans[yy_current_state];\n\t\t}\n\n\treturn yy_current_state;\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "yy_state_type"
      ]
    },
    "yy_try_NUL_trans": {
      "start_point": [
        2237,
        4
      ],
      "end_point": [
        2245,
        1
      ],
      "content": "static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )\n{\n\tregister int yy_is_jam;\n    \n\tyy_current_state = yy_NUL_trans[yy_current_state];\n\tyy_is_jam = (yy_current_state == 0);\n\n\t\treturn yy_is_jam ? 0 : yy_current_state;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "yy_state_type"
      ]
    },
    "yyunput": {
      "start_point": [
        2247,
        4
      ],
      "end_point": [
        2282,
        1
      ],
      "content": "static void yyunput (int c, register char * yy_bp )\n{\n\tregister char *yy_cp;\n    \n    yy_cp = (yy_c_buf_p);\n\n\t/* undo effects of setting up yytext */\n\t*yy_cp = (yy_hold_char);\n\n\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n\t\t{ /* need to shift things up to make room */\n\t\t/* +2 for EOB chars. */\n\t\tregister yy_size_t number_to_move = (yy_n_chars) + 2;\n\t\tregister char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[\n\t\t\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];\n\t\tregister char *source =\n\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];\n\n\t\twhile ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\t*--dest = *--source;\n\n\t\tyy_cp += (int) (dest - source);\n\t\tyy_bp += (int) (dest - source);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars =\n\t\t\t(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;\n\n\t\tif ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )\n\t\t\tYY_FATAL_ERROR( \"flex scanner push-back overflow\" );\n\t\t}\n\n\t*--yy_cp = (char) c;\n\n\t(yytext_ptr) = yy_bp;\n\t(yy_hold_char) = *yy_cp;\n\t(yy_c_buf_p) = yy_cp;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "input": {
      "start_point": [
        2288,
        4
      ],
      "end_point": [
        2357,
        1
      ],
      "content": "static int input  (void)\n#endif\n\n{\n\tint c;\n    \n\t*(yy_c_buf_p) = (yy_hold_char);\n\n\tif ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )\n\t\t{\n\t\t/* yy_c_buf_p now points to the character we want to return.\n\t\t * If this occurs *before* the EOB characters, then it's a\n\t\t * valid NUL; if not, then we've hit the end of the buffer.\n\t\t */\n\t\tif ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )\n\t\t\t/* This was really a NUL. */\n\t\t\t*(yy_c_buf_p) = '\\0';\n\n\t\telse\n\t\t\t{ /* need more input */\n\t\t\tyy_size_t offset = (yy_c_buf_p) - (yytext_ptr);\n\t\t\t++(yy_c_buf_p);\n\n\t\t\tswitch ( yy_get_next_buffer(  ) )\n\t\t\t\t{\n\t\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\t\t/* This happens because yy_g_n_b()\n\t\t\t\t\t * sees that we've accumulated a\n\t\t\t\t\t * token and flags that we need to\n\t\t\t\t\t * try matching the token before\n\t\t\t\t\t * proceeding.  But for input(),\n\t\t\t\t\t * there's no matching to consider.\n\t\t\t\t\t * So convert the EOB_ACT_LAST_MATCH\n\t\t\t\t\t * to EOB_ACT_END_OF_FILE.\n\t\t\t\t\t */\n\n\t\t\t\t\t/* Reset buffer status. */\n\t\t\t\t\tyyrestart(yyin );\n\n\t\t\t\t\t/*FALLTHROUGH*/\n\n\t\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t\t{\n\t\t\t\t\tif ( yywrap( ) )\n\t\t\t\t\t\treturn EOF;\n\n\t\t\t\t\tif ( ! (yy_did_buffer_switch_on_eof) )\n\t\t\t\t\t\tYY_NEW_FILE;\n#ifdef __cplusplus\n\t\t\t\t\treturn yyinput();\n#else\n\t\t\t\t\treturn input();\n#endif\n\t\t\t\t\t}\n\n\t\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\t\t(yy_c_buf_p) = (yytext_ptr) + offset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tc = *(unsigned char *) (yy_c_buf_p);\t/* cast for 8-bit char's */\n\t*(yy_c_buf_p) = '\\0';\t/* preserve yytext */\n\t(yy_hold_char) = *++(yy_c_buf_p);\n\n\tYY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\\n');\n\n\treturn c;\n}",
      "lines": 70,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yyrestart": {
      "start_point": [
        2365,
        4
      ],
      "end_point": [
        2376,
        1
      ],
      "content": "void yyrestart  (FILE * input_file )\n{\n    \n\tif ( ! YY_CURRENT_BUFFER ){\n        yyensure_buffer_stack ();\n\t\tYY_CURRENT_BUFFER_LVALUE =\n            yy_create_buffer(yyin,YY_BUF_SIZE );\n\t}\n\n\tyy_init_buffer(YY_CURRENT_BUFFER,input_file );\n\tyy_load_buffer_state( );\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "yy_switch_to_buffer": {
      "start_point": [
        2382,
        4
      ],
      "end_point": [
        2411,
        1
      ],
      "content": "void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )\n{\n    \n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tyypop_buffer_state();\n\t *\t\tyypush_buffer_state(new_buffer);\n     */\n\tyyensure_buffer_stack ();\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tyy_load_buffer_state( );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (yywrap()) processing, but the only time this flag\n\t * is looked at is after yywrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\t(yy_did_buffer_switch_on_eof) = 1;\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "yy_load_buffer_state": {
      "start_point": [
        2413,
        0
      ],
      "end_point": [
        2419,
        1
      ],
      "content": "static void yy_load_buffer_state  (void)\n{\n    \t(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n\t(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;\n\tyyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;\n\t(yy_hold_char) = *(yy_c_buf_p);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_create_buffer": {
      "start_point": [
        2427,
        4
      ],
      "end_point": [
        2449,
        1
      ],
      "content": "YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )\n{\n\tYY_BUFFER_STATE b;\n    \n\tb = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n\n\tb->yy_buf_size = size;\n\n\t/* yy_ch_buf has to be 2 characters longer than the size given because\n\t * we need to put in 2 end-of-buffer characters.\n\t */\n\tb->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );\n\tif ( ! b->yy_ch_buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );\n\n\tb->yy_is_our_buffer = 1;\n\n\tyy_init_buffer(b,file );\n\n\treturn b;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_delete_buffer": {
      "start_point": [
        2455,
        4
      ],
      "end_point": [
        2468,
        1
      ],
      "content": "void yy_delete_buffer (YY_BUFFER_STATE  b )\n{\n    \n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n\n\tif ( b->yy_is_our_buffer )\n\t\tyyfree((void *) b->yy_ch_buf  );\n\n\tyyfree((void *) b  );\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "yy_init_buffer": {
      "start_point": [
        2474,
        4
      ],
      "end_point": [
        2496,
        1
      ],
      "content": "static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )\n\n{\n\tint oerrno = errno;\n    \n\tyy_flush_buffer(b );\n\n\tb->yy_input_file = file;\n\tb->yy_fill_buffer = 1;\n\n    /* If b is the current buffer, then yy_init_buffer was _probably_\n     * called from yyrestart() or through yy_get_next_buffer.\n     * In that case, we don't want to reset the lineno or column.\n     */\n    if (b != YY_CURRENT_BUFFER){\n        b->yy_bs_lineno = 1;\n        b->yy_bs_column = 0;\n    }\n\n        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\n    \n\terrno = oerrno;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_flush_buffer": {
      "start_point": [
        2502,
        4
      ],
      "end_point": [
        2523,
        1
      ],
      "content": "void yy_flush_buffer (YY_BUFFER_STATE  b )\n{\n    \tif ( ! b )\n\t\treturn;\n\n\tb->yy_n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->yy_buf_pos = &b->yy_ch_buf[0];\n\n\tb->yy_at_bol = 1;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == YY_CURRENT_BUFFER )\n\t\tyy_load_buffer_state( );\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "yypush_buffer_state": {
      "start_point": [
        2531,
        0
      ],
      "end_point": [
        2555,
        1
      ],
      "content": "void yypush_buffer_state (YY_BUFFER_STATE new_buffer )\n{\n    \tif (new_buffer == NULL)\n\t\treturn;\n\n\tyyensure_buffer_stack();\n\n\t/* This block is copied from yy_switch_to_buffer. */\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(yy_c_buf_p) = (yy_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);\n\t\t}\n\n\t/* Only push if top exists. Otherwise, replace top. */\n\tif (YY_CURRENT_BUFFER)\n\t\t(yy_buffer_stack_top)++;\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\n\t/* copied from yy_switch_to_buffer. */\n\tyy_load_buffer_state( );\n\t(yy_did_buffer_switch_on_eof) = 1;\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "yypop_buffer_state": {
      "start_point": [
        2561,
        0
      ],
      "end_point": [
        2575,
        1
      ],
      "content": "void yypop_buffer_state (void)\n{\n    \tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tyy_delete_buffer(YY_CURRENT_BUFFER );\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif ((yy_buffer_stack_top) > 0)\n\t\t--(yy_buffer_stack_top);\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tyy_load_buffer_state( );\n\t\t(yy_did_buffer_switch_on_eof) = 1;\n\t}\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "yyensure_buffer_stack": {
      "start_point": [
        2580,
        0
      ],
      "end_point": [
        2621,
        1
      ],
      "content": "static void yyensure_buffer_stack (void)\n{\n\tyy_size_t num_to_alloc;\n    \n\tif (!(yy_buffer_stack)) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n\t\tnum_to_alloc = 1;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (yy_buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n\t\t\t\t\t\t\t\t  \n\t\tmemset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\t\t\t\t\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t\t(yy_buffer_stack_top) = 0;\n\t\treturn;\n\t}\n\n\tif ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tint grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = (yy_buffer_stack_max) + grow_size;\n\t\t(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc\n\t\t\t\t\t\t\t\t((yy_buffer_stack),\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (yy_buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );\n\n\t\t/* zero only the new slots.*/\n\t\tmemset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\t(yy_buffer_stack_max) = num_to_alloc;\n\t}\n}",
      "lines": 42,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_scan_buffer": {
      "start_point": [
        2629,
        0
      ],
      "end_point": [
        2656,
        1
      ],
      "content": "YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )\n{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn 0;\n\n\tb = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );\n\n\tb->yy_buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = 0;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tyy_switch_to_buffer(b  );\n\n\treturn b;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_scan_string": {
      "start_point": [
        2666,
        0
      ],
      "end_point": [
        2670,
        1
      ],
      "content": "YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )\n{\n    \n\treturn yy_scan_bytes(yystr,strlen(yystr) );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_scan_bytes": {
      "start_point": [
        2679,
        0
      ],
      "end_point": [
        2707,
        1
      ],
      "content": "YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )\n{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n;\n\tint i;\n    \n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = _yybytes_len + 2;\n\tbuf = (char *) yyalloc(n  );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_bytes()\" );\n\n\tfor ( i = 0; i < _yybytes_len; ++i )\n\t\tbuf[i] = yybytes[i];\n\n\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = yy_scan_buffer(buf,n );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in yy_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n}",
      "lines": 29,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_fatal_error": {
      "start_point": [
        2713,
        0
      ],
      "end_point": [
        2717,
        1
      ],
      "content": "static void yy_fatal_error (yyconst char* msg )\n{\n    \t(void) fprintf( stderr, \"%s\\n\", msg );\n\texit( YY_EXIT_FAILURE );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yyget_lineno": {
      "start_point": [
        2741,
        0
      ],
      "end_point": [
        2745,
        1
      ],
      "content": "int yyget_lineno  (void)\n{\n        \n    return yylineno;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "yyget_in": {
      "start_point": [
        2750,
        0
      ],
      "end_point": [
        2753,
        1
      ],
      "content": "FILE *yyget_in  (void)\n{\n        return yyin;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*yyget_in  (void)",
        "*"
      ]
    },
    "yyget_out": {
      "start_point": [
        2758,
        0
      ],
      "end_point": [
        2761,
        1
      ],
      "content": "FILE *yyget_out  (void)\n{\n        return yyout;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*yyget_out  (void)",
        "*"
      ]
    },
    "yyget_leng": {
      "start_point": [
        2766,
        0
      ],
      "end_point": [
        2769,
        1
      ],
      "content": "yy_size_t yyget_leng  (void)\n{\n        return yyleng;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "yy_size_t"
      ]
    },
    "yyget_text": {
      "start_point": [
        2775,
        0
      ],
      "end_point": [
        2778,
        1
      ],
      "content": "char *yyget_text  (void)\n{\n        return yytext;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "char",
        "*yyget_text  (void)",
        "*"
      ]
    },
    "yyset_lineno": {
      "start_point": [
        2784,
        0
      ],
      "end_point": [
        2788,
        1
      ],
      "content": "void yyset_lineno (int  line_number )\n{\n    \n    yylineno = line_number;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "yyset_in": {
      "start_point": [
        2796,
        0
      ],
      "end_point": [
        2799,
        1
      ],
      "content": "void yyset_in (FILE *  in_str )\n{\n        yyin = in_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "yyset_out": {
      "start_point": [
        2801,
        0
      ],
      "end_point": [
        2804,
        1
      ],
      "content": "void yyset_out (FILE *  out_str )\n{\n        yyout = out_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "yyget_debug": {
      "start_point": [
        2806,
        0
      ],
      "end_point": [
        2809,
        1
      ],
      "content": "int yyget_debug  (void)\n{\n        return yy_flex_debug;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "yyset_debug": {
      "start_point": [
        2811,
        0
      ],
      "end_point": [
        2814,
        1
      ],
      "content": "void yyset_debug (int  bdebug )\n{\n        yy_flex_debug = bdebug ;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "yy_init_globals": {
      "start_point": [
        2816,
        0
      ],
      "end_point": [
        2842,
        1
      ],
      "content": "static int yy_init_globals (void)\n{\n        /* Initialization is the same as for the non-reentrant scanner.\n     * This function is called from yylex_destroy(), so don't allocate here.\n     */\n\n    (yy_buffer_stack) = 0;\n    (yy_buffer_stack_top) = 0;\n    (yy_buffer_stack_max) = 0;\n    (yy_c_buf_p) = (char *) 0;\n    (yy_init) = 0;\n    (yy_start) = 0;\n\n/* Defined in main.c */\n#ifdef YY_STDINIT\n    yyin = stdin;\n    yyout = stdout;\n#else\n    yyin = (FILE *) 0;\n    yyout = (FILE *) 0;\n#endif\n\n    /* For future reference: Set errno on error, since we are called by\n     * yylex_init()\n     */\n    return 0;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yylex_destroy": {
      "start_point": [
        2845,
        0
      ],
      "end_point": [
        2864,
        1
      ],
      "content": "int yylex_destroy  (void)\n{\n    \n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\tyy_delete_buffer(YY_CURRENT_BUFFER  );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\tyypop_buffer_state();\n\t}\n\n\t/* Destroy the stack itself. */\n\tyyfree((yy_buffer_stack) );\n\t(yy_buffer_stack) = NULL;\n\n    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n     * yylex() is called, initialization will occur. */\n    yy_init_globals( );\n\n    return 0;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "yy_flex_strncpy": {
      "start_point": [
        2871,
        0
      ],
      "end_point": [
        2876,
        1
      ],
      "content": "static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )\n{\n\tregister int i;\n\tfor ( i = 0; i < n; ++i )\n\t\ts1[i] = s2[i];\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_flex_strlen": {
      "start_point": [
        2880,
        0
      ],
      "end_point": [
        2887,
        1
      ],
      "content": "static int yy_flex_strlen (yyconst char * s )\n{\n\tregister int n;\n\tfor ( n = 0; s[n]; ++n )\n\t\t;\n\n\treturn n;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yyalloc": {
      "start_point": [
        2890,
        0
      ],
      "end_point": [
        2893,
        1
      ],
      "content": "void *yyalloc (yy_size_t  size )\n{\n\treturn (void *) malloc( size );\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void",
        "*yyalloc (yy_size_t  size )",
        "*"
      ]
    },
    "yyrealloc": {
      "start_point": [
        2895,
        0
      ],
      "end_point": [
        2905,
        1
      ],
      "content": "void *yyrealloc  (void * ptr, yy_size_t  size )\n{\n\t/* The cast to (char *) in the following accommodates both\n\t * implementations that use char* generic pointers, and those\n\t * that use void* generic pointers.  It works with the latter\n\t * because both ANSI C and C++ allow castless assignment from\n\t * any pointer type to void*, and deal with argument conversions\n\t * as though doing an assignment.\n\t */\n\treturn (void *) realloc( (char *) ptr, size );\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void",
        "*yyrealloc  (void * ptr, yy_size_t  size )",
        "*"
      ]
    },
    "yyfree": {
      "start_point": [
        2907,
        0
      ],
      "end_point": [
        2910,
        1
      ],
      "content": "void yyfree (void * ptr )\n{\n\tfree( (char *) ptr );\t/* see yyrealloc() for (char *) cast */\n}",
      "lines": 4,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "cpp_indent": {
      "start_point": [
        2918,
        0
      ],
      "end_point": [
        2946,
        1
      ],
      "content": "static int\ncpp_indent (const char *in_file)\n{\n  FILE *in = NULL;\n  int fail;\n\n  if (STREQ (in_file, \"-\"))\n    {\n      yyin = stdin;\n      in_file = \"standard input\";\n    }\n  else\n    {\n      if ((in = fopen (in_file, \"r\")) == NULL)\n        {\n          error (EXIT_FILE_ERROR, errno, \"%s\", in_file);\n        }\n      yyin = in;\n    }\n\n  fail = cpp_i (in_file);\n\n  obstack_free (&opener_stack, NULL);\n\n  if (in && fclose (in) == EOF)\n    error (EXIT_FILE_ERROR, errno, \"%s\", in_file);\n\n  return fail;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "usage": {
      "start_point": [
        2949,
        0
      ],
      "end_point": [
        3017,
        1
      ],
      "content": "static void\nusage (int status)\n{\n  if (status != 0)\n    {\n      fprintf (stderr, \"Try `%s --help' for more information.\\n\",\n               program_name);\n    }\n  else\n    {\n      printf (_(\"\\\nUsage: %s [FILE]\\n\\\n  or:  %s -c [OPTION] [FILE]...\\n\\\n\"), program_name, program_name);\n      fputs (_(\"\\\n\\n\\\nIndent the C preprocessor directives in FILE to reflect their nesting\\n\\\nand ensure that there is exactly one space character between each #if,\\n\\\n#elif, #define directive and the following token, and write the result\\n\\\n\"), stdout);\n      fputs (_(\"\\\nto standard output.  The number of spaces between the `#' and the following\\n\\\ndirective must correspond to the level of nesting of that directive.\\n\\\nWith no FILE, or when FILE is -, read standard input.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\n  -a, --ansi             when checking, fail if text follows #else or #endif\\n\\\n  -c, --check            set exit code, but don't produce any output\\n\\\n  -l, --list-files-only  don't generate diagnostics about indentation;\\n\\\n                         print to stdout only the names of files that\\n\\\n                         are not properly indented\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -m, --max-string-length=LENGTH\\n\\\n                         fail if there is a double-quoted string longer\\n\\\n                         than LENGTH;  if LENGTH is 0 (the default),\\n\\\n                         then there is no limit\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\n\\\nWith the -c option, don't write to stdout.  Instead, check the\\n\\\nindentation of the specified files giving diagnostics for preprocessor\\n\\\nlines that aren't properly indented or are otherwise invalid.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nNote that --ansi without --check does not correct the problem of\\n\\\nnon-ANSI text following #else and #endif directives.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nThe exit code will be one of these:\\n\\\n  0  all directives properly indented\\n\\\n  1  some cpp directive(s) improperly indented, or\\n\\\n     text follows #else/#endif (enabled with --check --ansi), or\\n\\\n     a double-quoted string is longer than the specified maximum\\n\\\n  2  #if/#endif mismatch, EOF in comment or string\\n\\\n  3  file (e.g. open/read/write) error\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nA pragma directive may have its `#' indented.\\n\\\n\"), stdout);\n      printf (_(\"\\nReport bugs to <%s>.\\n\"), PACKAGE_BUGREPORT);\n    }\n  exit (status == 0 ? EXIT_SUCCESS : EXIT_FAILURE);\n}",
      "lines": 69,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gobble_define": {
      "start_point": [
        3024,
        0
      ],
      "end_point": [
        3043,
        1
      ],
      "content": "static void\ngobble_define (unsigned int *line_number)\n{\n  int c;\n  int backslash_count = 0;\n  while ((c = INPUT_AND_ECHO ()) != EOF)\n    {\n      if (c == '\\n')\n        {\n          ++(*line_number);\n          if (backslash_count % 2 == 0)\n            break;\n        }\n\n      if (c == '\\\\')\n        ++backslash_count;\n      else\n        backslash_count = 0;\n    }\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gobble_c_comment": {
      "start_point": [
        3048,
        0
      ],
      "end_point": [
        3078,
        1
      ],
      "content": "static void\ngobble_c_comment (const char *in_file, unsigned int *line_number)\n{\n  int start_lineno = *line_number;\n  for ( ; ; )\n    {\n      int c;\n      while ((c = INPUT_AND_ECHO ()) != '*' && c != EOF)\n        {\n          if (c == '\\n')\n            ++(*line_number);\n        }\n\n      if (c == '*')\n        {\n          while ((c = INPUT_AND_ECHO ()) == '*')\n            ;\n          if (c == '/')\n            break;    /* found the end */\n          if (c == '\\n')\n            ++(*line_number);\n        }\n\n      if (c == EOF)\n        {\n          error (EXIT_LEX_ERROR, 0, _(\"%s: line %d: EOF in comment\"),\n                 in_file, start_lineno);\n          break;\n        }\n    }\n}",
      "lines": 31,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gobble_line": {
      "start_point": [
        3082,
        0
      ],
      "end_point": [
        3094,
        1
      ],
      "content": "static void\ngobble_line (unsigned int *line_number)\n{\n  int c;\n  while ((c = INPUT_AND_ECHO ()) != EOF)\n    {\n      if (c == '\\n')\n        {\n          ++(*line_number);\n          break;\n        }\n    }\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        3096,
        0
      ],
      "end_point": [
        3176,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int i;\n  int max_err;\n  char **file_list;\n  int c;\n  int fail = 0;\n\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  while ((c = getopt_long (argc, argv, \"aclm:\", long_options, NULL)) != -1)\n    {\n      switch (c)\n        {\n        case 0:\n          break;\n\n        case 'a':\n          ansi_check = 1;\n          break;\n\n        case 'c':\n          inhibit_output = 1;\n          break;\n\n        case 'l':\n          inhibit_output = 1;\n          list_files_only = 1;\n          break;\n\n        case 'm':\n          if (xstrtoul (optarg, NULL, 0, &max_string_length, NULL)\n              != LONGINT_OK)\n            {\n              error (0, 0, _(\"invalid maximum string length %s\"), optarg);\n              fail = 1;\n            }\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_LEX_ERROR);\n          break;\n        }\n    }\n\n  if (fail)\n    exit (EXIT_FAILURE);\n\n  if (!inhibit_output && argc - optind > 2)\n    {\n      error (0, 0, _(\"too many arguments\"));\n      usage (EXIT_FAILURE);\n    }\n\n  file_list = (optind == argc ? default_file_list : argv + optind);\n\n  max_err = 0;\n  for (i = 0; file_list[i]; i++)\n    {\n      int err;\n\n      err = cpp_indent (file_list[i]);\n      if (err > max_err)\n        max_err = err;\n\n      if (err && list_files_only)\n        puts (file_list[i]);\n    }\n\n  exit (max_err);\n}",
      "lines": 81,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "cppi/cppi-1.18/src/cppi.l": {
    "noyywrap": {
      "start_point": [
        16,
        1
      ],
      "end_point": [
        22,
        1
      ],
      "content": "option noyywrap\n%top{\n/* config.h must precede flex's inclusion of <stdio.h>\n   in order for its _GNU_SOURCE definition to take effect.  */\n#include \"config.h\"\n#include \"system.h\"\n}",
      "lines": 7,
      "depth": 5,
      "decorators": null
    },
    "INPUT_AND_ECHO": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "static int\nINPUT_AND_ECHO (void)\n{\n  int _c_ = input ();\n  if (_c_ != EOF && !inhibit_output)\n    fputc (_c_, yyout);\n  return _c_;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "lookup_cpp_keyword": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "static enum Eic_type\nlookup_cpp_keyword (const char *prefix, size_t len, const char **kw)\n{\n  /* Find the beginning of the keyword.  */\n  const char *p;\n  for (p = prefix; ; ++p, --len)\n    {\n      switch (*p)\n        {\n        case '#':\n        case ' ':\n        case '\\t':\n          break;\n\n        default:\n          {\n            struct KW const *ent = cpp_cond_lookup (p, len);\n            *kw = p;\n            return (ent ? ent->code : EIC_OTHER);\n          }\n        }\n      assert (len > 0);\n    }\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "enum Eic_type",
        "enum",
        "Eic_type"
      ]
    },
    "kth_entry": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        202,
        1
      ],
      "content": "static inline struct KL_pair\nkth_entry (unsigned int k)\n{\n  struct KL_pair *s = (struct KL_pair *) obstack_base (&opener_stack);\n  assert (k < OPENER_STACK_HEIGHT);\n  return s[k];\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "struct KL_pair",
        "struct",
        "KL_pair"
      ]
    },
    "pop": {
      "start_point": [
        204,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "static inline void\npop (void)\n{\n  int pair_size = sizeof (struct KL_pair);\n  assert (OPENER_STACK_HEIGHT > 0);\n  obstack_blank (&opener_stack, -pair_size);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "push": {
      "start_point": [
        212,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "static inline void\npush (enum Eic_type opener_type, unsigned int line_number)\n{\n  struct KL_pair pair;\n  pair.opener_type = opener_type;\n  pair.line_number = line_number;\n\n  obstack_grow (&opener_stack, &pair, sizeof (struct KL_pair));\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "emit_or_check": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "static int\nemit_or_check (enum Eic_type type, const char *text, const char *other)\n{\n  int fail = 1;\n\n  if (inhibit_output)\n    {\n      int n;\n      int depth = (i_depth < 0 ? 0 : i_depth);\n      if ((text[0] == '#'\n           && (n = strspn (text + 1, \" \")) == depth\n           && !isblank (text[1 + n]))\n          /* This allows pragmas to have exactly one space before the `#'.\n             E.g., ` #pragma alloca' or ` #  pragma alloca' .  */\n          || (text[0] == ' '\n              && text[1] == '#'\n              && type == EIC_PRAGMA\n              && (n = strspn (text + 2, \" \")) == depth - 1\n              && text[n + 2] == 'p'))\n        {\n          fail = 0;\n        }\n    }\n  else\n    {\n      int i;\n      const char *dir = (type == EIC_OTHER ? other : directive[type]);\n      int space_first = (type == EIC_PRAGMA && text[0] == ' ');\n\n      if (space_first)\n        {\n          fputc (' ', yyout);\n          fputc ('#', yyout);\n          for (i = 0; i < i_depth - 1; i++)\n            fputc (' ', yyout);\n        }\n      else\n        {\n          fputc ('#', yyout);\n          for (i = 0; i < i_depth; i++)\n            fputc (' ', yyout);\n        }\n\n      fputs (dir, yyout);\n\n      fail = 0;\n    }\n\n  return fail;\n}",
      "lines": 50,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "emit_indented_cpp": {
      "start_point": [
        273,
        0
      ],
      "end_point": [
        363,
        1
      ],
      "content": "static enum Eic_type\nemit_indented_cpp (char const *in_file, unsigned int line_number,\n                   char const *text, size_t len, int *fail)\n{\n  const char *keyword;\n  enum Eic_type t = lookup_cpp_keyword (text, len, &keyword);\n\n  *fail = 0;\n\n  switch (t)\n    {\n    case EIC_IF:\n    case EIC_IFDEF:\n    case EIC_IFNDEF:\n      /* Maintain a stack of (keyword, line number) pairs to better\n         report any `unterminated #if...' errors.  Put a new pair\n         on the stack.  */\n      push (t, line_number);\n\n      *fail = emit_or_check (t, yytext, keyword);\n      ++i_depth;\n      break;\n\n    case EIC_ELSE:\n    case EIC_ELIF:\n      if (i_depth <= initial_i_depth)\n        {\n          if (!list_files_only)\n            {\n              error (0, 0, _(\"%s: line %d: found #%s without matching #if\"),\n                     in_file, line_number, directive[t]);\n            }\n          i_depth = 0;\n          emit_or_check (t, yytext, keyword);\n          *fail = 2;\n        }\n      else\n        {\n          --i_depth;\n          *fail = emit_or_check (t, yytext, keyword);\n          ++i_depth;\n        }\n      break;\n\n    case EIC_ENDIF:\n      if (i_depth <= initial_i_depth)\n        {\n          if (!list_files_only)\n            {\n              error (0, 0, _(\"%s: line %d: found #%s without matching #if\"),\n                     in_file, line_number, directive[t]);\n            }\n          i_depth = initial_i_depth + 1;\n          *fail = 2;\n        }\n      else\n        {\n          /* We've just found an #endif.  Pop off and discard the\n             keyword,line-number pair that's on the top of the stack.\n             That pair identifies the matching #if, #ifdef, or #ifndef.  */\n          pop ();\n        }\n\n      --i_depth;\n      {\n        int tf = emit_or_check (t, yytext, keyword);\n        if (tf > *fail)\n          *fail = tf;\n      }\n      break;\n\n    case EIC_PRAGMA:\n    case EIC_DEFINE:\n    case EIC_OTHER:\n      *fail = emit_or_check (t, yytext, keyword);\n      break;\n\n    case EIC_INVALID:\n    default:\n      abort ();\n    }\n\n  if (*fail == EXIT_NOT_PROPERLY_INDENTED)\n    {\n      if (!list_files_only)\n        error (0, 0, _(\"%s: line %d: not properly indented\"),\n               in_file, line_number);\n    }\n\n  return t;\n}",
      "lines": 91,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "enum Eic_type",
        "enum",
        "Eic_type"
      ]
    },
    "cpp_indent": {
      "start_point": [
        601,
        0
      ],
      "end_point": [
        629,
        1
      ],
      "content": "static int\ncpp_indent (const char *in_file)\n{\n  FILE *in = NULL;\n  int fail;\n\n  if (STREQ (in_file, \"-\"))\n    {\n      yyin = stdin;\n      in_file = \"standard input\";\n    }\n  else\n    {\n      if ((in = fopen (in_file, \"r\")) == NULL)\n        {\n          error (EXIT_FILE_ERROR, errno, \"%s\", in_file);\n        }\n      yyin = in;\n    }\n\n  fail = cpp_i (in_file);\n\n  obstack_free (&opener_stack, NULL);\n\n  if (in && fclose (in) == EOF)\n    error (EXIT_FILE_ERROR, errno, \"%s\", in_file);\n\n  return fail;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "usage": {
      "start_point": [
        632,
        0
      ],
      "end_point": [
        700,
        1
      ],
      "content": "static void\nusage (int status)\n{\n  if (status != 0)\n    {\n      fprintf (stderr, \"Try `%s --help' for more information.\\n\",\n               program_name);\n    }\n  else\n    {\n      printf (_(\"\\\nUsage: %s [FILE]\\n\\\n  or:  %s -c [OPTION] [FILE]...\\n\\\n\"), program_name, program_name);\n      fputs (_(\"\\\n\\n\\\nIndent the C preprocessor directives in FILE to reflect their nesting\\n\\\nand ensure that there is exactly one space character between each #if,\\n\\\n#elif, #define directive and the following token, and write the result\\n\\\n\"), stdout);\n      fputs (_(\"\\\nto standard output.  The number of spaces between the `#' and the following\\n\\\ndirective must correspond to the level of nesting of that directive.\\n\\\nWith no FILE, or when FILE is -, read standard input.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\n  -a, --ansi             when checking, fail if text follows #else or #endif\\n\\\n  -c, --check            set exit code, but don't produce any output\\n\\\n  -l, --list-files-only  don't generate diagnostics about indentation;\\n\\\n                         print to stdout only the names of files that\\n\\\n                         are not properly indented\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -m, --max-string-length=LENGTH\\n\\\n                         fail if there is a double-quoted string longer\\n\\\n                         than LENGTH;  if LENGTH is 0 (the default),\\n\\\n                         then there is no limit\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\n\\\nWith the -c option, don't write to stdout.  Instead, check the\\n\\\nindentation of the specified files giving diagnostics for preprocessor\\n\\\nlines that aren't properly indented or are otherwise invalid.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nNote that --ansi without --check does not correct the problem of\\n\\\nnon-ANSI text following #else and #endif directives.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nThe exit code will be one of these:\\n\\\n  0  all directives properly indented\\n\\\n  1  some cpp directive(s) improperly indented, or\\n\\\n     text follows #else/#endif (enabled with --check --ansi), or\\n\\\n     a double-quoted string is longer than the specified maximum\\n\\\n  2  #if/#endif mismatch, EOF in comment or string\\n\\\n  3  file (e.g. open/read/write) error\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nA pragma directive may have its `#' indented.\\n\\\n\"), stdout);\n      printf (_(\"\\nReport bugs to <%s>.\\n\"), PACKAGE_BUGREPORT);\n    }\n  exit (status == 0 ? EXIT_SUCCESS : EXIT_FAILURE);\n}",
      "lines": 69,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gobble_define": {
      "start_point": [
        707,
        0
      ],
      "end_point": [
        726,
        1
      ],
      "content": "static void\ngobble_define (unsigned int *line_number)\n{\n  int c;\n  int backslash_count = 0;\n  while ((c = INPUT_AND_ECHO ()) != EOF)\n    {\n      if (c == '\\n')\n        {\n          ++(*line_number);\n          if (backslash_count % 2 == 0)\n            break;\n        }\n\n      if (c == '\\\\')\n        ++backslash_count;\n      else\n        backslash_count = 0;\n    }\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gobble_c_comment": {
      "start_point": [
        731,
        0
      ],
      "end_point": [
        761,
        1
      ],
      "content": "static void\ngobble_c_comment (const char *in_file, unsigned int *line_number)\n{\n  int start_lineno = *line_number;\n  for ( ; ; )\n    {\n      int c;\n      while ((c = INPUT_AND_ECHO ()) != '*' && c != EOF)\n        {\n          if (c == '\\n')\n            ++(*line_number);\n        }\n\n      if (c == '*')\n        {\n          while ((c = INPUT_AND_ECHO ()) == '*')\n            ;\n          if (c == '/')\n            break;    /* found the end */\n          if (c == '\\n')\n            ++(*line_number);\n        }\n\n      if (c == EOF)\n        {\n          error (EXIT_LEX_ERROR, 0, _(\"%s: line %d: EOF in comment\"),\n                 in_file, start_lineno);\n          break;\n        }\n    }\n}",
      "lines": 31,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gobble_line": {
      "start_point": [
        765,
        0
      ],
      "end_point": [
        777,
        1
      ],
      "content": "static void\ngobble_line (unsigned int *line_number)\n{\n  int c;\n  while ((c = INPUT_AND_ECHO ()) != EOF)\n    {\n      if (c == '\\n')\n        {\n          ++(*line_number);\n          break;\n        }\n    }\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        779,
        0
      ],
      "end_point": [
        859,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int i;\n  int max_err;\n  char **file_list;\n  int c;\n  int fail = 0;\n\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  while ((c = getopt_long (argc, argv, \"aclm:\", long_options, NULL)) != -1)\n    {\n      switch (c)\n        {\n        case 0:\n          break;\n\n        case 'a':\n          ansi_check = 1;\n          break;\n\n        case 'c':\n          inhibit_output = 1;\n          break;\n\n        case 'l':\n          inhibit_output = 1;\n          list_files_only = 1;\n          break;\n\n        case 'm':\n          if (xstrtoul (optarg, NULL, 0, &max_string_length, NULL)\n              != LONGINT_OK)\n            {\n              error (0, 0, _(\"invalid maximum string length %s\"), optarg);\n              fail = 1;\n            }\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_LEX_ERROR);\n          break;\n        }\n    }\n\n  if (fail)\n    exit (EXIT_FAILURE);\n\n  if (!inhibit_output && argc - optind > 2)\n    {\n      error (0, 0, _(\"too many arguments\"));\n      usage (EXIT_FAILURE);\n    }\n\n  file_list = (optind == argc ? default_file_list : argv + optind);\n\n  max_err = 0;\n  for (i = 0; file_list[i]; i++)\n    {\n      int err;\n\n      err = cpp_indent (file_list[i]);\n      if (err > max_err)\n        max_err = err;\n\n      if (err && list_files_only)\n        puts (file_list[i]);\n    }\n\n  exit (max_err);\n}",
      "lines": 81,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "cppi/cppi-1.18/src/system.h": {
    "to_uchar": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        77,
        61
      ],
      "content": "static inline unsigned char to_uchar (char ch) { return ch; }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "unsigned char",
        "unsigned",
        "char"
      ]
    }
  }
}